GS_MASK          0x000F0000

//
// Entry flags
//

#define WAVEBANKENTRY_FLAGS_READAHEAD       0x00000001  // Enable stream read-ahead
#define WAVEBANKENTRY_FLAGS_LOOPCACHE       0x00000002  // One or more looping sounds use this wave
#define WAVEBANKENTRY_FLAGS_REMOVELOOPTAIL  0x00000004  // Remove data after the end of the loop region
#define WAVEBANKENTRY_FLAGS_IGNORELOOP      0x00000008  // Used internally when the loop region can't be used
#define WAVEBANKENTRY_FLAGS_MASK            0x00000008

//
// Entry wave format identifiers
//

#define WAVEBANKMINIFORMAT_TAG_PCM      0x0     // PCM data
#define WAVEBANKMINIFORMAT_TAG_XMA      0x1     // XMA data
#define WAVEBANKMINIFORMAT_TAG_ADPCM    0x2     // ADPCM data

#define WAVEBANKMINIFORMAT_BITDEPTH_8   0x0     // 8-bit data (PCM only)
#define WAVEBANKMINIFORMAT_BITDEPTH_16  0x1     // 16-bit data (PCM only)

//
// Arbitrary fixed sizes
//
#define WAVEBANKENTRY_XMASTREAMS_MAX          3   // enough for 5.1 channel audio
#define WAVEBANKENTRY_XMACHANNELS_MAX         6   // enough for 5.1 channel audio (cf. XAUDIOCHANNEL_SOURCEMAX)

//
// DVD data sizes
//

#define WAVEBANK_DVD_SECTOR_SIZE    2048
#define WAVEBANK_DVD_BLOCK_SIZE     (WAVEBANK_DVD_SECTOR_SIZE * 16)

//
// Bank alignment presets
//

#define WAVEBANK_ALIGNMENT_MIN  4                           // Minimum alignment
#define WAVEBANK_ALIGNMENT_DVD  WAVEBANK_DVD_SECTOR_SIZE    // DVD-optimized alignment

//
// Wave bank segment identifiers
//

typedef enum WAVEBANKSEGIDX
{
    WAVEBANK_SEGIDX_BANKDATA = 0,       // Bank data
    WAVEBANK_SEGIDX_ENTRYMETADATA,      // Entry meta-data
    WAVEBANK_SEGIDX_SEEKTABLES,         // Storage for seek tables for the encoded waves.
    WAVEBANK_SEGIDX_ENTRYNAMES,         // Entry friendly names
    WAVEBANK_SEGIDX_ENTRYWAVEDATA,      // Entry wave data
    WAVEBANK_SEGIDX_COUNT
} WAVEBANKSEGIDX, *LPWAVEBANKSEGIDX;

typedef const WAVEBANKSEGIDX *LPCWAVEBANKSEGIDX;

//
// Endianness
//

#ifdef __cplusplus

namespace XACTWaveBank
{
    __inline void SwapBytes(DWORD &dw)
    {

#ifdef _X86_

        __asm
        {
            mov edi, dw
            mov eax, [edi]
            bswap eax
            mov [edi], eax
        }

#else // _X86_

        dw = _byteswap_ulong(dw);

#endif // _X86_

    }

    __inline void SwapBytes(WORD &w)
    {

#ifdef _X86_

        __asm
        {
            mov edi, w
            mov ax, [edi]
            xchg ah, al
            mov [edi], ax
        }

#else // _X86_

        w = _byteswap_ushort(w);

#endif // _X86_

    }

}

#endif // __cplusplus

//
// Wave bank region in bytes.
//

typedef struct WAVEBANKREGION
{
    DWORD       dwOffset;               // Region offset, in bytes.
    DWORD       dwLength;               // Region length, in bytes.

#ifdef __cplusplus

    void SwapBytes(void)
    {
        XACTWaveBank::SwapBytes(dwOffset);
        XACTWaveBank::SwapBytes(dwLength);
    }

#endif // __cplusplus

} WAVEBANKREGION, *LPWAVEBANKREGION;

typedef const WAVEBANKREGION *LPCWAVEBANKREGION;


//
// Wave bank region in samples.
//

typedef struct WAVEBANKSAMPLEREGION
{
    DWORD       dwStartSample;          // Start sample for the region.
    DWORD       dwTotalSamples;         // Region length in samples.

#ifdef __cplusplus

    void SwapBytes(void)
    {
        XACTWaveBank::SwapBytes(dwStartSample);
        XACTWaveBank::SwapBytes(dwTotalSamples);
    }

#endif // __cplusplus

} WAVEBANKSAMPLEREGION, *LPWAVEBANKSAMPLEREGION;

typedef const WAVEBANKSAMPLEREGION *LPCWAVEBANKSAMPLEREGION;


//
// Wave bank file header
//

typedef struct WAVEBANKHEADER
{
    DWORD           dwSignature;                        // File signature
    DWORD           dwVersion;                          // Version of the tool that created the file
    DWORD           dwHeaderVersion;                    // Version of the file format
    WAVEBANKREGION  Segments[WAVEBANK_SEGIDX_COUNT];    // Segment lookup table

#ifdef __cplusplus

    void SwapBytes(void)
    {
        XACTWaveBank::SwapBytes(dwSignature);
        XACTWaveBank::SwapBytes(dwVersion);
        XACTWaveBank::SwapBytes(dwHeaderVersion);

        for(int i = 0; i < WAVEBANK_SEGIDX_COUNT; i++)
        {
            Segments[i].SwapBytes();
        }
    }

#endif // __cplusplus

} WAVEBANKHEADER, *LPWAVEBANKHEADER;

typedef const WAVEBANKHEADER *LPCWAVEBANKHEADER;

//
// Entry compressed data format
//

typedef union WAVEBANKMINIWAVEFORMAT
{
    struct
    {
        DWORD       wFormatTag      : 2;        // Format tag
        DWORD       nChannels       : 3;        // Channel count (1 - 6)
        DWORD       nSamplesPerSec  : 18;       // Sampling rate
        DWORD       wBlockAlign     : 8;        // Block alignment
        DWORD       wBitsPerSample  : 1;        // Bits per sample (8 vs. 16, PCM only)
    };

    DWORD           dwValue;

#ifdef __cplusplus

    void SwapBytes(void)
    {
        XACTWaveBank::SwapBytes(dwValue);
    }

    WORD BitsPerSample() const
    {
        return wBitsPerSample == WAVEBANKMINIFORMAT_BITDEPTH_16 ? 16 : 8;
    }

    #define ADPCM_MINIWAVEFORMAT_BLOCKALIGN_CONVERSION_OFFSET 22
    DWORD BlockAlign() const
    {
        return wFormatTag != WAVEBANKMINIFORMAT_TAG_ADPCM ? wBlockAlign :
               (wBlockAlign + ADPCM_MINIWAVEFORMAT_BLOCKALIGN_CONVERSION_OFFSET) * nChannels;
    }

#endif // __cplusplus

} WAVEBANKMINIWAVEFORMAT, *LPWAVEBANKMINIWAVEFORMAT;

typedef const WAVEBANKMINIWAVEFORMAT *LPCWAVEBANKMINIWAVEFORMAT;

//
// Entry meta-data
//

typedef struct WAVEBANKENTRY
{
    union
    {
        struct
        {
            // Entry flags
            DWORD                   dwFlags  :  4;

            // Duration of the wave, in units of one sample.
            // For instance, a ten second long wave sampled
            // at 48KHz would have a duration of 480,000.
            // This value is not affected by the number of
            // channels, the number of bits per sample, or the
            // compression format of the wave.
            DWORD                   Duration : 28;
        };
        DWORD dwFlagsAndDuration;
    };

    WAVEBANKMINIWAVEFORMAT  Format;         // Entry format.
    WAVEBANKREGION          PlayRegion;     // Region within the wave data segment that contains this entry.
    WAVEBANKSAMPLEREGION    LoopRegion;     // Region within the wave data (in samples) that should loop.

#ifdef __cplusplus

    void SwapBytes(void)
    {
        XACTWaveBank::SwapBytes(dwFlagsAndDuration);
        Format.SwapBytes();
        PlayRegion.SwapBytes();
        LoopRegion.SwapBytes();
    }

#endif // __cplusplus

} WAVEBANKENTRY, *LPWAVEBANKENTRY;

typedef const WAVEBANKENTRY *LPCWAVEBANKENTRY;

//
// Compact entry meta-data
//

typedef struct WAVEBANKENTRYCOMPACT
{
    DWORD       dwOffset            : 21;       // Data offset, in sectors
    DWORD       dwLengthDeviation   : 11;       // Data length deviation, in bytes

#ifdef __cplusplus

    void SwapBytes(void)
    {
        XACTWaveBank::SwapBytes(*(LPDWORD)this);
    }

#endif // __cplusplus

} WAVEBANKENTRYCOMPACT, *LPWAVEBANKENTRYCOMPACT;

typedef const WAVEBANKENTRYCOMPACT *LPCWAVEBANKENTRYCOMPACT;

//
// Bank data segment
//

typedef struct WAVEBANKDATA
{
    DWORD                   dwFlags;                                // Bank flags
    DWORD                   dwEntryCount;                           // Number of entries in the bank
    CHAR                    szBankName[WAVEBANK_BANKNAME_LENGTH];   // Bank friendly name
    DWORD                   dwEntryMetaDataElementSize;             // Size of each entry meta-data element, in bytes
    DWORD                   dwEntryNameElementSize;                 // Size of each entry name element, in bytes
    DWORD                   dwAlignment;                            // Entry alignment, in bytes
    WAVEBANKMINIWAVEFORMAT  CompactFormat;                          // Format data for compact bank
    FILETIME                BuildTime;                              // Build timestamp

#ifdef __cplusplus

    void SwapBytes(void)
    {
        XACTWaveBank::SwapBytes(dwFlags);
        XACTWaveBank::SwapBytes(dwEntryCount);
        XACTWaveBank::SwapBytes(dwEntryMetaDataElementSize);
        XACTWaveBank::SwapBytes(dwEntryNameElementSize);
        XACTWaveBank::SwapBytes(dwAlignment);
        CompactFormat.SwapBytes();
        XACTWaveBank::SwapBytes(BuildTime.dwLowDateTime);
        XACTWaveBank::SwapBytes(BuildTime.dwHighDateTime);
    }

#endif // __cplusplus

} WAVEBANKDATA, *LPWAVEBANKDATA;

typedef const WAVEBANKDATA *LPCWAVEBANKDATA;

#ifdef _M_PPCBE
#pragma bitfield_order(pop)
#endif

#pragma warning(pop)
#pragma pack(pop)

#endif // __XACTWB_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DirectX\Dec2006\Include\XInput.h ===
/***************************************************************************
*                                                                          *
*   XInput.h -- This module defines XBOX controller APIs                   *
*               and constansts for the Windows platform.                   *
*                                                                          *
*   Copyright (c) Microsoft Corp. All rights reserved.                     *
*                                                                          *
***************************************************************************/
#ifndef _XINPUT_H_
#define _XINPUT_H_

#include <windef.h>

// Current name of the DLL shipped in the same SDK as this header.
// The name reflects the current version
#define XINPUT_DLL_A  "xinput1_3.dll"
#define XINPUT_DLL_W L"xinput1_3.dll"
#ifdef UNICODE
    #define XINPUT_DLL XINPUT_DLL_W
#else
    #define XINPUT_DLL XINPUT_DLL_A
#endif 

//
// Device types available in XINPUT_CAPABILITIES
//
#define XINPUT_DEVTYPE_GAMEPAD          0x01

//
// Device subtypes available in XINPUT_CAPABILITIES
//
#define XINPUT_DEVSUBTYPE_GAMEPAD       0x01
#define XINPUT_DEVSUBTYPE_WHEEL         0x02
#define XINPUT_DEVSUBTYPE_ARCADE_STICK  0x03
#define XINPUT_DEVSUBTYPE_FLIGHT_SICK   0x04
#define XINPUT_DEVSUBTYPE_DANCE_PAD     0x05

//
// Flags for XINPUT_CAPABILITIES
//
#define XINPUT_CAPS_VOICE_SUPPORTED     0x0004

//
// Constants for gamepad buttons
//
#define XINPUT_GAMEPAD_DPAD_UP          0x0001
#define XINPUT_GAMEPAD_DPAD_DOWN        0x0002
#define XINPUT_GAMEPAD_DPAD_LEFT        0x0004
#define XINPUT_GAMEPAD_DPAD_RIGHT       0x0008
#define XINPUT_GAMEPAD_START            0x0010
#define XINPUT_GAMEPAD_BACK             0x0020
#define XINPUT_GAMEPAD_LEFT_THUMB       0x0040
#define XINPUT_GAMEPAD_RIGHT_THUMB      0x0080
#define XINPUT_GAMEPAD_LEFT_SHOULDER    0x0100
#define XINPUT_GAMEPAD_RIGHT_SHOULDER   0x0200
#define XINPUT_GAMEPAD_A                0x1000
#define XINPUT_GAMEPAD_B                0x2000
#define XINPUT_GAMEPAD_X                0x4000
#define XINPUT_GAMEPAD_Y                0x8000


//
// Gamepad thresholds
//
#define XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE  7849
#define XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE 8689
#define XINPUT_GAMEPAD_TRIGGER_THRESHOLD    30

//
// Flags to pass to XInputGetCapabilities
//
#define XINPUT_FLAG_GAMEPAD             0x00000001

//
// Devices that support batteries
//
#define BATTERY_DEVTYPE_GAMEPAD         0x00
#define BATTERY_DEVTYPE_HEADSET         0x01

//
// Flags for battery status level
//
#define BATTERY_TYPE_DISCONNECTED       0x00    // This device is not connected
#define BATTERY_TYPE_WIRED              0x01    // Wired device, no battery
#define BATTERY_TYPE_ALKALINE           0x02    // Alkaline battery source
#define BATTERY_TYPE_NIMH               0x03    // Nickel Metal Hydride battery source
#define BATTERY_TYPE_UNKNOWN            0xFF    // Cannot determine the battery type

// These are only valid for wireless, connected devices, with known battery types
// The amount of use time remaining depends on the type of device.
#define BATTERY_LEVEL_EMPTY             0x00
#define BATTERY_LEVEL_LOW               0x01
#define BATTERY_LEVEL_MEDIUM            0x02
#define BATTERY_LEVEL_FULL              0x03

// User index definitions
#define XUSER_MAX_COUNT                 4

#define XUSER_INDEX_ANY                 0x000000FF


//
// Codes returned for the gamepad keystroke
//

#define VK_PAD_A                        0x5800
#define VK_PAD_B                        0x5801
#define VK_PAD_X                        0x5802
#define VK_PAD_Y                        0x5803
#define VK_PAD_RSHOULDER                0x5804
#define VK_PAD_LSHOULDER                0x5805
#define VK_PAD_LTRIGGER                 0x5806
#define VK_PAD_RTRIGGER                 0x5807

#define VK_PAD_DPAD_UP                  0x5810
#define VK_PAD_DPAD_DOWN                0x5811
#define VK_PAD_DPAD_LEFT                0x5812
#define VK_PAD_DPAD_RIGHT               0x5813
#define VK_PAD_START                    0x5814
#define VK_PAD_BACK                     0x5815
#define VK_PAD_LTHUMB_PRESS             0x5816
#define VK_PAD_RTHUMB_PRESS             0x5817

#define VK_PAD_LTHUMB_UP                0x5820
#define VK_PAD_LTHUMB_DOWN              0x5821
#define VK_PAD_LTHUMB_RIGHT             0x5822
#define VK_PAD_LTHUMB_LEFT              0x5823
#define VK_PAD_LTHUMB_UPLEFT            0x5824
#define VK_PAD_LTHUMB_UPRIGHT           0x5825
#define VK_PAD_LTHUMB_DOWNRIGHT         0x5826
#define VK_PAD_LTHUMB_DOWNLEFT          0x5827

#define VK_PAD_RTHUMB_UP                0x5830
#define VK_PAD_RTHUMB_DOWN              0x5831
#define VK_PAD_RTHUMB_RIGHT             0x5832
#define VK_PAD_RTHUMB_LEFT              0x5833
#define VK_PAD_RTHUMB_UPLEFT            0x5834
#define VK_PAD_RTHUMB_UPRIGHT           0x5835
#define VK_PAD_RTHUMB_DOWNRIGHT         0x5836
#define VK_PAD_RTHUMB_DOWNLEFT          0x5837

//
// Flags used in XINPUT_KEYSTROKE
//
#define XINPUT_KEYSTROKE_KEYDOWN        0x0001
#define XINPUT_KEYSTROKE_KEYUP          0x0002
#define XINPUT_KEYSTROKE_REPEAT         0x0004

//
// Structures used by XInput APIs
//
typedef struct _XINPUT_GAMEPAD
{
    WORD                                wButtons;
    BYTE                                bLeftTrigger;
    BYTE                                bRightTrigger;
    SHORT                               sThumbLX;
    SHORT                               sThumbLY;
    SHORT                               sThumbRX;
    SHORT                               sThumbRY;
} XINPUT_GAMEPAD, *PXINPUT_GAMEPAD;

typedef struct _XINPUT_STATE
{
    DWORD                               dwPacketNumber;
    XINPUT_GAMEPAD                      Gamepad;
} XINPUT_STATE, *PXINPUT_STATE;

typedef struct _XINPUT_VIBRATION
{
    WORD                                wLeftMotorSpeed;
    WORD                                wRightMotorSpeed;
} XINPUT_VIBRATION, *PXINPUT_VIBRATION;

typedef struct _XINPUT_CAPABILITIES
{
    BYTE                                Type;
    BYTE                                SubType;
    WORD                                Flags;
    XINPUT_GAMEPAD                      Gamepad;
    XINPUT_VIBRATION                    Vibration;
} XINPUT_CAPABILITIES, *PXINPUT_CAPABILITIES;

typedef struct _XINPUT_BATTERY_INFORMATION
{
    BYTE BatteryType;
    BYTE BatteryLevel;
} XINPUT_BATTERY_INFORMATION, *PXINPUT_BATTERY_INFORMATION;

typedef struct _XINPUT_KEYSTROKE
{
    WORD    VirtualKey;
    WCHAR   Unicode;
    WORD    Flags;
    BYTE    UserIndex;
    BYTE    HidCode;
} XINPUT_KEYSTROKE, *PXINPUT_KEYSTROKE;

//
// XInput APIs
//
#ifdef __cplusplus
extern "C" {
#endif

DWORD WINAPI XInputGetState
(
    DWORD         dwUserIndex,  // [in] Index of the gamer associated with the device
    XINPUT_STATE* pState        // [out] Receives the current state
);

DWORD WINAPI XInputSetState
(
    DWORD             dwUserIndex,  // [in] Index of the gamer associated with the device
    XINPUT_VIBRATION* pVibration    // [in, out] The vibration information to send to the controller
);

DWORD WINAPI XInputGetCapabilities
(
    DWORD                dwUserIndex,   // [in] Index of the gamer associated with the device
    DWORD                dwFlags,       // [in] Input flags that identify the device type
    XINPUT_CAPABILITIES* pCapabilities  // [out] Receives the capabilities
);

void WINAPI XInputEnable
(
    BOOL enable     // [in] Indicates whether xinput is enabled or disabled. 
);

DWORD WINAPI XInputGetDSoundAudioDeviceGuids
(
    DWORD dwUserIndex,          // [in] Index of the gamer associated with the device
    GUID* pDSoundRenderGuid,    // [out] DSound device ID for render
    GUID* pDSoundCaptureGuid    // [out] DSound device ID for capture
);

DWORD WINAPI XInputGetBatteryInformation
(
    DWORD                       dwUserIndex,        // [in]  Index of the gamer associated with the device
    BYTE                        devType,            // [in]  Which device on this user index
    XINPUT_BATTERY_INFORMATION* pBatteryInformation // [out] Contains the level and types of batteries
);

DWORD WINAPI XInputGetKeystroke
(
    DWORD dwUserIndex,              // [in]  Index of the gamer associated with the device
    DWORD dwReserved,               // [in]  Reserved for future use
    PXINPUT_KEYSTROKE pKeystroke    // [out] Pointer to an XINPUT_KEYSTROKE structure that receives an input event.
);

#ifdef __cplusplus
}
#endif

#endif  //_XINPUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DirectX\Dec2006\Include\xact.h ===
/*++

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    xact.h

Abstract:

    XACT public interfaces, functions and data types

--*/

#pragma once

#ifndef _XACT_H_
#define _XACT_H_

//------------------------------------------------------------------------------
// XACT class and interface IDs (Version 2.5)
//------------------------------------------------------------------------------
#ifndef _XBOX // XACT COM support only exists on Windows
    #include <comdecl.h> // For DEFINE_CLSID, DEFINE_IID and DECLARE_INTERFACE
    DEFINE_CLSID(XACTEngine,         54b68bc7, 3a45, 416b, a8, c9, 19, bf, 19, ec, 1d, f5);
    DEFINE_CLSID(XACTAuditionEngine, aeaf4809, 6e94, 4663, 8f, f8, 1b, 4c, 7c, 0e, 6d, fd);
    DEFINE_CLSID(XACTDebugEngine,    290d0a8c, a131, 4cf4, 8b, bd, 37, d0, 2b, 59, cc, 4a);
    DEFINE_IID(IXACTEngine,          f9df94ad, 6960, 4307, bf, ad, 4e, 97, ac, 18, 94, c6);
#endif

// Ignore the rest of this header if only the GUID definitions were requested:
#ifndef GUID_DEFS_ONLY

//------------------------------------------------------------------------------
// Includes
//------------------------------------------------------------------------------

#ifndef _XBOX
    #include <windows.h>
    #include <objbase.h>
    #include <float.h>
#else
    #include <xaudio.h>
#endif
#include <limits.h>
#include <xact2wb.h>

//------------------------------------------------------------------------------
// Forward Declarations
//------------------------------------------------------------------------------

typedef struct IXACTSoundBank       IXACTSoundBank;
typedef struct IXACTWaveBank        IXACTWaveBank;
typedef struct IXACTCue             IXACTCue;
typedef struct IXACTWave            IXACTWave;
typedef struct IXACTEngine          IXACTEngine;
typedef struct XACT_NOTIFICATION    XACT_NOTIFICATION;


//------------------------------------------------------------------------------
// Typedefs
//------------------------------------------------------------------------------

typedef WORD  XACTINDEX;            // All normal indices
typedef BYTE  XACTNOTIFICATIONTYPE; // Notification type
typedef FLOAT XACTVARIABLEVALUE;    // Variable value
typedef WORD  XACTVARIABLEINDEX;    // Variable index
typedef WORD  XACTCATEGORY;         // Sound category
typedef BYTE  XACTCHANNEL;          // Audio channel
typedef FLOAT XACTVOLUME;           // Volume value
typedef LONG  XACTTIME;             // Time (in ms)
typedef SHORT XACTPITCH;            // Pitch value
typedef BYTE  XACTLOOPCOUNT;        // For all loops / recurrences
typedef BYTE  XACTVARIATIONWEIGHT;  // Variation weight
typedef BYTE  XACTPRIORITY;         // Sound priority
typedef BYTE  XACTINSTANCELIMIT;    // Instance limitations

//------------------------------------------------------------------------------
// Constants
//------------------------------------------------------------------------------
static const XACTTIME               XACTTIME_MIN                    = LONG_MIN;
static const XACTTIME               XACTTIME_MAX                    = LONG_MAX; // 24 days 20:31:23.647
static const XACTTIME               XACTTIME_INFINITE               = LONG_MAX;
static const XACTINSTANCELIMIT      XACTINSTANCELIMIT_INFINITE      = 0xff;
static const XACTINSTANCELIMIT      XACTINSTANCELIMIT_MIN           = 0x00; // == 1 instance total (0 additional instances)
static const XACTINSTANCELIMIT      XACTINSTANCELIMIT_MAX           = 0xfe; // == 255 instances total (254 additional instances)
static const XACTINDEX              XACTINDEX_MIN                   = 0x0;
static const XACTINDEX              XACTINDEX_MAX                   = 0xfffe;
static const XACTINDEX              XACTINDEX_INVALID               = 0xffff;
static const XACTNOTIFICATIONTYPE   XACTNOTIFICATIONTYPE_MIN        = 0x00;
static const XACTNOTIFICATIONTYPE   XACTNOTIFICATIONTYPE_MAX        = 0xff;
static const XACTVARIABLEVALUE      XACTVARIABLEVALUE_MIN           = -FLT_MAX;
static const XACTVARIABLEVALUE      XACTVARIABLEVALUE_MAX           = FLT_MAX;
static const XACTVARIABLEINDEX      XACTVARIABLEINDEX_MIN           = 0x0000;
static const XACTVARIABLEINDEX      XACTVARIABLEINDEX_MAX           = 0xfffe;
static const XACTVARIABLEINDEX      XACTVARIABLEINDEX_INVALID       = 0xffff;
static const XACTCATEGORY           XACTCATEGORY_MIN                = 0x0;
static const XACTCATEGORY           XACTCATEGORY_MAX                = 0xfffe;
static const XACTCATEGORY           XACTCATEGORY_INVALID            = 0xffff;
static const XACTCHANNEL            XACTCHANNEL_MIN                 = 0;
static const XACTCHANNEL            XACTCHANNEL_MAX                 = 0xFF;
static const XACTPITCH              XACTPITCH_MIN                   = -1200;
static const XACTPITCH              XACTPITCH_MAX                   = 1200;
static const XACTVOLUME             XACTVOLUME_MIN                  = 0.0f;
static const XACTVOLUME             XACTVOLUME_MAX                  = FLT_MAX;
static const XACTVARIABLEVALUE      XACTPARAMETERVALUE_MIN          = -FLT_MAX;
static const XACTVARIABLEVALUE      XACTPARAMETERVALUE_MAX          = FLT_MAX;
static const XACTLOOPCOUNT          XACTLOOPCOUNT_MIN               = 0x0;
static const XACTLOOPCOUNT          XACTLOOPCOUNT_MAX               = 0xfe;
static const XACTLOOPCOUNT          XACTLOOPCOUNT_INFINITE          = 0xff;
static const DWORD                  XACTWAVEALIGNMENT_MIN           = 2048;
#ifdef _XBOX
static const XAUDIOVOICEINDEX       XACTMAXOUTPUTVOICECOUNT         = 3;
#endif // _XBOX


// -----------------------------------------------------------------------------
// Cue friendly name length
// -----------------------------------------------------------------------------
#define XACT_CUE_NAME_LENGTH        0xFF

// -----------------------------------------------------------------------------
// Current Content Tool Version
// -----------------------------------------------------------------------------
#define XACT_CONTENT_VERSION        42

// -----------------------------------------------------------------------------
// XACT Stop Flags
// -----------------------------------------------------------------------------
static const DWORD XACT_FLAG_STOP_RELEASE       = 0x00000000; // Stop with release envelope (or as authored), for looping waves this acts as break loop.
static const DWORD XACT_FLAG_STOP_IMMEDIATE     = 0x00000001; // Stop immediately

// -----------------------------------------------------------------------------
// XACT Manage Data Flag - XACT will manage the lifetime of this data
// -----------------------------------------------------------------------------
static const DWORD XACT_FLAG_MANAGEDATA         = 0x00000001;

// -----------------------------------------------------------------------------
// XACT Content Preparation Flags
// -----------------------------------------------------------------------------
static const DWORD XACT_FLAG_BACKGROUND_MUSIC   = 0x00000002; // Marks the waves as background music.
static const DWORD XACT_FLAG_UNITS_MS           = 0x00000004; // Indicates that the units passed in are in milliseconds.
static const DWORD XACT_FLAG_UNITS_SAMPLES      = 0x00000008; // Indicates that the units passed in are in samples.

// -----------------------------------------------------------------------------
// XACT State flags
// -----------------------------------------------------------------------------
static const DWORD XACT_STATE_CREATED           = 0x00000001; // Created, but nothing else
static const DWORD XACT_STATE_PREPARING         = 0x00000002; // In the middle of preparing
static const DWORD XACT_STATE_PREPARED          = 0x00000004; // Prepared, but not yet played
static const DWORD XACT_STATE_PLAYING           = 0x00000008; // Playing (though could be paused)
static const DWORD XACT_STATE_STOPPING          = 0x00000010; // Stopping
static const DWORD XACT_STATE_STOPPED           = 0x00000020; // Stopped
static const DWORD XACT_STATE_PAUSED            = 0x00000040; // Paused (Can be combined with some of the other state flags above)
static const DWORD XACT_STATE_INUSE             = 0x00000080; // Object is in use (used by wavebanks and soundbanks).
static const DWORD XACT_STATE_PREPAREFAILED     = 0x80000000; // Object preparation failed.

//------------------------------------------------------------------------------
// XACT Parameters
//------------------------------------------------------------------------------

#define XACT_FLAG_GLOBAL_SETTINGS_MANAGEDATA    XACT_FLAG_MANAGEDATA

// -----------------------------------------------------------------------------
// File IO Callbacks
// -----------------------------------------------------------------------------
typedef BOOL (__stdcall * XACT_READFILE_CALLBACK)(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
typedef BOOL (__stdcall * XACT_GETOVERLAPPEDRESULT_CALLBACK)(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, BOOL bWait);

typedef struct XACT_FILEIO_CALLBACKS
{
    XACT_READFILE_CALLBACK              readFileCallback;
    XACT_GETOVERLAPPEDRESULT_CALLBACK   getOverlappedResultCallback;

} XACT_FILEIO_CALLBACKS, *PXACT_FILEIO_CALLBACKS;
typedef const XACT_FILEIO_CALLBACKS *PCXACT_FILEIO_CALLBACKS;

// -----------------------------------------------------------------------------
// Notification Callback
// -----------------------------------------------------------------------------
typedef void (__stdcall * XACT_NOTIFICATION_CALLBACK)(const XACT_NOTIFICATION* pNotification);

#ifndef _XBOX

#define XACT_RENDERER_ID_LENGTH                 0xff    // Maximum number of characters allowed in the renderer ID
#define XACT_RENDERER_NAME_LENGTH               0xff    // Maximum number of characters allowed in the renderer display name.

// -----------------------------------------------------------------------------
// Renderer Details
// -----------------------------------------------------------------------------
typedef struct XACT_RENDERER_DETAILS
{
    WCHAR rendererID[XACT_RENDERER_ID_LENGTH];          // The string ID for the rendering device.
    WCHAR displayName[XACT_RENDERER_NAME_LENGTH];       // A friendly name suitable for display to a human.
    BOOL  defaultDevice;                                // Set to TRUE if this device is the primary audio device on the system.

} XACT_RENDERER_DETAILS, *LPXACT_RENDERER_DETAILS;
#endif

// -----------------------------------------------------------------------------
// Engine Look-Ahead Time
// -----------------------------------------------------------------------------
#define XACT_ENGINE_LOOKAHEAD_DEFAULT           250     // Default look-ahead time of 250ms can be used during XACT engine initialization.

// -----------------------------------------------------------------------------
// Runtime (engine) parameters
// -----------------------------------------------------------------------------
typedef struct XACT_RUNTIME_PARAMETERS
{
    DWORD                           lookAheadTime;                  // Time in ms
    void*                           pGlobalSettingsBuffer;          // Buffer containing the global settings file
    DWORD                           globalSettingsBufferSize;       // Size of global settings buffer
    DWORD                           globalSettingsFlags;            // Flags for global settings
    DWORD                           globalSettingsAllocAttributes;  // Global settings buffer allocation attributes (see XMemAlloc)
    XACT_FILEIO_CALLBACKS           fileIOCallbacks;                // File I/O callbacks
    XACT_NOTIFICATION_CALLBACK      fnNotificationCallback;         // Callback that receives notifications.
#ifndef _XBOX
    PWSTR                           pRendererID;                    // Ptr to the ID for the audio renderer the engine should connect to.
#endif

} XACT_RUNTIME_PARAMETERS, *LPXACT_RUNTIME_PARAMETERS;
typedef const XACT_RUNTIME_PARAMETERS *LPCXACT_RUNTIME_PARAMETERS;

//------------------------------------------------------------------------------
// Streaming Parameters
//------------------------------------------------------------------------------

typedef struct XACT_STREAMING_PARAMETERS
{
    HANDLE  file;            // File handle associated with wavebank data
    DWORD   offset;          // Offset within file of wavebank header (must be sector aligned)
    DWORD   flags;           // Flags (none currently)
    WORD    packetSize;      // Stream packet size (in sectors) to use for each stream (min = 2)
                             //   number of sectors (DVD = 2048 bytes: 2 = 4096, 3 = 6144, 4 = 8192 etc.)
                             //   optimal DVD size is a multiple of 16 (DVD block = 16 DVD sectors)

} XACT_WAVEBANK_STREAMING_PARAMETERS, *LPXACT_WAVEBANK_STREAMING_PARAMETERS, XACT_STREAMING_PARAMETERS, *LPXACT_STREAMING_PARAMETERS;
typedef const XACT_STREAMING_PARAMETERS *LPCXACT_STREAMING_PARAMETERS;
typedef const XACT_WAVEBANK_STREAMING_PARAMETERS *LPCXACT_WAVEBANK_STREAMING_PARAMETERS;

// Structure used to report cue properties back to the client.
typedef struct XACT_CUE_PROPERTIES
{
    CHAR                friendlyName[XACT_CUE_NAME_LENGTH]; // Empty if the soundbank doesn't contain any friendly names
    BOOL                interactive;                        // TRUE if an IA cue; FALSE otherwise
    XACTINDEX           iaVariableIndex;                    // Only valid for IA cues; XACTINDEX_INVALID otherwise
    XACTINDEX           numVariations;                      // Number of variations in the cue
    XACTINSTANCELIMIT   maxInstances;                       // Number of maximum instances for this cue
    XACTINSTANCELIMIT   currentInstances;                   // Current active instances of this cue

} XACT_CUE_PROPERTIES, *LPXACT_CUE_PROPERTIES;

// Strucutre used to return the track properties.
typedef struct XACT_TRACK_PROPERTIES
{
    XACTTIME        duration;                   // Duration of the track in ms
    XACTINDEX       numVariations;              // Number of wave variations in the track
    XACTCHANNEL     numChannels;                // Number of channels for the active wave variation on this track
    XACTINDEX       waveVariation;              // Index of the active wave variation
    XACTLOOPCOUNT   loopCount;                  // Current loop count on this track

} XACT_TRACK_PROPERTIES, *LPXACT_TRACK_PROPERTIES;

// Structure used to return the properties of a variation.
typedef struct XACT_VARIATION_PROPERTIES
{
    XACTINDEX               index;              // Index of the variation in the cue's variation list
    XACTVARIATIONWEIGHT     weight;             // Weight for the active variation. Valid only for complex cues
    XACTVARIABLEVALUE       iaVariableMin;      // Valid only for IA cues
    XACTVARIABLEVALUE       iaVariableMax;      // Valid only for IA cues
    BOOL                    linger;             // Valid only for IA cues

} XACT_VARIATION_PROPERTIES, *LPXACT_VARIATION_PROPERTIES;

// Structure used to return the properties of the sound referenced by a variation.
typedef struct XACT_SOUND_PROPERTIES
{
    XACTCATEGORY            category;           // Category this sound belongs to
    BYTE                    priority;           // Priority of this variation
    XACTPITCH               pitch;              // Current pitch set on the active variation
    XACTVOLUME              volume;             // Current volume set on the active variation
    XACTINDEX               numTracks;          // Number of tracks in the active variation
    XACT_TRACK_PROPERTIES   arrTrackProperties; // Array of active track properties (has numTracks number of elements)

} XACT_SOUND_PROPERTIES, *LPXACT_SOUND_PROPERTIES;

// Structure used to return the properties of the active variation and the sound referenced.
typedef struct XACT_SOUND_VARIATION_PROPERTIES
{
    XACT_VARIATION_PROPERTIES   variationProperties;// Properties for this variation
    XACT_SOUND_PROPERTIES       soundProperties;    // Proeprties for the sound referenced by this variation

} XACT_SOUND_VARIATION_PROPERTIES, *LPXACT_SOUND_VARIATION_PROPERTIES;

// Structure used to return the properties of an active cue instance.
typedef struct XACT_CUE_INSTANCE_PROPERTIES
{
    DWORD                            allocAttributes;            // Buffer allocation attributes (see XMemAlloc)
    XACT_CUE_PROPERTIES              cueProperties;              // Properties of the cue that are shared by all instances.
    XACT_SOUND_VARIATION_PROPERTIES  activeVariationProperties;  // Properties if the currently active variation.

} XACT_CUE_INSTANCE_PROPERTIES, *LPXACT_CUE_INSTANCE_PROPERTIES;

// Structure used to return the common wave properties.
typedef struct XACT_WAVE_PROPERTIES
{
    char                    friendlyName[WAVEBANK_ENTRYNAME_LENGTH];   // Friendly name for the wave; empty if the wavebank doesn't contain friendly names.
    WAVEBANKMINIWAVEFORMAT  format;                                    // Format for the wave.
    DWORD                   durationInSamples;                         // Duration of the wave in units of one sample
    WAVEBANKSAMPLEREGION    loopRegion;                                // Loop region defined in samples.
    BOOL                    streaming;                                 // Set to TRUE if the wave is streaming; FALSE otherwise.

} XACT_WAVE_PROPERTIES, *LPXACT_WAVE_PROPERTIES;
typedef const XACT_WAVE_PROPERTIES* LPCXACT_WAVE_PROPERTIES;

// Structure used to return the properties specific to a wave instance.
typedef struct XACT_WAVE_INSTANCE_PROPERTIES
{
    XACT_WAVE_PROPERTIES    properties;                                 // Static properties common to all the wave instances.
    BOOL                    backgroundMusic;                            // Set to TRUE if the wave is tagged as background music; FALSE otherwise.

} XACT_WAVE_INSTANCE_PROPERTIES, *LPXACT_WAVE_INSTANCE_PROPERTIES;
typedef const XACT_WAVE_INSTANCE_PROPERTIES* LPCXACT_WAVE_INSTANCE_PROPERTIES;

//------------------------------------------------------------------------------
// Channel Mapping / Speaker Panning
//------------------------------------------------------------------------------

typedef struct XACTCHANNELMAPENTRY
{
    XACTCHANNEL   InputChannel;
    XACTCHANNEL   OutputChannel;
    XACTVOLUME    Volume;

} XACTCHANNELMAPENTRY, *LPXACTCHANNELMAPENTRY;
typedef const XACTCHANNELMAPENTRY *LPCXACTCHANNELMAPENTRY;

typedef struct XACTCHANNELMAP
{
    XACTCHANNEL             EntryCount;
    XACTCHANNELMAPENTRY*    paEntries;

} XACTCHANNELMAP, *LPXACTCHANNELMAP;
typedef const XACTCHANNELMAP *LPCXACTCHANNELMAP;

typedef struct XACTCHANNELVOLUMEENTRY
{
    XACTCHANNEL   EntryIndex;
    XACTVOLUME    Volume;

} XACTCHANNELVOLUMEENTRY, *LPXACTCHANNELVOLUMEENTRY;
typedef const XACTCHANNELVOLUMEENTRY *LPCXACTCHANNELVOLUMEENTRY;

typedef struct XACTCHANNELVOLUME
{
    XACTCHANNEL             EntryCount;
    XACTCHANNELVOLUMEENTRY* paEntries;

} XACTCHANNELVOLUME, *LPXACTCHANNELVOLUME;
typedef const XACTCHANNELVOLUME *LPCXACTCHANNELVOLUME;

//------------------------------------------------------------------------------
// Notifications
//------------------------------------------------------------------------------

static const XACTNOTIFICATIONTYPE XACTNOTIFICATIONTYPE_CUEPREPARED                      = 1;  // None, SoundBank, SoundBank & cue index, cue instance
static const XACTNOTIFICATIONTYPE XACTNOTIFICATIONTYPE_CUEPLAY                          = 2;  // None, SoundBank, SoundBank & cue index, cue instance
static const XACTNOTIFICATIONTYPE XACTNOTIFICATIONTYPE_CUESTOP                          = 3;  // None, SoundBank, SoundBank & cue index, cue instance
static const XACTNOTIFICATIONTYPE XACTNOTIFICATIONTYPE_CUEDESTROYED                     = 4;  // None, SoundBank, SoundBank & cue index, cue instance
static const XACTNOTIFICATIONTYPE XACTNOTIFICATIONTYPE_MARKER                           = 5;  // None, SoundBank, SoundBank & cue index, cue instance
static const XACTNOTIFICATIONTYPE XACTNOTIFICATIONTYPE_SOUNDBANKDESTROYED               = 6;  // None, SoundBank
static const XACTNOTIFICATIONTYPE XACTNOTIFICATIONTYPE_WAVEBANKDESTROYED                = 7;  // None, WaveBank
static const XACTNOTIFICATIONTYPE XACTNOTIFICATIONTYPE_LOCALVARIABLECHANGED             = 8;  // None, SoundBank, SoundBank & cue index, cue instance
static const XACTNOTIFICATIONTYPE XACTNOTIFICATIONTYPE_GLOBALVARIABLECHANGED            = 9;  // None
static const XACTNOTIFICATIONTYPE XACTNOTIFICATIONTYPE_GUICONNECTED                     = 10; // None
static const XACTNOTIFICATIONTYPE XACTNOTIFICATIONTYPE_GUIDISCONNECTED                  = 11; // None
static const XACTNOTIFICATIONTYPE XACTNOTIFICATIONTYPE_WAVEPREPARED                     = 12; // None, WaveBank & wave index, wave instance.
static const XACTNOTIFICATIONTYPE XACTNOTIFICATIONTYPE_WAVEPLAY                         = 13; // None, SoundBank, SoundBank & cue index, cue instance, WaveBank, wave instance
static const XACTNOTIFICATIONTYPE XACTNOTIFICATIONTYPE_WAVESTOP                         = 14; // None, SoundBank, SoundBank & cue index, cue instance, WaveBank, wave instance
static const XACTNOTIFICATIONTYPE XACTNOTIFICATIONTYPE_WAVELOOPED                       = 15; // None, SoundBank, SoundBank & cue index, cue instance, WaveBank, wave instance
static const XACTNOTIFICATIONTYPE XACTNOTIFICATIONTYPE_WAVEDESTROYED                    = 16; // None, WaveBank & wave index, wave instance.
static const XACTNOTIFICATIONTYPE XACTNOTIFICATIONTYPE_WAVEBANKPREPARED                 = 17; // None, WaveBank
static const XACTNOTIFICATIONTYPE XACTNOTIFICATIONTYPE_WAVEBANKSTREAMING_INVALIDCONTENT = 18; // None, WaveBank

static const BYTE XACT_FLAG_NOTIFICATION_PERSIST = 0x01;

// Pack the notification structures
#pragma pack(push, 1)

// Notification description used for registering, un-registering and flushing notifications
typedef struct XACT_NOTIFICATION_DESCRIPTION
{
    XACTNOTIFICATIONTYPE type;          // Notification type
    BYTE                 flags;         // Flags
    IXACTSoundBank*      pSoundBank;    // SoundBank instance
    IXACTWaveBank*       pWaveBank;     // WaveBank instance
    IXACTCue*            pCue;          // Cue instance
    IXACTWave*           pWave;         // Wave instance
    XACTINDEX            cueIndex;      // Cue index
    XACTINDEX            waveIndex;     // Wave index
    PVOID                pvContext;     // User context (optional)

} XACT_NOTIFICATION_DESCRIPTION, *LPXACT_NOTIFICATION_DESCRIPTION;
typedef const XACT_NOTIFICATION_DESCRIPTION *LPCXACT_NOTIFICATION_DESCRIPTION;

// Notification structure for all XACTNOTIFICATIONTYPE_CUE* notifications
typedef struct XACT_NOTIFICATION_CUE
{
    XACTINDEX       cueIndex;   // Cue index
    IXACTSoundBank* pSoundBank; // SoundBank instance
    IXACTCue*       pCue;       // Cue instance

} XACT_NOTIFICATION_CUE, *LPXACT_NOTIFICATION_CUE;
typedef const XACT_NOTIFICATION_CUE *LPCXACT_NOTIFICATION_CUE;

// Notification structure for all XACTNOTIFICATIONTYPE_MARKER* notifications
typedef struct XACT_NOTIFICATION_MARKER
{
    XACTINDEX       cueIndex;   // Cue index
    IXACTSoundBank* pSoundBank; // SoundBank instance
    IXACTCue*       pCue;       // Cue instance
    DWORD           marker;     // Marker value

} XACT_NOTIFICATION_MARKER, *LPXACT_NOTIFICATION_MARKER;
typedef const XACT_NOTIFICATION_MARKER *LPCXACT_NOTIFICATION_MARKER;

// Notification structure for all XACTNOTIFICATIONTYPE_SOUNDBANK* notifications
typedef struct XACT_NOTIFICATION_SOUNDBANK
{
    IXACTSoundBank* pSoundBank; // SoundBank instance

} XACT_NOTIFICATION_SOUNDBANK, *LPXACT_NOTIFICATION_SOUNDBANK;
typedef const XACT_NOTIFICATION_SOUNDBANK *LPCXACT_NOTIFICATION_SOUNDBANK;

// Notification structure for all XACTNOTIFICATIONTYPE_WAVEBANK* notifications
typedef struct XACT_NOTIFICATION_WAVEBANK
{
    IXACTWaveBank*  pWaveBank;  // WaveBank instance

} XACT_NOTIFICATION_WAVEBANK, *LPXACT_NOTIFICATION_WAVEBANK;
typedef const XACT_NOTIFICATION_WAVEBANK *LPCXACT_NOTIFICATION_WAVEBANK;

// Notification structure for all XACTNOTIFICATIONTYPE_*VARIABLE* notifications
typedef struct XACT_NOTIFICATION_VARIABLE
{
    XACTINDEX           cueIndex;       // Cue index
    IXACTSoundBank*     pSoundBank;     // SoundBank instance
    IXACTCue*           pCue;           // Cue instance
    XACTVARIABLEINDEX   variableIndex;  // Variable index
    XACTVARIABLEVALUE   variableValue;  // Variable value
    BOOL                local;          // TRUE if a local variable

} XACT_NOTIFICATION_VARIABLE, *LPXACT_NOTIFICATION_VARIABLE;
typedef const XACT_NOTIFICATION_VARIABLE *LPCXACT_NOTIFICATION_VARIABLE;

// Notification structure for all XACTNOTIFICATIONTYPE_GUI* notifications
typedef struct XACT_NOTIFICATION_GUI
{
    DWORD   reserved; // Reserved
} XACT_NOTIFICATION_GUI, *LPXACT_NOTIFICATION_GUI;
typedef const XACT_NOTIFICATION_GUI *LPCXACT_NOTIFICATION_GUI;

// Notification structure for all XACTNOTIFICATIONTYPE_WAVE* notifications
typedef struct XACT_NOTIFICATION_WAVE
{
    IXACTWaveBank*  pWaveBank;  // WaveBank
    XACTINDEX       waveIndex;  // Wave index
    XACTINDEX       cueIndex;   // Cue index
    IXACTSoundBank* pSoundBank; // SoundBank instance
    IXACTCue*       pCue;       // Cue instance
    IXACTWave*      pWave;      // Wave instance

} XACT_NOTIFICATION_WAVE, *LPXACT_NOTIFICATION_WAVE;
typedef const XACT_NOTIFICATION_WAVE *LPCXACT_NOTIFICATION_WAVE;

// General notification structure
typedef struct XACT_NOTIFICATION
{
    XACTNOTIFICATIONTYPE    type;        // Notification type
    LONG                    timeStamp;   // Timestamp of notification (milliseconds)
    PVOID                   pvContext;   // User context (optional)
    union
    {
        XACT_NOTIFICATION_CUE       cue;        // XACTNOTIFICATIONTYPE_CUE*
        XACT_NOTIFICATION_MARKER    marker;     // XACTNOTIFICATIONTYPE_MARKER*
        XACT_NOTIFICATION_SOUNDBANK soundBank;  // XACTNOTIFICATIONTYPE_SOUNDBANK*
        XACT_NOTIFICATION_WAVEBANK  waveBank;   // XACTNOTIFICATIONTYPE_WAVEBANK*
        XACT_NOTIFICATION_VARIABLE  variable;   // XACTNOTIFICATIONTYPE_VARIABLE*
        XACT_NOTIFICATION_GUI       gui;        // XACTNOTIFICATIONTYPE_GUI*
        XACT_NOTIFICATION_WAVE      wave;       // XACTNOTIFICATIONTYPE_WAVE*
    };

} XACT_NOTIFICATION, *LPXACT_NOTIFICATION;
typedef const XACT_NOTIFICATION *LPCXACT_NOTIFICATION;
#pragma pack(pop)

//------------------------------------------------------------------------------
// IXACTSoundBank
//------------------------------------------------------------------------------

#define XACT_FLAG_SOUNDBANK_STOP_IMMEDIATE  XACT_FLAG_STOP_IMMEDIATE
#define XACT_SOUNDBANKSTATE_INUSE           XACT_STATE_INUSE

STDAPI_(XACTINDEX) IXACTSoundBank_GetCueIndex(IXACTSoundBank* pSoundBank, PCSTR szFriendlyName);
STDAPI IXACTSoundBank_GetNumCues(IXACTSoundBank* pSoundBank, XACTINDEX* pnNumCues);
STDAPI IXACTSoundBank_GetCueProperties(IXACTSoundBank* pSoundBank, XACTINDEX nCueIndex, LPXACT_CUE_PROPERTIES pProperties);
STDAPI IXACTSoundBank_Prepare(IXACTSoundBank* pSoundBank, XACTINDEX nCueIndex, DWORD dwFlags, XACTTIME timeOffset, IXACTCue** ppCue);
STDAPI IXACTSoundBank_Play(IXACTSoundBank* pSoundBank, XACTINDEX nCueIndex, DWORD dwFlags, XACTTIME timeOffset, IXACTCue** ppCue);
STDAPI IXACTSoundBank_Stop(IXACTSoundBank* pSoundBank, XACTINDEX nCueIndex, DWORD dwFlags);
STDAPI IXACTSoundBank_Destroy(IXACTSoundBank* pSoundBank);
STDAPI IXACTSoundBank_GetState(IXACTSoundBank* pSoundBank, DWORD* pdwState);

#undef INTERFACE
#define INTERFACE IXACTSoundBank

DECLARE_INTERFACE(IXACTSoundBank)
{
    STDMETHOD_(XACTINDEX, GetCueIndex)(THIS_ PCSTR szFriendlyName) PURE;
    STDMETHOD(GetNumCues)(THIS_ XACTINDEX* pnNumCues) PURE;
    STDMETHOD(GetCueProperties)(THIS_ XACTINDEX nCueIndex, LPXACT_CUE_PROPERTIES pProperties) PURE;
    STDMETHOD(Prepare)(THIS_ XACTINDEX nCueIndex, DWORD dwFlags, XACTTIME timeOffset, IXACTCue** ppCue) PURE;
    STDMETHOD(Play)(THIS_ XACTINDEX nCueIndex, DWORD dwFlags, XACTTIME timeOffset, IXACTCue** ppCue) PURE;
    STDMETHOD(Stop)(THIS_ XACTINDEX nCueIndex, DWORD dwFlags) PURE;
    STDMETHOD(Destroy)(THIS) PURE;
    STDMETHOD(GetState)(THIS_ DWORD* pdwState) PURE;
};

#ifdef __cplusplus

__inline HRESULT __stdcall IXACTSoundBank_Destroy(IXACTSoundBank* pSoundBank)
{
    return pSoundBank->Destroy();
}

__inline XACTINDEX __stdcall IXACTSoundBank_GetCueIndex(IXACTSoundBank* pSoundBank, PCSTR szFriendlyName)
{
    return pSoundBank->GetCueIndex(szFriendlyName);
}

__inline HRESULT __stdcall IXACTSoundBank_GetNumCues(IXACTSoundBank* pSoundBank, XACTINDEX* pnNumCues)
{
    return pSoundBank->GetNumCues(pnNumCues);
}

__inline HRESULT __stdcall IXACTSoundBank_GetCueProperties(IXACTSoundBank* pSoundBank, XACTINDEX nCueIndex, LPXACT_CUE_PROPERTIES pProperties)
{
    return pSoundBank->GetCueProperties(nCueIndex, pProperties);
}

__inline HRESULT __stdcall IXACTSoundBank_Prepare(IXACTSoundBank* pSoundBank, XACTINDEX nCueIndex, DWORD dwFlags, XACTTIME timeOffset, IXACTCue** ppCue)
{
    return pSoundBank->Prepare(nCueIndex, dwFlags, timeOffset, ppCue);
}

__inline HRESULT __stdcall IXACTSoundBank_Play(IXACTSoundBank* pSoundBank, XACTINDEX nCueIndex, DWORD dwFlags, XACTTIME timeOffset, IXACTCue** ppCue)
{
    return pSoundBank->Play(nCueIndex, dwFlags, timeOffset, ppCue);
}

__inline HRESULT __stdcall IXACTSoundBank_Stop(IXACTSoundBank* pSoundBank, XACTINDEX nCueIndex, DWORD dwFlags)
{
    return pSoundBank->Stop(nCueIndex, dwFlags);
}

__inline HRESULT __stdcall IXACTSoundBank_GetState(IXACTSoundBank* pSoundBank, DWORD* pdwState)
{
    return pSoundBank->GetState(pdwState);
}

#else // __cplusplus

__inline HRESULT __stdcall IXACTSoundBank_Destroy(IXACTSoundBank* pSoundBank)
{
    return pSoundBank->lpVtbl->Destroy(pSoundBank);
}

__inline XACTINDEX __stdcall IXACTSoundBank_GetCueIndex(IXACTSoundBank* pSoundBank, PCSTR szFriendlyName)
{
    return pSoundBank->lpVtbl->GetCueIndex(pSoundBank, szFriendlyName);
}

__inline HRESULT __stdcall IXACTSoundBank_GetNumCues(IXACTSoundBank* pSoundBank, XACTINDEX* pnNumCues)
{
    return pSoundBank->lpVtbl->GetNumCues(pSoundBank, pnNumCues);
}

__inline HRESULT __stdcall IXACTSoundBank_GetCueProperties(IXACTSoundBank* pSoundBank, XACTINDEX nCueIndex, LPXACT_CUE_PROPERTIES pProperties)
{
    return pSoundBank->lpVtbl->GetCueProperties(pSoundBank, nCueIndex, pProperties);
}

__inline HRESULT __stdcall IXACTSoundBank_Prepare(IXACTSoundBank* pSoundBank, XACTINDEX nCueIndex, DWORD dwFlags, XACTTIME timeOffset, IXACTCue** ppCue)
{
    return pSoundBank->lpVtbl->Prepare(pSoundBank, nCueIndex, dwFlags, timeOffset, ppCue);
}

__inline HRESULT __stdcall IXACTSoundBank_Play(IXACTSoundBank* pSoundBank, XACTINDEX nCueIndex, DWORD dwFlags, XACTTIME timeOffset, IXACTCue** ppCue)
{
    return pSoundBank->lpVtbl->Play(pSoundBank, nCueIndex, dwFlags, timeOffset, ppCue);
}

__inline HRESULT __stdcall IXACTSoundBank_Stop(IXACTSoundBank* pSoundBank, XACTINDEX nCueIndex, DWORD dwFlags)
{
    return pSoundBank->lpVtbl->Stop(pSoundBank, nCueIndex, dwFlags);
}

__inline HRESULT __stdcall IXACTSoundBank_GetState(IXACTSoundBank* pSoundBank, DWORD* pdwState)
{
    return pSoundBank->lpVtbl->GetState(pSoundBank, pdwState);
}

#endif // __cplusplus

//------------------------------------------------------------------------------
// IXACTWaveBank
//------------------------------------------------------------------------------
#define XACT_WAVEBANKSTATE_INUSE            XACT_STATE_INUSE         // Currently in-use
#define XACT_WAVEBANKSTATE_PREPARED         XACT_STATE_PREPARED      // Prepared
#define XACT_WAVEBANKSTATE_PREPAREFAILED    XACT_STATE_PREPAREFAILED // Prepare failed.


STDAPI IXACTWaveBank_Destroy(IXACTWaveBank* pWaveBank);
STDAPI IXACTWaveBank_GetState(IXACTWaveBank* pWaveBank, DWORD* pdwState);
STDAPI IXACTWaveBank_GetNumWaves(IXACTWaveBank* pWaveBank, XACTINDEX* pnNumWaves);
STDAPI_(XACTINDEX) IXACTWaveBank_GetWaveIndex(IXACTWaveBank* pWaveBank, PCSTR szFriendlyName);
STDAPI IXACTWaveBank_GetWaveProperties(IXACTWaveBank* pWaveBank, XACTINDEX nWaveIndex, LPXACT_WAVE_PROPERTIES pWaveProperties);
STDAPI IXACTWaveBank_Prepare(IXACTWaveBank* pWaveBank, XACTINDEX nWaveIndex, DWORD dwFlags, DWORD dwPlayOffset, XACTLOOPCOUNT nLoopCount, IXACTWave** ppWave);
STDAPI IXACTWaveBank_Play(IXACTWaveBank* pWaveBank, XACTINDEX nWaveIndex, DWORD dwFlags, DWORD dwPlayOffset, XACTLOOPCOUNT nLoopCount, IXACTWave** ppWave);
STDAPI IXACTWaveBank_Stop(IXACTWaveBank* pWaveBank, XACTINDEX nWaveIndex, DWORD dwFlags);

#undef INTERFACE
#define INTERFACE IXACTWaveBank

DECLARE_INTERFACE(IXACTWaveBank)
{
    STDMETHOD(Destroy)(THIS) PURE;
    STDMETHOD(GetNumWaves)(THIS_ XACTINDEX* pnNumWaves) PURE;
    STDMETHOD_(XACTINDEX, GetWaveIndex)(THIS_ PCSTR szFriendlyName) PURE;
    STDMETHOD(GetWaveProperties)(THIS_ XACTINDEX nWaveIndex, LPXACT_WAVE_PROPERTIES pWaveProperties) PURE;
    STDMETHOD(Prepare)(THIS_ XACTINDEX nWaveIndex, DWORD dwFlags, DWORD dwPlayOffset, XACTLOOPCOUNT nLoopCount, IXACTWave** ppWave) PURE;
    STDMETHOD(Play)(THIS_ XACTINDEX nWaveIndex, DWORD dwFlags, DWORD dwPlayOffset, XACTLOOPCOUNT nLoopCount, IXACTWave** ppWave) PURE;
    STDMETHOD(Stop)(THIS_ XACTINDEX nWaveIndex, DWORD dwFlags) PURE;
    STDMETHOD(GetState)(THIS_ DWORD* pdwState) PURE;
};

#ifdef __cplusplus

__inline HRESULT __stdcall IXACTWaveBank_Destroy(IXACTWaveBank* pWaveBank)
{
    return pWaveBank->Destroy();
}

__inline HRESULT __stdcall IXACTWaveBank_GetNumWaves(IXACTWaveBank* pWaveBank, XACTINDEX* pnNumWaves)
{
    return pWaveBank->GetNumWaves(pnNumWaves);
}

__inline XACTINDEX __stdcall IXACTWaveBank_GetWaveIndex(IXACTWaveBank* pWaveBank, PCSTR szFriendlyName)
{
    return pWaveBank->GetWaveIndex(szFriendlyName);
}

__inline HRESULT __stdcall IXACTWaveBank_GetWaveProperties(IXACTWaveBank* pWaveBank, XACTINDEX nWaveIndex, LPXACT_WAVE_PROPERTIES pWaveProperties)
{
    return pWaveBank->GetWaveProperties(nWaveIndex, pWaveProperties);
}

__inline HRESULT __stdcall IXACTWaveBank_Prepare(IXACTWaveBank* pWaveBank, XACTINDEX nWaveIndex, DWORD dwFlags, DWORD dwPlayOffset, XACTLOOPCOUNT nLoopCount, IXACTWave** ppWave)
{
    return pWaveBank->Prepare(nWaveIndex, dwFlags, dwPlayOffset, nLoopCount, ppWave);
}

__inline HRESULT __stdcall IXACTWaveBank_Play(IXACTWaveBank* pWaveBank, XACTINDEX nWaveIndex, DWORD dwFlags, DWORD dwPlayOffset, XACTLOOPCOUNT nLoopCount, IXACTWave** ppWave)
{
    return pWaveBank->Play(nWaveIndex, dwFlags, dwPlayOffset, nLoopCount, ppWave);
}

__inline HRESULT __stdcall IXACTWaveBank_Stop(IXACTWaveBank* pWaveBank, XACTINDEX nWaveIndex, DWORD dwFlags)
{
    return pWaveBank->Stop(nWaveIndex, dwFlags);
}

__inline HRESULT __stdcall IXACTWaveBank_GetState(IXACTWaveBank* pWaveBank, DWORD* pdwState)
{
    return pWaveBank->GetState(pdwState);
}

#else // __cplusplus

__inline HRESULT __stdcall IXACTWaveBank_Destroy(IXACTWaveBank* pWaveBank)
{
    return pWaveBank->lpVtbl->Destroy(pWaveBank);
}

__inline HRESULT __stdcall IXACTWaveBank_GetNumWaves(IXACTWaveBank* pWaveBank, XACTINDEX* pnNumWaves)
{
    return pWaveBank->lpVtbl->GetNumWaves(pWaveBank, pnNumWaves);
}

__inline XACTINDEX __stdcall IXACTWaveBank_GetWaveIndex(IXACTWaveBank* pWaveBank, PCSTR szFriendlyName)
{
    return pWaveBank->lpVtbl->GetWaveIndex(pWaveBank, szFriendlyName);
}

__inline HRESULT __stdcall IXACTWaveBank_GetWaveProperties(IXACTWaveBank* pWaveBank, XACTINDEX nWaveIndex, LPXACT_WAVE_PROPERTIES pWaveProperties)
{
    return pWaveBank->lpVtbl->GetWaveProperties(pWaveBank, nWaveIndex, pWaveProperties);
}

__inline HRESULT __stdcall IXACTWaveBank_Prepare(IXACTWaveBank* pWaveBank, XACTINDEX nWaveIndex, DWORD dwFlags, DWORD dwPlayOffset, XACTLOOPCOUNT nLoopCount, IXACTWave** ppWave)
{
    return pWaveBank->lpVtbl->Prepare(pWaveBank, nWaveIndex, dwFlags, dwPlayOffset, nLoopCount, ppWave);
}

__inline HRESULT __stdcall IXACTWaveBank_Play(IXACTWaveBank* pWaveBank, XACTINDEX nWaveIndex, DWORD dwFlags, DWORD dwPlayOffset, XACTLOOPCOUNT nLoopCount, IXACTWave** ppWave)
{
    return pWaveBank->lpVtbl->Play(pWaveBank, nWaveIndex, dwFlags, dwPlayOffset, nLoopCount, ppWave);
}

__inline HRESULT __stdcall IXACTWaveBank_Stop(IXACTWaveBank* pWaveBank, XACTINDEX nWaveIndex, DWORD dwFlags)
{
    return pWaveBank->lpVtbl->Stop(pWaveBank, nWaveIndex, dwFlags);
}

__inline HRESULT __stdcall IXACTWaveBank_GetState(IXACTWaveBank* pWaveBank, DWORD* pdwState)
{
    return pWaveBank->lpVtbl->GetState(pWaveBank, pdwState);
}
#endif // __cplusplus


//------------------------------------------------------------------------------
// IXACTWave
//------------------------------------------------------------------------------

STDAPI IXACTWave_Destroy(IXACTWave* pWave);
STDAPI IXACTWave_Play(IXACTWave* pWave);
STDAPI IXACTWave_Stop(IXACTWave* pWave, DWORD dwFlags);
STDAPI IXACTWave_Pause(IXACTWave* pWave, BOOL fPause);
STDAPI IXACTWave_GetState(IXACTWave* pWave, DWORD* pdwState);
STDAPI IXACTWave_SetPitch(IXACTWave* pWave, XACTPITCH pitch);
STDAPI IXACTWave_SetVolume(IXACTWave* pWave, XACTVOLUME volume);
STDAPI IXACTWave_SetMatrixCoefficients(IXACTWave* pWave, UINT32 uSrcChannelCount, UINT32 uDstChannelCount, float* pMatrixCoefficients);
STDAPI IXACTWave_GetProperties(IXACTWave* pWave, LPXACT_WAVE_INSTANCE_PROPERTIES pProperties);

#undef INTERFACE
#define INTERFACE IXACTWave

DECLARE_INTERFACE(IXACTWave)
{
    STDMETHOD(Destroy)(THIS) PURE;
    STDMETHOD(Play)(THIS) PURE;
    STDMETHOD(Stop)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD(Pause)(THIS_ BOOL fPause) PURE;
    STDMETHOD(GetState)(THIS_ DWORD* pdwState) PURE;
    STDMETHOD(SetPitch)(THIS_ XACTPITCH pitch) PURE;
    STDMETHOD(SetVolume)(THIS_ XACTVOLUME volume) PURE;
    STDMETHOD(SetMatrixCoefficients)(THIS_ UINT32 uSrcChannelCount, UINT32 uDstChannelCount, float* pMatrixCoefficients) PURE;
    STDMETHOD(GetProperties)(THIS_ LPXACT_WAVE_INSTANCE_PROPERTIES pProperties) PURE;
};

#ifdef __cplusplus

__inline HRESULT __stdcall IXACTWave_Destroy(IXACTWave* pWave)
{
    return pWave->Destroy();
}

__inline HRESULT __stdcall IXACTWave_Play(IXACTWave* pWave)
{
    return pWave->Play();
}

__inline HRESULT __stdcall IXACTWave_Stop(IXACTWave* pWave, DWORD dwFlags)
{
    return pWave->Stop(dwFlags);
}

__inline HRESULT __stdcall IXACTWave_Pause(IXACTWave* pWave, BOOL fPause)
{
    return pWave->Pause(fPause);
}

__inline HRESULT __stdcall IXACTWave_GetState(IXACTWave* pWave, DWORD* pdwState)
{
    return pWave->GetState(pdwState);
}

__inline HRESULT __stdcall IXACTWave_SetPitch(IXACTWave* pWave, XACTPITCH pitch)
{
    return pWave->SetPitch(pitch);
}

__inline HRESULT __stdcall IXACTWave_SetVolume(IXACTWave* pWave, XACTVOLUME volume)
{
    return pWave->SetVolume(volume);
}

__inline HRESULT __stdcall IXACTWave_SetMatrixCoefficients(IXACTWave* pWave, UINT32 uSrcChannelCount, UINT32 uDstChannelCount, float* pMatrixCoefficients)
{
    return pWave->SetMatrixCoefficients(uSrcChannelCount, uDstChannelCount, pMatrixCoefficients);
}

__inline HRESULT __stdcall IXACTWave_GetProperties(IXACTWave* pWave, LPXACT_WAVE_INSTANCE_PROPERTIES pProperties)
{
    return pWave->GetProperties(pProperties);
}

#else // __cplusplus

__inline HRESULT __stdcall IXACTWave_Destroy(IXACTWave* pWave)
{
    return pWave->lpVtbl->Destroy(pWave);
}

__inline HRESULT __stdcall IXACTWave_Play(IXACTWave* pWave)
{
    return pWave->lpVtbl->Play(pWave);
}

__inline HRESULT __stdcall IXACTWave_Stop(IXACTWave* pWave, DWORD dwFlags)
{
    return pWave->lpVtbl->Stop(pWave, dwFlags);
}

__inline HRESULT __stdcall IXACTWave_Pause(IXACTWave* pWave, BOOL fPause)
{
    return pWave->lpVtbl->Pause(pWave, fPause);
}

__inline HRESULT __stdcall IXACTWave_GetState(IXACTWave* pWave, DWORD* pdwState)
{
    return pWave->lpVtbl->GetState(pWave, pdwState);
}

__inline HRESULT __stdcall IXACTWave_SetPitch(IXACTWave* pWave, XACTPITCH pitch)
{
    return pWave->lpVtbl->SetPitch(pWave, pitch);
}

__inline HRESULT __stdcall IXACTWave_SetVolume(IXACTWave* pWave, XACTVOLUME volume)
{
    return pWave->lpVtbl->SetVolume(pWave, volume);
}

__inline HRESULT __stdcall IXACTWave_SetMatrixCoefficients(IXACTWave* pWave, UINT32 uSrcChannelCount, UINT32 uDstChannelCount, float* pMatrixCoefficients)
{
    return pWave->lpVtbl->SetMatrixCoefficients(pWave, uSrcChannelCount, uDstChannelCount, pMatrixCoefficients);
}

__inline HRESULT __stdcall IXACTWave_GetProperties(IXACTWave* pWave, LPXACT_WAVE_INSTANCE_PROPERTIES pProperties)
{
    return pWave->lpVtbl->GetProperties(pWave, pProperties);
}
#endif // __cplusplus

//------------------------------------------------------------------------------
// IXACTCue
//------------------------------------------------------------------------------

// Cue Flags
#define XACT_FLAG_CUE_STOP_RELEASE      XACT_FLAG_STOP_RELEASE
#define XACT_FLAG_CUE_STOP_IMMEDIATE    XACT_FLAG_STOP_IMMEDIATE

// Mutually exclusive states
#define XACT_CUESTATE_CREATED           XACT_STATE_CREATED   // Created, but nothing else
#define XACT_CUESTATE_PREPARING         XACT_STATE_PREPARING // In the middle of preparing
#define XACT_CUESTATE_PREPARED          XACT_STATE_PREPARED  // Prepared, but not yet played
#define XACT_CUESTATE_PLAYING           XACT_STATE_PLAYING   // Playing (though could be paused)
#define XACT_CUESTATE_STOPPING          XACT_STATE_STOPPING  // Stopping
#define XACT_CUESTATE_STOPPED           XACT_STATE_STOPPED   // Stopped
#define XACT_CUESTATE_PAUSED            XACT_STATE_PAUSED    // Paused (can be combined with other states)

STDAPI IXACTCue_Destroy(IXACTCue* pCue);
STDAPI IXACTCue_Play(IXACTCue* pCue);
STDAPI IXACTCue_Stop(IXACTCue* pCue, DWORD dwFlags);
STDAPI IXACTCue_GetState(IXACTCue* pCue, DWORD* pdwState);
STDAPI IXACTCue_GetChannelMap(IXACTCue*, LPXACTCHANNELMAP pChannelMap, DWORD BufferSize, LPDWORD pRequiredSize);
STDAPI IXACTCue_SetChannelMap(IXACTCue*, LPCXACTCHANNELMAP pChannelMap);
STDAPI IXACTCue_GetChannelVolume(IXACTCue*, LPXACTCHANNELVOLUME pVolume);
STDAPI IXACTCue_SetChannelVolume(IXACTCue*, LPCXACTCHANNELVOLUME pVolume);
STDAPI IXACTCue_SetMatrixCoefficients(IXACTCue*, UINT32 uSrcChannelCount, UINT32 uDstChannelCount, float* pMatrixCoefficients);
STDAPI_(XACTVARIABLEINDEX) IXACTCue_GetVariableIndex(IXACTCue* pCue, PCSTR szFriendlyName);
STDAPI IXACTCue_SetVariable(IXACTCue* pCue, XACTVARIABLEINDEX nIndex, XACTVARIABLEVALUE nValue);
STDAPI IXACTCue_GetVariable(IXACTCue* pCue, XACTVARIABLEINDEX nIndex, XACTVARIABLEVALUE* nValue);
STDAPI IXACTCue_Pause(IXACTCue* pCue, BOOL fPause);
STDAPI IXACTCue_GetProperties(IXACTCue* pCue, LPXACT_CUE_INSTANCE_PROPERTIES* ppProperties);
#ifdef _XBOX
STDAPI IXACTCue_SetVoiceOutput(IXACTCue*, LPCXAUDIOVOICEOUTPUT pVoiceOutput);
STDAPI IXACTCue_SetVoiceOutputVolume(IXACTCue*, LPCXAUDIOVOICEOUTPUTVOLUME pVolume);
#endif // _XBOX

#undef INTERFACE
#define INTERFACE IXACTCue

DECLARE_INTERFACE(IXACTCue)
{
    STDMETHOD(Play)(THIS) PURE;
    STDMETHOD(Stop)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD(GetState)(THIS_ DWORD* pdwState) PURE;
    STDMETHOD(Destroy)(THIS) PURE;
    STDMETHOD(GetChannelMap)(THIS_ LPXACTCHANNELMAP pChannelMap, DWORD BufferSize, LPDWORD pRequiredSize) PURE;
    STDMETHOD(SetChannelMap)(THIS_ LPCXACTCHANNELMAP pChannelMap) PURE;
    STDMETHOD(GetChannelVolume)(THIS_ LPXACTCHANNELVOLUME pVolume) PURE;
    STDMETHOD(SetChannelVolume)(THIS_ LPCXACTCHANNELVOLUME pVolume) PURE;
    STDMETHOD(SetMatrixCoefficients)(THIS_ UINT32 uSrcChannelCount, UINT32 uDstChannelCount, float* pMatrixCoefficients) PURE;
    STDMETHOD_(XACTVARIABLEINDEX, GetVariableIndex)(THIS_ PCSTR szFriendlyName) PURE;
    STDMETHOD(SetVariable)(THIS_ XACTVARIABLEINDEX nIndex, XACTVARIABLEVALUE nValue) PURE;
    STDMETHOD(GetVariable)(THIS_ XACTVARIABLEINDEX nIndex, XACTVARIABLEVALUE* nValue) PURE;
    STDMETHOD(Pause)(THIS_ BOOL fPause) PURE;
    STDMETHOD(GetProperties)(THIS_ LPXACT_CUE_INSTANCE_PROPERTIES* ppProperties) PURE;
#ifdef _XBOX
    STDMETHOD(SetVoiceOutput)(THIS_ LPCXAUDIOVOICEOUTPUT pVoiceOutput) PURE;
    STDMETHOD(SetVoiceOutputVolume)(THIS_ LPCXAUDIOVOICEOUTPUTVOLUME pVolume) PURE;
#endif // _XBOX
};

#ifdef __cplusplus

__inline HRESULT __stdcall IXACTCue_Play(IXACTCue* pCue)
{
    return pCue->Play();
}

__inline HRESULT __stdcall IXACTCue_Stop(IXACTCue* pCue, DWORD dwFlags)
{
    return pCue->Stop(dwFlags);
}

__inline HRESULT __stdcall IXACTCue_GetState(IXACTCue* pCue, DWORD* pdwState)
{
    return pCue->GetState(pdwState);
}

__inline HRESULT __stdcall IXACTCue_Destroy(IXACTCue* pCue)
{
    return pCue->Destroy();
}

__inline HRESULT __stdcall IXACTCue_GetChannelMap(IXACTCue* pCue, LPXACTCHANNELMAP pChannelMap, DWORD BufferSize, LPDWORD pRequiredSize)
{
    return pCue->GetChannelMap(pChannelMap, BufferSize, pRequiredSize);
}

__inline HRESULT __stdcall IXACTCue_SetChannelMap(IXACTCue* pCue, LPCXACTCHANNELMAP pChannelMap)
{
    return pCue->SetChannelMap(pChannelMap);
}

__inline HRESULT __stdcall IXACTCue_GetChannelVolume(IXACTCue* pCue, LPXACTCHANNELVOLUME pVolume)
{
    return pCue->GetChannelVolume(pVolume);
}

__inline HRESULT __stdcall IXACTCue_SetChannelVolume(IXACTCue* pCue, LPCXACTCHANNELVOLUME pVolume)
{
    return pCue->SetChannelVolume(pVolume);
}

__inline HRESULT __stdcall IXACTCue_SetMatrixCoefficients(IXACTCue* pCue, UINT32 uSrcChannelCount, UINT32 uDstChannelCount, float* pMatrixCoefficients)
{
    return pCue->SetMatrixCoefficients(uSrcChannelCount, uDstChannelCount, pMatrixCoefficients);
}

__inline XACTVARIABLEINDEX __stdcall IXACTCue_GetVariableIndex(IXACTCue* pCue, PCSTR szFriendlyName)
{
    return pCue->GetVariableIndex(szFriendlyName);
}

__inline HRESULT __stdcall IXACTCue_SetVariable(IXACTCue* pCue, XACTVARIABLEINDEX nIndex, XACTVARIABLEVALUE nValue)
{
    return pCue->SetVariable(nIndex, nValue);
}

__inline HRESULT __stdcall IXACTCue_GetVariable(IXACTCue* pCue, XACTVARIABLEINDEX nIndex, XACTVARIABLEVALUE* pnValue)
{
    return pCue->GetVariable(nIndex, pnValue);
}

__inline HRESULT __stdcall IXACTCue_Pause(IXACTCue* pCue, BOOL fPause)
{
    return pCue->Pause(fPause);
}

__inline HRESULT __stdcall IXACTCue_GetProperties(IXACTCue* pCue, LPXACT_CUE_INSTANCE_PROPERTIES* ppProperties)
{
    return pCue->GetProperties(ppProperties);
}

#ifdef _XBOX
__inline HRESULT __stdcall IXACTCue_SetVoiceOutput(IXACTCue* pCue, LPCXAUDIOVOICEOUTPUT pVoiceOutput)
{
    return pCue->SetVoiceOutput(pVoiceOutput);
}

__inline HRESULT __stdcall IXACTCue_SetVoiceOutputVolume(IXACTCue* pCue, LPCXAUDIOVOICEOUTPUTVOLUME pVolume)
{
    return pCue->SetVoiceOutputVolume(pVolume);
}
#endif // _XBOX

#else // __cplusplus

__inline HRESULT __stdcall IXACTCue_Play(IXACTCue* pCue)
{
    return pCue->lpVtbl->Play(pCue);
}

__inline HRESULT __stdcall IXACTCue_Stop(IXACTCue* pCue, DWORD dwFlags)
{
    return pCue->lpVtbl->Stop(pCue, dwFlags);
}

__inline HRESULT __stdcall IXACTCue_GetState(IXACTCue* pCue, DWORD* pdwState)
{
    return pCue->lpVtbl->GetState(pCue, pdwState);
}

__inline HRESULT __stdcall IXACTCue_Destroy(IXACTCue* pCue)
{
    return pCue->lpVtbl->Destroy(pCue);
}

__inline HRESULT __stdcall IXACTCue_GetChannelMap(IXACTCue* pCue, LPXACTCHANNELMAP pChannelMap, DWORD BufferSize, LPDWORD pRequiredSize)
{
    return pCue->lpVtbl->GetChannelMap(pCue, pChannelMap, BufferSize, pRequiredSize);
}

__inline HRESULT __stdcall IXACTCue_SetChannelMap(IXACTCue* pCue, LPCXACTCHANNELMAP pChannelMap)
{
    return pCue->lpVtbl->SetChannelMap(pCue, pChannelMap);
}

__inline HRESULT __stdcall IXACTCue_GetChannelVolume(IXACTCue* pCue, LPXACTCHANNELVOLUME pVolume)
{
    return pCue->lpVtbl->GetChannelVolume(pCue, pVolume);
}

__inline HRESULT __stdcall IXACTCue_SetChannelVolume(IXACTCue* pCue, LPCXACTCHANNELVOLUME pVolume)
{
    return pCue->lpVtbl->SetChannelVolume(pCue, pVolume);
}

__inline HRESULT __stdcall IXACTCue_SetMatrixCoefficients(IXACTCue* pCue, UINT32 uSrcChannelCount, UINT32 uDstChannelCount, float* pMatrixCoefficients)
{
    return pCue->lpVtbl->SetMatrixCoefficients(pCue, uSrcChannelCount, uDstChannelCount, pMatrixCoefficients);
}

__inline XACTVARIABLEINDEX __stdcall IXACTCue_GetVariableIndex(IXACTCue* pCue, PCSTR szFriendlyName)
{
    return pCue->lpVtbl->GetVariableIndex(pCue, szFriendlyName);
}

__inline HRESULT __stdcall IXACTCue_SetVariable(IXACTCue* pCue, XACTVARIABLEINDEX nIndex, XACTVARIABLEVALUE nValue)
{
    return pCue->lpVtbl->SetVariable(pCue, nIndex, nValue);
}

__inline HRESULT __stdcall IXACTCue_GetVariable(IXACTCue* pCue, XACTVARIABLEINDEX nIndex, XACTVARIABLEVALUE* pnValue)
{
    return pCue->lpVtbl->GetVariable(pCue, nIndex, pnValue);
}

__inline HRESULT __stdcall IXACTCue_Pause(IXACTCue* pCue, BOOL fPause)
{
    return pCue->lpVtbl->Pause(pCue, fPause);
}

__inline HRESULT __stdcall IXACTCue_GetProperties(IXACTCue* pCue, LPXACT_CUE_INSTANCE_PROPERTIES* ppProperties)
{
    return pCue->lpVtbl->GetProperties(pCue, ppProperties);
}

#ifdef _XBOX
__inline HRESULT __stdcall IXACTCue_SetVoiceOutput(IXACTCue* pCue, LPCXAUDIOVOICEOUTPUT pVoiceOutput)
{
    return pCue->lpVtbl->SetVoiceOutput(pCue, pVoiceOutput);
}

__inline HRESULT __stdcall IXACTCue_SetVoiceOutputVolume(IXACTCue* pCue, LPCXAUDIOVOICEOUTPUTVOLUME pVolume)
{
    return pCue->lpVtbl->SetVoiceOutputVolume(pCue, pVolume);
}
#endif // _XBOX

#endif // __cplusplus

//------------------------------------------------------------------------------
// IXACTEngine
//------------------------------------------------------------------------------

// Engine flags
#define XACT_FLAG_ENGINE_CREATE_MANAGEDATA    XACT_FLAG_MANAGEDATA
#define XACT_FLAG_ENGINE_STOP_IMMEDIATE       XACT_FLAG_STOP_IMMEDIATE

STDAPI_(ULONG) IXACTEngine_AddRef(IXACTEngine* pEngine);
STDAPI_(ULONG) IXACTEngine_Release(IXACTEngine* pEngine);
#ifndef _XBOX
STDAPI IXACTEngine_GetRendererCount(IXACTEngine* pEngine, XACTINDEX* pnRendererCount);
STDAPI IXACTEngine_GetRendererDetails(IXACTEngine* pEngine, XACTINDEX nRendererIndex, LPXACT_RENDERER_DETAILS pRendererDetails);
#endif
STDAPI IXACTEngine_Initialize(IXACTEngine* pEngine, const XACT_RUNTIME_PARAMETERS* pParams);
STDAPI IXACTEngine_ShutDown(IXACTEngine* pEngine);
STDAPI IXACTEngine_DoWork(IXACTEngine* pEngine);
STDAPI IXACTEngine_CreateSoundBank(IXACTEngine* pEngine, const void* pvBuffer, DWORD dwSize, DWORD dwFlags, DWORD dwAllocAttributes, IXACTSoundBank** ppSoundBank);
STDAPI IXACTEngine_CreateInMemoryWaveBank(IXACTEngine* pEngine, const void* pvBuffer, DWORD dwSize, DWORD dwFlags, DWORD dwAllocAttributes, IXACTWaveBank** ppWaveBank);
STDAPI IXACTEngine_CreateStreamingWaveBank(IXACTEngine* pEngine, const XACT_WAVEBANK_STREAMING_PARAMETERS* pParms, IXACTWaveBank** ppWaveBank);
STDAPI IXACTEngine_PrepareWave(IXACTEngine* pEngine, DWORD dwFlags, PCSTR szWavePath, WORD wStreamingPacketSize, DWORD dwAlignment, DWORD dwPlayOffset, XACTLOOPCOUNT nLoopCount, IXACTWave** ppWave);
STDAPI IXACTEngine_PrepareInMemoryWave(IXACTEngine* pEngine, DWORD dwFlags, WAVEBANKENTRY entry, DWORD* pdwSeekTable, BYTE* pbWaveData, DWORD dwPlayOffset, XACTLOOPCOUNT nLoopCount, IXACTWave** ppWave);
STDAPI IXACTEngine_PrepareStreamingWave(IXACTEngine* pEngine, DWORD dwFlags, WAVEBANKENTRY entry, XACT_STREAMING_PARAMETERS streamingParams, DWORD dwAlignment, DWORD* pdwSeekTable, DWORD dwPlayOffset, XACTLOOPCOUNT nLoopCount, IXACTWave** ppWave);
STDAPI IXACTEngine_RegisterNotification(IXACTEngine* pEngine, const XACT_NOTIFICATION_DESCRIPTION* pNotificationDesc);
STDAPI IXACTEngine_UnRegisterNotification(IXACTEngine* pEngine, const XACT_NOTIFICATION_DESCRIPTION* pNotificationDesc);
STDAPI_(XACTCATEGORY) IXACTEngine_GetCategory(IXACTEngine* pEngine, PCSTR szFriendlyName);
STDAPI IXACTEngine_Stop(IXACTEngine* pEngine, XACTCATEGORY nCategory, DWORD dwFlags);
STDAPI IXACTEngine_SetVolume(IXACTEngine* pEngine, XACTCATEGORY nCategory, XACTVOLUME nVolume);
STDAPI IXACTEngine_Pause(IXACTEngine* pEngine, XACTCATEGORY nCategory, BOOL fPause);
STDAPI_(XACTVARIABLEINDEX) IXACTEngine_GetGlobalVariableIndex(IXACTEngine* pEngine, PCSTR szFriendlyName);
STDAPI IXACTEngine_SetGlobalVariable(IXACTEngine* pEngine, XACTVARIABLEINDEX nIndex, XACTVARIABLEVALUE nValue);
STDAPI IXACTEngine_GetGlobalVariable(IXACTEngine* pEngine, XACTVARIABLEINDEX nIndex, XACTVARIABLEVALUE* pnValue);

#undef INTERFACE
#define INTERFACE IXACTEngine

#ifdef _XBOX
DECLARE_INTERFACE(IXACTEngine)
{
#else
DECLARE_INTERFACE_(IXACTEngine, IUnknown)
{
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, OUT void** ppvObj) PURE;
#endif

    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

#ifndef _XBOX
    STDMETHOD(GetRendererCount)(THIS_ XACTINDEX* pnRendererCount) PURE;
    STDMETHOD(GetRendererDetails)(THIS_ XACTINDEX nRendererIndex, LPXACT_RENDERER_DETAILS pRendererDetails) PURE;
#endif

    STDMETHOD(Initialize)(THIS_ const XACT_RUNTIME_PARAMETERS* pParams) PURE;
    STDMETHOD(ShutDown)(THIS) PURE;

    STDMETHOD(DoWork)(THIS) PURE;

    STDMETHOD(CreateSoundBank)(THIS_ const void* pvBuffer, DWORD dwSize, DWORD dwFlags, DWORD dwAllocAttributes, IXACTSoundBank** ppSoundBank) PURE;
    STDMETHOD(CreateInMemoryWaveBank)(THIS_ const void* pvBuffer, DWORD dwSize, DWORD dwFlags, DWORD dwAllocAttributes, IXACTWaveBank** ppWaveBank) PURE;
    STDMETHOD(CreateStreamingWaveBank)(THIS_ const XACT_WAVEBANK_STREAMING_PARAMETERS* pParms, IXACTWaveBank** ppWaveBank) PURE;

    STDMETHOD(PrepareWave)(THIS_ DWORD dwFlags, PCSTR szWavePath, WORD wStreamingPacketSize, DWORD dwAlignment, DWORD dwPlayOffset, XACTLOOPCOUNT nLoopCount, IXACTWave** ppWave) PURE;
    STDMETHOD(PrepareInMemoryWave)(THIS_ DWORD dwFlags, WAVEBANKENTRY entry, DWORD* pdwSeekTable, BYTE* pbWaveData, DWORD dwPlayOffset, XACTLOOPCOUNT nLoopCount, IXACTWave** ppWave) PURE;
    STDMETHOD(PrepareStreamingWave)(THIS_ DWORD dwFlags, WAVEBANKENTRY entry, XACT_STREAMING_PARAMETERS streamingParams, DWORD dwAlignment, DWORD* pdwSeekTable, DWORD dwPlayOffset, XACTLOOPCOUNT nLoopCount, IXACTWave** ppWave) PURE;

    STDMETHOD(RegisterNotification)(THIS_ const XACT_NOTIFICATION_DESCRIPTION* pNotificationDesc) PURE;
    STDMETHOD(UnRegisterNotification)(THIS_ const XACT_NOTIFICATION_DESCRIPTION* pNotificationDesc) PURE;

    STDMETHOD_(XACTCATEGORY, GetCategory)(THIS_ PCSTR szFriendlyName) PURE;
    STDMETHOD(Stop)(THIS_ XACTCATEGORY nCategory, DWORD dwFlags) PURE;
    STDMETHOD(SetVolume)(THIS_ XACTCATEGORY nCategory, XACTVOLUME nVolume) PURE;
    STDMETHOD(Pause)(THIS_ XACTCATEGORY nCategory, BOOL fPause) PURE;

    STDMETHOD_(XACTVARIABLEINDEX, GetGlobalVariableIndex)(THIS_ PCSTR szFriendlyName) PURE;
    STDMETHOD(SetGlobalVariable)(THIS_ XACTVARIABLEINDEX nIndex, XACTVARIABLEVALUE nValue) PURE;
    STDMETHOD(GetGlobalVariable)(THIS_ XACTVARIABLEINDEX nIndex, XACTVARIABLEVALUE* nValue) PURE;
};

#ifdef __cplusplus

__inline ULONG __stdcall IXACTEngine_AddRef(IXACTEngine* pEngine)
{
    return pEngine->AddRef();
}

__inline ULONG __stdcall IXACTEngine_Release(IXACTEngine* pEngine)
{
    return pEngine->Release();
}

#ifndef _XBOX
__inline HRESULT __stdcall IXACTEngine_GetRendererCount(IXACTEngine* pEngine, XACTINDEX* pnRendererCount)
{
    return pEngine->GetRendererCount(pnRendererCount);
}

__inline HRESULT __stdcall IXACTEngine_GetRendererDetails(IXACTEngine* pEngine, XACTINDEX nRendererIndex, LPXACT_RENDERER_DETAILS pRendererDetails)
{
    return pEngine->GetRendererDetails(nRendererIndex, pRendererDetails);
}
#endif

__inline HRESULT __stdcall IXACTEngine_Initialize(IXACTEngine* pEngine, const XACT_RUNTIME_PARAMETERS* pParams)
{
    return pEngine->Initialize(pParams);
}

__inline HRESULT __stdcall IXACTEngine_ShutDown(IXACTEngine* pEngine)
{
    return pEngine->ShutDown();
}

__inline HRESULT __stdcall IXACTEngine_DoWork(IXACTEngine* pEngine)
{
    return pEngine->DoWork();
}

__inline HRESULT __stdcall IXACTEngine_CreateSoundBank(IXACTEngine* pEngine, const void* pvBuffer, DWORD dwSize, DWORD dwFlags, DWORD dwAllocAttributes, IXACTSoundBank** ppSoundBank)
{
    return pEngine->CreateSoundBank(pvBuffer, dwSize, dwFlags, dwAllocAttributes, ppSoundBank);
}

__inline HRESULT __stdcall IXACTEngine_CreateInMemoryWaveBank(IXACTEngine* pEngine, const void* pvBuffer, DWORD dwSize, DWORD dwFlags, DWORD dwAllocAttributes, IXACTWaveBank** ppWaveBank)
{
    return pEngine->CreateInMemoryWaveBank(pvBuffer, dwSize, dwFlags, dwAllocAttributes, ppWaveBank);
}

__inline HRESULT __stdcall IXACTEngine_CreateStreamingWaveBank(IXACTEngine* pEngine, const XACT_WAVEBANK_STREAMING_PARAMETERS* pParms, IXACTWaveBank** ppWaveBank)
{
    return pEngine->CreateStreamingWaveBank(pParms, ppWaveBank);
}

__inline HRESULT __stdcall IXACTEngine_PrepareWave(IXACTEngine* pEngine, DWORD dwFlags, PCSTR szWavePath, WORD wStreamingPacketSize, DWORD dwAlignment, DWORD dwPlayOffset, XACTLOOPCOUNT nLoopCount, IXACTWave * * ppWave)
{
    return pEngine->PrepareWave(dwFlags, szWavePath, wStreamingPacketSize, dwAlignment, dwPlayOffset, nLoopCount, ppWave);
}

__inline HRESULT __stdcall IXACTEngine_PrepareInMemoryWave(IXACTEngine* pEngine, DWORD dwFlags, WAVEBANKENTRY entry, DWORD* pdwSeekTable, BYTE* pbWaveData, DWORD dwPlayOffset, XACTLOOPCOUNT nLoopCount, IXACTWave** ppWave)
{
    return pEngine->PrepareInMemoryWave(dwFlags, entry, pdwSeekTable, pbWaveData, dwPlayOffset, nLoopCount, ppWave);
}

__inline HRESULT __stdcall IXACTEngine_PrepareStreamingWave(IXACTEngine* pEngine, DWORD dwFlags, WAVEBANKENTRY entry, XACT_STREAMING_PARAMETERS streamingParams, DWORD dwAlignment, DWORD* pdwSeekTable, DWORD dwPlayOffset, XACTLOOPCOUNT nLoopCount, IXACTWave** ppWave)
{
    return pEngine->PrepareStreamingWave(dwFlags, entry, streamingParams, dwAlignment, pdwSeekTable, dwPlayOffset, nLoopCount, ppWave);
}

__inline HRESULT __stdcall IXACTEngine_RegisterNotification(IXACTEngine* pEngine, const XACT_NOTIFICATION_DESCRIPTION* pNotificationDesc)
{
    return pEngine->RegisterNotification(pNotificationDesc);
}

__inline HRESULT __stdcall IXACTEngine_UnRegisterNotification(IXACTEngine* pEngine, const XACT_NOTIFICATION_DESCRIPTION* pNotificationDesc)
{
    return pEngine->UnRegisterNotification(pNotificationDesc);
}

__inline XACTCATEGORY __stdcall IXACTEngine_GetCategory(IXACTEngine* pEngine, PCSTR szFriendlyName)
{
    return pEngine->GetCategory(szFriendlyName);
}

__inline HRESULT __stdcall IXACTEngine_Stop(IXACTEngine* pEngine, XACTCATEGORY nCategory, DWORD dwFlags)
{
    return pEngine->Stop(nCategory, dwFlags);
}

__inline HRESULT __stdcall IXACTEngine_SetVolume(IXACTEngine* pEngine, XACTCATEGORY nCategory, XACTVOLUME nVolume)
{
    return pEngine->SetVolume(nCategory, nVolume);
}

__inline HRESULT __stdcall IXACTEngine_Pause(IXACTEngine* pEngine, XACTCATEGORY nCategory, BOOL fPause)
{
    return pEngine->Pause(nCategory, fPause);
}

__inline XACTVARIABLEINDEX __stdcall IXACTEngine_GetGlobalVariableIndex(IXACTEngine* pEngine, PCSTR szFriendlyName)
{
    return pEngine->GetGlobalVariableIndex(szFriendlyName);
}

__inline HRESULT __stdcall IXACTEngine_SetGlobalVariable(IXACTEngine* pEngine, XACTVARIABLEINDEX nIndex, XACTVARIABLEVALUE nValue)
{
    return pEngine->SetGlobalVariable(nIndex, nValue);
}

__inline HRESULT __stdcall IXACTEngine_GetGlobalVariable(IXACTEngine* pEngine, XACTVARIABLEINDEX nIndex, XACTVARIABLEVALUE* nValue)
{
    return pEngine->GetGlobalVariable(nIndex, nValue);
}

#else // __cplusplus

__inline ULONG __stdcall IXACTEngine_AddRef(IXACTEngine* pEngine)
{
    return pEngine->lpVtbl->AddRef(pEngine);
}

__inline ULONG __stdcall IXACTEngine_Release(IXACTEngine* pEngine)
{
    return pEngine->lpVtbl->Release(pEngine);
}

#ifndef _XBOX
__inline HRESULT __stdcall IXACTEngine_GetRendererCount(IXACTEngine* pEngine, XACTINDEX* pnRendererCount)
{
    return pEngine->lpVtbl->GetRendererCount(pEngine, pnRendererCount);
}

__inline HRESULT __stdcall IXACTEngine_GetRendererDetails(IXACTEngine* pEngine, XACTINDEX nRendererIndex, LPXACT_RENDERER_DETAILS pRendererDetails)
{
    return pEngine->lpVtbl->GetRendererDetails(pEngine, nRendererIndex, pRendererDetails);
}
#endif

__inline HRESULT __stdcall IXACTEngine_Initialize(IXACTEngine* pEngine, const XACT_RUNTIME_PARAMETERS* pParams)
{
    return pEngine->lpVtbl->Initialize(pEngine, pParams);
}

__inline HRESULT __stdcall IXACTEngine_ShutDown(IXACTEngine* pEngine)
{
    return pEngine->lpVtbl->ShutDown(pEngine);
}

__inline HRESULT __stdcall IXACTEngine_DoWork(IXACTEngine* pEngine)
{
    return pEngine->lpVtbl->DoWork(pEngine);
}

__inline HRESULT __stdcall IXACTEngine_CreateSoundBank(IXACTEngine* pEngine, const void* pvBuffer, DWORD dwSize, DWORD dwFlags, DWORD dwAllocAttributes, IXACTSoundBank** ppSoundBank)
{
    return pEngine->lpVtbl->CreateSoundBank(pEngine, pvBuffer, dwSize, dwFlags, dwAllocAttributes, ppSoundBank);
}

__inline HRESULT __stdcall IXACTEngine_CreateInMemoryWaveBank(IXACTEngine* pEngine, const void* pvBuffer, DWORD dwSize, DWORD dwFlags, DWORD dwAllocAttributes, IXACTWaveBank** ppWaveBank)
{
    return pEngine->lpVtbl->CreateInMemoryWaveBank(pEngine, pvBuffer, dwSize, dwFlags, dwAllocAttributes, ppWaveBank);
}

__inline HRESULT __stdcall IXACTEngine_CreateStreamingWaveBank(IXACTEngine* pEngine, const XACT_WAVEBANK_STREAMING_PARAMETERS* pParms, IXACTWaveBank** ppWaveBank)
{
    return pEngine->lpVtbl->CreateStreamingWaveBank(pEngine, pParms, ppWaveBank);
}

__inline HRESULT __stdcall IXACTEngine_PrepareWave(IXACTEngine* pEngine, DWORD dwFlags, PCSTR szWavePath, WORD wStreamingPacketSize, DWORD dwAlignment, DWORD dwPlayOffset, XACTLOOPCOUNT nLoopCount, IXACTWave * * ppWave)
{
    return pEngine->lpVtbl->PrepareWave(pEngine, dwFlags, szWavePath, wStreamingPacketSize, dwAlignment, dwPlayOffset, nLoopCount, ppWave);
}

__inline HRESULT __stdcall IXACTEngine_PrepareInMemoryWave(IXACTEngine* pEngine, DWORD dwFlags, WAVEBANKENTRY entry, DWORD* pdwSeekTable, BYTE* pbWaveData, DWORD dwPlayOffset, XACTLOOPCOUNT nLoopCount, IXACTWave** ppWave)
{
    return pEngine->lpVtbl->PrepareInMemoryWave(pEngine, dwFlags, entry, pdwSeekTable, pbWaveData, dwPlayOffset, nLoopCount, ppWave);
}

__inline HRESULT __stdcall IXACTEngine_PrepareStreamingWave(IXACTEngine* pEngine, DWORD dwFlags, WAVEBANKENTRY entry, XACT_STREAMING_PARAMETERS streamingParams, DWORD dwAlignment, DWORD* pdwSeekTable, DWORD dwPlayOffset, XACTLOOPCOUNT nLoopCount, IXACTWave** ppWave)
{
    return pEngine->lpVtbl->PrepareStreamingWave(pEngine, dwFlags, entry, streamingParams, dwAlignment, pdwSeekTable, dwPlayOffset, nLoopCount, ppWave);
}


__inline HRESULT __stdcall IXACTEngine_RegisterNotification(IXACTEngine* pEngine, const XACT_NOTIFICATION_DESCRIPTION* pNotificationDesc)
{
    return pEngine->lpVtbl->RegisterNotification(pEngine, pNotificationDesc);
}

__inline HRESULT __stdcall IXACTEngine_UnRegisterNotification(IXACTEngine* pEngine, const XACT_NOTIFICATION_DESCRIPTION* pNotificationDesc)
{
    return pEngine->lpVtbl->UnRegisterNotification(pEngine, pNotificationDesc);
}

__inline XACTCATEGORY __stdcall IXACTEngine_GetCategory(IXACTEngine* pEngine, PCSTR szFriendlyName)
{
    return pEngine->lpVtbl->GetCategory(pEngine, szFriendlyName);
}

__inline HRESULT __stdcall IXACTEngine_Stop(IXACTEngine* pEngine, XACTCATEGORY nCategory, DWORD dwFlags)
{
    return pEngine->lpVtbl->Stop(pEngine, nCategory, dwFlags);
}

__inline HRESULT __stdcall IXACTEngine_SetVolume(IXACTEngine* pEngine, XACTCATEGORY nCategory, XACTVOLUME nVolume)
{
    return pEngine->lpVtbl->SetVolume(pEngine, nCategory, nVolume);
}

__inline HRESULT __stdcall IXACTEngine_Pause(IXACTEngine* pEngine, XACTCATEGORY nCategory, BOOL fPause)
{
    return pEngine->lpVtbl->Pause(pEngine, nCategory, fPause);
}

__inline XACTVARIABLEINDEX __stdcall IXACTEngine_GetGlobalVariableIndex(IXACTEngine* pEngine, PCSTR szFriendlyName)
{
    return pEngine->lpVtbl->GetGlobalVariableIndex(pEngine, szFriendlyName);
}

__inline HRESULT __stdcall IXACTEngine_SetGlobalVariable(IXACTEngine* pEngine, XACTVARIABLEINDEX nIndex, XACTVARIABLEVALUE nValue)
{
    return pEngine->lpVtbl->SetGlobalVariable(pEngine, nIndex, nValue);
}

__inline HRESULT __stdcall IXACTEngine_GetGlobalVariable(IXACTEngine* pEngine, XACTVARIABLEINDEX nIndex, XACTVARIABLEVALUE* nValue)
{
    return pEngine->lpVtbl->GetGlobalVariable(pEngine, nIndex, nValue);
}

#endif // __cplusplus

//------------------------------------------------------------------------------
// XACT API's (these are deprecated and will be removed in a future release)
//------------------------------------------------------------------------------

#ifdef _XBOX

#define XACT_FLAG_API_CREATE_MANAGEDATA     XACT_FLAG_MANAGEDATA
#define XACT_FLAG_API_STOP_IMMEDIATE        XACT_FLAG_STOP_IMMEDIATE

STDAPI XACTInitialize(const XACT_RUNTIME_PARAMETERS* pParams);
STDAPI XACTShutDown(void);
STDAPI XACTDoWork(void);

STDAPI XACTCreateSoundBank(const void* pvBuffer, DWORD dwSize, DWORD dwFlags, DWORD dwAllocAttributes, IXACTSoundBank** ppSoundBank);
STDAPI XACTCreateInMemoryWaveBank(const void* pvBuffer, DWORD dwSize, DWORD dwFlags, DWORD dwAllocAttributes, IXACTWaveBank** ppWaveBank);
STDAPI XACTCreateStreamingWaveBank(const XACT_WAVEBANK_STREAMING_PARAMETERS* pParms, IXACTWaveBank** ppWaveBank);

STDAPI XACTRegisterNotification(const XACT_NOTIFICATION_DESCRIPTION* pNotificationDesc);
STDAPI XACTUnRegisterNotification(const XACT_NOTIFICATION_DESCRIPTION* pNotificationDesc);

STDAPI_(XACTCATEGORY) XACTGetCategory(PCSTR szFriendlyName);
STDAPI XACTStop(XACTCATEGORY nCategory, DWORD dwFlags);
STDAPI XACTSetVolume(XACTCATEGORY nCategory, XACTVOLUME nVolume);
STDAPI XACTPause(XACTCATEGORY nCategory, BOOL fPause);

STDAPI_(XACTVARIABLEINDEX) XACTGetGlobalVariableIndex(PCSTR szFriendlyName);
STDAPI XACTSetGlobalVariable(XACTVARIABLEINDEX nIndex, XACTVARIABLEVALUE nValue);
STDAPI XACTGetGlobalVariable(XACTVARIABLEINDEX nIndex, XACTVARIABLEVALUE* pnValue);

#endif // #ifdef _XBOX

//------------------------------------------------------------------------------
// Create Engine
//------------------------------------------------------------------------------

// Flags used only in XACTCreateEngine below.  These flags are valid but ignored
// when building for Xbox 360; to enable auditioning on that platform you must
// link explicitly to an auditioning version of the XACT static library.
static const DWORD XACT_FLAG_API_AUDITION_MODE = 0x00000001;
static const DWORD XACT_FLAG_API_DEBUG_MODE    = 0x00000002;

STDAPI XACTCreateEngine(DWORD dwCreationFlags, IXACTEngine** ppEngine);

#ifndef _XBOX

#if defined (UNICODE)
#   define XACT_DEBUGENGINE_REGISTRY_KEY   L"Software\\Microsoft\\XACT"
#   define XACT_DEBUGENGINE_REGISTRY_VALUE L"DebugEngine"
#else
#   define XACT_DEBUGENGINE_REGISTRY_KEY   "Software\\Microsoft\\XACT"
#   define XACT_DEBUGENGINE_REGISTRY_VALUE "DebugEngine"
#endif

#ifdef __cplusplus

__inline HRESULT __stdcall XACTCreateEngine(DWORD dwCreationFlags, IXACTEngine** ppEngine)
{
    HRESULT hr;
    HKEY    key;
    DWORD   data;
    DWORD   type     = REG_DWORD;
    DWORD   dataSize = sizeof(DWORD);
    BOOL    debug    = (dwCreationFlags & XACT_FLAG_API_DEBUG_MODE) ? TRUE : FALSE;
    BOOL    audition = (dwCreationFlags & XACT_FLAG_API_AUDITION_MODE) ? TRUE : FALSE;

    // If neither the debug nor audition flags are set, see if the debug registry key is set
    if(!debug && !audition &&
       (RegOpenKeyEx(HKEY_LOCAL_MACHINE, XACT_DEBUGENGINE_REGISTRY_KEY, 0, KEY_READ, &key) == ERROR_SUCCESS))
    {
        if(RegQueryValueEx(key, XACT_DEBUGENGINE_REGISTRY_VALUE, NULL, &type, (LPBYTE)&data, &dataSize) == ERROR_SUCCESS)
        {
            if(data)
            {
                debug = TRUE;
            }
        }
        RegCloseKey(key);
    }

    // Priority order: Audition, Debug, Retail
    hr = CoCreateInstance(audition ? __uuidof(XACTAuditionEngine)
                          : (debug ? __uuidof(XACTDebugEngine) : __uuidof(XACTEngine)),
                          NULL, CLSCTX_INPROC_SERVER, __uuidof(IXACTEngine), (void**)ppEngine);

    // If debug engine does not exist fallback to retail version
    if(FAILED(hr) && debug && !audition)
    {
        hr = CoCreateInstance(__uuidof(XACTEngine), NULL, CLSCTX_INPROC_SERVER, __uuidof(IXACTEngine), (void**)ppEngine);
    }

    return hr;
}

#else

__inline HRESULT __stdcall XACTCreateEngine(DWORD dwCreationFlags, IXACTEngine** ppEngine)
{
    HRESULT hr;
    HKEY    key;
    DWORD   data;
    DWORD   type     = REG_DWORD;
    DWORD   dataSize = sizeof(DWORD);
    BOOL    debug    = (dwCreationFlags & XACT_FLAG_API_DEBUG_MODE) ? TRUE : FALSE;
    BOOL    audition = (dwCreationFlags & XACT_FLAG_API_AUDITION_MODE) ? TRUE : FALSE;

    // If neither the debug nor audition flags are set, see if the debug registry key is set
    if(!debug && !audition &&
       (RegOpenKeyEx(HKEY_LOCAL_MACHINE, XACT_DEBUGENGINE_REGISTRY_KEY, 0, KEY_READ, &key) == ERROR_SUCCESS))
    {
        if(RegQueryValueEx(key, XACT_DEBUGENGINE_REGISTRY_VALUE, NULL, &type, (LPBYTE)&data, &dataSize) == ERROR_SUCCESS)
        {
            if(data)
            {
                debug = TRUE;
            }
        }
        RegCloseKey(key);
    }

    // Priority order: Audition, Debug, Retail
    hr = CoCreateInstance(audition ? &CLSID_XACTAuditionEngine
                          : (debug ? &CLSID_XACTDebugEngine : &CLSID_XACTEngine),
                          NULL, CLSCTX_INPROC_SERVER, &IID_IXACTEngine, (void**)ppEngine);

    // If debug engine does not exist fallback to retail version
    if(FAILED(hr) && debug && !audition)
    {
        hr = CoCreateInstance(&CLSID_XACTEngine, NULL, CLSCTX_INPROC_SERVER, &IID_IXACTEngine, (void**)ppEngine);
    }

    return hr;
}

#endif // #ifdef __cplusplus
#endif // #ifndef _XBOX

//------------------------------------------------------------------------------
// XACT specific error codes
//------------------------------------------------------------------------------

#define FACILITY_XACTENGINE 0xAC7
#define XACTENGINEERROR(n) MAKE_HRESULT(SEVERITY_ERROR, FACILITY_XACTENGINE, n)

#define XACTENGINE_E_OUTOFMEMORY               E_OUTOFMEMORY      // Out of memory
#define XACTENGINE_E_INVALIDARG                E_INVALIDARG       // Invalid arg
#define XACTENGINE_E_NOTIMPL                   E_NOTIMPL          // Not implemented
#define XACTENGINE_E_FAIL                      E_FAIL             // Unknown error

#define XACTENGINE_E_ALREADYINITIALIZED        XACTENGINEERROR(0x001)   // The engine is already initialized
#define XACTENGINE_E_NOTINITIALIZED            XACTENGINEERROR(0x002)   // The engine has not been initialized
#define XACTENGINE_E_EXPIRED                   XACTENGINEERROR(0x003)   // The engine has expired (demo or pre-release version)
#define XACTENGINE_E_NONOTIFICATIONCALLBACK    XACTENGINEERROR(0x004)   // No notification callback
#define XACTENGINE_E_NOTIFICATIONREGISTERED    XACTENGINEERROR(0x005)   // Notification already registered
#define XACTENGINE_E_INVALIDUSAGE              XACTENGINEERROR(0x006)   // Invalid usage
#define XACTENGINE_E_INVALIDDATA               XACTENGINEERROR(0x007)   // Invalid data
#define XACTENGINE_E_INSTANCELIMITFAILTOPLAY   XACTENGINEERROR(0x008)   // Fail to play due to instance limit
#define XACTENGINE_E_NOGLOBALSETTINGS          XACTENGINEERROR(0x009)   // Global Settings not loaded
#define XACTENGINE_E_INVALIDVARIABLEINDEX      XACTENGINEERROR(0x00a)   // Invalid variable index
#define XACTENGINE_E_INVALIDCATEGORY           XACTENGINEERROR(0x00b)   // Invalid category
#define XACTENGINE_E_INVALIDCUEINDEX           XACTENGINEERROR(0x00c)   // Invalid cue index
#define XACTENGINE_E_INVALIDWAVEINDEX          XACTENGINEERROR(0x00d)   // Invalid wave index
#define XACTENGINE_E_INVALIDTRACKINDEX         XACTENGINEERROR(0x00e)   // Invalid track index
#define XACTENGINE_E_INVALIDSOUNDOFFSETORINDEX XACTENGINEERROR(0x00f)   // Invalid sound offset or index
#define XACTENGINE_E_READFILE                  XACTENGINEERROR(0x010)   // Error reading a file
#define XACTENGINE_E_UNKNOWNEVENT              XACTENGINEERROR(0x011)   // Unknown event type
#define XACTENGINE_E_INCALLBACK                XACTENGINEERROR(0x012)   // Invalid call of method of function from callback
#define XACTENGINE_E_NOWAVEBANK                XACTENGINEERROR(0x013)   // No wavebank exists for desired operation
#define XACTENGINE_E_SELECTVARIATION           XACTENGINEERROR(0x014)   // Unable to select a variation
#define XACTENGINE_E_MULTIPLEAUDITIONENGINES   XACTENGINEERROR(0x015)   // There can be only one audition engine
#define XACTENGINE_E_WAVEBANKNOTPREPARED       XACTENGINEERROR(0x016)   // The wavebank is not prepared
#define XACTENGINE_E_NORENDERER                XACTENGINEERROR(0x017)   // No audio device found on.
#define XACTENGINE_E_INVALIDENTRYCOUNT         XACTENGINEERROR(0x018)   // Invalid entry count for channel maps
#define XACTENGINE_E_SEEKTIMEBEYONDCUEEND      XACTENGINEERROR(0x019)   // Time offset for seeking is beyond the cue end.
#define XACTENGINE_E_SEEKTIMEBEYONDWAVEEND     XACTENGINEERROR(0x019)   // Time offset for seeking is beyond the wave end.
#define XACTENGINE_E_NOFRIENDLYNAMES           XACTENGINEERROR(0x01a)   // Friendly names are not included in the bank.

#define XACTENGINE_E_AUDITION_WRITEFILE             XACTENGINEERROR(0x101)  // Error writing a file during auditioning
#define XACTENGINE_E_AUDITION_NOSOUNDBANK           XACTENGINEERROR(0x102)  // Missing a soundbank
#define XACTENGINE_E_AUDITION_INVALIDRPCINDEX       XACTENGINEERROR(0x103)  // Missing an RPC curve
#define XACTENGINE_E_AUDITION_MISSINGDATA           XACTENGINEERROR(0x104)  // Missing data for an audition command
#define XACTENGINE_E_AUDITION_UNKNOWNCOMMAND        XACTENGINEERROR(0x105)  // Unknown command
#define XACTENGINE_E_AUDITION_INVALIDDSPINDEX       XACTENGINEERROR(0x106)  // Missing a DSP parameter
#define XACTENGINE_E_AUDITION_MISSINGWAVE           XACTENGINEERROR(0x107)  // Wave does not exist in auditioned wavebank
#define XACTENGINE_E_AUDITION_CREATEDIRECTORYFAILED XACTENGINEERROR(0x108)  // Failed to create a directory for streaming wavebank data
#define XACTENGINE_E_AUDITION_INVALIDSESSION        XACTENGINEERROR(0x109)  // Invalid audition session
#endif // #ifndef GUID_DEFS_ONLY
#endif // #ifndef _XACT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DirectX\Dec2006\Include\xact3d.h ===
/*-========================================================================-_
 |                                - XACT3D -                                |
 |        Copyright (c) Microsoft Corporation.  All rights reserved.        |
 |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|
 |VERSION:  0.1                         MODEL:   Unmanaged User-mode        |
 |CONTRACT: N / A                       EXCEPT:  No Exceptions              |
 |PARENT:   N / A                       MINREQ:  Win2000, Xbox360           |
 |PROJECT:  XACT3D                      DIALECT: MS Visual C++ 7.0          |
 |>------------------------------------------------------------------------<|
 | DUTY: XACT 3D support                                                    |
 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^
  NOTES:
    1.  See X3DAudio.h for information regarding X3DAudio types.            */


#ifndef __XACT3D_H__
#define __XACT3D_H__
//--------------<D-E-F-I-N-I-T-I-O-N-S>-------------------------------------//
    #include <x3daudio.h>
    #include <xact.h>

    // Supported speaker positions, represented as azimuth angles.
    //
    // Here's a picture of the azimuth angles for the 8 cardinal points,
    // seen from above.  The emitter's base position is at the origin 0.
    //
    //           FRONT
    //             | 0  <-- azimuth
    //             |
    //    7pi/4 \  |  / pi/4
    //           \ | /
    // LEFT       \|/      RIGHT
    // 3pi/2-------0-------pi/2
    //            /|\
    //           / | \
    //    5pi/4 /  |  \ 3pi/4
    //             |
    //             | pi
    //           BACK
    //
    #define LEFT_AZIMUTH                    (3*X3DAUDIO_PI/2)
    #define RIGHT_AZIMUTH                   (X3DAUDIO_PI/2)
    #define FRONT_LEFT_AZIMUTH              (7*X3DAUDIO_PI/4)
    #define FRONT_RIGHT_AZIMUTH             (X3DAUDIO_PI/4)
    #define FRONT_CENTER_AZIMUTH            0.0f
    #define LOW_FREQUENCY_AZIMUTH           X3DAUDIO_2PI
    #define BACK_LEFT_AZIMUTH               (5*X3DAUDIO_PI/4)
    #define BACK_RIGHT_AZIMUTH              (3*X3DAUDIO_PI/4)
    #define BACK_CENTER_AZIMUTH             X3DAUDIO_PI
    #define FRONT_LEFT_OF_CENTER_AZIMUTH    (15*X3DAUDIO_PI/8)
    #define FRONT_RIGHT_OF_CENTER_AZIMUTH   (X3DAUDIO_PI/8)


//--------------<D-A-T-A---T-Y-P-E-S>---------------------------------------//
    // Supported emitter channel layouts:
    static const float aStereoLayout[] =
    {
        LEFT_AZIMUTH,
        RIGHT_AZIMUTH
    };
    static const float a2Point1Layout[] =
    {
        LEFT_AZIMUTH,
        RIGHT_AZIMUTH,
        LOW_FREQUENCY_AZIMUTH
    };
    static const float aQuadLayout[] =
    {
        FRONT_LEFT_AZIMUTH,
        FRONT_RIGHT_AZIMUTH,
        BACK_LEFT_AZIMUTH,
        BACK_RIGHT_AZIMUTH
    };
    static const float a4Point1Layout[] =
    {
        FRONT_LEFT_AZIMUTH,
        FRONT_RIGHT_AZIMUTH,
        LOW_FREQUENCY_AZIMUTH,
        BACK_LEFT_AZIMUTH,
        BACK_RIGHT_AZIMUTH
    };
    static const float a5Point1Layout[] =
    {
        FRONT_LEFT_AZIMUTH,
        FRONT_RIGHT_AZIMUTH,
        FRONT_CENTER_AZIMUTH,
        LOW_FREQUENCY_AZIMUTH,
        BACK_LEFT_AZIMUTH,
        BACK_RIGHT_AZIMUTH
    };
    static const float a7Point1Layout[] =
    {
        FRONT_LEFT_AZIMUTH,
        FRONT_RIGHT_AZIMUTH,
        FRONT_CENTER_AZIMUTH,
        LOW_FREQUENCY_AZIMUTH,
        BACK_LEFT_AZIMUTH,
        BACK_RIGHT_AZIMUTH,
        LEFT_AZIMUTH,
        RIGHT_AZIMUTH
    };


//--------------<F-U-N-C-T-I-O-N-S>-----------------------------------------//
    ////
    // DESCRIPTION:
    //  Initializes the 3D API's:
    //
    // REMARKS:
    //  This method only needs to be called once
    //  The number of bits set in SpeakerChannelMask should equal the number of
    //  channels expected on the final mix.
    //
    // PARAMETERS:
    //  SpeakerChannelMask - [in]  speaker geometry configuration on the final mix, specifies assignment of channels to speaker positions, defined as per WAVEFORMATEXTENSIBLE.dwChannelMask, must be != 0
    //                             Currently only SPEAKER_STEREO and SPEAKER_5POINT1 is supported by X3DAudio.
    //  pEngine            - [in]  pointer to the XACT engine
    //  X3DInstance        - [out] Handle to the X3DAudio instance
    //
    // RETURN VALUE:
    //  HResult error code
    ////
    EXTERN_C HRESULT inline XACT3DInitialize (UINT32 SpeakerChannelMask, IXACTEngine* pEngine, X3DAUDIO_HANDLE X3DInstance)
    {
        HRESULT hr = S_OK;
        if (pEngine == NULL) {
            hr = E_POINTER;
        }

        XACTVARIABLEVALUE nSpeedOfSound = 0.0f;
        if (SUCCEEDED(hr)) {
            XACTVARIABLEINDEX xactSpeedOfSoundID = pEngine->GetGlobalVariableIndex("SpeedOfSound");
            hr = pEngine->GetGlobalVariable(xactSpeedOfSoundID, &nSpeedOfSound);
        }
        if (SUCCEEDED(hr)) {
            X3DAudioInitialize(SpeakerChannelMask, nSpeedOfSound, X3DInstance);
        }

        return hr;
    }


    ////
    // DESCRIPTION:
    //  Calculates DSP settings with respect to 3D parameters:
    //
    // PARAMETERS:
    //  X3DInstance        - [in]  X3DAudio instance (returned from XACT3DInitialize)
    //  pListener          - [in]  point of 3D audio reception
    //  pEmitter           - [in]  3D audio source
    //  pDSPSettings       - [out] receives calculation results, applied to an XACT cue via XACT3DApply
    //
    // RETURN VALUE:
    //  HResult error code
    ////
    EXTERN_C HRESULT inline XACT3DCalculate (X3DAUDIO_HANDLE X3DInstance, const X3DAUDIO_LISTENER* pListener, X3DAUDIO_EMITTER* pEmitter, X3DAUDIO_DSP_SETTINGS* pDSPSettings)
    {
        HRESULT hr = S_OK;
        if (pListener == NULL || pEmitter == NULL || pDSPSettings == NULL) {
            hr = E_POINTER;
        }

        if(SUCCEEDED(hr)) {
            if (pEmitter->ChannelCount > 1 && pEmitter->pChannelAzimuths == NULL) {
                pEmitter->ChannelRadius = 1.0f;

                switch (pEmitter->ChannelCount) {
                    case 2: pEmitter->pChannelAzimuths = (float*)&aStereoLayout[0]; break;
                    case 3: pEmitter->pChannelAzimuths = (float*)&a2Point1Layout[0]; break;
                    case 4: pEmitter->pChannelAzimuths = (float*)&aQuadLayout[0]; break;
                    case 5: pEmitter->pChannelAzimuths = (float*)&a4Point1Layout[0]; break;
                    case 6: pEmitter->pChannelAzimuths = (float*)&a5Point1Layout[0]; break;
                    case 8: pEmitter->pChannelAzimuths = (float*)&a7Point1Layout[0]; break;
                    default: hr = E_FAIL; break;
                }
            }
        }

        if(SUCCEEDED(hr)) {
            static X3DAUDIO_DISTANCE_CURVE_POINT DefaultCurvePoints[2] = { 0.0f, 1.0f, 1.0f, 1.0f };
            static X3DAUDIO_DISTANCE_CURVE       DefaultCurve          = { (X3DAUDIO_DISTANCE_CURVE_POINT*)&DefaultCurvePoints[0], 2 };
            if (pEmitter->pVolumeCurve == NULL) {
                pEmitter->pVolumeCurve = &DefaultCurve;
            }
            if (pEmitter->pLFECurve == NULL) {
                pEmitter->pLFECurve = &DefaultCurve;
            }

            X3DAudioCalculate(X3DInstance, pListener, pEmitter, X3DAUDIO_CALCULATE_MATRIX | X3DAUDIO_CALCULATE_DOPPLER | X3DAUDIO_CALCULATE_EMITTER_ANGLE, pDSPSettings);
        }

        return hr;
    }


    ////
    // DESCRIPTION:
    //  Applies a 3D calculation returned by XACT3DCalculate to a cue:
    //
    // PARAMETERS:
    //  pDSPSettings - [in] calculation results generated by XACT3DCalculate
    //  pCue         - [in] cue to which to apply pDSPSettings
    //
    // RETURN VALUE:
    //  HResult error code
    ////
    EXTERN_C HRESULT inline XACT3DApply (X3DAUDIO_DSP_SETTINGS* pDSPSettings, IXACTCue* pCue)
    {
        HRESULT hr = S_OK;
        if (pDSPSettings == NULL || pCue == NULL) {
            hr = E_POINTER;
        }

        if (SUCCEEDED(hr)) {
            hr = pCue->SetMatrixCoefficients(pDSPSettings->SrcChannelCount, pDSPSettings->DstChannelCount, pDSPSettings->pMatrixCoefficients);
        }
        if (SUCCEEDED(hr)) {
            XACTVARIABLEINDEX xactDistanceID = pCue->GetVariableIndex("Distance");
            hr = pCue->SetVariable(xactDistanceID, pDSPSettings->EmitterToListenerDistance);
        }
        if (SUCCEEDED(hr)) {
            XACTVARIABLEINDEX xactDopplerID = pCue->GetVariableIndex("DopplerPitchScalar");
            hr = pCue->SetVariable(xactDopplerID, pDSPSettings->DopplerFactor);
        }
        if (SUCCEEDED(hr)) {
            XACTVARIABLEINDEX xactOrientationID = pCue->GetVariableIndex("OrientationAngle");
            hr = pCue->SetVariable(xactOrientationID, pDSPSettings->EmitterToListenerAngle * (180.0f / X3DAUDIO_PI));
        }

        return hr;
    }


#endif // __XACT3D_H__
//---------------------------------<-EOF->----------------------------------//
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\DirectX\Dec2006\Include\X3DAudio.h ===
/*-========================================================================-_
 |                               - X3DAUDIO -                               |
 |        Copyright (c) Microsoft Corporation.  All rights reserved.        |
 |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|
 |VERSION:  1.1                         MODEL:   Unmanaged User-mode        |
 |CONTRACT: N / A                       EXCEPT:  No Exceptions              |
 |PARENT:   N / A                       MINREQ:  Win2000, Xenon             |
 |PROJECT:  X3DAudio                    DIALECT: MS Visual C++ 7.0          |
 |>------------------------------------------------------------------------<|
 | DUTY: Cross-platform stand-alone 3D audio math library                   |
 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^
  NOTES:
    1.  Definition of terms:
            LFE: Low Frequency Effect -- always omnidirectional.
            LPF: Low Pass Filter, divided into two classifications:
                 Direct -- Applied to the direct signal path,
                           used for obstruction/occlusion effect.
                 Reverb -- Applied to the reverb signal path,
                           used for occlusion effect only.

    2.  Volume level is expressed as a linear amplitude scaler:
        1.0f represents no attenuation applied to the original signal,
        0.5f denotes an attenuation of 6dB, and 0.0f results in silence.
        Amplification (volume > 1.0f) is also allowed, and is not clamped.

    3.  X3DAudio uses a left-handed Cartesian coordinate system with values
        on the x-axis increasing from left to right, on the y-axis from
        bottom to top, and on the z-axis from near to far.
        Azimuths are measured clockwise from a given reference direction.

        Distance measurement is with respect to user-defined world units.
        Applications may provide coordinates using any system of measure
        as all non-normalized calculations are scale invariant, with such
        operations natively occurring in the user-defined world unit space.
        Metric constants are supplied only as a convenience.
        Distance is calculated using the Euclidean norm formula.

    4.  Only real values are permissible with functions using 32-bit
        float parameters -- NAN and infinite values are not accepted.
        All computation occurs in 32-bit precision mode.                    */


#ifndef __X3DAUDIO_H__
#define __X3DAUDIO_H__
//--------------<D-E-F-I-N-I-T-I-O-N-S>-------------------------------------//
    #if defined(_XBOX)
        #include <vectorintrinsics.h>
    #endif
    #include <d3d9types.h>

    // speaker geometry configuration flags, specifies assignment of channels to speaker positions, defined as per WAVEFORMATEXTENSIBLE.dwChannelMask
    #if !defined(SPEAKER_FRONT_LEFT)
        #define SPEAKER_FRONT_LEFT            0x00000001
        #define SPEAKER_FRONT_RIGHT           0x00000002
        #define SPEAKER_FRONT_CENTER          0x00000004
        #define SPEAKER_LOW_FREQUENCY         0x00000008
        #define SPEAKER_BACK_LEFT             0x00000010
        #define SPEAKER_BACK_RIGHT            0x00000020
        #define SPEAKER_FRONT_LEFT_OF_CENTER  0x00000040
        #define SPEAKER_FRONT_RIGHT_OF_CENTER 0x00000080
        #define SPEAKER_BACK_CENTER           0x00000100
        #define SPEAKER_SIDE_LEFT             0x00000200
        #define SPEAKER_SIDE_RIGHT            0x00000400
        #define SPEAKER_TOP_CENTER            0x00000800
        #define SPEAKER_TOP_FRONT_LEFT        0x00001000
        #define SPEAKER_TOP_FRONT_CENTER      0x00002000
        #define SPEAKER_TOP_FRONT_RIGHT       0x00004000
        #define SPEAKER_TOP_BACK_LEFT         0x00008000
        #define SPEAKER_TOP_BACK_CENTER       0x00010000
        #define SPEAKER_TOP_BACK_RIGHT        0x00020000
    #endif

    // standard speaker geometry configurations, used with X3DAudioInitialize
    #if !defined(SPEAKER_STEREO)
        #define SPEAKER_STEREO           (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT)
        #define SPEAKER_2POINT1          (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | SPEAKER_LOW_FREQUENCY)
        #define SPEAKER_SURROUND         (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | SPEAKER_FRONT_CENTER | SPEAKER_BACK_CENTER)
        #define SPEAKER_QUAD             (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | SPEAKER_BACK_LEFT | SPEAKER_BACK_RIGHT)
        #define SPEAKER_4POINT1          (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | SPEAKER_LOW_FREQUENCY | SPEAKER_BACK_LEFT | SPEAKER_BACK_RIGHT)
        #define SPEAKER_5POINT1          (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | SPEAKER_FRONT_CENTER | SPEAKER_LOW_FREQUENCY | SPEAKER_BACK_LEFT | SPEAKER_BACK_RIGHT)
        #define SPEAKER_7POINT1          (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | SPEAKER_FRONT_CENTER | SPEAKER_LOW_FREQUENCY | SPEAKER_BACK_LEFT | SPEAKER_BACK_RIGHT | SPEAKER_FRONT_LEFT_OF_CENTER | SPEAKER_FRONT_RIGHT_OF_CENTER)
        #define SPEAKER_5POINT1_SURROUND (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | SPEAKER_FRONT_CENTER | SPEAKER_LOW_FREQUENCY | SPEAKER_SIDE_LEFT  | SPEAKER_SIDE_RIGHT)
        #define SPEAKER_7POINT1_SURROUND (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | SPEAKER_FRONT_CENTER | SPEAKER_LOW_FREQUENCY | SPEAKER_BACK_LEFT | SPEAKER_BACK_RIGHT | SPEAKER_SIDE_LEFT  | SPEAKER_SIDE_RIGHT)
    #endif

    // xenon speaker geometry configuration, used with X3DAudioInitialize
    #if defined(_XBOX)
        #define SPEAKER_XBOX SPEAKER_5POINT1
    #endif


    #define X3DAUDIO_HANDLE_BYTESIZE 20 // size of instance handle in bytes

    // float math constants
    #define X3DAUDIO_PI  3.141592654f
    #define X3DAUDIO_2PI 6.283185307f

    // speed of sound in meters per second for dry air at approximately 20C, used with X3DAudioInitialize
    #define X3DAUDIO_SPEED_OF_SOUND 343.5f

    // calculation control flags, used with X3DAudioCalculate
    #define X3DAUDIO_CALCULATE_MATRIX        0x00000001 // enable matrix coefficient table calculation
    #define X3DAUDIO_CALCULATE_DELAY         0x00000002 // enable delay time array calculation (stereo final mix only)
    #define X3DAUDIO_CALCULATE_LPF_DIRECT    0x00000004 // enable LPF direct-path coefficient calculation
    #define X3DAUDIO_CALCULATE_LPF_REVERB    0x00000008 // enable LPF reverb-path coefficient calculation
    #define X3DAUDIO_CALCULATE_REVERB        0x00000010 // enable reverb send level calculation
    #define X3DAUDIO_CALCULATE_DOPPLER       0x00000020 // enable doppler shift factor calculation
    #define X3DAUDIO_CALCULATE_EMITTER_ANGLE 0x00000040 // enable emitter-to-listener interior angle calculation

    #define X3DAUDIO_CALCULATE_ZEROCENTER    0x00010000 // do not position to front center speaker, center destination channel will be zero in returned matrix coefficient table, used only for matrix calculations and only for final mix formats that have a front center channel


//--------------<M-A-C-R-O-S>-----------------------------------------------//
    // function storage-class attribute and calltype
    #if defined(_XBOX) || defined(X3DAUDIOSTATIC)
        #define X3DAUDIO_API_(type) EXTERN_C type STDAPICALLTYPE
    #else
        #if defined(X3DEXPORT)
            #define X3DAUDIO_API_(type) EXTERN_C __declspec(dllexport) type STDAPICALLTYPE
        #else
            #define X3DAUDIO_API_(type) EXTERN_C __declspec(dllimport) type STDAPICALLTYPE
        #endif
    #endif
    #define X3DAUDIO_IMP_(type) type STDMETHODCALLTYPE


//--------------<D-A-T-A---T-Y-P-E-S>---------------------------------------//
    // primitive types
    typedef INT_PTR  NWORD;   // natural machine word, bytesize platform specific
    typedef UINT_PTR UNWORD;  // unsigned natural machine word, bytesize platform specific
    typedef float    FLOAT32; // 32-bit IEEE float
    typedef D3DVECTOR X3DAUDIO_VECTOR; // float 3D vector

    // instance handle to precalculated constants
    typedef BYTE X3DAUDIO_HANDLE[X3DAUDIO_HANDLE_BYTESIZE];


    // Distance curve point:
    // Defines a DSP setting at a given normalized distance.
    typedef struct X3DAUDIO_DISTANCE_CURVE_POINT
    {
        FLOAT32 Distance;   // normalized distance, must be within [0.0f, 1.0f]
        FLOAT32 DSPSetting; // DSP control setting
    } X3DAUDIO_DISTANCE_CURVE_POINT, *LPX3DAUDIO_DISTANCE_CURVE_POINT;

    // Distance curve:
    // A piecewise curve made up of linear segments used to
    // define DSP behaviour with respect to normalized distance.
    //
    // Note that curve point distances are normalized within [0.0f, 1.0f].
    // X3DAUDIO_EMITTER.CurveDistanceScaler must be used to scale the
    // normalized distances to user-defined world units.
    // For distances beyond CurveDistanceScaler * 1.0f,
    // pPoints[PointCount-1].DSPSetting is used as the DSP setting.
    //
    // All distance curve spans must be such that:
    //      pPoints[k-1].DSPSetting + ((pPoints[k].DSPSetting-pPoints[k-1].DSPSetting) / (pPoints[k].Distance-pPoints[k-1].Distance)) * (pPoints[k].Distance-pPoints[k-1].Distance) != NAN or infinite values
    // For all points in the distance curve where 1 <= k < PointCount.
    typedef struct X3DAUDIO_DISTANCE_CURVE
    {
        X3DAUDIO_DISTANCE_CURVE_POINT* pPoints;    // distance curve point array, must have at least PointCount elements with no duplicates and be sorted in ascending order with respect to Distance
        UINT32                         PointCount; // number of distance curve points, must be >= 2 as all distance curves must have at least two endpoints, defining DSP settings at 0.0f and 1.0f normalized distance
    } X3DAUDIO_DISTANCE_CURVE, *LPX3DAUDIO_DISTANCE_CURVE;
    static const X3DAUDIO_DISTANCE_CURVE_POINT X3DAudioDefault_LinearCurvePoints[2] = { 0.0f, 1.0f, 1.0f, 0.0f };
    static const X3DAUDIO_DISTANCE_CURVE       X3DAudioDefault_LinearCurve          = { (X3DAUDIO_DISTANCE_CURVE_POINT*)&X3DAudioDefault_LinearCurvePoints[0], 2 };

    // Cone:
    // Specifies directionality for a single-channel emitter by
    // scaling DSP behaviour with respect to the emitter's front orientation.
    // This is modeled using two sound cones: an inner cone and an outer cone.
    // On/within the inner cone, DSP settings are scaled by the inner values.
    // On/beyond the outer cone, DSP settings are scaled by the outer values.
    // If on both the cones, DSP settings are scaled by the inner values only.
    // Between the two cones, the scaler is linearly interpolated between the
    // inner and outer values.  Set both cone angles to 0 or X3DAUDIO_2PI for
    // omnidirectionality using only the outer or inner values respectively.
    typedef struct X3DAUDIO_CONE
    {
        FLOAT32 InnerAngle; // inner cone angle in radians, must be within [0.0f, X3DAUDIO_2PI]
        FLOAT32 OuterAngle; // outer cone angle in radians, must be within [InnerAngle, X3DAUDIO_2PI]

        FLOAT32 InnerVolume; // volume level scaler on/within inner cone, used only for matrix calculations, must be within [0.0f, 2.0f] when used
        FLOAT32 OuterVolume; // volume level scaler on/beyond outer cone, used only for matrix calculations, must be within [0.0f, 2.0f] when used
        FLOAT32 InnerLPF;    // LPF (both direct and reverb paths) coefficient scaler on/within inner cone, used only for LPF (both direct and reverb paths) calculations, must be within [0.0f, 1.0f] when used
        FLOAT32 OuterLPF;    // LPF (both direct and reverb paths) coefficient scaler on/beyond outer cone, used only for LPF (both direct and reverb paths) calculations, must be within [0.0f, 1.0f] when used
        FLOAT32 InnerReverb; // reverb send level scaler on/within inner cone, used only for reverb calculations, must be within [0.0f, 2.0f] when used
        FLOAT32 OuterReverb; // reverb send level scaler on/beyond outer cone, used only for reverb calculations, must be within [0.0f, 2.0f] when used
    } X3DAUDIO_CONE, *LPX3DAUDIO_CONE;
    static const X3DAUDIO_CONE X3DAudioDefault_DirectionalCone = { X3DAUDIO_PI/2, X3DAUDIO_PI, 1.0f, 0.708f, 1.0f, 0.75f, 0.708f, 1.0f };


    // Listener:
    // Defines a point of 3D audio reception.
    typedef struct X3DAUDIO_LISTENER
    {
        X3DAUDIO_VECTOR OrientFront; // orientation of front direction, used only for matrix and delay calculations, must be orthonormal with OrientTop when used
        X3DAUDIO_VECTOR OrientTop;   // orientation of top direction, used only for matrix and delay calculations, must be orthonormal with OrientFront when used

        X3DAUDIO_VECTOR Position; // position in user-defined world units, does not affect Velocity
        X3DAUDIO_VECTOR Velocity; // velocity vector in user-defined world units/second, used only for doppler calculations, does not affect Position
    } X3DAUDIO_LISTENER, *LPX3DAUDIO_LISTENER;

    // Emitter:
    // Defines a 3D audio source, divided into two classifications:
    //
    // Single-point -- For use with single-channel sounds.
    //                 Positioned at the emitter base, i.e. the channel radius
    //                 and azimuth are ignored if the number of channels == 1.
    //
    //                 May be omnidirectional or directional using a cone.
    //                 The cone originates from the emitter base position,
    //                 and is directed by the emitter's front orientation.
    //
    // Multi-point  -- For use with multi-channel sounds.
    //                 Each non-LFE channel is positioned using an
    //                 azimuth along the channel radius with respect to the
    //                 front orientation vector in the plane orthogonal to the
    //                 top orientation vector.  An azimuth of X3DAUDIO_2PI
    //                 specifies a channel is a LFE.  Such channels are
    //                 positioned at the emitter base and are calculated
    //                 with respect to pLFECurve only, never pVolumeCurve.
    //
    //                 Multi-point emitters are always omnidirectional,
    //                 i.e. the cone is ignored if the number of channels > 1.
    //
    // Note that many properties are shared among all channel points,
    // locking certain behaviour with respect to the emitter base position.
    // For example, doppler shift is always calculated with respect to the
    // emitter base position and so is constant for all its channel points.
    // Distance curve calculations are also with respect to the emitter base
    // position, with the curves being calculated independently of each other.
    // For instance, volume and LFE calculations do not affect one another.
    typedef struct X3DAUDIO_EMITTER
    {
        X3DAUDIO_CONE* pCone; // sound cone, used only with single-channel emitters for matrix, LPF (both direct and reverb paths), and reverb calculations, NULL specifies omnidirectionality
        X3DAUDIO_VECTOR OrientFront; // orientation of front direction, used only for emitter angle calculations or with multi-channel emitters for matrix calculations or single-channel emitters with cones for matrix, LPF (both direct and reverb paths), and reverb calculations, must be normalized when used
        X3DAUDIO_VECTOR OrientTop;   // orientation of top direction, used only with multi-channel emitters for matrix calculations, must be orthonormal with OrientFront when used

        X3DAUDIO_VECTOR Position; // position in user-defined world units, does not affect Velocity
        X3DAUDIO_VECTOR Velocity; // velocity vector in user-defined world units/second, used only for doppler calculations, does not affect Position

        UINT32 ChannelCount;       // number of sound channels, must be > 0
        FLOAT32 ChannelRadius;     // channel radius, used only with multi-channel emitters for matrix calculations, must be >= 0.0f when used
        FLOAT32* pChannelAzimuths; // channel azimuth array, used only with multi-channel emitters for matrix calculations, contains positions of each channel expressed in radians along the channel radius with respect to the front orientation vector in the plane orthogonal to the top orientation vector, or X3DAUDIO_2PI to specify a LFE channel, must have at least ChannelCount elements, all within [0.0f, X3DAUDIO_2PI] when used

        X3DAUDIO_DISTANCE_CURVE* pVolumeCurve;    // volume level distance curve, used only for matrix calculations, NULL specifies a default curve that conforms to the inverse square law with distances <= 1.0f clamped to no attenuation, CurveDistanceScaler is ignored when this parameter is NULL
        X3DAUDIO_DISTANCE_CURVE* pLFECurve;       // LFE level distance curve, used only for matrix calculations, NULL specifies a default curve that conforms to the inverse square law with distances <= 1.0f clamped to no attenuation, CurveDistanceScaler is ignored when this parameters is NULL
        X3DAUDIO_DISTANCE_CURVE* pLPFDirectCurve; // LPF direct-path coefficient distance curve, used only for LPF direct-path calculations, NULL specifies the default curve: [0.0f,1.0f], [1.0f,0.75f]
        X3DAUDIO_DISTANCE_CURVE* pLPFReverbCurve; // LPF reverb-path coefficient distance curve, used only for LPF reverb-path calculations, NULL specifies the default curve: [0.0f,0.75f], [1.0f,0.75f]
        X3DAUDIO_DISTANCE_CURVE* pReverbCurve;    // reverb send level distance curve, used only for reverb calculations, NULL specifies the default curve: [0.0f,1.0f], [1.0f,0.0f]

        FLOAT32 CurveDistanceScaler; // curve distance scaler, used to scale normalized distance curves to user-defined world units and/or exaggerate their effect, does not affect any other calculations, must be within [FLT_MIN, FLT_MAX] when used
        FLOAT32 DopplerScaler;       // doppler shift scaler, used to exaggerate doppler shift effect, does not affect any other calculations, must be within [0.0f, FLT_MAX] when used
    } X3DAUDIO_EMITTER, *LPX3DAUDIO_EMITTER;


    // DSP settings:
    // Receives results from a call to X3DAudioCalculate() to be sent
    // to the low-level audio rendering API for 3D signal processing.
    //
    // The user is responsible for allocating the matrix coefficient table,
    // delay time array, and initializing the channel counts when used.
    typedef struct X3DAUDIO_DSP_SETTINGS
    {
        FLOAT32* pMatrixCoefficients; // [in] matrix coefficient table, receives an array representing the volume level of each source channel present in each destination channel with the source channels being the column index and the destination channels being the row index of the table, must have at least SrcChannelCount*DstChannelCount elements
        FLOAT32* pDelayTimes;         // [in] delay time array, receives delays for each destination channel in milliseconds, must have at least DstChannelCount elements (stereo final mix only)
        UINT32 SrcChannelCount;       // [in] number of source channels, must equal number of channels on respective emitter
        UINT32 DstChannelCount;       // [in] number of destination channels, must equal number of channels on the final mix

        FLOAT32 LPFDirectCoefficient; // [out] LPF direct-path coefficient
        FLOAT32 LPFReverbCoefficient; // [out] LPF reverb-path coefficient
        FLOAT32 ReverbLevel; // [out] reverb send level
        FLOAT32 DopplerFactor; // [out] doppler shift factor, scales resampler ratio for doppler shift effect, where the effective frequency = DopplerFactor * original frequency
        FLOAT32 EmitterToListenerAngle; // [out] emitter-to-listener interior angle, expressed in radians with respect to the emitter's front orientation

        FLOAT32 EmitterToListenerDistance; // [out] distance in user-defined world units from the emitter base to listener position, always calculated
        FLOAT32 EmitterVelocityComponent; // [out] component of emitter velocity vector projected onto emitter->listener vector in user-defined world units/second, calculated only for doppler
        FLOAT32 ListenerVelocityComponent; // [out] component of listener velocity vector projected onto emitter->listener vector in user-defined world units/second, calculated only for doppler
    } X3DAUDIO_DSP_SETTINGS, *LPX3DAUDIO_DSP_SETTINGS;


//--------------<F-U-N-C-T-I-O-N-S>-----------------------------------------//
    // sets all global 3D audio constants
    X3DAUDIO_API_(void) X3DAudioInitialize (UINT32 SpeakerChannelMask, FLOAT32 SpeedOfSound, X3DAUDIO_HANDLE Instance);

    // calculates DSP settings with respect to 3D parameters
    X3DAUDIO_API_(void) X3DAudioCalculate (const X3DAUDIO_HANDLE Instance, const X3DAUDIO_LISTENER* pListener, const X3DAUDIO_EMITTER* pEmitter, UINT32 Flags, X3DAUDIO_DSP_SETTINGS* pDSPSettings);


#endif // __X3DAUDIO_H__
//---------------------------------<-EOF->----------------------------------//
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\FCL\Include\detours.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Core Detours Functionality (detours.h of detours.lib)
//
//  Microsoft Research Detours Package, Version 2.1.
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//

#pragma once
#ifndef _DETOURS_H_
#define _DETOURS_H_

#define DETOURS_VERSION     20100   // 2.1.0

//////////////////////////////////////////////////////////////////////////////
//

#if (_MSC_VER < 1299)
typedef LONG LONG_PTR;
typedef ULONG ULONG_PTR;
#endif

#ifndef __in_z
#define __in_z
#endif

//////////////////////////////////////////////////////////////////////////////
//
#ifndef GUID_DEFINED
#define GUID_DEFINED
typedef struct  _GUID
{
    DWORD Data1;
    WORD Data2;
    WORD Data3;
    BYTE Data4[ 8 ];
} GUID;

#ifdef INITGUID
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        const GUID name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
#else
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    const GUID name
#endif // INITGUID
#endif // !GUID_DEFINED

#if defined(__cplusplus)
#ifndef _REFGUID_DEFINED
#define _REFGUID_DEFINED
#define REFGUID             const GUID &
#endif // !_REFGUID_DEFINED
#else // !__cplusplus
#ifndef _REFGUID_DEFINED
#define _REFGUID_DEFINED
#define REFGUID             const GUID * const
#endif // !_REFGUID_DEFINED
#endif // !__cplusplus

//
//////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/////////////////////////////////////////////////// Instruction Target Macros.
//
#define DETOUR_INSTRUCTION_TARGET_NONE          ((PVOID)0)
#define DETOUR_INSTRUCTION_TARGET_DYNAMIC       ((PVOID)(LONG_PTR)-1)
#define DETOUR_SECTION_HEADER_SIGNATURE         0x00727444   // "Dtr\0"

extern const GUID DETOUR_EXE_RESTORE_GUID;

#define DETOUR_TRAMPOLINE_SIGNATURE             0x21727444  // Dtr!
typedef struct _DETOUR_TRAMPOLINE DETOUR_TRAMPOLINE, *PDETOUR_TRAMPOLINE;

/////////////////////////////////////////////////////////// Binary Structures.
//
#pragma pack(push, 8)
typedef struct _DETOUR_SECTION_HEADER
{
    DWORD       cbHeaderSize;
    DWORD       nSignature;
    DWORD       nDataOffset;
    DWORD       cbDataSize;

    DWORD       nOriginalImportVirtualAddress;
    DWORD       nOriginalImportSize;
    DWORD       nOriginalBoundImportVirtualAddress;
    DWORD       nOriginalBoundImportSize;

    DWORD       nOriginalIatVirtualAddress;
    DWORD       nOriginalIatSize;
    DWORD       nOriginalSizeOfImage;
    DWORD       cbPrePE;

    DWORD       nOriginalClrFlags;
    DWORD       reserved1;
    DWORD       reserved2;
    DWORD       reserved3;

    // Followed by cbPrePE bytes of data.
} DETOUR_SECTION_HEADER, *PDETOUR_SECTION_HEADER;

typedef struct _DETOUR_SECTION_RECORD
{
    DWORD       cbBytes;
    DWORD       nReserved;
    GUID        guid;
} DETOUR_SECTION_RECORD, *PDETOUR_SECTION_RECORD;

typedef struct _DETOUR_CLR_HEADER
{
    // Header versioning
    ULONG                   cb;
    USHORT                  MajorRuntimeVersion;
    USHORT                  MinorRuntimeVersion;

    // Symbol table and startup information
    IMAGE_DATA_DIRECTORY    MetaData;
    ULONG                   Flags;

    // Followed by the rest of the header.
} DETOUR_CLR_HEADER, *PDETOUR_CLR_HEADER;

typedef struct _DETOUR_EXE_RESTORE
{
    ULONG               cb;

    PIMAGE_DOS_HEADER   pidh;
    PIMAGE_NT_HEADERS   pinh;
    PULONG              pclrFlags;
    DWORD               impDirProt;

    IMAGE_DOS_HEADER    idh;
    IMAGE_NT_HEADERS    inh;
    ULONG               clrFlags;
} DETOUR_EXE_RESTORE, *PDETOUR_EXE_RESTORE;

#pragma pack(pop)

#define DETOUR_SECTION_HEADER_DECLARE(cbSectionSize) \
{ \
      sizeof(DETOUR_SECTION_HEADER),\
      DETOUR_SECTION_HEADER_SIGNATURE,\
      sizeof(DETOUR_SECTION_HEADER),\
      (cbSectionSize),\
      \
      0,\
      0,\
      0,\
      0,\
      \
      0,\
      0,\
      0,\
      0,\
}

///////////////////////////////////////////////////////////// Binary Typedefs.
//
typedef BOOL (CALLBACK *PF_DETOUR_BINARY_BYWAY_CALLBACK)(PVOID pContext,
                                                         PCHAR pszFile,
                                                         PCHAR *ppszOutFile);

typedef BOOL (CALLBACK *PF_DETOUR_BINARY_FILE_CALLBACK)(PVOID pContext,
                                                        PCHAR pszOrigFile,
                                                        PCHAR pszFile,
                                                        PCHAR *ppszOutFile);

typedef BOOL (CALLBACK *PF_DETOUR_BINARY_SYMBOL_CALLBACK)(PVOID pContext,
                                                          ULONG nOrigOrdinal,
                                                          ULONG nOrdinal,
                                                          ULONG *pnOutOrdinal,
                                                          PCHAR pszOrigSymbol,
                                                          PCHAR pszSymbol,
                                                          PCHAR *ppszOutSymbol);

typedef BOOL (CALLBACK *PF_DETOUR_BINARY_COMMIT_CALLBACK)(PVOID pContext);

typedef BOOL (CALLBACK *PF_DETOUR_ENUMERATE_EXPORT_CALLBACK)(PVOID pContext,
                                                             ULONG nOrdinal,
                                                             PCHAR pszName,
                                                             PVOID pCode);

typedef VOID * PDETOUR_BINARY;
typedef VOID * PDETOUR_LOADED_BINARY;

//////////////////////////////////////////////////////////// Detours 2.1 APIs.
//

LONG WINAPI DetourTransactionBegin();
LONG WINAPI DetourTransactionAbort();
LONG WINAPI DetourTransactionCommit();
LONG WINAPI DetourTransactionCommitEx(PVOID **pppFailedPointer);

LONG WINAPI DetourUpdateThread(HANDLE hThread);

LONG WINAPI DetourAttach(PVOID *ppPointer,
                         PVOID pDetour);

LONG WINAPI DetourAttachEx(PVOID *ppPointer,
                           PVOID pDetour,
                           PDETOUR_TRAMPOLINE *ppRealTrampoline,
                           PVOID *ppRealTarget,
                           PVOID *ppRealDetour);

LONG WINAPI DetourDetach(PVOID *ppPointer,
                         PVOID pDetour);

VOID WINAPI DetourSetIgnoreTooSmall(BOOL fIgnore);

////////////////////////////////////////////////////////////// Code Functions.
//
PVOID WINAPI DetourFindFunction(PCSTR pszModule, PCSTR pszFunction);
PVOID WINAPI DetourCodeFromPointer(PVOID pPointer, PVOID *ppGlobals);

PVOID WINAPI DetourCopyInstruction(PVOID pDst, PVOID pSrc, PVOID *ppTarget);
PVOID WINAPI DetourCopyInstructionEx(PVOID pDst,
                                     PVOID pSrc,
                                     PVOID *ppTarget,
                                     LONG *plExtra);

///////////////////////////////////////////////////// Loaded Binary Functions.
//
HMODULE WINAPI DetourEnumerateModules(HMODULE hModuleLast);
PVOID WINAPI DetourGetEntryPoint(HMODULE hModule);
ULONG WINAPI DetourGetModuleSize(HMODULE hModule);
BOOL WINAPI DetourEnumerateExports(HMODULE hModule,
                                   PVOID pContext,
                                   PF_DETOUR_ENUMERATE_EXPORT_CALLBACK pfExport);

PVOID WINAPI DetourFindPayload(HMODULE hModule, REFGUID rguid, DWORD *pcbData);
DWORD WINAPI DetourGetSizeOfPayloads(HMODULE hModule);

///////////////////////////////////////////////// Persistent Binary Functions.
//

PDETOUR_BINARY WINAPI DetourBinaryOpen(HANDLE hFile);
PVOID WINAPI DetourBinaryEnumeratePayloads(PDETOUR_BINARY pBinary,
                                           GUID *pGuid,
                                           DWORD *pcbData,
                                           DWORD *pnIterator);
PVOID WINAPI DetourBinaryFindPayload(PDETOUR_BINARY pBinary,
                                     REFGUID rguid,
                                     DWORD *pcbData);
PVOID WINAPI DetourBinarySetPayload(PDETOUR_BINARY pBinary,
                                    REFGUID rguid,
                                    PVOID pData,
                                    DWORD cbData);
BOOL WINAPI DetourBinaryDeletePayload(PDETOUR_BINARY pBinary, REFGUID rguid);
BOOL WINAPI DetourBinaryPurgePayloads(PDETOUR_BINARY pBinary);
BOOL WINAPI DetourBinaryResetImports(PDETOUR_BINARY pBinary);
BOOL WINAPI DetourBinaryEditImports(PDETOUR_BINARY pBinary,
                                    PVOID pContext,
                                    PF_DETOUR_BINARY_BYWAY_CALLBACK pfByway,
                                    PF_DETOUR_BINARY_FILE_CALLBACK pfFile,
                                    PF_DETOUR_BINARY_SYMBOL_CALLBACK pfSymbol,
                                    PF_DETOUR_BINARY_COMMIT_CALLBACK pfCommit);
BOOL WINAPI DetourBinaryWrite(PDETOUR_BINARY pBinary, HANDLE hFile);
BOOL WINAPI DetourBinaryClose(PDETOUR_BINARY pBinary);

/////////////////////////////////////////////////// Create Process & Load Dll.
//
typedef BOOL (WINAPI *PDETOUR_CREATE_PROCESS_ROUTINEA)
    (LPCSTR lpApplicationName,
     LPSTR lpCommandLine,
     LPSECURITY_ATTRIBUTES lpProcessAttributes,
     LPSECURITY_ATTRIBUTES lpThreadAttributes,
     BOOL bInheritHandles,
     DWORD dwCreationFlags,
     LPVOID lpEnvironment,
     LPCSTR lpCurrentDirectory,
     LPSTARTUPINFOA lpStartupInfo,
     LPPROCESS_INFORMATION lpProcessInformation);

typedef BOOL (WINAPI *PDETOUR_CREATE_PROCESS_ROUTINEW)
    (LPCWSTR lpApplicationName,
     LPWSTR lpCommandLine,
     LPSECURITY_ATTRIBUTES lpProcessAttributes,
     LPSECURITY_ATTRIBUTES lpThreadAttributes,
     BOOL bInheritHandles,
     DWORD dwCreationFlags,
     LPVOID lpEnvironment,
     LPCWSTR lpCurrentDirectory,
     LPSTARTUPINFOW lpStartupInfo,
     LPPROCESS_INFORMATION lpProcessInformation);

BOOL WINAPI DetourCreateProcessWithDllA(LPCSTR lpApplicationName,
                                        __in_z LPSTR lpCommandLine,
                                        LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                        LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                        BOOL bInheritHandles,
                                        DWORD dwCreationFlags,
                                        LPVOID lpEnvironment,
                                        LPCSTR lpCurrentDirectory,
                                        LPSTARTUPINFOA lpStartupInfo,
                                        LPPROCESS_INFORMATION lpProcessInformation,
                                        LPCSTR lpDetouredDllFullName,
                                        LPCSTR lpDllName,
                                        PDETOUR_CREATE_PROCESS_ROUTINEA
                                        pfCreateProcessA);

BOOL WINAPI DetourCreateProcessWithDllW(LPCWSTR lpApplicationName,
                                        __in_z LPWSTR lpCommandLine,
                                        LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                        LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                        BOOL bInheritHandles,
                                        DWORD dwCreationFlags,
                                        LPVOID lpEnvironment,
                                        LPCWSTR lpCurrentDirectory,
                                        LPSTARTUPINFOW lpStartupInfo,
                                        LPPROCESS_INFORMATION lpProcessInformation,
                                        LPCSTR lpDetouredDllFullName,
                                        LPCSTR lpDllName,
                                        PDETOUR_CREATE_PROCESS_ROUTINEW
                                        pfCreateProcessW);

#ifdef UNICODE
#define DetourCreateProcessWithDll  DetourCreateProcessWithDllW
#define PDETOUR_CREATE_PROCESS_ROUTINE     PDETOUR_CREATE_PROCESS_ROUTINEW
#else
#define DetourCreateProcessWithDll  DetourCreateProcessWithDllA
#define PDETOUR_CREATE_PROCESS_ROUTINE     PDETOUR_CREATE_PROCESS_ROUTINEA
#endif // !UNICODE

BOOL WINAPI DetourCopyPayloadToProcess(HANDLE hProcess,
                                       REFGUID rguid,
                                       PVOID pvData,
                                       DWORD cbData);
BOOL WINAPI DetourRestoreAfterWith();
BOOL WINAPI DetourRestoreAfterWithEx(PVOID pvData, DWORD cbData);

HMODULE WINAPI DetourGetDetouredMarker();

//
//////////////////////////////////////////////////////////////////////////////
#ifdef __cplusplus
}
#endif // __cplusplus

//////////////////////////////////////////////// Detours Internal Definitions.
//
#ifdef __cplusplus
#ifdef DETOURS_INTERNAL

#ifndef __deref_out
#define __deref_out
#endif

#ifndef __deref
#define __deref
#endif

//////////////////////////////////////////////////////////////////////////////
//
#if (_MSC_VER < 1299)
#include <imagehlp.h>
typedef IMAGEHLP_MODULE IMAGEHLP_MODULE64;
typedef PIMAGEHLP_MODULE PIMAGEHLP_MODULE64;
typedef IMAGEHLP_SYMBOL SYMBOL_INFO;
typedef PIMAGEHLP_SYMBOL PSYMBOL_INFO;

static inline
LONG InterlockedCompareExchange(LONG *ptr, LONG nval, LONG oval)
{
    return (LONG)::InterlockedCompareExchange((PVOID*)ptr, (PVOID)nval, (PVOID)oval);
}
#else
#include <dbghelp.h>
#endif

#ifdef IMAGEAPI // defined by DBGHELP.H
typedef LPAPI_VERSION (NTAPI *PF_ImagehlpApiVersionEx)(LPAPI_VERSION AppVersion);

typedef BOOL (NTAPI *PF_SymInitialize)(IN HANDLE hProcess,
                                       IN LPCSTR UserSearchPath,
                                       IN BOOL fInvadeProcess);
typedef DWORD (NTAPI *PF_SymSetOptions)(IN DWORD SymOptions);
typedef DWORD (NTAPI *PF_SymGetOptions)(VOID);
typedef DWORD64 (NTAPI *PF_SymLoadModule64)(IN HANDLE hProcess,
                                            IN HANDLE hFile,
                                            IN PSTR ImageName,
                                            IN PSTR ModuleName,
                                            IN DWORD64 BaseOfDll,
                                            IN DWORD SizeOfDll);
typedef BOOL (NTAPI *PF_SymGetModuleInfo64)(IN HANDLE hProcess,
                                            IN DWORD64 qwAddr,
                                            OUT PIMAGEHLP_MODULE64 ModuleInfo);
typedef BOOL (NTAPI *PF_SymFromName)(IN HANDLE hProcess,
                                     IN LPSTR Name,
                                     OUT PSYMBOL_INFO Symbol);

typedef struct _DETOUR_SYM_INFO
{
    HANDLE                  hProcess;
    HMODULE                 hDbgHelp;
    PF_ImagehlpApiVersionEx pfImagehlpApiVersionEx;
    PF_SymInitialize        pfSymInitialize;
    PF_SymSetOptions        pfSymSetOptions;
    PF_SymGetOptions        pfSymGetOptions;
    PF_SymLoadModule64      pfSymLoadModule64;
    PF_SymGetModuleInfo64   pfSymGetModuleInfo64;
    PF_SymFromName          pfSymFromName;
} DETOUR_SYM_INFO, *PDETOUR_SYM_INFO;

PDETOUR_SYM_INFO DetourLoadDbgHelp(VOID);

#endif // IMAGEAPI

#ifndef DETOUR_TRACE
#if DETOUR_DEBUG
#define DETOUR_TRACE(x) printf x
#define DETOUR_BREAK()  DebugBreak()
#include <stdio.h>
#include <limits.h>
#else
#define DETOUR_TRACE(x)
#define DETOUR_BREAK()
#endif
#endif

#ifdef DETOURS_IA64
__declspec(align(16)) struct DETOUR_IA64_BUNDLE
{
  public:
    union
    {
        BYTE    data[16];
        UINT64  wide[2];
    };

  public:
    struct DETOUR_IA64_METADATA;

    typedef BOOL (DETOUR_IA64_BUNDLE::* DETOUR_IA64_METACOPY)
        (const DETOUR_IA64_METADATA *pMeta, DETOUR_IA64_BUNDLE *pDst) const;

    enum {
        A_UNIT  = 1u,
        I_UNIT  = 2u,
        M_UNIT  = 3u,
        B_UNIT  = 4u,
        F_UNIT  = 5u,
        L_UNIT  = 6u,
        X_UNIT  = 7u,
        UNIT_MASK = 7u,
        STOP    = 8u
    };
    struct DETOUR_IA64_METADATA
    {
        ULONG       nTemplate       : 8;    // Instruction template.
        ULONG       nUnit0          : 4;    // Unit for slot 0
        ULONG       nUnit1          : 4;    // Unit for slot 1
        ULONG       nUnit2          : 4;    // Unit for slot 2
        DETOUR_IA64_METACOPY    pfCopy;     // Function pointer.
    };

  protected:
    BOOL CopyBytes(const DETOUR_IA64_METADATA *pMeta, DETOUR_IA64_BUNDLE *pDst) const;
    BOOL CopyBytesMMB(const DETOUR_IA64_METADATA *pMeta, DETOUR_IA64_BUNDLE *pDst) const;
    BOOL CopyBytesMBB(const DETOUR_IA64_METADATA *pMeta, DETOUR_IA64_BUNDLE *pDst) const;
    BOOL CopyBytesBBB(const DETOUR_IA64_METADATA *pMeta, DETOUR_IA64_BUNDLE *pDst) const;
    BOOL CopyBytesMLX(const DETOUR_IA64_METADATA *pMeta, DETOUR_IA64_BUNDLE *pDst) const;

    static const DETOUR_IA64_METADATA s_rceCopyTable[33];

  public:
    // 120 112 104 96 88 80 72 64 56 48 40 32 24 16  8  0
    //  f.  e.  d. c. b. a. 9. 8. 7. 6. 5. 4. 3. 2. 1. 0.

    //                                      00
    // f.e. d.c. b.a. 9.8. 7.6. 5.4. 3.2. 1.0.
    // 0000 0000 0000 0000 0000 0000 0000 001f : Template [4..0]
    // 0000 0000 0000 0000 0000 03ff ffff ffe0 : Zero [ 41..  5]
    // 0000 0000 0000 0000 0000 3c00 0000 0000 : Zero [ 45.. 42]
    // 0000 0000 0007 ffff ffff c000 0000 0000 : One  [ 82.. 46]
    // 0000 0000 0078 0000 0000 0000 0000 0000 : One  [ 86.. 83]
    // 0fff ffff ff80 0000 0000 0000 0000 0000 : Two  [123.. 87]
    // f000 0000 0000 0000 0000 0000 0000 0000 : Two  [127..124]
    BYTE    GetTemplate() const;
    BYTE    GetInst0() const;
    BYTE    GetInst1() const;
    BYTE    GetInst2() const;
    BYTE    GetUnit0() const;
    BYTE    GetUnit1() const;
    BYTE    GetUnit2() const;
    UINT64  GetData0() const;
    UINT64  GetData1() const;
    UINT64  GetData2() const;

  public:
    BOOL    IsBrl() const;
    VOID    SetBrl();
    VOID    SetBrl(UINT64 target);
    UINT64  GetBrlTarget() const;
    VOID    SetBrlTarget(UINT64 target);
    VOID    SetBrlImm(UINT64 imm);
    UINT64  GetBrlImm() const;

    BOOL    IsMovlGp() const;
    UINT64  GetMovlGp() const;
    VOID    SetMovlGp(UINT64 gp);

    VOID    SetInst0(BYTE nInst);
    VOID    SetInst1(BYTE nInst);
    VOID    SetInst2(BYTE nInst);
    VOID    SetData0(UINT64 nData);
    VOID    SetData1(UINT64 nData);
    VOID    SetData2(UINT64 nData);
    BOOL    SetNop0();
    BOOL    SetNop1();
    BOOL    SetNop2();
    BOOL    SetStop();

    BOOL    Copy(DETOUR_IA64_BUNDLE *pDst) const;
};
#endif // DETOURS_IA64

//////////////////////////////////////////////////////////////////////////////

#endif // DETOURS_INTERNAL
#endif // __cplusplus

#endif // _DETOURS_H_
//
////////////////////////////////////////////////////////////////  End of File.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\FCL\Include\syelog.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Detours Test Program (syelog.h of syelog.lib)
//
//  Microsoft Research Detours Package, Version 2.1.
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
#pragma once
#ifndef _SYELOGD_H_
#define _SYELOGD_H_
#include <stdarg.h>

#pragma pack(push, 1)
#pragma warning(push)
#pragma warning(disable: 4200)

//////////////////////////////////////////////////////////////////////////////
//
//
#define SYELOG_PIPE_NAMEA       "\\\\.\\pipe\\syelog"
#define SYELOG_PIPE_NAMEW       L"\\\\.\\pipe\\syelog"
#ifdef UNICODE
#define SYELOG_PIPE_NAME        SYELOG_PIPE_NAMEW
#else
#define SYELOG_PIPE_NAME        SYELOG_PIPE_NAMEA
#endif

//////////////////////////////////////////////////////////////////////////////
//
#define SYELOG_MAXIMUM_MESSAGE  4086    // 4096 - sizeof(header stuff)

typedef struct _SYELOG_MESSAGE
{
    USHORT      nBytes;
    BYTE        nFacility;
    BYTE        nSeverity;
    DWORD       nProcessId;
    FILETIME    ftOccurance;
    BOOL        fTerminate;
    CHAR        szMessage[SYELOG_MAXIMUM_MESSAGE];
} SYELOG_MESSAGE, *PSYELOG_MESSAGE;


// Facility Codes.
//
#define SYELOG_FACILITY_KERNEL          0x10            // OS Kernel
#define SYELOG_FACILITY_SECURITY        0x20            // OS Security
#define SYELOG_FACILITY_LOGGING         0x30            // OS Logging-internal
#define SYELOG_FACILITY_SERVICE         0x40            // User-mode system daemon
#define SYELOG_FACILITY_APPLICATION     0x50            // User-mode application
#define SYELOG_FACILITY_USER            0x60            // User self-generated.
#define SYELOG_FACILITY_LOCAL0          0x70            // Locally defined.
#define SYELOG_FACILITY_LOCAL1          0x71            // Locally defined.
#define SYELOG_FACILITY_LOCAL2          0x72            // Locally defined.
#define SYELOG_FACILITY_LOCAL3          0x73            // Locally defined.
#define SYELOG_FACILITY_LOCAL4          0x74            // Locally defined.
#define SYELOG_FACILITY_LOCAL5          0x75            // Locally defined.
#define SYELOG_FACILITY_LOCAL6          0x76            // Locally defined.
#define SYELOG_FACILITY_LOCAL7          0x77            // Locally defined.
#define SYELOG_FACILITY_LOCAL8          0x78            // Locally defined.
#define SYELOG_FACILITY_LOCAL9          0x79            // Locally defined.

// Severity Codes.
//
#define SYELOG_SEVERITY_FATAL           0x00            // System is dead.
#define SYELOG_SEVERITY_ALERT           0x10            // Take action immediately.
#define SYELOG_SEVERITY_CRITICAL        0x20            // Critical condition.
#define SYELOG_SEVERITY_ERROR           0x30            // Error
#define SYELOG_SEVERITY_WARNING         0x40            // Warning
#define SYELOG_SEVERITY_NOTICE          0x50            // Significant condition.
#define SYELOG_SEVERITY_INFORMATION     0x60            // Informational
#define SYELOG_SEVERITY_AUDIT_FAIL      0x66            // Audit Failed
#define SYELOG_SEVERITY_AUDIT_PASS      0x67            // Audit Succeeeded
#define SYELOG_SEVERITY_DEBUG           0x70            // Debugging

// Logging Functions.
//
VOID SyelogOpen(PCSTR pszIdentifier, BYTE nFacility);
VOID Syelog(BYTE nSeverity, PCSTR pszMsgf, ...);
VOID SyelogV(BYTE nSeverity, PCSTR pszMsgf, va_list args);
VOID SyelogClose(BOOL fTerminate);

#pragma warning(pop)
#pragma pack(pop)

#endif //  _SYELOGD_H_
//
///////////////////////////////////////////////////////////////// End of File.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\FCL\Include\MITMClient.h ===
///////////////////////////////////////////////////////////////////////////
//
// MITM Client
//
// C++ Class Defining Unmanaged Interactions with the SWI MITM Server
//
//
// Copyright 2005, Microsoft Corporation
//
//

#pragma once

#ifndef MITM_CLIENT_H
#define MITM_CLIENT_H

#define DllExport		__declspec( dllexport )

// Error Messages
//
// IMPORTANT: These MUST be kept in sync manually between the unmanaged interface and
//            the managed code of the servers
#define MITM_SERVER_ERROR_NONE							0
#define MITM_SERVER_ERROR_UNKNOWN						1
#define MITM_SERVER_ERROR_ILLEGAL_ARGUMENT				2
#define MITM_SERVER_ERROR_NOT_INITIALIZED				3
#define MITM_SERVER_ERROR_ALREADY_INITIALIZED			4
#define MITM_SERVER_ERROR_CONFLICTING_INSTANCE_ALREADY_EXISTS				5

#define MITM_ERROR_RESERVED_FOR_INTERFACE_APPLICATIONS_START			1024
#define MITM_SERVER_ERROR_OUT_OF_MEM					(MITM_ERROR_RESERVED_FOR_INTERFACE_APPLICATIONS_START + 0)
#define MITM_SERVER_ERROR_IPC_FAILURE					(MITM_ERROR_RESERVED_FOR_INTERFACE_APPLICATIONS_START + 1)
#define MITM_SERVER_ERROR_UNEXPECTED_RESPONSE			(MITM_ERROR_RESERVED_FOR_INTERFACE_APPLICATIONS_START + 2)
#define MITM_SERVER_ERROR_INTERFACE_ALREADY_ACTIVE		(MITM_ERROR_RESERVED_FOR_INTERFACE_APPLICATIONS_START + 3)
#define MITM_SERVER_ERROR_INTERFACE_NOT_ACTIVE			(MITM_ERROR_RESERVED_FOR_INTERFACE_APPLICATIONS_START + 4)
#define MITM_SERVER_ERROR_CLASS_NOT_VALID_INTERFACE		(MITM_ERROR_RESERVED_FOR_INTERFACE_APPLICATIONS_START + 5)
#define MITM_SERVER_ERROR_CLASS_NOT_FOUND				(MITM_ERROR_RESERVED_FOR_INTERFACE_APPLICATIONS_START + 6)
#define MITM_SERVER_ERROR_CLASS_NOT_INSTANTIATED		(MITM_ERROR_RESERVED_FOR_INTERFACE_APPLICATIONS_START + 7)
#define MITM_SERVER_ERROR_SESSION_NOT_ACTIVE			(MITM_ERROR_RESERVED_FOR_INTERFACE_APPLICATIONS_START + 8)
#define MITM_SERVER_ERROR_CLASS_NOT_PROPERLY_DEFINED	(MITM_ERROR_RESERVED_FOR_INTERFACE_APPLICATIONS_START + 9)
#define MITM_SERVER_ERROR_ILLEGAL_IDENTIFIER			(MITM_ERROR_RESERVED_FOR_INTERFACE_APPLICATIONS_START + 10)
#define MITM_SERVER_ERROR_COMMAND_NOT_PROPERLY_DEFINED	(MITM_ERROR_RESERVED_FOR_INTERFACE_APPLICATIONS_START + 11)

// Key constants
//
#define MITM_SERVER_INVALID_SESSION_ID					0

namespace MITMClient
{
	// Fuzzer Message Type Declarations
	class ServerToClientMessage;
	class ClientToServerMessage;
	typedef ServerToClientMessage * (*MITM_MESSAGE_CTOR_FUNC)( const LPBYTE, DWORD );

	// Useful functions
	DllExport WCHAR *ConvertToUnicode( const CHAR *source );

	class DllExport Buffer
	{
	public:
		// Constructors and Destructors
		Buffer( void );
		virtual ~Buffer( void );

		// Modifiers
		void Set( DWORD cbBuferMax );
		void Set( PBYTE pbBuffer, DWORD cbBufferUsed );
		virtual void Set( PBYTE pbBuffer, DWORD cbBufferMax, DWORD cBufferUsed ) = 0;

		// Accessors
		inline const PBYTE GetBuffer( void ) const			{ return m_pbBuffer; }
		inline DWORD GetBufferSizeUsed( void ) const		{ return m_cbBufferUsed; }
		inline DWORD GetBufferSizeMax( void ) const			{ return m_cbBufferMax; }

	protected:
		PBYTE	m_pbBuffer;
		DWORD	m_cbBufferMax;
		DWORD	m_cbBufferUsed;
	};

	class DllExport LocalBuffer : public Buffer
	{
	public:
		// Constructors and Destructors
		LocalBuffer( void );
		virtual ~LocalBuffer( void );

		// Modifiers
		virtual void Set( PBYTE pbBuffer, DWORD cbBufferMax, DWORD cBufferUsed );
	};

	class DllExport RemoteBuffer : public Buffer
	{
	public: 
		// Constructors and Destructors
		RemoteBuffer( void );
		virtual ~RemoteBuffer( void );

		// Modifiers
		virtual void Set( PBYTE pbBuffer, DWORD cbBufferMax, DWORD cBufferUsed );
	};

	class DllExport RemoteClass
	{
	public:
			// Constructors and Destructors
			RemoteClass( void );
			RemoteClass( const char *pszClassname );
			RemoteClass( char **pszDefinitionString, char chArgumentSeparator, char chDefinitionSeparator );
			RemoteClass( const char *pszClassname, DWORD cArguments, ... );
			RemoteClass( const char *pszClassname, DWORD cArguments, const char **ppszArguments );
			RemoteClass( const WCHAR *pwzClassname );
			RemoteClass( WCHAR **pwzDefinitionString, WCHAR wchArgumentSeparator, WCHAR wchDefinitionSeparator );
			RemoteClass( const WCHAR *pwzClassname, DWORD cArguments, ... );
			RemoteClass( const WCHAR *pwzClassname, DWORD cArguments, const WCHAR **ppwzArguments );

#ifdef _NATIVE_WCHAR_T_DEFINED
			RemoteClass( const UINT16 *pwzClassname );
			RemoteClass( UINT16 **pwzDefinitionString, UINT16 wchArgumentSeparator, UINT16 wchDefinitionSeparator );
			RemoteClass( const UINT16 *pwzClassname, DWORD cArguments, ... );
			RemoteClass( const UINT16 *pwzClassname, DWORD cArguments, const UINT16 **ppwzArguments );
#endif
			virtual ~RemoteClass( void );

			// Factory constructors
			static RemoteClass **ParseDefinitions( const char *pszDefinition, char chArgumentSeparator, char chDefinitionSeparator, DWORD *pcDefinitions );
#ifdef _NATIVE_WCHAR_T_DEFINED
			static RemoteClass **ParseDefinitions( const UINT16 *pwzDefinition, UINT16 wchArgumentSeparator, UINT16 wchDefinitionSeparator, DWORD *pcDefinitions );
#endif
			static RemoteClass **ParseDefinitions( const WCHAR *pwzDefinition, WCHAR wchArgumentSeparator, WCHAR wchDefinitionSeparator, DWORD *pcDefinitions );
			static void FreeDefinitions( DWORD cDefinitions, RemoteClass **arrpobjDefinitions );

			// Accessors:
			//
			// The Get* functions exist to handle the Razzle/VS split, where Razzle builds
			// may treat WCHAR as a UINT16, but VS 2005 treats it as an internal type. We cannot
			// overload the return value of Classname and Argument (because they would differ only
			// in return value), so we have separate accessors that use them to allow access for
			// any client application that considers a WCHAR to be a UINT16
			void GetClassname( const WCHAR **ppwzClassname ) const;
			void GetArgument( DWORD index, const WCHAR **ppwzArgument ) const;
#ifdef _NATIVE_WCHAR_T_DEFINED
			void GetClassname( const UINT16 **ppwzClassname ) const;
			void GetArgument( DWORD index, const UINT16 **ppwzArgument ) const;
#endif
			const WCHAR *Classname( void ) const;
			DWORD ArgumentCount( void ) const;
			const WCHAR *Argument( DWORD index ) const;
			bool IsValid( void ) const;
			
	private:
			// Modifiers
			void ParseDefinition( WCHAR **ppwzDefinition, WCHAR wchArgumentSeparator, WCHAR wchDefinitionSeparator );
			static DWORD CountDefinitions( const WCHAR *pwzDefinition, WCHAR wchDefinitionSeparator );
			static DWORD CountArguments( const WCHAR *pwzDefinition, WCHAR wchArgumentSeparator, WCHAR wchDefinitionSeperator );
			static void CopyArgument( WCHAR **ppwzSource, WCHAR *pwzDestination, WCHAR wchArgumentSeparator, WCHAR wchDefinitionSeparator );

			// Data Members
			WCHAR *	m_pwzClassname;
			DWORD	m_cArguments;
			WCHAR**	m_ppwzArguments;
	};

	class DllExport Interface
	{
	public:
		Interface( void );
		virtual ~Interface( void );

		// Functions
		bool Configure(		const CHAR	*pszMITMServer,			// Input, Server named pipe
							DWORD	cbBufferSize,				// Input, Size of the Fuzzing buffers
							DWORD	*pdwErrorCode = NULL		// Optional Output, the error code if an error occurred
							);

#ifdef _NATIVE_WCHAR_T_DEFINED
		bool Configure(		const UINT16 *pwzMITMServer,// Input, Server named pipe
							DWORD	cbBufferSize,				// Input, Size of the Fuzzing buffers
							DWORD	*pdwErrorCode = NULL		// Optional Output, the error code if an error occurred
							);
#endif

		bool Configure(		const WCHAR	*pwzMITMServer,			// Input, Server named pipe
							DWORD	cbBufferSize,				// Input, Size of the Fuzzing buffers
							DWORD	*pdwErrorCode = NULL		// Optional Output, the error code if an error occurred
							);

		bool RequestPlugIn( const char * pszPlugInIdentifier,	// Input, the Identifier assigned to the plugin
							const RemoteClass *pobjPlugIn,		// Input, the PlugIn class definition
							DWORD *pdwErrorCode = NULL			// Optional Output, the error code if an error occurred
							);

#ifdef _NATIVE_WCHAR_T_DEFINED
		bool RequestPlugIn( const UINT16 * pwzPlugInIdentifier,	 // Input, the Identifier assigned to the plugin
							const RemoteClass *pobjPlugIn,		 // Input, the PlugIn class definition
							DWORD *pdwErrorCode = NULL			 // Optional Output, the error code if an error occurred
							);
#endif

		bool RequestPlugIn( const WCHAR * pwzPlugInIdentifier,	 // Input, the Identifier assigned to the plugin
							const RemoteClass *pobjPlugIn,		 // Input, the PlugIn class definition
							DWORD *pdwErrorCode = NULL			 // Optional Output, the error code if an error occurred
							);

		bool CommandPlugIns(  const char * pszPlugInIdentifier,	// Input, the Identifier assigned to the plugin or plugins (RegExp wildcards are acceptable)
							const char * pszCommand,			// Input, the command string to the plugin
							DWORD cArguments,					// Input, the number of arguments
							const char **ppszArguments,			// Input, the arguments (or NULL if the argument count is zero)
							DWORD *pdwErrorCode = NULL			// Optional Output, the error code if an error occurred
							);

#ifdef _NATIVE_WCHAR_T_DEFINED
		bool CommandPlugIns(  const UINT16 * pwzPlugInIdentifier,	// Input, the Identifier assigned to the plugin or plugins  (RegExp wildcards are acceptable)
							const UINT16 * pwzCommand,				// Input, the command string to the plugin
							DWORD cArguments,						// Input, the number of arguments
							const UINT16 **ppwzArguments,			// Input, the arguments (or NULL if the argument count is zero)
							DWORD *pdwErrorCode = NULL				// Optional Output, the error code if an error occurred
							);
#endif

		bool CommandPlugIns(  const WCHAR * pwzPlugInIdentifier,// Input, the Identifier assigned to the plugin or plugins  (RegExp wildcards are acceptable)
							const WCHAR * pwzCommand,			// Input, the command string to the plugin
							DWORD cArguments,					// Input, the number of arguments
							const WCHAR **ppwzArguments,		// Input, the arguments (or NULL if the argument count is zero)
							DWORD *pdwErrorCode = NULL			// Optional Output, the error code if an error occurred
							);

		bool StartSession(	const char * pszMachineName,		// Input, the machine name of the instrumented application
							const char * pszImageName,			// Input, the image name of the instrumented process
							DWORD		 dwProcessId,			// Input, the process id of the instrumented process
							const RemoteClass *pobjProcessor,	// Input, Processing class definition or NULL
							DWORD			   cMonitors,		// Input, Monitor count
							const RemoteClass **ppobjMonitors,	// Input, Monitor class definitions or NULL
							DWORD		*pdwSessionID,			// Output, Pointer to the new Session ID
							DWORD		*pdwErrorCode = NULL	// Optional Output, the error code if an error occurred
							);

#ifdef _NATIVE_WCHAR_T_DEFINED
		bool StartSession(	const UINT16 *pwzMachineName,		// Input, the machine name of the instrumented application
							const UINT16 *pwzImageName,			// Input, the image name of the instrumented process
							DWORD		 dwProcessId,			// Input, the process id of the instrumented process
							const RemoteClass *pobjProcessor,	// Input, Processing class definition or NULL
							DWORD			   cMonitors,		// Input, Monitor count
							const RemoteClass **ppobjMonitors,	// Input, Monitor class definitions or NULL
							DWORD		*pdwSessionID,			// Output, Pointer to the new Session ID
							DWORD		*pdwErrorCode = NULL	// Optional Output, the error code if an error occurred
							);
#endif

		bool StartSession(	const WCHAR *pwzMachineName,		// Input, the machine name of the instrumented application
							const WCHAR *pwzImageName,			// Input, the image name of the instrumented process
							DWORD		 dwProcessId,			// Input, the process id of the instrumented process
							const RemoteClass *pobjProcessor,	// Input, Processing class definition or NULL
							DWORD			   cMonitors,		// Input, Monitor count
							const RemoteClass **ppobjMonitors,	// Input, Monitor class definitions or NULL
							DWORD		*pdwSessionID,			// Output, Pointer to the new Session ID
							DWORD		*pdwErrorCode = NULL	// Optional Output, the error code if an error occurred
							);

		bool EndSession(	DWORD	dwSessionID,			// Input, Session ID
							DWORD  *pdwErrorCode = NULL		// Optional Output, the error code if an error occurred
							);

		bool ProcessData(	DWORD		dwSessionID,				// Input, Session ID
							const CHAR	*pszOperationDescription,	// Input, A description of the operation for logging purposes (or NULL)
							const CHAR	*pszFormatContext,			// Input, Format Context (or NULL)
							DWORD		cBuffers,					// Input, the buffers
							const LocalBuffer *parrInputBuffers,	// Input, the outgoing buffers
							RemoteBuffer **pparrOutputBuffers,		// Output, the returned buffers
							bool		*pfFuzzingDeferred,			// Output, the server is holding the data for further processing, or NULL if that is not a valid option
							bool		*pfSequentialFuzzingComplete, // Output, the server has completed sequential fuzzing, or NULL if we do not care about sequential fuzzing
							DWORD		*pdwErrorCode = NULL		// Optional Output, the error code if an error occurred
							);

#ifdef _NATIVE_WCHAR_T_DEFINED
		bool ProcessData(	DWORD		dwSessionID,				// Input, Session ID
							const UINT16 *pwzOperationDescription,	// Input, A description of the operation for logging purposes (or NULL)
							const UINT16 *pwzFormatContext,			// Input, Format Context (or NULL)
							DWORD		cBuffers,					// Input, the buffers
							const LocalBuffer *parrInputBuffers,	// Input, the outgoing buffers
							RemoteBuffer **pparrOutputBuffers,		// Output, the returned buffers
							bool		*pfFuzzingDeferred,			// Output, the server is holding the data for further processing, or NULL if that is not a valid option
							bool		*pfSequentialFuzzingComplete, // Output, the server has completed sequential fuzzing, or NULL if we do not care about sequential fuzzing
							DWORD		*pdwErrorCode = NULL		// Optional Output, the error code if an error occurred
							);
#endif

		bool ProcessData(	DWORD		dwSessionID,				// Input, Session ID
							const WCHAR	*pwzOperationDescription,	// Input, A description of the operation for logging purposes (or NULL)
							const WCHAR	*pwzFormatContext,			// Input, Format Context (or NULL)
							DWORD		cBuffers,					// Input, the buffers
							const LocalBuffer *parrInputBuffers,	// Input, the outgoing buffers
							RemoteBuffer **pparrOutputBuffers,		// Output, the returned buffers
							bool		*pfFuzzingDeferred,			// Output, the server is holding the data for further processing, or NULL if that is not a valid option
							bool		*pfSequentialFuzzingComplete, // Output, the server has completed sequential fuzzing, or NULL if we do not care about sequential fuzzing
							DWORD		*pdwErrorCode = NULL		// Optional Output, the error code if an error occurred
							);

		bool ReportData(	DWORD		dwSessionID,				// Input, Session ID
							const CHAR	*pszOperationDescription,	// Input, A description of the operation for logging purposes (or NULL)
							const CHAR	*pszFormatContext,			// Input, Format Context (or NULL)
							DWORD		cBuffers,					// Input, the buffers
							const LocalBuffer *parrInputBuffers,	// Input, the outgoing buffers
							DWORD		*pdwErrorCode = NULL		// Optional Output, the error code if an error occurred
							);

#ifdef _NATIVE_WCHAR_T_DEFINED
		bool ReportData(	DWORD		dwSessionID,					// Input, Session ID
							const UINT16	*pwzOperationDescription,	// Input, A description of the operation for logging purposes (or NULL)
							const UINT16	*pwzFormatContext,			// Input, Format Context (or NULL)
							DWORD		cBuffers,						// Input, the buffers
							const LocalBuffer *parrInputBuffers,		// Input, the outgoing buffers
							DWORD		*pdwErrorCode = NULL			// Optional Output, the error code if an error occurred
							);
#endif

		bool ReportData(	DWORD		dwSessionID,				// Input, Session ID
							const WCHAR	*pwzOperationDescription,	// Input, A description of the operation for logging purposes (or NULL)
							const WCHAR	*pwzFormatContext,			// Input, Format Context (or NULL)
							DWORD		cBuffers,					// Input, the buffers
							const LocalBuffer *parrInputBuffers,	// Input, the outgoing buffers
							DWORD		*pdwErrorCode = NULL		// Optional Output, the error code if an error occurred
							);

		bool UnwindProcessedData(
							DWORD		dwSessionID,				// Input, Session ID
							const CHAR	*pszOperationDescription,	// Input, A description of the operation for logging purposes (or NULL)
							const CHAR	*pszFormatContext,			// Input, Format Context (or NULL)
							DWORD		cbData,						// Input, the bytes to unwind
							DWORD		*pdwErrorCode = NULL		// Optional Output, the error code if an error occurred
							);

#ifdef _NATIVE_WCHAR_T_DEFINED
		bool UnwindProcessedData(
							DWORD		dwSessionID,				// Input, Session ID
							const UINT16 *pwzOperationDescription,	// Input, A description of the operation for logging purposes (or NULL)
							const UINT16 *pwzFormatContext,			// Input, Format Context (or NULL)
							DWORD		cbData,						// Input, the bytes to unwind
							DWORD		*pdwErrorCode = NULL		// Optional Output, the error code if an error occurred
							);
#endif

		bool UnwindProcessedData(
							DWORD		dwSessionID,				// Input, Session ID
							const WCHAR	*pwzOperationDescription,	// Input, A description of the operation for logging purposes (or NULL)
							const WCHAR	*pwzFormatContext,			// Input, Format Context (or NULL)
							DWORD		cbData,						// Input, the bytes to unwind
							DWORD		*pdwErrorCode = NULL		// Optional Output, the error code if an error occurred
							);

		bool LogMessage(
							DWORD		dwSessionID,				// Input, Session ID
							const CHAR	*pszMessage,				// Input, The message to log
							DWORD		*pdwErrorCode = NULL		// Optional Output, the error code if an error occurred
							);

#ifdef _NATIVE_WCHAR_T_DEFINED
		bool LogMessage(
							DWORD		dwSessionID,				// Input, Session ID
							const UINT16 *pwzMessage,				// Input, The message to log
							DWORD		*pdwErrorCode = NULL		// Optional Output, the error code if an error occurred
							);
#endif

		bool LogMessage(
							DWORD		dwSessionID,				// Input, Session ID
							const WCHAR	*pwzMessage,				// Input, The message to log
							DWORD		*pdwErrorCode = NULL		// Optional Output, the error code if an error occurred
							);

		bool LogMessage(
							const CHAR	*pszMessage,				// Input, The message to log
							DWORD		*pdwErrorCode = NULL		// Optional Output, the error code if an error occurred
							);

#ifdef _NATIVE_WCHAR_T_DEFINED
		bool LogMessage(
							const UINT16 *pwzMessage,				// Input, The message to log
							DWORD		*pdwErrorCode = NULL		// Optional Output, the error code if an error occurred
							);
#endif

		bool LogMessage(
							const WCHAR	*pwzMessage,				// Input, The message to log
							DWORD		*pdwErrorCode = NULL		// Optional Output, the error code if an error occurred
							);
	private:
		ServerToClientMessage *SendMessage( const WCHAR * pwzMITMServer, const ClientToServerMessage *pobjMessage );
		static inline void SetError( DWORD *pdwError, DWORD dwErrorValue )		{ if( pdwError) *pdwError = dwErrorValue; }

		// Transmission Buffers
		DWORD				m_cbBufferSize;
		PBYTE				m_pbInputBuffer;
		PBYTE				m_pbOutputBuffer;

		// Message Mapping
		MITM_MESSAGE_CTOR_FUNC	*m_parrMessageMap;

		// Session Management
		DWORD				m_cSessions;
		WCHAR				m_wzMITMServer[MAX_PATH];

		// Thread Safety
		CRITICAL_SECTION	m_objLock;
	};
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MSCOMGeoInfo\1.0.0.0\SDK\GeoLocation_API_Sample\Default.aspx.cs ===
using System;
using System.Data;
using System.Configuration;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Web.UI.HtmlControls;
using Microsoft.MSCOM.Geo.GeoLocationAPI;
using System.Collections;


public partial class _Default : System.Web.UI.Page 
{
    private System.Collections.Generic.List<CountryRegion> countries = null;
    private DropDownList countryListTable = null;

    protected void Page_Load(object sender, EventArgs e)
    {
        /*System.Text.StringBuilder buf = new System.Text.StringBuilder();
        buf.Append("<H4>");
        buf.Append("Hello User");
        buf.Append("<br/> You are located at <i> "+ Profile.CityName + ","
                                                + Profile.StateProvinceName + "," 
                                                + Profile.CountryRegionName 
                                                + "</i>"
                  );
        buf.Append("<br/>This sample web application demonstrates the usage of GeoLocation API . ");
        buf.Append("Please click the Run button next to each of the options");
        buf.Append("</h4>");
        
        intro.Visible = true;

        intro.InnerHtml = buf.ToString();
         * */
        //showHelpMessage(buf.ToString());

    }


    
     #region "Run Button Methods"
     protected void getGeoFromIP_Button_Click(object sender, EventArgs e)
    {
       
         
        controlOptions(false, getGeoFromIP_Input);

        if (!getGeoFromIP_Input.Visible)
        {
            getGeoFromIP_Input.Visible = true;
        }

    }

    protected void getGeoFromMapID_Button_Click(object sender, EventArgs e)
    {
        controlOptions(false, getGeoFromMapID_Input);

        if (!getGeoFromMapID_Input.Visible)
        {
            getGeoFromMapID_Input.Visible = true;
        }

    }

    protected void getGeoFromPostal_Button_Click(object sender, EventArgs e)
    {
        controlOptions(false, getGeoFromPostal_Input);

        if (!getGeoFromPostal_Input.Visible)
        {
            getGeoFromPostal_Input.Visible = true;
        }

    }
#endregion  

    #region "Private Utility Methods"
    private void showHelpMessage(String msg)
    {
        RealData.Text = msg;

    }

    private void controlOptions(bool flag , HtmlGenericControl control)
    {
          RealData.Text = null;
          CodeBehind.Text = null;
          RealData.Controls.Clear();

          if( control.ID != "getGeoFromPostal_Input")
              getGeoFromPostal_Input.Visible = flag;

          if (control.ID != "getGeoFromMapID_Input")
              getGeoFromMapID_Input.Visible = flag;

          if (control.ID != "getGeoFromIP_Input")
              getGeoFromIP_Input.Visible = flag;

    }

    private void displayGeoInfo(GeoInfo geoInfo)
    {
        if (geoInfo == null)
        {
            String message = "<h3>Error locating geo information from the input</h3";
            showHelpMessage(message);
            return;
        }

 

        System.Text.StringBuilder buf = new System.Text.StringBuilder();
        buf.Append("<H4>geoInfo { ");
        buf.Append("<ul> ");


        buf.Append("cityDisplayName - ").AppendLine().Append("  ").Append(geoInfo.CityDisplayName).AppendLine();
        buf.Append("</ul> ");
        buf.Append("<ul> ");

        buf.Append("StateProvinceCode - ").AppendLine().Append("  ").Append(geoInfo.StateProvinceCode).AppendLine();
        buf.Append("</ul> ");
        buf.Append("<ul> ");

        buf.Append("StateProvinceDisplayName - ").AppendLine().Append("  ").Append(geoInfo.StateProvinceDisplayName).AppendLine();
        buf.Append("</ul> ");
        buf.Append("<ul> ");

        buf.Append("ZipCodeString - ").AppendLine().Append("  ").Append(geoInfo.ZipcodeInfo).AppendLine();
        buf.Append("</ul> ");
        buf.Append("<ul> ");

        buf.Append("CountryRegionCode - ").AppendLine().Append("  ").Append(geoInfo.CountryRegionCode).AppendLine();
        buf.Append("</ul> ");
        buf.Append("<ul> ");

        buf.Append("CountryRegionDisplayName - ").AppendLine().Append("  ").Append(geoInfo.CountryRegionDisplayName).AppendLine();
        buf.Append("</ul> ");

  /*      buf.Append("<ul> ");
        buf.Append("DSTEndTimeUniversal - " + geoInfo.DSTEndTimeUniversal + "\n");
        buf.Append("DSTTimeZoneOffset - " + geoInfo.DSTTimeZoneOffset + "\n");
        buf.Append("IsEuropeanUnion - " + geoInfo.IsEuropeanUnion + "\n");
        buf.Append("Latitude - " + geoInfo.Latitude + "\n");
        buf.Append("Longitude - " + geoInfo.Longitude + "\n");
        buf.Append("MapPointId - " + geoInfo.MapPointId + "\n");
        buf.Append("MapPointIDParent - " + geoInfo.MapPointIDParent + "\n");
        buf.Append("TimeZoneDisplayName - " + geoInfo.TimeZoneDisplayName + "\n");

        
        buf.Append("</ul>");
    
   * 
   * 
   */
        buf.Append("} </H4>");

 
        //display.Visible = true;
        //display.Controls.Clear();
        //display.InnerHtml = buf.ToString();


        RealData.Text = buf.ToString();


    }

    private GeoZipCodeStringMode getGeoZipCodeStringMode(String value)
    {
        if (value != null)
        {

            if (value.Equals("GeoZipCodeStringMode.None"))
            {
                return GeoZipCodeStringMode.None;
            }
            else if (value.Equals("GeoZipCodeStringMode.ZipCodeString"))
            {
                return GeoZipCodeStringMode.ZipCodeString;
            }
            else
            {
                return GeoZipCodeStringMode.ZipCodeStringPlus;
            }
        }
        else
        {
            return GeoZipCodeStringMode.None;
        }
    }
    #endregion

 

    #region "API Invoking Methods"

       protected void getCGL_Button_Click(object sender, EventArgs e)
    {
        controlOptions(false, getCGL);
        String userLanguage = null;
        if (countries == null)
        {
            userLanguage = HttpContext.Current.Request.UserLanguages[0];

            /*
             *  The code below is the work horse behind this method.
             *  It invokes the GetCountryRegionList method and fetches a list of CountryRegion objects
             * 
             */

            countries = GeoLocation.GetCountryRegionList(userLanguage);
        }

        if (countries == null || countries.Count < 1)
        {
            String message = "<h4>There was an error loading countries</h4>";
            showHelpMessage(message);
            return;
        }

        if (countryListTable == null)
        {
            countryListTable = new DropDownList();
            countryListTable.BorderStyle = BorderStyle.Dotted;
            countryListTable.Height = Unit.Pixel(100);
            countryListTable.Width = Unit.Pixel(500);

            countryListTable.EnableViewState = false;
            countryListTable.Style["overflow"] = "scroll";


            foreach (CountryRegion country in countries)
            {
                ListItem cell = new ListItem();

                cell.Text = country.DisplayName;
                String toolTip = "DisplayName [" + country.DisplayName
                                          + "] , IsEU [" + country.IsEU
                                          + "] , DisplayLanguage [" + country.DisplayLanguage
                                          + "] , Code [" + country.Code
                                          + "] , LanguageID [" + country.LanguageId + "]";
                //cell.ToolTip = toolTip;

                //row.Controls.Add(cell);

                countryListTable.Items.Add(cell);
            }
        }

        //display.Controls.Clear();
        RealData.Controls.Clear();
        RealData.Text = null;
        RealData.Controls.Add(countryListTable);
        CodeBehind.Text = "GeoLocation.GetCountryRegionList(\"" + userLanguage + "\")";



        //        display.Controls.Add(countryListTable);
        display.Visible = true;

    }

       protected void getGeoFromIP_Invoke_Click(object sender, EventArgs e)
        {
            CodeBehind.Text = null;

            if (String.IsNullOrEmpty(getGeoFromIP_Input_IP.Text))
            {
                String message = "<h3>Please enter an valid IP Address </h3>";
                showHelpMessage(message);
                return;
            }
            String language = HttpContext.Current.Request.UserLanguages[0];

            if (!String.IsNullOrEmpty(getGeoFromIP_Input_Language.Text))
            {
                language = getGeoFromIP_Input_Language.Text;
            }

            String statsData = "Sample User";

            if (!String.IsNullOrEmpty(getGeoFromIP_Input_StatsData.Text))
            {
                statsData = getGeoFromIP_Input_StatsData.Text;
            }

            GeoZipCodeStringMode zipCodeChoice = getGeoZipCodeStringMode(getGeoFromIP_Input_ZipCodeFormatList.SelectedValue);

            CodeBehind.Text = "GeoInfo geoInfo = GeoLocation.GetGeoInfoFromIPAddress(\"" + getGeoFromIP_Input_IP.Text + "\" , \""
                                                        + language + "\" , "
                                                        + getGeoFromIP_Input_ZipCodeFormatList.SelectedValue + " , \""
                                                        + statsData + "\")";


            GeoInfo geoInfo = GeoLocation.GetGeoInfoFromIPAddress(getGeoFromIP_Input_IP.Text,
                                                                    language,
                                                                    zipCodeChoice,
                                                                    statsData);

            displayGeoInfo(geoInfo);
        }

       protected void getGeoFromPostal_Invoke_Click(object sender, EventArgs e)
        {
            CodeBehind.Text = null;
            if (String.IsNullOrEmpty(getGeoFromPostal_Input_PostalCode.Text))
            {
                String message = "<h3>Please enter an valid PostalCode</h3>";
                showHelpMessage(message);
                return;
            }

            if (String.IsNullOrEmpty(getGeoFromPostal_Input_CountryCode.Text))
            {
                String message = "<h3>Please enter an valid CountryCode</h3>";
                showHelpMessage(message);
                return;
            }

            String language = HttpContext.Current.Request.UserLanguages[0];
            String statsData = "Sample User";

            if (!String.IsNullOrEmpty(getGeoFromPostal_Input_Language.Text))
            {
                language = getGeoFromPostal_Input_Language.Text;
            }

            if (!String.IsNullOrEmpty(getGeoFromPostal_Input_StatsData.Text))
            {
                statsData = getGeoFromPostal_Input_StatsData.Text;
            }

            GeoZipCodeStringMode zipCodeChoice = getGeoZipCodeStringMode(getGeoFromPostal_Input_ZipCodeFormatList.SelectedValue);

            CodeBehind.Text = "GeoInfo geoInfo = GeoLocation.GetGeoInfoFromPostalCode(\""
                                    + getGeoFromPostal_Input_PostalCode.Text + "\" , \""
                                    + getGeoFromPostal_Input_CountryCode.Text + "\" , \""
                                    + language + "\" , "
                                    + getGeoFromPostal_Input_ZipCodeFormatList.SelectedValue + " , \""
                                    + statsData + "\" ) ";


            GeoInfo geoInfo = GeoLocation.GetGeoInfoFromPostalCode(getGeoFromPostal_Input_PostalCode.Text,
                                                                   getGeoFromPostal_Input_CountryCode.Text,
                                                                   language,
                                                                   zipCodeChoice,
                                                                   statsData);

            displayGeoInfo(geoInfo);

        }

       protected void getGeoFromMapID_Invoke_Click(object sender, EventArgs e)
        {
            CodeBehind.Text = null;
            int mapId = -1;
            try
            {
                mapId = int.Parse(getGeoFromMapID_Input_MapID.Text);
            }
            catch (Exception myEx)
            {
                String message = "<h3>Please input an integer mapID</h3";
                showHelpMessage(message);
                return;
            }

            String language = HttpContext.Current.Request.UserLanguages[0];
            String statsData = "Sample User";

            if (!String.IsNullOrEmpty(getGeoFromMapID_Input_Language.Text))
            {
                language = getGeoFromMapID_Input_Language.Text;
            }

            if (!String.IsNullOrEmpty(getGeoFromMapID_Input_StatsData.Text))
            {
                statsData = getGeoFromMapID_Input_StatsData.Text;
            }

            GeoZipCodeStringMode zipCodeChoice = getGeoZipCodeStringMode(getGeoFromMapID_Input_ZipCodeFormatList.SelectedValue);

            CodeBehind.Text = "GeoInfo geoInfo = GeoLocation.GetGeoInfoFromMapPointId( "
                                    + mapId + " , \""
                                    + language + "\" , "
                                    + getGeoFromMapID_Input_ZipCodeFormatList.SelectedValue + " , \""
                                    + statsData + "\" )";


            GeoInfo geoInfo = GeoLocation.GetGeoInfoFromMapPointId(mapId,
                                                                   language,
                                                                   zipCodeChoice,
                                                                   statsData);
            displayGeoInfo(geoInfo);

        }
    #endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MSCOMGeoInfo\1.0.0.0\SDK\GeoLocation_Explicit_Set\Default.aspx.cs ===
using System;
using System.Data;
using System.Configuration;
using System.Collections;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Web.UI.HtmlControls;

public partial class _Default : System.Web.UI.Page
{
    protected void Page_Load(object sender, EventArgs e)
    {
        String countryName = Profile.CountryRegionName;
        String regionName = Profile.StateProvinceName;
        String cityName = Profile.CityName;
         



        System.Text.StringBuilder buffer = new System.Text.StringBuilder();
        

        buffer.Append("<H3> Welcome . Events in  <i> ");
        bool setComma = false;
        if (!String.IsNullOrEmpty(cityName)) {
            buffer.Append(cityName).Append(" ");
            setComma = true;
            
        }
        
        if (!String.IsNullOrEmpty(regionName)) {
            if (setComma)
                buffer.Append(" , ");

            buffer.Append(regionName).Append(" ");

            if (!setComma)
                setComma = true;
        }
        
        if (!String.IsNullOrEmpty(countryName)) {
            if (setComma)
                buffer.Append(" , ");

            buffer.Append(countryName).Append(" ");
        }

        buffer.Append(" </i> </h3>");

        intro.InnerHtml = buffer.ToString();

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MSCOMGeoInfo\1.0.0.0\SDK\GeoLocation_Explicit_Set\GeoSegSample.ascx.cs ===
using System;
using System.Data;
using System.Configuration;
using System.Collections;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Web.UI.HtmlControls;

using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using Microsoft.MSCOM.Geo.GeoLocationAPI;

public partial class GeoSegSample : System.Web.UI.UserControl
{
    private List<CountryRegion> countries;
    private List<GeoEntity> states;
    private List<GeoEntity> cities;
    

    protected const String COUNTRIES_WITH_POSTAL_CODE_KEY = "CountriesWithPostalCode";

    protected void Page_Load(object sender, EventArgs e)
    {

        if (!Page.IsPostBack) //accessed first Time
        {

             Hashtable countriesWithPostalCode = new Hashtable(50);
            /* debug */
            //pageEvents.InnerHtml = pageEvents.InnerHtml + " <h5> Page Loading </h5>";
            
//            pageEvents.Visible = true;


             
            if (Request.UrlReferrer != null )
            {
                //pageEvents.InnerText = Request.UrlReferrer.ToString();
                forwardURL.InnerText = Request.UrlReferrer.ToString();
            }
            else
            {
                //pageEvents.InnerText = "Cannot set the referral";
            }

            /*
             * 
             * if (Request.Browser.Cookies)
                pageEvents.InnerText = pageEvents.InnerText + " Cookies are supported";
            else
                pageEvents.InnerText = pageEvents.InnerText + " Cookies are not supported";
             * 
             * */


            

            //ArrayList countries = GeoLocation.getCountryList();

            countries = Microsoft.MSCOM.Geo.GeoLocationAPI.GeoLocation.GetCountryRegionList();

            

            String defaultCountryName = null;

            CountryRegion defaultCountry = null;

            if (countries != null)
            {
                status.Visible = true;
                status.InnerText = "Processing";

                /*
                 * if (countryHashTable.Count > 0)
                {
                    countryHashTable.Clear();
                }
                 * */


                for (int i = 0; i < countries.Count; i++)
                {

                    ListItem item = new ListItem();


                    item.Value = countries[i].Id.ToString() + ";" +  countries[i].Code + ";" + countries[i].LanguageId.ToString() + ";" + countries[i].SupportPostalCode.ToString();
                    item.Text = countries[i].DisplayName;

                    if (countries[i].SupportPostalCode && !countriesWithPostalCode.ContainsKey(item.Value))
                        countriesWithPostalCode.Add(item.Value, null);

                    /*
                     * String details = countries[i].LanguageId.ToString()
                                        + " , " + countries[i].Code
                                        + " , " + countries[i].SupportPostalCode.ToString();

                    pageEvents.InnerText = pageEvents.InnerText + " \n " + details;
                     * 
                     */
                    /* List Item losing attributes on postback, so don't even bother.
                    item.Attributes.Add(LANGUAGE_ID_KEY, countries[i].LanguageId.ToString());
                    item.Attributes.Add(SUPPORTS_POSTAL_CODE_KEY, countries[i].SupportPostalCode.ToString());
                    item.Attributes.Add(COUNTRY_CODE_KEY, countries[i].Code);
                     */

                    CountryList.Items.Add(item);

                    if (i == 0)
                    {
                        item.Selected = true;
                        defaultCountry = countries[i];
                    }
                }
                CountryList.ToolTip = "Please select a Country from the drop down selection";
               

                showChildRegions("country", defaultCountry.GetChildrenList() , defaultCountry.SupportPostalCode);

                status.Visible = false;
                CountryLabel.Visible = true;

               // ViewState[COUNTRIES_WITH_POSTAL_CODE_KEY] = countriesWithPostalCode;
               

            }
            else
            {
                status.Visible = true;
                status.InnerText = "No Values";

                ListItem item = new ListItem();
                item.Text = "Not Available";
                CountryList.Items.Add(item);
            }
             
             
        }
        else
        {
            /*
             * 
            if (Request.UrlReferrer != null)
            {

                pageEvents.InnerText = Request.UrlReferrer.ToString();
                forwardURL.InnerText = Request.UrlReferrer.ToString();
            }
            else
            {
                pageEvents.InnerText = "Cannot set the referral";
            }


            if (Request.Browser.Cookies)
                pageEvents.InnerText = pageEvents.InnerText + " Cookies are supported";
            else
                pageEvents.InnerText = pageEvents.InnerText + " Cookies are not supported";
             * 
             * 
             */



        }

    } //PageLoad end

    protected void showChildRegions(String type, List<GeoEntity> childList , bool countrySupportsPostalCode)
    {
        if (type.Equals("country"))
        { //1st time loading or user changed country 
            if (childList != null && childList.Count > 0)
            {
                pageEvents.InnerText = "";

                String childType = null;
                Type t = childList[0].GetType();
                

                if (t.ToString().Contains("StateProvince"))
                {
                    childType = "state";
                }
                else if (t.ToString().Contains("City")) 
                {
                    childType = "city";
                } else  
                {
                    childType = "unknown";
                }

                if (childType.Equals("state"))
                {
                    CityList.Visible = false;
                    CityLabel.Visible = false;
                   // states = childList ;
                    renderField("state", childList);
                }
                else
                {
                    RegionLabel.Visible = false;
                    RegionList.Visible = false;
                  //  cities =  childList ;
                    renderField("city", childList);
                }
                if (countrySupportsPostalCode)
                    showPostalCodeOption(true);
                 

            }
            else
            {
                //showPostalCodeOption(false);
                RegionAndCityBlock.Visible = false;
                pageEvents.InnerText = "Sorry, We don't have further information on this country.";


 /*               RegionList.Visible = false;
                RegionLabel.Visible = false;

                CityList.Visible = false;
                CityLabel.Visible = false;
   
  * 
  * 
  */
            }
        }
        else
        {
            //if (cities != null && cities.Count > 0)
              //  cities.Clear();

            //if (CityList.Items.Count > 0)
              //  CityList.Items.Clear();

            //cities = childList;
            renderField("city", childList);
        }

    }

    private void renderField(String type, List<GeoEntity> childList)
    {
        if (type.Equals("state"))
        {
            StateProvince defaultState = null;
            if (RegionList.Items.Count > 0)
                RegionList.Items.Clear();
            StateProvince state = null;
            for (int stateIndex = 0; stateIndex < childList.Count; stateIndex++)
            {
                ListItem stateItem = new ListItem();
                state = (StateProvince)childList[stateIndex];
                stateItem.Text = state.DisplayName;
                stateItem.Value = state.Id.ToString();

                //stateItem.Attributes.Add(LANGUAGE_ID_KEY, state.LanguageId.ToString());
                RegionList.Items.Add(stateItem);

                if (stateIndex == 0)
                    defaultState = state;

            }
            
            showChildRegions("state" , defaultState.GetChildrenList() , false);
            
            RegionList.Visible = true;
            RegionLabel.Visible = true;
 
        }
        else if (type.Equals("city"))
        {
            if (CityList.Items.Count > 0)
                CityList.Items.Clear();

            City city = null;
            for (int cityIndex = 0; cityIndex < childList.Count; cityIndex++)
            {
                city = (City)childList[cityIndex];

                ListItem cityItem = new ListItem();
                cityItem.Text = city.DisplayName;
                cityItem.Value = city.Id.ToString();

                // cityItem.Attributes.Add(LANGUAGE_ID_KEY, city.LanguageId.ToString());
                CityList.Items.Add(cityItem);
            }
            CityList.Visible = true;
            CityLabel.Visible = true;
            //SaveButton.Enabled = true;

             
        }
    }


    

    protected void showPostalCodeOption(bool isPostal )
    {

        if ( isPostal )
        {
            // Show the option for user to select by PostalCode 

             
            showUserOption.Visible = true;
            showUserOption.Checked = false;

            displayMessage.Visible = true;
            displayMessage.InnerText = "Select To Enter PostalCode";

            PostalCodeBlock.Visible = false;
            PostalCode.Text = "";
            showPostalState.Checked = false;
             

        }
        else
        {
            // disable all PostalCode related stuff.

             
            PostalCodeBlock.Visible = false;
            PostalCode.Text = "";


            showUserOption.Checked = false;
            showUserOption.Visible = false;

            displayMessage.Visible = false;
            displayMessage.InnerText = "";

            showPostalState.Checked = false;

            //SaveButton.Enabled = false;

        }
    }


    private void stylizeElement(String elem)
    {
        if (elem.Equals("city"))
        {
            CityLabel.Style.Add("top" , "300px");
            CityLabel.Style.Add("left" , "300px");

            CityList.Style.Add("top" , "600px");
            CityList.Style.Add("left" , "600px");

        }

        else if (elem.Equals("state"))
        {
            RegionLabel.Style.Add("top"  , "100px");
            RegionLabel.Style.Add("left" , "100px" );

            RegionList.Style.Add("top", "500px");
            RegionList.Style.Add("left", "500px");


        }

        else if (elem.Equals("country"))
        {
            CountryLabel.Style.Add("top", "100px");
            CountryLabel.Style.Add("left", "100px");

            CountryList.Style.Add("top", "100px");
            CountryList.Style.Add("left ", "100px");
        }

    }

    protected void showChildRegionsFromID(String type, 
                                          String countryIDStr,
                                          String regionIDStr )
    {


        int regionId = -1;
        bool supportsPostal = false;


        if (type.Equals("country"))
        {
            regionId = int.Parse(countryIDStr.Substring(0, countryIDStr.IndexOf(';')));
            supportsPostal = bool.Parse(countryIDStr.Substring(countryIDStr.LastIndexOf(';') + 1));
        }
        else
        {
          regionId =  int.Parse(regionIDStr);
        }

          

/*         object obj = ViewState[COUNTRIES_WITH_POSTAL_CODE_KEY];

         if (obj != null)
         {
             supportsPostal = ((Hashtable)obj).ContainsKey(countryIDStr);
         }

 * */
         /*
          * 
          * pageEvents.InnerText = pageEvents.InnerText + " \n " +
                               " CountryID  " + countryIDStr + " Supports Postal " + supportsPostal;
          * 
          * */

         showChildRegions(type,
                          Microsoft.MSCOM.Geo.GeoLocationAPI.GeoLocation.GetChildListFromId(regionId),
                          supportsPostal
                          );
               

    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MSCOMGeoInfo\1.0.0.0\SDK\GeoLocation_Explicit_Set\GeoWrapper2.aspx.cs ===
using System;
using System.Data;
using System.Configuration;
using System.Collections;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Web.UI.HtmlControls;

public partial class GeoWrapper2 : System.Web.UI.Page
{
    protected void Page_Load(object sender, EventArgs e)
    {
      
        if (!Request.Browser.Cookies)
        {
           Response.Redirect("error.html");
        }

        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MSCOMGeoInfo\1.0.0.0\SDK\GeoProfile_Provider_Sample\Default.aspx.cs ===
using System;
using System.Data;
using System.Configuration;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Web.UI.HtmlControls;

public partial class _Default : System.Web.UI.Page 
{
    private static SettingsPropertyCollection myCollection = null;

    private const  String GEO_PROVIDER_NAME = "GeoProfileProvider";
    private const String MAP_POINT_ID_PROP_NAME = "MapPointID";
    private const String SELECTED_MAP_ID = "selectedMapID";


     

    

    protected void Page_Load(object sender, EventArgs e)
    {
         
       populateProfileData();
                   
             
    }

    protected void Get_Click(object sender, EventArgs e)
    {
        populateProfileData();
    }

    private void populateProfileData()
    {
        log.InnerText = "Loading Properties";

        deleteTableData();


        if (myCollection == null) {
            createPropertyValueCollection();
        }

        
        SettingsPropertyValueCollection spvc = Profile.Providers[GEO_PROVIDER_NAME].GetPropertyValues(Profile.Context, myCollection);

 
        if ( spvc.Count == 0)
        {
            TableCell cell = new TableCell();
            cell.Text = "Error , No Properties Found";
            TableRow row = new TableRow();
            row.Controls.Add(cell);
            contentTable.Controls.Add(row);
        }
        else
        {
            foreach (SettingsPropertyValue sp in spvc)
            {   
                    String propName = sp.Name;
                    String propVal = null;
                    if (sp.PropertyValue != null)
                        propVal = sp.PropertyValue.ToString();
                    else
                        propVal = "null";

                    TableRow row = new TableRow();
                    TableCell label = new TableCell();
                    label.Text = propName;
                    row.Controls.Add(label);

                    TableCell data = new TableCell();
                    TextBox tBox = new TextBox();
                    tBox.Text = propVal;
                    tBox.ReadOnly = true;
                    data.Controls.Add(tBox);
                    row.Controls.Add(data);

                    contentTable.Controls.Add(row);

            } //foreach
            contentTable.BorderStyle = BorderStyle.Dashed;
            log.InnerText = null;        
    

        }
        
    }
    private void deleteTableData()
    {
        contentTable.Controls.Clear();
    }

    private void createPropertyValueCollection()
    {
         myCollection = ProfileCommon.Properties;

        foreach (SettingsProperty prop in myCollection)
        {
            if (!prop.Provider.Name.Equals(GEO_PROVIDER_NAME))
            {
                myCollection.Remove(prop.Name);
            }
        }

         
    }

    protected void Save_Click(object sender, EventArgs e)
    {
        int mapIdInt = -1;
        try {
           mapIdInt =  int.Parse(MapIDInput.Text);
        } catch (Exception exception) {
            log.InnerText = "Please enter a valid integer MapPointID";
        }

        if (mapIdInt != -1)
        {
            Profile.MapPointID = mapIdInt;
            Profile.Save();

            
            

            Page.Response.Redirect(Page.Request.Url.ToString());
            
        }
         
        

    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MSCOMGeoInfo\1.1.0.0\SDK\GeoLocation_Explicit_Set\Default.aspx.cs ===
using System;
using System.Data;
using System.Configuration;
using System.Collections;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Web.UI.HtmlControls;

public partial class _Default : System.Web.UI.Page
{
    protected void Page_Load(object sender, EventArgs e)
    {
        String countryName = Profile.CountryRegionName;
        String regionName = Profile.StateProvinceName;
        String cityName = Profile.CityName;
         



        System.Text.StringBuilder buffer = new System.Text.StringBuilder();
        

        buffer.Append("<H3> Welcome . Events in  <i> ");
        bool setComma = false;
        if (!String.IsNullOrEmpty(cityName)) {
            buffer.Append(cityName).Append(" ");
            setComma = true;
            
        }
        
        if (!String.IsNullOrEmpty(regionName)) {
            if (setComma)
                buffer.Append(" , ");

            buffer.Append(regionName).Append(" ");

            if (!setComma)
                setComma = true;
        }
        
        if (!String.IsNullOrEmpty(countryName)) {
            if (setComma)
                buffer.Append(" , ");

            buffer.Append(countryName).Append(" ");
        }

        buffer.Append(" </i> </h3>");

        intro.InnerHtml = buffer.ToString();

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MSCOMGeoInfo\1.1.0.0\SDK\GeoLocation_API_Sample\Default.aspx.cs ===
using System;
using System.Data;
using System.Configuration;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Web.UI.HtmlControls;
using Microsoft.MSCOM.Geo.GeoLocationAPI;
using System.Collections;


public partial class _Default : System.Web.UI.Page 
{
    private System.Collections.Generic.List<CountryRegion> countries = null;
    private DropDownList countryListTable = null;

    protected void Page_Load(object sender, EventArgs e)
    {
        /*System.Text.StringBuilder buf = new System.Text.StringBuilder();
        buf.Append("<H4>");
        buf.Append("Hello User");
        buf.Append("<br/> You are located at <i> "+ Profile.CityName + ","
                                                + Profile.StateProvinceName + "," 
                                                + Profile.CountryRegionName 
                                                + "</i>"
                  );
        buf.Append("<br/>This sample web application demonstrates the usage of GeoLocation API . ");
        buf.Append("Please click the Run button next to each of the options");
        buf.Append("</h4>");
        
        intro.Visible = true;

        intro.InnerHtml = buf.ToString();
         * */
        //showHelpMessage(buf.ToString());

    }


    
     #region "Run Button Methods"
     protected void getGeoFromIP_Button_Click(object sender, EventArgs e)
    {
       
         
        controlOptions(false, getGeoFromIP_Input);

        if (!getGeoFromIP_Input.Visible)
        {
            getGeoFromIP_Input.Visible = true;
        }

    }

    protected void getGeoFromMapID_Button_Click(object sender, EventArgs e)
    {
        controlOptions(false, getGeoFromMapID_Input);

        if (!getGeoFromMapID_Input.Visible)
        {
            getGeoFromMapID_Input.Visible = true;
        }

    }

    protected void getGeoFromPostal_Button_Click(object sender, EventArgs e)
    {
        controlOptions(false, getGeoFromPostal_Input);

        if (!getGeoFromPostal_Input.Visible)
        {
            getGeoFromPostal_Input.Visible = true;
        }

    }
#endregion  

    #region "Private Utility Methods"
    private void showHelpMessage(String msg)
    {
        RealData.Text = msg;

    }

    private void controlOptions(bool flag , HtmlGenericControl control)
    {
          RealData.Text = null;
          CodeBehind.Text = null;
          RealData.Controls.Clear();

          if( control.ID != "getGeoFromPostal_Input")
              getGeoFromPostal_Input.Visible = flag;

          if (control.ID != "getGeoFromMapID_Input")
              getGeoFromMapID_Input.Visible = flag;

          if (control.ID != "getGeoFromIP_Input")
              getGeoFromIP_Input.Visible = flag;

    }

    private void displayGeoInfo(GeoInfo geoInfo)
    {
        if (geoInfo == null)
        {
            String message = "<h3>Error locating geo information from the input</h3";
            showHelpMessage(message);
            return;
        }

 

        System.Text.StringBuilder buf = new System.Text.StringBuilder();
        buf.Append("<H4>geoInfo { ");
        buf.Append("<ul> ");


        buf.Append("cityDisplayName - ").AppendLine().Append("  ").Append(geoInfo.CityDisplayName).AppendLine();
        buf.Append("</ul> ");
        buf.Append("<ul> ");

        buf.Append("StateProvinceCode - ").AppendLine().Append("  ").Append(geoInfo.StateProvinceCode).AppendLine();
        buf.Append("</ul> ");
        buf.Append("<ul> ");

        buf.Append("StateProvinceDisplayName - ").AppendLine().Append("  ").Append(geoInfo.StateProvinceDisplayName).AppendLine();
        buf.Append("</ul> ");
        buf.Append("<ul> ");

        buf.Append("ZipCodeString - ").AppendLine().Append("  ").Append(geoInfo.ZipcodeInfo).AppendLine();
        buf.Append("</ul> ");
        buf.Append("<ul> ");

        buf.Append("CountryRegionCode - ").AppendLine().Append("  ").Append(geoInfo.CountryRegionCode).AppendLine();
        buf.Append("</ul> ");
        buf.Append("<ul> ");

        buf.Append("CountryRegionDisplayName - ").AppendLine().Append("  ").Append(geoInfo.CountryRegionDisplayName).AppendLine();
        buf.Append("</ul> ");

  /*      buf.Append("<ul> ");
        buf.Append("DSTEndTimeUniversal - " + geoInfo.DSTEndTimeUniversal + "\n");
        buf.Append("DSTTimeZoneOffset - " + geoInfo.DSTTimeZoneOffset + "\n");
        buf.Append("IsEuropeanUnion - " + geoInfo.IsEuropeanUnion + "\n");
        buf.Append("Latitude - " + geoInfo.Latitude + "\n");
        buf.Append("Longitude - " + geoInfo.Longitude + "\n");
        buf.Append("MapPointId - " + geoInfo.MapPointId + "\n");
        buf.Append("MapPointIDParent - " + geoInfo.MapPointIDParent + "\n");
        buf.Append("TimeZoneDisplayName - " + geoInfo.TimeZoneDisplayName + "\n");

        
        buf.Append("</ul>");
    
   * 
   * 
   */
        buf.Append("} </H4>");

 
        //display.Visible = true;
        //display.Controls.Clear();
        //display.InnerHtml = buf.ToString();


        RealData.Text = buf.ToString();


    }

    private GeoZipCodeStringMode getGeoZipCodeStringMode(String value)
    {
        if (value != null)
        {

            if (value.Equals("GeoZipCodeStringMode.None"))
            {
                return GeoZipCodeStringMode.None;
            }
            else if (value.Equals("GeoZipCodeStringMode.ZipCodeString"))
            {
                return GeoZipCodeStringMode.ZipCodeString;
            }
            else
            {
                return GeoZipCodeStringMode.ZipCodeStringPlus;
            }
        }
        else
        {
            return GeoZipCodeStringMode.None;
        }
    }
    #endregion

 

    #region "API Invoking Methods"

       protected void getCGL_Button_Click(object sender, EventArgs e)
    {
        controlOptions(false, getCGL);
        String userLanguage = null;
        if (countries == null)
        {
            userLanguage = HttpContext.Current.Request.UserLanguages[0];

            /*
             *  The code below is the work horse behind this method.
             *  It invokes the GetCountryRegionList method and fetches a list of CountryRegion objects
             * 
             */

            countries = GeoLocation.GetCountryRegionList(userLanguage);
        }

        if (countries == null || countries.Count < 1)
        {
            String message = "<h4>There was an error loading countries</h4>";
            showHelpMessage(message);
            return;
        }

        if (countryListTable == null)
        {
            countryListTable = new DropDownList();
            countryListTable.BorderStyle = BorderStyle.Dotted;
            countryListTable.Height = Unit.Pixel(100);
            countryListTable.Width = Unit.Pixel(500);

            countryListTable.EnableViewState = false;
            countryListTable.Style["overflow"] = "scroll";


            foreach (CountryRegion country in countries)
            {
                ListItem cell = new ListItem();

                cell.Text = country.DisplayName;
                String toolTip = "DisplayName [" + country.DisplayName
                                          + "] , IsEU [" + country.IsEU
                                          + "] , DisplayLanguage [" + country.DisplayLanguage
                                          + "] , Code [" + country.Code
                                          + "] , LanguageID [" + country.LanguageId + "]";
                //cell.ToolTip = toolTip;

                //row.Controls.Add(cell);

                countryListTable.Items.Add(cell);
            }
        }

        //display.Controls.Clear();
        RealData.Controls.Clear();
        RealData.Text = null;
        RealData.Controls.Add(countryListTable);
        CodeBehind.Text = "GeoLocation.GetCountryRegionList(\"" + userLanguage + "\")";



        //        display.Controls.Add(countryListTable);
        display.Visible = true;

    }

       protected void getGeoFromIP_Invoke_Click(object sender, EventArgs e)
        {
            CodeBehind.Text = null;

            if (String.IsNullOrEmpty(getGeoFromIP_Input_IP.Text))
            {
                String message = "<h3>Please enter an valid IP Address </h3>";
                showHelpMessage(message);
                return;
            }
            String language = HttpContext.Current.Request.UserLanguages[0];

            if (!String.IsNullOrEmpty(getGeoFromIP_Input_Language.Text))
            {
                language = getGeoFromIP_Input_Language.Text;
            }

            String statsData = "Sample User";

            if (!String.IsNullOrEmpty(getGeoFromIP_Input_StatsData.Text))
            {
                statsData = getGeoFromIP_Input_StatsData.Text;
            }

            GeoZipCodeStringMode zipCodeChoice = getGeoZipCodeStringMode(getGeoFromIP_Input_ZipCodeFormatList.SelectedValue);

            CodeBehind.Text = "GeoInfo geoInfo = GeoLocation.GetGeoInfoFromIPAddress(\"" + getGeoFromIP_Input_IP.Text + "\" , \""
                                                        + language + "\" , "
                                                        + getGeoFromIP_Input_ZipCodeFormatList.SelectedValue + " , \""
                                                        + statsData + "\")";


            GeoInfo geoInfo = GeoLocation.GetGeoInfoFromIPAddress(getGeoFromIP_Input_IP.Text,
                                                                    language,
                                                                    zipCodeChoice,
                                                                    statsData);

            displayGeoInfo(geoInfo);
        }

       protected void getGeoFromPostal_Invoke_Click(object sender, EventArgs e)
        {
            CodeBehind.Text = null;
            if (String.IsNullOrEmpty(getGeoFromPostal_Input_PostalCode.Text))
            {
                String message = "<h3>Please enter an valid PostalCode</h3>";
                showHelpMessage(message);
                return;
            }

            if (String.IsNullOrEmpty(getGeoFromPostal_Input_CountryCode.Text))
            {
                String message = "<h3>Please enter an valid CountryCode</h3>";
                showHelpMessage(message);
                return;
            }

            String language = HttpContext.Current.Request.UserLanguages[0];
            String statsData = "Sample User";

            if (!String.IsNullOrEmpty(getGeoFromPostal_Input_Language.Text))
            {
                language = getGeoFromPostal_Input_Language.Text;
            }

            if (!String.IsNullOrEmpty(getGeoFromPostal_Input_StatsData.Text))
            {
                statsData = getGeoFromPostal_Input_StatsData.Text;
            }

            GeoZipCodeStringMode zipCodeChoice = getGeoZipCodeStringMode(getGeoFromPostal_Input_ZipCodeFormatList.SelectedValue);

            CodeBehind.Text = "GeoInfo geoInfo = GeoLocation.GetGeoInfoFromPostalCode(\""
                                    + getGeoFromPostal_Input_PostalCode.Text + "\" , \""
                                    + getGeoFromPostal_Input_CountryCode.Text + "\" , \""
                                    + language + "\" , "
                                    + getGeoFromPostal_Input_ZipCodeFormatList.SelectedValue + " , \""
                                    + statsData + "\" ) ";


            GeoInfo geoInfo = GeoLocation.GetGeoInfoFromPostalCode(getGeoFromPostal_Input_PostalCode.Text,
                                                                   getGeoFromPostal_Input_CountryCode.Text,
                                                                   language,
                                                                   zipCodeChoice,
                                                                   statsData);

            displayGeoInfo(geoInfo);

        }

       protected void getGeoFromMapID_Invoke_Click(object sender, EventArgs e)
        {
            CodeBehind.Text = null;
            int mapId = -1;
            try
            {
                mapId = int.Parse(getGeoFromMapID_Input_MapID.Text);
            }
            catch (Exception myEx)
            {
                String message = "<h3>Please input an integer mapID</h3";
                showHelpMessage(message);
                return;
            }

            String language = HttpContext.Current.Request.UserLanguages[0];
            String statsData = "Sample User";

            if (!String.IsNullOrEmpty(getGeoFromMapID_Input_Language.Text))
            {
                language = getGeoFromMapID_Input_Language.Text;
            }

            if (!String.IsNullOrEmpty(getGeoFromMapID_Input_StatsData.Text))
            {
                statsData = getGeoFromMapID_Input_StatsData.Text;
            }

            GeoZipCodeStringMode zipCodeChoice = getGeoZipCodeStringMode(getGeoFromMapID_Input_ZipCodeFormatList.SelectedValue);

            CodeBehind.Text = "GeoInfo geoInfo = GeoLocation.GetGeoInfoFromMapPointId( "
                                    + mapId + " , \""
                                    + language + "\" , "
                                    + getGeoFromMapID_Input_ZipCodeFormatList.SelectedValue + " , \""
                                    + statsData + "\" )";


            GeoInfo geoInfo = GeoLocation.GetGeoInfoFromMapPointId(mapId,
                                                                   language,
                                                                   zipCodeChoice,
                                                                   statsData);
            displayGeoInfo(geoInfo);

        }
    #endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MSCOMGeoInfo\1.1.0.0\SDK\GeoLocation_Explicit_Set\GeoSegSample.ascx.cs ===
using System;
using System.Data;
using System.Configuration;
using System.Collections;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Web.UI.HtmlControls;

using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using Microsoft.MSCOM.Geo.GeoLocationAPI;

public partial class GeoSegSample : System.Web.UI.UserControl
{
    private List<CountryRegion> countries;
    private List<GeoEntity> states;
    private List<GeoEntity> cities;
    

    protected const String COUNTRIES_WITH_POSTAL_CODE_KEY = "CountriesWithPostalCode";

    protected void Page_Load(object sender, EventArgs e)
    {

        if (!Page.IsPostBack) //accessed first Time
        {

             Hashtable countriesWithPostalCode = new Hashtable(50);
            /* debug */
            //pageEvents.InnerHtml = pageEvents.InnerHtml + " <h5> Page Loading </h5>";
            
//            pageEvents.Visible = true;


             
            if (Request.UrlReferrer != null )
            {
                //pageEvents.InnerText = Request.UrlReferrer.ToString();
                forwardURL.InnerText = Request.UrlReferrer.ToString();
            }
            else
            {
                //pageEvents.InnerText = "Cannot set the referral";
            }

            /*
             * 
             * if (Request.Browser.Cookies)
                pageEvents.InnerText = pageEvents.InnerText + " Cookies are supported";
            else
                pageEvents.InnerText = pageEvents.InnerText + " Cookies are not supported";
             * 
             * */


            

            //ArrayList countries = GeoLocation.getCountryList();

            countries = Microsoft.MSCOM.Geo.GeoLocationAPI.GeoLocation.GetCountryRegionList();

            

            String defaultCountryName = null;

            CountryRegion defaultCountry = null;

            if (countries != null)
            {
                status.Visible = true;
                status.InnerText = "Processing";

                /*
                 * if (countryHashTable.Count > 0)
                {
                    countryHashTable.Clear();
                }
                 * */


                for (int i = 0; i < countries.Count; i++)
                {

                    ListItem item = new ListItem();


                    item.Value = countries[i].Id.ToString() + ";" +  countries[i].Code + ";" + countries[i].LanguageId.ToString() + ";" + countries[i].SupportPostalCode.ToString();
                    item.Text = countries[i].DisplayName;

                    if (countries[i].SupportPostalCode && !countriesWithPostalCode.ContainsKey(item.Value))
                        countriesWithPostalCode.Add(item.Value, null);

                    /*
                     * String details = countries[i].LanguageId.ToString()
                                        + " , " + countries[i].Code
                                        + " , " + countries[i].SupportPostalCode.ToString();

                    pageEvents.InnerText = pageEvents.InnerText + " \n " + details;
                     * 
                     */
                    /* List Item losing attributes on postback, so don't even bother.
                    item.Attributes.Add(LANGUAGE_ID_KEY, countries[i].LanguageId.ToString());
                    item.Attributes.Add(SUPPORTS_POSTAL_CODE_KEY, countries[i].SupportPostalCode.ToString());
                    item.Attributes.Add(COUNTRY_CODE_KEY, countries[i].Code);
                     */

                    CountryList.Items.Add(item);

                    if (i == 0)
                    {
                        item.Selected = true;
                        defaultCountry = countries[i];
                    }
                }
                CountryList.ToolTip = "Please select a Country from the drop down selection";
               

                showChildRegions("country", defaultCountry.GetChildrenList() , defaultCountry.SupportPostalCode);

                status.Visible = false;
                CountryLabel.Visible = true;

               // ViewState[COUNTRIES_WITH_POSTAL_CODE_KEY] = countriesWithPostalCode;
               

            }
            else
            {
                status.Visible = true;
                status.InnerText = "No Values";

                ListItem item = new ListItem();
                item.Text = "Not Available";
                CountryList.Items.Add(item);
            }
             
             
        }
        else
        {
            /*
             * 
            if (Request.UrlReferrer != null)
            {

                pageEvents.InnerText = Request.UrlReferrer.ToString();
                forwardURL.InnerText = Request.UrlReferrer.ToString();
            }
            else
            {
                pageEvents.InnerText = "Cannot set the referral";
            }


            if (Request.Browser.Cookies)
                pageEvents.InnerText = pageEvents.InnerText + " Cookies are supported";
            else
                pageEvents.InnerText = pageEvents.InnerText + " Cookies are not supported";
             * 
             * 
             */



        }

    } //PageLoad end

    protected void showChildRegions(String type, List<GeoEntity> childList , bool countrySupportsPostalCode)
    {
        if (type.Equals("country"))
        { //1st time loading or user changed country 
            if (childList != null && childList.Count > 0)
            {
                pageEvents.InnerText = "";

                String childType = null;
                Type t = childList[0].GetType();
                

                if (t.ToString().Contains("StateProvince"))
                {
                    childType = "state";
                }
                else if (t.ToString().Contains("City")) 
                {
                    childType = "city";
                } else  
                {
                    childType = "unknown";
                }

                if (childType.Equals("state"))
                {
                    CityList.Visible = false;
                    CityLabel.Visible = false;
                   // states = childList ;
                    renderField("state", childList);
                }
                else
                {
                    RegionLabel.Visible = false;
                    RegionList.Visible = false;
                  //  cities =  childList ;
                    renderField("city", childList);
                }
                if (countrySupportsPostalCode)
                    showPostalCodeOption(true);
                 

            }
            else
            {
                //showPostalCodeOption(false);
                RegionAndCityBlock.Visible = false;
                pageEvents.InnerText = "Sorry, We don't have further information on this country.";


 /*               RegionList.Visible = false;
                RegionLabel.Visible = false;

                CityList.Visible = false;
                CityLabel.Visible = false;
   
  * 
  * 
  */
            }
        }
        else
        {
            //if (cities != null && cities.Count > 0)
              //  cities.Clear();

            //if (CityList.Items.Count > 0)
              //  CityList.Items.Clear();

            //cities = childList;
            renderField("city", childList);
        }

    }

    private void renderField(String type, List<GeoEntity> childList)
    {
        if (type.Equals("state"))
        {
            StateProvince defaultState = null;
            if (RegionList.Items.Count > 0)
                RegionList.Items.Clear();
            StateProvince state = null;
            for (int stateIndex = 0; stateIndex < childList.Count; stateIndex++)
            {
                ListItem stateItem = new ListItem();
                state = (StateProvince)childList[stateIndex];
                stateItem.Text = state.DisplayName;
                stateItem.Value = state.Id.ToString();

                //stateItem.Attributes.Add(LANGUAGE_ID_KEY, state.LanguageId.ToString());
                RegionList.Items.Add(stateItem);

                if (stateIndex == 0)
                    defaultState = state;

            }
            
            showChildRegions("state" , defaultState.GetChildrenList() , false);
            
            RegionList.Visible = true;
            RegionLabel.Visible = true;
 
        }
        else if (type.Equals("city"))
        {
            if (CityList.Items.Count > 0)
                CityList.Items.Clear();

            City city = null;
            for (int cityIndex = 0; cityIndex < childList.Count; cityIndex++)
            {
                city = (City)childList[cityIndex];

                ListItem cityItem = new ListItem();
                cityItem.Text = city.DisplayName;
                cityItem.Value = city.Id.ToString();

                // cityItem.Attributes.Add(LANGUAGE_ID_KEY, city.LanguageId.ToString());
                CityList.Items.Add(cityItem);
            }
            CityList.Visible = true;
            CityLabel.Visible = true;
            //SaveButton.Enabled = true;

             
        }
    }


    

    protected void showPostalCodeOption(bool isPostal )
    {

        if ( isPostal )
        {
            // Show the option for user to select by PostalCode 

             
            showUserOption.Visible = true;
            showUserOption.Checked = false;

            displayMessage.Visible = true;
            displayMessage.InnerText = "Select To Enter PostalCode";

            PostalCodeBlock.Visible = false;
            PostalCode.Text = "";
            showPostalState.Checked = false;
             

        }
        else
        {
            // disable all PostalCode related stuff.

             
            PostalCodeBlock.Visible = false;
            PostalCode.Text = "";


            showUserOption.Checked = false;
            showUserOption.Visible = false;

            displayMessage.Visible = false;
            displayMessage.InnerText = "";

            showPostalState.Checked = false;

            //SaveButton.Enabled = false;

        }
    }


    private void stylizeElement(String elem)
    {
        if (elem.Equals("city"))
        {
            CityLabel.Style.Add("top" , "300px");
            CityLabel.Style.Add("left" , "300px");

            CityList.Style.Add("top" , "600px");
            CityList.Style.Add("left" , "600px");

        }

        else if (elem.Equals("state"))
        {
            RegionLabel.Style.Add("top"  , "100px");
            RegionLabel.Style.Add("left" , "100px" );

            RegionList.Style.Add("top", "500px");
            RegionList.Style.Add("left", "500px");


        }

        else if (elem.Equals("country"))
        {
            CountryLabel.Style.Add("top", "100px");
            CountryLabel.Style.Add("left", "100px");

            CountryList.Style.Add("top", "100px");
            CountryList.Style.Add("left ", "100px");
        }

    }

    protected void showChildRegionsFromID(String type, 
                                          String countryIDStr,
                                          String regionIDStr )
    {


        int regionId = -1;
        bool supportsPostal = false;


        if (type.Equals("country"))
        {
            regionId = int.Parse(countryIDStr.Substring(0, countryIDStr.IndexOf(';')));
            supportsPostal = bool.Parse(countryIDStr.Substring(countryIDStr.LastIndexOf(';') + 1));
        }
        else
        {
          regionId =  int.Parse(regionIDStr);
        }

          

/*         object obj = ViewState[COUNTRIES_WITH_POSTAL_CODE_KEY];

         if (obj != null)
         {
             supportsPostal = ((Hashtable)obj).ContainsKey(countryIDStr);
         }

 * */
         /*
          * 
          * pageEvents.InnerText = pageEvents.InnerText + " \n " +
                               " CountryID  " + countryIDStr + " Supports Postal " + supportsPostal;
          * 
          * */

         showChildRegions(type,
                          Microsoft.MSCOM.Geo.GeoLocationAPI.GeoLocation.GetChildListFromId(regionId),
                          supportsPostal
                          );
               

    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MSCOMGeoInfo\1.1.0.0\SDK\GeoLocation_Explicit_Set\GeoWrapper2.aspx.cs ===
using System;
using System.Data;
using System.Configuration;
using System.Collections;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Web.UI.HtmlControls;

public partial class GeoWrapper2 : System.Web.UI.Page
{
    protected void Page_Load(object sender, EventArgs e)
    {
      
        if (!Request.Browser.Cookies)
        {
           Response.Redirect("error.html");
        }

        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MSCOMGeoInfo\1.1.0.0\SDK\GeoProfile_Provider_Sample\Default.aspx.cs ===
using System;
using System.Data;
using System.Configuration;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Web.UI.HtmlControls;

public partial class _Default : System.Web.UI.Page 
{
    private static SettingsPropertyCollection myCollection = null;

    private const  String GEO_PROVIDER_NAME = "GeoProfileProvider";
    private const String MAP_POINT_ID_PROP_NAME = "MapPointID";
    private const String SELECTED_MAP_ID = "selectedMapID";


     

    

    protected void Page_Load(object sender, EventArgs e)
    {
         
       populateProfileData();
                   
             
    }

    protected void Get_Click(object sender, EventArgs e)
    {
        populateProfileData();
    }

    private void populateProfileData()
    {
        log.InnerText = "Loading Properties";

        deleteTableData();


        if (myCollection == null) {
            createPropertyValueCollection();
        }

        
        SettingsPropertyValueCollection spvc = Profile.Providers[GEO_PROVIDER_NAME].GetPropertyValues(Profile.Context, myCollection);

 
        if ( spvc.Count == 0)
        {
            TableCell cell = new TableCell();
            cell.Text = "Error , No Properties Found";
            TableRow row = new TableRow();
            row.Controls.Add(cell);
            contentTable.Controls.Add(row);
        }
        else
        {
            foreach (SettingsPropertyValue sp in spvc)
            {   
                    String propName = sp.Name;
                    String propVal = null;
                    if (sp.PropertyValue != null)
                        propVal = sp.PropertyValue.ToString();
                    else
                        propVal = "null";

                    TableRow row = new TableRow();
                    TableCell label = new TableCell();
                    label.Text = propName;
                    row.Controls.Add(label);

                    TableCell data = new TableCell();
                    TextBox tBox = new TextBox();
                    tBox.Text = propVal;
                    tBox.ReadOnly = true;
                    data.Controls.Add(tBox);
                    row.Controls.Add(data);

                    contentTable.Controls.Add(row);

            } //foreach
            contentTable.BorderStyle = BorderStyle.Dashed;
            log.InnerText = null;        
    

        }
        
    }
    private void deleteTableData()
    {
        contentTable.Controls.Clear();
    }

    private void createPropertyValueCollection()
    {
         myCollection = ProfileCommon.Properties;

        foreach (SettingsProperty prop in myCollection)
        {
            if (!prop.Provider.Name.Equals(GEO_PROVIDER_NAME))
            {
                myCollection.Remove(prop.Name);
            }
        }

         
    }

    protected void Save_Click(object sender, EventArgs e)
    {
        int mapIdInt = -1;
        try {
           mapIdInt =  int.Parse(MapIDInput.Text);
        } catch (Exception exception) {
            log.InnerText = "Please enter a valid integer MapPointID";
        }

        if (mapIdInt != -1)
        {
            Profile.MapPointID = mapIdInt;
            Profile.Save();

            
            

            Page.Response.Redirect(Page.Request.Url.ToString());
            
        }
         
        

    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MuSigma\LinearAlgebra\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("LinearAlgebra")]
[assembly: AssemblyDescription("A light-weight library of matrix and vector types.")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft Research Ltd.")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("2004 (c) Microsoft Research Ltd.")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MuSigma\LinearAlgebra\Matrix.cs ===
/////////////////////////////////////////////////////////////////////////////////////////////
// Matrix.cs			A light-weight matrix library
//
// 2004 written by Ralf Herbrich
// Microsoft Research Ltd.
/////////////////////////////////////////////////////////////////////////////////////////////

using System;
using System.Diagnostics;

namespace LinearAlgebra
{
	/// <summary>
	/// A light-weight matrix class for  arbitrary sized matrices. Most of these functions are implemented in a 
	/// straighforward way and are not optimised for any particular target CPU architecture.
	/// </summary>
	public class Matrix 
	{
		#region Data declaration
		/// <summary>
		/// The raw values of the matrix.
		/// </summary>
		double [,]	m_dData;
		#endregion

		#region Constructors
		/// <summary>
		/// Constructs a matrix with zeros entries.
		/// </summary>
		/// <param name="iNoRows">Number of rows.</param>
		/// <param name="iNoColumns">Number of columns.</param>
		public Matrix (int iNoRows, int iNoColumns)
		{
			m_dData = new double [iNoRows, iNoColumns];
			for (int i = 0; i < iNoRows; i++)
				for (int j = 0; j < iNoColumns; j++)
					this [i, j] = 0.0;
		}

		/// <summary>
		/// Constructs a square matrix.
		/// </summary>
		/// <param name="iNoRows">Number of rows and columns.</param>
		public Matrix (int iNoRows) : this (iNoRows, iNoRows) {}

		/// <summary>
		/// Constructs a square diagonal matrix.
		/// </summary>
		/// <param name="iNoRows">Number of rows and columns.</param>
		/// <param name="dDiagonal">The diagonal entry.</param>
		public Matrix (int iNoRows, double dDiagonal)
		{
			m_dData = new double [iNoRows, iNoRows];
			for (int i = 0; i < iNoRows; i++)
				for (int j = 0; j < iNoRows; j++)
					this [i, j] = (i != j)?0.0:dDiagonal;
		}

		/// <summary>
		/// Constructs a square diagonal matrix.
		/// </summary>
		/// <param name="dDiagonal">The diagonal of the matrix.</param>
		/// <remarks>This constructor allows different entries on the diagonal of the matrix.</remarks>
		public Matrix (double [] dDiagonal)
		{
			m_dData = new double [dDiagonal.Length, dDiagonal.Length];
			for (int i = 0; i < dDiagonal.Length; i++)
				for (int j = 0; j < dDiagonal.Length; j++)
					this [i, j] = (i != j)?0.0:dDiagonal[i];
		}

		/// <summary>
		/// Constructs a deep copy of a matrix.
		/// </summary>
		/// <param name="aMatrix">Matrix to be copied.</param>
		public Matrix (Matrix aMatrix)
		{
			m_dData = new double [aMatrix.NoRows, aMatrix.NoColumns];

			// copy the matrix one-by-one
			for (int i = 0; i < aMatrix.NoRows; i++)
				for (int j = 0; j < aMatrix.NoColumns; j++)
					this [i, j] = aMatrix.m_dData [i, j];
		}

		/// <summary>
		/// Constructs a shallow copy of a matrix.
		/// </summary>
		/// <param name="dData">Matrix data to be used.</param>
		public Matrix (double [,] dData)
		{
			m_dData = dData;;
		}
		#endregion

		#region Properties and Indexers
		/// <summary>
		/// Indicator if the matrix is a row vector.
		/// </summary>
		public bool IsRowVector 
		{
			get 
			{
				return this.NoRows == 1;
			}
		}

		/// <summary>
		/// Indicator if the matrix is a column vector.
		/// </summary>
		public bool IsColumnVector 
		{
			get 
			{
				return this.NoColumns == 1;
			}
		}
		
		/// <summary>
		/// Indicator whether or not the matrix is a vector.
		/// </summary>
		public bool IsVector 
		{
			get 
			{
				return this.IsRowVector || this.IsColumnVector;
			}
		}

		/// <summary>
		/// Number of rows.
		/// </summary>
		public int NoRows
		{
			get 
			{
				return m_dData.GetLength (0);
			}
		}

		/// <summary>
		/// Number of columns.
		/// </summary>
		public int NoColumns
		{
			get 
			{
				return m_dData.GetLength (1);
			}
		}

		/// <summary>
		/// Number of total elements of the matrix.
		/// </summary>
		public int NoElements
		{
			get 
			{
				return this.NoRows * this.NoColumns;
			}
		}

		/// <summary>
		/// Element in the zero-based row <c>iRowIndex</c> and zero-based column <c>iColumnIndex</c>.
		/// </summary>
		public double this[ int iRowIndex, int iColumnIndex] 
		{
			get 
			{
				return m_dData [iRowIndex, iColumnIndex];
			}
			set 
			{
				m_dData [iRowIndex, iColumnIndex] = value;
			}
		}

		/// <summary>
		/// Element at position <c>iIndex</c> if the matrix is vector. 
		/// </summary>
		public double this[ int iIndex] 
		{
			get 
			{
				if (this.IsRowVector)
					return m_dData [0, iIndex];
				if (this.IsColumnVector)
					return m_dData [iIndex, 0];
				throw new Exception ("Matrix cannot be accessed like a vector.");
			}
			set 
			{
				if (this.NoRows == 1)
					m_dData [0, iIndex] = value;
				else if (this.NoColumns == 1)
					m_dData [iIndex, 0] = value;
				else throw new Exception ("Matrix cannot be accessed like a vector.");
			}
		}
		#endregion

		#region Object related code
		/// <summary>
		/// Compares with another matrix.
		/// </summary>
		/// <param name="aMatrix">Matrix A.</param>
		/// <returns>Returns true if A is equal to the matrix in every element.</returns>
		override public bool Equals (object aMatrix)
		{
			Matrix A = (Matrix) aMatrix;

			// check that the matrix comparison can be carried out
			if ((A.NoRows != this.NoRows) || (A.NoColumns != this.NoColumns))
				return false;

			// compare the matrices elementwise
			for (int i = 0; i < A.NoRows; i++)
				for (int j = 0; j < A.NoColumns; j++)
					if (A [i, j] != this [i, j])
						return false;

			// if we reached here, the two matrices ARE the same
			return true;
		}

		/// <summary>
		/// Computes a new hash code for the matrix.
		/// </summary>
		/// <returns>The hash code as an integer.</returns>
		/// <remarks>This function simply computes the products of the number of rows and colums and adds the 
		/// first element (0,0) of the matrix in order to compute a hash code.</remarks>
		public override int GetHashCode()
		{
			// The hash code is the total number of elements plus the first element.
			if (NoRows > 0 && NoColumns > 0)
				return NoRows * NoColumns + (int) m_dData [0, 0];
			else
				return NoRows * NoColumns;
		}

		/// <summary>
		/// Creates a string representation of the matrix.
		/// </summary>
		/// <returns>A string showing the matrix elements.</returns>
		override public string ToString ()
		{
			string aResult = "";

			// build the string row after row
			for (int i = 0; i < this.NoRows; i++) 
			{
				for (int j = 0; j < this.NoColumns; j++) 
				{
					aResult += String.Format ("{0,-6:f}\t", m_dData [i, j]);
				}
				aResult += "\n";
			}

			return aResult;
		}
		#endregion

		#region Unary Operators
		/// <summary>
		/// The implicit cast of a matrix into a double array.
		/// </summary>
		/// <param name="A">Matrix A.</param>
		/// <returns>The elements of the matrix A as a double array.</returns>
		public static implicit operator double[,] (Matrix A)
		{
			return A.m_dData;
		}

		/// <summary>
		/// An explicit cast of a matrix into a double. 
		/// </summary>
		/// <param name="A">Matrix A.</param>
		/// <returns>The only element of the matrix A as a double.</returns>
		/// <remarks>This cast throws an exception if the matrix has more than one row or more than one column.</remarks>
		public static explicit operator double(Matrix A)
		{
			if (A.NoRows != 1 || A.NoColumns != 1)
				throw new Exception ("Cast is not possible: Matrix is too big.");

			return A [0];
		}

		/// <summary>
		/// The implicit case of a double array into a matrix.
		/// </summary>
		/// <param name="dData">The double array to be casted.</param>
		/// <returns>A new matrix object whose <c>Data</c> property points to the double array.</returns>
		public static implicit operator Matrix (double [,] dData)
		{
			return new Matrix (dData);
		}

		/// <summary>
		/// The implicit cast of a double into a matrix.
		/// </summary>
		/// <param name="x">The double to be casted.</param>
		/// <returns>A 1 x 1 matrix with the only element equal to <c>x</c>.</returns>
		public static implicit operator Matrix(double x)
		{
			Matrix A = new Matrix (1, 1);
			A [0] = x;
			return A;
		}

		/// <summary>
		/// Negates the matrix.
		/// </summary>
		public void Negate ()
		{
			// return the result in a new matrix
			for (int i = 0; i < this.NoRows; i++)
				for (int j = 0; j < this.NoColumns; j++)
					this [i, j] = -this [i, j];
		}

		/// <summary>
		/// Negates a matrix.
		/// </summary>
		/// <param name="A">Matrix A.</param>
		/// <returns>Matrix A negated, that is -A.</returns>
		public static Matrix operator -(Matrix A)
		{
			// defer the work by making a deep copy
			Matrix B = new Matrix (A);
			B.Negate ();
			return B;
		}
		#endregion

		#region Binary Operators
		/// <summary>
		/// Compares two matrices.
		/// </summary>
		/// <param name="A">Matrix A.</param>
		/// <param name="B">Matrix B.</param>
		/// <returns>Returns true if A is equal to B in every element.</returns>
		public static bool operator ==(Matrix A, Matrix B)
		{
			return A.Equals (B);
		}

		/// <summary>
		/// Compares two matrices.
		/// </summary>
		/// <param name="A">Matrix A.</param>
		/// <param name="B">Matrix B.</param>
		/// <returns>Returns true if A is not equal to B in every element.</returns>
		public static bool operator !=(Matrix A, Matrix B)
		{
			return !(A.Equals (B));
		}

		/// <summary>
		/// Adds a matrix.
		/// </summary>
		/// <param name="A">Matrix to be added.</param>
		public void Add (Matrix A)
		{
			// check that the matrix addition can be carried out
			if ((A.NoRows != this.NoRows) || (A.NoColumns != this.NoColumns))
				throw new Exception ("Matrices are of differing size and cannot be added.");

			// add the other matrices 
			for (int i = 0; i < A.NoRows; i++)
				for (int j = 0; j < A.NoColumns; j++)
					this [i, j] += A [i, j];
		}

		/// <summary>
		/// Adds two matrices.
		/// </summary>
		/// <param name="A">Matrix A.</param>
		/// <param name="B">Matrix B.</param>
		/// <returns>The matrix sum of A and B, that is A + B.</returns>
		public static Matrix operator +(Matrix A, Matrix B)
		{
			// defer the work by making a deep copy
			Matrix C = new Matrix (A);
			C.Add (B);
			return C;
		}

		/// <summary>
		/// Substract a matrix.
		/// </summary>
		/// <param name="A">Matrix to be substracted.</param>
		public void Substract (Matrix A)
		{
			// check that the matrix subsctraction can be carried out
			if ((A.NoRows != this.NoRows) || (A.NoColumns != this.NoColumns))
				throw new Exception ("Matrices are of differing size cannot be substracted.");

			// substracts the matrix
			for (int i = 0; i < A.NoRows; i++)
				for (int j = 0; j < A.NoColumns; j++)
					this [i, j] -= A [i, j];
		}

		/// <summary>
		/// Substracts two matrices.
		/// </summary>
		/// <param name="A">Matrix A.</param>
		/// <param name="B">Matrix B.</param>
		/// <returns>Matrix B substracted from matrix B, that is A - B.</returns>
		public static Matrix operator -(Matrix A, Matrix B)
		{
			// defer the work by making a deep copy
			Matrix C = new Matrix (A);
			C.Substract (B);
			return C;
		}

		/// <summary>
		/// Multiplies with a matrix from the right. 
		/// </summary>
		/// <param name="A">Matrix to be multiplied from the right</param>
		/// <remarks>This will most likely change the size of the matrix.</remarks>
		public void Multiply (Matrix A)
		{
			// check that the matrix multiplication can be carried out
			if (this.NoColumns != A.NoRows)
				throw new Exception ("Matrices sizes do not match for multiplication.");

			// for multiplication we have to save the results in a new matrix since it does not work component-wise
			double [,] dData = new double [this.NoRows, A.NoColumns];
			for (int i = 0; i < this.NoRows; i++)
				for (int j = 0; j < A.NoColumns; j++)
					for (int k = 0; k < this.NoColumns; k++)
						dData [i, j] += (this [i, k] * A [k, j]);

			// copy the new data (shallow)
			m_dData = dData;
		}

		/// <summary>
		/// Multiplies two matrices.
		/// </summary>
		/// <param name="A">Matrix A.</param>
		/// <param name="B">Matrix B.</param>
		/// <returns>Matrix A times matrix B, that is A * B.</returns>
		public static Matrix operator *(Matrix A, Matrix B)
		{
			// defer the work by making a deep copy
			Matrix C = new Matrix (A);
			C.Multiply (B);
			return C;
		}

		/// <summary>
		/// Multiplies with a scalar, that is, each element of the matrix is multiplied by the scalar.
		/// </summary>
		/// <param name="x">The scaling factor.</param>
		public void Mulitply (double x)
		{
			// multiplies every element of the matrix
			for (int i = 0; i < this.NoRows; i++)
				for (int j = 0; j < this.NoColumns; j++)
					this [i, j] *= x;
			
			// done!
			return;
		}

		/// <summary>
		/// Multiplies a matrix with a scalar.
		/// </summary>
		/// <param name="A">Matrix A.</param>
		/// <param name="x">Scalar x.</param>
		/// <returns>Matrix A times scalar x, that is every element of A is multiplied by x.</returns>
		public static Matrix operator *(Matrix A, double x)
		{
			// defer the work by making a deep copy
			Matrix B = new Matrix (A);
			B.Mulitply (x);
			return B;
		}

		/// <summary>
		/// Multiplies a scalar with a matrix.
		/// </summary>
		/// <param name="x">Scalar x.</param>
		/// <param name="A">Matrix A.</param>
		/// <returns>Matrix A times scalar x, that is every element of A is multiplied by x.</returns>
		public static Matrix operator *(double x, Matrix A)
		{
			return (A * x);
		}

		/// <summary>
		/// Didives by a scalar, that is, every element is divided by the scalar.
		/// </summary>
		/// <param name="x">The scalar to be dividing by.</param>
		public void Divide (double x)
		{
			// divides every element of the matrix
			for (int i = 0; i < this.NoRows; i++)
				for (int j = 0; j < this.NoColumns; j++)
					this [i, j] /= x;
		}

		/// <summary>
		/// Divides a matrix by a scalar.
		/// </summary>
		/// <param name="A">Matrix A.</param>
		/// <param name="x">Scalar x.</param>
		/// <returns>Matrix A divided by scalar x, that is every element of A is divided by x.</returns>
		public static Matrix operator /(Matrix A, double x)
		{
			// defer the work by making a deep copy
			Matrix B = new Matrix (A);
			B.Divide (x);
			return B;
		}
		#endregion 

		#region Basic Matrix Functions
		/// <summary>
		/// Transposes the matrix.
		/// </summary>
		/// <returns>The transposed matrix.</returns>
		public Matrix Transpose ()
		{
			Matrix A = new Matrix (this.NoColumns, this.NoRows);

			// copy the matrix one-by-one
			for (int i = 0; i < this.NoRows; i++)
				for (int j = 0; j < this.NoColumns; j++)
					A [j, i] = this [i, j];

			// return the pointer to the object
			return A;
		}

		/// <summary>
		/// Computes the Cholesky decomposition. 
		/// </summary>
		/// <returns>A lower triangular matrix containing the Cholesky decomposition.</returns>
		/// <remarks>This method does not check for the symmetry. It throws an exception if the matrix is not 
		/// square or if the matrix is not positive definite.</remarks>
		public Matrix Cholesky () 
		{
			// check that the matrix is square
			if (this.NoRows != this.NoColumns)
				throw new Exception ("Matrix must be square for Cholesky decomposition.");
				
			// compute the Cholesky factor
			Matrix L = new Matrix (this.NoRows);
			double dSum = 0.0;

			for (int i = 0; i < this.NoRows; i++) 
			{
				for (int j = i; j < this.NoRows; j++)
				{
					dSum = this [i, j];
					for (int k = 0; k < i; k++)
						dSum -= L [i, k] * L [j, k];

					if (i == j)
					{
						// diagonal entry
						if (dSum < 0.0) throw new ArithmeticException ("Matrix is not positive definite.");
						L [i, i] = Math.Sqrt (dSum);
					}
					else
						L [j, i] = dSum / L [i, i];

				}
			}

			// returns the Cholesky factor
			return L;
		}

		/// <summary>
		/// Computes the inverse of a square positive definite matrix. 
		/// </summary>
		/// <returns>The inverse of the matrix.</returns>
		/// <remarks>Note that the method does not check for the symmetry. Moreover, the inverse method assumes
		/// that the matrix is positive definite.</remarks>
		public Matrix Inverse ()
		{
			// the inverse Cholesky factor
			Matrix I = InverseCholeskyFactor ();

			// returns the inverse which is simple the inverse Cholesky factor multiplied with itself
			return (I.Transpose () * I);
		}

		/// <summary>
		/// Computes the inverse of the Cholesky factor of the matrix.  
		/// </summary>
		/// <returns>The inverse of the Cholesky factor of the matrix.</returns>
		/// <remarks>Note that the method does not check for the symmetry.</remarks>
		public Matrix InverseCholeskyFactor ()
		{
			Matrix I;

			// check that the matrix is square
			if (this.NoRows != this.NoColumns)
				throw new Exception ("Matrix must be square for inversion.");
				
			// have a very fast version if the matrix is actually a scalar
			if (this.NoRows == 1) 
			{
				I = new Matrix (this.NoRows, this.NoColumns);
				I [0] = Math.Sqrt (1.0 / this [0]);
			} 
			else 
			{

				// compute the Cholesky factor
				Matrix L = this.Cholesky ();

				// compute the inverse Cholesky factor by back-substitution
				I = new Matrix (this.NoRows);
				double dSum = 0.0;
				for (int i = 0; i < I.NoRows; i++)
				{
					I [i, i] = 1.0 / L [i, i];
					for (int j = i + 1; j < I.NoRows; j++)
					{
						dSum = 0.0;
						for (int k = i; k < j; k++)
							dSum -= L [j, k] * I [k, i];
						I [j, i] = dSum / L [j, j];
					}
				}
			}

			// return the inverse Cholesky factor
			return (I);
		}

		/// <summary>
		/// Computes the determinant of a positive semidefinite matrix.  
		/// </summary>
		/// <returns>The determinant of the matrix.</returns>
		public double Determinant ()
		{
			// check that the matrix is square
			if (this.NoRows != this.NoColumns)
				throw new Exception ("Matrix must be square for determinant.");
				
			// 1. Scalar case: Fast version 
			if (this.NoRows == 1) 
			{
				return this [0, 0];
			}
 
			// 2. 2 x 2 case: Fast version 
			if (this.NoRows == 2) 
			{
				return this [0, 0] * this [1, 1] - this [0, 1] * this [1, 0];
			} 

			// 3. General case: Via the Cholesky factor
			Matrix L = this.Cholesky ();

			// the determinant is the product of the square diagonal elements of the Cholesky factor
			double dDeterminant = 1.0;
			for (int i = 0; i < L.NoRows; i++)
				dDeterminant *= L [i, i] * L [i, i];

			// done!
			return (dDeterminant);
		}
		#endregion

		#region Matrix Value Checking Code
		/// <summary>
		/// Checks if any element of the matrix is not-a-number.
		/// </summary>
		/// <returns>Returns true the matrix contains at least one element that is not-a-number.</returns>
		public bool IsNaN ()
		{
			// compare the matrices elementwise
			for (int i = 0; i < this.NoRows; i++)
				for (int j = 0; j < this.NoColumns; j++)
					if (double.IsNaN (this [i, j]))
						return true;

			// if we reached here, then the matrix contains no not-a-numbers
			return false;
		}

		/// <summary>
		/// Checks if any element of the matrix is infinity.
		/// </summary>
		/// <returns>Returns true the matrix contains at least one element that is infinity.</returns>
		public bool IsInfinity ()
		{
			// compare the matrices elementwise
			for (int i = 0; i < this.NoRows; i++)
				for (int j = 0; j < this.NoColumns; j++)
					if (double.IsInfinity (this [i, j]))
						return true;

			// if we reached here, then the matrix contains no infinities
			return false;
		}
		#endregion 

		#region Test code
		/// <summary>
		/// This function tests the matrix class on some exemplary matrices.
		/// </summary>
		/// <remarks>This code should give the following output on the console
		/// <code>
		///			A = 
		///			0.00  	0.00  	0.00  	
		///			0.00  	0.00  	0.00  	
		///
		///			B = 
		///			1.00  	3.00  	6.00  	
		///			2.00  	5.00  	1.00  	
		///
		///			2.0 * B = 
		///			2.00  	6.00  	12.00 	
		///			4.00  	10.00 	2.00  	
		///
		///			B * 2.0 = 
		///			2.00  	6.00  	12.00 	
		///			4.00  	10.00 	2.00  	
		///
		///			C = 
		///			1.00  	3.00  	6.00  	
		///			2.00  	5.00  	1.00  	
		///
		///			-C = 
		///			-1.00 	-3.00 	-6.00 	
		///			-2.00 	-5.00 	-1.00 	
		///
		///			B + C = 
		///			2.00  	6.00  	12.00 	
		///			4.00  	10.00 	2.00  	
		///
		///			B - C = 
		///			0.00  	0.00  	0.00  	
		///			0.00  	0.00  	0.00  	
		///
		///			B' * C = 
		///			5.00  	13.00 	8.00  	
		///			13.00 	34.00 	23.00 	
		///			8.00  	23.00 	37.00 	
		///
		///			I = 
		///			1.00  	0.00  	0.00  	0.00  	
		///			0.00  	1.00  	0.00  	0.00  	
		///			0.00  	0.00  	1.00  	0.00  	
		///			0.00  	0.00  	0.00  	1.00  	
		///
		///			S = 
		///			0.00  	0.00  	0.00  	0.00  	
		///			0.00  	0.00  	0.00  	0.00  	
		///			0.00  	0.00  	0.00  	0.00  	
		///			0.00  	0.00  	0.00  	0.00  	
		///
		///			B == C = True
		///
		///			A == (B - C) = True
		///
		///			I == S = False
		///
		///			D = 
		///			1.00  	1.00  	2.00  	
		///			2.00  	3.00  	3.00  	
		///			3.00  	2.00  	1.00  	
		///			
		///			F = 
		///			1.00  	1.00  	2.00  	
		///			2.00  	3.00  	3.00  	
		///			3.00  	2.00  	1.00  	
		///
		///			E = 
		///			6.00  	11.00 	7.00  	
		///			11.00 	22.00 	15.00 	
		///			7.00  	15.00 	14.00 	
		///
		///			L = 
		///			2.45  	0.00  	0.00  	
		///			4.49  	1.35  	0.00  	
		///			2.86  	1.60  	1.81  	
		///
		///			L * L' = 
		///			6.00  	11.00 	7.00  	
		///			11.00 	22.00 	15.00 	
		///			7.00  	15.00 	14.00 	
		///
		///			E^-1 = 
		///			2.31  	-1.36 	0.31  	
		///			-1.36 	0.97  	-0.36 	
		///			0.31  	-0.36 	0.31  	
		///
		///			E * E^-1 = 
		///			1.00  	0.00  	0.00  	
		///			0.00  	1.00  	0.00  	
		///			0.00  	0.00  	1.00  	
		///
		///			E * E^-1 = 
		///			1.00  	0.00  	0.00  	
		///			0.00  	1.00  	0.00  	
		///			0.00  	0.00  	1.00  	
		///			
		///			det (E) = 
		///			35.9999999999999		
		///
		///	</code>
		/// </remarks>
		public static void TestMatrixClass ()
		{
			Matrix A = new Matrix (2, 3);
			Matrix B = new Matrix (2, 3);
			B [0, 0] = 1.0;
			B [1, 0] = 2.0;
			B [0, 1] = 3.0;
			B [1, 1] = 5.0;
			B [0, 2] = 6.0;
			B [1, 2] = 1.0;
			Matrix C = new Matrix (B);
			Matrix D = new Matrix (3, 3);
			double [,] dD = D;
			dD [0, 0] = 1.0;
			dD [1, 0] = 2.0;
			dD [2, 0] = 3.0;
			dD [0, 1] = 1.0;
			dD [1, 1] = 3.0;
			dD [2, 1] = 2.0;
			dD [0, 2] = 2.0;
			dD [1, 2] = 3.0;
			dD [2, 2] = 1.0;
			Matrix E = D * D.Transpose ();
			Matrix F = (Matrix) dD;
			Matrix I = new Matrix (4, 1.0);
			Matrix S = new Matrix (4);
			Console.WriteLine ("A = \n" + A.ToString ());
			Console.WriteLine ("B = \n" + B.ToString ());
			Console.WriteLine ("2.0 * B = \n" + (2.0 * B).ToString ());
			Console.WriteLine ("B * 2.0 = \n" + (B * 2.0).ToString ());
			Console.WriteLine ("C = \n" + C.ToString ());
			Console.WriteLine ("-C = \n" + (-C).ToString ());
			Console.WriteLine ("B + C = \n" + (B + C).ToString ());
			Console.WriteLine ("B - C = \n" + (B - C).ToString ());
			Console.WriteLine ("B' * C = \n" + (B.Transpose () * C).ToString ());
			Console.WriteLine ("I = \n" + I.ToString ());
			Console.WriteLine ("S = \n" + S.ToString ());
			Console.WriteLine ("B == C = " + (B == C).ToString () + "\n");
			Console.WriteLine ("A == (B - C) = " + (A == (B - C)).ToString () + "\n");
			Console.WriteLine ("I == S = " + (I == S).ToString () + "\n");
			Console.WriteLine ("D = \n" +  D.ToString ());
			Console.WriteLine ("F = \n" +  F.ToString ());
			Console.WriteLine ("E = \n" +  E.ToString ());
			Matrix L = E.Cholesky ();
			Console.WriteLine ("L = \n" +  L.ToString ());
			Console.WriteLine ("L * L' = \n" +  (L * L.Transpose ()).ToString ());
			Matrix EInv = E.Inverse ();
			Console.WriteLine ("E^-1 = \n" +  (EInv).ToString ());
			Console.WriteLine ("E * E^-1 = \n" +  (E * EInv).ToString ());
			Console.WriteLine ("E * E^-1 = \n" +  (E * EInv).ToString ());
			Console.WriteLine ("det (E) = \n" +  E.Determinant ().ToString ());
		}
		#endregion
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MuSigma\MSRanking\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("MSRanking")]
[assembly: AssemblyDescription("Library of several ranking systems.")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft Research Ltd.")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("2004 (c) Microsoft Research Ltd.")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.3.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MuSigma\MSRanking\GameList.cs ===
/////////////////////////////////////////////////////////////////////////////////////////////
// GameList.cs		Management functions for games list. 
//
// 2004 written by Ralf Herbrich
// Microsoft Research Ltd.
/////////////////////////////////////////////////////////////////////////////////////////////

using System;
using System.Collections;

namespace MSRanking
{
	/// <summary>
	/// A class which manages a chronological series of games. Games will automatically be sorted by the date at which they ended. Note that 
	/// this class will enforce that no two games ended at EXACTLY the same time.
	/// </summary>
	public class GameList
	{
		/// <summary>
		/// A variable sized list of games sorted by the time the game ended.
		/// </summary>
		SortedList m_aGameList;			

		/// <summary>
		/// Default constructor which initialises an empty game list.
		/// </summary>
		public GameList ()
		{
			m_aGameList = new SortedList ();
		}

		/// <summary>
		/// Clears (empties) the game list.
		/// </summary>
		public void Clear ()
		{
			m_aGameList.Clear ();
		}

		/// <summary>
		/// The total number of games.
		/// </summary>
		public int NumberOfGames 
		{
			get 
			{
				return m_aGameList.Count;
			}
		}

		/// <summary>
		/// Adds a new game to the game list. 
		/// </summary>
		/// <param name="aGame">A new game.</param>
		/// <remarks>An exception is thrown if there already exists a game at the specified date.</remarks>
		public void AddGame (Game aGame)
		{
			try 
			{
				// add the game
				m_aGameList.Add (aGame.Date, aGame);
			} 
			catch
			{
				throw new Exception ("Game at this data exists already.");
			}
		}

		/// <summary>
		/// Gets the game at a specified index.
		/// </summary>
		/// <param name="iIndex">The index.</param>
		/// <returns>The Game at the specified index, or null if the index was out of range.</returns>
		/// <remarks>The game index is effectively the position of the game in the chronological sorting of all games 
		/// with respect to the date at which the game was played.</remarks>
		public Game GetGame (int iIndex)
		{
			try 
			{
				return ((Game) m_aGameList.GetByIndex (iIndex));
			} 
			catch (ArgumentOutOfRangeException) 
			{
				return (null);
			}
		}

		/// <summary>
		/// All game dates.
		/// </summary>
		public string [] GameDates 
		{
			get 
			{
				IList aTmpList = m_aGameList.GetKeyList ();
				string [] szGameDatesList = new string [m_aGameList.Count];

				for (int i = 0; i < m_aGameList.Count; i++) 
				{
					DateTime aDate = (DateTime) aTmpList [i];
					szGameDatesList [i] = aDate.ToLongDateString () + "\t" + aDate.ToLongTimeString ();
				}

				return (szGameDatesList);
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MuSigma\MSRanking\Game.cs ===
/////////////////////////////////////////////////////////////////////////////////////////////
// Game.cs		Management functions for a single game.
//
// 2004 written by Ralf Herbrich
// Microsoft Research Ltd.
/////////////////////////////////////////////////////////////////////////////////////////////

using System;
using System.Collections;

namespace MSRanking
{
	/// <summary>
	/// A class to represent a single game between some teams each of which comprised of several players. Each game also has
	/// to have the date at which it ended. This time is assumed to be the time when the game finsihed as each team will
	/// know about its scores (which is only possible AFTER the game).
	/// </summary>
	public class Game
	{
		/// <summary>
		/// The date at which the game ended.
		/// </summary>
		DateTime m_aDate;		
		/// <summary>
		/// A variable sized list of teams.
		/// </summary>
		ArrayList m_aTeams;

		/// <summary>
		/// Constructs a game that ended at a specified date between at a maximal number of teams. 
		/// </summary>
		/// <param name="aDate">Date at which the game ended.</param>
		/// <param name="iMaxNumberOfTeams">Maximum number of teams.</param>
		/// <remarks>An exception will be thrown if more than the specified number of teams are added.</remarks>
		public Game (DateTime aDate, int iMaxNumberOfTeams)
		{
			// copy parameters
			m_aDate = aDate;
			m_aTeams = new ArrayList (iMaxNumberOfTeams);
		}

		/// <summary>
		/// Constructs a game that ended at a specified date between an arbitrary number of teams.
		/// </summary>
		/// <param name="aDate">Date at which the game ended.</param>
		public Game (DateTime aDate)
		{
			// copy parameters
			m_aDate = aDate;
			m_aTeams = new ArrayList ();
		}
	
		/// <summary>
		/// The date at which the game ended.
		/// </summary>
		public DateTime Date 
		{
			get 
			{
				return m_aDate;
			}
		}

		/// <summary>
		/// The number of participating teams.
		/// </summary>
		public int NumberOfTeams 
		{
			get 
			{
				return m_aTeams.Count;
			}
		}

		/// <summary>
		/// The total number of players participating in the game.
		/// </summary>
		public int NumberOfPlayers
		{
			get 
			{
				// count the players team by team
				int iNumberOfPlayers = 0;
				for (int i = 0; i < this.NumberOfTeams; i++) 
					iNumberOfPlayers += GetTeam (i).NumberOfPlayers;

				return iNumberOfPlayers;
			}
		}

		/// <summary>
		/// Adds a team to the game.
		/// </summary>
		/// <param name="aTeam">The team to be added.</param>
		/// <returns>The team index of the team added.</returns>
		/// <remarks>The team index is a zero-based internal index used by this class.</remarks>
		public int AddTeam (Team aTeam)
		{
			return (m_aTeams.Add (aTeam));
		}

		/// <summary>
		/// Gets the team at a specified index.
		/// </summary>
		/// <param name="iTeamIndex">The index of the team.</param>
		/// <returns>The team at the given index or null, if the index is wrong.</returns>
		/// <remarks>The team index is a zero-based internal index used by this class.</remarks>
		public Team GetTeam (int iTeamIndex)
		{
			if (iTeamIndex < 0 || iTeamIndex > this.NumberOfTeams)
				return null;

			return ((Team) m_aTeams [iTeamIndex]);
		}

		/// <summary>
		/// Gets the winner between two teams.
		/// </summary>
		/// <param name="iTeamIndex1">Team index of team 1.</param>
		/// <param name="iTeamIndex2">Team index of team 2.</param>
		/// <returns>Returns +1 if team 1 won against team 2, -1 if team 2 won against team 1, and 0 it both teams
		/// draw.</returns>
		/// <remarks>The team index is a zero-based internal index used by this class.</remarks>
		public int GetWinner (int iTeamIndex1, int iTeamIndex2)
		{
			int iScoreTeam1 = GetTeam (iTeamIndex1).TeamScore;
			int iScoreTeam2 = GetTeam (iTeamIndex2).TeamScore;

			// return the result based on the rankings
			if (iScoreTeam1 > iScoreTeam2)
				return +1;
			else if (iScoreTeam2 > iScoreTeam1) 
				return -1;
			else
				return 0;
		}

		/// <summary>
		/// All player IDs of all players in the game.
		/// </summary>
		public int [] PlayerIDs
		{
			get 
			{
				ArrayList aResult = new ArrayList ();

				// add the player IDs of all teams
				for (int i = 0; i < m_aTeams.Count; i++) 
					aResult.AddRange (GetTeam (i).PlayerIDs);

				return ((int []) aResult.ToArray (typeof (int)));
			}
		}

		/// <summary>
		/// All team indicies of all players in the game.
		/// </summary>
		/// <remarks>The team index is a zero-based internal index used by this class.</remarks>
		public int [] TeamIDs
		{
			get 
			{
				ArrayList aResult = new ArrayList ();

				// add the team IDs for all players
				for (int i = 0; i < m_aTeams.Count; i++) 
					for (int j = 0; j < GetTeam (i).NumberOfPlayers; j++)
					aResult.Add (i);

				return ((int []) aResult.ToArray (typeof (int)));
			}
		}

		/// <summary>
		/// The full ranking of all teams based on the team scores.
		/// </summary>
		public Ranking Ranking
		{
			get 
			{
				// construct a true ranking of the teams
				int [] iScores = new int [m_aTeams.Count];
				
				for (int i = 0; i < m_aTeams.Count; i++) 
					iScores [i] = GetTeam (i).TeamScore;

				return new Ranking (iScores);
			}
		}

		/// <summary>
		/// Removes all empty teams.
		/// </summary>
		public void RemoveEmptyTeams ()
		{
			// cycle through all teams and remove those with zero number of players
			for (int i = 0; i < m_aTeams.Count; i++) 
				if (((Team) m_aTeams [i]).NumberOfPlayers == 0) 
				{
					m_aTeams.RemoveAt (i);
					i = i - 1;
				}

			// done!
			return;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MuSigma\MSRanking\PlayerSkills.cs ===
/////////////////////////////////////////////////////////////////////////////////////////////
// PlayerSkills.cs		Management class for individual player skills
//
// 2004 written by Ralf Herbrich
// Microsoft Research Ltd.
/////////////////////////////////////////////////////////////////////////////////////////////

using System;
using System.Collections;

namespace MSRanking
{
	/// <summary>
	/// A class which manages a chronological series of skills for a player. The date of a skill 
	/// will mean that the skill is valid until this date (including it) but nothing will be known 
	/// afterwards. Note that this class will only allow inserting new skills <c>after</c> the last 
	/// inserted skill. 
	/// </summary>
	public class PlayerSkills
	{
		/// <summary>
		/// A variable sized list of skills.
		/// </summary>
		ArrayList m_aPlayerSkillList;	
		/// <summary>
		/// A variable sized list of dates at which the skills are valid.
		/// </summary>
		ArrayList m_aDatesList;	
		/// <summary>
		/// The maximal length of the array lists. 
		/// </summary>
		int m_iMaxLength;
		/// <summary>
		/// The index of the current element.
		/// </summary>
		int m_iCurrentElementIndex;

		/// <summary>
		/// Construcuts a variable sized list of skills of given maximal length.
		/// </summary>
		public PlayerSkills () : this (int.MaxValue) {}

		/// <summary>
		/// Construcuts a variable sized list of skills of given maximal length.
		/// </summary>
		public PlayerSkills (int iMaxLength)
		{
			m_aPlayerSkillList = new ArrayList ();
			m_aDatesList = new ArrayList ();
			if (iMaxLength < 2)
				throw new Exception ("A skill list must have at least two elements.");
			m_iMaxLength = iMaxLength;
			m_iCurrentElementIndex = -1;
		}

		/// <summary>
		/// Adds a new skill valid at a specified date.
		/// </summary>
		/// <param name="aSkill">The new skill.</param>
		/// <param name="aDate">Time at which the skill is valid.</param>
		/// <remarks>The date of a skill will mean that the skill is valid until this date (including 
		/// it) but nothing will be known afterwards. This method will throw an exception if the time 
		/// is before ar at the latest skill time.</remarks>
		public void AddSkill (Skill aSkill, DateTime aDate)
		{
			if (this.LatestDate >= aDate)
				throw new Exception ("New skills must be after the last inserted skill.");

			if (m_aPlayerSkillList.Count < m_iMaxLength) 
			{
				m_aPlayerSkillList.Add (aSkill);
				m_aDatesList.Add (aDate);
				m_iCurrentElementIndex = m_aPlayerSkillList.Count - 1;
			}
			else 
			{
				m_iCurrentElementIndex = (++m_iCurrentElementIndex) % m_iMaxLength;
				m_aPlayerSkillList [m_iCurrentElementIndex] = aSkill;
				m_aDatesList [m_iCurrentElementIndex] = aDate;
			}

			// done!
			return;
		}

		/// <summary>
		/// Clears (empties) the list of player skill.
		/// </summary>
		public void Clear ()
		{
			m_aPlayerSkillList.Clear ();
			m_aDatesList.Clear ();
			m_iCurrentElementIndex = -1;
		}

		/// <summary>
		/// The latest skill (or null if the list of skills is empty).
		/// </summary>
		public Skill LatestSkill
		{
			get 
			{
				if (m_aPlayerSkillList.Count == 0)
					return null;
				return (Skill) m_aPlayerSkillList [m_iCurrentElementIndex];
			}
		}

		/// <summary>
		/// The latest date (or 0 ticks if the list of skills is empty).
		/// </summary>
		public DateTime LatestDate
		{
			get 
			{
				if (m_aDatesList.Count == 0)
					return new DateTime (0L);
				return (DateTime) m_aDatesList [m_iCurrentElementIndex];
			}
		}

		/// <summary>
		/// Gets the latest skill until (and including) a specific date.
		/// </summary>
		/// <param name="aDate">The target date.</param>
		/// <returns>The skill that is nearest in the past to the target data or null if there is no skill.</returns>
		public Skill GetLatestSkill (DateTime aDate)
		{
			// scan backwards in time (exploit the ordering of the lists).
			int iCount = m_aDatesList.Count;
			for (int i = 0; i < iCount; i++)
				if (((DateTime) m_aDatesList [(m_iCurrentElementIndex - i) % iCount]) <= aDate)
					return ((Skill) m_aPlayerSkillList [(m_iCurrentElementIndex - i) % iCount]);

			// if the date was even before the first date that we knew anything about, then return null.
			return null;
		}

		/// <summary>
		/// Total number of skills.
		/// </summary>
		public int NumberOfSkills
		{
			get 
			{
				return m_aPlayerSkillList.Count;
			}
		}

		/// <summary>
		/// The list of skills sorted by chronologically.
		/// </summary>
		public Skill [] Skills
		{
			get 
			{
				int iCount = m_aPlayerSkillList.Count;
				ArrayList aSkills = new ArrayList (iCount);
				for (int i = 0; i < m_aPlayerSkillList.Count; i++)
					aSkills.Add (m_aPlayerSkillList [(m_iCurrentElementIndex + i + 1) % iCount]);
				return ((Skill []) aSkills.ToArray (typeof (Skill)));
			}
		}

		/// <summary>
		/// The sorted list of dates.
		/// </summary>
		public DateTime [] Dates
		{
			get 
			{
				int iCount = m_aDatesList.Count;
				ArrayList aDates = new ArrayList (iCount);
				for (int i = 0; i < m_aDatesList.Count; i++)
					aDates.Add (m_aDatesList [(m_iCurrentElementIndex + i + 1) % iCount]);
				return ((DateTime []) aDates.ToArray (typeof (DateTime)));
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MuSigma\MSRanking\PlayerList.cs ===
/////////////////////////////////////////////////////////////////////////////////////////////
// PlayerList.cs		Management functions for player list. 
//
// 2004 written by Ralf Herbrich
// Microsoft Research Ltd.
/////////////////////////////////////////////////////////////////////////////////////////////

using System;
using System.Collections;

namespace MSRanking
{
	/// <summary>
	/// A class to manage a list of players. Each player will be uniquely represented by a name. The class will also manage a zero-based 
	/// unique player identification (ID) for each player.  
	/// </summary>
	public class PlayerList
	{		
		/// <summary>
		/// Mapping from player names to unique player IDs.
		/// </summary>
		Hashtable m_aPlayerID;
		/// <summary>
		/// Mapping from unique player IDs to player names.
		/// </summary>
		ArrayList m_aPlayerNames;

		/// <summary>
		/// Default constructor which initialises an empty player list.
		/// </summary>
		public PlayerList ()
		{
			m_aPlayerID = new Hashtable ();
			m_aPlayerNames = new ArrayList ();
		}

		/// <summary>
		/// Clears (empties) the player list.
		/// </summary>
		public void Clear ()
		{
			m_aPlayerID.Clear ();
			m_aPlayerNames.Clear ();
		}

		/// <summary>
		/// Adds a player to the player list. 
		/// </summary>
		/// <param name="szPlayerName">The name of the player.</param>
		/// <returns>The unique ID of the added player or -1 if the player exists already.</returns>
		/// <remarks>The player ID is a zero-based index which grows for every player added.</remarks>
		public int AddPlayer (string szPlayerName)
		{
			if (m_aPlayerID.ContainsKey (szPlayerName))
				return -1;

			// adds the player
			int iIndex = m_aPlayerNames.Add (szPlayerName);
			m_aPlayerID [szPlayerName] = iIndex; 

			// done!
			return (iIndex);
		}

		/// <summary>
		/// Gets the player ID for a given player name.
		/// </summary>
		/// <param name="szPlayerName">The name of the player.</param>
		/// <returns>The ID of the player or -1, if the player does not exists.</returns>
		public int GetPlayerID (string szPlayerName)
		{
			if (m_aPlayerID.ContainsKey (szPlayerName))
				return ((int) m_aPlayerID [szPlayerName]);
			else
				return (-1);
		}

		/// <summary>
		/// Total number of players in the player list.
		/// </summary>
		public int NumberOfPlayers
		{
			get 
			{
				return m_aPlayerNames.Count;
			}
		}

		/// <summary>
		/// Gets the name for a given player ID.
		/// </summary>
		/// <param name="iPlayerID">The player ID.</param>
		/// <returns>The name of the player or null if the player ID is out of range.</returns>
		public string GetPlayerName (int iPlayerID)
		{
			if (iPlayerID >= m_aPlayerNames.Count)
				return (null);


			return ((string) m_aPlayerNames [iPlayerID]);
		}

		/// <summary>
		/// A string array of all player names.
		/// </summary>
		public string [] PlayerNames 
		{
			get 
			{
				string [] szPlayerNameList = new string [m_aPlayerNames.Count];

				for (int i = 0; i < m_aPlayerNames.Count; i++)
					szPlayerNameList [i] = (string) m_aPlayerNames [i];

				return (szPlayerNameList);
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MuSigma\MSRanking\Ranking.cs ===
/////////////////////////////////////////////////////////////////////////////////////////////
// Ranking.cs		A class that represents a ranking between n elements.
//
// 2004 written by Ralf Herbrich
// Microsoft Research Ltd.
/////////////////////////////////////////////////////////////////////////////////////////////

using System;

namespace MSRanking
{
	/// <summary>
	/// A class that represents a ranking between n elements. In this class, rank 1 is assumed to be the highest rank. Moreover, it is possible
	/// that two elements are on the same rank. In this case, no rank gap is introduced; a valid ranking is thus 1,1,2,3 instead of 1,1,3,4.
	/// </summary>
	public class Ranking
	{
		/// <summary>
		/// The ranks of each element. Note that the ranks will always be between 1 and m_iRanks.Length.
		/// </summary>
		int	[] m_iRanks;

		/// <summary>
		/// Constructs an identity ranking between a specified number of elements. The first element will be of highest rank and
		/// the last element will be of lowest rank.
		/// </summary>
		/// <param name="iNumberOfElements">Number of elements.</param>
		public Ranking (int iNumberOfElements)
		{
			m_iRanks = new int [iNumberOfElements];

			for (int i = 0; i < m_iRanks.Length; i++)
				m_iRanks [i] = i + 1;
		}

		/// <summary>
		/// Constructs a ranking based on the values given in an vector of nunbers.
		/// </summary>
		/// <param name="iElements">A list of integers.</param>
		/// <remarks>This method will have to call sorting routines so it may become slow when passed a long list of integers!</remarks>
		public Ranking (int [] iElements) 
		{
			// if there are no elements to sort then 
			if (iElements.Length == 0)
				m_iRanks = new int [0];
			else 
			{
				m_iRanks = new int [iElements.Length];
				int [] iIndex = new int [iElements.Length];

				// construct an identity ranking
				for (int i = 0; i < iElements.Length; i++) 
					iIndex [i] = i;

				// sort the ranking
				Array.Sort ((int []) iElements.Clone (), iIndex);

				// compute the ranks
				m_iRanks [iIndex [iElements.Length - 1]] = 1;
				for (int i = 1; i < m_iRanks.Length; i++) 
				{
					if (iElements [iIndex [iElements.Length - 1 - i]] < iElements [iIndex [iElements.Length - i]])
						m_iRanks [iIndex [iElements.Length - 1 - i]] = m_iRanks [iIndex [iElements.Length - i]] + 1;
					else	
						m_iRanks [iIndex [iElements.Length - 1 - i]] = m_iRanks [iIndex [iElements.Length - i]];
				}
			}
		}

		/// <summary>
		/// Zero-based indicies which reflect the rankings.
		/// </summary>
		public int [] Indicies
		{
			get 
			{
				int [] iIndex = new int [m_iRanks.Length];

				for (int i = 0; i < m_iRanks.Length; i++) 
					iIndex [i] = i;

				Array.Sort ((int []) m_iRanks.Clone (), iIndex);

				return iIndex;
			}
		}

		/// <summary>
		/// Number of elements in the ranking.
		/// </summary>
		public int NumberOfElements 
		{
			get 
			{
				return m_iRanks.Length;
			}
		}

		/// <summary>
		/// Computes the factorial of n.
		/// </summary>
		/// <param name="n">The parameter <c>n</c>.</param>
		/// <returns>The factorial of <c>n</c>.</returns>
		private long Factorial (int n)
		{
			long [] lFactorial = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800, 479001600, 6227020800, 87178291200};
			if (n >= lFactorial.Length)
				throw new Exception ("Factorial cannot be represented by a long number.");

			return lFactorial [n];
		}

		/// <summary>
		/// Number of equivalent rankings.
		/// </summary>
		public long NumberOfEquivalenceClasses
		{
			get 
			{
				// get the rankings re-ordered
				int [] iRanks = (int []) m_iRanks.Clone ();
				Array.Sort (iRanks);

				// compute the number of equivalence classes
				long iNumberOfEquivalenceClasses = 1;
				int k = 0;
				for (int i = 0; i < iRanks.Length; i++) 
				{
					if (iRanks [i] != iRanks [k]) 
					{
						iNumberOfEquivalenceClasses *= Factorial (i - k);
						k = i;
					}
				}
				iNumberOfEquivalenceClasses *= Factorial (iRanks.Length - k);

				return iNumberOfEquivalenceClasses;
			}
		}

		/// <summary>
		/// Compares the rank of two elements.
		/// </summary>
		/// <param name="i">Index of the first element.</param>
		/// <param name="j">Index of the second element.</param>
		/// <returns>Returns +1 is the first element is of higher rank than the second element, -1 if the 
		/// second element is of higher rank than the first element, or 0 if both elements are of same rank.</returns>
		public int GetWinner (int i, int j)
		{
			if (m_iRanks [i] < m_iRanks [j]) return +1;
			if (m_iRanks [i] > m_iRanks [j]) return -1;

			return 0;
		}

		/// <summary>
		/// Computes the difference to another ranking.
		/// </summary>
		/// <param name="aRanking">Ranking to be compared with.</param>
		/// <returns>A value between 0 and 1 indicating the difference between the two rankings.</returns>
		/// <remarks>The ranking difference will be computed as the fraction of pairs of elements where the two rankings disagree. This
		/// can be seen as the fractional difference between the number of swapping operations that bubble sort would take to sort each
		/// of the two rankings.</remarks>
		public double Difference (Ranking aRanking) 
		{
			if (aRanking.NumberOfElements != this.NumberOfElements)
				throw new Exception ("Rankings are of different length.");

			// if there are not enough elements then the ranking is perfect
			if (aRanking.NumberOfElements < 2)
				return 0.0;

			// count the number of pairs which are differently ranked
			int iNumberOfDifferentPairs = 0;
			for (int i = 0; i < aRanking.NumberOfElements; i++)
				for (int j = i + 1; j < this.NumberOfElements; j++) 
					if (this.GetWinner (i, j) != aRanking.GetWinner (i, j))
						iNumberOfDifferentPairs++;

			// re-normalise
			return 2.0 * (double) iNumberOfDifferentPairs / (double) (this.NumberOfElements * (this.NumberOfElements - 1));
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MuSigma\MSRanking\PlayerSkillsList.cs ===
/////////////////////////////////////////////////////////////////////////////////////////////
// PlayerSkillsList.cs		Management functions for list of player skills
//
// 2004 written by Ralf Herbrich
// Microsoft Research Ltd.
/////////////////////////////////////////////////////////////////////////////////////////////

using System;
using System.Collections;

namespace MSRanking
{
	/// <summary>
	/// A class that manages list of skills indexed by players. Each player will be identified by a unqiue player ID. This
	/// list is managing a chronologically sorted list of skills for each player. The PlayerSkills class and this class should not be confused: 
	/// Whereas the PlayerSkills class manages all skills of a single player in time, this class manages a list of PlayerSkills for all players.
	/// </summary>
	public class PlayerSkillsList
	{
		/// <summary>
		/// A variable sized mapping between player IDs and player skills.
		/// </summary>
		Hashtable m_aSkillsList;

		/// <summary>
		/// Constructs a variable sized list of skill lists.
		/// </summary>
		public PlayerSkillsList()
		{
			m_aSkillsList = new Hashtable ();
		}

		/// <summary>
		/// Clears (empties) the list of skill lists.
		/// </summary>
		public void Clear ()
		{
			m_aSkillsList.Clear ();
		}

		/// <summary>
		/// Clears (empties) the chronologically sorted list of skills for each player but retains
		/// its own internal list of skill lists.
		/// </summary>
		public void ClearPlayerSkills ()
		{
			IDictionaryEnumerator aEnumerator = m_aSkillsList.GetEnumerator ();
			while (aEnumerator.MoveNext ()) 
				((PlayerSkills) aEnumerator.Value).Clear ();
		}

		/// <summary>
		/// Adds a the chronologically sorted list of skills for a new player with a specified unique player index.
		/// </summary>
		/// <param name="aPlayerSkills">A chronologically sorted list of skills for the player.</param>
		/// <param name="iPlayerID">The unique player ID.</param>
		public void AddPlayerSkills (PlayerSkills aPlayerSkills, int iPlayerID)
		{
			m_aSkillsList.Add (iPlayerID, aPlayerSkills);
		}

		/// <summary>
		/// Gets the list of skills for a given player ID.
		/// </summary>
		/// <param name="iPlayerID">The unique player ID.</param>
		/// <returns>The chronologically sorted list of skills for the player with the specified ID or null if 
		/// the player does not exists.</returns>
		public PlayerSkills GetPlayerSkills (int iPlayerID)
		{
			if (!m_aSkillsList.ContainsKey (iPlayerID))
				return null;

			return (PlayerSkills) m_aSkillsList [iPlayerID];
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MuSigma\MSRanking\RankingSystem.cs ===
/////////////////////////////////////////////////////////////////////////////////////////////
// RankingSystem.cs			All abstract ranking system classes. 
//
// 2004 written by Ralf Herbrich
// Microsoft Research Ltd.
/////////////////////////////////////////////////////////////////////////////////////////////

using System;

namespace MSRanking
{
	#region Ranking System
	/// <summary>
	/// The abstract base class that manages a list of player skill lists. A ranking system will allow to incorporate a game outcomes 
	/// an update the inidividual player skills accordingly. Moreover, a ranking system will offer a predicition of the outcome of the 
	/// game to support matchmaking mechanisms. 
	/// </summary>
	public abstract class RankingSystem
	{
		/// <summary>
		/// The list of player skill list.
		/// </summary>
		protected PlayerSkillsList m_aPlayerSkillsList;

		/// <summary>
		/// Constructs a ranking system for a given list of player skill lists.
		/// </summary>
		/// <param name="aPlayerSkillsList">A list of player skill lists. If the list is <c>null</c>, a new list of player
		/// skill lists will be created.</param>
		public RankingSystem (PlayerSkillsList aPlayerSkillsList)
		{
			if (aPlayerSkillsList == null)
				m_aPlayerSkillsList = new PlayerSkillsList ();
			else
				m_aPlayerSkillsList = aPlayerSkillsList;
		}

		/// <summary>
		/// Constructs a ranking system with a new list of player skill lists.
		/// </summary>
		public RankingSystem () : this (null) {}

		/// <summary>
		/// Clears all the chronologically sorted skills of all the players maintained by this ranking system.
		/// </summary>
		public void ClearPlayerSkills () 
		{
			m_aPlayerSkillsList.ClearPlayerSkills ();
		}

		/// <summary>
		/// Updates the player skills with a particular game.
		/// </summary>
		/// <param name="aGame">The game to be incorporated.</param>
		/// <returns>True, if the update was performed.</returns>
		abstract public bool Update (Game aGame);

		/// <summary>
		/// Computes the most likely outcome of a game.
		/// </summary>
		/// <param name="aGame">The game for which the outcome should be predicted.</param>
		/// <returns>The most likely ranking.</returns>
		/// <remarks>Note that this function ignores the actual game outcome which is contained in the game passed to the method.
		/// The method is supposed to throw an exception if the outcome cannot be predicted.</remarks>
		abstract public Ranking PredictedOutcome (Game aGame);

		/// <summary>
		/// The list of player skill lists maintained by the ranking system.
		/// </summary>
		public PlayerSkillsList PlayerSkillsList
		{
			get 
			{
				return m_aPlayerSkillsList;
			}
		}
	}
	#endregion

	#region Probabilistic Ranking System
	/// <summary>
	/// The abstract base class that manages a list of player skill lists. A probabilistic ranking system is a ranking system which is
	/// based on a probabilistic model of the game outcome. Hence, in such a ranking system it is possible to compute the probability of a
	/// particualr game outcome.
	/// </summary>
	public abstract class ProbabilisticRankingSystem : RankingSystem
	{

		/// <summary>
		/// Constructs a probabilistic ranking system for a given list of player skill lists.
		/// </summary>
		/// <param name="aPlayerSkillsList">A list of player skill lists. If this list is <c>null</c>, a new list of player
		/// skill lists will be created.</param>
		public ProbabilisticRankingSystem (PlayerSkillsList aPlayerSkillsList) : base (aPlayerSkillsList) {}

		/// <summary>
		/// Constructs a probabilistic ranking system with a new list of player skill lists.
		/// </summary>
		public ProbabilisticRankingSystem () : base () {}

		/// <summary>
		/// Computes the probability for some rankings for a given game.
		/// </summary>
		/// <param name="aGame">The game for which the ranking probabilities should be computed.</param>
		/// <param name="aRankings">A list of rankings for which the probability should be computed.</param>
		/// <returns>The probabilities of the specified rankings for the given game. This method throws an exception if 
		/// the probabilities cannot be computed.</returns>
		abstract public double [] RankingProbability (Game aGame, Ranking [] aRankings);

		/// <summary>
		/// Updates the player skills with a particular game.
		/// </summary>
		/// <param name="aGame">The game to be incorporated.</param>
		/// <returns>True, if the update was performed.</returns>
		/// <remarks>This method uses the evidence based <c>Update</c> method and should not be overriden!</remarks>
		public override bool Update(Game aGame)
		{
			double dTmp;
			return this.Update (aGame, out dTmp);
		}

		/// <summary>
		/// Updates the player skills with a particular game and computes the evidence of the game.
		/// </summary>
		/// <param name="aGame">The game to be incorporated.</param>
		/// <param name="dEvidence">The evidence of the game (as an output parameter).</param>
		/// <returns>True, if the update was performed.</returns>
		abstract public bool Update (Game aGame, out double dEvidence);

		/// <summary>
		/// Computes the most likely game outcome based on the probability for each ranking.
		/// </summary>
		/// <param name="aGame">The game for which the outcome should be predicted.</param>
		/// <returns>The most likely outcome.</returns>
		/// <remarks>The method throws an exception if the outcome cannot be predicted. At the moment, it works only for
		/// two-team games.</remarks>
		public override Ranking PredictedOutcome (Game aGame)
		{
			// check that we can compute the probability of the outcome
			if (aGame.NumberOfTeams != 2)
				throw new Exception ("Game outcomes can only be predicted for two-player games.");

			// enumerate all three rankings
			Ranking [] aRankings = new Ranking [3] {	
													   new Ranking (new int [2] {1, 0}),	// Team 1 wins
													   new Ranking (new int [2] {0, 1}),	// Team 2 wins
													   new Ranking (new int [2] {0, 0})		// Teams draw
												   }; 

			// compute the probabilities for all three outcomes
			double [] dProbabilities = RankingProbability (aGame, aRankings);

			// pick the maximum probability outcome
			if (dProbabilities [0] > dProbabilities [1] && dProbabilities [0] > dProbabilities [2])
				return aRankings [0];
			if (dProbabilities [1] > dProbabilities [0] && dProbabilities [1] > dProbabilities [2])
				return aRankings [1];

			return aRankings [2];
		}
	}
	#endregion 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MuSigma\MSRanking\Skill.cs ===
/////////////////////////////////////////////////////////////////////////////////////////////
// Skill.cs		Abstract base class of a player skill
//
// 2004 written by Ralf Herbrich
// Microsoft Research Ltd.
/////////////////////////////////////////////////////////////////////////////////////////////

using System;

namespace MSRanking
{
	/// <summary>
	/// Abstract base class of all skills. Since we are interested in rankings, each skill must be convertible into a (skill) level 
	/// and a more fine-grained skill point measure. For example, the number of kills, the total ammount of experience points, etc. are valid 
	/// skill measures. Since we have both levels and skill points, a fractional level will tell us the fractional amount of difference 
	/// between the level and the skill points.
	/// </summary>
	abstract public class Skill
	{
		/// <summary>
		/// Default constructor.
		/// </summary>
		public Skill() {}

		/// <summary>
		/// The skill points of the player. 
		/// </summary>
		/// <remarks>Skill points are the exact, fine-grained summary of skill.</remarks>
		abstract public double Points
		{
			get;
		}

		/// <summary>
		/// A skill level of the player.
		/// </summary>
		/// <remarks>Levels are the broad version of the skill points.</remarks>
		abstract public int Level
		{
			get;
		}

		/// <summary>
		/// The fractional difference between the level and the points. This value should always be between 0 and 1.
		/// </summary>
		abstract public double FractionalLevel
		{
			get;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MuSigma\MSRanking\Team.cs ===
/////////////////////////////////////////////////////////////////////////////////////////////
// Team.cs		Management functions for a single team.
//
// 2004 written by Ralf Herbrich
// Microsoft Research Ltd.
/////////////////////////////////////////////////////////////////////////////////////////////

using System;
using System.Collections;

namespace MSRanking
{
	/// <summary>
	/// A class to represent a team of players together with their scores. Each player will be represented by a unique integer ID.
	/// The score will be an integer value.
	/// </summary>
	public class Team
	{
		/// <summary>
		/// The variable size list of player ID's that form the team.
		/// </summary>
		ArrayList m_aPlayerID;	
		/// <summary>
		/// The variable size list of player scores for each player on the team. 
		/// </summary>
		ArrayList	m_aScore;

		/// <summary>
		/// Construcuts a new team with a given maximal number of players.
		/// </summary>
		/// <param name="iMaxNumberOfPlayers">Maximal number of players.</param>
		/// <remarks>If more than the specified number of players are added an exception will be thrown.</remarks>
		public Team (int iMaxNumberOfPlayers)
		{
			m_aPlayerID = new ArrayList (iMaxNumberOfPlayers);
			m_aScore = new ArrayList (iMaxNumberOfPlayers);
		}

		/// <summary>
		/// Construcuts a new team with a variable number of players.
		/// </summary>
		public Team ()
		{
			m_aPlayerID = new ArrayList ();
			m_aScore = new ArrayList ();
		}

		/// <summary>
		/// Adds a new player to the team.
		/// </summary>
		/// <param name="iPlayerID">Player ID of the new player.</param>
		/// <param name="iScore">Score of the new player.</param>
		/// <returns>The player index of the added player.</returns>
		/// <remarks>The player index must not be confused with the player ID. The player index is a zero-based
		/// internal index used by this class.</remarks>
		public int AddPlayer (int iPlayerID, int iScore)
		{
			m_aPlayerID.Add (iPlayerID);
			return (m_aScore.Add (iScore));
		}

		/// <summary>
		/// Total number of players in the team.
		/// </summary>
		public int NumberOfPlayers
		{
			get 
			{
				return m_aPlayerID.Count;
			}
		}

		/// <summary>
		/// Score of the team.
		/// </summary>
		/// <remarks>The score of a team is always the the sum of the scores of all players in the team.</remarks>
		public int TeamScore 
		{
			get 
			{
				// do the summation by hand
				int iTotalScore = 0;
				for (int i = 0; i < m_aScore.Count; i++) iTotalScore += (int) m_aScore [i];

				return iTotalScore;
			}
		}

		/// <summary>
		/// Get the player ID for a player at specified index.
		/// </summary>
		/// <param name="iPlayer">The player index.</param>
		/// <returns>The global player ID or -1 if the index is out of range.</returns>
		/// <remarks>The player index must not be confused with the player ID. The player index is a zero-based
		/// internal index used by this class and increases everytime a player is added.</remarks>
		public int GetPlayerID (int iPlayer)
		{
			if (iPlayer < 0 || iPlayer > this.NumberOfPlayers)
				return -1;

			return (int) m_aPlayerID [iPlayer];
		}

		/// <summary>
		/// All player IDs for the entire team.
		/// </summary>
		public int [] PlayerIDs
		{
			get 
			{
				// copy them into an array
				int [] iPlayerIDs = new int [m_aPlayerID.Count];
				for (int i = 0; i < m_aPlayerID.Count; i++) iPlayerIDs [i] = (int) m_aPlayerID [i];

				return iPlayerIDs;
			}
		}

		/// <summary>
		/// Gets the score for the player at a specified index.
		/// </summary>
		/// <param name="iPlayer">The player index.</param>
		/// <returns>The score of the player.</returns>
		/// <remarks>The player index must not be confused with the player ID. The player index is a zero-based
		/// internal index used by this class and increases everytime a player is added.</remarks>
		public int GetPlayerScore (int iPlayer)
		{
			if (iPlayer < 0 || iPlayer > this.NumberOfPlayers)
				throw new Exception ("iPlayer out of range.");

			return (int) m_aScore [iPlayer];
		}

		/// <summary>
		/// Scores for every player on the team.
		/// </summary>
		public int [] PlayerScores 
		{
			get 
			{
				// copy them into an array
				int [] iScores = new int [m_aScore.Count];
				for (int i = 0; i < m_aScore.Count; i++) iScores [i] = (int) m_aScore [i];

				return iScores;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MuSigma\MSRanking\RankingSystems\Halo2RankingSystem.cs ===
/////////////////////////////////////////////////////////////////////////////////////////////
// Halo2RankingSystem.cs			Halo 2 Beta Ranking system 
//
// 2004 written by Ralf Herbrich
// Microsoft Research Ltd.
/////////////////////////////////////////////////////////////////////////////////////////////

using System;
using System.Collections;
using MSRanking.Skills;

namespace MSRanking.RankingSystems
{
	/// <summary>
	/// A class that represents the Halo 2 ranking system. This class manages a list of player skill lists. 
	/// Game outcomes will be incorporated by the Halo 2 update equation. 
	/// </summary>
	public class Halo2RankingSystem : RankingSystem
	{
		/// <summary>
		/// The table of experience points deltas. The columns are as follows
		/// <code>
		///		Higher ranked oppoents wins
		///		Higher ranked oppoents loses
		///		Lower ranked opponent wins
		///		Lower ranked opponent loses
		///	</code>
		/// </summary>
		int [,] m_iHalo2DeltaTable = {{100, -100, 100, -100}, 
									  { 95, -105, 115, -85},
									  { 90, -110, 130, -70},
									  { 85, -115, 145, -55},
									  { 80, -120, 155, -45},
									  { 75, -125, 165, -35},
									  { 70, -130, 175, -25}};
		/// <summary>
		/// The table of loss factors for the first ten levels. All the other levels will have
		/// a loss factor of 1.
		/// </summary>
		double [] m_dLossFactor =   {	0.00, 0.05, 0.10, 0.20,
										0.35, 0.50, 0.65, 0.80,
										0.90, 0.95, 1.00};
 


		/// <summary>
		/// Constructs a new instance of the HALO 2 ranking system.
		/// </summary>
		public Halo2RankingSystem () : base () {}

		/// <summary>
		/// Constructs a new instance of the HALO 2 ranking system.
		/// </summary>
		/// <param name="aPlayerSkillsList">A list of player skill lists.</param>
		public Halo2RankingSystem (PlayerSkillsList aPlayerSkillsList) : base (aPlayerSkillsList) {}

		/// <summary>
		/// Updates the player skills given a particular game.
		/// </summary>
		/// <param name="aGame">The game to be incorporated.</param>
		/// <returns>True, if the update was performed.</returns>
		override public bool Update (Game aGame)
		{
			// get all player and team IDs
			int [] iPlayerIDs = aGame.PlayerIDs;
			int [] iTeamIDs = aGame.TeamIDs;

			// make sure that there is at least one player skill
			for (int i = 0; i < iPlayerIDs.Length; i++) 
				if (m_aPlayerSkillsList.GetPlayerSkills (iPlayerIDs [i]).LatestSkill == null) 
					m_aPlayerSkillsList.GetPlayerSkills (iPlayerIDs [i]).AddSkill (new Halo2Skill (0, 0), aGame.Date);

			// do not do an update if there are one or less teams
			if (aGame.NumberOfTeams <= 1)
				return false;

			////////////////////////////////////////////////
			// compute the average level for each team
			double [] dTeamLevel = new double [aGame.NumberOfTeams];
			for (int i = 0; i < aGame.NumberOfTeams; i++) 
			{
				Team aTeam = aGame.GetTeam (i);
				dTeamLevel [i] = 0.0;

				for (int j = 0; j < aTeam.NumberOfPlayers; j++) 
					dTeamLevel [i] += (double) ((Halo2Skill) m_aPlayerSkillsList.GetPlayerSkills (aTeam.GetPlayerID (j)).LatestSkill).Level;

				dTeamLevel [i] /= (double) aTeam.NumberOfPlayers;
			}

			// go through all players
			for (int i = 0; i < iPlayerIDs.Length; i++) 
			{
				int iOpponentPlayerCount = 0;
				double dExperiencePointDelta = 0.0f;

				// go through all opponent players
				for (int j = 0; j < iPlayerIDs.Length; j++) 
				{
					int iTeam1ID = iTeamIDs [i];
					int iTeam2ID = iTeamIDs [j];

					if (iTeam1ID != iTeam2ID) 
					{
						// update opponent count
						iOpponentPlayerCount++;

						// get the level gap
						int iLevelGap = (int) Math.Abs (dTeamLevel [iTeam1ID] - dTeamLevel [iTeam2ID]);
						if (iLevelGap > 6) iLevelGap = 6;

						/////////////////////////////////////////////////////////////////
						// update the experience points delta
						switch (aGame.GetWinner (iTeam1ID, iTeam2ID)) 
						{
							case +1: // Player i wins against player j
								if (dTeamLevel [iTeam1ID] > dTeamLevel [iTeam2ID])
									dExperiencePointDelta += (double) m_iHalo2DeltaTable [iLevelGap, 0];
								else
									dExperiencePointDelta += (double) m_iHalo2DeltaTable [iLevelGap, 2];
								break;
							case -1: // Player i loses against player j
								if (dTeamLevel [iTeam1ID] > dTeamLevel [iTeam2ID])
									dExperiencePointDelta += (double) m_iHalo2DeltaTable [iLevelGap, 1];
								else
									dExperiencePointDelta += (double) m_iHalo2DeltaTable [iLevelGap, 3];
								break;
							case 0: // Player i draws against player j
								if (dTeamLevel [iTeam1ID] > dTeamLevel [iTeam2ID]) 
								{
									dExperiencePointDelta += (double) m_iHalo2DeltaTable [iLevelGap, 0];
									dExperiencePointDelta += (double) m_iHalo2DeltaTable [iLevelGap, 1];
								}
								else 
								{
									dExperiencePointDelta += (double) m_iHalo2DeltaTable [iLevelGap, 2];
									dExperiencePointDelta += (double) m_iHalo2DeltaTable [iLevelGap, 3];
								}
								break;
						}
					}
				}

				//////////////////////////////////////////////////
				// compute the average experience points change
				dExperiencePointDelta /= (double) iOpponentPlayerCount;

				//////////////////////////////////////////////////
				// incorporate loss factors
				Halo2Skill aHalo2Skill = (Halo2Skill) m_aPlayerSkillsList.GetPlayerSkills ((int) iPlayerIDs [i]).LatestSkill;
				if (dExperiencePointDelta < 0.0)
					if (aHalo2Skill.Level < m_dLossFactor.Length)
						dExperiencePointDelta *= m_dLossFactor [aHalo2Skill.Level];

				//////////////////////////////////////////////////
				// add the new player skill
				Halo2Skill aNewSkill = new Halo2Skill ((int) aHalo2Skill.Points, aHalo2Skill.Level);
				aNewSkill.AddExperiencePoints ((int) dExperiencePointDelta);
				m_aPlayerSkillsList.GetPlayerSkills ((int) iPlayerIDs [i]).AddSkill (aNewSkill, aGame.Date.AddSeconds (+1));
			}

			// indicate the an update has happened
			return true;
		}


		/// <summary>
		/// Computes the most likely outcome by comparing the sum of the skill points of all players participating.
		/// </summary>
		/// <param name="aGame">The game for which the outcome should be predicted.</param>
		/// <returns>The predicted ranking.</returns>
		public override Ranking PredictedOutcome (Game aGame)
		{
			// compute team skills
			int [] iTeamSkillPoints = new int [aGame.NumberOfTeams];
			
			for (int iTeamCounter = 0; iTeamCounter < aGame.NumberOfTeams; iTeamCounter++) 
			{
				Team aTeam = aGame.GetTeam (iTeamCounter);
				iTeamSkillPoints [iTeamCounter] = 0;
				for (int iPlayerCounter = 0; iPlayerCounter < aTeam.NumberOfPlayers; iPlayerCounter++) 
				{
					// get the global player ID
					int iPlayerID = aTeam.GetPlayerID (iPlayerCounter);

					// increase the team skill
					Halo2Skill aHalo2Skill = (Halo2Skill) m_aPlayerSkillsList.GetPlayerSkills (iPlayerID).GetLatestSkill (aGame.Date);
					iTeamSkillPoints [iTeamCounter] += (int) aHalo2Skill.Points;
				}
			}

			// compute the ranking difference
			return new Ranking (iTeamSkillPoints);
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MuSigma\MSRanking\RankingSystems\ELORankingSystem.cs ===
/////////////////////////////////////////////////////////////////////////////////////////////
// ELORankingSystem.cs			ELO Ranking system 
//
// 2004 written by Ralf Herbrich
// Microsoft Research Ltd.
/////////////////////////////////////////////////////////////////////////////////////////////

using System;
using Numerics;
using MSRanking.Skills;

namespace MSRanking.RankingSystems
{
	/// <summary>
	/// A class that represents the ELO ranking system. This class manages a list of player skill lists. 
	/// Game outcomes will be incorporated by the ELO update equation. 
	/// </summary>
	public class ELORankingSystem : ProbabilisticRankingSystem
	{
		#region Class specific variable declarations
		/// <summary>
		/// The standard deviation of the performance distribution.
		/// </summary>
		double m_dBeta;
		/// <summary>
		/// The decay factor for the estimation of the winning probability.
		/// </summary>
		double	m_dAlpha;
		#endregion 

		#region Constructors
		/// <summary>
		/// Constructs a new instance of the ELO ranking system.
		/// </summary>
		/// <param name="aPlayerSkillsList">A list of player skill lists.</param>
		/// <param name="dBeta">The standard deviation of the performance distribution.</param>
		/// <param name="dAlpha">The decay factor for the estimation of the winning probability.</param>
		public ELORankingSystem (PlayerSkillsList aPlayerSkillsList, double dBeta, double dAlpha) : base (aPlayerSkillsList)
		{
			// copy the arguments
			this.Beta = dBeta;
			this.Alpha = dAlpha;
		}

		/// <summary>
		/// Constructs a new instance of the ELO ranking system with an empty list of player skill list.
		/// </summary>
		/// <param name="dBeta">The standard deviation of the performance distribution.</param>
		/// <param name="dAlpha">The decay factor for the estimation of the winning probability.</param>
		public ELORankingSystem (double dBeta, double dAlpha) : this (null, dBeta, dAlpha) {}
		#endregion

		#region Properties code
		/// <summary>
		/// The standard deviation of the performance distribution.
		/// </summary>
		public double Beta 
		{
			get 
			{
				return m_dBeta;
			}
			set 
			{
				if (value < 0.0)
					throw new Exception ("Standard deviation of performance distribution must be positive.");
				m_dBeta = value;
			}
		}

		/// <summary>
		/// The decay factor for the estimation of the winning probability.
		/// </summary>
		public double Alpha
		{
			get 
			{
				return m_dAlpha;
			}
			set 
			{
				if (value < 0.0 || value > 1.0)
					throw new Exception ("Decay factor must be between 0 and 1.");
				m_dAlpha = value;
			}
		}
		#endregion

		#region Update code
		/// <summary>
		/// Updates the player skills given a particular game. This the update equation for two player games. 
		/// This function also computes the evidence of the particular game. 
		/// </summary>
		/// <param name="aGame">The game to be incorporated.</param>
		/// <param name="dEvidence">The evidence of the game (as an output parameter).</param>
		/// <returns>True is the update was performed.</returns>
		override public bool Update (Game aGame, out double dEvidence)
		{
			// initially, set the evidence to zero
			dEvidence = 0.0;

			// make sure that we at least add an entry for all those players who did not yet played 
			// because we DID learn that the player is in the system from this moment on regardless 
			// of the fact that we may not be able to update the skill.
			int [] iPlayerIDs = aGame.PlayerIDs;
			for (int i = 0; i < iPlayerIDs.Length; i++) 
				if (m_aPlayerSkillsList.GetPlayerSkills (iPlayerIDs [i]).LatestSkill == null) 
					m_aPlayerSkillsList.GetPlayerSkills (iPlayerIDs [i]).AddSkill (new ELOSkill (), aGame.Date);

			// indicate the the update could not be performed and exit if we have anything different than two players
			if (aGame.NumberOfTeams != 2 || aGame.GetTeam (0).NumberOfPlayers != 1 || aGame.GetTeam (1).NumberOfPlayers != 1)
				return false;

			// get the skill points of the two players involved
			PlayerSkills aPlayer1Skills = m_aPlayerSkillsList.GetPlayerSkills (aGame.GetTeam (0).GetPlayerID (0));
			PlayerSkills aPlayer2Skills = m_aPlayerSkillsList.GetPlayerSkills (aGame.GetTeam (1).GetPlayerID (0));
			double dSkillPlayer1 = ((ELOSkill) aPlayer1Skills.LatestSkill).Points;
			double dSkillPlayer2 = ((ELOSkill) aPlayer2Skills.LatestSkill).Points;

			// Compute the 'magic' K factor
			double dK = Alpha * Beta * Math.Sqrt (Math.PI);
			double dPhi = GaussianApproximations.Phi ((dSkillPlayer1 - dSkillPlayer2) / (Math.Sqrt (2.0) * Beta));
			double dDelta = 1.0 - dPhi;
			double dDelta0 = 0.5 - dPhi;
			double dDeltaSkillPlayer1 = 0.0, dDeltaSkillPlayer2 = 0.0;
			
			// Compute the individual updates
			switch (aGame.GetWinner (0, 1))
			{
				case +1: // Case 1: Player 1 wins against Player 2
					dDeltaSkillPlayer1 = dK * dDelta;
					dDeltaSkillPlayer2 = -dDeltaSkillPlayer1;
					dEvidence = dPhi;			// dPhi IS the evidence (probability of) win of player 1!
					break;
				case -1: // Case 2: Player 2 wins against Player 1
					dDeltaSkillPlayer1 = -dK * (1.0 - dDelta);
					dDeltaSkillPlayer2 = -dDeltaSkillPlayer1;
					dEvidence = 1.0 - dPhi;		// the evidence for a win of player 2 is 1 - the evidence of the win of player 1
					break;
				case 0: // Case 3: Player 1 and Player 2 draw
					dDeltaSkillPlayer1 = dK * dDelta0;
					dDeltaSkillPlayer2 = -dDeltaSkillPlayer1;
					dEvidence = 0.0;			// the evidence for a draw is zero
					break;
			}

			// put the new skill back into the database
			aPlayer1Skills.AddSkill (new ELOSkill (dSkillPlayer1 + dDeltaSkillPlayer1), aGame.Date.AddSeconds (+1));
			aPlayer2Skills.AddSkill (new ELOSkill (dSkillPlayer2 + dDeltaSkillPlayer2), aGame.Date.AddSeconds (+1));

			// indicate that we did a successful update
			return true;
		}
		#endregion

		#region Ranking Probability code
		/// <summary>
		/// Computes the marginalised probability for some rankings for a given game.
		/// </summary>
		/// <param name="aGame">The game for which the ranking probabilities should be computed.</param>
		/// <param name="aRankings">A list of rankings for which the probability should be computed.</param>
		/// <returns>The probabilities of the specified rankings for the given game. This method throws an exception if 
		/// the probabilities cannot be computed.</returns>
		public override double [] RankingProbability (Game aGame, Ranking [] aRankings)
		{
			// check that we can compute the probability of the outcome
			if (aGame.NumberOfTeams != 2 || aGame.GetTeam (0).NumberOfPlayers != 1 || aGame.GetTeam (1).NumberOfPlayers != 1)
				throw new Exception ("Probability of ranking can only be computed for 2 players (not teams).");

			// allocate the result 
			double [] dProbabilities = new double [aRankings.Length];

			// get the game date
			DateTime aDate = aGame.Date;

			// run over all rankings
			for (int i = 0; i < aRankings.Length; i++) 
			{
				// get the player skill points
				double dSkillPlayer1 = ((ELOSkill) m_aPlayerSkillsList.GetPlayerSkills (aGame.GetTeam (0).GetPlayerID (0)).GetLatestSkill (aDate)).Points;
				double dSkillPlayer2 = ((ELOSkill) m_aPlayerSkillsList.GetPlayerSkills (aGame.GetTeam (1).GetPlayerID (0)).GetLatestSkill (aDate)).Points;

				// Compute the probability
				switch (aRankings [i].GetWinner (0, 1))
				{
					case +1: // Case 1: Player 1 wins against Player 2
						dProbabilities [i] = GaussianApproximations.Phi ((dSkillPlayer1 - dSkillPlayer2) / (Math.Sqrt (2.0) * Beta));
						break;
					case -1: // Case 2: Player 2 wins against Player 1
						dProbabilities [i] = GaussianApproximations.Phi ((dSkillPlayer2 - dSkillPlayer1) / (Math.Sqrt (2.0) * Beta));
						break;
					case 0: // Case 3: Player 1 and Player 2 draw
						dProbabilities [i] = 0.0;
						break;
				}
			}

			// return the probabilities
			return dProbabilities;
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MuSigma\MSRanking\RankingSystems\MuSigmaRankingSystem.cs ===
/////////////////////////////////////////////////////////////////////////////////////////////
// MuSigmaRankingSystem.cs			MuSigma Ranking system 
//
// 2004 written by Ralf Herbrich
// Microsoft Research Ltd.
/////////////////////////////////////////////////////////////////////////////////////////////

using System;
using System.Collections;
using System.Diagnostics;
using MSRanking.Skills;
using LinearAlgebra;
using Sampling;
using Numerics;

namespace MSRanking.RankingSystems
{
	/// <summary>
	/// Different types of approximation algorithm for the multi-team case.
	/// </summary>
	public enum Algorithm 
	{
		/// <summary>
		/// Genz' algorithm as described in <i>A. Genz. Numerical Computation of Multivariate 
		/// Normal Probabilities.</i> 1992.
		/// </summary>
		GenzAlgorithm, 
		/// <summary>
		/// Gaussien EP algorithm as described in <i>T. P. Minka. A family of algorithms for approximate Bayesian 
		/// inference.</i> PhD thesis. MIT. 2001.
		/// </summary>
		EPAlgorithm
	};

	/// <summary>
	/// A class that represents the MuSigma ranking system. This class manages a list of player skill lists. 
	/// Game outcomes will be incorporated by the MuSigma update equation. 
	/// </summary>
	public class MuSigmaRankingSystem : ProbabilisticRankingSystem
	{
		#region Class specific variable declarations
		/// <summary>
		/// The standard deviation of the performance distribution.
		/// </summary>
		double m_dBeta;
		/// <summary>
		/// The draw margin on the performance scale.
		/// </summary>
		double m_dEpsilon;
		/// <summary>
		/// The increase in standard deviation responsible for modelling the dynamics of the skill belief.
		/// </summary>
		double	m_dTau;
		/// <summary>
		/// The number of iterations of the numerical approximation code.
		/// </summary>
		int m_iNumberOfIterations;
		/// <summary>
		/// The particular algorithm used.
		/// </summary>
		Algorithm m_aApproximationAlgorithm;
		#endregion 

		#region Constructors
		/// <summary>
		/// Constructs a new instance of the MuSigma ranking system.
		/// </summary>
		/// <param name="aPlayerSkillsList">A list of player skill lists.</param>
		/// <param name="dBeta">The standard deviation of the performance distribution.</param>
		/// <param name="dEpsilon">The draw margin on the performance scale.</param>
		/// <param name="dTau">The increase in standard deviation that accounts for dynamics.</param>
		/// <param name="aApproximationAlgorithm">The approximation algorithm used.</param>
		/// <param name="iNumberOfIterations">The number of iterations whenever numerical integration is used.</param>
		public MuSigmaRankingSystem (PlayerSkillsList aPlayerSkillsList, double dBeta, double dEpsilon, double dTau, 
			Algorithm aApproximationAlgorithm, int iNumberOfIterations) : base (aPlayerSkillsList)
		{
			// copy the arguments
			this.Beta = dBeta;
			this.Tau = dTau;
			this.Epsilon = dEpsilon;
			this.NumberOfIterations = iNumberOfIterations;
			this.ApproximationAlgorithm = aApproximationAlgorithm;
		}

		/// <summary>
		/// Constructs a new instance of the MuSigma ranking system using the EP algorithm for approximation.
		/// </summary>
		/// <param name="aPlayerSkillsList">A list of player skill lists.</param>
		/// <param name="dBeta">The standard deviation of the performance distribution.</param>
		/// <param name="dEpsilon">The draw margin on the performance scale.</param>
		/// <param name="dTau">The increase in standard deviation that accounts for dynamics.</param>
		/// <param name="iNumberOfIterations">The number of iterations whenever numerical integration is used.</param>
		public MuSigmaRankingSystem (PlayerSkillsList aPlayerSkillsList, double dBeta, double dEpsilon, double dTau, int iNumberOfIterations) : this (aPlayerSkillsList, dBeta, dEpsilon, dTau, Algorithm.EPAlgorithm, iNumberOfIterations) {}

		/// <summary>
		/// Constructs a new instance of the MuSigma ranking system with an empty list of player skill list using the EP algorithm.
		/// </summary>
		/// <param name="dBeta">The standard deviation of the performance distribution.</param>
		/// <param name="dEpsilon">The draw margin on the performance scale.</param>
		/// <param name="dTau">The increase in standard deviation that accounts for dynamics.</param>
		/// <param name="iNumberOfIterations">The number of iterations whenever numerical integration is used.</param>
		public MuSigmaRankingSystem (double dBeta, double dEpsilon, double dTau, int iNumberOfIterations) : this (null, dBeta, dEpsilon, dTau, iNumberOfIterations) {}

		/// <summary>
		/// Constructs a new instance of the MuSigma ranking system with an empty list of player skill list and a fixed number of 
		/// 20 iterations for the numerical integration using the EP algorithm.
		/// </summary>
		/// <param name="dBeta">The standard deviation of the performance distribution.</param>
		/// <param name="dEpsilon">The draw margin on the performance scale.</param>
		/// <param name="dTau">The increase in standard deviation that accounts for dynamics.</param>
		public MuSigmaRankingSystem (double dBeta, double dEpsilon, double dTau) : this (dBeta, dEpsilon, dTau, 20) {}

		/// <summary>
		/// Constructs a new instance of the MuSigma ranking system with a fixed number of 20 iterations for the numerical integration using the EP algorithm.
		/// </summary>
		/// <param name="aPlayerSkillsList">A list of player skill lists.</param>
		/// <param name="dBeta">The standard deviation of the performance distribution.</param>
		/// <param name="dEpsilon">The draw margin on the performance scale.</param>
		/// <param name="dTau">The increase in standard deviation that accounts for dynamics.</param>
		public MuSigmaRankingSystem (PlayerSkillsList aPlayerSkillsList, double dBeta, double dEpsilon, double dTau) : this (aPlayerSkillsList, dBeta, dEpsilon, dTau, 20) {}
		#endregion

		#region Properties code
		/// <summary>
		/// The standard deviation of the performance distribution.
		/// </summary>
		public double Beta 
		{
			get 
			{
				return m_dBeta;
			}
			set 
			{
				if (value < 0.0)
					throw new Exception ("Standard deviation of performance distribution must be positive.");
				m_dBeta = value;
			}
		}

		/// <summary>
		/// The draw margin on the performance scale.
		/// </summary>
		public double Epsilon
		{
			get 
			{
				return m_dEpsilon;
			}
			set 
			{
				if (value < 0.0)
					throw new Exception ("Draw margin on the performance scale must be positive.");
				m_dEpsilon = value;
			}
		}

		/// <summary>
		/// The draw probability on the performance scale. Setting this property changes <c>Epsilon</c>
		/// for the current value of <c>Beta</c>.
		/// </summary>
		public double DrawProbability
		{
			get
			{
				return (1.0 - 2.0 * GaussianApproximations.Phi (-Epsilon / (Math.Sqrt (2.0) * Beta)));
			}
			set
			{
				if (value < 0.0 || value >= 1.0)
					throw new Exception ("The draw probability must be between 0.0 and 1.0.");
				m_dEpsilon = -Math.Sqrt (2.0) * Beta * GaussianApproximations.PhiInverse ((1.0 - value) / 2.0);
			}
		}

		/// <summary>
		/// The increase in standard deviation of the skill belief (dynamics prior).
		/// </summary>
		public double Tau
		{
			get 
			{
				return m_dTau;
			}
			set 
			{
				if (value < 0.0)
					throw new Exception ("Increase in standard deviation of the skill belief must be positive.");
				m_dTau = value;
			}
		}

		/// <summary>
		/// Number of iterations of the numerical approximation code.
		/// </summary>
		public int NumberOfIterations
		{
			get 
			{
				return m_iNumberOfIterations;
			}
			set 
			{
				if (value < 20)
					throw new Exception ("Number of iterations must be at least 20");
				m_iNumberOfIterations = value;
			}
		}

		/// <summary>
		/// Approximation algorithm for the multi-team and multi-player case.
		/// </summary>
		public Algorithm ApproximationAlgorithm
		{
			get 
			{
				return m_aApproximationAlgorithm;
			}
			set 
			{
				m_aApproximationAlgorithm = value;
			}
		}
		#endregion

		#region Internal game representation and skill belief specific code
		/// <summary>
		/// This struct holds the internal representation of a game in terms of matrices.
		/// </summary>
		private struct InternalGameRepresentation
		{
			/// <summary>
			/// A matrix with as many rows as players and as many column are there are teams (minus one).
			/// </summary>
			public Matrix A;
			/// <summary>
			/// The lower integration limits.
			/// </summary>
			public Matrix a;
			/// <summary>
			/// The upper integration limits.
			/// </summary>
			public Matrix b;
			/// <summary>
			/// A mapping from the index to the global player ID.
			/// </summary>
			public ArrayList iIndexToPlayerID;
		}

		/// <summary>
		/// Computes the internal game representation for a particular ranking.
		/// </summary>
		/// <param name="aGame">The game to be represented.</param>
		/// <param name="aRanking">The ranking of the game.</param>
		/// <returns></returns>
		private InternalGameRepresentation ComputeInternalGameRepresentation (Game aGame, Ranking aRanking)
		{
			// cache the number of players and the number of teams (for performance reasons only)
			int iNumberOfPlayers = aGame.NumberOfPlayers;
			int iNumberOfTeams = aGame.NumberOfTeams;

			// initialise the internal game representation
			InternalGameRepresentation aResult;
			aResult.A = new Matrix (iNumberOfPlayers, iNumberOfTeams - 1);
			aResult.a = new Matrix (iNumberOfTeams - 1, 1);
			aResult.b = new Matrix (iNumberOfTeams - 1, 1);
			aResult.iIndexToPlayerID = new ArrayList (aGame.NumberOfPlayers);

			// get the final game ranking
			int [] iIndex = aRanking.Indicies;

			// main loop over all teams
			for (int i = 0, iTotalPlayerCount = 0; i < iNumberOfTeams; i++) 
			{
				// update the player ID mapping
				Team aTeamAtCurrentRank = aGame.GetTeam (iIndex [i]);
				aResult.iIndexToPlayerID.AddRange (aTeamAtCurrentRank.PlayerIDs);

				if (i < iNumberOfTeams - 1) 
				{
					// construct the next column of 'A' and the next entry for the integration boundaries 'a' and 'b'
					Team aTeamAtNextRank = aGame.GetTeam (iIndex [i + 1]);

					switch (aRanking.GetWinner (iIndex [i], iIndex [i + 1])) 
					{
						case +1:
							aResult.a [i] = Epsilon;
							aResult.b [i] = double.PositiveInfinity;
							break;
						case 0:
							aResult.a [i] = -Epsilon;
							aResult.b [i] = Epsilon;
							break;
						default:
							// we should never get here
							Debug.Assert (false, "Internal error. Must be in the Rankings class.");
							break;
					}

					double dCurrentTwoTeamPlayerCount = (double) (aTeamAtCurrentRank.NumberOfPlayers + aTeamAtNextRank.NumberOfPlayers);
					for (int j = 0; j < aTeamAtCurrentRank.NumberOfPlayers; j++)
						aResult.A [iTotalPlayerCount++, i] = 2.0 / dCurrentTwoTeamPlayerCount;
					for (int j = 0; j < aTeamAtNextRank.NumberOfPlayers; j++)
						aResult.A [iTotalPlayerCount + j, i] = -2.0 / dCurrentTwoTeamPlayerCount;
				}
			}
			
			// return the results
			return aResult;
		}

		private struct InternalSkillBelief
		{
			/// <summary>
			/// Means of skill beliefs.
			/// </summary>
			public Matrix mu;
			/// <summary>
			/// Covariance matrix  of skill beliefs.
			/// </summary>
			public Matrix Sigma;
		}

		/// <summary>
		/// Gets the skill beliefs of all players participating in a game.
		/// </summary>
		/// <param name="aInternalGame">Internal representation of the game.</param>
		/// <param name="aDate">Date at which we would like to know the skill beliefs. If the time is at zero ticks, the latest 
		/// skill belief will be used.</param>
		/// <returns>An internal representation of the skill belief.</returns>
		/// <remarks>Note that this function already adds the amount of \tau^2 if it is queried for the latest skill beliefs.</remarks>
		private InternalSkillBelief GetSkillBelief (InternalGameRepresentation aInternalGame, DateTime aDate)
		{
			// get the total number of players
			int iNumberOfPlayers = aInternalGame.A.NoRows;

			// initialise the return structure
			InternalSkillBelief aResult;
			aResult.mu = new Matrix (iNumberOfPlayers, 1);
			aResult.Sigma = new Matrix (iNumberOfPlayers, iNumberOfPlayers);

			// get the skill beliefs from the list of player skill beliefs maintained by this ranking system
			for (int i = 0; i < iNumberOfPlayers; i++) 
			{
				MuSigmaSkill aMuSigmaSkill;
				if (aDate.Ticks == 0) 
				{
					aMuSigmaSkill = (MuSigmaSkill) (m_aPlayerSkillsList.GetPlayerSkills ((int) aInternalGame.iIndexToPlayerID [i]).LatestSkill);
					aResult.mu [i] = aMuSigmaSkill.Mu;
					aResult.Sigma [i, i] = aMuSigmaSkill.Sigma * aMuSigmaSkill.Sigma + Tau * Tau;
				}
				else 
				{
					aMuSigmaSkill = (MuSigmaSkill) (m_aPlayerSkillsList.GetPlayerSkills ((int) aInternalGame.iIndexToPlayerID [i]).GetLatestSkill (aDate));
					aResult.mu [i] = aMuSigmaSkill.Mu;
					aResult.Sigma [i, i] = aMuSigmaSkill.Sigma * aMuSigmaSkill.Sigma;
				}
			}

			// return the result
			return aResult;
		}
		#endregion

		#region Update code
		/// <summary>
		/// Updates the player skills given a particular game. This the general update equation for an arbitrary number
		/// of teams and players per team. This function also computes the evidence of this particular game.
		/// </summary>
		/// <param name="aGame">The game to be incorporated.</param>
		/// <param name="dEvidence">The evidence of the game (as an output parameter).</param>
		/// <returns>True is the update was performed.</returns>
		override public bool Update (Game aGame, out double dEvidence)
		{
			// initially, set the evidence to zero
			dEvidence = 0.0;

			// make sure that we at least add an entry for all those players who did not yet played 
			// because we DID learn that the player is in the system from this moment on regardless 
			// of the fact that we may not be able to update the score distribution
			int [] iPlayerIDs = aGame.PlayerIDs;
			for (int i = 0; i < iPlayerIDs.Length; i++) 
				if (m_aPlayerSkillsList.GetPlayerSkills (iPlayerIDs [i]).LatestSkill == null) 
					m_aPlayerSkillsList.GetPlayerSkills (iPlayerIDs [i]).AddSkill (new MuSigmaSkill (), aGame.Date);

			// indicate the the update could not be performed and exit if we have one team only
			if (aGame.NumberOfTeams <= 1)
				return false;

			try 
			{
				// This will indicate that we are interested in the latest skill belief
				DateTime aZeroTime = new DateTime (0);

				// Compute the internal game representation
				InternalGameRepresentation aGR = ComputeInternalGameRepresentation (aGame, aGame.Ranking);

				// Get the current skill beliefs
				InternalSkillBelief aS = GetSkillBelief (aGR, aZeroTime); 

				/////////////////////////////////////////////
				//  1. Compute u 
				//  2. Compute C and CInverse := C^{-1}
				//  3. Compute ACInverse := A * C^{-1}
				//  4. Compute v := ACInverse * (<u> - u)
				//  5. Compute W := ACInverse * (C - (<uu^T> - <u><u^T>)) * ACInverse^T
				/////////////////////////////////////////////
				Matrix u = aGR.A.Transpose () * aS.mu;
				Matrix C = aGR.A.Transpose () * (new Matrix (aS.Sigma.NoRows, Beta * Beta) + aS.Sigma) * aGR.A;
				Matrix CInverse = C.Inverse ();
				Matrix ACInverse = aGR.A * CInverse;
				Matrix v = null, W = null;

				switch (m_aApproximationAlgorithm) 
				{
					case Algorithm.GenzAlgorithm:
						GaussianApproximations.TGMoments aMoments;
						aMoments = GaussianApproximations.CalculateTGMoments (u, C, aGR.a, aGR.b, m_iNumberOfIterations); 
						v = ACInverse * (aMoments.M1 - u);
						W = ACInverse * ((C - (aMoments.M2 - aMoments.M1 * aMoments.M1.Transpose ())) * ACInverse.Transpose ());
						dEvidence = aMoments.M0;
						break;
					case Algorithm.EPAlgorithm:
						GaussianApproximations.TGAParameters aParameters;
						aParameters = GaussianApproximations.CalculateTGAParameters (u, C, aGR.a, aGR.b, m_iNumberOfIterations); 
						v = ACInverse * (aParameters.mu - u);
						W = ACInverse * ((C - aParameters.Sigma) * ACInverse.Transpose ());
						dEvidence = aParameters.Z;
						break;
				}
			
				// Write back the updated skill belief
				for (int i = 0; i < aS.mu.NoRows; i++)
				{
					double dMultiplicativeCorrection = (1.0 - aS.Sigma [i, i] * W [i, i]);
					double dAdditiveCorrection = aS.Sigma [i, i] * v [i];

					if (dMultiplicativeCorrection > 1.0) 
					{
						Console.WriteLine ("Multiplicative correction out of valid range (above): " + dMultiplicativeCorrection.ToString ());
						dMultiplicativeCorrection = 1.0;
					}
					if (dMultiplicativeCorrection < 0.0) 
					{
						Console.WriteLine ("Multiplicative correction out of valid range (below): " + dMultiplicativeCorrection.ToString ());
						dMultiplicativeCorrection = 0.0;
					}

					MuSigmaSkill aMuSigmaSkill = new MuSigmaSkill (aS.mu [i] + dAdditiveCorrection, 
						Math.Sqrt (aS.Sigma [i, i] * dMultiplicativeCorrection));
					m_aPlayerSkillsList.GetPlayerSkills ((int) aGR.iIndexToPlayerID [i]).AddSkill (aMuSigmaSkill, aGame.Date.AddSeconds (+1));
				}

				// indicate the the update was performed.
				return true;
			}

			catch (ArithmeticException)
			{
				Console.WriteLine ("Skipped game at " + aGame.Date.ToLongDateString () + " " + aGame.Date.ToLongTimeString ());
				// do not do the update because there are numerical problems
				return false;
			}
		}
		#endregion

		#region Ranking Probability code
		/// <summary>
		/// Computes the marginalised probability for some rankings for a given game.
		/// </summary>
		/// <param name="aGame">The game for which the ranking probabilities should be computed.</param>
		/// <param name="aRankings">A list of rankings for which the probability should be computed.</param>
		/// <returns>The probabilities of the specified rankings for the given game. This method throws an exception if 
		/// the probabilities cannot be computed.</returns>
		public override double [] RankingProbability (Game aGame, Ranking [] aRankings)
		{
			// check that we can compute the probability of the outcome
			if (aGame.NumberOfTeams < 2)
				throw new Exception ("Probability of ranking can only be computed for 2 or more players.");

			// allocate the result 
			double [] dProbabilities = new double [aRankings.Length];

			for (int i = 0; i < aRankings.Length; i++) 
			{
				// Compute the internal game representation
				InternalGameRepresentation aGR = ComputeInternalGameRepresentation (aGame, aRankings [i]);

				// Get the current skill belief
				InternalSkillBelief aS = GetSkillBelief (aGR, aGame.Date); 

				// Compute u and C
				Matrix u = aGR.A.Transpose () * aS.mu;
				Matrix C = aGR.A.Transpose () * (new Matrix (aS.Sigma.NoRows, Beta * Beta) + aS.Sigma) * aGR.A;

				// Compute the probability
				
				switch (m_aApproximationAlgorithm) 
				{
					case Algorithm.GenzAlgorithm:
						dProbabilities [i] = GaussianApproximations.Phi (u, C, aGR.a, aGR.b, m_iNumberOfIterations);
						break;
					case Algorithm.EPAlgorithm:
						dProbabilities [i] = GaussianApproximations.PhiEP (u, C, aGR.a, aGR.b, m_iNumberOfIterations);
						break;
				}
			}

			// return the result
			return dProbabilities;
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MuSigma\MSRanking\Skills\ELOSkill.cs ===
/////////////////////////////////////////////////////////////////////////////////////////////
// ELOSkill.cs		Class of a ELO player skill.
//
// 2004 written by Ralf Herbrich
// Microsoft Research Ltd.
/////////////////////////////////////////////////////////////////////////////////////////////

using System;

namespace MSRanking.Skills
{
	/// <summary>
	/// A class to represent the skill in the ELO system, that is, a single skill point measure.
	/// </summary>
	public class ELOSkill : Skill
	{
		/// <summary>
		/// The skill points of the player.
		/// </summary>
		double m_dPoints;		

		/// <summary>
		/// Constructor which initialises the score of the player.
		/// </summary>
		/// <param name="dPoints">Initial skill points.</param>
		public ELOSkill (double dPoints)
		{
			m_dPoints = dPoints;
		}

		/// <summary>
		/// Constructor which initialises the skill points to 1200.
		/// </summary>
		public ELOSkill () : this (1200.0) {}

		/// <summary>
		/// Skill points of the player. 
		/// </summary>
		override public double Points
		{
			get 
			{
				return m_dPoints;
			}
		}

		/// <summary>
		/// Skill level of the player. The skill level is obtained by dividing the skill points by 50 and making sure it never gets negative.
		/// </summary>
		public override int Level
		{
			get
			{
				return Math.Max ((int) Math.Ceiling (this.Points / 50.0), 0);
			}
		}

		/// <summary>
		/// Fractional skill level of the player.
		/// </summary>
		public override double FractionalLevel
		{
			get
			{
				double dFractionalLevel = 1.0 - ((((double) (this.Level)) * 50.0 - this.Points) / 50.0);
				
				return (dFractionalLevel > 1.0)?1.0:((dFractionalLevel < 0.0)?0.0:dFractionalLevel);
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MuSigma\MSRanking\Skills\Halo2Skills.cs ===
/////////////////////////////////////////////////////////////////////////////////////////////
// Halo2Skill.cs		Class of a Halo 2 player skill.
//
// 2004 written by Ralf Herbrich
// Microsoft Research Ltd.
/////////////////////////////////////////////////////////////////////////////////////////////

using System;

namespace MSRanking.Skills
{
	/// <summary>
	/// A class to represent the skill in the Halo 2 system, that is, the current experience points.
	/// </summary>
	public class Halo2Skill : Skill
	{
		/// <summary>
		/// The experience points of the player.
		/// </summary>
		int m_iExperiencePoints;
		/// <summary>
		/// The level of the player.
		/// </summary>
		int m_iLevel;

		/// <summary>
		/// Constructor which initialises the experience points and levels.
		/// </summary>
		/// <param name="iExperiencePoints">Experience points.</param>
		/// <param name="iLevel">Level</param>
		public Halo2Skill (int iExperiencePoints, int iLevel)
		{
			m_iExperiencePoints = iExperiencePoints;
			m_iLevel = iLevel;
		}

		/// <summary>
		/// The number of experience points.
		/// </summary>
		public int ExperiencePoints
		{
			get 
			{
				return m_iExperiencePoints;
			}
		}

		/// <summary>
		/// The skill points of the player. This is just the experience points.
		/// </summary>
		override public double Points
		{
			get 
			{
				return (double) this.ExperiencePoints;
			}
		}

		/// <summary>
		/// The skill level of the player. 
		/// </summary>
		override public int Level
		{
			get 
			{
				return (m_iLevel < 0)?0:m_iLevel;
			}
		}

		/// <summary>
		/// Adds experience points. 
		/// </summary>
		/// <remarks>Makes sure that the skill level only updates downwards if the experience points falls below halfway 
		/// the skill level thresholds of the skill level below. This feature adds an effective momentum to the movement of the skill 
		/// level downwards.
		/// </remarks>
		public void AddExperiencePoints (int iExperiencePointsDelta)
		{
			int [] iLevelThresholds = {   100, 200, 400, 600, 900, 1200,
										  1600, 2000, 2500, 3000, 3500, 4000,
										  4500, 5000, 5500, 6000, 6500, 7000, 
										  7500, 8000, 8500, 9000, 9500, 10000,
										  10500, 11000, 11500, 12000, 12500, 13000, 
										  13500, 14000, 14500, 15000, 15500, 16000,
										  16500, 17000, 17500, 18100, 18900, 20000,
										  21500, 23500, 26100, 29400, 33500, 38500,
										  44500};
			// increases the experience points 
			m_iExperiencePoints += iExperiencePointsDelta;

			if (iExperiencePointsDelta > 0) 
			{
				// possibly increases the level
				while (m_iLevel < iLevelThresholds.Length &&  m_iExperiencePoints > iLevelThresholds [m_iLevel])
					m_iLevel++;
			}
			else 
			{
				// possible decrease the level
				while (m_iLevel > 1 && m_iExperiencePoints < (iLevelThresholds [m_iLevel - 2] + iLevelThresholds [m_iLevel - 1]) / 2)
					m_iLevel--;
			}
		}

		/// <summary>
		/// Fractional skill level of the player.
		/// </summary>
		override public double FractionalLevel
		{
			get 
			{
				int [] iLevelThresholds = {   100, 200, 400, 600, 900, 1200,
											  1600, 2000, 2500, 3000, 3500, 4000,
											  4500, 5000, 5500, 6000, 6500, 7000, 
											  7500, 8000, 8500, 9000, 9500, 10000,
											  10500, 11000, 11500, 12000, 12500, 13000, 
											  13500, 14000, 14500, 15000, 15500, 16000,
											  16500, 17000, 17500, 18100, 18900, 20000,
											  21500, 23500, 26100, 29400, 33500, 38500,
											  44500};

				// for the first and last level, we cannot compute them so we might as well return 0.0
				if (m_iLevel <= 0 || m_iLevel ==  50)
					return 0.0;

				// gets the lower and upper boundary
				double dFraction = (double) (m_iExperiencePoints - iLevelThresholds [m_iLevel - 1]) / 
					(double) (iLevelThresholds [m_iLevel] - iLevelThresholds [m_iLevel - 1]);

				return (dFraction > 0.0)?dFraction:((dFraction < 1.0)?dFraction:1.0);
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MuSigma\MSRanking\Skills\MuSigmaSkill.cs ===
/////////////////////////////////////////////////////////////////////////////////////////////
// MuSigmaSkill.cs		Class of a MuSigma skill belief.
//
// 2004 written by Ralf Herbrich
// Microsoft Research Ltd.
/////////////////////////////////////////////////////////////////////////////////////////////

using System;

namespace MSRanking.Skills
{
	/// <summary>
	/// A class to represent the skill belief in the MuSigma system, that is, the parameters \mu (mean) and \sigma (standard deviation) of 
	/// the Gaussian skill belief.
	/// </summary>
	public class MuSigmaSkill : Skill
	{
		/// <summary>
		/// The mean of the skill belief.
		/// </summary>
		double m_dMu;		
		/// <summary>
		/// The standard deviation of the skill belief.
		/// </summary>
		double m_dSigma;	

		/// <summary>
		/// Constructor which initialises mean and standard deviation of the skill belief.
		/// </summary>
		/// <param name="dMu">Mean of the skill belief.</param>
		/// <param name="dSigma">Standard deviation of the skill belief.</param>
		public MuSigmaSkill (double dMu, double dSigma)
		{
			m_dMu = dMu;
			m_dSigma = dSigma;
		}

		/// <summary>
		/// Constructor which initialises the skill belief with mean of 1200 and standard
		/// deviation of 400.
		/// </summary>
		public MuSigmaSkill () : this (1200.0, 400.0) {}

		/// <summary>
		/// The mean of the skill belief.
		/// </summary>
		public double Mu 
		{
			get 
			{
				return m_dMu;
			}
		}

		/// <summary>
		/// The standard deviation of the skill belief.
		/// </summary>
		public double Sigma 
		{
			get 
			{
				return m_dSigma;
			}
		}

		/// <summary>
		/// Skill points of the player. 
		/// </summary>
		/// <remarks>The skill points of the player is the lower 99% quantile of the skill belief. This is a very conservative 
		/// estimate of the true skill of a player and should always lower bound the true skill.</remarks>
		override public double Points
		{
			get 
			{
				return m_dMu - 3.0 * m_dSigma;
			}
		}

		/// <summary>
		/// Skill level of the player. The skill level is obtained by dividing the skill points by 50 and making sure it never gets negative.
		/// </summary>
		public override int Level
		{
			get
			{
				return Math.Max ((int) Math.Ceiling (this.Points / 50.0), 0);
			}
		}

		/// <summary>
		/// Fractional skill level of the player.
		/// </summary>
		public override double FractionalLevel
		{
			get
			{
				double dFractionalLevel = 1.0 - ((((double) (this.Level)) * 50.0 - this.Points) / 50.0);
				
				return (dFractionalLevel > 1.0)?1.0:((dFractionalLevel < 0.0)?0.0:dFractionalLevel);
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MuSigma\MuSigma\AboutWindow.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Reflection;

namespace MuSigma
{
	/// <summary>
	/// A class that represent the "About" dialog window for the MuSigma application. Displays some fancy HALO 2 image
	/// and copyright information.
	/// </summary>
	public class AboutWindow : System.Windows.Forms.Form
	{
		private System.Windows.Forms.Label lblTitle1;
		private System.Windows.Forms.Button btnOK;
		private System.Windows.Forms.Label lblInformation;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		/// <summary>
		/// Constructs a new instance of an about window.
		/// </summary>
		public AboutWindow()
		{
			// Required for Windows Form Designer support
			InitializeComponent();

			// put the version information for all packages in the about text field
			Version aMSRankingVersion = typeof (MSRanking.RankingSystems.MuSigmaRankingSystem).Assembly.GetName ().Version;
			Version aMainVersion = typeof (MainWindow).Assembly.GetName ().Version;
			Version aNumericsVersion = typeof (Numerics.GaussianApproximations).Assembly.GetName ().Version;

			lblInformation.Text = "2004 (c) Microsoft Research Ltd.\n\nHalo 2 analyser v. " + aMainVersion.ToString () + 
					"\nRanking package v. " + aMSRankingVersion.ToString () + 
					"\nNumerics package v. " + aNumericsVersion.ToString ();
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(AboutWindow));
			this.lblTitle1 = new System.Windows.Forms.Label();
			this.lblInformation = new System.Windows.Forms.Label();
			this.btnOK = new System.Windows.Forms.Button();
			this.SuspendLayout();
			// 
			// lblTitle1
			// 
			this.lblTitle1.BackColor = System.Drawing.Color.Transparent;
			this.lblTitle1.Font = new System.Drawing.Font("Franklin Gothic Demi", 36F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.lblTitle1.ForeColor = System.Drawing.Color.DarkSlateGray;
			this.lblTitle1.Location = new System.Drawing.Point(32, 16);
			this.lblTitle1.Name = "lblTitle1";
			this.lblTitle1.Size = new System.Drawing.Size(416, 112);
			this.lblTitle1.TabIndex = 4;
			this.lblTitle1.Text = "Halo 2 Ranking System Analyser";
			this.lblTitle1.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
			// 
			// lblInformation
			// 
			this.lblInformation.BackColor = System.Drawing.Color.Transparent;
			this.lblInformation.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Italic, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.lblInformation.Location = new System.Drawing.Point(48, 128);
			this.lblInformation.Name = "lblInformation";
			this.lblInformation.Size = new System.Drawing.Size(368, 88);
			this.lblInformation.TabIndex = 5;
			this.lblInformation.Text = "2004 (c) by Microsoft Research Ltd .";
			this.lblInformation.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
			// 
			// btnOK
			// 
			this.btnOK.BackColor = System.Drawing.Color.Transparent;
			this.btnOK.DialogResult = System.Windows.Forms.DialogResult.OK;
			this.btnOK.Location = new System.Drawing.Point(184, 224);
			this.btnOK.Name = "btnOK";
			this.btnOK.Size = new System.Drawing.Size(104, 32);
			this.btnOK.TabIndex = 6;
			this.btnOK.Text = "OK";
			// 
			// AboutWindow
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.BackgroundImage = ((System.Drawing.Image)(resources.GetObject("$this.BackgroundImage")));
			this.ClientSize = new System.Drawing.Size(472, 262);
			this.Controls.Add(this.btnOK);
			this.Controls.Add(this.lblInformation);
			this.Controls.Add(this.lblTitle1);
			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
			this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
			this.MaximizeBox = false;
			this.MinimizeBox = false;
			this.Name = "AboutWindow";
			this.Text = "About Halo 2 MuSigma";
			this.ResumeLayout(false);

		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MuSigma\MuSigma\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("MuSigma")]
[assembly: AssemblyDescription("Front-end for the HALO 2 multiplayer results to evaluate ranking algorithms.")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft Research Ltd.")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("2004 (c) Microsoft Resarch Ltd.")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.9.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MuSigma\MuSigma\Halo2Game.cs ===
/////////////////////////////////////////////////////////////////////////////////////////////
// Halo2Game.cs		Game management functions for HALO 2 games. Manages extra information.
//
// 2004 written by Ralf Herbrich
// Microsoft Research Ltd.
/////////////////////////////////////////////////////////////////////////////////////////////

using System;
using MSRanking;

namespace MuSigma
{
	/// <summary>
	/// A class to represent a HALO 2 game. In addition to the functionality of the base class, this class also stores
	/// the hopper, the variant and the map name of the game.
	/// </summary>
	public class Halo2Game : Game
	{
		/// <summary>
		/// Name of the map.
		/// </summary>
		string m_szMap;
		/// <summary>
		/// Name of the game variant.
		/// </summary>
		string m_szVariant;
		/// <summary>
		/// Name of the game hopper.
		/// </summary>
		string m_szHopper;

		/// <summary>
		/// Constructs a HALO 2 game of a specific HALO 2 variant that ended at a specific date on a given HALO 2 map 
		/// in a given HALO 2 hopper.
		/// </summary>
		/// <param name="aDate">Date at which the HALO 2 game ended.</param>
		/// <param name="szMap">Name of the HALO 2 map at which the game happened.</param>
		/// <param name="szVariant">Name of the HALO 2 game variant.</param>
		/// <param name="szHopper">Name of the HALO 2 hopper.</param>
		public Halo2Game (DateTime aDate, string szMap, string szVariant, string szHopper) : base (aDate)
		{
			// copy parameters
			m_szMap = szMap;
			m_szVariant = szVariant;
			m_szHopper = szHopper;
		}

		/// <summary>
		/// Name of the HALO 2 map where the game took place.
		/// </summary>
		public string Map
		{
			get 
			{
				return m_szMap;
			}
		}

		/// <summary>
		/// Name of the HALO 2 variant of the game.
		/// </summary>
		public string Variant
		{
			get 
			{
				return m_szVariant;
			}
		}

		/// <summary>
		/// Name of the HALO 2 hopper in which the game took place.
		/// </summary>
		public string Hopper
		{
			get 
			{
				return m_szHopper;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MuSigma\MuSigma\Halo2GameList.cs ===
/////////////////////////////////////////////////////////////////////////////////////////////
// Halo2GameList.cs		Management functions for a list of Halo 2 games. 
//
// 2004 written by Ralf Herbrich
// Microsoft Research Ltd.
/////////////////////////////////////////////////////////////////////////////////////////////

using System;
using System.Collections;
using MSRanking;

namespace MuSigma
{
	/// <summary>
	/// A class which manages a series of games. Games will not be automatically be sorted by the date at which they ended but it is assumed. 
	/// that the games are added in chronological order. Note that this class will enforce that no two games ended at EXACTLY the same time.
	/// </summary>
	public class Halo2GameList
	{
		/// <summary>
		/// A variable sized list of games.
		/// </summary>
		ArrayList m_aHalo2GameList;			

		/// <summary>
		/// Default constructor which initialises an empty game list.
		/// </summary>
		public Halo2GameList ()
		{
			m_aHalo2GameList = new ArrayList ();
		}

		/// <summary>
		/// Clears (empties) the game list.
		/// </summary>
		public void Clear ()
		{
			m_aHalo2GameList.Clear ();
		}

		/// <summary>
		/// The total number of games.
		/// </summary>
		public int NumberOfGames 
		{
			get 
			{
				return m_aHalo2GameList.Count;
			}
		}

		/// <summary>
		/// Adds a new game to the game list. 
		/// </summary>
		/// <param name="aHalo2Game">A new game.</param>
		/// <remarks>An exception is thrown if there already exists a game at the specified date.</remarks>
		public void AddGame (Halo2Game aHalo2Game)
		{
			// if the game list is empty, just add
			if (m_aHalo2GameList.Count == 0) 
			{
				m_aHalo2GameList.Add (aHalo2Game);
				return;
			}

			// check that the game added is always after the last added game
			if (((Halo2Game) m_aHalo2GameList [m_aHalo2GameList.Count - 1]).Date >= aHalo2Game.Date)
				throw new Exception ("Halo 2 game is not added in chronological order.");
			else
				m_aHalo2GameList.Add (aHalo2Game);
		}

		/// <summary>
		/// Gets the game at a specified index.
		/// </summary>
		/// <param name="iIndex">The index.</param>
		/// <returns>The Game at the specified index, or null if the index was out of range.</returns>
		public Halo2Game GetGame (int iIndex)
		{
			try 
			{
				return ((Halo2Game) m_aHalo2GameList [iIndex]);
			} 
			catch (ArgumentOutOfRangeException) 
			{
				return (null);
			}
		}

		/// <summary>
		/// All game dates.
		/// </summary>
		public string [] GameDates 
		{
			get 
			{
				string [] szGameDatesList = new string [m_aHalo2GameList.Count];

				for (int i = 0; i < m_aHalo2GameList.Count; i++) 
				{
					DateTime aDate = this.GetGame (i).Date;
					szGameDatesList [i] = aDate.ToLongDateString () + "\t" + aDate.ToLongTimeString ();
				}

				return (szGameDatesList);
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MuSigma\MuSigma\LogWindow.cs ===
/////////////////////////////////////////////////////////////////////////////////////////////
// LogWindow.cs		Dialog window that shows log information.
//
// 2004 written by Ralf Herbrich
// Microsoft Research Ltd.
/////////////////////////////////////////////////////////////////////////////////////////////

using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;

namespace MuSigma
{
	/// <summary>
	/// A class that represents a dialog form for displaying additional logging information. Each log
	/// must fit within a line and is displayed in a non-selectable listbox. 
	/// </summary>
	public class LogWindow : System.Windows.Forms.Form
	{
		private System.Windows.Forms.ListBox lbLog;
		private System.Windows.Forms.Button btnOK;
		private System.Windows.Forms.Label lblTitle;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		/// <summary>
		/// Constrcuts a new instance of a log window.
		/// </summary>
		public LogWindow()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(LogWindow));
			this.lbLog = new System.Windows.Forms.ListBox();
			this.btnOK = new System.Windows.Forms.Button();
			this.lblTitle = new System.Windows.Forms.Label();
			this.SuspendLayout();
			// 
			// lbLog
			// 
			this.lbLog.Location = new System.Drawing.Point(32, 72);
			this.lbLog.Name = "lbLog";
			this.lbLog.SelectionMode = System.Windows.Forms.SelectionMode.None;
			this.lbLog.Size = new System.Drawing.Size(480, 199);
			this.lbLog.TabIndex = 0;
			// 
			// btnOK
			// 
			this.btnOK.DialogResult = System.Windows.Forms.DialogResult.OK;
			this.btnOK.Location = new System.Drawing.Point(212, 288);
			this.btnOK.Name = "btnOK";
			this.btnOK.Size = new System.Drawing.Size(120, 32);
			this.btnOK.TabIndex = 1;
			this.btnOK.Text = "OK";
			// 
			// lblTitle
			// 
			this.lblTitle.Font = new System.Drawing.Font("Microsoft Sans Serif", 18F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.lblTitle.Location = new System.Drawing.Point(44, 16);
			this.lblTitle.Name = "lblTitle";
			this.lblTitle.Size = new System.Drawing.Size(456, 40);
			this.lblTitle.TabIndex = 2;
			this.lblTitle.Text = "Information";
			this.lblTitle.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
			// 
			// LogWindow
			// 
			this.AcceptButton = this.btnOK;
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(544, 344);
			this.Controls.Add(this.lblTitle);
			this.Controls.Add(this.btnOK);
			this.Controls.Add(this.lbLog);
			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
			this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
			this.MaximizeBox = false;
			this.Name = "LogWindow";
			this.ShowInTaskbar = false;
			this.Text = "Information";
			this.ResumeLayout(false);

		}
		#endregion

		/// <summary>
		/// Clears the log list.
		/// </summary>
		public void ClearLogList ()
		{
			lbLog.Items.Clear ();
		}

		/// <summary>
		/// Log name (appearing on the window title).
		/// </summary>
		public string LogName 
		{
			set 
			{
				this.Text = value;
				lblTitle.Text = value;
			}
		}

		/// <summary>
		/// Adds a new line of log information. 
		/// </summary>
		/// <param name="szLine">Line to be added.</param>
		public void AddLine (string szLine)
		{
			lbLog.Items.Add (szLine);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MuSigma\MuSigma\QuickCommandDialog.cs ===
/////////////////////////////////////////////////////////////////////////////////////////////
// QickCommandDialog.cs		Windows from to select quick commands.
//
// 2004 written by Ralf Herbrich
// Microsoft Research Ltd.
/////////////////////////////////////////////////////////////////////////////////////////////

using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;

namespace MuSigma
{
	/// <summary>
	/// This dialog form offers the possibility to display and select in a list of quickly accessible commands. 
	/// </summary>
	public class QuickCommandDialog : System.Windows.Forms.Form
	{
		#region Variable declarations
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;
		/// <summary>
		/// The list of command information.
		/// </summary>
		private ArrayList m_szCommandInformationList;

		private System.Windows.Forms.ListBox lbCommandName;
		private System.Windows.Forms.Label lblCommandInfo;
		private System.Windows.Forms.Label label2;
		private System.Windows.Forms.Button btnOK;
		private System.Windows.Forms.Button btnCancel;
		#endregion

		#region Constructor and Destructor
		/// <summary>
		/// Constructs a new Quick Command dialog. The dialog will not be displayed.
		/// </summary>
		public QuickCommandDialog ()
		{
			// Required for Windows Form Designer support
			InitializeComponent();

			// initialise the information list
			m_szCommandInformationList = new ArrayList ();
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}
		#endregion

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(QuickCommandDialog));
			this.lbCommandName = new System.Windows.Forms.ListBox();
			this.lblCommandInfo = new System.Windows.Forms.Label();
			this.label2 = new System.Windows.Forms.Label();
			this.btnCancel = new System.Windows.Forms.Button();
			this.btnOK = new System.Windows.Forms.Button();
			this.SuspendLayout();
			// 
			// lbCommandName
			// 
			this.lbCommandName.Location = new System.Drawing.Point(24, 56);
			this.lbCommandName.Name = "lbCommandName";
			this.lbCommandName.Size = new System.Drawing.Size(304, 264);
			this.lbCommandName.TabIndex = 2;
			this.lbCommandName.DoubleClick += new System.EventHandler(this.lbCommandName_DoubleClick);
			this.lbCommandName.SelectedIndexChanged += new System.EventHandler(this.lbCommandName_SelectedIndexChanged);
			// 
			// lblCommandInfo
			// 
			this.lblCommandInfo.Location = new System.Drawing.Point(352, 56);
			this.lblCommandInfo.Name = "lblCommandInfo";
			this.lblCommandInfo.Size = new System.Drawing.Size(240, 264);
			this.lblCommandInfo.TabIndex = 3;
			// 
			// label2
			// 
			this.label2.Font = new System.Drawing.Font("Microsoft Sans Serif", 24F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.label2.Location = new System.Drawing.Point(96, 8);
			this.label2.Name = "label2";
			this.label2.Size = new System.Drawing.Size(416, 40);
			this.label2.TabIndex = 4;
			this.label2.Text = "Quick Commands";
			this.label2.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
			// 
			// btnCancel
			// 
			this.btnCancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
			this.btnCancel.Location = new System.Drawing.Point(512, 336);
			this.btnCancel.Name = "btnCancel";
			this.btnCancel.TabIndex = 1;
			this.btnCancel.Text = "Cancel";
			// 
			// btnOK
			// 
			this.btnOK.DialogResult = System.Windows.Forms.DialogResult.OK;
			this.btnOK.Location = new System.Drawing.Point(424, 336);
			this.btnOK.Name = "btnOK";
			this.btnOK.TabIndex = 0;
			this.btnOK.Text = "OK";
			// 
			// QuickCommandDialog
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(618, 368);
			this.Controls.Add(this.btnOK);
			this.Controls.Add(this.btnCancel);
			this.Controls.Add(this.label2);
			this.Controls.Add(this.lblCommandInfo);
			this.Controls.Add(this.lbCommandName);
			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
			this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
			this.MaximizeBox = false;
			this.Name = "QuickCommandDialog";
			this.Text = "QuickCommandDialog";
			this.ResumeLayout(false);

		}
		#endregion

		#region Property code
		/// <summary>
		/// The index of the currently selected command.
		/// </summary>
		public int SelectedCommandIndex 
		{
			get 
			{
				return lbCommandName.SelectedIndex;
			}
		}
		#endregion

		#region Data manipuldation code
		/// <summary>
		/// Adds a new command to the quick command list.
		/// </summary>
		/// <param name="szCommandName">The name of the command to be added.</param>
		/// <param name="szCommandInformation">The extra information for this command.</param>
		public void AddCommand (string szCommandName, string szCommandInformation)
		{
			lbCommandName.Items.Add (szCommandName);
			m_szCommandInformationList.Add (szCommandInformation);
			lbCommandName.SetSelected (0, true);
		}
		#endregion

		#region Event handlers
		/// <summary>
		/// Handles a click on the selected command.
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		private void lbCommandName_SelectedIndexChanged (object sender, System.EventArgs e)
		{
			lblCommandInfo.Text = (string) m_szCommandInformationList [lbCommandName.SelectedIndex];
		}

		/// <summary>
		/// Handles a double click on the selected command.
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		private void lbCommandName_DoubleClick(object sender, System.EventArgs e)
		{
			this.DialogResult = DialogResult.OK;
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MuSigma\MuSigma\RankingParameters.cs ===
/////////////////////////////////////////////////////////////////////////////////////////////
// RankingParameter.cs		Windows from to input ranking parameters.
//
// 2004 written by Ralf Herbrich
// Microsoft Research Ltd.
/////////////////////////////////////////////////////////////////////////////////////////////

using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Diagnostics;
using Numerics;
using MSRanking.RankingSystems;

namespace MuSigma
{
	/// <summary>
	/// A class that represents a dialog form for obtaining ranking parameters such as the performance standard deviation.
	/// </summary>
	public class RankingParameters : System.Windows.Forms.Form
	{
		#region Form specific variable declarations
		private System.Windows.Forms.Button btnOk;
		private System.Windows.Forms.Button btnCancel;
		private System.Windows.Forms.Label label4;
		private System.Windows.Forms.ToolTip toolTip;
		private System.Windows.Forms.CheckBox cbAdvanced;
		private System.Windows.Forms.TabControl tbcMain;
		private System.Windows.Forms.GroupBox gbMuSigmaApproximation;
		private System.Windows.Forms.Label lblMuSigmaIterations;
		private System.Windows.Forms.GroupBox gbMuSigmaDynamics;
		private System.Windows.Forms.Label lblMuSigmaTau;
		private System.Windows.Forms.GroupBox gbMuSigmaScoreScale;
		private System.Windows.Forms.Label lblMuSigmaBeta;
		private System.Windows.Forms.GroupBox gbMuSigmaDraw;
		private System.Windows.Forms.Label lblMuSigmaDrawProbability;
		private System.Windows.Forms.Label lblMuSigmaEpsilon;
		private System.Windows.Forms.TabPage tpMuSigma;
		private System.Windows.Forms.TabPage tpELO;
		private System.Windows.Forms.GroupBox dbELODynamics;
		private System.Windows.Forms.Label lblELOAlpha;
		private System.Windows.Forms.Label lblELOBeta;
		private System.Windows.Forms.GroupBox gbELOScoreScale;
		private System.Windows.Forms.NumericUpDown numMuSigmaBeta;
		private System.Windows.Forms.NumericUpDown numMuSigmaEpsilon;
		private System.Windows.Forms.NumericUpDown numMuSigmaDrawProbability;
		private System.Windows.Forms.NumericUpDown numMuSigmaTau;
		private System.Windows.Forms.NumericUpDown numMuSigmaIterations;
		private System.Windows.Forms.NumericUpDown numELOBeta;
		private System.Windows.Forms.NumericUpDown numELOAlpha;
		private System.Windows.Forms.Label lblMuSigmaApproximationAlgorithm;
		private System.Windows.Forms.ComboBox cbMuSigmaAlgorithm;
		private System.ComponentModel.IContainer components;
		#endregion

		#region Constructor and Destructor
		/// <summary>
		/// Constructs an instance of the ranking parameters dialog form.
		/// </summary>
		public RankingParameters()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			// update the draw probability field
			UpdateMuSigmaDrawProbability ();

			// update the visible elements
			cbAdvanced_CheckedChanged (null, null);
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}
		#endregion

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.components = new System.ComponentModel.Container();
			System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(RankingParameters));
			this.btnOk = new System.Windows.Forms.Button();
			this.btnCancel = new System.Windows.Forms.Button();
			this.label4 = new System.Windows.Forms.Label();
			this.toolTip = new System.Windows.Forms.ToolTip(this.components);
			this.lblMuSigmaIterations = new System.Windows.Forms.Label();
			this.lblMuSigmaTau = new System.Windows.Forms.Label();
			this.lblMuSigmaBeta = new System.Windows.Forms.Label();
			this.lblMuSigmaDrawProbability = new System.Windows.Forms.Label();
			this.lblMuSigmaEpsilon = new System.Windows.Forms.Label();
			this.lblELOAlpha = new System.Windows.Forms.Label();
			this.lblELOBeta = new System.Windows.Forms.Label();
			this.cbAdvanced = new System.Windows.Forms.CheckBox();
			this.tbcMain = new System.Windows.Forms.TabControl();
			this.tpMuSigma = new System.Windows.Forms.TabPage();
			this.gbMuSigmaApproximation = new System.Windows.Forms.GroupBox();
			this.numMuSigmaIterations = new System.Windows.Forms.NumericUpDown();
			this.gbMuSigmaDynamics = new System.Windows.Forms.GroupBox();
			this.numMuSigmaTau = new System.Windows.Forms.NumericUpDown();
			this.gbMuSigmaScoreScale = new System.Windows.Forms.GroupBox();
			this.numMuSigmaBeta = new System.Windows.Forms.NumericUpDown();
			this.gbMuSigmaDraw = new System.Windows.Forms.GroupBox();
			this.numMuSigmaDrawProbability = new System.Windows.Forms.NumericUpDown();
			this.numMuSigmaEpsilon = new System.Windows.Forms.NumericUpDown();
			this.tpELO = new System.Windows.Forms.TabPage();
			this.dbELODynamics = new System.Windows.Forms.GroupBox();
			this.numELOAlpha = new System.Windows.Forms.NumericUpDown();
			this.gbELOScoreScale = new System.Windows.Forms.GroupBox();
			this.numELOBeta = new System.Windows.Forms.NumericUpDown();
			this.lblMuSigmaApproximationAlgorithm = new System.Windows.Forms.Label();
			this.cbMuSigmaAlgorithm = new System.Windows.Forms.ComboBox();
			this.tbcMain.SuspendLayout();
			this.tpMuSigma.SuspendLayout();
			this.gbMuSigmaApproximation.SuspendLayout();
			((System.ComponentModel.ISupportInitialize)(this.numMuSigmaIterations)).BeginInit();
			this.gbMuSigmaDynamics.SuspendLayout();
			((System.ComponentModel.ISupportInitialize)(this.numMuSigmaTau)).BeginInit();
			this.gbMuSigmaScoreScale.SuspendLayout();
			((System.ComponentModel.ISupportInitialize)(this.numMuSigmaBeta)).BeginInit();
			this.gbMuSigmaDraw.SuspendLayout();
			((System.ComponentModel.ISupportInitialize)(this.numMuSigmaDrawProbability)).BeginInit();
			((System.ComponentModel.ISupportInitialize)(this.numMuSigmaEpsilon)).BeginInit();
			this.tpELO.SuspendLayout();
			this.dbELODynamics.SuspendLayout();
			((System.ComponentModel.ISupportInitialize)(this.numELOAlpha)).BeginInit();
			this.gbELOScoreScale.SuspendLayout();
			((System.ComponentModel.ISupportInitialize)(this.numELOBeta)).BeginInit();
			this.SuspendLayout();
			// 
			// btnOk
			// 
			this.btnOk.DialogResult = System.Windows.Forms.DialogResult.OK;
			this.btnOk.Location = new System.Drawing.Point(40, 472);
			this.btnOk.Name = "btnOk";
			this.btnOk.Size = new System.Drawing.Size(96, 32);
			this.btnOk.TabIndex = 0;
			this.btnOk.Text = "OK";
			// 
			// btnCancel
			// 
			this.btnCancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
			this.btnCancel.Location = new System.Drawing.Point(152, 472);
			this.btnCancel.Name = "btnCancel";
			this.btnCancel.Size = new System.Drawing.Size(96, 32);
			this.btnCancel.TabIndex = 1;
			this.btnCancel.Text = "Cancel";
			// 
			// label4
			// 
			this.label4.Font = new System.Drawing.Font("Microsoft Sans Serif", 18F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.label4.Location = new System.Drawing.Point(56, 8);
			this.label4.Name = "label4";
			this.label4.Size = new System.Drawing.Size(208, 64);
			this.label4.TabIndex = 8;
			this.label4.Text = "Ranking Parameters";
			this.label4.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
			// 
			// lblMuSigmaIterations
			// 
			this.lblMuSigmaIterations.Location = new System.Drawing.Point(16, 24);
			this.lblMuSigmaIterations.Name = "lblMuSigmaIterations";
			this.lblMuSigmaIterations.Size = new System.Drawing.Size(88, 24);
			this.lblMuSigmaIterations.TabIndex = 6;
			this.lblMuSigmaIterations.Text = "Iterations";
			this.lblMuSigmaIterations.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
			this.toolTip.SetToolTip(this.lblMuSigmaIterations, "The number of iterations used in the numerical approximation package.");
			// 
			// lblMuSigmaTau
			// 
			this.lblMuSigmaTau.Location = new System.Drawing.Point(16, 24);
			this.lblMuSigmaTau.Name = "lblMuSigmaTau";
			this.lblMuSigmaTau.Size = new System.Drawing.Size(88, 20);
			this.lblMuSigmaTau.TabIndex = 6;
			this.lblMuSigmaTau.Text = "Tau";
			this.lblMuSigmaTau.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
			this.toolTip.SetToolTip(this.lblMuSigmaTau, "The change in standard deviation of the skill belief from game to game. Larger values keep the skill belief " +
				"very dynamic but the method has little memory.");
			// 
			// lblMuSigmaBeta
			// 
			this.lblMuSigmaBeta.Location = new System.Drawing.Point(16, 24);
			this.lblMuSigmaBeta.Name = "lblMuSigmaBeta";
			this.lblMuSigmaBeta.Size = new System.Drawing.Size(88, 20);
			this.lblMuSigmaBeta.TabIndex = 2;
			this.lblMuSigmaBeta.Text = "Beta";
			this.lblMuSigmaBeta.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
			this.toolTip.SetToolTip(this.lblMuSigmaBeta, "The standard deviation of the performance of each player.");
			// 
			// lblMuSigmaDrawProbability
			// 
			this.lblMuSigmaDrawProbability.Location = new System.Drawing.Point(16, 56);
			this.lblMuSigmaDrawProbability.Name = "lblMuSigmaDrawProbability";
			this.lblMuSigmaDrawProbability.Size = new System.Drawing.Size(88, 20);
			this.lblMuSigmaDrawProbability.TabIndex = 11;
			this.lblMuSigmaDrawProbability.Text = "Draw Probability";
			this.lblMuSigmaDrawProbability.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
			this.toolTip.SetToolTip(this.lblMuSigmaDrawProbability, "The probability of a draw between two players with identical playing strength.");
			// 
			// lblMuSigmaEpsilon
			// 
			this.lblMuSigmaEpsilon.Location = new System.Drawing.Point(16, 24);
			this.lblMuSigmaEpsilon.Name = "lblMuSigmaEpsilon";
			this.lblMuSigmaEpsilon.Size = new System.Drawing.Size(88, 20);
			this.lblMuSigmaEpsilon.TabIndex = 4;
			this.lblMuSigmaEpsilon.Text = "Epsilon";
			this.lblMuSigmaEpsilon.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
			this.toolTip.SetToolTip(this.lblMuSigmaEpsilon, "The draw margin on the performance scale.");
			// 
			// lblELOAlpha
			// 
			this.lblELOAlpha.Location = new System.Drawing.Point(16, 24);
			this.lblELOAlpha.Name = "lblELOAlpha";
			this.lblELOAlpha.Size = new System.Drawing.Size(88, 20);
			this.lblELOAlpha.TabIndex = 6;
			this.lblELOAlpha.Text = "Alpha";
			this.lblELOAlpha.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
			this.toolTip.SetToolTip(this.lblELOAlpha, "One minus the discount factor of the game outcomes. Higher values will only consi" +
				"der the data of a short time window.");
			// 
			// lblELOBeta
			// 
			this.lblELOBeta.Location = new System.Drawing.Point(16, 24);
			this.lblELOBeta.Name = "lblELOBeta";
			this.lblELOBeta.Size = new System.Drawing.Size(88, 20);
			this.lblELOBeta.TabIndex = 2;
			this.lblELOBeta.Text = "Beta";
			this.lblELOBeta.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
			this.toolTip.SetToolTip(this.lblELOBeta, "The standard deviation of the performance of each player.");
			// 
			// cbAdvanced
			// 
			this.cbAdvanced.CheckAlign = System.Drawing.ContentAlignment.MiddleRight;
			this.cbAdvanced.Location = new System.Drawing.Point(200, 64);
			this.cbAdvanced.Name = "cbAdvanced";
			this.cbAdvanced.Size = new System.Drawing.Size(80, 24);
			this.cbAdvanced.TabIndex = 15;
			this.cbAdvanced.Text = "Advanced";
			this.cbAdvanced.CheckedChanged += new System.EventHandler(this.cbAdvanced_CheckedChanged);
			// 
			// tbcMain
			// 
			this.tbcMain.Controls.Add(this.tpMuSigma);
			this.tbcMain.Controls.Add(this.tpELO);
			this.tbcMain.Location = new System.Drawing.Point(16, 96);
			this.tbcMain.Name = "tbcMain";
			this.tbcMain.SelectedIndex = 0;
			this.tbcMain.Size = new System.Drawing.Size(264, 360);
			this.tbcMain.TabIndex = 16;
			// 
			// tpMuSigma
			// 
			this.tpMuSigma.Controls.Add(this.gbMuSigmaApproximation);
			this.tpMuSigma.Controls.Add(this.gbMuSigmaDynamics);
			this.tpMuSigma.Controls.Add(this.gbMuSigmaScoreScale);
			this.tpMuSigma.Controls.Add(this.gbMuSigmaDraw);
			this.tpMuSigma.Location = new System.Drawing.Point(4, 22);
			this.tpMuSigma.Name = "tpMuSigma";
			this.tpMuSigma.Size = new System.Drawing.Size(256, 334);
			this.tpMuSigma.TabIndex = 0;
			this.tpMuSigma.Text = "MuSigma";
			// 
			// gbMuSigmaApproximation
			// 
			this.gbMuSigmaApproximation.Controls.Add(this.cbMuSigmaAlgorithm);
			this.gbMuSigmaApproximation.Controls.Add(this.lblMuSigmaApproximationAlgorithm);
			this.gbMuSigmaApproximation.Controls.Add(this.numMuSigmaIterations);
			this.gbMuSigmaApproximation.Controls.Add(this.lblMuSigmaIterations);
			this.gbMuSigmaApproximation.Location = new System.Drawing.Point(16, 231);
			this.gbMuSigmaApproximation.Name = "gbMuSigmaApproximation";
			this.gbMuSigmaApproximation.Size = new System.Drawing.Size(232, 97);
			this.gbMuSigmaApproximation.TabIndex = 18;
			this.gbMuSigmaApproximation.TabStop = false;
			this.gbMuSigmaApproximation.Text = "Approximation Parameters";
			// 
			// numMuSigmaIterations
			// 
			this.numMuSigmaIterations.Increment = new System.Decimal(new int[] {
																				   10,
																				   0,
																				   0,
																				   0});
			this.numMuSigmaIterations.Location = new System.Drawing.Point(112, 24);
			this.numMuSigmaIterations.Maximum = new System.Decimal(new int[] {
																				 10000,
																				 0,
																				 0,
																				 0});
			this.numMuSigmaIterations.Minimum = new System.Decimal(new int[] {
																				 20,
																				 0,
																				 0,
																				 0});
			this.numMuSigmaIterations.Name = "numMuSigmaIterations";
			this.numMuSigmaIterations.Size = new System.Drawing.Size(112, 20);
			this.numMuSigmaIterations.TabIndex = 15;
			this.numMuSigmaIterations.Value = new System.Decimal(new int[] {
																			   20,
																			   0,
																			   0,
																			   0});
			// 
			// gbMuSigmaDynamics
			// 
			this.gbMuSigmaDynamics.Controls.Add(this.numMuSigmaTau);
			this.gbMuSigmaDynamics.Controls.Add(this.lblMuSigmaTau);
			this.gbMuSigmaDynamics.Location = new System.Drawing.Point(16, 167);
			this.gbMuSigmaDynamics.Name = "gbMuSigmaDynamics";
			this.gbMuSigmaDynamics.Size = new System.Drawing.Size(232, 56);
			this.gbMuSigmaDynamics.TabIndex = 17;
			this.gbMuSigmaDynamics.TabStop = false;
			this.gbMuSigmaDynamics.Text = "Dynamics Paramters";
			// 
			// numMuSigmaTau
			// 
			this.numMuSigmaTau.DecimalPlaces = 1;
			this.numMuSigmaTau.Increment = new System.Decimal(new int[] {
																			1,
																			0,
																			0,
																			65536});
			this.numMuSigmaTau.Location = new System.Drawing.Point(112, 24);
			this.numMuSigmaTau.Name = "numMuSigmaTau";
			this.numMuSigmaTau.Size = new System.Drawing.Size(112, 20);
			this.numMuSigmaTau.TabIndex = 14;
			this.numMuSigmaTau.Value = new System.Decimal(new int[] {
																		10,
																		0,
																		0,
																		0});
			// 
			// gbMuSigmaScoreScale
			// 
			this.gbMuSigmaScoreScale.Controls.Add(this.numMuSigmaBeta);
			this.gbMuSigmaScoreScale.Controls.Add(this.lblMuSigmaBeta);
			this.gbMuSigmaScoreScale.Location = new System.Drawing.Point(16, 7);
			this.gbMuSigmaScoreScale.Name = "gbMuSigmaScoreScale";
			this.gbMuSigmaScoreScale.Size = new System.Drawing.Size(232, 56);
			this.gbMuSigmaScoreScale.TabIndex = 15;
			this.gbMuSigmaScoreScale.TabStop = false;
			this.gbMuSigmaScoreScale.Text = "Performance Parameters";
			// 
			// numMuSigmaBeta
			// 
			this.numMuSigmaBeta.Location = new System.Drawing.Point(112, 24);
			this.numMuSigmaBeta.Maximum = new System.Decimal(new int[] {
																		   1000,
																		   0,
																		   0,
																		   0});
			this.numMuSigmaBeta.Minimum = new System.Decimal(new int[] {
																		   1,
																		   0,
																		   0,
																		   0});
			this.numMuSigmaBeta.Name = "numMuSigmaBeta";
			this.numMuSigmaBeta.Size = new System.Drawing.Size(112, 20);
			this.numMuSigmaBeta.TabIndex = 4;
			this.numMuSigmaBeta.Value = new System.Decimal(new int[] {
																		 250,
																		 0,
																		 0,
																		 0});
			this.numMuSigmaBeta.ValueChanged += new System.EventHandler(this.numMuSigmaBeta_ValueChanged);
			// 
			// gbMuSigmaDraw
			// 
			this.gbMuSigmaDraw.Controls.Add(this.numMuSigmaDrawProbability);
			this.gbMuSigmaDraw.Controls.Add(this.numMuSigmaEpsilon);
			this.gbMuSigmaDraw.Controls.Add(this.lblMuSigmaDrawProbability);
			this.gbMuSigmaDraw.Controls.Add(this.lblMuSigmaEpsilon);
			this.gbMuSigmaDraw.Location = new System.Drawing.Point(16, 71);
			this.gbMuSigmaDraw.Name = "gbMuSigmaDraw";
			this.gbMuSigmaDraw.Size = new System.Drawing.Size(232, 88);
			this.gbMuSigmaDraw.TabIndex = 16;
			this.gbMuSigmaDraw.TabStop = false;
			this.gbMuSigmaDraw.Text = "Draw Parameters";
			// 
			// numMuSigmaDrawProbability
			// 
			this.numMuSigmaDrawProbability.DecimalPlaces = 2;
			this.numMuSigmaDrawProbability.Increment = new System.Decimal(new int[] {
																						1,
																						0,
																						0,
																						131072});
			this.numMuSigmaDrawProbability.Location = new System.Drawing.Point(112, 56);
			this.numMuSigmaDrawProbability.Maximum = new System.Decimal(new int[] {
																					  99,
																					  0,
																					  0,
																					  131072});
			this.numMuSigmaDrawProbability.Minimum = new System.Decimal(new int[] {
																					  1,
																					  0,
																					  0,
																					  131072});
			this.numMuSigmaDrawProbability.Name = "numMuSigmaDrawProbability";
			this.numMuSigmaDrawProbability.Size = new System.Drawing.Size(112, 20);
			this.numMuSigmaDrawProbability.TabIndex = 13;
			this.numMuSigmaDrawProbability.Value = new System.Decimal(new int[] {
																					5,
																					0,
																					0,
																					65536});
			this.numMuSigmaDrawProbability.ValueChanged += new System.EventHandler(this.numMuSigmaDrawProbability_ValueChanged);
			// 
			// numMuSigmaEpsilon
			// 
			this.numMuSigmaEpsilon.Location = new System.Drawing.Point(112, 24);
			this.numMuSigmaEpsilon.Maximum = new System.Decimal(new int[] {
																			  1000,
																			  0,
																			  0,
																			  0});
			this.numMuSigmaEpsilon.Minimum = new System.Decimal(new int[] {
																			  1,
																			  0,
																			  0,
																			  0});
			this.numMuSigmaEpsilon.Name = "numMuSigmaEpsilon";
			this.numMuSigmaEpsilon.Size = new System.Drawing.Size(112, 20);
			this.numMuSigmaEpsilon.TabIndex = 12;
			this.numMuSigmaEpsilon.Value = new System.Decimal(new int[] {
																			50,
																			0,
																			0,
																			0});
			this.numMuSigmaEpsilon.ValueChanged += new System.EventHandler(this.numMuSigmaEpsilon_ValueChanged);
			// 
			// tpELO
			// 
			this.tpELO.Controls.Add(this.dbELODynamics);
			this.tpELO.Controls.Add(this.gbELOScoreScale);
			this.tpELO.Location = new System.Drawing.Point(4, 22);
			this.tpELO.Name = "tpELO";
			this.tpELO.Size = new System.Drawing.Size(256, 294);
			this.tpELO.TabIndex = 1;
			this.tpELO.Text = "ELO";
			// 
			// dbELODynamics
			// 
			this.dbELODynamics.Controls.Add(this.numELOAlpha);
			this.dbELODynamics.Controls.Add(this.lblELOAlpha);
			this.dbELODynamics.Location = new System.Drawing.Point(16, 72);
			this.dbELODynamics.Name = "dbELODynamics";
			this.dbELODynamics.Size = new System.Drawing.Size(232, 56);
			this.dbELODynamics.TabIndex = 20;
			this.dbELODynamics.TabStop = false;
			this.dbELODynamics.Text = "Dynamics Paramters";
			// 
			// numELOAlpha
			// 
			this.numELOAlpha.DecimalPlaces = 2;
			this.numELOAlpha.Increment = new System.Decimal(new int[] {
																		  1,
																		  0,
																		  0,
																		  131072});
			this.numELOAlpha.Location = new System.Drawing.Point(112, 24);
			this.numELOAlpha.Maximum = new System.Decimal(new int[] {
																		99,
																		0,
																		0,
																		131072});
			this.numELOAlpha.Minimum = new System.Decimal(new int[] {
																		1,
																		0,
																		0,
																		131072});
			this.numELOAlpha.Name = "numELOAlpha";
			this.numELOAlpha.Size = new System.Drawing.Size(112, 20);
			this.numELOAlpha.TabIndex = 14;
			this.numELOAlpha.Value = new System.Decimal(new int[] {
																	  5,
																	  0,
																	  0,
																	  65536});
			// 
			// gbELOScoreScale
			// 
			this.gbELOScoreScale.Controls.Add(this.numELOBeta);
			this.gbELOScoreScale.Controls.Add(this.lblELOBeta);
			this.gbELOScoreScale.Location = new System.Drawing.Point(16, 8);
			this.gbELOScoreScale.Name = "gbELOScoreScale";
			this.gbELOScoreScale.Size = new System.Drawing.Size(232, 56);
			this.gbELOScoreScale.TabIndex = 18;
			this.gbELOScoreScale.TabStop = false;
			this.gbELOScoreScale.Text = "Performance Parameters";
			// 
			// numELOBeta
			// 
			this.numELOBeta.Location = new System.Drawing.Point(112, 24);
			this.numELOBeta.Maximum = new System.Decimal(new int[] {
																	   1000,
																	   0,
																	   0,
																	   0});
			this.numELOBeta.Minimum = new System.Decimal(new int[] {
																	   1,
																	   0,
																	   0,
																	   0});
			this.numELOBeta.Name = "numELOBeta";
			this.numELOBeta.Size = new System.Drawing.Size(112, 20);
			this.numELOBeta.TabIndex = 5;
			this.numELOBeta.Value = new System.Decimal(new int[] {
																	 250,
																	 0,
																	 0,
																	 0});
			// 
			// lblMuSigmaApproximationAlgorithm
			// 
			this.lblMuSigmaApproximationAlgorithm.Location = new System.Drawing.Point(16, 56);
			this.lblMuSigmaApproximationAlgorithm.Name = "lblMuSigmaApproximationAlgorithm";
			this.lblMuSigmaApproximationAlgorithm.Size = new System.Drawing.Size(88, 24);
			this.lblMuSigmaApproximationAlgorithm.TabIndex = 16;
			this.lblMuSigmaApproximationAlgorithm.Text = "Algorithm";
			this.lblMuSigmaApproximationAlgorithm.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
			this.toolTip.SetToolTip(this.lblMuSigmaApproximationAlgorithm, "The number of iterations used in the numerical approximation package.");
			// 
			// cbMuSigmaAlgorithm
			// 
			this.cbMuSigmaAlgorithm.Items.AddRange(new object[] {
																	"EP Algorithm",
																	"Genz Algorithm"});
			this.cbMuSigmaAlgorithm.Location = new System.Drawing.Point(112, 56);
			this.cbMuSigmaAlgorithm.Name = "cbMuSigmaAlgorithm";
			this.cbMuSigmaAlgorithm.Size = new System.Drawing.Size(112, 21);
			this.cbMuSigmaAlgorithm.TabIndex = 17;
			this.cbMuSigmaAlgorithm.Text = "EP Algorithm";
			// 
			// RankingParameters
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(290, 520);
			this.Controls.Add(this.tbcMain);
			this.Controls.Add(this.cbAdvanced);
			this.Controls.Add(this.label4);
			this.Controls.Add(this.btnCancel);
			this.Controls.Add(this.btnOk);
			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
			this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
			this.MaximizeBox = false;
			this.MinimizeBox = false;
			this.Name = "RankingParameters";
			this.ShowInTaskbar = false;
			this.Text = "MuSigma Ranking Parameters";
			this.tbcMain.ResumeLayout(false);
			this.tpMuSigma.ResumeLayout(false);
			this.gbMuSigmaApproximation.ResumeLayout(false);
			((System.ComponentModel.ISupportInitialize)(this.numMuSigmaIterations)).EndInit();
			this.gbMuSigmaDynamics.ResumeLayout(false);
			((System.ComponentModel.ISupportInitialize)(this.numMuSigmaTau)).EndInit();
			this.gbMuSigmaScoreScale.ResumeLayout(false);
			((System.ComponentModel.ISupportInitialize)(this.numMuSigmaBeta)).EndInit();
			this.gbMuSigmaDraw.ResumeLayout(false);
			((System.ComponentModel.ISupportInitialize)(this.numMuSigmaDrawProbability)).EndInit();
			((System.ComponentModel.ISupportInitialize)(this.numMuSigmaEpsilon)).EndInit();
			this.tpELO.ResumeLayout(false);
			this.dbELODynamics.ResumeLayout(false);
			((System.ComponentModel.ISupportInitialize)(this.numELOAlpha)).EndInit();
			this.gbELOScoreScale.ResumeLayout(false);
			((System.ComponentModel.ISupportInitialize)(this.numELOBeta)).EndInit();
			this.ResumeLayout(false);

		}
		#endregion

		#region Event Handler
		/// <summary>
		/// Updates the 'Draw Probability' field in the MuSigma tab.
		/// </summary>
		private void UpdateMuSigmaDrawProbability ()
		{
			try 
			{
				double dEpsilon = Convert.ToDouble (numMuSigmaEpsilon.Value);
				double dBeta = Convert.ToDouble (numMuSigmaBeta.Value);
				double dProbability = 1.0 - 2.0 * GaussianApproximations.Phi (-dEpsilon / (Math.Sqrt (2.0) * dBeta));
				numMuSigmaDrawProbability.Value = Convert.ToDecimal (dProbability);
			}
			catch 
			{
				numMuSigmaDrawProbability.Value = Convert.ToDecimal (0.5);
			}
		}

		/// <summary>
		/// Handles a change in the Epsilon field in the MuSigma tab.
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		private void numMuSigmaEpsilon_ValueChanged(object sender, System.EventArgs e)
		{
			if (numMuSigmaEpsilon.Focused)
				UpdateMuSigmaDrawProbability ();		
		}

		/// <summary>
		/// Handles a change in the Beta parameter field in the MuSigma tab. 
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		private void numMuSigmaBeta_ValueChanged(object sender, System.EventArgs e)
		{
			if (numMuSigmaBeta.Focused)
				UpdateMuSigmaDrawProbability ();
		}
		/// <summary>
		/// Handles an input into the 'Draw Probability' box in the MuSigma tab.
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		private void numMuSigmaDrawProbability_ValueChanged(object sender, System.EventArgs e)
		{
			if (numMuSigmaDrawProbability.Focused) 
			{
				try 
				{
					double dProbability = Convert.ToDouble (numMuSigmaDrawProbability.Value);
					double dBeta = Convert.ToDouble (numMuSigmaBeta.Value);
					double dEpsilon = -Math.Sqrt (2) * dBeta * GaussianApproximations.PhiInverse ((1.0 - dProbability) / 2.0);
					numMuSigmaEpsilon.Value = Convert.ToDecimal (dEpsilon);
				}
				catch 
				{
					numMuSigmaEpsilon.Value = 10;
				}		
			}		
		}

		/// <summary>
		/// Handles a click on the "Advanced button".
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		private void cbAdvanced_CheckedChanged(object sender, System.EventArgs e)
		{		
			if (cbAdvanced.Checked) 
			{
				gbMuSigmaScoreScale.Visible = true;
				gbMuSigmaDynamics.Visible = true;
				gbMuSigmaApproximation.Visible = true;
				gbELOScoreScale.Visible = true;

				lblMuSigmaEpsilon.Visible = true;
				numMuSigmaEpsilon.Visible = true;
			}
			else 
			{
				gbMuSigmaScoreScale.Visible = false;
				gbMuSigmaDynamics.Visible = false;
				gbMuSigmaApproximation.Visible = false;
				gbELOScoreScale.Visible = false;

				lblMuSigmaEpsilon.Visible = false;
				numMuSigmaEpsilon.Visible = false;
			}
		}
		#endregion

		#region Properties
		/// <summary>
		/// The standard deviation of the performance in the MuSigma system.
		/// </summary>
		public double MuSigmaBeta
		{
			get 
			{
				return Convert.ToDouble (numMuSigmaBeta.Value);
			}
			set 
			{
				if (value < 0)
					throw new Exception ("Beta must be positive.");
				numMuSigmaBeta.Value = Convert.ToDecimal (value);
				UpdateMuSigmaDrawProbability ();
			}
		}

		/// <summary>
		/// The standard deviation of the performance in the ELO system.
		/// </summary>
		public double ELOBeta
		{
			get 
			{
				return Convert.ToDouble (numELOBeta.Value);
			}
			set 
			{
				if (value < 0)
					throw new Exception ("Beta must be positive.");
				numELOBeta.Value = Convert.ToDecimal (value);
			}
		}

		/// <summary>
		/// The draw margin in the MuSigma system.
		/// </summary>
		public double MuSigmaEpsilon
		{
			get 
			{
				return Convert.ToDouble (numMuSigmaEpsilon.Value);
			}
			set 
			{
				if (value < 0)
					throw new Exception ("Epsilon must be positive.");
				numMuSigmaEpsilon.Value = Convert.ToDecimal (value);
				UpdateMuSigmaDrawProbability ();
			}
		}
		
		/// <summary>
		/// The increase in standard deviation of skill belief (dynamics prior) in the MuSigma system.
		/// </summary>
		public double MuSigmaTau
		{
			get 
			{
				return Convert.ToDouble (numMuSigmaTau.Value);
			}
			set 
			{
				if (value < 0.0)
					throw new Exception ("Tau must be positive.");
				numMuSigmaTau.Value = Convert.ToDecimal (value);
			}
		}

		/// <summary>
		/// One minus the discount factor in the game outcome (dynamics) in the ELO system.
		/// </summary>
		public double ELOAlpha
		{
			get 
			{
				return Convert.ToDouble (numELOAlpha.Value);
			}
			set 
			{
				if (value < 0.0 || value > 1.0)
					throw new Exception ("Alpha must be between 0 and 1.");
				numELOAlpha.Value = Convert.ToDecimal (value);
			}
		}

		/// <summary>
		/// Number of iterations of the numerical approximation algorithm in the MuSigma system.
		/// </summary>
		public int MuSigmaIterations 
		{
			get 
			{
				return Convert.ToInt32 (numMuSigmaIterations.Value);
			}
			set 
			{
				if (value < 20)
					throw new Exception ("Number of iterations must be at least 20.");
				numMuSigmaIterations.Value = Convert.ToDecimal (value);
			}
		}

		/// <summary>
		/// Approximation algorithm used in the MuSigma system.
		/// </summary>
		public Algorithm MuSigmaApproximationAlgorithm
		{
			get 
			{
				switch (cbMuSigmaAlgorithm.SelectedIndex) 
				{
					case 0: 
						return Algorithm.EPAlgorithm; 
					case 1: 
						return Algorithm.GenzAlgorithm; 
					default: 
						Debug.Assert (false, "Algorithm list is too long."); 
						// we should not get here
						return Algorithm.EPAlgorithm;
				}
			}
			set 
			{
				switch (value)
				{
					case Algorithm.EPAlgorithm: 
						cbMuSigmaAlgorithm.SelectedIndex = 0; 
						break;
					case Algorithm.GenzAlgorithm: 
						cbMuSigmaAlgorithm.SelectedIndex = 1; 
						break;
					default: 
						Debug.Assert (false, "Invalid algorithm.");
						break;
				}
			}
		}

		/// <summary>
		/// Indicator whether or not the dialog is in advanced mode.
		/// </summary>
		public bool AdvancedMode
		{
			get 
			{
				return cbAdvanced.Checked;
			}
			set 
			{
				cbAdvanced.Checked = value;
			}
		}
		#endregion

		#region Show Dialog code
		/// <summary>
		/// Shows the dialog form and executes the modal dialog.
		/// </summary>
		/// <param name="bAllowCancel">Determines if the 'Cancel' button should be enabled.</param>
		/// <returns>The dialog result.</returns>
		public DialogResult ShowDialog (bool bAllowCancel)
		{
			if (bAllowCancel)
			{
				this.btnCancel.Enabled = true;
				return base.ShowDialog ();
			}
			else 
			{
				this.btnCancel.Enabled = false;
				return base.ShowDialog ();
			}
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MuSigma\MuSigma\PlotWindow.cs ===
/////////////////////////////////////////////////////////////////////////////////////////////
// PlotWindow.cs		Dialog window that shows a simple plot.
//
// 2004 written by Ralf Herbrich
// Microsoft Research Ltd.
/////////////////////////////////////////////////////////////////////////////////////////////

using System;
using System.Text;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.IO;
using Microsoft.Office.Interop.Owc11;

namespace MuSigma
{
	/// <summary>
	/// A class that represents a window for plotting several one-dimensional functions. The class supports up to 256 different
	/// functions at any one time. Functions will be re-sampled before drawn to improve speed. The window also has a menu to configure 
	/// the plot once it is drawn on screen. This class makes heavy use of the Office 11 Chart COM ActiveX component.
	/// </summary>
	public class PlotWindow : System.Windows.Forms.Form
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;			

		#region Data declaration
		/// <summary>
		/// A variable-sized array of literal strings for the index data of each function.
		/// </summary>
		private ArrayList m_szIndex;
		/// <summary>
		/// A variable-sized array of literal strings for the X data of each function.
		/// </summary>
		private ArrayList m_szDataX;
		/// <summary>
		/// A variable-sized array of literal strings for the Y data of each function.
		/// </summary>
		private ArrayList m_szDataY;
		/// <summary>
		/// A variable-sized array of literal strings for the error bar data of each function.
		/// </summary>
		private ArrayList m_szErrorBar;
		/// <summary>
		/// A variable-sized array of literal strings for the names of each function.
		/// </summary>
		private ArrayList m_szDataNames;
		/// <summary>
		/// A string for the .
		/// </summary>

		private AxMicrosoft.Office.Interop.Owc11.AxChartSpace axChartSpace;
		private System.Windows.Forms.MainMenu mainMenu1;
		private System.Windows.Forms.MenuItem menuItem1;
		private System.Windows.Forms.MenuItem menuItem2;
		private System.Windows.Forms.MenuItem rbData;
		private System.Windows.Forms.MenuItem rbIndex;
		private System.Windows.Forms.MenuItem cbLegend;
		private System.Windows.Forms.MenuItem cbYAxis;
		private System.Windows.Forms.MenuItem menuItem4;
		private System.Windows.Forms.MenuItem menuItem5;
		private System.Windows.Forms.MenuItem menuItem3;
		private System.Windows.Forms.MenuItem menuCloseWindow;
		private System.Windows.Forms.MenuItem menuSaveFigure;
		private System.Windows.Forms.SaveFileDialog dlgSavePicture;
		private System.Windows.Forms.MenuItem menuItem7;
		private System.Windows.Forms.MenuItem menuSaveRawData;
		private System.Windows.Forms.SaveFileDialog dlgSaveRawData;		// the names of the data series
		private ChChart   m_aChart;
		#endregion 

		#region Constructor and Destructor
		/// <summary>
		/// Constructs a new instance of a plot window. This will make the window visible.
		/// </summary>
		public PlotWindow()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			// initialises the data arrays			
			m_aChart = this.axChartSpace.Charts.Add (0);
			m_szIndex = new ArrayList ();
			m_szDataX = new ArrayList ();
			m_szDataY = new ArrayList ();
			m_szErrorBar = new ArrayList ();
			m_szDataNames = new ArrayList ();

			// initialise tbe "Save Picture Dialog"
			dlgSavePicture.Filter = "PNG Files (*.png)|*.png|GIF Files (*.gif)|*.gif|JPEG Files (*.jpg)|*.jpg";
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}
		#endregion

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(PlotWindow));
			this.axChartSpace = new AxMicrosoft.Office.Interop.Owc11.AxChartSpace();
			this.mainMenu1 = new System.Windows.Forms.MainMenu();
			this.menuItem3 = new System.Windows.Forms.MenuItem();
			this.menuSaveFigure = new System.Windows.Forms.MenuItem();
			this.menuItem7 = new System.Windows.Forms.MenuItem();
			this.menuCloseWindow = new System.Windows.Forms.MenuItem();
			this.menuItem1 = new System.Windows.Forms.MenuItem();
			this.menuItem2 = new System.Windows.Forms.MenuItem();
			this.rbData = new System.Windows.Forms.MenuItem();
			this.rbIndex = new System.Windows.Forms.MenuItem();
			this.menuItem4 = new System.Windows.Forms.MenuItem();
			this.cbYAxis = new System.Windows.Forms.MenuItem();
			this.menuItem5 = new System.Windows.Forms.MenuItem();
			this.cbLegend = new System.Windows.Forms.MenuItem();
			this.dlgSavePicture = new System.Windows.Forms.SaveFileDialog();
			this.menuSaveRawData = new System.Windows.Forms.MenuItem();
			this.dlgSaveRawData = new System.Windows.Forms.SaveFileDialog();
			((System.ComponentModel.ISupportInitialize)(this.axChartSpace)).BeginInit();
			this.SuspendLayout();
			// 
			// axChartSpace
			// 
			this.axChartSpace.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
				| System.Windows.Forms.AnchorStyles.Left) 
				| System.Windows.Forms.AnchorStyles.Right)));
			this.axChartSpace.DataSource = null;
			this.axChartSpace.Enabled = true;
			this.axChartSpace.Location = new System.Drawing.Point(8, 8);
			this.axChartSpace.Name = "axChartSpace";
			this.axChartSpace.OcxState = ((System.Windows.Forms.AxHost.State)(resources.GetObject("axChartSpace.OcxState")));
			this.axChartSpace.Size = new System.Drawing.Size(776, 504);
			this.axChartSpace.TabIndex = 0;
			// 
			// mainMenu1
			// 
			this.mainMenu1.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
																					  this.menuItem3,
																					  this.menuItem1});
			// 
			// menuItem3
			// 
			this.menuItem3.Index = 0;
			this.menuItem3.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
																					  this.menuSaveFigure,
																					  this.menuSaveRawData,
																					  this.menuItem7,
																					  this.menuCloseWindow});
			this.menuItem3.Text = "&File";
			// 
			// menuSaveFigure
			// 
			this.menuSaveFigure.Index = 0;
			this.menuSaveFigure.Text = "&Save Figure ...";
			this.menuSaveFigure.Click += new System.EventHandler(this.menuSaveFigure_Click);
			// 
			// menuItem7
			// 
			this.menuItem7.Index = 2;
			this.menuItem7.Text = "-";
			// 
			// menuCloseWindow
			// 
			this.menuCloseWindow.Index = 3;
			this.menuCloseWindow.Text = "&Close Window";
			this.menuCloseWindow.Click += new System.EventHandler(this.menuCloseWindow_Click);
			// 
			// menuItem1
			// 
			this.menuItem1.Index = 1;
			this.menuItem1.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
																					  this.menuItem2,
																					  this.menuItem4,
																					  this.cbYAxis,
																					  this.menuItem5,
																					  this.cbLegend});
			this.menuItem1.Text = "&View";
			// 
			// menuItem2
			// 
			this.menuItem2.Index = 0;
			this.menuItem2.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
																					  this.rbData,
																					  this.rbIndex});
			this.menuItem2.Text = "&X Axis";
			// 
			// rbData
			// 
			this.rbData.Checked = true;
			this.rbData.Index = 0;
			this.rbData.RadioCheck = true;
			this.rbData.Text = "X";
			this.rbData.Click += new System.EventHandler(this.rbXAxis_CheckedChanged);
			// 
			// rbIndex
			// 
			this.rbIndex.Index = 1;
			this.rbIndex.RadioCheck = true;
			this.rbIndex.Text = "Index";
			this.rbIndex.Click += new System.EventHandler(this.rbXAxis_CheckedChanged);
			// 
			// menuItem4
			// 
			this.menuItem4.Index = 1;
			this.menuItem4.Text = "-";
			// 
			// cbYAxis
			// 
			this.cbYAxis.Checked = true;
			this.cbYAxis.Index = 2;
			this.cbYAxis.Text = "Y";
			this.cbYAxis.Click += new System.EventHandler(this.cbYAxis_Click);
			// 
			// menuItem5
			// 
			this.menuItem5.Index = 3;
			this.menuItem5.Text = "-";
			// 
			// cbLegend
			// 
			this.cbLegend.Checked = true;
			this.cbLegend.Index = 4;
			this.cbLegend.Text = "&Legend";
			this.cbLegend.Click += new System.EventHandler(this.cbLegend_Click);
			// 
			// dlgSavePicture
			// 
			this.dlgSavePicture.DefaultExt = "png";
			// 
			// menuSaveRawData
			// 
			this.menuSaveRawData.Index = 1;
			this.menuSaveRawData.Text = "Save Raw Data ...";
			this.menuSaveRawData.Click += new System.EventHandler(this.menuSaveRawData_Click);
			// 
			// dlgSaveRawData
			// 
			this.dlgSaveRawData.DefaultExt = "csv";
			// 
			// PlotWindow
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(792, 518);
			this.Controls.Add(this.axChartSpace);
			this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
			this.Menu = this.mainMenu1;
			this.MinimizeBox = false;
			this.Name = "PlotWindow";
			this.ShowInTaskbar = false;
			this.Text = "PlayerProgression";
			((System.ComponentModel.ISupportInitialize)(this.axChartSpace)).EndInit();
			this.ResumeLayout(false);

		}
		#endregion

		#region Data Input/Output code
		/// <summary>
		/// Adds one data series to the plot window.
		/// </summary>
		/// <param name="dDataX">The <c>x</c> values as a double array.</param>
		/// <param name="dDataY">The <c>y</c> values as a double array.</param>
		/// <param name="dErrorBar">The <c>errorBar</c> values as a double array.</param>
		/// <param name="szName">The name of the data series.</param>
		/// <returns>True, if the data was subsampled.</returns>
		/// <remarks>If the <c>dErrorBar</c> parameter is <c>null</c> then no error bars are added.</remarks>
		public bool AddData (double [] dDataX, double [] dDataY, double [] dErrorBar, string szName)
		{
			// check that the right sized arrays are passed
			if (dDataX.Length != dDataY.Length)
				throw new Exception ("dDataX and dDataY should be of equal length.");

			// add the name of the data series
			m_szDataNames.Add (szName);

			// possibly subsample the data
			const int iMaxLength = 2000;
			bool bSubsampled = (dDataX.Length > iMaxLength);

			// construct the series strings
			StringBuilder szX = new StringBuilder (iMaxLength * 10);
			StringBuilder szY = new StringBuilder (iMaxLength * 10);
			StringBuilder szErrorBar = new StringBuilder (iMaxLength * 10);
			StringBuilder szIndex = new StringBuilder (iMaxLength * 10);

			// build the strings
			int iIndex;
			int iLength = (bSubsampled)?iMaxLength:dDataX.Length;
			for (int i = 0; i < iLength; i++) 
			{
				if (bSubsampled)
					iIndex = (i * dDataX.Length) / iMaxLength;
				else
					iIndex = i;
				szX.AppendFormat ("{0,9},", dDataX [iIndex]);
				szY.AppendFormat ("{0,9},", dDataY [iIndex]);
				if (dErrorBar != null)
					szErrorBar.AppendFormat ("{0,9}\t", dErrorBar [iIndex]);
				szIndex.AppendFormat ("{0,9},", iIndex);
			}

			// add the strings to the series
			m_szDataX.Add (szX.ToString ());
			m_szDataY.Add (szY.ToString ());
			m_szErrorBar.Add ((dErrorBar == null)?null:szErrorBar.ToString ());
			m_szIndex.Add (szIndex.ToString ());

			// return whether or not the series was subsampled
			return bSubsampled;
		}

		/// <summary>
		/// Adds one data series to the plot window.
		/// </summary>
		/// <param name="dDataX">The <c>x</c> values as a double array.</param>
		/// <param name="dDataY">The <c>y</c> values as a double array.</param>
		/// <param name="szName">The name of the data series.</param>
		/// <returns>True, if the data was subsampled.</returns>
		public bool AddData (double [] dDataX, double [] dDataY, string szName)
		{
			return AddData (dDataX, dDataY, null, szName);
		}

		/// <summary>
		/// Adds one data series.
		/// </summary>
		/// <param name="dDataX">The <c>x</c> values as a double array.</param>
		/// <param name="dDataY">The <c>y</c> values as a double array.</param>
		/// <returns>True, if the data was subsampled.</returns>
		/// <remarks>The series will be assigned a standard name 'Series <c>n</c>' where <c>n</c> is the internal 
		/// zero-based index of the series.</remarks>
		public bool AddData (double [] dDataX, double [] dDataY)
		{
			return AddData (dDataX, dDataY, "Series " + m_szDataNames.Count.ToString ());
		}

		/// <summary>
		/// Clears all data series.
		/// </summary>
		public void Clear ()
		{
			m_szIndex.Clear ();
			m_szDataX.Clear ();
			m_szDataY.Clear ();
			m_szErrorBar.Clear ();
			m_szDataNames.Clear ();
		}
		#endregion

		#region Properties
		/// <summary>
		/// Title of the x-axis.
		/// </summary>
		public string XAxisTitle 
		{
			get 
			{
				return rbData.Text;
			}
			set 
			{
				rbData.Text = value;
			}
		}

		/// <summary>
		/// Alternative title of the x-axis.
		/// </summary>
		public string AlternativeXAxisTitle 
		{
			get 
			{
				return rbIndex.Text;
			}
			set 
			{
				rbIndex.Text = value;
			}
		}

		/// <summary>
		/// Title of the y-axis.
		/// </summary>
		public string YAxisTitle 
		{
			get 
			{
				return cbYAxis.Text;
			}
			set 
			{
				cbYAxis.Text = value;
			}
		}

		/// <summary>
		/// Plot has a legend?
		/// </summary>
		public bool Legend
		{
			get 
			{
				return cbLegend.Checked;
			}
			set 
			{
				cbLegend.Checked = value;
			}
		}

		/// <summary>
		/// Plot has a Y axis title?
		/// </summary>
		public bool YAxis
		{
			get 
			{
				return cbYAxis.Checked;
			}
			set 
			{
				cbYAxis.Checked = value;
			}
		}

		/// <summary>
		/// The chart space on which is drawn.
		/// </summary>
		public AxMicrosoft.Office.Interop.Owc11.AxChartSpace ChartSpace
		{
			get 
			{
				return this.axChartSpace;
			}
		}
		#endregion

		#region Modifier code
		/// <summary>
		/// Sets the data axis as the active x-axis.
		/// </summary>
		public void SetXAxis ()
		{
			rbData.Checked = true;
			rbIndex.Checked = false;
			return;
		}

		/// <summary>
		/// Sets the index axis as the active x-axis.
		/// </summary>
		public void SetAlternativeXAxis ()
		{
			rbIndex.Checked = true;
			rbData.Checked = false;
			return;
		}
		#endregion

		#region Update code
		/// <summary>
		/// Updates the chart on the plot. No series will be displayed until this method is called.
		/// </summary>
		public void UpdateChart ()
		{
			// delete the current chart
			this.axChartSpace.Charts.Delete (0);

			m_aChart = this.axChartSpace.Charts.Add (0);
			for (int i = 0; i < m_szDataX.Count; i++) 
			{
				try 
				{
					// add the series to the chart space
					ChSeries aSeries = m_aChart.SeriesCollection.Add (i);
					aSeries.Type = ChartChartTypeEnum.chChartTypeScatterLine;
					aSeries.SetData (ChartDimensionsEnum.chDimSeriesNames, (int) ChartSpecialDataSourcesEnum.chDataLiteral, m_szDataNames [i]);
					if (rbData.Checked)
						aSeries.SetData (ChartDimensionsEnum.chDimXValues, (int) ChartSpecialDataSourcesEnum.chDataLiteral, m_szDataX [i]);
					if (rbIndex.Checked)
						aSeries.SetData (ChartDimensionsEnum.chDimXValues, (int) ChartSpecialDataSourcesEnum.chDataLiteral, m_szIndex [i]);
					aSeries.SetData (ChartDimensionsEnum.chDimYValues, (int) ChartSpecialDataSourcesEnum.chDataLiteral, m_szDataY [i]);

					// add error bars
					if (m_szErrorBar [i] != null) 
					{
						ChErrorBars aErrorBars = aSeries.ErrorBarsCollection.Add ();
						aErrorBars.SetData (ChartErrorBarCustomValuesEnum.chErrorBarMinusValues, (int) ChartSpecialDataSourcesEnum.chDataLiteral, m_szErrorBar [i]);
						aErrorBars.SetData (ChartErrorBarCustomValuesEnum.chErrorBarPlusValues, (int) ChartSpecialDataSourcesEnum.chDataLiteral, m_szErrorBar [i]);
					}
				}
				catch 
				{
					MessageBox.Show ("Too many series to plot. Please reduce the number.");
					i = m_szDataX.Count;
				}
			}

			// "nicify" the plot
			if (cbLegend.Checked) 
			{
				m_aChart.HasLegend = true;
				m_aChart.Legend.Position = ChartLegendPositionEnum.chLegendPositionRight;
			}
			if (rbData.Checked) 
			{
				m_aChart.Axes [1].HasTitle = true;
				m_aChart.Axes [1].Title.Caption = rbData.Text;
			}
			if (rbIndex.Checked)
			{
				m_aChart.Axes [1].HasTitle = true;
				m_aChart.Axes [1].Title.Caption = rbIndex.Text;
			}
			if (cbYAxis.Checked) 
			{
				m_aChart.Axes [0].HasTitle = true;
				m_aChart.Axes [0].Title.Caption = cbYAxis.Text;
			}
		}
		#endregion

		#region Event handler code
		/// <summary>
		/// Handles a click on the two x-axis titles menu entries. Changes the value of the active x title and 
		/// redraws the plot.
		/// </summary>
		/// <param name="sender">Sender of the message.</param>
		/// <param name="e">Event arguments from the event handler.</param>
		private void rbXAxis_CheckedChanged (object sender, System.EventArgs e)
		{
			// check if anything needs to change; if not then just leave
			if (((MenuItem) sender).Checked) return;

			// clear all check boxes
			rbData.Checked = false;
			rbIndex.Checked = false;

			// check the relevant box again
			((MenuItem) sender).Checked = true;

			// update the chart
			UpdateChart ();
		}

		/// <summary>
		/// Handles a click on the "Legend" menu entry. This method redraws the plot.
		/// </summary>
		/// <param name="sender">Sender of the message.</param>
		/// <param name="e">Event arguments from the event handler.</param>
		private void cbLegend_Click (object sender, System.EventArgs e)
		{
			cbLegend.Checked = !cbLegend.Checked;
			UpdateChart ();
		}


		/// <summary>
		/// Handles a click on the "Y Axis" menu entry. This method redraws the plot.
		/// </summary>
		/// <param name="sender">Sender of the message.</param>
		/// <param name="e">Event arguments from the event handler.</param>
		private void cbYAxis_Click (object sender, System.EventArgs e)
		{
			cbYAxis.Checked = !cbYAxis.Checked;
			UpdateChart ();
		}

		/// <summary>
		/// Handles a click on the "Close Windows" menu entry.
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		private void menuCloseWindow_Click (object sender, System.EventArgs e)
		{
			this.Close ();
		}

		/// <summary>
		/// Handles a click on the "Save Figure ..." menu entry.
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		private void menuSaveFigure_Click (object sender, System.EventArgs e)
		{
			// suggested file name
			dlgSavePicture.FileName = this.Text;

			// save the image
			if (dlgSavePicture.ShowDialog () == DialogResult.OK) 
			{
				switch (dlgSavePicture.FilterIndex) 
				{
					case 1: 
						axChartSpace.ExportPicture (dlgSavePicture.FileName, "png", axChartSpace.Width, axChartSpace.Height);
						break;
					case 2: 
						axChartSpace.ExportPicture (dlgSavePicture.FileName, "gif", axChartSpace.Width, axChartSpace.Height);
						MessageBox.Show ("GIF file. " + dlgSavePicture.FileName);
						break;
					case 3: 
						axChartSpace.ExportPicture (dlgSavePicture.FileName, "jpg", axChartSpace.Width, axChartSpace.Height);
						MessageBox.Show ("JPEG file. " + dlgSavePicture.FileName);
						break;
				}
			}
		}
		#endregion

		/// <summary>
		/// Handles a click on the "Save Raw Data ..." menu entry.
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		private void menuSaveRawData_Click (object sender, System.EventArgs e)
		{
			// suggested file name
			dlgSaveRawData.FileName = this.Text;

			// save the image
			if (dlgSaveRawData.ShowDialog () == DialogResult.OK) 
			{
				// create the header
				for (int i = 0; i < m_szDataX.Count; i++) 
				{
					// open the CSV stream
					string szFileNameBase = dlgSaveRawData.FileName.Substring (0, dlgSaveRawData.FileName.LastIndexOf ("."));
					string szFileNameExt = dlgSaveRawData.FileName.Substring (dlgSaveRawData.FileName.LastIndexOf ("."));
					StreamWriter aCSVOutput = new StreamWriter (szFileNameBase + "-" + m_szDataNames [i] + szFileNameExt);

					// get the data 
					string [] szX = ((string) m_szDataX [i]).Split (',');
					string [] szY = ((string) m_szDataY [i]).Split (',');
					string [] szErrorBar = null;

					// write the header
					if (m_szErrorBar [i] != null) 
					{
						aCSVOutput.WriteLine ("X,Y,error");
						szErrorBar = ((string) m_szErrorBar [i]).Split ('\t');
					}
					else 
						aCSVOutput.WriteLine ("X,Y");

					for (int j = 0; j < szX.Length; j++) 
					{
						if (m_szErrorBar [i] != null) 
							aCSVOutput.WriteLine (szX [j] + "," + szY [j] + "," + szErrorBar [j]);
						else 
							aCSVOutput.WriteLine (szX [j] + "," + szY [j]);
					}

					// close the CVS stream
					aCSVOutput.Close ();
				}
			}	
	
			// done!
			return;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MuSigma\MuSigma\SQLImportDialog.cs ===
/////////////////////////////////////////////////////////////////////////////////////////////
// SQLImportData.cs		Dialog window for the SQL parameters.
//
// 2004 written by Ralf Herbrich
// Microsoft Research Ltd.
/////////////////////////////////////////////////////////////////////////////////////////////

using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;

namespace MuSigma
{
	/// <summary>
	/// A class that represents a dialog form for obtaining SQL import parameters such as the server name, the database name
	/// and HALO 2 specific information such at the hopper and variant types.
	/// </summary>
	public class SQLImportDialog : System.Windows.Forms.Form
	{
		private System.Windows.Forms.Label label2;
		private System.Windows.Forms.ComboBox cbGameHopper;
		private System.Windows.Forms.Label label3;
		private System.Windows.Forms.ComboBox cbGameVariant;
		private System.Windows.Forms.Label label4;
		private System.Windows.Forms.Button bntOK;
		private System.Windows.Forms.Button btnCancel;
		private System.Windows.Forms.ComboBox cbMap;
		private System.Windows.Forms.Label label5;
		private System.Windows.Forms.TextBox txtSQLServerName;
		private System.Windows.Forms.Label label6;
		private System.Windows.Forms.TextBox txtDatabaseName;
		private System.Windows.Forms.GroupBox groupBox1;
		private System.Windows.Forms.Label label1;
		private System.Windows.Forms.GroupBox groupBox2;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		/// <summary>
		/// A variable sized string array of game hopper names.
		/// </summary>
		string [] m_szGameHoppers = {"Arranged Games", "Free For All", "Small Teams", "Large Teams", 
									 "1 vs. 1", "Team vs. Team", "Unranked Large Teams", "Unranked Small Teams",
									 "Multi Team", "Hopper 14"};
		/// <summary>
		/// A variable sized list of database indicies representing these hoppers.
		/// </summary>
		int [] m_iGameHoppers = {0, 1, 2, 3, 
								 5, 6, 7, 8, 
								 9, 14};

		/// <summary>
		/// A variable sized string array of game variant names.
		/// </summary>
		string [] m_szGameVariants = {"CTF", "Slayer", "Assault", "Variant 4"};
		/// <summary>
		/// A variable sized list of database indicies representing these variants.
		/// </summary>
		int [] m_iGameVariants = {1, 2, 9, 4};
		
		/// <summary>
		/// A variable sized string array of game map names.
		/// </summary>
		string [] m_szGameMaps = {"Ivory Tower", "Midship", "Zanzibar", "Waterworks", "Lockout"};
		private System.Windows.Forms.CheckBox cbUsePlayerFlags;
		/// <summary>
		/// A variable sized list of database indicies representing these game maps.
		/// </summary>
		int [] m_iGameMaps = {10, 20, 30, 40, 50};

		/// <summary>
		/// Constructs an instance of a dialog for importing data from a SQL database.
		/// </summary>
		public SQLImportDialog()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			/////////////////////////////////////////////////////////////
			// populate the game hopper checkbox
			cbGameHopper.Items.Clear ();
			cbGameHopper.Items.Add ("Any hopper");
			cbGameHopper.Items.AddRange (m_szGameHoppers);
			cbGameHopper.Text = (string) cbGameHopper.Items [0];

			/////////////////////////////////////////////////////////////
			// populate the game variants checkbox
			cbGameVariant.Items.Clear ();
			cbGameVariant.Items.Add ("Any variant");
			cbGameVariant.Items.AddRange (m_szGameVariants);
			cbGameVariant.Text = (string) cbGameVariant.Items [0];

			/////////////////////////////////////////////////////////////
			// populate the game maps checkbox
			cbMap.Items.Clear ();
			cbMap.Items.Add ("Any map");
			cbMap.Items.AddRange (m_szGameMaps);
			cbMap.Text = (string) cbMap.Items [0];
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(SQLImportDialog));
			this.cbGameHopper = new System.Windows.Forms.ComboBox();
			this.label2 = new System.Windows.Forms.Label();
			this.label3 = new System.Windows.Forms.Label();
			this.cbGameVariant = new System.Windows.Forms.ComboBox();
			this.label4 = new System.Windows.Forms.Label();
			this.cbMap = new System.Windows.Forms.ComboBox();
			this.bntOK = new System.Windows.Forms.Button();
			this.btnCancel = new System.Windows.Forms.Button();
			this.label5 = new System.Windows.Forms.Label();
			this.txtSQLServerName = new System.Windows.Forms.TextBox();
			this.txtDatabaseName = new System.Windows.Forms.TextBox();
			this.label6 = new System.Windows.Forms.Label();
			this.groupBox1 = new System.Windows.Forms.GroupBox();
			this.label1 = new System.Windows.Forms.Label();
			this.groupBox2 = new System.Windows.Forms.GroupBox();
			this.cbUsePlayerFlags = new System.Windows.Forms.CheckBox();
			this.groupBox1.SuspendLayout();
			this.groupBox2.SuspendLayout();
			this.SuspendLayout();
			// 
			// cbGameHopper
			// 
			this.cbGameHopper.Location = new System.Drawing.Point(120, 24);
			this.cbGameHopper.Name = "cbGameHopper";
			this.cbGameHopper.Size = new System.Drawing.Size(121, 21);
			this.cbGameHopper.TabIndex = 2;
			this.cbGameHopper.Text = "Any";
			// 
			// label2
			// 
			this.label2.Location = new System.Drawing.Point(8, 24);
			this.label2.Name = "label2";
			this.label2.TabIndex = 2;
			this.label2.Text = "Game Hopper";
			this.label2.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
			// 
			// label3
			// 
			this.label3.Location = new System.Drawing.Point(8, 56);
			this.label3.Name = "label3";
			this.label3.TabIndex = 4;
			this.label3.Text = "Game Variant";
			this.label3.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
			// 
			// cbGameVariant
			// 
			this.cbGameVariant.Location = new System.Drawing.Point(120, 56);
			this.cbGameVariant.Name = "cbGameVariant";
			this.cbGameVariant.Size = new System.Drawing.Size(121, 21);
			this.cbGameVariant.TabIndex = 3;
			this.cbGameVariant.Text = "Any";
			// 
			// label4
			// 
			this.label4.Location = new System.Drawing.Point(8, 88);
			this.label4.Name = "label4";
			this.label4.TabIndex = 6;
			this.label4.Text = "Map";
			this.label4.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
			// 
			// cbMap
			// 
			this.cbMap.Location = new System.Drawing.Point(120, 88);
			this.cbMap.Name = "cbMap";
			this.cbMap.Size = new System.Drawing.Size(121, 21);
			this.cbMap.TabIndex = 4;
			this.cbMap.Text = "Any";
			// 
			// bntOK
			// 
			this.bntOK.DialogResult = System.Windows.Forms.DialogResult.OK;
			this.bntOK.Location = new System.Drawing.Point(40, 336);
			this.bntOK.Name = "bntOK";
			this.bntOK.Size = new System.Drawing.Size(88, 32);
			this.bntOK.TabIndex = 0;
			this.bntOK.Text = "OK";
			// 
			// btnCancel
			// 
			this.btnCancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
			this.btnCancel.Location = new System.Drawing.Point(168, 336);
			this.btnCancel.Name = "btnCancel";
			this.btnCancel.Size = new System.Drawing.Size(88, 32);
			this.btnCancel.TabIndex = 1;
			this.btnCancel.Text = "Cancel";
			// 
			// label5
			// 
			this.label5.Location = new System.Drawing.Point(16, 24);
			this.label5.Name = "label5";
			this.label5.TabIndex = 7;
			this.label5.Text = "SQL Server";
			this.label5.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
			// 
			// txtSQLServerName
			// 
			this.txtSQLServerName.Location = new System.Drawing.Point(128, 24);
			this.txtSQLServerName.Name = "txtSQLServerName";
			this.txtSQLServerName.Size = new System.Drawing.Size(112, 20);
			this.txtSQLServerName.TabIndex = 8;
			this.txtSQLServerName.Text = "msrc-mlpsql";
			// 
			// txtDatabaseName
			// 
			this.txtDatabaseName.Location = new System.Drawing.Point(128, 56);
			this.txtDatabaseName.Name = "txtDatabaseName";
			this.txtDatabaseName.Size = new System.Drawing.Size(112, 20);
			this.txtDatabaseName.TabIndex = 10;
			this.txtDatabaseName.Text = "Halo2Stats";
			// 
			// label6
			// 
			this.label6.Location = new System.Drawing.Point(16, 56);
			this.label6.Name = "label6";
			this.label6.TabIndex = 9;
			this.label6.Text = "Database";
			this.label6.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
			// 
			// groupBox1
			// 
			this.groupBox1.Controls.Add(this.txtDatabaseName);
			this.groupBox1.Controls.Add(this.label6);
			this.groupBox1.Controls.Add(this.label5);
			this.groupBox1.Controls.Add(this.txtSQLServerName);
			this.groupBox1.Location = new System.Drawing.Point(24, 56);
			this.groupBox1.Name = "groupBox1";
			this.groupBox1.Size = new System.Drawing.Size(248, 88);
			this.groupBox1.TabIndex = 11;
			this.groupBox1.TabStop = false;
			this.groupBox1.Text = "SQL Server Information";
			// 
			// label1
			// 
			this.label1.Font = new System.Drawing.Font("Microsoft Sans Serif", 14F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.label1.Location = new System.Drawing.Point(64, 16);
			this.label1.Name = "label1";
			this.label1.Size = new System.Drawing.Size(168, 24);
			this.label1.TabIndex = 0;
			this.label1.Text = "Import Parameters";
			this.label1.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
			// 
			// groupBox2
			// 
			this.groupBox2.Controls.Add(this.cbGameHopper);
			this.groupBox2.Controls.Add(this.label2);
			this.groupBox2.Controls.Add(this.label3);
			this.groupBox2.Controls.Add(this.cbGameVariant);
			this.groupBox2.Controls.Add(this.label4);
			this.groupBox2.Controls.Add(this.cbMap);
			this.groupBox2.Location = new System.Drawing.Point(24, 168);
			this.groupBox2.Name = "groupBox2";
			this.groupBox2.Size = new System.Drawing.Size(248, 120);
			this.groupBox2.TabIndex = 12;
			this.groupBox2.TabStop = false;
			this.groupBox2.Text = "Game Type Filters";
			// 
			// cbUsePlayerFlags
			// 
			this.cbUsePlayerFlags.Checked = true;
			this.cbUsePlayerFlags.CheckState = System.Windows.Forms.CheckState.Checked;
			this.cbUsePlayerFlags.Location = new System.Drawing.Point(24, 296);
			this.cbUsePlayerFlags.Name = "cbUsePlayerFlags";
			this.cbUsePlayerFlags.Size = new System.Drawing.Size(248, 24);
			this.cbUsePlayerFlags.TabIndex = 13;
			this.cbUsePlayerFlags.Text = "Use Player Flags";
			// 
			// SQLImportDialog
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(298, 384);
			this.Controls.Add(this.cbUsePlayerFlags);
			this.Controls.Add(this.groupBox2);
			this.Controls.Add(this.groupBox1);
			this.Controls.Add(this.btnCancel);
			this.Controls.Add(this.bntOK);
			this.Controls.Add(this.label1);
			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
			this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
			this.KeyPreview = true;
			this.MaximizeBox = false;
			this.Name = "SQLImportDialog";
			this.ShowInTaskbar = false;
			this.Text = "SQL Import Dialog";
			this.groupBox1.ResumeLayout(false);
			this.groupBox2.ResumeLayout(false);
			this.ResumeLayout(false);

		}
		#endregion

		/// <summary>
		/// The SQL filter string corresponding to the settings of the dialog box.
		/// </summary>
		public string SQLFilterString 
		{
			get 
			{
				string szSQLFilterString = "";

				// game hopper
				if (cbGameHopper.SelectedIndex > 0)
					szSQLFilterString += "game_hopper = " + m_iGameHoppers [cbGameHopper.SelectedIndex - 1].ToString ();

				// game variants
				if (cbGameVariant.SelectedIndex > 0) 
				{
					if (szSQLFilterString.Length > 0)
						szSQLFilterString += " and ";
					szSQLFilterString += "game_variant = " + m_iGameVariants [cbGameVariant.SelectedIndex - 1].ToString ();
				}

				// game maps
				if (cbMap.SelectedIndex > 0) 
				{
					if (szSQLFilterString.Length > 0)
						szSQLFilterString += " and ";
					szSQLFilterString += "game_map = " + m_iGameMaps [cbMap.SelectedIndex - 1].ToString ();
				}

				// possibly add the keyword
				if (szSQLFilterString.Length > 0)
					szSQLFilterString = "where " + szSQLFilterString;

				return szSQLFilterString;
			}
		}

		/// <summary>
		/// The HALO 2 internal ID of the currently selected hopper (or -1 if no hopper is selected).
		/// </summary>
		public int CurrentHopperID
		{
			get 
			{
				if (cbGameHopper.SelectedIndex > 0)
					return m_iGameHoppers [cbGameHopper.SelectedIndex - 1];
				else
					return -1;
			}
			set 
			{
				if (value < 0 || value > m_iGameHoppers.Length)
					throw new Exception ("Parameter value too big.");
				cbGameHopper.SelectedIndex = value;
			}
		}

		/// <summary>
		/// The HALO 2 internal ID of the currently selected map (or -1 if no map is selected).
		/// </summary>
		public int CurrentMapID
		{
			get 
			{
				if (cbMap.SelectedIndex > 0)
					return m_iGameMaps [cbMap.SelectedIndex - 1];
				else
					return -1;
			}
			set 
			{
				if (value < 0 || value > m_iGameMaps.Length)
					throw new Exception ("Parameter value too big.");
				cbMap.SelectedIndex = value;
			}
		}

		/// <summary>
		/// The HALO 2 internal ID of the currently selected variant (or -1 if no variant is selected).
		/// </summary>
		public int CurrentVariantID
		{
			get 
			{
				if (cbGameVariant.SelectedIndex > 0)
					return m_iGameVariants [cbGameVariant.SelectedIndex - 1];
				else
					return -1;
			}
			set 
			{
				if (value < 0 || value > m_iGameVariants.Length)
					throw new Exception ("Parameter value too big.");
				cbGameVariant.SelectedIndex = value;
			}
		}

		/// <summary>
		/// The name of the SQL server as currently entered.
		/// </summary>
		public string SQLServerName 
		{
			get 
			{
				return txtSQLServerName.Text;
			}
			set 
			{
				txtSQLServerName.Text = value;
			}
		}

		/// <summary>
		/// Use player flags during import.
		/// </summary>
		public bool UsePlayerFlags 
		{
			get 
			{
				return cbUsePlayerFlags.Checked;
			}
			set 
			{
				cbUsePlayerFlags.Checked = value;
			}
		}

		/// <summary>
		/// The name of the database as currently entered.
		/// </summary>
		public string DatabaseName
		{
			get 
			{
				return txtDatabaseName.Text;
			}
			set 
			{
				txtDatabaseName.Text = value;
			}
		}

		/// <summary>
		/// Gets the name of a map for a given map ID.
		/// </summary>
		/// <param name="iMapID">The HALO 2 internal map ID.</param>
		/// <returns>The map name or null if the map ID does not exist.</returns>
		public string GetMapName (int iMapID)
		{
			// linear search through all possible game maps
			for (int i = 0; i < m_iGameMaps.Length; i++)
				if (iMapID == m_iGameMaps [i])
					return m_szGameMaps [i];

			return null;
		}

		/// <summary>
		/// Gets the name of a variant for a given variant ID.
		/// </summary>
		/// <param name="iVariantID">The HALO 2 internal variant ID.</param>
		/// <returns>The variant name or null if the variant ID does not exist.</returns>
		public string GetVariantName (int iVariantID)
		{
			// linear search through all possible game variant
			for (int i = 0; i < m_iGameVariants.Length; i++)
				if (iVariantID == m_iGameVariants [i])
					return m_szGameVariants [i];

			return null;
		}

		/// <summary>
		/// Gets the name of a hopper for a given hopper ID.
		/// </summary>
		/// <param name="iHopperID">The HALO 2 internal hopper ID.</param>
		/// <returns>The hopper name or null if the hopper ID does not exists.</returns>
		public string GetHopperName (int iHopperID)
		{
			// linear search through all possible game hoppers
			for (int i = 0; i < m_iGameHoppers.Length; i++)
				if (iHopperID == m_iGameHoppers [i])
					return m_szGameHoppers [i];

			return null;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MuSigma\MuSigma\Main.cs ===
/////////////////////////////////////////////////////////////////////////////////////////////
// MuSigma.cs		Main function of the Mu-Sigma ranking system UI
//
// 2004 written y Ralf Herbrich
// Microsoft Research Ltd.
/////////////////////////////////////////////////////////////////////////////////////////////

using System;
using System.Drawing;
using System.Collections;
using System.Data.SqlClient;
using System.ComponentModel;
using System.Windows.Forms;
using System.Data;
using System.Text;
using System.IO;
using System.Diagnostics;
using System.Reflection;
using MSRanking;
using MSRanking.Skills;
using MSRanking.RankingSystems;
using Sampling;
using Numerics;

namespace MuSigma
{
	/// <summary>
	/// This is the main form of the MuSigma application. It provides the UI for all the functionality of reading data, running
	/// different ranking algorithms and analysing the ranking and matchmaking quality.
	/// </summary>
	public class MainWindow : System.Windows.Forms.Form
	{
		#region Application specific varaibles
		/// <summary>
		/// List of mapping from the Halo 2 internal player IDs to the ranking system internal player IDs.
		/// </summary>
		private Hashtable m_aHalo2PlayerIDToInternalPlayerID;
		/// <summary>
		/// List of mapping from the ranking system internal player IDs to the Halo 2 internal player IDs.
		/// </summary>
		private Hashtable m_aInternalPlayerIDToHalo2PlayerID;
		/// <summary>
		/// List of players.
		/// </summary>
		private PlayerList m_aPlayerList;			
		/// <summary>
		/// List of games.
		/// </summary>
		private Halo2GameList m_aGameList;
		/// <summary>
		/// The currently selected ranking system.
		/// </summary>
		private RankingSystem m_aCurrentRankingSystem;
		/// <summary>
		/// The Halo 2 ranking system.
		/// </summary>
		private Halo2RankingSystem m_aHalo2RankingSystem;	
		/// <summary>
		/// The Halo 2 ranking system (for the raw data).
		/// </summary>
		private Halo2RankingSystem m_aRawHalo2RankingSystem;	
		/// <summary>
		/// The MuSigma ranking system.
		/// </summary>
		private MuSigmaRankingSystem m_aMuSigmaRankingSystem;		
		/// <summary>
		/// The ELO ranking system.
		/// </summary>
		private ELORankingSystem m_aELORankingSystem;		
		/// <summary>
		/// List of games played by each player (game IDs).
		/// </summary>
		private ArrayList [] m_aGamesPlayed;			
		/// <summary>
		/// List of game IDs which are currently displayed on screen.
		/// </summary>
		private int [] m_iViewedGameID;
		/// <summary>
		/// The granularity of the progress bar.
		/// </summary>
		private const int m_iProgressBarGranularity = 1000;
		/// <summary>
		/// The global start date of all date based calculations
		/// </summary>
		private DateTime m_aStartDate;
		/// <summary>
		/// The SQL import parameter dialog.
		/// </summary>
		private SQLImportDialog m_aSQLImportDialog;
		/// <summary>
		/// The player progression window.
		/// </summary>
		private PlotWindow m_aPlayerProgression;
		/// <summary>
		/// The MuSigma performance progression window.
		/// </summary>
		private PlotWindow m_aMuSigmaPlayerPerformance;
		/// <summary>
		/// The ELO performance progression window.
		/// </summary>
		private PlotWindow m_aELOPlayerPerformance;
		/// <summary>
		/// The global log window.
		/// </summary>
		private LogWindow m_aLogWindow;
		/// <summary>
		/// The global ranking parameters window.
		/// </summary>
		private RankingParameters m_aRankingParameters;
		/// <summary>
		/// The "About" window.
		/// </summary>
		private AboutWindow m_aAboutWindow;
		/// <summary>
		/// The Result Import dialog.
		/// </summary>
		private ResultImportDialog m_aResultImportDialog;
		/// <summary>
		/// The "Quick Command" dialog form.
		/// </summary>
		private QuickCommandDialog m_aQuickCommandDialog;
		#endregion 

		#region Application specific form declarations
		private System.Windows.Forms.GroupBox gbGameData;
		private System.Windows.Forms.ListBox lbPlayerList;
		private System.Windows.Forms.ListBox lbGameList;
		private System.ComponentModel.IContainer components;
		private System.Windows.Forms.Label lblPlayerList;
		private System.Windows.Forms.Label lblGameList;
		private System.Windows.Forms.Label [] lblPlayerNames;
		private System.Windows.Forms.Label [] lblPlayerScore;
		private System.Windows.Forms.Label [] lblPlayerLevel;
		private System.Windows.Forms.MenuItem [] menuIterationsCount;
		private System.Windows.Forms.PictureBox [] pbExperienceBar;
		private System.Drawing.Graphics [] gcExperienceBar;
		private System.Windows.Forms.Label lblNoPlayers;
		private System.Windows.Forms.Label lblNoGames;
		private System.Windows.Forms.ToolTip ttMuSigma;
		private System.Windows.Forms.Panel pnlGameInfo;
		private System.Windows.Forms.Label lblGameInfo;
		private System.Windows.Forms.MainMenu mainMenu1;
		private System.Windows.Forms.MenuItem menuItem1;
		private System.Windows.Forms.MenuItem menuItem5;
		private System.Windows.Forms.MenuItem menuItem6;
		private System.Windows.Forms.MenuItem menuItem9;
		private System.Windows.Forms.MenuItem menuItem12;
		private System.Windows.Forms.MenuItem menuItem17;
		private System.Windows.Forms.MenuItem menuQuit;
		private System.Windows.Forms.MenuItem menuShowProgressWindow;
		private System.Windows.Forms.MenuItem menuShowLogWindow;
		private System.Windows.Forms.MenuItem rbMuSigmaRankingResults;
		private System.Windows.Forms.MenuItem rbViewAllGames;
		private System.Windows.Forms.MenuItem rbViewSelectedGames;
		private System.Windows.Forms.MenuItem rbSelectPolicyOr;
		private System.Windows.Forms.MenuItem rbSelectPolicyAnd;
		private System.Windows.Forms.MenuItem menuItem2;
		private System.Windows.Forms.MenuItem rbAlphabeticalSorting;
		private System.Windows.Forms.MenuItem menuItem4;
		private System.Windows.Forms.MenuItem menuRecomputeRanking;
		private System.Windows.Forms.MenuItem menuAbout;
		private System.Windows.Forms.MenuItem menuItem7;
		private System.Windows.Forms.MenuItem menuRankingDifference;
		private System.Windows.Forms.GroupBox gbOptions;
		private System.Windows.Forms.Label lblRankingSystem;
		private System.Windows.Forms.Label lblPlayerSorting;
		private System.Windows.Forms.Label lblGameView;
		private System.Windows.Forms.MenuItem rbRawHalo2RankingResults;
		private System.Windows.Forms.MenuItem rbHalo2RankingResults;
		private System.Windows.Forms.MenuItem menuMuSigmaLogProbability;
		private System.Windows.Forms.MenuItem menuReadGames;
		private System.Windows.Forms.MenuItem menuReadResults;
		private System.Windows.Forms.MenuItem menuSaveResults;
		private System.Windows.Forms.MenuItem menuCompareSelectedPlayers;
		private System.Windows.Forms.MenuItem menuItem3;
		private System.Windows.Forms.MenuItem menuMuSigmaIterationsCheck;
		private System.Windows.Forms.MenuItem menuNumberOfIterations;
		private System.Windows.Forms.MenuItem menuDebugAdditionalSeparator;
		private System.Windows.Forms.MenuItem menuAttachWindows;
		private System.Windows.Forms.MenuItem menuItem8;
		private System.Windows.Forms.MenuItem menuQuickCommands;
		private System.Windows.Forms.MenuItem menuItem11;
		private System.Windows.Forms.MenuItem rbELORankingResults;
		private System.Windows.Forms.MenuItem menuPlayersandGamesOnly;
		private System.Windows.Forms.MenuItem menuShowPerformanceWindows;
		private System.Windows.Forms.MenuItem menuItem10;
		private System.Windows.Forms.MenuItem menuExportEquivalentRankings;
		private System.Windows.Forms.MenuItem menuPhasePlots;
		private System.Windows.Forms.MenuItem rbSkillSorting;
		private System.Windows.Forms.MenuItem menuEvidenceAnalysis;
		private System.Windows.Forms.ProgressBar pbProgress;
		#endregion

		#region Constructor and Destructor
		/// <summary>
		/// Constructs a new main window for the application.
		/// </summary>
		public MainWindow ()
		{
			////////////////////////////////////////////////////////////////
			// required for Windows Form Designer support
			InitializeComponent();

			////////////////////////////////////////////////////////////////
			// the main window title is the version number
			Version aVersion = typeof (MainWindow).Assembly.GetName ().Version;
			this.Text = "Halo 2 Ranking Analyser (v " + aVersion.ToString () + ")";

			////////////////////////////////////////////////////////////////
			// allocate the start data
			m_aStartDate = new DateTime (2004, 7, 1, 0, 0, 0);

			////////////////////////////////////////////////////////////////
			// prepare the dialogs
			m_aSQLImportDialog = new SQLImportDialog ();
			m_aPlayerProgression = new PlotWindow ();
			m_aELOPlayerPerformance = new PlotWindow ();
			m_aMuSigmaPlayerPerformance = new PlotWindow ();
			m_aLogWindow = new LogWindow ();
			m_aRankingParameters = new RankingParameters ();
			m_aAboutWindow = new AboutWindow ();
			m_aResultImportDialog = new ResultImportDialog ();

			////////////////////////////////////////////////////////////////
			// prepare the Quick Command dialog
			m_aQuickCommandDialog = new QuickCommandDialog ();
			m_aQuickCommandDialog.AddCommand ("'DJ 116' and 'Striker' in 1 vs. 1", 
				"Shows the outcome probability as it evolves over time for both players.\n" +
				"\n" + 
				"Remember that this was the cheating weekend. 'DJ 116' is winning it but he " + 
				"admitted exploiting that at 3:00 a.m. he was able to match himself with the same " + 
				"people (he effectively brakes the matchmaking). This helped him massively in the Halo 2 ranking " + 
				"system. Then he used two strategies:\n" +
				"\n" +
				"1. He convinced 'pie are round' to let him win.\n" + 
				"2. He got 'Striker' up to a higher level by win/losing consecutively and finally bounced off 'Striker'.\n" + 
				"\n" +
				"Note that you still have to select which results you would like to see.");
			m_aQuickCommandDialog.AddCommand ("'char' and 'SQLwildman' in FFA hopper", 
				"Shows the outcome probability as it evolves over time for both players. \n" +
				"\n" + 
				"Clearly, the MuSigma system indicates that 'char' is the better player. In contrast, the Halo 2 " + 
				"Beta system places 'SQLwildman' eight levels higher than 'char'. Who do you believe is better? " + 
				"Hint: Look at the list of games the two played agaist each other! \n" + 
				"\n" + 
				"Note that the MuSigma discovers the true playing strength level of 'char' after about 10 games played." + 
				"Moreover, the plots also show that the system can account for the clear learning effect taking place with " + 
				"'SQLwildman'.\n" +
				"\n" + 
				"Note that you still have to select which results you would like to see.");
			m_aQuickCommandDialog.AddCommand ("'SQLwildman' and 'BNG herr jones' in Small Teams", 
				"Shows the outcome probability as it evolves over time for both players.\n " + 
				"\n" + 
				"The MuSigma system indicates that 'BNG herr jones' is the better player in a team. In contrast, the Halo 2 " + 
				"Beta system eventually places 'SQLwildman' ten levels higher than 'BNG herr jones'. Who do you believe is better? " + 
				"This is an example where the team update equation has hurt 'BNG herr jones'. Note that 'BNG herr jones' was in only " + 
				"13 out of 78 team games member of the losing team and the teams were widely varying which supports the ranking " + 
				"of the MuSigma system.\n" + 
				"\n" + 
				"Note that you still have to select which results you would like to see.");
			m_aQuickCommandDialog.AddCommand ("Score span over time", 
				"Shows the span of the skill points over time for five players ranging from the best player ('char') to some " +
				"bad players ('qimugtaqpaq').\n " + 
				"\n" + 
				"The scale once chosen by the prior (1200 +- 400 points) is never " + 
				"left which gives MuSigma skill points an absolute scale to measure skill against. This " + 
				"does not imply that the final histogram over skill points is uniform; it simply means that the skill points will not " + 
				"explode over time (as can happen with the Halo 2 ranking system).\n" + 
				"\n" + 
				"Note that you still have to select which results you would like to see.");
			m_aQuickCommandDialog.AddCommand ("Predictive performance on 1 vs. 1", 
				"Shows the ranking difference between the the two rankings based on the current skill points and the actual" +
				"game outcome.\n " + 
				"\n" + 
				"Clearly the MuSigma skill belief allows to predict the game outcome much better although eventually, the Halo 2 experience points are " + 
				"reflective of the true playing strength. Note that this plot mixes the matchmaking ability with the ability to predict " + 
				"the outcome: in perfectly-matched games one should never be able to be better than 50%!\n" + 
				"\n" + 
				"Note that you still have to select which results you would like to see.");

#if DEBUG
			// change to a different database in the testing phase
			m_aSQLImportDialog.DatabaseName = "Halo2Beta";

			// change to a different database in the testing phase
			m_aSQLImportDialog.SQLServerName = "msrc-mlpsql";

			// put the ranking parameters form into advanced mode
			m_aRankingParameters.AdvancedMode = true;

			////////////////////////////////////////////////////////////////
			// generate the submenu of list of number of iterations
			int [] iNumberOfIterationsList = new int [] { 20, 50, 100, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 10000 };
			menuIterationsCount = new MenuItem [iNumberOfIterationsList.Length];
			for (int i = 0; i < iNumberOfIterationsList.Length; i++)
			{
				menuIterationsCount [i] = new MenuItem ();
				menuIterationsCount [i].Checked = true;
				menuIterationsCount [i].Index = i;
				menuIterationsCount [i].Text = iNumberOfIterationsList [i].ToString ();
				menuIterationsCount [i].Click += new System.EventHandler (this.menuIterationsCount_Click);
				menuNumberOfIterations.MenuItems.Add (menuIterationsCount [i]);
			}
#else
			// put the ranking parameters dialog in non-advanced mode
			m_aRankingParameters.AdvancedMode = false;

			// disable the analyse menu in a non-DEBUG build
			menuNumberOfIterations.Visible = false;
			menuMuSigmaIterationsCheck.Visible = false;
			menuDebugAdditionalSeparator.Visible = false;		
			menuMuSigmaLogProbability.Visible = false;
			menuExportEquivalentRankings.Visible = false;
			menuEvidenceAnalysis.Visible = false;
#endif

			////////////////////////////////////////////////////////////////
			// build the game data labels
			lblPlayerNames = new System.Windows.Forms.Label [16];
			lblPlayerScore = new System.Windows.Forms.Label [16];
			lblPlayerLevel = new System.Windows.Forms.Label [16];
			pbExperienceBar = new System.Windows.Forms.PictureBox [16];
			gcExperienceBar = new System.Drawing.Graphics [16];
			for (int i = 0; i < 16; i++) 
			{
				lblPlayerNames [i] = new System.Windows.Forms.Label ();
				lblPlayerNames [i].Location = new System.Drawing.Point (16, 24 + i * 24);
				lblPlayerNames [i].Width = 200;
				lblPlayerNames [i].Name = "lblPlayerNames" + i.ToString ();
				lblPlayerNames [i].TabIndex = i;
				lblPlayerNames [i].Text = "";
				gbGameData.Controls.Add (lblPlayerNames [i]);

				lblPlayerScore [i] = new System.Windows.Forms.Label ();
				lblPlayerScore [i].Location = new System.Drawing.Point (220, 24 + i * 24);
				lblPlayerScore [i].Width = 30;
				lblPlayerScore [i].Name = "lblPlayerScore" + i.ToString ();
				lblPlayerScore [i].TabIndex = i;
				lblPlayerScore [i].Text = "";
				gbGameData.Controls.Add (lblPlayerScore [i]);

				pbExperienceBar [i] = new System.Windows.Forms.PictureBox ();
				pbExperienceBar [i].Location = new System.Drawing.Point (260, 22 + i * 24);
				pbExperienceBar [i].Width = 50;
				pbExperienceBar [i].Height = 18;
				pbExperienceBar [i].Name = "pbExperienceBar" + i.ToString ();
				pbExperienceBar [i].TabIndex = i;
				gcExperienceBar [i] = pbExperienceBar [i].CreateGraphics ();
				gcExperienceBar [i].Clear (Color.White);
				gbGameData.Controls.Add (pbExperienceBar [i]);

				lblPlayerLevel [i] = new System.Windows.Forms.Label ();
				lblPlayerLevel [i].Location = new System.Drawing.Point (320, 24 + i * 24);
				lblPlayerLevel [i].Width = 50;
				lblPlayerLevel [i].Name = "lblPlayerLevel" + i.ToString ();
				lblPlayerLevel [i].TabIndex = i;
				lblPlayerLevel [i].Text = "";
				gbGameData.Controls.Add (lblPlayerLevel [i]);

			}
			
			////////////////////////////////////////////////////////////////
			// allocate the player list
			// allocate the player ID mappings
			// allocate the game list
			// allocate the ranking systems
			m_aPlayerList = new PlayerList ();
			m_aGameList = new Halo2GameList ();
			m_aHalo2PlayerIDToInternalPlayerID = new Hashtable ();
			m_aInternalPlayerIDToHalo2PlayerID = new Hashtable ();

			m_aRawHalo2RankingSystem = new Halo2RankingSystem ();	// we will never use the update method!
			m_aHalo2RankingSystem = new Halo2RankingSystem (); 
			m_aMuSigmaRankingSystem = new MuSigmaRankingSystem (m_aRankingParameters.MuSigmaBeta, 
				m_aRankingParameters.MuSigmaEpsilon, m_aRankingParameters.MuSigmaTau);
			m_aMuSigmaRankingSystem.ApproximationAlgorithm = m_aRankingParameters.MuSigmaApproximationAlgorithm;
			m_aELORankingSystem = new ELORankingSystem (m_aRankingParameters.ELOBeta, m_aRankingParameters.ELOAlpha);
			m_aCurrentRankingSystem = m_aHalo2RankingSystem;

			////////////////////////////////////////////////////////////////
			// allocate the cross-reference list
			// allocate the viewed games list 
			m_aGamesPlayed = new ArrayList [m_aPlayerList.NumberOfPlayers];
			m_iViewedGameID = new int [m_aPlayerList.NumberOfPlayers];

			////////////////////////////////////////////////////////////////
			// update the options box
			UpdateOptionsBox ();

			////////////////////////////////////////////////////////////////
			// Show the Quick Command list
			menuQuickCommands_Click (null, null);
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if (components != null) 
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}
		#endregion

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.components = new System.ComponentModel.Container();
			System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(MainWindow));
			this.lbPlayerList = new System.Windows.Forms.ListBox();
			this.lbGameList = new System.Windows.Forms.ListBox();
			this.gbGameData = new System.Windows.Forms.GroupBox();
			this.pnlGameInfo = new System.Windows.Forms.Panel();
			this.lblGameInfo = new System.Windows.Forms.Label();
			this.lblPlayerList = new System.Windows.Forms.Label();
			this.lblGameList = new System.Windows.Forms.Label();
			this.lblNoPlayers = new System.Windows.Forms.Label();
			this.lblNoGames = new System.Windows.Forms.Label();
			this.ttMuSigma = new System.Windows.Forms.ToolTip(this.components);
			this.gbOptions = new System.Windows.Forms.GroupBox();
			this.lblGameView = new System.Windows.Forms.Label();
			this.lblPlayerSorting = new System.Windows.Forms.Label();
			this.lblRankingSystem = new System.Windows.Forms.Label();
			this.mainMenu1 = new System.Windows.Forms.MainMenu();
			this.menuItem1 = new System.Windows.Forms.MenuItem();
			this.menuReadGames = new System.Windows.Forms.MenuItem();
			this.menuReadResults = new System.Windows.Forms.MenuItem();
			this.menuSaveResults = new System.Windows.Forms.MenuItem();
			this.menuItem11 = new System.Windows.Forms.MenuItem();
			this.menuQuickCommands = new System.Windows.Forms.MenuItem();
			this.menuItem4 = new System.Windows.Forms.MenuItem();
			this.menuQuit = new System.Windows.Forms.MenuItem();
			this.menuItem7 = new System.Windows.Forms.MenuItem();
			this.menuRecomputeRanking = new System.Windows.Forms.MenuItem();
			this.menuItem3 = new System.Windows.Forms.MenuItem();
			this.menuCompareSelectedPlayers = new System.Windows.Forms.MenuItem();
			this.menuRankingDifference = new System.Windows.Forms.MenuItem();
			this.menuMuSigmaLogProbability = new System.Windows.Forms.MenuItem();
			this.menuDebugAdditionalSeparator = new System.Windows.Forms.MenuItem();
			this.menuMuSigmaIterationsCheck = new System.Windows.Forms.MenuItem();
			this.menuNumberOfIterations = new System.Windows.Forms.MenuItem();
			this.menuExportEquivalentRankings = new System.Windows.Forms.MenuItem();
			this.menuItem5 = new System.Windows.Forms.MenuItem();
			this.menuItem6 = new System.Windows.Forms.MenuItem();
			this.rbRawHalo2RankingResults = new System.Windows.Forms.MenuItem();
			this.rbHalo2RankingResults = new System.Windows.Forms.MenuItem();
			this.rbELORankingResults = new System.Windows.Forms.MenuItem();
			this.rbMuSigmaRankingResults = new System.Windows.Forms.MenuItem();
			this.menuItem9 = new System.Windows.Forms.MenuItem();
			this.rbAlphabeticalSorting = new System.Windows.Forms.MenuItem();
			this.rbSkillSorting = new System.Windows.Forms.MenuItem();
			this.menuItem12 = new System.Windows.Forms.MenuItem();
			this.rbViewAllGames = new System.Windows.Forms.MenuItem();
			this.rbViewSelectedGames = new System.Windows.Forms.MenuItem();
			this.menuItem2 = new System.Windows.Forms.MenuItem();
			this.rbSelectPolicyOr = new System.Windows.Forms.MenuItem();
			this.rbSelectPolicyAnd = new System.Windows.Forms.MenuItem();
			this.menuItem17 = new System.Windows.Forms.MenuItem();
			this.menuShowProgressWindow = new System.Windows.Forms.MenuItem();
			this.menuShowPerformanceWindows = new System.Windows.Forms.MenuItem();
			this.menuShowLogWindow = new System.Windows.Forms.MenuItem();
			this.menuItem10 = new System.Windows.Forms.MenuItem();
			this.menuAttachWindows = new System.Windows.Forms.MenuItem();
			this.menuPhasePlots = new System.Windows.Forms.MenuItem();
			this.menuPlayersandGamesOnly = new System.Windows.Forms.MenuItem();
			this.menuItem8 = new System.Windows.Forms.MenuItem();
			this.menuAbout = new System.Windows.Forms.MenuItem();
			this.pbProgress = new System.Windows.Forms.ProgressBar();
			this.menuEvidenceAnalysis = new System.Windows.Forms.MenuItem();
			this.gbGameData.SuspendLayout();
			this.pnlGameInfo.SuspendLayout();
			this.gbOptions.SuspendLayout();
			this.SuspendLayout();
			// 
			// lbPlayerList
			// 
			this.lbPlayerList.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
				| System.Windows.Forms.AnchorStyles.Left)));
			this.lbPlayerList.Location = new System.Drawing.Point(32, 112);
			this.lbPlayerList.Name = "lbPlayerList";
			this.lbPlayerList.SelectionMode = System.Windows.Forms.SelectionMode.MultiExtended;
			this.lbPlayerList.Size = new System.Drawing.Size(176, 589);
			this.lbPlayerList.TabIndex = 0;
			this.ttMuSigma.SetToolTip(this.lbPlayerList, "List of gamertags of currently loaded players.");
			this.lbPlayerList.SelectedIndexChanged += new System.EventHandler(this.lbPlayerList_SelectedIndexChanged);
			// 
			// lbGameList
			// 
			this.lbGameList.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
				| System.Windows.Forms.AnchorStyles.Left)));
			this.lbGameList.Location = new System.Drawing.Point(240, 112);
			this.lbGameList.Name = "lbGameList";
			this.lbGameList.Size = new System.Drawing.Size(176, 589);
			this.lbGameList.TabIndex = 1;
			this.ttMuSigma.SetToolTip(this.lbGameList, "Chronologically sorted list of all games currently selected.");
			this.lbGameList.SelectedIndexChanged += new System.EventHandler(this.lbGameList_SelectedIndexChanged);
			// 
			// gbGameData
			// 
			this.gbGameData.BackColor = System.Drawing.Color.AntiqueWhite;
			this.gbGameData.Controls.Add(this.pnlGameInfo);
			this.gbGameData.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.gbGameData.Location = new System.Drawing.Point(464, 112);
			this.gbGameData.Name = "gbGameData";
			this.gbGameData.Size = new System.Drawing.Size(376, 456);
			this.gbGameData.TabIndex = 2;
			this.gbGameData.TabStop = false;
			this.gbGameData.Text = "Game Data";
			this.ttMuSigma.SetToolTip(this.gbGameData, "Final Ranking of the game.");
			// 
			// pnlGameInfo
			// 
			this.pnlGameInfo.BackColor = System.Drawing.Color.DarkOrange;
			this.pnlGameInfo.Controls.Add(this.lblGameInfo);
			this.pnlGameInfo.Location = new System.Drawing.Point(8, 416);
			this.pnlGameInfo.Name = "pnlGameInfo";
			this.pnlGameInfo.Size = new System.Drawing.Size(360, 32);
			this.pnlGameInfo.TabIndex = 0;
			this.ttMuSigma.SetToolTip(this.pnlGameInfo, "Map. hopper and variant of the current game.");
			// 
			// lblGameInfo
			// 
			this.lblGameInfo.Location = new System.Drawing.Point(8, 8);
			this.lblGameInfo.Name = "lblGameInfo";
			this.lblGameInfo.Size = new System.Drawing.Size(344, 16);
			this.lblGameInfo.TabIndex = 0;
			// 
			// lblPlayerList
			// 
			this.lblPlayerList.BackColor = System.Drawing.Color.Transparent;
			this.lblPlayerList.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.lblPlayerList.Location = new System.Drawing.Point(32, 88);
			this.lblPlayerList.Name = "lblPlayerList";
			this.lblPlayerList.Size = new System.Drawing.Size(176, 24);
			this.lblPlayerList.TabIndex = 5;
			this.lblPlayerList.Text = "Player List";
			this.lblPlayerList.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
			this.ttMuSigma.SetToolTip(this.lblPlayerList, "List of all loaded players.");
			// 
			// lblGameList
			// 
			this.lblGameList.BackColor = System.Drawing.Color.Transparent;
			this.lblGameList.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.lblGameList.Location = new System.Drawing.Point(240, 88);
			this.lblGameList.Name = "lblGameList";
			this.lblGameList.Size = new System.Drawing.Size(176, 24);
			this.lblGameList.TabIndex = 6;
			this.lblGameList.Text = "Game List";
			this.lblGameList.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
			this.ttMuSigma.SetToolTip(this.lblGameList, "List of all games. If the background is yellow, the total list of all games is sh" +
				"own.");
			// 
			// lblNoPlayers
			// 
			this.lblNoPlayers.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
			this.lblNoPlayers.BackColor = System.Drawing.Color.Transparent;
			this.lblNoPlayers.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Italic, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.lblNoPlayers.Location = new System.Drawing.Point(32, 704);
			this.lblNoPlayers.Name = "lblNoPlayers";
			this.lblNoPlayers.Size = new System.Drawing.Size(176, 16);
			this.lblNoPlayers.TabIndex = 10;
			this.lblNoPlayers.Text = "0 player(s)";
			this.lblNoPlayers.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
			this.ttMuSigma.SetToolTip(this.lblNoPlayers, "Total number of players.");
			// 
			// lblNoGames
			// 
			this.lblNoGames.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
			this.lblNoGames.BackColor = System.Drawing.Color.Transparent;
			this.lblNoGames.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Italic, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.lblNoGames.Location = new System.Drawing.Point(240, 704);
			this.lblNoGames.Name = "lblNoGames";
			this.lblNoGames.Size = new System.Drawing.Size(176, 16);
			this.lblNoGames.TabIndex = 11;
			this.lblNoGames.Text = "0 game(s)";
			this.lblNoGames.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
			this.ttMuSigma.SetToolTip(this.lblNoGames, "Total number of visible games/Total number of games loaded.");
			// 
			// gbOptions
			// 
			this.gbOptions.BackColor = System.Drawing.Color.FromArgb(((System.Byte)(192)), ((System.Byte)(192)), ((System.Byte)(255)));
			this.gbOptions.Controls.Add(this.lblGameView);
			this.gbOptions.Controls.Add(this.lblPlayerSorting);
			this.gbOptions.Controls.Add(this.lblRankingSystem);
			this.gbOptions.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.gbOptions.Location = new System.Drawing.Point(464, 576);
			this.gbOptions.Name = "gbOptions";
			this.gbOptions.Size = new System.Drawing.Size(376, 128);
			this.gbOptions.TabIndex = 12;
			this.gbOptions.TabStop = false;
			this.gbOptions.Text = "Current View";
			this.ttMuSigma.SetToolTip(this.gbOptions, "Currently selected parameters of the view. This can be changed in the View menu.");
			// 
			// lblGameView
			// 
			this.lblGameView.Font = new System.Drawing.Font("Lucida Sans Typewriter", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.lblGameView.Location = new System.Drawing.Point(16, 88);
			this.lblGameView.Name = "lblGameView";
			this.lblGameView.Size = new System.Drawing.Size(344, 23);
			this.lblGameView.TabIndex = 2;
			this.lblGameView.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
			this.ttMuSigma.SetToolTip(this.lblGameView, "Currently selected view criterium of games.");
			// 
			// lblPlayerSorting
			// 
			this.lblPlayerSorting.Font = new System.Drawing.Font("Lucida Sans Typewriter", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.lblPlayerSorting.Location = new System.Drawing.Point(16, 56);
			this.lblPlayerSorting.Name = "lblPlayerSorting";
			this.lblPlayerSorting.Size = new System.Drawing.Size(344, 23);
			this.lblPlayerSorting.TabIndex = 1;
			this.lblPlayerSorting.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
			this.ttMuSigma.SetToolTip(this.lblPlayerSorting, "Currently selected sorting criterium of players.");
			// 
			// lblRankingSystem
			// 
			this.lblRankingSystem.Font = new System.Drawing.Font("Lucida Sans Typewriter", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.lblRankingSystem.Location = new System.Drawing.Point(16, 24);
			this.lblRankingSystem.Name = "lblRankingSystem";
			this.lblRankingSystem.Size = new System.Drawing.Size(344, 23);
			this.lblRankingSystem.TabIndex = 0;
			this.lblRankingSystem.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
			this.ttMuSigma.SetToolTip(this.lblRankingSystem, "Currently selected ranking system.");
			// 
			// mainMenu1
			// 
			this.mainMenu1.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
																					  this.menuItem1,
																					  this.menuItem7,
																					  this.menuItem5,
																					  this.menuItem17});
			// 
			// menuItem1
			// 
			this.menuItem1.Index = 0;
			this.menuItem1.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
																					  this.menuReadGames,
																					  this.menuReadResults,
																					  this.menuSaveResults,
																					  this.menuItem11,
																					  this.menuQuickCommands,
																					  this.menuItem4,
																					  this.menuQuit});
			this.menuItem1.Text = "&File";
			// 
			// menuReadGames
			// 
			this.menuReadGames.Index = 0;
			this.menuReadGames.Text = "Read &Games ...";
			this.menuReadGames.Click += new System.EventHandler(this.menuReadGames_Click);
			// 
			// menuReadResults
			// 
			this.menuReadResults.Enabled = false;
			this.menuReadResults.Index = 1;
			this.menuReadResults.Text = "Read &Results ...";
			this.menuReadResults.Click += new System.EventHandler(this.menuReadResults_Click);
			// 
			// menuSaveResults
			// 
			this.menuSaveResults.Enabled = false;
			this.menuSaveResults.Index = 2;
			this.menuSaveResults.Text = "&Save Results";
			this.menuSaveResults.Click += new System.EventHandler(this.menuSaveResults_Click);
			// 
			// menuItem11
			// 
			this.menuItem11.Index = 3;
			this.menuItem11.Text = "-";
			// 
			// menuQuickCommands
			// 
			this.menuQuickCommands.Index = 4;
			this.menuQuickCommands.Text = "Q&uick Commands";
			this.menuQuickCommands.Click += new System.EventHandler(this.menuQuickCommands_Click);
			// 
			// menuItem4
			// 
			this.menuItem4.Index = 5;
			this.menuItem4.Text = "-";
			// 
			// menuQuit
			// 
			this.menuQuit.Index = 6;
			this.menuQuit.Text = "&Quit";
			this.menuQuit.Click += new System.EventHandler(this.menuQuit_Click);
			// 
			// menuItem7
			// 
			this.menuItem7.Index = 1;
			this.menuItem7.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
																					  this.menuRecomputeRanking,
																					  this.menuItem3,
																					  this.menuCompareSelectedPlayers,
																					  this.menuRankingDifference,
																					  this.menuMuSigmaLogProbability,
																					  this.menuDebugAdditionalSeparator,
																					  this.menuMuSigmaIterationsCheck,
																					  this.menuNumberOfIterations,
																					  this.menuExportEquivalentRankings,
																					  this.menuEvidenceAnalysis});
			this.menuItem7.Text = "Anal&yse";
			// 
			// menuRecomputeRanking
			// 
			this.menuRecomputeRanking.Index = 0;
			this.menuRecomputeRanking.Text = "&Recompute Ranking ...";
			this.menuRecomputeRanking.Click += new System.EventHandler(this.menuRecomputeRanking_Click);
			// 
			// menuItem3
			// 
			this.menuItem3.Index = 1;
			this.menuItem3.Text = "-";
			// 
			// menuCompareSelectedPlayers
			// 
			this.menuCompareSelectedPlayers.Index = 2;
			this.menuCompareSelectedPlayers.Text = "Compare &Selected Players";
			this.menuCompareSelectedPlayers.Click += new System.EventHandler(this.menuCompareSelectedPlayers_Click);
			// 
			// menuRankingDifference
			// 
			this.menuRankingDifference.Index = 3;
			this.menuRankingDifference.Text = "Ranking &Difference";
			this.menuRankingDifference.Click += new System.EventHandler(this.menuRankingDifference_Click);
			// 
			// menuMuSigmaLogProbability
			// 
			this.menuMuSigmaLogProbability.Index = 4;
			this.menuMuSigmaLogProbability.Text = "MuSigma Log &Probability";
			this.menuMuSigmaLogProbability.Click += new System.EventHandler(this.menuMuSigmaLogProbability_Click);
			// 
			// menuDebugAdditionalSeparator
			// 
			this.menuDebugAdditionalSeparator.Index = 5;
			this.menuDebugAdditionalSeparator.Text = "-";
			// 
			// menuMuSigmaIterationsCheck
			// 
			this.menuMuSigmaIterationsCheck.Index = 6;
			this.menuMuSigmaIterationsCheck.Text = "MuSigma &Iterations Check";
			this.menuMuSigmaIterationsCheck.Click += new System.EventHandler(this.menuMuSigmaIterationsCheck_Click);
			// 
			// menuNumberOfIterations
			// 
			this.menuNumberOfIterations.Index = 7;
			this.menuNumberOfIterations.Text = "&Iterations List";
			// 
			// menuExportEquivalentRankings
			// 
			this.menuExportEquivalentRankings.Index = 8;
			this.menuExportEquivalentRankings.Text = "Export &Equivalent Rankings";
			this.menuExportEquivalentRankings.Click += new System.EventHandler(this.menuExportEquivalentRankings_Click);
			// 
			// menuItem5
			// 
			this.menuItem5.Index = 2;
			this.menuItem5.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
																					  this.menuItem6,
																					  this.menuItem9,
																					  this.menuItem12});
			this.menuItem5.Text = "&View";
			// 
			// menuItem6
			// 
			this.menuItem6.Index = 0;
			this.menuItem6.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
																					  this.rbRawHalo2RankingResults,
																					  this.rbHalo2RankingResults,
																					  this.rbELORankingResults,
																					  this.rbMuSigmaRankingResults});
			this.menuItem6.Text = "&Ranking Results";
			this.menuItem6.Click += new System.EventHandler(this.rbRankingResults_Click);
			// 
			// rbRawHalo2RankingResults
			// 
			this.rbRawHalo2RankingResults.Index = 0;
			this.rbRawHalo2RankingResults.RadioCheck = true;
			this.rbRawHalo2RankingResults.Text = "Halo 2 Beta (raw data)";
			this.rbRawHalo2RankingResults.Click += new System.EventHandler(this.rbRankingResults_Click);
			// 
			// rbHalo2RankingResults
			// 
			this.rbHalo2RankingResults.Checked = true;
			this.rbHalo2RankingResults.Index = 1;
			this.rbHalo2RankingResults.RadioCheck = true;
			this.rbHalo2RankingResults.Text = "Halo 2 Beta";
			this.rbHalo2RankingResults.Click += new System.EventHandler(this.rbRankingResults_Click);
			// 
			// rbELORankingResults
			// 
			this.rbELORankingResults.Index = 2;
			this.rbELORankingResults.RadioCheck = true;
			this.rbELORankingResults.Text = "ELO";
			this.rbELORankingResults.Click += new System.EventHandler(this.rbRankingResults_Click);
			// 
			// rbMuSigmaRankingResults
			// 
			this.rbMuSigmaRankingResults.Index = 3;
			this.rbMuSigmaRankingResults.RadioCheck = true;
			this.rbMuSigmaRankingResults.Text = "MuSigma";
			this.rbMuSigmaRankingResults.Click += new System.EventHandler(this.rbRankingResults_Click);
			// 
			// menuItem9
			// 
			this.menuItem9.Index = 1;
			this.menuItem9.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
																					  this.rbAlphabeticalSorting,
																					  this.rbSkillSorting});
			this.menuItem9.Text = "&Player List";
			this.menuItem9.Click += new System.EventHandler(this.rbSkill_Click);
			// 
			// rbAlphabeticalSorting
			// 
			this.rbAlphabeticalSorting.Checked = true;
			this.rbAlphabeticalSorting.Index = 0;
			this.rbAlphabeticalSorting.RadioCheck = true;
			this.rbAlphabeticalSorting.Text = "&Alphabetical";
			this.rbAlphabeticalSorting.Click += new System.EventHandler(this.rbSkill_Click);
			// 
			// rbSkillSorting
			// 
			this.rbSkillSorting.Index = 1;
			this.rbSkillSorting.RadioCheck = true;
			this.rbSkillSorting.Text = "&Skill";
			this.rbSkillSorting.Click += new System.EventHandler(this.rbSkill_Click);
			// 
			// menuItem12
			// 
			this.menuItem12.Index = 2;
			this.menuItem12.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
																					   this.rbViewAllGames,
																					   this.rbViewSelectedGames,
																					   this.menuItem2,
																					   this.rbSelectPolicyOr,
																					   this.rbSelectPolicyAnd});
			this.menuItem12.Text = "&Game List";
			// 
			// rbViewAllGames
			// 
			this.rbViewAllGames.Index = 0;
			this.rbViewAllGames.RadioCheck = true;
			this.rbViewAllGames.Text = "&All Games";
			this.rbViewAllGames.Click += new System.EventHandler(this.rbViewGames_Click);
			// 
			// rbViewSelectedGames
			// 
			this.rbViewSelectedGames.Checked = true;
			this.rbViewSelectedGames.Index = 1;
			this.rbViewSelectedGames.RadioCheck = true;
			this.rbViewSelectedGames.Text = "&Selected Players ";
			this.rbViewSelectedGames.Click += new System.EventHandler(this.rbViewGames_Click);
			// 
			// menuItem2
			// 
			this.menuItem2.Index = 2;
			this.menuItem2.Text = "-";
			// 
			// rbSelectPolicyOr
			// 
			this.rbSelectPolicyOr.Checked = true;
			this.rbSelectPolicyOr.Index = 3;
			this.rbSelectPolicyOr.RadioCheck = true;
			this.rbSelectPolicyOr.Text = "At &Least One Player";
			this.rbSelectPolicyOr.Click += new System.EventHandler(this.rbSelectPolicy_Click);
			// 
			// rbSelectPolicyAnd
			// 
			this.rbSelectPolicyAnd.Index = 4;
			this.rbSelectPolicyAnd.RadioCheck = true;
			this.rbSelectPolicyAnd.Text = "&All Selected Players";
			this.rbSelectPolicyAnd.Click += new System.EventHandler(this.rbSelectPolicy_Click);
			// 
			// menuItem17
			// 
			this.menuItem17.Index = 3;
			this.menuItem17.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
																					   this.menuShowProgressWindow,
																					   this.menuShowPerformanceWindows,
																					   this.menuShowLogWindow,
																					   this.menuItem10,
																					   this.menuAttachWindows,
																					   this.menuPhasePlots,
																					   this.menuPlayersandGamesOnly,
																					   this.menuItem8,
																					   this.menuAbout});
			this.menuItem17.Text = "&Windows";
			// 
			// menuShowProgressWindow
			// 
			this.menuShowProgressWindow.Index = 0;
			this.menuShowProgressWindow.Text = "&Level-Progress Window";
			this.menuShowProgressWindow.Click += new System.EventHandler(this.menuShowProgressWindow_Click);
			// 
			// menuShowPerformanceWindows
			// 
			this.menuShowPerformanceWindows.Index = 1;
			this.menuShowPerformanceWindows.Text = "Performance Windows";
			this.menuShowPerformanceWindows.Click += new System.EventHandler(this.menuShowPerformanceWindows_Click);
			// 
			// menuShowLogWindow
			// 
			this.menuShowLogWindow.Index = 2;
			this.menuShowLogWindow.Text = "Lo&g Window";
			this.menuShowLogWindow.Click += new System.EventHandler(this.menuShowLogWindow_Click);
			// 
			// menuItem10
			// 
			this.menuItem10.Index = 3;
			this.menuItem10.Text = "-";
			// 
			// menuAttachWindows
			// 
			this.menuAttachWindows.Checked = true;
			this.menuAttachWindows.Index = 4;
			this.menuAttachWindows.Text = "Attach Progress Windows";
			this.menuAttachWindows.Click += new System.EventHandler(this.menuAttachWindows_Click);
			// 
			// menuPhasePlots
			// 
			this.menuPhasePlots.Index = 5;
			this.menuPhasePlots.Text = "Performance Phase Plots";
			this.menuPhasePlots.Click += new System.EventHandler(this.menuPhasePlots_Click);
			// 
			// menuPlayersandGamesOnly
			// 
			this.menuPlayersandGamesOnly.Index = 6;
			this.menuPlayersandGamesOnly.Text = "Player And Games List Only";
			this.menuPlayersandGamesOnly.Click += new System.EventHandler(this.menuPlayersandGamesOnly_Click);
			// 
			// menuItem8
			// 
			this.menuItem8.Index = 7;
			this.menuItem8.Text = "-";
			// 
			// menuAbout
			// 
			this.menuAbout.Index = 8;
			this.menuAbout.Text = "&About";
			this.menuAbout.Click += new System.EventHandler(this.menuAbout_Click);
			// 
			// pbProgress
			// 
			this.pbProgress.Location = new System.Drawing.Point(8, 8);
			this.pbProgress.Name = "pbProgress";
			this.pbProgress.Size = new System.Drawing.Size(944, 8);
			this.pbProgress.TabIndex = 18;
			this.pbProgress.Visible = false;
			// 
			// menuEvidenceAnalysis
			// 
			this.menuEvidenceAnalysis.Index = 9;
			this.menuEvidenceAnalysis.Text = "Evidence analysis ...";
			this.menuEvidenceAnalysis.Click += new System.EventHandler(this.menuEvidenceAnalysis_Click);
			// 
			// MainWindow
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.BackgroundImage = ((System.Drawing.Image)(resources.GetObject("$this.BackgroundImage")));
			this.ClientSize = new System.Drawing.Size(962, 736);
			this.Controls.Add(this.pbProgress);
			this.Controls.Add(this.gbOptions);
			this.Controls.Add(this.lblNoGames);
			this.Controls.Add(this.lblNoPlayers);
			this.Controls.Add(this.lblGameList);
			this.Controls.Add(this.lblPlayerList);
			this.Controls.Add(this.gbGameData);
			this.Controls.Add(this.lbGameList);
			this.Controls.Add(this.lbPlayerList);
			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle;
			this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
			this.MaximizeBox = false;
			this.Menu = this.mainMenu1;
			this.Name = "MainWindow";
			this.SizeChanged += new System.EventHandler(this.MainWindow_LocationChanged);
			this.LocationChanged += new System.EventHandler(this.MainWindow_LocationChanged);
			this.gbGameData.ResumeLayout(false);
			this.pnlGameInfo.ResumeLayout(false);
			this.gbOptions.ResumeLayout(false);
			this.ResumeLayout(false);

		}
		#endregion

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main() 
		{
			Application.Run (new MainWindow ());
		}

		#region Analyse Options Box code
		/// <summary>
		/// Gets the currently selected ranking system.
		/// </summary>
		/// <returns>A pointer to the respective menu-entry.</returns>
		private MenuItem SelectedRankingSystem ()
		{
			if (rbRawHalo2RankingResults.Checked) return rbRawHalo2RankingResults;
			if (rbHalo2RankingResults.Checked) return rbHalo2RankingResults;
			if (rbELORankingResults.Checked) return rbELORankingResults;
			if (rbMuSigmaRankingResults.Checked) return rbMuSigmaRankingResults;
			Debug.Assert (false, "Internal error: No ranking system selected!");
			return null;
		}

		/// <summary>
		/// Updates the options group box with the selected menu entries.
		/// </summary>
		private void UpdateOptionsBox ()
		{
			const string szFormatString = "{0,-20}: {1}";

			// ranking system
			lblRankingSystem.Text = String.Format (szFormatString, "Ranking system", SelectedRankingSystem ().Text);

			// sorting
			if (rbAlphabeticalSorting.Checked)
				lblPlayerSorting.Text = String.Format (szFormatString, "Sorting", rbAlphabeticalSorting.Text);
			if (rbSkillSorting.Checked)
				lblPlayerSorting.Text = String.Format (szFormatString, "Sorting", rbSkillSorting.Text);

			// games view
			if (rbViewAllGames.Checked)
				lblGameView.Text = String.Format (szFormatString, "Games", rbViewAllGames.Text);
			if (rbViewSelectedGames.Checked)
				lblGameView.Text = String.Format (szFormatString, "Games", rbViewSelectedGames.Text);
		}
		#endregion

		#region Game Data Box code
		/// <summary>
		/// Clears the game data group box.
		/// </summary>
		/// <param name="iStartIndex">The start index from which to start erasing fields.</param>
		private void ClearGameDataBox (int iStartIndex)
		{
			// set the group box title
			if (iStartIndex == 0)
				lblGameInfo.Text = "";

			// erase the remaining slots on the screen
			for (int i = iStartIndex; i < 16; i++) 
			{
				lblPlayerNames [i].Text = "";
				lblPlayerScore [i].Text = "";
				lblPlayerLevel [i].Text = "";
				gcExperienceBar [i]. Clear (Color.AntiqueWhite);
				gcExperienceBar [i]. Flush ();
			}
		}

		/// <summary>
		/// Clears the game data group box fully.
		/// </summary>
		private void ClearGameDataBox ()
		{
			ClearGameDataBox (0);		
		}

		/// <summary>
		/// Redraws the game data group box. This includes clearing the empty entries.
		/// </summary>
		private void UpdateGameDataGroupdBox ()
		{
			// check that a game is selected
			if (lbGameList.SelectedIndex == -1)
				return;

			// get the game
			Halo2Game aGame = m_aGameList.GetGame (m_iViewedGameID [lbGameList.SelectedIndex]);

			// show the extra info in the game data title
			lblGameInfo.Text = aGame.Map + " - " + aGame.Variant + " - " + aGame.Hopper; 

			// resort the teams such that the top ranks are on top
			int [] iTeamIndex = aGame.Ranking.Indicies;

			// go through it team by team
			int iTotalPlayerCounter = 0;
			for (int iTeamCounter = 0; iTeamCounter < aGame.NumberOfTeams; iTeamCounter++) 
			{
				// get the current team
				Team aTeam = aGame.GetTeam (iTeamIndex [iTeamCounter]);

				// reorder the team by team scores
				int [] iPlayerIndex = new int [aTeam.NumberOfPlayers];
				for (int i = 0; i < aTeam.NumberOfPlayers; i++) iPlayerIndex [i] = i;
				Array.Sort (aTeam.PlayerScores, iPlayerIndex);

				// determine the team's colour
				System.Drawing.Color aColor = System.Drawing.Color.Red;
				switch (iTeamIndex [iTeamCounter])
				{
					case 0: aColor = System.Drawing.Color.Red; break;
					case 1: aColor = System.Drawing.Color.Blue; break;
					case 2: aColor = System.Drawing.Color.Green; break;
					case 3: aColor = System.Drawing.Color.Purple; break;
					case 4: aColor = System.Drawing.Color.Brown; break;
					case 5: aColor = System.Drawing.Color.Magenta; break;
					case 6: aColor = System.Drawing.Color.DarkCyan; break;
					case 7: aColor = System.Drawing.Color.DarkGoldenrod; break;
					case 8: aColor = System.Drawing.Color.YellowGreen; break;
					case 9: aColor = System.Drawing.Color.Salmon; break;
					case 10: aColor = System.Drawing.Color.Black; break;
					case 11: aColor = System.Drawing.Color.White; break;
					case 12: aColor = System.Drawing.Color.SlateGray; break;
					case 13: aColor = System.Drawing.Color.Tomato; break;
					case 14: aColor = System.Drawing.Color.Khaki; break;
					case 15: aColor = System.Drawing.Color.Maroon; break;
					default: Debug.Assert (false, "Number of teams exceeds number of different colours."); break;
				}

				// get the current player skills list
				PlayerSkillsList aCurrentSkillList = m_aCurrentRankingSystem.PlayerSkillsList;

				// loop through all players in the team
				for (int iPlayerCounter = aTeam.NumberOfPlayers - 1; iPlayerCounter >= 0; iPlayerCounter--, iTotalPlayerCounter++) 
				{
					// get the global player ID
					int iPlayerID = aTeam.GetPlayerID (iPlayerIndex [iPlayerCounter]);

					// fill the text slot with gamertag, team score and player score
					lblPlayerNames [iTotalPlayerCounter].Text = String.Format ("[{0}]   {1,-20}", 
						aTeam.TeamScore, m_aPlayerList.GetPlayerName (iPlayerID));
					lblPlayerScore [iTotalPlayerCounter].Text = String.Format ("({0})", 
						aTeam.GetPlayerScore (iPlayerIndex [iPlayerCounter]));
					lblPlayerNames [iTotalPlayerCounter].ForeColor = aColor;
					lblPlayerScore [iTotalPlayerCounter].ForeColor = aColor;

					// add the current ranking's skill estimate
					Skill aSkill = (Skill) aCurrentSkillList.GetPlayerSkills (iPlayerID).GetLatestSkill (aGame.Date);

					// display all information 
					gcExperienceBar [iTotalPlayerCounter].Clear (Color.White);
					gcExperienceBar [iTotalPlayerCounter].FillRectangle (new SolidBrush (aColor), 
						0, 0, 
						(int) Math.Ceiling (aSkill.FractionalLevel * pbExperienceBar [iTotalPlayerCounter].Width), 
						pbExperienceBar [iTotalPlayerCounter].Height);
					gcExperienceBar [iTotalPlayerCounter].Flush ();

					lblPlayerLevel [iTotalPlayerCounter].Text = "Lvl " + aSkill.Level.ToString ();
					lblPlayerLevel [iTotalPlayerCounter].ForeColor = aColor;
				}
			}

			// clear the remaining items data box
			ClearGameDataBox (iTotalPlayerCounter);
		}
		#endregion
		
		#region Player and Games List Box code
		/// <summary>
		/// Update the player and game list box.
		/// </summary>
		/// <param name="bUpdatePlayerList">Determines if the player list box should be updated.</param>
		/// <param name="bUpdateGameList">Determines if the game list box should be updated.</param>
		private void UpdateListBoxes (bool bUpdatePlayerList, bool bUpdateGameList)
		{
			if (bUpdatePlayerList)
			{
				////////////////////////////////////////////////////////////
				// save the old selection
				////////////////////////////////////////////////////////////
				string [] szOldSelection = null;
				if (lbPlayerList.SelectedIndices.Count > 0) 
				{
					szOldSelection = new string [lbPlayerList.SelectedIndices.Count];
					for (int i = 0; i < szOldSelection.Length; i++)
						szOldSelection [i] = (string) lbPlayerList.SelectedItems [i];
				}

				// update the player list box
				lbPlayerList.Items.Clear ();

				///////////////////////////////////////////////////////////
				// alphabetical sorting
				///////////////////////////////////////////////////////////
				if (rbAlphabeticalSorting.Checked) 
				{
					string [] szPlayerNames = m_aPlayerList.PlayerNames;
					Array.Sort (szPlayerNames);
					lbPlayerList.Items.AddRange (szPlayerNames);
				}

				///////////////////////////////////////////////////////////
				// skill sorting
				///////////////////////////////////////////////////////////
				if (rbSkillSorting.Checked) 
				{
					string [] szPlayerNames = m_aPlayerList.PlayerNames;
					double [] dSkillPoints = new double [szPlayerNames.Length];
					PlayerSkillsList aCurrentSkillsList = m_aCurrentRankingSystem.PlayerSkillsList;
					for (int i = 0; i < dSkillPoints.Length; i++) 
					{ 
						Skill aSkill = aCurrentSkillsList.GetPlayerSkills (m_aPlayerList.GetPlayerID (szPlayerNames [i])).LatestSkill;
						dSkillPoints [i] = (aSkill == null)?0.0:-aSkill.Points;
					}
					Array.Sort (dSkillPoints, szPlayerNames);
					lbPlayerList.Items.AddRange (szPlayerNames);
				}

				////////////////////////////////////////////////////////////
				// restore the old selection
				////////////////////////////////////////////////////////////
				
				if (szOldSelection != null)
				{
					for (int iOldSelectionIndex = 0; iOldSelectionIndex < szOldSelection.Length; iOldSelectionIndex++) 
						for (int i = 0; i < lbPlayerList.Items.Count; i++)
							if (String.Compare (szOldSelection [iOldSelectionIndex], (string) lbPlayerList.Items [i]) == 0)
								lbPlayerList.SetSelected (i, true);
				}

				// give some extra information about the length of the player list
				lblNoPlayers.Text = lbPlayerList.Items.Count.ToString () + " player(s)";
			}

			if (bUpdateGameList)
			{
				// update the game list
				lbGameList.Items.Clear ();
				for (int i = 0; i < m_iViewedGameID.Length; i++)  
				{
					Halo2Game aGame = m_aGameList.GetGame (m_iViewedGameID [i]);
					lbGameList.Items.Add (aGame.Date.ToLongDateString () + "\t" + aGame.Date.ToLongTimeString ());
				}

				// change the colour style to indicate if the full list is show
				if (m_iViewedGameID.Length == m_aGameList.NumberOfGames) 
					lbGameList.BackColor = Color.Wheat;
				else
					lbGameList.BackColor = Color.White;

				// give some extra info about the number of currently selected games and the total number of games
				lblNoGames.Text = lbGameList.Items.Count.ToString () + " out of " + m_aGameList.NumberOfGames.ToString () + " game(s)";
			}

			// done!
			return;
		}

		/// <summary>
		/// Recomputes the <c>m_aGamesPlayed</c> list.
		/// </summary>
		private void ComputeCrossReferenceList ()
		{
			// re-allocate the memory
			m_aGamesPlayed = new ArrayList [m_aPlayerList.NumberOfPlayers];
			for (int i = 0; i <m_aPlayerList.NumberOfPlayers; i++)
				m_aGamesPlayed [i] = new ArrayList ();

			// loop through all games and update the respective lists
			for (int iGameCount = 0; iGameCount < m_aGameList.NumberOfGames; iGameCount++)
			{
				int [] aPlayerIDs = m_aGameList.GetGame (iGameCount).PlayerIDs;

				for (int i = 0; i < aPlayerIDs.Length; i++)
					m_aGamesPlayed [aPlayerIDs [i]].Add (iGameCount);
			}

			// done!
			return;
		}

		/// <summary>
		/// Computes the new (sub)-selection of games and re-displays them.
		/// </summary>
		private void ComputeNewSelection ()
		{
			if (rbViewAllGames.Checked)
			{
				// adjust the label
				lblGameList.Text = "Game List";

				// fill the entire list if no players are selected
				m_iViewedGameID = new int [m_aGameList.NumberOfGames];
				for (int i = 0; i < m_aGameList.NumberOfGames; i++)
					m_iViewedGameID [i] = i;
			}

			if (rbViewSelectedGames.Checked)
			{
				// adjust the label
				lblGameList.Text = "Game List (filtered)";

				// if there are no players selected then do not show any games
				if (lbPlayerList.SelectedItems.Count == 0) 
					m_iViewedGameID = new int [0];
				else 
				{

					ArrayList aTotalList = new ArrayList ();
					if (rbSelectPolicyOr.Checked) 
					{
						// select the games where at least one of the selected players participated
						for (int i = 0; i < lbPlayerList.SelectedItems.Count; i++)
						{
							int iPlayerID = m_aPlayerList.GetPlayerID ((string) lbPlayerList.SelectedItems [i]);
							for (int j = 0; j < m_aGamesPlayed [iPlayerID].Count; j++)
								if (!aTotalList.Contains (m_aGamesPlayed [iPlayerID] [j]))
									aTotalList.Add (m_aGamesPlayed [iPlayerID] [j]);
						}
					}

					if (rbSelectPolicyAnd.Checked)
					{
						int iPlayerID = m_aPlayerList.GetPlayerID ((string) lbPlayerList.SelectedItems [0]);
						aTotalList.AddRange (m_aGamesPlayed [iPlayerID]);
						for (int i = 1; i < lbPlayerList.SelectedItems.Count; i++)
						{
							iPlayerID = m_aPlayerList.GetPlayerID ((string) lbPlayerList.SelectedItems [i]);
							for (int j = 0; j < aTotalList.Count; j++)
								if (!m_aGamesPlayed [iPlayerID].Contains (aTotalList [j]))
									aTotalList.RemoveAt (j--);
						}
					}

					// sort the list chronologically
					m_iViewedGameID = (int []) aTotalList.ToArray (typeof (int));
					DateTime [] aDateList = new DateTime [m_iViewedGameID.Length];
					for (int i = 0; i < m_iViewedGameID.Length; i++)
						aDateList [i] = m_aGameList.GetGame (m_iViewedGameID [i]).Date;
					Array.Sort (aDateList, m_iViewedGameID);
				}
			}

			// delete the game data display
			ClearGameDataBox ();

			// update the list boxes
			UpdateListBoxes (false, true);
		}
		#endregion

		#region SQL import and export code
		/// <summary>
		/// Builds the player list by reading from the current SQL database.
		/// </summary>
		private void ReadPlayerNames ()
		{
			// open SQL connection
			SqlConnection aSQLConnection = new SqlConnection ("Initial Catalog = " + m_aSQLImportDialog.DatabaseName + "; Data Source = " + 
				m_aSQLImportDialog.SQLServerName + "; Integrated Security = SSPI");
			aSQLConnection.Open ();

			// read the data from the SQL database
			DataSet aPlayerTable = new DataSet ();
			if (m_aSQLImportDialog.UsePlayerFlags)
			{
				SqlCommand aPlayerTableCommand = new 
					SqlCommand ("select distinct(tPlayers.gamertag),tPlayers.player_id,tPlayers.player_flags " + 
					"from tPlayerGames " +
					"join tGames on tPlayerGames.game_id = tGames.game_id " + 
					"join tPlayers on tPlayerGames.player_id = tPlayers.player_id and tPlayerGames.player_flags = tPlayers.player_flags " +
					m_aSQLImportDialog.SQLFilterString, aSQLConnection);
				aPlayerTableCommand.CommandTimeout = 0;
				SqlDataAdapter aPlayerTableAdapter = new SqlDataAdapter (aPlayerTableCommand);
				aPlayerTableAdapter.Fill (aPlayerTable);
			} 
			else 
			{
				SqlCommand aPlayerTableCommand = new 
					SqlCommand ("select distinct(tPlayers.gamertag),tPlayers.player_id " + 
					"from tPlayerGames " +
					"join tGames on tPlayerGames.game_id = tGames.game_id " + 
					"join tPlayers on tPlayerGames.player_id = tPlayers.player_id " +
					m_aSQLImportDialog.SQLFilterString, aSQLConnection);
				aPlayerTableCommand.CommandTimeout = 0;
				SqlDataAdapter aPlayerTableAdapter = new SqlDataAdapter (aPlayerTableCommand);
				aPlayerTableAdapter.Fill (aPlayerTable);
			}
			DataRowCollection aCollection = aPlayerTable.Tables [0].Rows;

			// clear all the lists
			m_aHalo2PlayerIDToInternalPlayerID.Clear ();
			m_aInternalPlayerIDToHalo2PlayerID.Clear ();
			m_aPlayerList.Clear ();
			m_aRawHalo2RankingSystem.PlayerSkillsList.Clear ();
			m_aHalo2RankingSystem.PlayerSkillsList.Clear ();
			m_aELORankingSystem.PlayerSkillsList.Clear ();
			m_aMuSigmaRankingSystem.PlayerSkillsList.Clear ();

			// initialise the progress bar
			int iNumberOfPlayersPerStep = (aCollection.Count > 2 * m_iProgressBarGranularity)?aCollection.Count / m_iProgressBarGranularity:1;
			pbProgress.Visible = true;
			pbProgress.Maximum = (aCollection.Count > 2 * m_iProgressBarGranularity)?m_iProgressBarGranularity:aCollection.Count;
			pbProgress.Step = 1;
			pbProgress.Minimum = 0;
			pbProgress.Value = 0;
				
			// main loop to read player names
			for (int iCnt = 0; iCnt < aCollection.Count; iCnt++)
			{
				// get the data row
				DataRow aRow = aCollection [iCnt];

				// get the gamertag
				string szGamerTag = aRow ["gamertag"].ToString ().Trim ();
				int iPlayerID = -1;

				// try to add the player and append a number if he/she exists already
				for (int i = 0; (i == 0) || (iPlayerID == -1); i++)
				{
					if (i == 0)
						iPlayerID = m_aPlayerList.AddPlayer (szGamerTag);
					else	
						iPlayerID = m_aPlayerList.AddPlayer (szGamerTag + " [" + i.ToString () + "]");

					if (iPlayerID == -1)
						m_aLogWindow.AddLine ("Player " + szGamerTag + " exists already. Trying " + 
							szGamerTag + " [" + (i + 1).ToString () + "]");
				}

				// create the relation between internal and Halo 2 player IDs
				string szHalo2PlayerID = null;
				if (m_aSQLImportDialog.UsePlayerFlags)
				{
					szHalo2PlayerID = aRow ["player_id"].ToString () + "@" + aRow ["player_flags"].ToString ();
				} 
				else 
				{
					szHalo2PlayerID = aRow ["player_id"].ToString ();
				}
				m_aHalo2PlayerIDToInternalPlayerID [szHalo2PlayerID] = iPlayerID;
				m_aInternalPlayerIDToHalo2PlayerID [iPlayerID] = szHalo2PlayerID;

				// add the individual player skill lists to the several lists of player skill lists
				m_aRawHalo2RankingSystem.PlayerSkillsList.AddPlayerSkills (new PlayerSkills (), iPlayerID);
				m_aHalo2RankingSystem.PlayerSkillsList.AddPlayerSkills (new PlayerSkills (), iPlayerID);
				m_aELORankingSystem.PlayerSkillsList.AddPlayerSkills (new PlayerSkills (), iPlayerID);
				m_aMuSigmaRankingSystem.PlayerSkillsList.AddPlayerSkills (new PlayerSkills (), iPlayerID);

				// update progress bar
				if (iCnt % iNumberOfPlayersPerStep == 0)
					pbProgress.PerformStep ();
			}

			// make the progres bar invisible
			pbProgress.Visible = false;

			// close SQL connection
			aSQLConnection.Close ();
		}

		/// <summary>
		/// Reads all games from the current SQL database. 
		/// </summary>
		/// <remarks>This function assumes that the player list is already populated.</remarks>
		private void ReadGames ()
		{
			// open SQL connection
			SqlConnection aSQLConnection = new SqlConnection ("Initial Catalog = " + m_aSQLImportDialog.DatabaseName + "; Data Source = " + 
				m_aSQLImportDialog.SQLServerName + "; Integrated Security = SSPI");
			aSQLConnection.Open ();

			// read the data from the SQL database
			DataSet aPlayerGamesTable = new DataSet ();
			if (m_aSQLImportDialog.UsePlayerFlags)
			{
				SqlCommand aPlayerGamesTableCommand = new 
					SqlCommand ("select tGames.game_id,tGames.game_time,tPlayerGames.player_id,tPlayerGames.player_flags,tPlayerGames.team,tPlayerGames.Standing,tPlayerGames.score,tPlayerGames.experience,tPlayerGames.skill_level,tGames.game_hopper,tGames.game_variant,tGames.game_map " + 
					"from tPlayerGames " +  
					"join tGames on tPlayerGames.game_id = tGames.game_id " + 
					m_aSQLImportDialog.SQLFilterString + " " + 
					"order by tGames.game_time", aSQLConnection);
				aPlayerGamesTableCommand.CommandTimeout = 0;
				SqlDataAdapter aPlayerGamesTableAdapter = new SqlDataAdapter (aPlayerGamesTableCommand);
				aPlayerGamesTableAdapter.Fill (aPlayerGamesTable);
			}
			else			
			{
				SqlCommand aPlayerGamesTableCommand = new 
					SqlCommand ("select tGames.game_id,tGames.game_time,tPlayerGames.player_id,tPlayerGames.team,tPlayerGames.Standing,tPlayerGames.score,tPlayerGames.experience,tPlayerGames.skill_level,tGames.game_hopper,tGames.game_variant,tGames.game_map " + 
					"from tPlayerGames " +  
					"join tGames on tPlayerGames.game_id = tGames.game_id " + 
					m_aSQLImportDialog.SQLFilterString + " " + 
					"order by tGames.game_time", aSQLConnection);
				aPlayerGamesTableCommand.CommandTimeout = 0;
				SqlDataAdapter aPlayerGamesTableAdapter = new SqlDataAdapter (aPlayerGamesTableCommand);
				aPlayerGamesTableAdapter.Fill (aPlayerGamesTable);
			}
			DataRowCollection aCollection = aPlayerGamesTable.Tables [0].Rows;

			// initialise the progress bar and log window
			int iNumberOfGamesPerStep = (aCollection.Count > 2 * m_iProgressBarGranularity)?aCollection.Count / m_iProgressBarGranularity:1;
			pbProgress.Visible = true;
			pbProgress.Maximum = (aCollection.Count > 2 * m_iProgressBarGranularity)?m_iProgressBarGranularity:aCollection.Count;
			pbProgress.Step = 1;
			pbProgress.Minimum = 0;
			pbProgress.Value = 0;
	
			// clear the list of games
			m_aGameList.Clear ();

			// prepare the addition of games
			int iCurrentGameID = -1;
			int iTotalNoGames = 0;
			Halo2Game aHalo2Game = null;

			// cycle through the sorted player games table one line by one
			for (int iCnt = 0; iCnt < aCollection.Count; iCnt++)
			{
				// get the data row
				DataRow aRow = aCollection [iCnt];
 
				// should we start accumulating the information of a new game?
				if (iCurrentGameID != (int) aRow ["game_id"])
				{
					// is there already a game?
					if (iCurrentGameID != -1)
					{
						// prune the teams
						aHalo2Game.RemoveEmptyTeams ();

						// ... then add it to the game list
						m_aGameList.AddGame (aHalo2Game);
						iTotalNoGames++;
					}

					DateTime aNewDate = Convert.ToDateTime (aRow ["game_time"]);
					if (aHalo2Game != null && aHalo2Game.Date >= aNewDate) 
					{
						aHalo2Game = new Halo2Game (aHalo2Game.Date.AddSeconds (1), 
							m_aSQLImportDialog.GetMapName ((int) aRow ["game_map"]), 
							m_aSQLImportDialog.GetVariantName ((short) aRow ["game_variant"]), 
							m_aSQLImportDialog.GetHopperName ((short) aRow ["game_hopper"]));
						m_aLogWindow.AddLine ("Game at " + aNewDate.ToLongDateString () + " " + 
							aNewDate.ToLongTimeString () + " exists already. Added 1 artificial second.");
					}
					else
						aHalo2Game = new Halo2Game (aNewDate,
							m_aSQLImportDialog.GetMapName ((int) aRow ["game_map"]), 
							m_aSQLImportDialog.GetVariantName ((short) aRow ["game_variant"]), 
							m_aSQLImportDialog.GetHopperName ((short) aRow ["game_hopper"]));
					iCurrentGameID = (int) aRow ["game_id"];
				}

				// get the information from the player games table
				string szHalo2PlayerID = null;
				if (m_aSQLImportDialog.UsePlayerFlags)
				{
					szHalo2PlayerID = aRow ["player_id"].ToString () + "@" + aRow ["player_flags"].ToString ();
				}
				else
				{
					szHalo2PlayerID = aRow ["player_id"].ToString ();
				}
				int iPlayerID = (int) m_aHalo2PlayerIDToInternalPlayerID [szHalo2PlayerID];
				short iScore = (short) aRow ["score"];
				short iTeamID = (short) aRow ["team"];

				if (iTeamID >= 0) 
				{
					// potentially fill up the number of teams and then add the player
					for (int i = aHalo2Game.NumberOfTeams; i <= iTeamID; i++) aHalo2Game.AddTeam (new Team (i));
					aHalo2Game.GetTeam (iTeamID).AddPlayer (iPlayerID, iScore);

					// add the raw HALO 2 skills
					int iExperiencePoints = (int) aRow ["experience"];
					short iLevel = (short) aRow ["skill_level"];
					m_aRawHalo2RankingSystem.PlayerSkillsList.GetPlayerSkills (iPlayerID).AddSkill (new Halo2Skill (iExperiencePoints, iLevel), aHalo2Game.Date);
				}
				else
					m_aLogWindow.AddLine ("TeamID " + iTeamID.ToString () + " encountered. Ignored.");

				// perform a progress bar step
				if (iCnt % iNumberOfGamesPerStep == 0)
					pbProgress.PerformStep ();
			}																	   

			// make all games visible
			m_iViewedGameID = new int [iTotalNoGames];
			for (int i = 0; i < m_iViewedGameID.Length; i++)
				m_iViewedGameID [i] = i;

			// make the progres bar invisible
			pbProgress.Visible = false;

			// close SQL connection
			aSQLConnection.Close ();

			// if no games could be loaded then give a message on screen
			if (m_aGameList.NumberOfGames == 0)
				MessageBox.Show ("No games with these setting available.");
		}

		/// <summary>
		/// Reads new player and game data from a SQL database using the information stored in the SQL Dialog.
		/// </summary>
		/// <param name="bShowLog">Indicates if the log should be shown.</param>
		private void ReadSQLData (bool bShowLog)
		{
			// clear the log information list
			m_aLogWindow.ClearLogList ();
			m_aLogWindow.LogName = "SQL Import Log";

			// read the player data
			ReadPlayerNames ();

			// read the games data
			ReadGames ();

			// get available results
			GetAvailableResults ();

			// possibly recompute the ranking systems
			if (m_aResultImportDialog.NumnberOfResults == 0 || ReadResults () == false) 
			{ 
				m_aRankingParameters.ShowDialog (false);
				RecomputeRankingSystems (true);
			}

			// re-computes the cross-reference list
			ComputeCrossReferenceList ();

			// update the player and game list box 
			UpdateListBoxes (true, false);

			// re-computes the cross-reference list
			ComputeNewSelection ();

			// show the log window
			if (bShowLog) m_aLogWindow.ShowDialog ();
		}

		/// <summary>
		/// Puts all available results into the results import form.
		/// </summary>
		/// <remarks>This function enables/disables the 'Read results' menu entry.</remarks>
		private void GetAvailableResults ()
		{
			// clear all previous results from the import dialog
			m_aResultImportDialog.Clear ();

			// potentially create the results table 
			CreateResultTables ();

			// open SQL connection
			SqlConnection aSQLConnection = new SqlConnection ("Initial Catalog = " + m_aSQLImportDialog.DatabaseName + "; Data Source = " + 
				m_aSQLImportDialog.SQLServerName + "; Integrated Security = SSPI");
			aSQLConnection.Open ();

			// read all the results
			SqlCommand aResultsTableCommand = new 
				SqlCommand ("select res_id,res_date from tResults " +  
				m_aSQLImportDialog.SQLFilterString, aSQLConnection);
			aResultsTableCommand.CommandTimeout = 0;
			SqlDataAdapter aResultsTableAdapter = new SqlDataAdapter (aResultsTableCommand);
			DataSet aResultsTable = new DataSet ();
			aResultsTableAdapter.Fill (aResultsTable);

			// closes the SQL connection
			aSQLConnection.Close ();

			// check that there is at least one result, otherwise just return
			if (aResultsTable.Tables [0].Rows.Count == 0) 
			{
				menuReadResults.Enabled = false;
				return;
			}

			// open SQL connection
			aSQLConnection = new SqlConnection ("Initial Catalog = " + m_aSQLImportDialog.DatabaseName + "; Data Source = " + 
				m_aSQLImportDialog.SQLServerName + "; Integrated Security = SSPI");
			aSQLConnection.Open ();

			// populate the results import window
			foreach (DataRow aRow in aResultsTable.Tables [0].Rows)
			{
				// read all the parameters from the parameters table
				SqlCommand aParametersTableCommand = new 
					SqlCommand ("select param_name,param_value from tParameters where res_id = " + aRow ["res_id"].ToString (), aSQLConnection);
				aParametersTableCommand.CommandTimeout = 0;
				SqlDataAdapter aParametersTableAdapter = new SqlDataAdapter (aParametersTableCommand);
				DataSet aParametersTable = new DataSet ();
				aParametersTableAdapter.Fill (aParametersTable);

				// create the informations string
				string [] szInformation = new string [aParametersTable.Tables [0].Rows.Count];
				int iCnt = 0;
				foreach (DataRow aParameterRow in aParametersTable.Tables [0].Rows)
					szInformation [iCnt++] = aParameterRow ["param_name"].ToString ().Trim () + " = " + aParameterRow ["param_value"].ToString ().Trim ();

				// add the new information to the results import dialog
				m_aResultImportDialog.AddResult (aRow ["res_date"].ToString (), szInformation, (int) aRow ["res_id"]);
			}
			// closes the SQL connection
			aSQLConnection.Close ();

			// enable the 'Read Results' menu entry
			menuReadResults.Enabled = true;
		}
		
		/// <summary>
		/// Creates the result tables if they do not exist in the database or does nothing otherwise.
		/// </summary>
		private void CreateResultTables ()
		{
			// open SQL connection
			SqlConnection aSQLConnection = new SqlConnection ("Initial Catalog = " + m_aSQLImportDialog.DatabaseName + "; Data Source = " + 
				m_aSQLImportDialog.SQLServerName + "; Integrated Security = SSPI");
			aSQLConnection.Open ();

			// create the "create tables" commands
			SqlCommand aCreateResultsTableCommand = new 
				SqlCommand ("create table dbo.tResults (res_id int primary key not null, res_date datetime not null, res_type int not null default 1, " + 
				"game_map int, game_variant smallint, game_hopper smallint)", aSQLConnection);
			SqlCommand aCreateParametersTableCommand = new 
				SqlCommand ("create table dbo.tParameters (res_id int not null, param_name char(255) not null, param_value char(1024) not null, " + 
				"primary key (res_id, param_name))", aSQLConnection);
			SqlCommand aCreateMSRankingsTableCommand = new 
				SqlCommand ("create table dbo.tMSRankings (res_id int not null, player_id bigint not null, player_flags int not null, no_teams int not null, rank_date datetime not null, " + 
				"mu float not null, sigma float not null, primary key (res_id, player_id, player_flags, rank_date))", aSQLConnection);
			SqlCommand aCreateELORankingsTableCommand = new 
				SqlCommand ("create table dbo.tELORankings (res_id int not null, player_id bigint not null, player_flags int not null, rank_date datetime not null, " + 
				"score float not null, primary key (res_id, player_id, player_flags, rank_date))", aSQLConnection);
			SqlCommand aCreateHalo2RankingsTableCommand = new 
				SqlCommand ("create table dbo.tH2Rankings (res_id int not null, player_id bigint not null, player_flags int not null, rank_date datetime not null, " + 
				"exp_pts int not null, level int not null, primary key (res_id, player_id, player_flags, rank_date))", aSQLConnection);

			// execute the commands
			try 
			{
				aCreateResultsTableCommand.ExecuteNonQuery ();
				m_aLogWindow.AddLine ("Create an empty results table.");
			}
			catch
			{
			}

			try 
			{
				aCreateParametersTableCommand.ExecuteNonQuery ();
				m_aLogWindow.AddLine ("Create an empty parameters table.");
			}
			catch 
			{
			}

			try 
			{
				aCreateHalo2RankingsTableCommand.ExecuteNonQuery ();
				m_aLogWindow.AddLine ("Create an empty Halo 2 rankings table.");
			}
			catch 
			{
			}

			try 
			{
				aCreateELORankingsTableCommand.ExecuteNonQuery ();
				m_aLogWindow.AddLine ("Create an empty ELO rankings table.");
			}
			catch 
			{
			}

			try 
			{
				aCreateMSRankingsTableCommand.ExecuteNonQuery ();
				m_aLogWindow.AddLine ("Create an empty MuSigma rankings table.");
			}
			catch 
			{
			}

			// close the connection
			aSQLConnection.Close ();
		}

		#region Parameter strings
		/// <summary>
		/// Unique parameter string for the 'MuSigma' Beta parameter.
		/// </summary>
		private const string m_szMuSigmaBeta = "MuSigmaBeta";
		/// <summary>
		/// Unique parameter string for the 'MuSigma' Epsilon parameter.
		/// </summary>
		private const string m_szMuSigmaEpsilon = "MuSigmaEpsilon";
		/// <summary>
		/// Unique parameter string for the 'MuSigma' Tau parameter.
		/// </summary>
		private const string m_szMuSigmaTau = "MuSigmaTau";
		/// <summary>
		/// Unique parameter string for the 'MuSigma' Iterations parameter.
		/// </summary>
		private const string m_szMuSigmaIterations = "MuSigmaIterations";
		/// <summary>
		/// Unique parameter string for the 'MuSigma' Approximation algorithm parameter.
		/// </summary>
		private const string m_szMuSigmaApproximationAlgorithm = "MuSigmaApproximationAlgorithm";
		/// <summary>
		/// Unique parameter string for the 'ELO' Beta parameter.
		/// </summary>
		private const string m_szELOBeta = "ELOBeta";
		/// <summary>
		/// Unique parameter string for the 'ELO' Alpha parameter.
		/// </summary>
		private const string m_szELOAlpha = "ELOAlpha";
		#endregion 

		/// <summary>
		/// Checks if there are pre-computed results and reads them from the SQL database.
		/// </summary>
		/// <returns>Returns <c>True</c> if the results were already read in.</returns>
		private bool ReadResults ()
		{
			// get the available results
			GetAvailableResults ();

			// put the results window on the screen and ask the user 
			if (m_aResultImportDialog.ShowDialog () == DialogResult.OK)
			{
				//////////////////////////////////////////////////////////////////////////////
				// open the SQL database
				//////////////////////////////////////////////////////////////////////////////

				SqlConnection aSQLConnection = new SqlConnection ("Initial Catalog = " + m_aSQLImportDialog.DatabaseName + "; Data Source = " + 
					m_aSQLImportDialog.SQLServerName + "; Integrated Security = SSPI");
				aSQLConnection.Open ();

				//////////////////////////////////////////////////////////////////////////////
				// read the parameters
				//////////////////////////////////////////////////////////////////////////////
				
				string [] szInformation = m_aResultImportDialog.SelectedResultInformations;
				for (int i = 0; i < szInformation.Length; i++) 
				{
					if (szInformation [i].Split ('=') [0].Trim ().CompareTo (m_szELOBeta) == 0) 
					{
						m_aRankingParameters.ELOBeta = Convert.ToDouble (szInformation [i].Split ('=') [1].Trim ());
						m_aELORankingSystem.Beta = m_aRankingParameters.ELOBeta;
					}
					if (szInformation [i].Split ('=') [0].Trim ().CompareTo (m_szELOAlpha) == 0) 
					{
						m_aRankingParameters.ELOAlpha = Convert.ToDouble (szInformation [i].Split ('=') [1].Trim ());
						m_aELORankingSystem.Alpha = m_aRankingParameters.ELOAlpha;
					}
					if (szInformation [i].Split ('=') [0].Trim ().CompareTo (m_szMuSigmaBeta) == 0) 
					{
						m_aRankingParameters.MuSigmaBeta = Convert.ToDouble (szInformation [i].Split ('=') [1].Trim ());
						m_aMuSigmaRankingSystem.Beta = m_aRankingParameters.MuSigmaBeta;
					}
					if (szInformation [i].Split ('=') [0].Trim ().CompareTo (m_szMuSigmaEpsilon) == 0) 
					{
						m_aRankingParameters.MuSigmaEpsilon = Convert.ToDouble (szInformation [i].Split ('=') [1].Trim ());
						m_aMuSigmaRankingSystem.Epsilon = m_aRankingParameters.MuSigmaEpsilon;
					}
					if (szInformation [i].Split ('=') [0].Trim ().CompareTo (m_szMuSigmaTau) == 0) 
					{
						m_aRankingParameters.MuSigmaTau = Convert.ToDouble (szInformation [i].Split ('=') [1].Trim ());
						m_aMuSigmaRankingSystem.Tau = m_aRankingParameters.MuSigmaTau;
					}
					if (szInformation [i].Split ('=') [0].Trim ().CompareTo (m_szMuSigmaIterations) == 0) 
					{
						m_aRankingParameters.MuSigmaIterations = Convert.ToInt32 (szInformation [i].Split ('=') [1].Trim ());
						m_aMuSigmaRankingSystem.NumberOfIterations = m_aRankingParameters.MuSigmaIterations;
					}
				}

				//////////////////////////////////////////////////////////////////////////////
				// prepare the read of the tables
				//////////////////////////////////////////////////////////////////////////////

				int iNumberOfGamesPerStep = (m_aGameList.NumberOfGames > 2 * m_iProgressBarGranularity)?m_aGameList.NumberOfGames / m_iProgressBarGranularity:1;

				//////////////////////////////////////////////////////////////////////////////
				// read the Halo 2 rankings
				//////////////////////////////////////////////////////////////////////////////
				
				// initialise the progress bar and log window
				pbProgress.Visible = true;
				pbProgress.Step = 1;
				pbProgress.Minimum = 0;
				pbProgress.Value = 0;

				// initialise the MS ranking list
				m_aHalo2RankingSystem.ClearPlayerSkills ();

				// main loop
				SqlCommand aReadH2RankingsTableCommand = new 
					SqlCommand ("select player_id,player_flags,rank_date,exp_pts,level from tH2Rankings where res_id = " + 
					m_aResultImportDialog.SelectedResultID.ToString (), aSQLConnection);
				SqlDataReader aH2RankingsReader = aReadH2RankingsTableCommand.ExecuteReader ();
				for (int i = 0; aH2RankingsReader.Read (); i++) 
				{
					string szHalo2PlayerID = aH2RankingsReader.GetValue (0).ToString () + "@" + aH2RankingsReader.GetValue (1).ToString ();
					int iPlayerID = (int) m_aHalo2PlayerIDToInternalPlayerID [szHalo2PlayerID];
					Halo2Skill aHalo2Skill = new Halo2Skill (aH2RankingsReader.GetInt32 (3), aH2RankingsReader.GetInt32 (4));
					m_aHalo2RankingSystem.PlayerSkillsList.GetPlayerSkills (iPlayerID).AddSkill (aHalo2Skill, (DateTime) aH2RankingsReader.GetValue (2));
					if (i % iNumberOfGamesPerStep == 0) pbProgress.PerformStep ();
				}
				aH2RankingsReader.Close ();

				// if results have just been read then do not allow to save them
				menuSaveResults.Enabled = false;

				// make the progres bar invisible
				pbProgress.Visible = false;

				//////////////////////////////////////////////////////////////////////////////
				// read the ELO rankings
				//////////////////////////////////////////////////////////////////////////////
				
				// initialise the progress bar and log window
				pbProgress.Visible = true;
				pbProgress.Maximum = (m_aGameList.NumberOfGames > 2 * m_iProgressBarGranularity)?m_iProgressBarGranularity:m_aGameList.NumberOfGames;
				pbProgress.Step = 1;
				pbProgress.Minimum = 0;
				pbProgress.Value = 0;

				// initialise the ELO ranking list
				m_aELORankingSystem.ClearPlayerSkills ();

				// main loop
				SqlCommand aReadELORankingsTableCommand = new 
					SqlCommand ("select player_id,player_flags,rank_date,score from tELORankings where res_id = " + 
					m_aResultImportDialog.SelectedResultID.ToString (), aSQLConnection);
				SqlDataReader aELORankingsReader = aReadELORankingsTableCommand.ExecuteReader ();
				for (int i = 0; aELORankingsReader.Read (); i++) 
				{
					string szHalo2PlayerID = aELORankingsReader.GetValue (0).ToString () + "@" + aELORankingsReader.GetValue (1).ToString ();
					int iPlayerID = (int) m_aHalo2PlayerIDToInternalPlayerID [szHalo2PlayerID];
					ELOSkill aELOSkill = new ELOSkill (aELORankingsReader.GetDouble (3));
					m_aELORankingSystem.PlayerSkillsList.GetPlayerSkills (iPlayerID).AddSkill (aELOSkill, (DateTime) aELORankingsReader.GetValue (2));
					if (i % iNumberOfGamesPerStep == 0) pbProgress.PerformStep ();
				}
				aELORankingsReader.Close ();

				// make the progres bar invisible
				pbProgress.Visible = false;

				//////////////////////////////////////////////////////////////////////////////
				// read the MS rankings
				//////////////////////////////////////////////////////////////////////////////
				
				// initialise the progress bar and log window
				pbProgress.Visible = true;
				pbProgress.Maximum = (m_aGameList.NumberOfGames > 2 * m_iProgressBarGranularity)?m_iProgressBarGranularity:m_aGameList.NumberOfGames;
				pbProgress.Step = 1;
				pbProgress.Minimum = 0;
				pbProgress.Value = 0;

				// initialise the MuSigma ranking list
				m_aMuSigmaRankingSystem.ClearPlayerSkills ();

				// main loop
				SqlCommand aReadMSRankingsTableCommand = new 
					SqlCommand ("select player_id,player_flags,rank_date,mu,sigma from tMSRankings where res_id = " + 
					m_aResultImportDialog.SelectedResultID.ToString (), aSQLConnection);
				SqlDataReader aMSRankingsReader = aReadMSRankingsTableCommand.ExecuteReader ();
				for (int i = 0; aMSRankingsReader.Read (); i++) 
				{
					string szHalo2PlayerID = aMSRankingsReader.GetValue (0).ToString () + "@" + aMSRankingsReader.GetValue (1).ToString ();
					int iPlayerID = (int) m_aHalo2PlayerIDToInternalPlayerID [szHalo2PlayerID];
					MuSigmaSkill aMuSigmaSkill = new MuSigmaSkill (aMSRankingsReader.GetDouble (3), aMSRankingsReader.GetDouble (4));
					m_aMuSigmaRankingSystem.PlayerSkillsList.GetPlayerSkills (iPlayerID).AddSkill (aMuSigmaSkill, (DateTime) aMSRankingsReader.GetValue (2));
					if (i % iNumberOfGamesPerStep == 0) pbProgress.PerformStep ();
				}
				aMSRankingsReader.Close ();

				// make the progres bar invisible
				pbProgress.Visible = false;

				///////////////////////////////////////////////////////////////////
				// close the SQL database
				///////////////////////////////////////////////////////////////////
				
				aSQLConnection.Close ();
				return true;
			}
			else
				return false;
		}

		/// <summary>
		/// Writes the current ranking results into the SQL database.
		/// </summary>
		private void WriteRankings ()
		{
			/////////////////////////////////////////////////////////////////////////////////////////////
			// potentially create the results table 
			/////////////////////////////////////////////////////////////////////////////////////////////
			
			CreateResultTables ();

			// use the SQL server settings as specified in the SQL dialog box 
			SqlConnection aSQLConnection = new SqlConnection ("Initial Catalog = " + m_aSQLImportDialog.DatabaseName + "; Data Source = " + 
				m_aSQLImportDialog.SQLServerName + "; Integrated Security = SSPI");
			aSQLConnection.Open ();

			/////////////////////////////////////////////////////////////////////////////////////////////
			// Fill the tResults table with one more entry
			/////////////////////////////////////////////////////////////////////////////////////////////

			// read the last result ID
			SqlCommand aReadLastResultIDCommand = new SqlCommand ("select top 1 res_id from tResults order by res_id desc", aSQLConnection);
			SqlDataReader aReadLastResultIDReader = aReadLastResultIDCommand.ExecuteReader ();
			aReadLastResultIDReader.Read ();

			int iResultID;
			try 
			{
				iResultID = aReadLastResultIDReader.GetInt32 (0) + 1;
			}
			catch 
			{
				iResultID = 1;
			}
			aReadLastResultIDReader.Close ();

			// write the new result time and type 
			DateTime aCurrentTime = DateTime.Now;
			SqlCommand aWriteResultCommand = new SqlCommand ("insert into tResults (res_id, res_date, res_type, game_map, game_variant, game_hopper) values " + 
				"(" + 
				iResultID.ToString () + ", " + 
				"'" + aCurrentTime.ToLongDateString () + " " + aCurrentTime.ToLongTimeString () + "', " + 
				"1, " + 
				m_aSQLImportDialog.CurrentMapID.ToString () + ", " + 
				m_aSQLImportDialog.CurrentVariantID.ToString () + ", " + 
				m_aSQLImportDialog.CurrentHopperID.ToString () + 
				")", aSQLConnection);
			aWriteResultCommand.ExecuteNonQuery ();

			///////////////////////////////////////////////////////////////////////////////////////
			// Fill the tParameters table with all entries for the parameters used. In particular, 
			// write the version number of the MSRankingSystem and Halo2RankingSystem Assembly which 
			// indicates which version of the MuSigma and Halo2 ranking library was used.
			/////////////////////////////////////////////////////////////////////////////////////////////

			// write all the parameters 
			Version aVersion = typeof (MuSigmaRankingSystem).Assembly.GetName ().Version;
			SqlCommand aWriteParametersCommand =  new SqlCommand ("insert into tParameters (res_id, param_name, param_value) values " + 
				"(" + 
				iResultID.ToString ()+ ", " + 
				"'" + m_szMuSigmaBeta + "', " + 
				"'" + m_aMuSigmaRankingSystem.Beta.ToString () + "'" + 
				")\n" + 
				"insert into tParameters (res_id, param_name, param_value) values " + 
				"(" + 
				iResultID.ToString ()+ ", " + 
				"'" + m_szMuSigmaEpsilon  + "', " + 
				"'" + m_aMuSigmaRankingSystem.Epsilon.ToString () + "'" + 
				")\n" + 
				"insert into tParameters (res_id, param_name, param_value) values " + 
				"(" + 
				iResultID.ToString ()+ ", " + 
				"'" + m_szMuSigmaTau + "', " + 
				"'" + m_aMuSigmaRankingSystem.Tau.ToString () + "'" + 
				")\n" + 
				"insert into tParameters (res_id, param_name, param_value) values " + 
				"(" + 
				iResultID.ToString ()+ ", " + 
				"'" + m_szMuSigmaIterations + "', " + 
				"'" + m_aMuSigmaRankingSystem.NumberOfIterations.ToString () + "'" + 
				")\n" + 
				"insert into tParameters (res_id, param_name, param_value) values " + 
				"(" + 
				iResultID.ToString ()+ ", " + 
				"'" + m_szMuSigmaApproximationAlgorithm + "', " + 
				"'" + m_aMuSigmaRankingSystem.ApproximationAlgorithm.ToString () + "'" + 
				")\n" + 
				"insert into tParameters (res_id, param_name, param_value) values " + 
				"(" + 
				iResultID.ToString ()+ ", " + 
				"'" + m_szELOBeta + "', " + 
				"'" + m_aELORankingSystem.Beta.ToString () + "'" + 
				")\n" + 
				"insert into tParameters (res_id, param_name, param_value) values " + 
				"(" + 
				iResultID.ToString ()+ ", " + 
				"'" + m_szELOAlpha + "', " + 
				"'" + m_aELORankingSystem.Alpha.ToString () + "'" + 
				")\n" + 
				"insert into tParameters (res_id, param_name, param_value) values " + 
				"(" + 
				iResultID.ToString ()+ ", " + 
				"'Version', " + 
				"'" + aVersion.ToString () + "'" + 
				")", aSQLConnection);
			aWriteParametersCommand.ExecuteNonQuery ();
			

			/////////////////////////////////////////////////////////////////////////////////////////////
			// prepare the raw data writing code
			/////////////////////////////////////////////////////////////////////////////////////////////
			
			int iNumberOfPlayersPerStep = (m_aPlayerList.NumberOfPlayers > 2 * m_iProgressBarGranularity)?m_aPlayerList.NumberOfPlayers / m_iProgressBarGranularity:1;

			/////////////////////////////////////////////////////////////////////////////////////////////
			// Fill the tH2Rankings table
			/////////////////////////////////////////////////////////////////////////////////////////////

			// make the progres bar visible
			pbProgress.Visible = true;
			pbProgress.Maximum = (m_aPlayerList.NumberOfPlayers > 2 * m_iProgressBarGranularity)?m_iProgressBarGranularity:m_aPlayerList.NumberOfPlayers;
			pbProgress.Step = 1;
			pbProgress.Minimum = 0;
			pbProgress.Value = 0;

			// and output player after player the skill list
			DataSet aHalo2PlayerSkillsListDataset = new DataSet ();
			SqlDataAdapter aHalo2PlayerSkillsListAdaptar = new SqlDataAdapter ("SELECT TOP 0 * FROM tH2Rankings", aSQLConnection);
			aHalo2PlayerSkillsListAdaptar.Fill (aHalo2PlayerSkillsListDataset);

			PlayerSkillsList aHalo2PlayerSkillsList = m_aHalo2RankingSystem.PlayerSkillsList;
			DataTable aHalo2PlayerSkillsListDataTable = aHalo2PlayerSkillsListDataset.Tables [0];

			for (int iPlayerID = 0; iPlayerID < m_aPlayerList.NumberOfPlayers; iPlayerID++) 
			{
				PlayerSkills aPlayerSkills = aHalo2PlayerSkillsList.GetPlayerSkills (iPlayerID);
				Skill [] aSkills = aPlayerSkills.Skills;
				DateTime [] aDates = aPlayerSkills.Dates;

				for (int i = 0; i < aSkills.Length; i++) 
				{
					Halo2Skill aHalo2Skill = (Halo2Skill) aSkills [i];
					string [] szHalo2PlayerIDStrings = ((string) m_aInternalPlayerIDToHalo2PlayerID [iPlayerID]).Split ('@');
					DataRow aRow = aHalo2PlayerSkillsListDataTable.NewRow ();
					aRow ["res_id"] = iResultID;
					aRow ["player_id"] = Convert.ToInt64 (szHalo2PlayerIDStrings [0]);
					aRow ["player_flags"] = Convert.ToInt32 (szHalo2PlayerIDStrings [1]);
					aRow ["rank_date"] = aDates [i];
					aRow ["exp_pts"] = aHalo2Skill.ExperiencePoints;
					aRow ["level"] = aHalo2Skill.Level;
					aHalo2PlayerSkillsListDataTable.Rows.Add (aRow);
				}

				// update the progress bar
				if (iPlayerID % iNumberOfPlayersPerStep == 0) pbProgress.PerformStep ();
			}

			if (aHalo2PlayerSkillsListDataTable.Rows.Count > 0) 
			{
				// execute the big insert command on the server
				String szInsertCommand = "INSERT INTO tH2Rankings (res_id, player_id, player_flags, rank_date, exp_pts, level) VALUES (@res_id, @player_id, @player_flags, @rank_date, @exp_pts, @level)";
				aHalo2PlayerSkillsListAdaptar.InsertCommand = new SqlCommand (szInsertCommand,(SqlConnection) aSQLConnection);
				aHalo2PlayerSkillsListAdaptar.InsertCommand.Parameters.Add ("@res_id", SqlDbType.Int, 0, "res_id");
				aHalo2PlayerSkillsListAdaptar.InsertCommand.Parameters.Add ("@player_id", SqlDbType.BigInt, 0, "player_id");
				aHalo2PlayerSkillsListAdaptar.InsertCommand.Parameters.Add ("@player_flags", SqlDbType.Int, 0, "player_flags");
				aHalo2PlayerSkillsListAdaptar.InsertCommand.Parameters.Add ("@rank_date", SqlDbType.DateTime, 0, "rank_date");
				aHalo2PlayerSkillsListAdaptar.InsertCommand.Parameters.Add ("@exp_pts", SqlDbType.Int, 0, "exp_pts");
				aHalo2PlayerSkillsListAdaptar.InsertCommand.Parameters.Add ("@level", SqlDbType.Int, 0, "level");
				aHalo2PlayerSkillsListAdaptar.Update (aHalo2PlayerSkillsListDataset);
			}

			// make the progres bar invisible
			pbProgress.Visible = false;

			/////////////////////////////////////////////////////////////////////////////////////////////
			// Fill the tELORanking table
			/////////////////////////////////////////////////////////////////////////////////////////////

			// make the progres bar visible
			pbProgress.Visible = true;
			pbProgress.Maximum = (m_aPlayerList.NumberOfPlayers > 2 * m_iProgressBarGranularity)?m_iProgressBarGranularity:m_aPlayerList.NumberOfPlayers;
			pbProgress.Step = 1;
			pbProgress.Minimum = 0;
			pbProgress.Value = 0;

			// and output player after player the skill list
			DataSet aELOPlayerSkillsListDataset = new DataSet ();
			SqlDataAdapter aELOPlayerSkillsListAdaptar = new SqlDataAdapter ("SELECT TOP 0 * FROM tELORankings", aSQLConnection);
			aELOPlayerSkillsListAdaptar.Fill (aELOPlayerSkillsListDataset);

			PlayerSkillsList aELOPlayerSkillsList = m_aELORankingSystem.PlayerSkillsList;
			DataTable aELOPlayerSkillsListDataTable= aELOPlayerSkillsListDataset.Tables [0];

			for (int iPlayerID = 0; iPlayerID < m_aPlayerList.NumberOfPlayers; iPlayerID++) 
			{
				PlayerSkills aPlayerSkills = aELOPlayerSkillsList.GetPlayerSkills (iPlayerID);
				Skill [] aSkills = aPlayerSkills.Skills;
				DateTime [] aDates = aPlayerSkills.Dates;
				int iGamesPlayedIndex = 0;

				for (int i = 0; i < aSkills.Length; i++) 
				{
					// advance the games-played index
					while (m_aGameList.GetGame ((int) m_aGamesPlayed [iPlayerID] [iGamesPlayedIndex]).Date.AddSeconds (+1) < aDates [i])
						iGamesPlayedIndex++;

					// get the ELO skill for this player
					ELOSkill aELOSkill = (ELOSkill) aSkills [i];
					string [] szHalo2PlayerIDStrings = ((string) m_aInternalPlayerIDToHalo2PlayerID [iPlayerID]).Split ('@');

					DataRow aRow = aELOPlayerSkillsListDataTable.NewRow ();
					aRow ["res_id"] = iResultID;
					aRow ["player_id"] = Convert.ToInt64 (szHalo2PlayerIDStrings [0]);
					aRow ["player_flags"] = Convert.ToInt32 (szHalo2PlayerIDStrings [1]);
					aRow ["rank_date"] = aDates [i];
					aRow ["score"] = aELOSkill.Points;
					aELOPlayerSkillsListDataTable.Rows.Add (aRow);
				}

				// update the progress bar
				if (iPlayerID % iNumberOfPlayersPerStep == 0) pbProgress.PerformStep ();
			}

			// execute the big insert command on the server
			if (aELOPlayerSkillsListDataTable.Rows.Count > 0) 
			{
				// execute the big insert command on the server
				String szInsertCommand = "INSERT INTO tELORankings (res_id, player_id, player_flags, rank_date, score) VALUES (@res_id, @player_id, @player_flags, @rank_date, @score)";
				aELOPlayerSkillsListAdaptar.InsertCommand = new SqlCommand (szInsertCommand,(SqlConnection) aSQLConnection);
				aELOPlayerSkillsListAdaptar.InsertCommand.Parameters.Add ("@res_id", SqlDbType.Int, 0, "res_id");
				aELOPlayerSkillsListAdaptar.InsertCommand.Parameters.Add ("@player_id", SqlDbType.BigInt, 0, "player_id");
				aELOPlayerSkillsListAdaptar.InsertCommand.Parameters.Add ("@player_flags", SqlDbType.Int, 0, "player_flags");
				aELOPlayerSkillsListAdaptar.InsertCommand.Parameters.Add ("@rank_date", SqlDbType.DateTime, 0, "rank_date");
				aELOPlayerSkillsListAdaptar.InsertCommand.Parameters.Add ("@score", SqlDbType.Float, 0, "score");
				aELOPlayerSkillsListAdaptar.Update (aELOPlayerSkillsListDataset);
			}

			// make the progres bar invisible
			pbProgress.Visible = false;


			/////////////////////////////////////////////////////////////////////////////////////////////
			// Fill the tMSRanking table
			/////////////////////////////////////////////////////////////////////////////////////////////

			// make the progres bar visible
			pbProgress.Visible = true;
			pbProgress.Maximum = (m_aPlayerList.NumberOfPlayers > 2 * m_iProgressBarGranularity)?m_iProgressBarGranularity:m_aPlayerList.NumberOfPlayers;
			pbProgress.Step = 1;
			pbProgress.Minimum = 0;
			pbProgress.Value = 0;

			// and output player after player the skills list
			DataSet aMuSigmaPlayerSkillsListDataset = new DataSet ();
			SqlDataAdapter aMuSigmaPlayerSkillsListAdaptar = new SqlDataAdapter ("SELECT TOP 0 * FROM tMSRankings", aSQLConnection);
			aMuSigmaPlayerSkillsListAdaptar.Fill (aMuSigmaPlayerSkillsListDataset);

			PlayerSkillsList aMuSigmaPlayerSkillsList = m_aMuSigmaRankingSystem.PlayerSkillsList;
			DataTable aMuSigmaPlayerSkillsListDataTable= aMuSigmaPlayerSkillsListDataset.Tables [0];
			for (int iPlayerID = 0; iPlayerID < m_aPlayerList.NumberOfPlayers; iPlayerID++) 
			{
				PlayerSkills aPlayerSkills = aMuSigmaPlayerSkillsList.GetPlayerSkills (iPlayerID);
				Skill [] aSkills = aPlayerSkills.Skills;
				DateTime [] aDates = aPlayerSkills.Dates;
				int iGamesPlayedIndex = 0;

				for (int i = 0; i < aSkills.Length; i++) 
				{
					// advance the games-played index
					while (m_aGameList.GetGame ((int) m_aGamesPlayed [iPlayerID] [iGamesPlayedIndex]).Date.AddSeconds (+1) < aDates [i])
						iGamesPlayedIndex++;

					// get the MuSigma skill for this player
					MuSigmaSkill aMuSigmaSkill = (MuSigmaSkill) aSkills [i];
					string [] szHalo2PlayerIDStrings = ((string) m_aInternalPlayerIDToHalo2PlayerID [iPlayerID]).Split ('@');
					int iNumberOfTeams = (i == 0)?0:m_aGameList.GetGame ((int) m_aGamesPlayed [iPlayerID] [iGamesPlayedIndex]).NumberOfTeams;

					DataRow aRow = aMuSigmaPlayerSkillsListDataTable.NewRow ();
					aRow ["res_id"] = iResultID;
					aRow ["player_id"] = Convert.ToInt64 (szHalo2PlayerIDStrings [0]);
					aRow ["player_flags"] = Convert.ToInt32 (szHalo2PlayerIDStrings [1]);
					aRow ["no_teams"] = iNumberOfTeams;
					aRow ["rank_date"] = aDates [i];
					aRow ["mu"] = aMuSigmaSkill.Mu;
					aRow ["sigma"] = aMuSigmaSkill.Sigma;
					aMuSigmaPlayerSkillsListDataTable.Rows.Add (aRow);
				}

				// update the progress bar
				if (iPlayerID % iNumberOfPlayersPerStep == 0) pbProgress.PerformStep ();
			}

			// execute the big insert command on the server
			if (aMuSigmaPlayerSkillsListDataTable.Rows.Count > 0) 
			{
				// execute the big insert command on the server
				String szInsertCommand = "INSERT INTO tMSRankings (res_id, player_id, player_flags, no_teams, rank_date, mu, sigma) VALUES (@res_id, @player_id, @player_flags, @no_teams, @rank_date, @mu, @sigma)";
				aMuSigmaPlayerSkillsListAdaptar.InsertCommand = new SqlCommand (szInsertCommand,(SqlConnection) aSQLConnection);
				aMuSigmaPlayerSkillsListAdaptar.InsertCommand.Parameters.Add ("@res_id", SqlDbType.Int, 0, "res_id");
				aMuSigmaPlayerSkillsListAdaptar.InsertCommand.Parameters.Add ("@player_id", SqlDbType.BigInt, 0, "player_id");
				aMuSigmaPlayerSkillsListAdaptar.InsertCommand.Parameters.Add ("@player_flags", SqlDbType.Int, 0, "player_flags");
				aMuSigmaPlayerSkillsListAdaptar.InsertCommand.Parameters.Add ("@no_teams", SqlDbType.Int, 0, "no_teams");
				aMuSigmaPlayerSkillsListAdaptar.InsertCommand.Parameters.Add ("@rank_date", SqlDbType.DateTime, 0, "rank_date");
				aMuSigmaPlayerSkillsListAdaptar.InsertCommand.Parameters.Add ("@mu", SqlDbType.Float, 0, "mu");
				aMuSigmaPlayerSkillsListAdaptar.InsertCommand.Parameters.Add ("@sigma", SqlDbType.Float, 0, "sigma");
				aMuSigmaPlayerSkillsListAdaptar.Update (aMuSigmaPlayerSkillsListDataset);
			}

			// make the progres bar invisible
			pbProgress.Visible = false;

			/////////////////////////////////////////////////////////////////////////////////////////////
			// close the SQL connections
			/////////////////////////////////////////////////////////////////////////////////////////////
			aSQLConnection.Close ();
		}
		#endregion

		#region Ranking code
		/// <summary>
		/// Recomputes all the ranking system. 
		/// </summary>
		/// <param name="bAppendToLog">Inidicates if the log should be cleared.</param>
		private void RecomputeRankingSystems (bool bAppendToLog) 
		{
			// clear the log window
			if (!bAppendToLog) 
			{
				m_aLogWindow.ClearLogList ();
				m_aLogWindow.LogName = "Ranking problems";
			}

			/////////////////////////////////////////////////////////////////////////////////////////////
			// recompute all the rankings
			/////////////////////////////////////////////////////////////////////////////////////////////

			// make the progres bar visible
			int iNumberOfGamesPerStep = (m_aGameList.NumberOfGames > 2 * m_iProgressBarGranularity)?m_aGameList.NumberOfGames / m_iProgressBarGranularity:1;
			pbProgress.Visible = true;
			pbProgress.Maximum = (m_aGameList.NumberOfGames > 2 * m_iProgressBarGranularity)?m_iProgressBarGranularity:m_aGameList.NumberOfGames;
			pbProgress.Step = 1;
			pbProgress.Minimum = 0;
			pbProgress.Value = 0;

			// clears the skill lists of all players
			m_aHalo2RankingSystem.ClearPlayerSkills ();
			m_aELORankingSystem.ClearPlayerSkills ();
			m_aMuSigmaRankingSystem.ClearPlayerSkills ();

			// copies the parameter of the MuSigma ranking system from the dialog
			m_aMuSigmaRankingSystem.Beta = m_aRankingParameters.MuSigmaBeta;
			m_aMuSigmaRankingSystem.Epsilon = m_aRankingParameters.MuSigmaEpsilon;
			m_aMuSigmaRankingSystem.Tau = m_aRankingParameters.MuSigmaTau;
			m_aMuSigmaRankingSystem.NumberOfIterations = m_aRankingParameters.MuSigmaIterations;
			m_aMuSigmaRankingSystem.ApproximationAlgorithm = m_aRankingParameters.MuSigmaApproximationAlgorithm;

			// copies the parameter of the ELO ranking system from the dialog
			m_aELORankingSystem.Beta = m_aRankingParameters.ELOBeta;
			m_aELORankingSystem.Alpha = m_aRankingParameters.ELOAlpha;

			// ... and update the skills one by one
			for (int i = 0; i < m_aGameList.NumberOfGames; i++) 
			{
				Game aGame = m_aGameList.GetGame (i);

				if (!m_aHalo2RankingSystem.Update (aGame))
					m_aLogWindow.AddLine ("Halo2 update skipped game at " + aGame.Date.ToLongDateString () + " " + aGame.Date.ToLongTimeString ());
				if (!m_aELORankingSystem.Update (aGame))
					m_aLogWindow.AddLine ("ELO update skipped game at " + aGame.Date.ToLongDateString ()+ " " + aGame.Date.ToLongTimeString ());
				if (!m_aMuSigmaRankingSystem.Update (aGame))
					m_aLogWindow.AddLine ("MuSigma update skipped game at " + aGame.Date.ToLongDateString ()+ " " + aGame.Date.ToLongTimeString ());
				if (i % iNumberOfGamesPerStep == 0) pbProgress.PerformStep ();
			}

			// make the progres bar invisible
			pbProgress.Visible = false;
			
			// enable the 'Save Results' menu entry
			if (m_aGameList.NumberOfGames > 0)
				menuSaveResults.Enabled = true;
			else
				menuSaveResults.Enabled = false;

			// possibly show the log
			if (!bAppendToLog)
				m_aLogWindow.ShowDialog ();
		}

		/// <summary>
		/// Computes the evidence of the MuSigma and ELO ranking system for several settings of Beta and Epsilon. 
		/// </summary>
		/// <remarks>A recompute of the ranking systems will create a new entry in the experiments table.</remarks>
		private void EvidenceAnalysis () 
		{
			/////////////////////////////////////////////////////////////////////////////////////////////
			// set the parameters from the ranking parameters dialog box
			/////////////////////////////////////////////////////////////////////////////////////////////
			
			// copies the parameter of the MuSigma ranking system from the dialog
			m_aMuSigmaRankingSystem.Tau = m_aRankingParameters.MuSigmaTau;
			m_aMuSigmaRankingSystem.NumberOfIterations = m_aRankingParameters.MuSigmaIterations;
			m_aMuSigmaRankingSystem.ApproximationAlgorithm = m_aRankingParameters.MuSigmaApproximationAlgorithm;

			// copies the parameter of the ELO ranking system from the dialog
			m_aELORankingSystem.Alpha = m_aRankingParameters.ELOAlpha;

			// save the parameters we are going to change
			double dMuSigmaBeta = m_aRankingParameters.MuSigmaBeta;
			double dMuSigmaEpsilon = m_aRankingParameters.MuSigmaEpsilon;
			double dELOBeta = m_aRankingParameters.ELOBeta;

			// open the output stream
			StreamWriter aResultFile;
			SaveFileDialog aSaveResultFileDialog = new SaveFileDialog ();
			aSaveResultFileDialog.Filter = "csv files (*.csv)|*.csv|All files (*.*)|*.*";
			aSaveResultFileDialog.FilterIndex = 2;
			aSaveResultFileDialog.RestoreDirectory = true;
 
			if (aSaveResultFileDialog.ShowDialog () == DialogResult.OK)
				aResultFile = new StreamWriter (aSaveResultFileDialog.OpenFile ());
			else
				return;
			aResultFile.WriteLine ("beta,win_prob,epsilon,ELO_log_evidence,MuSigma_log_evidence");

			/////////////////////////////////////////////////////////////////////////////////////////////
			// recompute all the rankings (for varying values of Beta and Win probability)
			/////////////////////////////////////////////////////////////////////////////////////////////
			for (double dBeta = 5.0; dBeta < 1000.0; dBeta += 50.0)
			{
				for (double dWinProbability = 0.01; dWinProbability < 1.0; dWinProbability += 0.05)
				{
					double dEpsilon = -Math.Sqrt (2) * dBeta * GaussianApproximations.PhiInverse ((1.0 - dWinProbability) / 2.0);

					// make the progres bar visible
					int iNumberOfGamesPerStep = (m_aGameList.NumberOfGames > 2 * m_iProgressBarGranularity)?m_aGameList.NumberOfGames / m_iProgressBarGranularity:1;
					pbProgress.Visible = true;
					pbProgress.Maximum = (m_aGameList.NumberOfGames > 2 * m_iProgressBarGranularity)?m_iProgressBarGranularity:m_aGameList.NumberOfGames;
					pbProgress.Step = 1;
					pbProgress.Minimum = 0;
					pbProgress.Value = 0;

					// clears the skill lists of all players
					m_aELORankingSystem.ClearPlayerSkills ();
					m_aMuSigmaRankingSystem.ClearPlayerSkills ();

					// set the changing parameters
					m_aMuSigmaRankingSystem.Beta = dBeta;
					m_aELORankingSystem.Beta = dBeta;
					m_aMuSigmaRankingSystem.Epsilon = dEpsilon;

					// initialise the total log evidence
					double dLogMuSigmaEvidence = 0.0;
					double dLogELOEvidence = 0.0;

					// ... and update the skills one by one
					for (int i = 0; i < m_aGameList.NumberOfGames; i++) 
					{
						Game aGame = m_aGameList.GetGame (i);
						double dEvidence;

						if (!m_aELORankingSystem.Update (aGame, out dEvidence))
							m_aLogWindow.AddLine ("ELO update skipped game at " + aGame.Date.ToLongDateString ()+ " " + aGame.Date.ToLongTimeString ());
						else 
							if (dEvidence > 0.0) dLogELOEvidence += Math.Log (dEvidence);

						if (!m_aMuSigmaRankingSystem.Update (aGame, out dEvidence))
							m_aLogWindow.AddLine ("MuSigma update skipped game at " + aGame.Date.ToLongDateString ()+ " " + aGame.Date.ToLongTimeString ());
						else
							if (dEvidence > 0.0) dLogMuSigmaEvidence += Math.Log (dEvidence);

						if (i % iNumberOfGamesPerStep == 0) pbProgress.PerformStep ();
					}

					// make the progres bar invisible
					pbProgress.Visible = false;

					// save the line to the csv file
					aResultFile.WriteLine (dBeta + "," + dWinProbability + "," + dEpsilon + "," + dLogELOEvidence + "," + dLogMuSigmaEvidence);
				}
			}

			// close the file
			aResultFile.Close ();

			// save the parameters we are going to change
			m_aRankingParameters.MuSigmaBeta = dMuSigmaBeta;
			m_aRankingParameters.MuSigmaEpsilon = dMuSigmaEpsilon;
			m_aRankingParameters.ELOBeta = dELOBeta;
			
			// enable the 'Save Results' menu entry
			if (m_aGameList.NumberOfGames > 0)
				menuSaveResults.Enabled = true;
			else
				menuSaveResults.Enabled = false;

			// done!
			return;
		}

		/// <summary>
		/// Computes the ranking difference between a ranking system's prediction and the final game outcome. 
		/// </summary>
		/// <param name="aRankingSystem">The ranking system to use for the computation of the ranking difference.</param>
		/// <param name="iGameID">Internal game ID.</param>
		/// <returns>The ranking difference as a number in [0,1].</returns> 
		/// <remarks>This method throws an exception if the ranking difference cannot be computed.</remarks>
		private double RankingDifference (RankingSystem aRankingSystem, int iGameID)
		{
			try 
			{
				// get the game
				Halo2Game aGame = (Halo2Game) m_aGameList.GetGame (iGameID);
				// try the computations
				return aRankingSystem.PredictedOutcome (aGame).Difference (aGame.Ranking);
			}
			catch 
			{
				throw new Exception ("Ranking difference could not be computed.");
			}
		}

		/// <summary>
		/// Computes the ranking difference between the current ranking system's prediction and the final game outcome. 
		/// </summary>
		/// <param name="iGameID">Internal game ID.</param>
		/// <returns>The ranking difference between the current ranking system and the final game outcome.</returns> 
		/// <remarks>This method throws an exception if the ranking difference cannot be computed.</remarks>
		private double RankingDifference (int iGameID)
		{
			return RankingDifference (m_aCurrentRankingSystem, iGameID);
		}
		#endregion

		#region General helper code
		/// <summary>
		/// Computes the moving average of a series of numbers.
		/// </summary>
		/// <param name="dX">The series of data.</param>
		/// <param name="iWindowSize">The window size.</param>
		/// <returns>A series that is <c>iWindowSize</c> many elements shorter and contains the moving average.</returns>
		private double [] ComputeMovingAverage (double [] dX, int iWindowSize)
		{
			// check that there is enough data to form a moving average
			if (dX.Length < iWindowSize)
				return new double [0];

			// allocate memory for the solution
			double [] dMovingAverageX = new double [dX.Length - iWindowSize];
			dMovingAverageX [0] = 0.0;

			// compute the first entry explicitely
			for (int i = 0; i < iWindowSize; i++) 
				dMovingAverageX [0] += dX [i] / (double) iWindowSize;

			// compute the following entries by simple updates
			for (int i = 1; i < dMovingAverageX.Length; i++) 
				dMovingAverageX [i] = dMovingAverageX [i - 1] - dX [i - 1] / (double) iWindowSize + dX [iWindowSize + i - 1] / (double) iWindowSize;

			// return the result
			return dMovingAverageX;
		}
		#endregion

		#region Drawing code
		/// <summary>
		/// Draws the log probability of the MuSigma system over time in a separate plot window.
		/// </summary>
		private void DrawMuSigmaLogProbability ()
		{
			// initialise the progress window
			int iNumberOfGamesPerStep = (m_aGameList.NumberOfGames > 2 * m_iProgressBarGranularity)?m_aGameList.NumberOfGames / m_iProgressBarGranularity:1;
			pbProgress.Visible = true;
			pbProgress.Maximum = (m_aGameList.NumberOfGames > 2 * m_iProgressBarGranularity)?m_iProgressBarGranularity:m_aGameList.NumberOfGames;
			pbProgress.Step = 1;
			pbProgress.Minimum = 0;
			pbProgress.Value = 0;

			// allocate the ranking difference vectors
			double [] dProbability = new double [m_aGameList.NumberOfGames];
			double [] dDatesTmp = new double [m_aGameList.NumberOfGames];

			// computes the rank difference for each single game
			int iNoValidGames = 0;
			for (int iGameID = 0; iGameID < m_aGameList.NumberOfGames; iGameID++) 
			{
				// get the data
				Game aGame = m_aGameList.GetGame (iGameID);
				TimeSpan aTimePassed = aGame.Date.Subtract (m_aStartDate);
				dDatesTmp [iNoValidGames] = Convert.ToDouble (aTimePassed.TotalDays);

				try 
				{
					// compute the MuSigma ranking systems probability of the current game outcome
					dProbability [iNoValidGames++] = m_aMuSigmaRankingSystem.RankingProbability (aGame, new Ranking [1] { aGame.Ranking }) [0];
				}
				catch 
				{
				}

				// update the progress bar
				if (iGameID % iNumberOfGamesPerStep == 0)
					pbProgress.PerformStep ();
			}

			// hides the progress bar
			pbProgress.Visible = false;

			// do not do anything if there is no data
			if (iNoValidGames == 0) 
			{
				MessageBox.Show ("There are no valid games.");
				return;
			}

			// cut the length of the arrays
			double [] dLogProbability = new double [iNoValidGames];
			double [] dDates = new double [iNoValidGames];
			for (int i = 0; i < iNoValidGames; i++) 
			{
				// HACK: At the moment, we simply compute the probability but do not take the logarithm.
				dLogProbability [i] = dProbability [i];
				dDates [i] = dDatesTmp [i];
			}

			// compute the moving averages and send the data to the window
			int iWindowSize = Math.Min (2000, iNoValidGames/2);

			PlotWindow aLogProbabilityPlot;
			aLogProbabilityPlot = new PlotWindow ();
			aLogProbabilityPlot.Clear ();
			aLogProbabilityPlot.Text = "Probability of the Game Outcome";
			aLogProbabilityPlot.AddData (ComputeMovingAverage (dDates, iWindowSize), ComputeMovingAverage (dLogProbability, iWindowSize), "MuSigma");
			aLogProbabilityPlot.XAxisTitle = "Days since " + m_aStartDate.ToLongDateString ();
			aLogProbabilityPlot.AlternativeXAxisTitle = "Number of games played";
			aLogProbabilityPlot.SetAlternativeXAxis ();
			aLogProbabilityPlot.YAxisTitle = "Probability";
			aLogProbabilityPlot.UpdateChart ();
			aLogProbabilityPlot.Visible = true;
			aLogProbabilityPlot.ShowInTaskbar = true;
			aLogProbabilityPlot.MinimizeBox = true;
		}

		/// <summary>
		/// Draws a ranking difference window.
		/// </summary>
		private void DrawRankingDifferenceWindow ()
		{
			// initialise the progress window
			int iNumberOfGamesPerStep = (m_aGameList.NumberOfGames > 2 * m_iProgressBarGranularity)?m_aGameList.NumberOfGames / m_iProgressBarGranularity:1;
			pbProgress.Visible = true;
			pbProgress.Maximum = (m_aGameList.NumberOfGames > 2 * m_iProgressBarGranularity)?m_iProgressBarGranularity:m_aGameList.NumberOfGames;
			pbProgress.Step = 1;
			pbProgress.Minimum = 0;
			pbProgress.Value = 0;

			// allocate the ranking difference lists
			ArrayList dRawHalo2RankingDifference = new ArrayList (m_aGameList.NumberOfGames);
			ArrayList dHalo2RankingDifference = new ArrayList (m_aGameList.NumberOfGames);
			ArrayList dELORankingDifference = new ArrayList (m_aGameList.NumberOfGames);
			ArrayList dMuSigmaRankingDifference = new ArrayList (m_aGameList.NumberOfGames);
			ArrayList dDates = new ArrayList (m_aGameList.NumberOfGames);

			// computes the rank difference for each single game
			for (int iGameID = 0; iGameID < m_aGameList.NumberOfGames; iGameID++) 
			{
				Game aGame = m_aGameList.GetGame (iGameID);
				TimeSpan aTimePassed = aGame.Date.Subtract (m_aStartDate);
				double dCurrentDate = Convert.ToDouble (aTimePassed.TotalDays);

				try 
				{
					// try to compute the several ranking differences
					double dCurrentRawHalo2RankingDifference = RankingDifference (m_aRawHalo2RankingSystem, iGameID);
					double dCurrentHalo2RankingDifference = RankingDifference (m_aHalo2RankingSystem, iGameID);
					double dCurrentELORankingDifference = RankingDifference (m_aELORankingSystem, iGameID);
					double dCurrentMuSigmaRankingDifference = RankingDifference (m_aMuSigmaRankingSystem, iGameID);

					// if we get here, all three system could compute the difference
					dDates.Add (dCurrentDate);
					dRawHalo2RankingDifference.Add (dCurrentRawHalo2RankingDifference);
					dHalo2RankingDifference.Add (dCurrentHalo2RankingDifference);
					dELORankingDifference.Add (dCurrentELORankingDifference);
					dMuSigmaRankingDifference.Add (dCurrentMuSigmaRankingDifference);
				}
				catch 
				{
				}

				// update the progress bar
				if (iGameID % iNumberOfGamesPerStep == 0)
					pbProgress.PerformStep ();
			}

			// hides the progress bar
			pbProgress.Visible = false;

			// do not do anything if there is no data
			if (dDates.Count == 0)  
			{
				MessageBox.Show ("There are not enough 2 player games.");
				return;
			}

			// compute the moving averages and send the data to the window
			int iWindowSize = Math.Min (2000, dDates.Count/2);
			double [] dSmoothedDates = ComputeMovingAverage ((double []) dDates.ToArray (typeof (double)), iWindowSize);

			PlotWindow aRankingDifferenceWindow;
			aRankingDifferenceWindow = new PlotWindow ();
			aRankingDifferenceWindow.Clear ();
			aRankingDifferenceWindow.Text = "Ranking Difference";
			aRankingDifferenceWindow.AddData (dSmoothedDates, 
				ComputeMovingAverage ((double []) dRawHalo2RankingDifference.ToArray (typeof (double)), iWindowSize), "Halo 2 (raw data)");
			aRankingDifferenceWindow.AddData (dSmoothedDates, 
				ComputeMovingAverage ((double []) dHalo2RankingDifference.ToArray (typeof (double)), iWindowSize), "Halo 2");
			aRankingDifferenceWindow.AddData (dSmoothedDates, 
				ComputeMovingAverage ((double []) dELORankingDifference.ToArray (typeof (double)), iWindowSize), "ELO");
			aRankingDifferenceWindow.AddData (dSmoothedDates, 
				ComputeMovingAverage ((double []) dMuSigmaRankingDifference.ToArray (typeof (double)), iWindowSize), "MuSigma");
			aRankingDifferenceWindow.XAxisTitle = "Days since " + m_aStartDate.ToLongDateString ();
			aRankingDifferenceWindow.AlternativeXAxisTitle = "Number of games played";
			aRankingDifferenceWindow.SetAlternativeXAxis ();
			aRankingDifferenceWindow.YAxisTitle = "Rank difference";
			aRankingDifferenceWindow.UpdateChart ();
			aRankingDifferenceWindow.Visible = true;
			aRankingDifferenceWindow.ShowInTaskbar = true;
			aRankingDifferenceWindow.MinimizeBox = true;
		}

		/// <summary>
		/// Generates a series of plots for all pairs of selected players comparing them for a particular ranking system.
		/// </summary>
		/// <param name="aRankingSystem">The ranking system which will allow comparison.</param>
		/// <param name="szSystemName">The name of the system (used in the window title).</param>
		private void CompareSelectedPlayers (ProbabilisticRankingSystem aRankingSystem, string szSystemName)
		{
			// get the number of selected players
			int iNoSelectedPlayers = lbPlayerList.SelectedIndices.Count;

			// enumerate all three rankings
			Ranking [] aRankings = new Ranking [3] {	
													   new Ranking (new int [2] {1, 0}),	// Team 1 wins
													   new Ranking (new int [2] {0, 0}),	// Teams draw
													   new Ranking (new int [2] {0, 1})		// Team 2 wins
												   }; 


			// loop over all combinations of selected players
			PlayerSkillsList aPlayerSkillsList = aRankingSystem.PlayerSkillsList;
			for (int i = 0; i < iNoSelectedPlayers; i++)
				for (int j = i + 1; j < iNoSelectedPlayers; j++) 
				{
					// get the player IDs
					int iPlayer1ID = m_aPlayerList.GetPlayerID ((string) lbPlayerList.SelectedItems [i]);
					int iPlayer2ID = m_aPlayerList.GetPlayerID ((string) lbPlayerList.SelectedItems [j]);

					// get all the player skills
					PlayerSkills aPlayer1Skills = aPlayerSkillsList.GetPlayerSkills (iPlayer1ID);
					PlayerSkills aPlayer2Skills = aPlayerSkillsList.GetPlayerSkills (iPlayer2ID);

					// get all dates merged and sorted (including replications, though)
					ArrayList aTmpList = new ArrayList ();
					aTmpList.AddRange (aPlayer1Skills.Dates);
					aTmpList.AddRange (aPlayer2Skills.Dates); 
					DateTime [] aDatesList = (DateTime []) aTmpList.ToArray (typeof (DateTime)); 
					Array.Sort (aDatesList);

					// allocate the outcome probabilities lists
					ArrayList dWinningProbability = new ArrayList (aDatesList.Length);
					ArrayList dDrawingProbability = new ArrayList (aDatesList.Length);
					ArrayList dLosingProbability = new ArrayList (aDatesList.Length);
					ArrayList dDates = new ArrayList (aDatesList.Length);

					// generate all the probabilities for all moments at which skills changed
					DateTime aPreviousDate = new DateTime (0L);
					for (int k = 0; k < aDatesList.Length; k++)
					{
						// check if the game was already compared
						if (aPreviousDate.Ticks == 0 || aPreviousDate != aDatesList [k]) 
						{
							// generate an artificial game at the game time
							Game aGame = new Game (aDatesList [k]);
							Team aTeam1 = new Team ();
							Team aTeam2 = new Team ();
							aTeam1.AddPlayer (iPlayer1ID, 0);
							aTeam2.AddPlayer (iPlayer2ID, 0);
							aGame.AddTeam (aTeam1);
							aGame.AddTeam (aTeam2);

							try 
							{
								// compute the new winning probability
								double [] aProbabilities = aRankingSystem.RankingProbability (aGame, aRankings);

								// add the time
								TimeSpan aTimePassed = aGame.Date.Subtract (m_aStartDate);
								dDates.Add (Convert.ToDouble (aTimePassed.TotalDays));

								// add the three probabilities
								dWinningProbability.Add (aProbabilities [0]);
								dDrawingProbability.Add (aProbabilities [1]);
								dLosingProbability.Add (aProbabilities [2]);

								// update the previous date variable
								aPreviousDate = aDatesList [k];
							}
							catch 
							{
							}
						}
						else 
						{
							Console.WriteLine ("Identical game encounterd.");
						}
					}

					// draw all the results on a new window
					PlotWindow aPlotWindow = new PlotWindow ();
					aPlotWindow.AddData ((double []) dDates.ToArray (typeof (double)), (double []) dWinningProbability.ToArray (typeof (double)), 
						m_aPlayerList.GetPlayerName (iPlayer1ID) + " wins vs. " + m_aPlayerList.GetPlayerName (iPlayer2ID));
					aPlotWindow.AddData ((double []) dDates.ToArray (typeof (double)), (double []) dLosingProbability.ToArray (typeof (double)), 
						m_aPlayerList.GetPlayerName (iPlayer2ID) + " wins vs. " + m_aPlayerList.GetPlayerName (iPlayer1ID));
					aPlotWindow.AddData ((double []) dDates.ToArray (typeof (double)), (double []) dDrawingProbability.ToArray (typeof (double)), 
						m_aPlayerList.GetPlayerName (iPlayer1ID) + " draws with " + m_aPlayerList.GetPlayerName (iPlayer2ID));
					aPlotWindow.Text = szSystemName + " Comparison of " + m_aPlayerList.GetPlayerName (iPlayer1ID) + " and " + m_aPlayerList.GetPlayerName (iPlayer2ID);
					aPlotWindow.XAxisTitle = "Days since " + m_aStartDate.ToLongDateString ();
					aPlotWindow.AlternativeXAxisTitle = "Game index";
					aPlotWindow.SetAlternativeXAxis ();	
					aPlotWindow.YAxisTitle = "Outcome probabilities";
					aPlotWindow.UpdateChart ();
					aPlotWindow.Visible = true;
					aPlotWindow.ShowInTaskbar = true;
					aPlotWindow.MinimizeBox = true;
				}
		}
		/// <summary>
		/// Compares all selected players 1 vs. 1.
		/// </summary>
		private void CompareSelectedPlayers ()
		{
			// get the number of selected players
			int iNoSelectedPlayers = lbPlayerList.SelectedIndices.Count;

			// if there are not enough players selected, exit
			if (iNoSelectedPlayers < 2) 
			{
				MessageBox.Show ("There must be at least 2 players selected.");
				return;
			}
			// if there are too many players selected, check back and possibly exit
			if (iNoSelectedPlayers > 4) { 
				if (MessageBox.Show ("This will generate " + (iNoSelectedPlayers * (iNoSelectedPlayers - 1) / 2).ToString () + 
					" new windows. Proceed?", "Information", MessageBoxButtons.OKCancel) == DialogResult.Cancel)
					return;
			}

			// create all windows for the MuSigma ranking system
			CompareSelectedPlayers (m_aMuSigmaRankingSystem, "MuSigma");

			// create all windows for the ELO ranking system
			CompareSelectedPlayers (m_aELORankingSystem, "ELO");

			// done!
			return;
		}

		/// <summary>
		/// Checks if all of the progression windows are still visible and possibly re-creates them.
		/// </summary>
		private void CheckProgressionWindows ()
		{
			// access the chartspace to check if the window has disappeared
			try 
			{
				string szTmp = m_aPlayerProgression.ChartSpace.Charts.Count.ToString ();
			}
			catch 
			{
				m_aPlayerProgression = new PlotWindow ();
			}
			m_aPlayerProgression.Visible = menuShowProgressWindow.Checked;


			try 
			{
				string szTmp = m_aELOPlayerPerformance.ChartSpace.Charts.Count.ToString ();
			}
			catch 
			{
				m_aELOPlayerPerformance = new PlotWindow ();
			}
			m_aELOPlayerPerformance.Visible = menuShowPerformanceWindows.Checked;

			try 
			{
				string szTmp = m_aMuSigmaPlayerPerformance.ChartSpace.Charts.Count.ToString ();
			}
			catch 
			{
				m_aMuSigmaPlayerPerformance = new PlotWindow ();
			}
			m_aMuSigmaPlayerPerformance.Visible = menuShowPerformanceWindows.Checked;
			return;
		}
		/// <summary>
		/// Transfer the current player's level progression data to the level progression window.
		/// Transfers the current player's MuSigma skill data to the MuSigma performance data window.
		/// Transfers the current player's ELO skill data to the ELO performance data window.
		/// </summary>
		private void RefreshLevelProgressionWindow ()
		{
			// check the progression windows
			CheckProgressionWindows ();

			// clear the windows
			m_aPlayerProgression.Clear ();
			m_aELOPlayerPerformance.Clear ();
			m_aMuSigmaPlayerPerformance.Clear ();

			for (int j = 0; j < lbPlayerList.SelectedItems.Count; j++) 
			{
				// get the data to the player progress window
				int iPlayerID = m_aPlayerList.GetPlayerID ((string) lbPlayerList.SelectedItems [j]);
				Skill [] aAllSkills = m_aCurrentRankingSystem.PlayerSkillsList.GetPlayerSkills (iPlayerID).Skills;
				DateTime [] aAllDates = m_aCurrentRankingSystem.PlayerSkillsList.GetPlayerSkills (iPlayerID).Dates;
				Skill [] aAllMuSigmaSkills = m_aMuSigmaRankingSystem.PlayerSkillsList.GetPlayerSkills (iPlayerID).Skills;
				DateTime [] aAllMuSigmaDates = m_aMuSigmaRankingSystem.PlayerSkillsList.GetPlayerSkills (iPlayerID).Dates;
				Skill [] aAllELOSkills = m_aELORankingSystem.PlayerSkillsList.GetPlayerSkills (iPlayerID).Skills;
				DateTime [] aAllELODates = m_aELORankingSystem.PlayerSkillsList.GetPlayerSkills (iPlayerID).Dates;

				// extract the x and y coordinates (level progression)
				double [] dDates = new double [aAllDates.Length];
				double [] dLevels = new double [aAllSkills.Length];
				for (int i = 0; i < dDates.Length; i++) 
				{
					TimeSpan aTimePassed = aAllDates [i].Subtract (m_aStartDate);
					dDates [i] = Convert.ToDouble (aTimePassed.TotalDays);
					dLevels [i] = aAllSkills [i].Level;
				}

				// extract the x and y coordinates (ELO performance)
				double [] dELODates = new double [aAllELODates.Length];
				double [] dSkillPoints = new double [aAllELOSkills.Length];
				double [] dSkillPointDifferences = new double [aAllELOSkills.Length];
				for (int i = 0; i < dSkillPoints.Length; i++) 
				{
					TimeSpan aTimePassed = aAllELODates [i].Subtract (m_aStartDate);
					dELODates [i] = Convert.ToDouble (aTimePassed.TotalDays);
					dSkillPoints [i] = ((ELOSkill) aAllELOSkills [i]).Points;
					dSkillPointDifferences [i] = (i != dSkillPoints.Length - 1)?((ELOSkill) aAllELOSkills [i + 1]).Points - dSkillPoints [i]:0.0;
				}

				// extract the x and y coordinates (MuSigma performance)
				double [] dMSDates = new double [aAllMuSigmaDates.Length];
				double [] dMu = new double [aAllMuSigmaSkills.Length];
				double [] dMuDifference = new double [aAllMuSigmaSkills.Length];
				double [] dErrorBars = new double [aAllMuSigmaSkills.Length];
				for (int i = 0; i < dMu.Length; i++) 
				{
					TimeSpan aTimePassed = aAllMuSigmaDates [i].Subtract (m_aStartDate);
					dMSDates [i] = Convert.ToDouble (aTimePassed.TotalDays);
					dMu [i] = ((MuSigmaSkill) aAllMuSigmaSkills [i]).Mu;
					dMuDifference [i] = (i != dMu.Length - 1)?((MuSigmaSkill) aAllMuSigmaSkills [i + 1]).Mu - dMu [i]:0.0;
					dErrorBars [i] =((MuSigmaSkill) aAllMuSigmaSkills [i]).Sigma * 1.96;
				}

				// provide the windows with the right data
				m_aPlayerProgression.AddData (dDates, dLevels, m_aPlayerList.GetPlayerName (iPlayerID));
				if (menuPhasePlots.Checked) 
				{
					m_aELOPlayerPerformance.AddData (dSkillPoints, dSkillPointDifferences, m_aPlayerList.GetPlayerName (iPlayerID));
					m_aMuSigmaPlayerPerformance.AddData (dMu, dMuDifference, m_aPlayerList.GetPlayerName (iPlayerID));
				}
				else
				{
					m_aELOPlayerPerformance.AddData (dELODates, dSkillPoints, m_aPlayerList.GetPlayerName (iPlayerID));
					m_aMuSigmaPlayerPerformance.AddData (dMSDates, dMu, dErrorBars, m_aPlayerList.GetPlayerName (iPlayerID));
				}
			}

			// add labels to the player progression plot
			m_aPlayerProgression.Text = "Level Progression with the " + SelectedRankingSystem ().Text + " system";
			m_aPlayerProgression.XAxisTitle = "Days since " + m_aStartDate.ToLongDateString ();
			m_aPlayerProgression.AlternativeXAxisTitle = "Number of games played";
			m_aPlayerProgression.SetAlternativeXAxis ();
			m_aPlayerProgression.YAxisTitle = SelectedRankingSystem ().Text +  " Levels";
			m_aPlayerProgression.UpdateChart ();

			// add labels to the ELO player performance plot
			m_aELOPlayerPerformance.Text = "ELO Player Performance";
			m_aELOPlayerPerformance.AlternativeXAxisTitle = "Number of games played";
			if (menuPhasePlots.Checked) 
			{
				m_aELOPlayerPerformance.XAxisTitle = "Skill points";
				m_aELOPlayerPerformance.YAxisTitle = "Skill points change";
				m_aELOPlayerPerformance.SetXAxis ();
			}
			else
			{
				m_aELOPlayerPerformance.XAxisTitle = "Days since " + m_aStartDate.ToLongDateString ();
				m_aELOPlayerPerformance.YAxisTitle = "Skill points";
				m_aELOPlayerPerformance.SetAlternativeXAxis ();
			}
			m_aELOPlayerPerformance.UpdateChart ();

			// add labels to the MuSigma player performance plot
			m_aMuSigmaPlayerPerformance.Text = "MuSigma Player Performance";
			m_aMuSigmaPlayerPerformance.AlternativeXAxisTitle = "Number of games played";
			if (menuPhasePlots.Checked) 
			{
				m_aMuSigmaPlayerPerformance.XAxisTitle = "Mu";
				m_aMuSigmaPlayerPerformance.YAxisTitle = "Mu change";
				m_aMuSigmaPlayerPerformance.SetXAxis ();
			}
			else 
			{
				m_aMuSigmaPlayerPerformance.XAxisTitle = "Days since " + m_aStartDate.ToLongDateString ();
				m_aMuSigmaPlayerPerformance.YAxisTitle = "Mu";
				m_aMuSigmaPlayerPerformance.SetAlternativeXAxis ();
			}
			m_aMuSigmaPlayerPerformance.UpdateChart ();
		}
		#endregion

		#region Event Handler code
		/// <summary>
		/// Handles a click on a new game. Updates the game data window with the data of the currently selected game.
		/// </summary>
		/// <param name="sender">Sender of the message.</param>
		/// <param name="e">Event arguments when calling the event handler.</param>
		private void lbGameList_SelectedIndexChanged (object sender, System.EventArgs e)
		{
			UpdateGameDataGroupdBox ();
		}

		/// <summary>
		/// Handles a click on a new player. Changes the viewed game ID list to only include the games that were played by the player. 
		/// </summary>
		/// <param name="sender">Sender of the message.</param>
		/// <param name="e">Event arguments when calling the event handles.</param>
		private void lbPlayerList_SelectedIndexChanged (object sender, System.EventArgs e)
		{
			// possibly repopulate the games list
			if (rbViewSelectedGames.Checked) ComputeNewSelection ();

			// refresh the level progression window
			RefreshLevelProgressionWindow ();
		}

		/// <summary>
		/// Handles a click on the "Quit" menu. Closes the application.
		/// </summary>
		/// <param name="sender">Sender of the message.</param>
		/// <param name="e">Event arguments when calling the event handles.</param>
		private void menuQuit_Click(object sender, System.EventArgs e)
		{
			if (menuSaveResults.Enabled)
				switch (MessageBox.Show ("There are unsaved results. Do you want to save?", "Information", MessageBoxButtons.YesNoCancel))
				{
					case DialogResult.Yes: 
						menuSaveResults_Click (null, null);
						this.Close ();
						break;
					case DialogResult.No:
						this.Close ();
						break;
					case DialogResult.Cancel:
						break;
				}
			else	
				this.Close ();
		}

		/// <summary>
		/// Handles a click on the "Read Games ..." menu. Reads the player and games list from a SQL database. Also tries
		/// to read previously computed results or recomputes them.
		/// </summary>
		/// <param name="sender">Sender of the message.</param>
		/// <param name="e">Event arguments when calling the event handles.</param>
		private void menuReadGames_Click(object sender, System.EventArgs e)
		{
			// check that this will not overwrite some previously computed results
			if (menuSaveResults.Enabled)
				switch (MessageBox.Show ("There are unsaved results. Do you want to save?", "Information", MessageBoxButtons.YesNoCancel))
				{
					case DialogResult.Yes: 
						menuSaveResults_Click (null, null);
						break;
					case DialogResult.No:
						break;
					case DialogResult.Cancel:
						return;
				}
						
			// Get the game filters
			DialogResult aDialogResult = m_aSQLImportDialog.ShowDialog ();

			// delegate the work if the user pressed OK
			if (aDialogResult == DialogResult.OK)
				ReadSQLData (true);
		}

		/// <summary>
		/// Handles a click on particular iterations counts menu entry. 
		/// </summary>
		/// <param name="sender">Sender of the message.</param>
		/// <param name="e">Event arguments when calling the event handles.</param>
		private void menuIterationsCount_Click(object sender, System.EventArgs e)
		{
			MenuItem aCurrentItem = (MenuItem) sender;
			aCurrentItem.Checked = !aCurrentItem.Checked;
		}

		/// <summary>
		/// Handles a click on the "Level-Progression Window" menu entry. Displays or hides the level progress window.
		/// </summary>
		/// <param name="sender">Sender of the message.</param>
		/// <param name="e">Event arguments when calling the event handles.</param>
		private void menuShowProgressWindow_Click(object sender, System.EventArgs e)
		{
			// alters the checked state int the menu
			menuShowProgressWindow.Checked = !menuShowProgressWindow.Checked;

			// recreate the progression windows
			CheckProgressionWindows ();
		}
		/// <summary>
		/// Handles a click on the "Performance Windows" menu entry. Displays or hides the several performance windows.
		/// </summary>
		/// <param name="sender">Sender of the message.</param>
		/// <param name="e">Event arguments when calling the event handles.</param>
		private void menuShowPerformanceWindows_Click(object sender, System.EventArgs e)
		{		
			// alters the checked state int the menu
			menuShowPerformanceWindows.Checked = !menuShowPerformanceWindows.Checked;

			// recreate the progression windows
			CheckProgressionWindows ();
		}
		/// <summary>
		/// Handles a click on the "Player and Games only" menu entry.
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		private void menuPlayersandGamesOnly_Click(object sender, System.EventArgs e)
		{
			menuPlayersandGamesOnly.Checked = !menuPlayersandGamesOnly.Checked;

			if (menuPlayersandGamesOnly.Checked)
				Size = new Size (Size.Width - 500, Size.Height);
			else
				Size = new Size (Size.Width + 500, Size.Height);
		}

		/// <summary>
		/// Handles a click on the "Show Log Window" menu entry. Displays the log window dialog.
		/// </summary>
		/// <param name="sender">Sender of the message.</param>
		/// <param name="e">Event arguments when calling the event handles.</param>
		private void menuShowLogWindow_Click(object sender, System.EventArgs e)
		{
			m_aLogWindow.ShowDialog ();
		}

		/// <summary>
		/// Handles a click on the "HALO 2"/"Mu Sigma" ranking results menu entry. This function will also update the options
		/// box, send the new data to the level progression window, update the player list box (if the sorting was not alphabetical) 
		/// and update the game list box if the user also wanted to see selected game only.
		/// </summary>
		/// <param name="sender">Sender of the message.</param>
		/// <param name="e">Event arguments when calling the event handles.</param>
		/// <remarks>This method also changes the field <c>m_aCurrentRankingSystem</c> to the selected ranking system.</remarks>
		private void rbRankingResults_Click(object sender, System.EventArgs e)
		{
			// check if anything change; if not leave the function
			if (((MenuItem) sender).Checked) return;

			// check the checked status of the ranking results submenu
			rbRawHalo2RankingResults.Checked = false;
			rbHalo2RankingResults.Checked  = false;
			rbELORankingResults.Checked = false;
			rbMuSigmaRankingResults.Checked = false;
			((MenuItem) sender).Checked = true;

			// re-assing the m_aCurrentRankingSystem property
			if (rbRawHalo2RankingResults.Checked) 
				m_aCurrentRankingSystem = m_aRawHalo2RankingSystem;
			if (rbHalo2RankingResults.Checked) 
				m_aCurrentRankingSystem = m_aHalo2RankingSystem;
			if (rbELORankingResults.Checked) 
				m_aCurrentRankingSystem= m_aELORankingSystem;
			if (rbMuSigmaRankingResults.Checked) 
				m_aCurrentRankingSystem= m_aMuSigmaRankingSystem;

			// update the options window
			UpdateOptionsBox ();

			// update the player and games list box
			UpdateListBoxes (rbSkillSorting.Checked, rbViewSelectedGames.Checked & rbSkillSorting.Checked);

			// refresh the level progression window
			RefreshLevelProgressionWindow ();

			// update the game data panel
			UpdateGameDataGroupdBox ();		
		}

		/// <summary>
		/// Handles a click on the "view all/ view selected" menu item. This function will also update the options
		/// box and recompute the selected game list.
		/// </summary>
		/// <param name="sender">Sender of the message.</param>
		/// <param name="e">Event arguments when calling the event handles.</param>
		private void rbViewGames_Click(object sender, System.EventArgs e)
		{
			// check if anything change; if not leave the function
			if (((MenuItem) sender).Checked) return;

			// alternate between "all games"/"selected games"
			rbViewAllGames.Checked = false;
			rbViewSelectedGames.Checked = false;
			((MenuItem) sender).Checked = true;

			// update the options window
			UpdateOptionsBox ();

			// update the selection and re-display them
			ComputeNewSelection ();
		}

		/// <summary>
		/// Handles a click on the "at least one"/"all of them" menu item. This function will possibly recompute the 
		/// selected game list.
		/// </summary>
		/// <param name="sender">Sender of the message.</param>
		/// <param name="e">Event arguments when calling the event handles.</param>
		private void rbSelectPolicy_Click(object sender, System.EventArgs e)
		{
			// check if anything change; if not leave the function
			if (((MenuItem) sender).Checked) return;

			// alternate between "or policy"/"an policy"
			rbSelectPolicyAnd.Checked = false;
			rbSelectPolicyOr.Checked = false;
			((MenuItem) sender).Checked = true;

			// update the selection and re-display them (if "view selected games" is enabled)
			if (rbViewSelectedGames.Checked) ComputeNewSelection ();
		}

		/// <summary>
		/// Handles a click on the "alphabetical"/"skill" sorintg menu item. This function will also update the options
		/// box, update the player list box and update the game list box if the user also wanted to see selected game only.
		/// </summary>
		/// <param name="sender">Sender of the message.</param>
		/// <param name="e">Event arguments when calling the event handles.</param>
		private void rbSkill_Click(object sender, System.EventArgs e)
		{
			// check if anything change; if not leave the function
			if (((MenuItem) sender).Checked) return;

			// alternate between "alphabetical"/"skill"
			rbAlphabeticalSorting.Checked = false;
			rbSkillSorting.Checked = false;
			((MenuItem) sender).Checked = true;

			// update the options window
			UpdateOptionsBox ();

			// update the player and games list box
			UpdateListBoxes (true, rbViewSelectedGames.Checked);

			// refresh the level progression window
			RefreshLevelProgressionWindow ();

			// update the game data panel
			UpdateGameDataGroupdBox ();
		}

		/// <summary>
		/// Handles a click on the "Recompute Ranking" menu entry. This function will also update the options
		/// box, send the new data to the level progression window, update the player list box (if the sorting was not alphabetical) 
		/// and update the game list box if the user also wanted to see selected game only.
		/// </summary>
		/// <param name="sender">Sender of the message.</param>
		/// <param name="e">Event arguments when calling the event handles.</param>
		private void menuRecomputeRanking_Click(object sender, System.EventArgs e)
		{
			if (m_aRankingParameters.ShowDialog (true) == DialogResult.OK)
			{
				// Recompute MuSigma ranking
				RecomputeRankingSystems (false);

				// update the player and games list box
				UpdateListBoxes (rbSkillSorting.Checked, rbViewSelectedGames.Checked & rbSkillSorting.Checked);

				// refresh the level progression window
				RefreshLevelProgressionWindow ();

				// update the game data panel
				UpdateGameDataGroupdBox ();		
			}
		
		}

		/// <summary>
		/// Handles a click on the "About" menu entry. Pops up the about window.
		/// </summary>
		/// <param name="sender">Sender of the message.</param>
		/// <param name="e">Event arguments when calling the event handles.</param>
		private void menuAbout_Click(object sender, System.EventArgs e)
		{
			m_aAboutWindow.ShowDialog ();
		}

		/// <summary>
		/// Handles a click on the "Ranking Difference" menu entry. Computes the ranking error of all ranking systems
		/// and displays the results in a new window.
		/// </summary>
		/// <param name="sender">Sender of the message.</param>
		/// <param name="e">Event arguments when calling the event handles.</param>
		private void menuRankingDifference_Click(object sender, System.EventArgs e)
		{
			DrawRankingDifferenceWindow ();
		}

		/// <summary>
		/// Handles a click on the "MuSigma Log Probability" menu entry. Computes the log probability of all each new game for
		/// the MuSigma ranking system and displays the results in a new window.
		/// </summary>
		/// <param name="sender">Sender of the message.</param>
		/// <param name="e">Event arguments when calling the event handles.</param>
		private void menuMuSigmaLogProbability_Click(object sender, System.EventArgs e)
		{
			DrawMuSigmaLogProbability ();
		}

		/// <summary>
		/// Handles a click on the "Save Results" menu entry. This box will only available if there are new results.
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		private void menuSaveResults_Click(object sender, System.EventArgs e)
		{
			// write the results into the SQL database
			WriteRankings ();

			// re-populate the available results list
			GetAvailableResults ();

			// disable the 'Save Results' menu entry
			menuSaveResults.Enabled = false;
		}

		/// <summary>
		/// Handles a click on the "Read Results" menu entry. This box will only be available if there are results in the SQL database.
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		private void menuReadResults_Click(object sender, System.EventArgs e)
		{
			// read the available
			ReadResults ();
		}

		/// <summary>
		/// Handles "MuSigma Iterations Check" menu entry.
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		private void menuMuSigmaIterationsCheck_Click(object sender, System.EventArgs e)
		{
			// delegate the work if the user pressed OK in both the SQL Import box and the ranking parameters box
			if (m_aSQLImportDialog.ShowDialog () == DialogResult.OK && m_aRankingParameters.ShowDialog (true) == DialogResult.OK) 
			{
				// clear the log information list
				m_aLogWindow.ClearLogList ();
				m_aLogWindow.LogName = "SQL Import Log";

				// read the player data
				ReadPlayerNames ();

				// read the games data
				ReadGames ();

				for (int i = 0; i < menuIterationsCount.Length; i++)
				{
					// check if we have to do the computation in the first place
					if (menuIterationsCount [i].Checked) 
					{
						// extract the number of iterations
						int iNumberOfIterations = Convert.ToInt32 (menuIterationsCount [i].Text);

						// set the number of iterations in the MuSigma ranking system
						Console.WriteLine ("Number of iterations: " + iNumberOfIterations);
						m_aLogWindow.AddLine ("====> Iterations: " + iNumberOfIterations + " <====");
						m_aRankingParameters.MuSigmaIterations = iNumberOfIterations;
	
						// re-compute the ranking systems
						RecomputeRankingSystems (true);

						// re-computes the cross-reference list
						ComputeCrossReferenceList ();

						// save the results 
						menuSaveResults_Click (null, null);
					}
				}

				// re-computes the cross-reference list
				ComputeNewSelection ();

				// update the player and game list box 
				UpdateListBoxes (true, false);

				// show the log window
				m_aLogWindow.ShowDialog ();
			}
		}

		/// <summary>
		/// Handles a click on the "Compare Seleceted Players" menu entry. 
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		private void menuCompareSelectedPlayers_Click(object sender, System.EventArgs e)
		{
			CompareSelectedPlayers ();
		}

		/// <summary>
		/// Handles a change of location of the main window.
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		private void MainWindow_LocationChanged(object sender, System.EventArgs e)
		{
			if (menuAttachWindows.Checked) 
			{
				// work out the scaling factor such that all level progression windows fit to the right and left
				double dPlayerProgressionScale = (double) Height / (2.0 * (double) m_aPlayerProgression.Size.Height);
				m_aPlayerProgression.Size = new Size ((int) ((double) m_aPlayerProgression.Size.Width * dPlayerProgressionScale),
					(int) ((double) m_aPlayerProgression.Size.Height * dPlayerProgressionScale)); 
				double dELOPlayerPerformanceScale = (double) Height / (2.0 * (double) m_aMuSigmaPlayerPerformance.Size.Height);
				m_aELOPlayerPerformance.Size = new Size ((int) ((double) m_aELOPlayerPerformance.Size.Width * dELOPlayerPerformanceScale),
					(int) ((double) m_aELOPlayerPerformance.Size.Height * dELOPlayerPerformanceScale)); 
				double dMuSigmaPlayerPerformanceScale = (double) Height / (2.0 * (double) m_aMuSigmaPlayerPerformance.Size.Height);
				m_aMuSigmaPlayerPerformance.Size = new Size ((int) ((double) m_aMuSigmaPlayerPerformance.Size.Width * dMuSigmaPlayerPerformanceScale),
					(int) ((double) m_aMuSigmaPlayerPerformance.Size.Height * dMuSigmaPlayerPerformanceScale)); 
				
				// and now move their position and size to the right and left of the current window
				m_aPlayerProgression.Location = new Point (Location.X + Size.Width, Location.Y);
				m_aELOPlayerPerformance.Location = new Point (Location.X - m_aELOPlayerPerformance.Size.Width, Location.Y);		
				m_aMuSigmaPlayerPerformance.Location = new Point (Location.X - m_aMuSigmaPlayerPerformance.Size.Width, Location.Y + Size.Height / 2);		
			}
		}

		/// <summary>
		/// Handles a click on the "Attach progress windows" menu entry.
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		private void menuAttachWindows_Click(object sender, System.EventArgs e)
		{
			menuAttachWindows.Checked = !menuAttachWindows.Checked;
			MainWindow_LocationChanged (null, null);
		}

		/// <summary>
		/// Handles a click on the "Phase Plots" menu entry
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		private void menuPhasePlots_Click(object sender, System.EventArgs e)
		{
			menuPhasePlots.Checked = !menuPhasePlots.Checked;
			RefreshLevelProgressionWindow ();
		}

		/// <summary>
		/// Handles a click on the "Quick Command" menu entry.
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		private void menuQuickCommands_Click(object sender, System.EventArgs e)
		{
			if (m_aQuickCommandDialog.ShowDialog () == DialogResult.OK) 
			{
				switch (m_aQuickCommandDialog.SelectedCommandIndex) 
				{
					case 0:
						m_aSQLImportDialog.CurrentHopperID = 5;
						m_aSQLImportDialog.CurrentMapID = 0;
						m_aSQLImportDialog.CurrentVariantID = 0;
						m_aSQLImportDialog.UsePlayerFlags = true;
						ReadSQLData (false);
						while (lbPlayerList.SelectedIndices.Count > 0) lbPlayerList.SetSelected (lbPlayerList.SelectedIndices [0], false);
						string [] szSelectedPlayers0 = { "DJ 116", "Striker" };
						for (int i = 0; i < lbPlayerList.Items.Count; i++) 
						{
							for (int j = 0; j < szSelectedPlayers0.Length; j++)
								if (String.Compare ((string) lbPlayerList.Items [i], szSelectedPlayers0 [j]) == 0)
									lbPlayerList.SetSelected (i, true);
						}
						rbRankingResults_Click (rbHalo2RankingResults, null);
						rbSkill_Click (rbSkillSorting, null);
						rbViewGames_Click (rbViewSelectedGames, null);
						rbSelectPolicy_Click (rbSelectPolicyAnd, null);
						if (!menuShowProgressWindow.Checked) menuShowProgressWindow_Click (null, null);
						if (!menuShowPerformanceWindows.Checked) menuShowPerformanceWindows_Click (null, null);
						if (!menuAttachWindows.Checked) menuAttachWindows_Click (null, null);
						if (menuPhasePlots.Checked) menuPhasePlots_Click (null, null);
						menuCompareSelectedPlayers_Click (null, null);
						break;
					case 1:
						m_aSQLImportDialog.CurrentHopperID = 2;
						m_aSQLImportDialog.CurrentMapID = 0;
						m_aSQLImportDialog.CurrentVariantID = 0;
						m_aSQLImportDialog.UsePlayerFlags = true;
						ReadSQLData (false);
						while (lbPlayerList.SelectedIndices.Count > 0) lbPlayerList.SetSelected (lbPlayerList.SelectedIndices [0], false);
						string [] szSelectedPlayers1 = { "char", "SQLwildman" };
						for (int i = 0; i < lbPlayerList.Items.Count; i++) 
						{
							for (int j = 0; j < szSelectedPlayers1.Length; j++)
								if (String.Compare ((string) lbPlayerList.Items [i], szSelectedPlayers1 [j]) == 0)
									lbPlayerList.SetSelected (i, true);
						}
						rbRankingResults_Click (rbHalo2RankingResults, null);
						rbSkill_Click (rbSkillSorting, null);
						rbViewGames_Click (rbViewSelectedGames, null);
						rbSelectPolicy_Click (rbSelectPolicyAnd, null);
						if (!menuShowProgressWindow.Checked) menuShowProgressWindow_Click (null, null);
						if (!menuShowPerformanceWindows.Checked) menuShowPerformanceWindows_Click (null, null);
						if (!menuAttachWindows.Checked) menuAttachWindows_Click (null, null);
						if (menuPhasePlots.Checked) menuPhasePlots_Click (null, null);
						menuCompareSelectedPlayers_Click (null, null);
						break;
					case 2:
						m_aSQLImportDialog.CurrentHopperID = 3;
						m_aSQLImportDialog.CurrentMapID = 0;
						m_aSQLImportDialog.CurrentVariantID = 0;
						m_aSQLImportDialog.UsePlayerFlags = true;
						ReadSQLData (false);
						while (lbPlayerList.SelectedIndices.Count > 0) lbPlayerList.SetSelected (lbPlayerList.SelectedIndices [0], false);
						string [] szSelectedPlayers2 = { "SQLwildman", "BNG herr jones" };
						for (int i = 0; i < lbPlayerList.Items.Count; i++) 
						{
							for (int j = 0; j < szSelectedPlayers2.Length; j++)
								if (String.Compare ((string) lbPlayerList.Items [i], szSelectedPlayers2 [j]) == 0)
									lbPlayerList.SetSelected (i, true);
						}
						rbRankingResults_Click (rbHalo2RankingResults, null);
						rbSkill_Click (rbSkillSorting, null);
						rbViewGames_Click (rbViewSelectedGames, null);
						rbSelectPolicy_Click (rbSelectPolicyOr, null);
						if (!menuShowProgressWindow.Checked) menuShowProgressWindow_Click (null, null);
						if (!menuShowPerformanceWindows.Checked) menuShowPerformanceWindows_Click (null, null);
						if (!menuAttachWindows.Checked) menuAttachWindows_Click (null, null);
						if (menuPhasePlots.Checked) menuPhasePlots_Click (null, null);
						menuCompareSelectedPlayers_Click (null, null);
						break;
					case 3:
						m_aSQLImportDialog.CurrentHopperID = 2;
						m_aSQLImportDialog.CurrentMapID = 0;
						m_aSQLImportDialog.CurrentVariantID = 0;
						m_aSQLImportDialog.UsePlayerFlags = true;
						ReadSQLData (false);
						while (lbPlayerList.SelectedIndices.Count > 0) lbPlayerList.SetSelected (lbPlayerList.SelectedIndices [0], false);
						string [] szSelectedPlayers3 = { "char", "BunBetaJpn02", "Velo", "CrazyPants", "qimugtaqpaq" };
						for (int i = 0; i < lbPlayerList.Items.Count; i++) 
						{
							for (int j = 0; j < szSelectedPlayers3.Length; j++)
								if (String.Compare ((string) lbPlayerList.Items [i], szSelectedPlayers3 [j]) == 0)
									lbPlayerList.SetSelected (i, true);
						}
						rbRankingResults_Click (rbHalo2RankingResults, null);
						rbSkill_Click (rbSkillSorting, null);
						rbViewGames_Click (rbViewSelectedGames, null);
						rbSelectPolicy_Click (rbSelectPolicyOr, null);
						if (!menuShowProgressWindow.Checked) menuShowProgressWindow_Click (null, null);
						if (!menuShowPerformanceWindows.Checked) menuShowPerformanceWindows_Click (null, null);
						if (!menuAttachWindows.Checked) menuAttachWindows_Click (null, null);
						if (menuPhasePlots.Checked) menuPhasePlots_Click (null, null);
						break;
					case 4:
						m_aSQLImportDialog.CurrentHopperID = 5;
						m_aSQLImportDialog.CurrentMapID = 0;
						m_aSQLImportDialog.CurrentVariantID = 0;
						m_aSQLImportDialog.UsePlayerFlags = true;
						ReadSQLData (false);
						while (lbPlayerList.SelectedIndices.Count > 0) lbPlayerList.SetSelected (lbPlayerList.SelectedIndices [0], false);
						rbRankingResults_Click (rbHalo2RankingResults, null);
						rbSkill_Click (rbSkillSorting, null);
						rbViewGames_Click (rbViewSelectedGames, null);
						rbSelectPolicy_Click (rbSelectPolicyOr, null);
						if (menuShowProgressWindow.Checked) menuShowProgressWindow_Click (null, null);
						if (menuShowPerformanceWindows.Checked) menuShowPerformanceWindows_Click (null, null);
						menuRankingDifference_Click (null, null);
						break;
					default: 
						Debug.Assert (false, "Internal error in Quick Command Handling.");
						break;
				}
			}
		}

		/// <summary>
		/// Handles a click on the "Export Equivalent Rankings" menu entry.
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		private void menuExportEquivalentRankings_Click(object sender, System.EventArgs e)
		{
			// open the new stream
			StreamWriter aExportStream = new StreamWriter ("equivalent_rankings.csv", false);

			// go through all the games
			for (int i = 0; i < m_aGameList.NumberOfGames; i++) 
				aExportStream.WriteLine (m_aGameList.GetGame (i).Ranking.NumberOfEquivalenceClasses);

			// close the file
			aExportStream.Close ();
		}

		/// <summary>
		/// Handles a click on the "Evidence analysis ..." menu entry.
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		private void menuEvidenceAnalysis_Click(object sender, System.EventArgs e)
		{
			if (m_aRankingParameters.ShowDialog (true) == DialogResult.OK)
			{
				// Recompute MuSigma ranking for several settings of beta and epsilon
				EvidenceAnalysis ();

				// update the player and games list box
				UpdateListBoxes (rbSkillSorting.Checked, rbViewSelectedGames.Checked & rbSkillSorting.Checked);

				// refresh the level progression window
				RefreshLevelProgressionWindow ();

				// update the game data panel
				UpdateGameDataGroupdBox ();		
			}		
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MuSigma\MuSigma\ResultImportDialog.cs ===
/////////////////////////////////////////////////////////////////////////////////////////////
// ResultImportDialog.cs		Dialog window for the results import.
//
// 2004 written by Ralf Herbrich
// Microsoft Research Ltd.
/////////////////////////////////////////////////////////////////////////////////////////////

using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;

namespace MuSigma
{
	/// <summary>
	/// A class that represents a dialog form for obtaining the result index.
	/// </summary>
	public class ResultImportDialog : System.Windows.Forms.Form
	{
		private System.Windows.Forms.Label label1;
		private System.Windows.Forms.ListBox lbResults;
		private System.Windows.Forms.Label label2;
		private System.Windows.Forms.Label label3;
		private System.Windows.Forms.ListBox lbInformation;
		private System.Windows.Forms.Button btnOk;
		private System.Windows.Forms.Button btnCancel;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		/// <summary>
		/// A variable sized list of result IDs.
		/// </summary>
		private ArrayList m_iResultID;
		/// <summary>
		/// A variable sized list of string lists that contain extra information for every result string.
		/// </summary>
		private ArrayList m_szInformations;

		/// <summary>
		/// Constructs a result import dialog.
		/// </summary>
		public ResultImportDialog()
		{
			// Required for Windows Form Designer support
			InitializeComponent();

			// initialise the informations and result ID list
			m_szInformations = new ArrayList ();
			m_iResultID = new ArrayList ();
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(ResultImportDialog));
			this.label1 = new System.Windows.Forms.Label();
			this.lbResults = new System.Windows.Forms.ListBox();
			this.label2 = new System.Windows.Forms.Label();
			this.label3 = new System.Windows.Forms.Label();
			this.lbInformation = new System.Windows.Forms.ListBox();
			this.btnOk = new System.Windows.Forms.Button();
			this.btnCancel = new System.Windows.Forms.Button();
			this.SuspendLayout();
			// 
			// label1
			// 
			this.label1.Font = new System.Drawing.Font("Microsoft Sans Serif", 24F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.label1.Location = new System.Drawing.Point(16, 16);
			this.label1.Name = "label1";
			this.label1.Size = new System.Drawing.Size(360, 40);
			this.label1.TabIndex = 0;
			this.label1.Text = "Result Import";
			this.label1.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
			// 
			// lbResults
			// 
			this.lbResults.Location = new System.Drawing.Point(16, 88);
			this.lbResults.Name = "lbResults";
			this.lbResults.Size = new System.Drawing.Size(168, 238);
			this.lbResults.TabIndex = 1;
			this.lbResults.SelectedIndexChanged += new System.EventHandler(this.lbResults_SelectedIndexChanged);
			// 
			// label2
			// 
			this.label2.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Italic, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.label2.Location = new System.Drawing.Point(16, 72);
			this.label2.Name = "label2";
			this.label2.Size = new System.Drawing.Size(168, 16);
			this.label2.TabIndex = 2;
			this.label2.Text = "Results";
			this.label2.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
			// 
			// label3
			// 
			this.label3.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Italic, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.label3.Location = new System.Drawing.Point(200, 72);
			this.label3.Name = "label3";
			this.label3.Size = new System.Drawing.Size(168, 16);
			this.label3.TabIndex = 4;
			this.label3.Text = "Information";
			this.label3.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
			// 
			// lbInformation
			// 
			this.lbInformation.Location = new System.Drawing.Point(200, 88);
			this.lbInformation.Name = "lbInformation";
			this.lbInformation.SelectionMode = System.Windows.Forms.SelectionMode.None;
			this.lbInformation.Size = new System.Drawing.Size(216, 238);
			this.lbInformation.TabIndex = 3;
			// 
			// btnOk
			// 
			this.btnOk.DialogResult = System.Windows.Forms.DialogResult.OK;
			this.btnOk.Enabled = false;
			this.btnOk.Location = new System.Drawing.Point(32, 344);
			this.btnOk.Name = "btnOk";
			this.btnOk.Size = new System.Drawing.Size(112, 32);
			this.btnOk.TabIndex = 5;
			this.btnOk.Text = "Load";
			// 
			// btnCancel
			// 
			this.btnCancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
			this.btnCancel.Location = new System.Drawing.Point(248, 344);
			this.btnCancel.Name = "btnCancel";
			this.btnCancel.Size = new System.Drawing.Size(112, 32);
			this.btnCancel.TabIndex = 6;
			this.btnCancel.Text = "Recompute";
			// 
			// ResultImportDialog
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(434, 392);
			this.Controls.Add(this.btnCancel);
			this.Controls.Add(this.btnOk);
			this.Controls.Add(this.label3);
			this.Controls.Add(this.lbInformation);
			this.Controls.Add(this.label2);
			this.Controls.Add(this.lbResults);
			this.Controls.Add(this.label1);
			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
			this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
			this.Name = "ResultImportDialog";
			this.Text = "ResultImportDialog";
			this.ResumeLayout(false);

		}
		#endregion

		/// <summary>
		/// Clears all the results and information lists.
		/// </summary>
		public void Clear ()
		{
			lbResults.Items.Clear ();
			lbInformation.Items.Clear ();
			m_szInformations.Clear ();
			m_iResultID.Clear ();
			btnOk.Enabled = false;
		}

		/// <summary>
		/// Add a result line to the current list.
		/// </summary>
		/// <param name="szResult">The result line to be added.</param>
		/// <param name="szInformation">The list of extra information.</param>
		/// <param name="iResultID">The integer ID of the result.</param>
		public void AddResult (string szResult, string [] szInformation, int iResultID)
		{
			lbResults.Items.Add (szResult);
			m_szInformations.Add (szInformation);
			m_iResultID.Add (iResultID);
		}

		/// <summary>
		/// Handles the selection of a new result line.
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		private void lbResults_SelectedIndexChanged(object sender, System.EventArgs e)
		{
			if (lbResults.SelectedIndex != -1)
			{
				// enable the OK button
				btnOk.Enabled = true;

				// get the right string array
				string [] szInformation = (string []) m_szInformations [lbResults.SelectedIndex];
				// populate the informations listbox
				lbInformation.Items.Clear ();
				for (int i = 0; i < szInformation.Length; i++)
					lbInformation.Items.Add (szInformation [i]);
			}
			else 
				// disable the OK button if no result is selected
				btnOk.Enabled = false;
		}

		/// <summary>
		/// The ID of the selected result.
		/// </summary>
		public int SelectedResultID 
		{
			get 
			{
				return (int) m_iResultID [lbResults.SelectedIndex];
			}
		}
		/// <summary>
		/// A list of information strings about the selected result.
		/// </summary>
		public string [] SelectedResultInformations
		{
			get 
			{
				return (string []) m_szInformations [lbResults.SelectedIndex];
			}
		}
		/// <summary>
		/// Numnber of different results.
		/// </summary>
		public int NumnberOfResults
		{
			get 
			{
				return m_szInformations.Count;
			}
		}

		/// <summary>
		/// Flag if there are any results available.
		/// </summary>
		public bool ResultsAvailable
		{
			get 
			{
				return this.NumnberOfResults > 0;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MuSigma\MuSigmaRankDB\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("MuSigmaRankDB")]
[assembly: AssemblyDescription("Offline MuSigma ranking of game log databases.")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft Research Ltd.")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("2004 (c) Microsoft Resarch Ltd.")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MuSigma\MuSigmaRankDB\MuSigmaRankDB.cs ===
/////////////////////////////////////////////////////////////////////////////////////////////
// MuSigmaRankDB.cs		Main function of the MuSigma ranking system for large databases. This
//						static class delegates most of its work to other classes.
//
// 2004 written by Ralf Herbrich
// Microsoft Research Ltd.
/////////////////////////////////////////////////////////////////////////////////////////////

using System;
using System.IO;

namespace MuSigmaRankDB
{

	/// <summary>
	/// The MuSigmaRankDB allows to rank entire databases. This application is entirely driven by XML control files
	/// and will not require input from the keyboard. 
	/// </summary>
	class MuSigmaRankDB
	{
		/// <summary>
		/// Prints command line help onto the console.
		/// </summary>
		static void CommandLineHelp (string szProgramName)
		{
			Console.WriteLine ("USAGE: " + szProgramName + " <cntrl-file>");
			Console.WriteLine ("\n\t<cntrl-file>\tname of the XML file which controls the ranking task.");
			Console.WriteLine ("\nIf you need any further help, please email rherb@microsoft.com.");
		
			return;
		}

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static int Main (string[] args)
		{
			////////////////////////////////////////////////////////////////
			// output version information
			////////////////////////////////////////////////////////////////
			Version aVersion = typeof (MuSigmaRankDB).Assembly.GetName ().Version;
			Console.WriteLine ("MuSigma Rank Databases (v " + aVersion.ToString () + ")");
			Console.WriteLine ("2004 (c) by Microsoft Research\n");

			// TODO: This piece of code generates a standard configuration XML. This should be moved into a command-line option of the main program.
			// RankingParameters aNewRankingParameters = new RankingParameters ();
			// aNewRankingParameters.Write (new StreamWriter ("Halo2Live.xml"));

			////////////////////////////////////////////////////////////////
			// read the ranking task parameters
			////////////////////////////////////////////////////////////////
			if (args.Length != 1) 
			{
				CommandLineHelp ("MuSigmaRankDB");
				return -1;
			}
			RankingParameters aRankingParameters = null;
			try 
			{
				aRankingParameters = new RankingParameters (args [0]);
			}
			catch (Exception)
			{
				Console.WriteLine ("Could not open file " + args [0]);
				return -1;
			}

			////////////////////////////////////////////////////////////////
			// perform the ranking task
			////////////////////////////////////////////////////////////////
			RankingTask aRankingTask = new RankingTask (aRankingParameters);
			aRankingTask.Run ();

			////////////////////////////////////////////////////////////////
			// finished!
			////////////////////////////////////////////////////////////////
			return 0;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MuSigma\MuSigmaRankDB\RankingParameters.cs ===
/////////////////////////////////////////////////////////////////////////////////////////////
// RankingParameters.cs		Class for managing ranking parameters including input/output from/to XML
//
// 2004 written by Ralf Herbrich
// Microsoft Research Ltd.
/////////////////////////////////////////////////////////////////////////////////////////////

using System;
using System.Xml;
using System.IO;

namespace MuSigmaRankDB
{
	/// <summary>
	/// This class provides the manages the control parameters of a ranking task. It can write the parameters
	/// to XML and read an valid XML file.
	/// </summary>
	public class RankingParameters
	{
		#region Variable declarations
		/// <summary>
		/// Name of the server holding the SQL database.
		/// </summary>
		string m_szServerName;
		/// <summary>
		/// Name of the database holding the data.
		/// </summary>
		string m_szDatabaseName;
		
		/// <summary>
		/// Name of the table containing player data.
		/// </summary>
		string m_szPlayerTableName;
		/// <summary>
		/// Name of the table containing games data.
		/// </summary>
		string m_szGamesTableName;
		/// <summary>
		/// Name of the table containing player information for each game.
		/// </summary>
		string m_szPlayerGamesTableName;
		/// <summary>
		/// Name of the table containing the ranking tasks.
		/// </summary>
		string m_szRankingTasksTableName;
		/// <summary>
		/// Name of the table containing the ranking parameters.
		/// </summary>
		string m_szRankingParametersTableName;
		/// <summary>
		/// Name of the table containing the ranking data for all players.
		/// </summary>
		string m_szRankingDataTableName;

		/// <summary>
		/// Column name of the player ID column.
		/// </summary>
		string m_szColumnNamePlayerID;
		/// <summary>
		/// Column name of the gamertag column
		/// </summary>
		string m_szColumnNameGamertag;
		/// <summary>
		/// Column name of the game ID column.
		/// </summary>
		string m_szColumnNameGameID;
		/// <summary>
		/// Column name of the game time column.
		/// </summary>
		string m_szColumnNameGameTime;
		/// <summary>
		/// Column name of the game list column.
		/// </summary>
		string m_szColumnNameGameList;
		/// <summary>
		/// Column name of the team ID column.
		/// </summary>
		string m_szColumnNameTeamID;
		/// <summary>
		/// Column name of the final score column.
		/// </summary>
		string m_szColumnNameScore;

		/// <summary>
		/// The initial value of \mu for new players.
		/// </summary>
		double m_dMuSigmaPriorMu;
		/// <summary>
		/// The initial value of \sigma for new players.
		/// </summary>
		double m_dMuSigmaPriorSigma;
		/// <summary>
		/// The standard deviation of the performance.
		/// </summary>
		double m_dMuSigmaBeta;
		/// <summary>
		/// The draw margin on the performance scale.
		/// </summary>
		double m_dMuSigmaEpsilon;
		/// <summary>
		/// The dynamics of the skill points.
		/// </summary>
		double m_dMuSigmaTau;

		/// <summary>
		/// Index of the game list that will be ranked. A value of int.MinValue indicates that no game list criterion should be applied.
		/// </summary>
		int m_iRankedGameListID;
		/// <summary>
		/// Name of the game list that will be ranked.
		/// </summary>
		string m_szRankedGameListName;
		/// <summary>
		/// Indicates if the MuSigma algorithm should be used for ranking.
		/// </summary>
		bool m_bUseMuSigma;
		#endregion

		#region Constructor
		/// <summary>
		/// Generates standard ranking parameters.
		/// </summary>
		public RankingParameters ()
		{
			m_szServerName = "msrc-mlpsql";
			m_szDatabaseName = "Halo2Beta";

			m_szPlayerTableName = "tPlayers";
			m_szGamesTableName = "tGames";
			m_szPlayerGamesTableName = "tPlayerGames";
			m_szRankingTasksTableName = "tRankings";
			m_szRankingParametersTableName = "tRankingParameters";
			m_szRankingDataTableName = "tRankingData";

			m_szColumnNamePlayerID = "player_id";
			m_szColumnNameGamertag = "gamertag";
			m_szColumnNameGameID = "game_id";
			m_szColumnNameGameTime = "game_time";
			m_szColumnNameGameList = "game_hopper";
			m_szColumnNameTeamID = "team";
			m_szColumnNameScore = "score";

			m_dMuSigmaPriorMu = 1200.0;
			m_dMuSigmaPriorSigma = 400.0;
			m_dMuSigmaBeta = 250.0;
			m_dMuSigmaEpsilon = 50.0;
			m_dMuSigmaTau = 10.0;
			
			m_iRankedGameListID = 1;
			m_szRankedGameListName = "Free-For-All";
			m_bUseMuSigma = true;
		}

		/// <summary>
		/// Generates a ranking parameters object by reading an XML stream.
		/// </summary>
		/// <param name="aInputStream">Input stream for the XML.</param>
		public RankingParameters (TextReader aInputStream)
		{
			Read (aInputStream);
		}

		/// <summary>
		/// Generates a ranking parameters object by reading from an XML file.
		/// </summary>
		/// <param name="szFileName">Name of the XML file.</param>
		public RankingParameters (string szFileName)
		{
			Read (new StreamReader (szFileName));
		}
		#endregion

		#region Object specific code
		/// <summary>
		/// Computes a hash-code for the ranking parameters set (for list usage). This is done by hasing the 
		/// server name, database name and ranked game list name.
		/// </summary>
		/// <returns>A hash code for the ranking parameters.</returns>
		public override int GetHashCode ()
		{
			string szParameterString = this.ServerName + this.DatabaseName + this.RankedGameListName;
			return szParameterString.GetHashCode ();
		}

		/// <summary>
		/// Compares with a given set of ranking parameters.
		/// </summary>
		/// <param name="aObject">Ranking parameters to compare against.</param>
		/// <returns><c>true</c>, if the ranking parameters are equal; <c>false</c> otherwise.</returns>
		public override bool Equals (object aObject)
		{
			// cast the object
			RankingParameters aRankingParameters = (RankingParameters) aObject;

			// DATASOURCE
			if (aRankingParameters.ServerName.CompareTo (this.ServerName) != 0) return false;
			if (aRankingParameters.DatabaseName.CompareTo (this.DatabaseName) != 0) return false;

			// TABLE NAMES
			if (aRankingParameters.PlayerTableName.CompareTo (this.PlayerTableName) != 0) return false;
			if (aRankingParameters.GamesTableName.CompareTo (this.GamesTableName) != 0) return false;
			if (aRankingParameters.PlayerGamesTableName.CompareTo (this.PlayerGamesTableName) != 0) return false;
			if (aRankingParameters.RankingTasksTableName.CompareTo (this.RankingTasksTableName) != 0) return false;
			if (aRankingParameters.RankingParametersTableName.CompareTo (this.RankingParametersTableName) != 0) return false;
			if (aRankingParameters.RankingDataTableName.CompareTo (this.RankingDataTableName) != 0) return false;

			// COLUMN NAMES
			if (aRankingParameters.ColumnNamePlayerID.CompareTo (this.ColumnNamePlayerID) != 0) return false;
			if (aRankingParameters.ColumnNameGamertag.CompareTo (this.ColumnNameGamertag) != 0) return false;
			if (aRankingParameters.ColumnNameGameID.CompareTo (this.ColumnNameGameID) != 0) return false;
			if (aRankingParameters.ColumnNameGameTime.CompareTo (this.ColumnNameGameTime) != 0) return false;
			if (aRankingParameters.ColumnNameGameList.CompareTo (this.ColumnNameGameList) != 0) return false;
			if (aRankingParameters.ColumnNameTeamID.CompareTo (this.ColumnNameTeamID) != 0) return false;
			if (aRankingParameters.ColumnNameScore.CompareTo (this.ColumnNameScore) != 0) return false;

			// MUSIGMA PARAMETERS
			if (aRankingParameters.MuSigmaPriorMu != this.MuSigmaPriorMu) return false;
			if (aRankingParameters.MuSigmaPriorSigma != this.MuSigmaPriorSigma) return false;
			if (aRankingParameters.MuSigmaBeta != this.MuSigmaBeta) return false;
			if (aRankingParameters.MuSigmaEpsilon != this.MuSigmaEpsilon) return false;
			if (aRankingParameters.MuSigmaTau != this.MuSigmaTau) return false;

			// PROCESSING PARAMETERS
			if (aRankingParameters.RankedGameListID != this.RankedGameListID) return false;
			if (aRankingParameters.RankedGameListName.CompareTo (this.RankedGameListName) != 0) return false;
			if (aRankingParameters.UseMuSigma != this.UseMuSigma) return false;

			// if we arrive here, the ranking parameters must be identical
			return true;
		}
		#endregion

		#region Input and output methods
		/// <summary>
		/// Writes the current ranking parameters to an XML file.
		/// </summary>
		/// <param name="aOutputStream">Output stream for the XML.</param>
		public void Write (TextWriter aOutputStream)
		{
			////////////////////////////////////////////////////////////
			// use the XmlTextWriter class to write one-by-one
			XmlTextWriter aParameterXMLWriter = new XmlTextWriter (aOutputStream);
			aParameterXMLWriter.Formatting= Formatting.Indented;
			aParameterXMLWriter.WriteStartDocument ();
			
			////////////////////////////////////////////////////////////
			// write the data
			Write (aParameterXMLWriter);

			////////////////////////////////////////////////////////////
			// flush the XML to the disc
			aParameterXMLWriter.Flush ();
			aParameterXMLWriter.Close ();
		}
			
		/// <summary>
		/// Writes the current ranking parameters to an XML file.
		/// </summary>
		/// <param name="aParameterXMLWriter">Output XML stream.</param>
		public void Write (XmlTextWriter aParameterXMLWriter)
		{
			// TOP LEVEL
			aParameterXMLWriter.WriteComment ("This element contains all the information for the MuSigmaRankDB application to run. ");
			aParameterXMLWriter.WriteStartElement ("configuration");
			aParameterXMLWriter.WriteAttributeString ("version", "1.0");

			// DATASOURCE
			aParameterXMLWriter.WriteComment ("This element specifies the datasource such as server name, database name, etc. ");
			aParameterXMLWriter.WriteStartElement ("datasource");
			aParameterXMLWriter.WriteElementString  ("server", this.ServerName);
			aParameterXMLWriter.WriteElementString ("database", this.DatabaseName);
			aParameterXMLWriter.WriteFullEndElement ();

			// TABLE NAMES
			aParameterXMLWriter.WriteComment ("This element specifies the table names. ");
			aParameterXMLWriter.WriteStartElement ("tables");
			aParameterXMLWriter.WriteElementString ("players", this.PlayerTableName);
			aParameterXMLWriter.WriteElementString ("games", this.GamesTableName);
			aParameterXMLWriter.WriteElementString ("playergames", this.PlayerGamesTableName);
			aParameterXMLWriter.WriteElementString ("rankingtasks", this.RankingTasksTableName);
			aParameterXMLWriter.WriteElementString ("rankingparameters", this.RankingParametersTableName);
			aParameterXMLWriter.WriteElementString ("rankingdata", this.RankingDataTableName);
			aParameterXMLWriter.WriteFullEndElement ();

			// COLUMN NAMES
			aParameterXMLWriter.WriteComment ("This element specifies the individual column names in the tables. ");
			aParameterXMLWriter.WriteStartElement ("columns");
			aParameterXMLWriter.WriteStartElement ("players");
			aParameterXMLWriter.WriteElementString ("playerid", this.ColumnNamePlayerID);
			aParameterXMLWriter.WriteElementString ("gamertag", this.ColumnNameGamertag);
			aParameterXMLWriter.WriteFullEndElement ();
			aParameterXMLWriter.WriteStartElement ("games");
			aParameterXMLWriter.WriteElementString ("gameid", this.ColumnNameGameID);
			aParameterXMLWriter.WriteElementString ("gametime", this.ColumnNameGameTime);
			aParameterXMLWriter.WriteElementString ("gamelist", this.ColumnNameGameList);
			aParameterXMLWriter.WriteFullEndElement ();
			aParameterXMLWriter.WriteStartElement ("playergames");
			aParameterXMLWriter.WriteElementString ("teamid", this.ColumnNameTeamID);
			aParameterXMLWriter.WriteElementString ("score", this.ColumnNameScore);
			aParameterXMLWriter.WriteFullEndElement ();
			aParameterXMLWriter.WriteFullEndElement ();

			// MUSIGMA PARAMETERS
			aParameterXMLWriter.WriteComment ("This element specifies the parameters of the MuSigma system. ");
			aParameterXMLWriter.WriteStartElement ("musigma");
			aParameterXMLWriter.WriteStartElement ("prior");
			aParameterXMLWriter.WriteElementString ("mu", XmlConvert.ToString (this.MuSigmaPriorMu));
			aParameterXMLWriter.WriteElementString ("sigma", XmlConvert.ToString (this.MuSigmaPriorSigma));
			aParameterXMLWriter.WriteFullEndElement ();
			aParameterXMLWriter.WriteStartElement ("performance");
			aParameterXMLWriter.WriteElementString ("beta", XmlConvert.ToString (this.MuSigmaBeta));
			aParameterXMLWriter.WriteElementString ("epsilon", XmlConvert.ToString (this.MuSigmaEpsilon));
			aParameterXMLWriter.WriteFullEndElement ();
			aParameterXMLWriter.WriteStartElement ("dynamics");
			aParameterXMLWriter.WriteElementString ("tau", XmlConvert.ToString (this.MuSigmaTau));
			aParameterXMLWriter.WriteFullEndElement ();
			aParameterXMLWriter.WriteFullEndElement ();

			// PROCESSING PARAMETERS
			aParameterXMLWriter.WriteComment ("This element specifies the processing to be done. ");
			aParameterXMLWriter.WriteStartElement ("ranking");
			aParameterXMLWriter.WriteStartElement ("gamelist");
			aParameterXMLWriter.WriteElementString ("id", XmlConvert.ToString (this.RankedGameListID));
			aParameterXMLWriter.WriteElementString ("name", this.RankedGameListName);
			aParameterXMLWriter.WriteFullEndElement ();
			aParameterXMLWriter.WriteElementString ("musigma", XmlConvert.ToString (this.UseMuSigma));
			aParameterXMLWriter.WriteFullEndElement ();

			// END OF TOP LEVEL
			aParameterXMLWriter.WriteFullEndElement ();
		}

		/// <summary>
		/// Reads the ranking parameters from an XML stream.
		/// </summary>
		/// <param name="aParameterXMLReader">Input XML stream.</param>
		/// <remarks>This function throws and XmlException if the file format is wrong.</remarks>
		public void Read (XmlTextReader aParameterXMLReader)
		{
			////////////////////////////////////////////////////////////
			// look for the 'configuration' element
			while (aParameterXMLReader.Read () && (aParameterXMLReader.Name.CompareTo ("configuration") != 0));
			if (aParameterXMLReader.EOF)
				throw new Exception ("XML parameter file does not contain an 'configuration' element.");
			if (aParameterXMLReader.GetAttribute ("version").CompareTo ("1.0") != 0)
				throw new Exception ("Wrong version of the configuration. Only version 1.0 is supported.");
			aParameterXMLReader.Read ();	

			// DATASOURCE
			aParameterXMLReader.ReadStartElement ("datasource");
			m_szServerName = aParameterXMLReader.ReadElementString ("server");
			m_szDatabaseName = aParameterXMLReader.ReadElementString ("database");
			aParameterXMLReader.ReadEndElement ();
			
			// TABLE NAMES
			aParameterXMLReader.ReadStartElement ("tables");
			m_szPlayerTableName = aParameterXMLReader.ReadElementString ("players");
			m_szGamesTableName = aParameterXMLReader.ReadElementString ("games");
			m_szPlayerGamesTableName = aParameterXMLReader.ReadElementString ("playergames");
			m_szRankingTasksTableName = aParameterXMLReader.ReadElementString ("rankingtasks");
			m_szRankingParametersTableName = aParameterXMLReader.ReadElementString ("rankingparameters");
			m_szRankingDataTableName = aParameterXMLReader.ReadElementString ("rankingdata");
			aParameterXMLReader.ReadEndElement ();

			// COLUMN NAMES
			aParameterXMLReader.ReadStartElement ("columns");
			aParameterXMLReader.ReadStartElement ("players");
			m_szColumnNamePlayerID = aParameterXMLReader.ReadElementString ("playerid");
			m_szColumnNameGamertag = aParameterXMLReader.ReadElementString ("gamertag");
			aParameterXMLReader.ReadEndElement ();
			aParameterXMLReader.ReadStartElement ("games");
			m_szColumnNameGameID = aParameterXMLReader.ReadElementString ("gameid");
			m_szColumnNameGameTime = aParameterXMLReader.ReadElementString ("gametime");
			m_szColumnNameGameList = aParameterXMLReader.ReadElementString ("gamelist");
			aParameterXMLReader.ReadEndElement ();
			aParameterXMLReader.ReadStartElement ("playergames");
			m_szColumnNameTeamID = aParameterXMLReader.ReadElementString ("teamid");
			m_szColumnNameScore = aParameterXMLReader.ReadElementString ("score");
			aParameterXMLReader.ReadEndElement ();
			aParameterXMLReader.ReadEndElement ();

			// MUSIGMA PARAMETERS
			aParameterXMLReader.ReadStartElement ("musigma");
			aParameterXMLReader.ReadStartElement ("prior");
			m_dMuSigmaPriorMu = XmlConvert.ToDouble (aParameterXMLReader.ReadElementString ("mu"));
			m_dMuSigmaPriorSigma = XmlConvert.ToDouble (aParameterXMLReader.ReadElementString ("sigma"));
			aParameterXMLReader.ReadEndElement ();
			aParameterXMLReader.ReadStartElement ("performance");
			m_dMuSigmaBeta = XmlConvert.ToDouble (aParameterXMLReader.ReadElementString ("beta"));
			m_dMuSigmaEpsilon = XmlConvert.ToDouble (aParameterXMLReader.ReadElementString ("epsilon"));
			aParameterXMLReader.ReadEndElement ();
			aParameterXMLReader.ReadStartElement ("dynamics");
			m_dMuSigmaTau = XmlConvert.ToDouble (aParameterXMLReader.ReadElementString ("tau"));
			aParameterXMLReader.ReadEndElement ();
			aParameterXMLReader.ReadEndElement ();

			// PROCESSING PARAMETERS
			aParameterXMLReader.ReadStartElement ("ranking");
			aParameterXMLReader.ReadStartElement ("gamelist");
			m_iRankedGameListID =  XmlConvert.ToInt32 (aParameterXMLReader.ReadElementString ("id"));
			m_szRankedGameListName = aParameterXMLReader.ReadElementString ("name");
			aParameterXMLReader.ReadEndElement ();
			m_bUseMuSigma = XmlConvert.ToBoolean (aParameterXMLReader.ReadElementString ("musigma"));
			aParameterXMLReader.ReadEndElement ();
		}

		/// <summary>
		/// Reads the ranking parameters from an XML stream.
		/// </summary>
		/// <param name="aInputStream">Input stream for the XML.</param>
		/// <remarks>This function throws and XmlException if the file format is wrong.</remarks>
		public void Read (TextReader aInputStream)
		{
			////////////////////////////////////////////////////////////
			// use the XmlTextReader class to read one-by-one
			XmlTextReader aParameterXMLReader = new XmlTextReader (aInputStream);

			////////////////////////////////////////////////////////////
			// read the data
			Read (aParameterXMLReader);

			////////////////////////////////////////////////////////////
			// close the XML reader
			aParameterXMLReader.Close ();
		}
		#endregion

		#region Accessors
		/// <summary>
		/// The name of the SQL server holding the game log database.
		/// </summary>
		public string ServerName
		{
			get 
			{
				return m_szServerName;
			}
		}

		/// <summary>
		/// The name of the database holding the game log data.
		/// </summary>
		public string DatabaseName
		{
			get 
			{
				return m_szDatabaseName;
			}
		}

		/// <summary>
		/// Name of the table containing player data.
		/// </summary>
		public string PlayerTableName
		{
			get 
			{
				return m_szPlayerTableName;
			}
		}

		/// <summary>
		/// Name of the table containing games data.
		/// </summary>
		public string GamesTableName
		{
			get
			{
				return m_szGamesTableName;
			}
		}

		/// <summary>
		/// Name of the table containing player information for each game.
		/// </summary>
		public string PlayerGamesTableName
		{
			get 
			{
				return m_szPlayerGamesTableName;
			}
		}

		/// <summary>
		/// Name of the table containing the ranking tasks.
		/// </summary>
		public string RankingTasksTableName
		{
			get 
			{
				return m_szRankingTasksTableName;
			}
		}

		/// <summary>
		/// Name of the table containing the ranking parameters.
		/// </summary>
		public string RankingParametersTableName
		{
			get
			{
				return m_szRankingParametersTableName;
			}
		}

		/// <summary>
		/// Name of the table containing the ranking data for all players.
		/// </summary>
		public string RankingDataTableName
		{
			get
			{
				return m_szRankingDataTableName;
			}
		}

		/// <summary>
		/// Column name of the player ID column.
		/// </summary>
		public string ColumnNamePlayerID
		{
			get
			{
				return m_szColumnNamePlayerID;
			}
		}

		/// <summary>
		/// Column name of the gamertag column
		/// </summary>
		public string ColumnNameGamertag
		{
			get 
			{
				return m_szColumnNameGamertag;
			}
		}

		/// <summary>
		/// Column name of the game ID column.
		/// </summary>
		public string ColumnNameGameID
		{
			get 
			{
				return m_szColumnNameGameID;
			}
		}

		/// <summary>
		/// Column name of the game time column.
		/// </summary>
		public string ColumnNameGameTime
		{
			get
			{
				return m_szColumnNameGameTime;
			}
		}

		/// <summary>
		/// Column name of the game list column.
		/// </summary>
		public string ColumnNameGameList
		{
			get 
			{
				return m_szColumnNameGameList;
			}
		}

		/// <summary>
		/// Column name of the team ID column.
		/// </summary>
		public string ColumnNameTeamID
		{
			get 
			{
				return m_szColumnNameTeamID;
			}
		}

		/// <summary>
		/// Column name of the final score column.
		/// </summary>
		public string ColumnNameScore
		{
			get 
			{
				return m_szColumnNameScore;
			}
		}

		/// <summary>
		/// The initial value of \mu for new players.
		/// </summary>
		public double MuSigmaPriorMu 
		{
			get
			{
				return m_dMuSigmaPriorMu;
			}
		}

		/// <summary>
		/// The initial value of \sigma for new players.
		/// </summary>
		public double MuSigmaPriorSigma 
		{
			get 
			{
				return m_dMuSigmaPriorSigma;
			}
		}

		/// <summary>
		/// The standard deviation of the performance.
		/// </summary>
		public double MuSigmaBeta
		{
			get 
			{
				return m_dMuSigmaBeta;
			}
		}

		/// <summary>
		/// The draw margin on the performance scale.
		/// </summary>
		public double MuSigmaEpsilon
		{
			get 
			{
				return m_dMuSigmaEpsilon;
			}
		}

		/// <summary>
		/// The dynamics of the skill points.
		/// </summary>
		public double MuSigmaTau
		{
			get 
			{
				return m_dMuSigmaTau;
			}
		}

		/// <summary>
		/// Index of the game list that will be ranked. A value of int.MinValue indicates that no game list criterion should be applied.
		/// </summary>
		public int RankedGameListID
		{
			get
			{
				return m_iRankedGameListID;
			}
		}

		/// <summary>
		/// Name of the game list that will be ranked.
		/// </summary>
		public string RankedGameListName
		{
			get 
			{
				return m_szRankedGameListName;
			}
		}

		/// <summary>
		/// Indicates if the MuSigma algorithm should be used for ranking.
		/// </summary>
		public bool UseMuSigma
		{
			get
			{
				return m_bUseMuSigma;
			}
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MuSigma\MuSigmaRankDB\RankingTask.cs ===
/////////////////////////////////////////////////////////////////////////////////////////////
// RankingTask.cs		Class for managing a ranking task including the progress of the 
//						ranking task.
//
// 2004 written by Ralf Herbrich
// Microsoft Research Ltd.
/////////////////////////////////////////////////////////////////////////////////////////////

using System;
using System.IO;
using System.Xml;
using System.Data.SqlClient;
using System.Data.SqlTypes;
using System.Text;
using MSRanking;
using MSRanking.RankingSystems;
using MSRanking.Skills;

namespace MuSigmaRankDB
{
	/// <summary>
	/// This class tracks a ranking task. It manages enough information to be able to continue a previously interrupted
	/// ranking task computations.
	/// </summary>
	public class RankingTask
	{
		#region Variable declarations
		/// <summary>
		/// The ranking parameters for the ranking task.
		/// </summary>
		RankingParameters m_aRankingParameters;
		/// <summary>
		/// The ranking system used for the ranking task.
		/// </summary>
		MuSigmaRankingSystem m_aMuSigmaRankingSystem;
		/// <summary>
		/// The current list of players.
		/// </summary>
		PlayerList m_aPlayerList;
		/// <summary>
		/// The time of the game where the last update has happened. We use strings to be able to set this to "undefined".
		/// </summary>
		string m_szLastUpdateGameTime;
		/// <summary>
		/// In the case of ties, the unique game ID helps to distinguish.
		/// </summary>
		int m_iLastUpdateGameID;
		/// <summary>
		/// The unique ID of the current ranking task.
		/// </summary>
		int m_iTaskID;
		/// <summary>
		/// The SQL connection to the database specified for this ranking task.
		/// </summary>
		SqlConnection m_aSQLConnection;
		#endregion 

		#region Constructors
		/// <summary>
		/// Constructs a new ranking task. 
		/// </summary>
		/// <param name="aRankingParameters">The ranking parameters to be used. Some of them uniquely describe the ranking
		/// task.</param>
		public RankingTask (RankingParameters aRankingParameters)
		{
			m_aRankingParameters = aRankingParameters;
			m_aMuSigmaRankingSystem = new MuSigmaRankingSystem (new PlayerSkillsList (),
				m_aRankingParameters.MuSigmaBeta, 
				m_aRankingParameters.MuSigmaEpsilon, 
				m_aRankingParameters.MuSigmaTau);
			m_aPlayerList = new PlayerList ();
			m_szLastUpdateGameTime = "undefined";
			m_iLastUpdateGameID = -1;
			m_aSQLConnection = null;
			m_iTaskID = -1;
		}
		#endregion 

		#region SQL helper code
		/// <summary>
		/// Opens a new SQL connection to the specified server.
		/// </summary>
		/// <remarks>This method throws an exception if the connection cannot be opened. Also, it automatically closes an earlier connection 
		/// not yet closed properly.</remarks>
		private void OpenSQLConnection ()
		{
			// close the current connection first
			CloseSQLConnection (m_aSQLConnection);

			// and open a new one with the new parameters
			m_aSQLConnection = OpenNewSQLConnection ();

			// done!
			return;
		}

		/// <summary>
		/// Opens a new SQL connection to the specified server.
		/// </summary>
		/// <returns>The new SQL connection.</returns>
		/// <remarks>This method throws an exception if the connection cannot be opened.</remarks>
		private SqlConnection OpenNewSQLConnection ()
		{
			// open a new SQL connection with the new parameters
			SqlConnection aSQLConnection = new SqlConnection ("Initial Catalog = " + m_aRankingParameters.DatabaseName + "; Data Source = " + 
				m_aRankingParameters.ServerName + "; Integrated Security = SSPI");
			aSQLConnection.Open ();

			// return the new SQL connection
			return aSQLConnection;
		}

		/// <summary>
		/// Executes the SQL script command on a SQL connection. 
		/// </summary>
		/// <param name="aSQLConnection">The SQL connection on which to execute the command.</param>
		/// <param name="szCommand">The SQL script to be executed.</param>
		/// <param name="iTimeOut">The number of seconds for the command to time-out</param>
		private void ExecuteSQLCommand (SqlConnection aSQLConnection, string szCommand, int iTimeOut)
		{
			// executes the command with no timeout
			SqlCommand aSQLCommand = new SqlCommand (szCommand, aSQLConnection);
			aSQLCommand.CommandTimeout = iTimeOut;
			aSQLCommand.ExecuteNonQuery ();

			//done!
			return;
		}

		/// <summary>
		/// Executes the SQL script command on a SQL connection. This command will not time-out. 
		/// </summary>
		/// <param name="aSQLConnection">The SQL connection on which to execute the command.</param>
		/// <param name="szCommand">The SQL script to be executed.</param>
		private void ExecuteSQLCommand (SqlConnection aSQLConnection, string szCommand)
		{
			// set the time-out to zero
			ExecuteSQLCommand (aSQLConnection, szCommand, 0);

			//done!
			return;
		}

		/// <summary>
		/// Executes the SQL script command on the current connection. 
		/// </summary>
		/// <param name="szCommand">The SQL script to be executed.</param>
		/// <param name="iTimeOut">The number of seconds for the command to time-out</param>
		/// <remarks>This method opens a new connection if there is no open connection. However, the connection is not being
		/// closed automatically!</remarks>
		private void ExecuteSQLCommand (string szCommand, int iTimeOut)
		{
			// ensure that there is a SQL connection
			if (m_aSQLConnection == null) OpenSQLConnection ();

			// executes the command with a specified timeout
			ExecuteSQLCommand (m_aSQLConnection, szCommand, iTimeOut);

			//done!
			return;
		}

		/// <summary>
		/// Executes the SQL script command on the current connection. This command will not time-out.
		/// </summary>
		/// <param name="szCommand">The SQL script to be executed.</param>
		/// <remarks>This method opens a new connection if there is no open connection. However, the connection is not being
		/// closed automatically!</remarks>
		private void ExecuteSQLCommand (string szCommand)
		{
			ExecuteSQLCommand (szCommand, 0);
		}

		/// <summary>
		/// Executes the SQL script on a SQL connection and returns a SQL data reader for the results.
		/// </summary>
		/// <param name="aSQLConnection">A SQL connection on which to execute the SQL reader command.</param>
		/// <param name="szCommand">The SQL scripte to be executed.</param>
		/// <param name="iTimeOut">The number of seconds for the command to time-out.</param>
		/// <returns>A SQL data reader for sequential access to the results.</returns>
		private SqlDataReader ExecuteReader (SqlConnection aSQLConnection, string szCommand, int iTimeOut)
		{
			// execute the reader
			SqlCommand aSQLCommand = new SqlCommand (szCommand, aSQLConnection);
			aSQLCommand.CommandTimeout = iTimeOut;
			SqlDataReader aSQLReader = aSQLCommand.ExecuteReader ();

			// return the reader after success
			return aSQLReader;
		}

		/// <summary>
		/// Executes the SQL script on a SQL connection and returns a SQL data reader for the results without time-out.
		/// </summary>
		/// <param name="aSQLConnection">A SQL connection on which to execute the SQL reader command.</param>
		/// <param name="szCommand">The SQL scripte to be executed.</param>
		/// <returns>A SQL data reader for sequential access to the results.</returns>
		private SqlDataReader ExecuteReader (SqlConnection aSQLConnection, string szCommand)
		{
			// return the reader after success
			return ExecuteReader (aSQLConnection, szCommand, 0);
		}

		/// <summary>
		/// Executes the SQL script on the current connection and returns a SQL data reader for the results.
		/// </summary>
		/// <param name="szCommand">The SQL scripte to be executed.</param>
		/// <param name="iTimeOut">The number of seconds for the command to time-out.</param>
		/// <returns>A SQL data reader for sequential access to the results.</returns>
		/// <remarks>This method opens a new connection if there is no open connection. However, the connection is not being
		/// closed automatically!</remarks>
		private SqlDataReader ExecuteReader (string szCommand, int iTimeOut)
		{
			// ensure that there is a SQL connection
			if (m_aSQLConnection == null) OpenSQLConnection ();

			// return the reader after success
			return ExecuteReader (m_aSQLConnection, szCommand, iTimeOut);
		}

		/// <summary>
		/// Executes the SQL script on the current connection and returns a SQL data reader for the results without time-out.
		/// </summary>
		/// <param name="szCommand">The SQL scripte to be executed.</param>
		/// <returns>A SQL data reader for sequential access to the results.</returns>
		/// <remarks>This method opens a new connection if there is no open connection. However, the connection is not being
		/// closed automatically!</remarks>
		private SqlDataReader ExecuteReader (string szCommand)
		{
			// execute the reader without time-out
			return ExecuteReader (szCommand, 0);
		}

		/// <summary>
		/// Closes a SQL connection.
		/// </summary>
		private void CloseSQLConnection (SqlConnection aSQLConnection)
		{
			if (aSQLConnection != null) 
				aSQLConnection.Close ();

			// done!
			return;
		}

		/// <summary>
		/// Closes the current SQL connection.
		/// </summary>
		/// <remarks>This method does nothing if there is no open SQL connection.</remarks>
		private void CloseSQLConnection ()
		{
			// closes the connection
			CloseSQLConnection (m_aSQLConnection);
			m_aSQLConnection = null;

			// done!
			return;
		}

		/// <summary>
		/// Creates all the results tables.
		/// </summary>
		private void CreateResultTables ()
		{
			//////////////////////////////////////////////////////////////////////////
			// RANKING TASKS TABLE
			//////////////////////////////////////////////////////////////////////////
			try 
			{
				ExecuteSQLCommand ("if not exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[" + 
					m_aRankingParameters.RankingTasksTableName + 
					"]') and OBJECTPROPERTY(id, N'IsUserTable') = 1) BEGIN CREATE TABLE [dbo].[" + 
					m_aRankingParameters.RankingTasksTableName + 
					"] ([task_id] [int] IDENTITY (1, 1) NOT NULL ,[task_startdate] [datetime] NOT NULL ," + 
					"[task_playlistid] [int] NOT NULL ,[task_playlistname] [char] (64) NOT NULL) ON [PRIMARY] END");
				ExecuteSQLCommand ("ALTER TABLE [dbo].[" + m_aRankingParameters.RankingTasksTableName + 
					"] WITH NOCHECK ADD CONSTRAINT [PK_" + m_aRankingParameters.RankingTasksTableName + 
					"] PRIMARY KEY  CLUSTERED ([task_id]) ON [PRIMARY]");
				ExecuteSQLCommand ("exec sp_addextendedproperty N'MS_Description', N'Unique ID of the ranking task', N'user', N'dbo', N'table', N'" + 
					m_aRankingParameters.RankingTasksTableName + "', N'column', N'task_id'");
				ExecuteSQLCommand ("exec sp_addextendedproperty N'MS_Description', N'Unique ID of the play list processed in this ranking task', N'user', N'dbo', N'table', N'" + 
					m_aRankingParameters.RankingTasksTableName + "', N'column', N'task_playlistid'");
				ExecuteSQLCommand ("exec sp_addextendedproperty N'MS_Description', N'Name of the playlist processed in this ranking task', N'user', N'dbo', N'table', N'" + 
					m_aRankingParameters.RankingTasksTableName + "', N'column', N'task_playlistname'");
				ExecuteSQLCommand ("exec sp_addextendedproperty N'MS_Description', N'Start date of the ranking task', N'user', N'dbo', N'table', N'" + 
					m_aRankingParameters.RankingTasksTableName + "', N'column', N'task_startdate'");
			}
			catch 
			{
				Console.WriteLine ("[Ranking task table exists already]");
			}

			//////////////////////////////////////////////////////////////////////////
			// RANKING PARAMETERS TABLE
			//////////////////////////////////////////////////////////////////////////
			try 
			{
				ExecuteSQLCommand ("if not exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[" + 
					m_aRankingParameters.RankingParametersTableName + "]') and OBJECTPROPERTY(id, N'IsUserTable') = 1) BEGIN CREATE TABLE [dbo].[" + 
					m_aRankingParameters.RankingParametersTableName + "] ([row_id] [int] IDENTITY (1, 1) NOT NULL , [task_id] [int] NOT NULL ," + 
					"[parameter_name] [char] (64) NOT NULL , [parameter_value] [char] (256) NOT NULL ) ON [PRIMARY] END");
				ExecuteSQLCommand ("ALTER TABLE [dbo].[" + m_aRankingParameters.RankingParametersTableName + 
					"] WITH NOCHECK ADD CONSTRAINT [PK_" + m_aRankingParameters.RankingParametersTableName + 
					"] PRIMARY KEY  CLUSTERED ([row_id])  ON [PRIMARY]");
				ExecuteSQLCommand ("exec sp_addextendedproperty N'MS_Description', N'Name of the parameter', N'user', N'dbo', N'table', N'" + 
					m_aRankingParameters.RankingParametersTableName + "', N'column', N'parameter_name'");
				ExecuteSQLCommand ("exec sp_addextendedproperty N'MS_Description', N'Value of the parameter', N'user', N'dbo', N'table', N'" + 
					m_aRankingParameters.RankingParametersTableName + "', N'column', N'parameter_value'");
				ExecuteSQLCommand ("exec sp_addextendedproperty N'MS_Description', N'Unique ID of the ranking task', N'user', N'dbo', N'table', N'" + 
					m_aRankingParameters.RankingParametersTableName + "', N'column', N'task_id'");
			}
			catch
			{
				Console.WriteLine ("[Ranking parameters table exists already]");
			}

			//////////////////////////////////////////////////////////////////////////
			// RANKING DATA TABLE
			//////////////////////////////////////////////////////////////////////////
			try 
			{
				ExecuteSQLCommand ("if not exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[" + 
					m_aRankingParameters.RankingDataTableName + "]') and OBJECTPROPERTY(id, N'IsUserTable') = 1) BEGIN CREATE TABLE [dbo].[" + 
					m_aRankingParameters.RankingDataTableName + "] ([row_id] [bigint] IDENTITY (1, 1) NOT NULL , [task_id] [int] NOT NULL , " + 
					"[player_id] [bigint] NOT NULL , [rank_date] [datetime] NOT NULL , [mu] [float] NOT NULL , [sigma] [float] NOT NULL ) ON [PRIMARY] END");
//				ExecuteSQLCommand ("CREATE CLUSTERED INDEX [IX_Player_ID] ON [dbo].[" + m_aRankingParameters.RankingDataTableName + 
//					"]([player_id]) ON [PRIMARY]");
				ExecuteSQLCommand ("ALTER TABLE [dbo].[" + m_aRankingParameters.RankingDataTableName + 
					"] WITH NOCHECK ADD CONSTRAINT [PK_tRankingData] PRIMARY KEY  NONCLUSTERED ([row_id]) ON [PRIMARY]");

				ExecuteSQLCommand ("exec sp_addextendedproperty N'MS_Description', N'The mean of the skill belief', N'user', N'dbo', N'table', N'" + 
					m_aRankingParameters.RankingDataTableName + "', N'column', N'mu'");
				ExecuteSQLCommand ("exec sp_addextendedproperty N'MS_Description', N'The unique ID of the player', N'user', N'dbo', N'table', N'" + 
					m_aRankingParameters.RankingDataTableName + "', N'column', N'player_id'");
				ExecuteSQLCommand ("exec sp_addextendedproperty N'MS_Description', N'The date at which this ranking is valid', N'user', N'dbo', N'table', N'" + 
					m_aRankingParameters.RankingDataTableName + "', N'column', N'rank_date'");
				ExecuteSQLCommand ("exec sp_addextendedproperty N'MS_Description', N'The standard deviation of the skill belief', N'user', N'dbo', N'table', N'" + 
					m_aRankingParameters.RankingDataTableName + "', N'column', N'sigma'");
				ExecuteSQLCommand ("exec sp_addextendedproperty N'MS_Description', N'The unique ID of the ranking task', N'user', N'dbo', N'table', N'" + 
					m_aRankingParameters.RankingDataTableName + "', N'column', N'task_id'");
			}
			catch 
			{
				Console.WriteLine ("[Ranking data table exists already]");
			}
		}
		#endregion

		#region Game update code
		/// <summary>
		/// Updates the databases with a new game. 
		/// </summary>
		/// <param name="aSQLConnection">The SQL connection on which to execute the reader command.</param>
		/// <param name="iGameID">The unqiue game ID.</param>
		/// <param name="aGameTime">The time at which the game has happened.</param>
		/// <returns>This time may have been adjusted by the function to the earliest time the game 
		/// has happened because thre is already data for at least one of the players.</returns>
		/// <remarks>The caller has to ensure that the SQL connection is open.</remarks>
		private DateTime UpdateGame (SqlConnection aSQLConnection, int iGameID, DateTime aGameTime)
		{		
			// generate a new game
			Game aGame = new Game (aGameTime);

			// prepare an update for the uninitialised players
			StringBuilder szUpdateString = new StringBuilder ();

			//////////////////////////////////////////////////////////////////////
			// read all the players, teams and scores for the current game
			//////////////////////////////////////////////////////////////////////
			SqlDataReader aGameDataReader = ExecuteReader (aSQLConnection, "SELECT " + m_aRankingParameters.ColumnNamePlayerID + ", " + 
				m_aRankingParameters.ColumnNameTeamID + ", " + m_aRankingParameters.ColumnNameScore + " FROM [dbo].[" + 
				m_aRankingParameters.PlayerGamesTableName + "] WHERE (" + m_aRankingParameters.ColumnNameGameID + " = " + 
				iGameID.ToString () + ") ORDER BY " + m_aRankingParameters.ColumnNameTeamID);

			while (aGameDataReader.Read ())
			{
				// convert the results
				long lPlayerID = aGameDataReader.GetInt64 (0);
				short iTeamID = aGameDataReader.GetInt16 (1);
				short iScore = aGameDataReader.GetInt16 (2);

				// try to retrieve the internal player ID
				int iPlayerID = m_aPlayerList.GetPlayerID (lPlayerID.ToString ());

				// add the player to the player list (if he does not yet exists)
				PlayerSkills aPlayerSkills = null;
				if (iPlayerID == -1) 
				{
					// add the player and initialise his skills in memory
					iPlayerID = m_aPlayerList.AddPlayer (lPlayerID.ToString ());
					aPlayerSkills = new PlayerSkills (2);
					m_aMuSigmaRankingSystem.PlayerSkillsList.AddPlayerSkills (aPlayerSkills, iPlayerID);
					MuSigmaSkill aMuSigmaSkill = new MuSigmaSkill (m_aRankingParameters.MuSigmaPriorMu, m_aRankingParameters.MuSigmaPriorSigma);
					aPlayerSkills.AddSkill (aMuSigmaSkill, aGameTime);

					szUpdateString.Append ("INSERT INTO [dbo].[" + 
						m_aRankingParameters.RankingDataTableName + "] (task_id, player_id, rank_date, mu, sigma) VALUES (" +
						m_iTaskID.ToString () + ", " + 
						lPlayerID.ToString () + ", " + 
						"'" + aGameTime.ToLongDateString () + " " + aGameTime.ToLongTimeString () + "', " + 
						m_aRankingParameters.MuSigmaPriorMu.ToString () + ", " + 
						m_aRankingParameters.MuSigmaPriorSigma.ToString () + ")\n");
				}
				else
					aPlayerSkills = m_aMuSigmaRankingSystem.PlayerSkillsList.GetPlayerSkills (iPlayerID);

				// re-adjust the game time such that all player skills will be before or at the game time
				if (aPlayerSkills.LatestDate > aGameTime)
					aGameTime = aPlayerSkills.LatestDate;

				// add the player to the team
				for (int i = aGame.NumberOfTeams; i <= iTeamID; i++)
					aGame.AddTeam (new Team ());
				aGame.GetTeam (iTeamID).AddPlayer (iPlayerID, iScore);
			}
			aGameDataReader.Close ();
			aGame.RemoveEmptyTeams ();

			// write back the player skill initialisations (if necessary)
			if (szUpdateString.Length > 0)
				ExecuteSQLCommand (aSQLConnection, szUpdateString.ToString ());

			try 
			{
				//////////////////////////////////////////////////////////////////////
				// update the statistics
				//////////////////////////////////////////////////////////////////////
				m_aMuSigmaRankingSystem.Update (aGame);
			
				//////////////////////////////////////////////////////////////////////
				// write the new statistics into the database
				//////////////////////////////////////////////////////////////////////
				aGameTime = aGameTime.AddSeconds (+1);			// the results are valid one second after the game has happened
				int [] iPlayerIDs = aGame.PlayerIDs;
				szUpdateString = new StringBuilder ();
				for (int i = 0; i < iPlayerIDs.Length; i++) 
				{
					MuSigmaSkill aSkill = (MuSigmaSkill) m_aMuSigmaRankingSystem.PlayerSkillsList.GetPlayerSkills (iPlayerIDs [i]).LatestSkill;
					szUpdateString.Append ("INSERT INTO [dbo].[" + 
						m_aRankingParameters.RankingDataTableName + "] (task_id, " + 
						m_aRankingParameters.ColumnNamePlayerID + ", rank_date, mu, sigma) VALUES (" +
						m_iTaskID.ToString () + ", " + 
						m_aPlayerList.GetPlayerName (iPlayerIDs [i]) + ", " + 
						"'" + aGameTime.ToLongDateString () + " " + aGameTime.ToLongTimeString () + "', " + 
						aSkill.Mu.ToString () + ", " + 
						aSkill.Sigma.ToString () + ")\n");
				}
				ExecuteSQLCommand (aSQLConnection, szUpdateString.ToString ());
				aGameTime = aGameTime.AddSeconds (-1);			// re-adjust the time for the return value
			}
			catch 
			{
				Console.WriteLine ("\tSkipped game");
			}

			// done!
			return aGameTime;
		}
		#endregion

		#region Task execution code
		/// <summary>
		/// Reads all latest skills for the current task ID and adds them to the player skills list 
		/// maintained by the current MuSigma ranking system.
		/// </summary>
		private void ReadLatestSkills ()
		{
			// create the SQL transcript and execute the reader
			SqlDataReader aLatestSkillReader = ExecuteReader ("SELECT [tTmp].player_id, [tTmp].latest_rank_date, [dbo].[" + 
					m_aRankingParameters.RankingDataTableName + "].mu, [dbo].[" + 
					m_aRankingParameters.RankingDataTableName + "].sigma FROM (SELECT TOP 100 PERCENT player_id, MAX(rank_date) AS latest_rank_date FROM [dbo].[" + 
					m_aRankingParameters.RankingDataTableName + "] WHERE (task_id = " + 
					m_iTaskID.ToString () + ") GROUP BY player_id ORDER BY latest_rank_date) tTmp LEFT OUTER JOIN [dbo].[" + 
					m_aRankingParameters.RankingDataTableName +"] ON [dbo].[" + 
					m_aRankingParameters.RankingDataTableName + "].player_id = [tTmp].player_id AND [dbo].[" + 
					m_aRankingParameters.RankingDataTableName + "].rank_date = [tTmp].latest_rank_date WHERE (task_id = " + m_iTaskID.ToString () + ")");

			// while there is data, add it
			while (aLatestSkillReader.Read ())
			{
				long lPlayerID = aLatestSkillReader.GetInt64 (0);
				DateTime aRankDate = (DateTime) aLatestSkillReader.GetSqlDateTime (1);
				double dMu = aLatestSkillReader.GetDouble (2);
				double dSigma = aLatestSkillReader.GetDouble (3);

				int iPlayerID = m_aPlayerList.AddPlayer (lPlayerID.ToString ());
				PlayerSkills aPlayerSkills = new PlayerSkills (2);
				m_aMuSigmaRankingSystem.PlayerSkillsList.AddPlayerSkills (aPlayerSkills, iPlayerID);
				MuSigmaSkill aMuSigmaSkill = new MuSigmaSkill (dMu, dSigma);
				aPlayerSkills.AddSkill (aMuSigmaSkill, aRankDate);
			}
			aLatestSkillReader.Close ();

			// done!
			return;
		}

		/// <summary>
		/// Executes the ranking task. If a previous task was interrupted, the method continues this earlier task.
		/// </summary>
		public void Run ()
		{
			// open the two SQL connections necessary for the update
			OpenSQLConnection ();
			SqlConnection aNewSQLConnection = OpenNewSQLConnection ();

			////////////////////////////////////////////////////////////////
			// check if there already exists a previously stopped task and possibly overload
			////////////////////////////////////////////////////////////////
			string szTaskFile = m_aRankingParameters.GetHashCode ().ToString () + ".xml";
			bool bNewTask = true;
			try 
			{
				StreamReader aTaskFileReader = new StreamReader (szTaskFile);
				Console.Write ("A previous calculation has not yet finished. Continue (y/n)? ");
				if (Console.ReadLine ().ToUpper ().CompareTo ("Y") == 0) 
				{
					Read (aTaskFileReader);
					Console.WriteLine ("[Loading from " + szTaskFile + "]");
					bNewTask = false;
				}
				aTaskFileReader.Close ();
			}
			catch { }

			////////////////////////////////////////////////////////////////
			// create the result tables
			////////////////////////////////////////////////////////////////
			CreateResultTables ();

			////////////////////////////////////////////////////////////////
			// initialise the ranking system and player list (including skills)
			////////////////////////////////////////////////////////////////
			m_aMuSigmaRankingSystem = new MuSigmaRankingSystem (new PlayerSkillsList (),
				m_aRankingParameters.MuSigmaBeta, 
				m_aRankingParameters.MuSigmaEpsilon, 
				m_aRankingParameters.MuSigmaTau);
			m_aPlayerList = new PlayerList ();
			
			if (bNewTask) 
			{
				m_szLastUpdateGameTime = "undefined";
				m_iLastUpdateGameID = -1;
				Console.WriteLine ("[Starting a new task]");

				// add the task to the ranking task table and retrieve the new ID
				DateTime aCurrentTime = DateTime.Now;
				ExecuteSQLCommand ("INSERT INTO [dbo].[" + m_aRankingParameters.RankingTasksTableName + 
					"] ([task_startdate], [task_playlistid], [task_playlistname]) VALUES (" + 
					"'" + aCurrentTime.ToLongDateString () + " " + aCurrentTime.ToLongTimeString () + "', " + 
					m_aRankingParameters.RankedGameListID.ToString () + ", " + 
					"'" + m_aRankingParameters.RankedGameListName + "')");

				SqlDataReader aTaskIDReader = ExecuteReader ("SELECT MAX(task_id) FROM " + m_aRankingParameters.RankingTasksTableName);
				aTaskIDReader.Read ();
				m_iTaskID = aTaskIDReader.GetInt32 (0);
				aTaskIDReader.Close ();

				// add all the parameters used to the ranking parameters table
				ExecuteSQLCommand ("INSERT INTO [dbo].[" + m_aRankingParameters.RankingParametersTableName + 
					"] ([task_id], [parameter_name], [parameter_value]) VALUES (" + m_iTaskID.ToString () + ", " + 
					"'MuSigmaBeta', '" + m_aRankingParameters.MuSigmaBeta.ToString () + "')");
				ExecuteSQLCommand ("INSERT INTO [dbo].[" + m_aRankingParameters.RankingParametersTableName + 
					"] ([task_id], [parameter_name], [parameter_value]) VALUES (" + m_iTaskID.ToString () + ", " + 
					"'MuSigmaEpsilon', '" + m_aRankingParameters.MuSigmaEpsilon.ToString () + "')");
				ExecuteSQLCommand ("INSERT INTO [dbo].[" + m_aRankingParameters.RankingParametersTableName + 
					"] ([task_id], [parameter_name], [parameter_value]) VALUES (" + m_iTaskID.ToString () + ", " + 
					"'MuSigmaPriorMu', '" + m_aRankingParameters.MuSigmaPriorMu.ToString () + "')");
				ExecuteSQLCommand ("INSERT INTO [dbo].[" + m_aRankingParameters.RankingParametersTableName + 
					"] ([task_id], [parameter_name], [parameter_value]) VALUES (" + m_iTaskID.ToString () + ", " + 
					"'MuSigmaPriorSigma', '" + m_aRankingParameters.MuSigmaPriorSigma.ToString () + "')");
				ExecuteSQLCommand ("INSERT INTO [dbo].[" + m_aRankingParameters.RankingParametersTableName + 
					"] ([task_id], [parameter_name], [parameter_value]) VALUES (" + m_iTaskID.ToString () + ", " + 
					"'MuSigmaTau', '" + m_aRankingParameters.MuSigmaTau.ToString () + "')");
			}
			else 
				ReadLatestSkills ();

			////////////////////////////////////////////////////////////////
			// load all the games (on the server)
			////////////////////////////////////////////////////////////////
			string szGameTimeFilter;
			if (bNewTask)
				szGameTimeFilter = "";
			else
				szGameTimeFilter = " AND (" + m_aRankingParameters.ColumnNameGameTime + " >= '" + m_szLastUpdateGameTime + "')"; 

			SqlDataReader aGameReader = ExecuteReader ("SELECT " + m_aRankingParameters.ColumnNameGameID + ", " + 
					m_aRankingParameters.ColumnNameGameTime + " FROM " + m_aRankingParameters.GamesTableName + 
					" WHERE (" + m_aRankingParameters.ColumnNameGameList + " = " + m_aRankingParameters.RankedGameListID + ")" +
					szGameTimeFilter + 
					" ORDER BY " + m_aRankingParameters.ColumnNameGameTime + " ASC");

			////////////////////////////////////////////////////////////////
			// advance to exactly the game that we last updated (if necessary)
			////////////////////////////////////////////////////////////////
			if (!bNewTask) 
			{ 
				while (aGameReader.Read () && aGameReader.GetInt32 (0) != m_iLastUpdateGameID) 
					Console.WriteLine ("[Skipped game at " + aGameReader.GetDateTime (1).ToString () + "]");
			}
			
			////////////////////////////////////////////////////////////////
			// Main loop
			////////////////////////////////////////////////////////////////
			int iNumberOfGamesProcessed = 0;
			while (aGameReader.Read ())
			{
				// read the game relevant data
				DateTime aReadGameDate = (DateTime) aGameReader.GetSqlDateTime (1);
				string szReadGameDate = aReadGameDate.ToLongDateString () + " " + aReadGameDate.ToLongTimeString ();
				int iReadGameID = (int) aGameReader.GetSqlInt32 (0);

				// some output
				Console.WriteLine ("[Processing " + (++iNumberOfGamesProcessed) + "th game played at " + szReadGameDate + "]");

				// incorporate the current game
				DateTime aActualGameDate = UpdateGame (aNewSQLConnection, iReadGameID, aReadGameDate);
				if (aActualGameDate > aReadGameDate)
					Console.WriteLine ("   [Padded to " + aActualGameDate.ToLongDateString () + " " + aActualGameDate.ToLongTimeString () + "]");

				// increase the counter for the number of games processed and 
				// write the current progress to disc
				m_szLastUpdateGameTime = szReadGameDate;
				m_iLastUpdateGameID = iReadGameID;
				StreamWriter aTaskFileWriter = new StreamWriter (szTaskFile);
				Write (aTaskFileWriter);
				aTaskFileWriter.Close ();
			}

			////////////////////////////////////////////////////////////////
			// remove the XML ranking task file to indicate the the ranking has finsihed
			////////////////////////////////////////////////////////////////
			File.Delete (szTaskFile);

			// close the SQL connection
			CloseSQLConnection ();
			CloseSQLConnection (aNewSQLConnection);
		}
		#endregion

		#region Input and output code		
		/// <summary>
		/// Writes the ranking task information to an XML stream.
		/// </summary>
		/// <param name="aOutputStream">The output stream in XML format.</param>
		private void Write (TextWriter aOutputStream)
		{
			////////////////////////////////////////////////////////////
			// output progress specific information
			XmlTextWriter aTaskXMLWriter = new XmlTextWriter (aOutputStream);
			aTaskXMLWriter.Formatting= Formatting.Indented;

			// START OF THE XML FILE
			aTaskXMLWriter.WriteStartDocument ();
			aTaskXMLWriter.WriteComment ("This element contains all the information for the task. ");
			aTaskXMLWriter.WriteStartElement ("task");
			aTaskXMLWriter.WriteAttributeString ("version", "1.0");

			// INDENTIFICATION INFORMATION
			aTaskXMLWriter.WriteElementString  ("id", XmlConvert.ToString (m_iTaskID));

			// PROGRESS INFORMATION
			aTaskXMLWriter.WriteComment ("This element contains all the information for the task progress. ");
			aTaskXMLWriter.WriteStartElement ("progress");
			aTaskXMLWriter.WriteElementString  ("gametime", m_szLastUpdateGameTime);
			aTaskXMLWriter.WriteElementString  ("gameid", XmlConvert.ToString (m_iLastUpdateGameID));
			aTaskXMLWriter.WriteFullEndElement ();


			// RANKING PARAMETERS
			m_aRankingParameters.Write (aTaskXMLWriter);

			// END OF THE XML FILE
			aTaskXMLWriter.WriteFullEndElement ();

			// flush and close the XML stream
			aTaskXMLWriter.Flush ();
			aTaskXMLWriter.Close ();
		}

		/// <summary>
		/// Reads the ranking task information from an XML stream.
		/// </summary>
		/// <param name="aInputStream">The input stream in XML format.</param>
		private void Read (TextReader aInputStream)
		{
			////////////////////////////////////////////////////////////
			// output progress specific information
			XmlTextReader aTaskXMLReader = new XmlTextReader (aInputStream);

			////////////////////////////////////////////////////////////
			// look for the 'task' element
			while (aTaskXMLReader.Read () && (aTaskXMLReader.Name.CompareTo ("task") != 0));
			if (aTaskXMLReader.EOF)
				throw new Exception ("XML parameter file does not contain an 'task' element.");
			if (aTaskXMLReader.GetAttribute ("version").CompareTo ("1.0") != 0)
				throw new Exception ("Wrong version of the task information. Only version 1.0 is supported.");
			aTaskXMLReader.Read ();	

			// INDENTIFICATION INFORMATION
			m_iTaskID = XmlConvert.ToInt32 (aTaskXMLReader.ReadElementString  ("id"));

			// PROGRESS INFORMATION
			aTaskXMLReader.ReadStartElement ("progress");
			m_szLastUpdateGameTime = aTaskXMLReader.ReadElementString ("gametime");
			m_iLastUpdateGameID = XmlConvert.ToInt32 (aTaskXMLReader.ReadElementString ("gameid"));
			aTaskXMLReader.ReadEndElement ();

			// RANKING PARAMETERS
			m_aRankingParameters.Read (aTaskXMLReader);

			// END OF TOP LEVEL
			aTaskXMLReader.ReadEndElement ();

			////////////////////////////////////////////////////////////
			// close the XML reader
			aTaskXMLReader.Close ();
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MuSigma\Numerics\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("Numerics")]
[assembly: AssemblyDescription("A library of numerical Gaussian integral approximations.")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft Research Ltd.")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("2004 (c) Microsoft Research Ltd.")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.1.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MuSigma\Numerics\GaussianApproximations.cs ===
/////////////////////////////////////////////////////////////////////////////////////////////
// GaussianApproximations.cs			Static functions for Gaussian integrals
//
// 2004 written by Ralf Herbrich
// Microsoft Research Ltd.
/////////////////////////////////////////////////////////////////////////////////////////////

using System;
using System.IO;
using System.Diagnostics;
using LinearAlgebra;

namespace Numerics
{
	/// <summary>
	/// A static class that provides some functions for Gaussian integrals. In particular, this class provides
	/// correction functions for the mean and variance of the truncated Gaussian.
	/// </summary>
	public class GaussianApproximations
	{
		#region Erf functions
		/// <summary>
		/// Computes the complementary error function. This function is defined by 2/sqrt(pi) * integral from x to infinity of exp (-t^2) dt.
		/// </summary>
		/// <param name="x">The lower boundary of integration.</param>
		/// <returns>The complementary error function.</returns>
		/// <remarks>This method uses a Chebyshev series approximation which is exact in the whole range up to 1 * 10^{-7}.</remarks>
		public static double erfc (double x)
		{
			// check for boundary cases
			if (double.IsNegativeInfinity (x))
				return 2.0;
			if (double.IsPositiveInfinity (x))
				return 0.0;

			// ... otherwise do the hard work
			double z = Math.Abs (x);
			double t = 1.0 / (1.0 + 0.5 * z);
			double dResult = t * Math.Exp (-z*z 
				-1.26551223 + 
				t * (1.00002368 + 
				t * (0.37409196 + 
				t * (0.09678418 + 
				t * (-0.18628806 + 
				t * (0.27886807 + 
				t * (-1.13520398 +
				t * (1.48851587 + 
				t * (-0.82215223 + 
				t * 0.17087277)))))))));

			return (dResult = (x >= 0.0)? dResult: 2.0 - dResult);
		}

		/// <summary>
		/// Computes the inverse of the complementary error function. 
		/// </summary>
		/// <param name="y">The point of interest.</param>
		/// <returns>The inverse of the complementary error function.</returns>
		/// <remarks>This function uses a polynomial approximation together with one step of Halley's rational method.</remarks>
		public static double erfcinv (double y)
		{
			// check for boundary cases
			if (y < 0 || y > 2)
				throw new Exception ("Inverse complementary function not defined outside [0,2].");
			if (y == 0)
				return double.PositiveInfinity;
			if (y == 2)
				return double.NegativeInfinity;

			// stores the result
			double x = 0.0;

			// Rational approxiamtion for the central region
			if (y  >= 0.0485 && y <= 1.9515) 
			{
				double q = y - 1.0;
				double r = q * q;
				x = (((((0.01370600482778535*r - 0.3051415712357203)*r + 1.524304069216834)*r - 3.057303267970988)*r + 2.710410832036097)*r - 0.8862269264526915) * q /
					(((((-0.05319931523264068*r + 0.6311946752267222)*r - 2.432796560310728)*r + 4.175081992982483)*r - 3.320170388221430)*r + 1.0);
			}

			// Rational approximation for the lower region
			if (y < 0.0485)
			{
				double q = Math.Sqrt (-2.0 * Math.Log (y / 2.0));
				x = (((((0.005504751339936943*q + 0.2279687217114118)*q + 1.697592457770869)*q + 1.802933168781950)*q + -3.093354679843504)*q - 2.077595676404383) / 
					((((0.007784695709041462*q + 0.3224671290700398)*q + 2.445134137142996)*q + 3.754408661907416)*q + 1.0);
			}
			
			// Rational approximation for the upper region
			if (y > 1.9515) 
			{
				double q = Math.Sqrt (-2.0 * Math.Log (1 - y / 2.0));
				x = -(((((0.005504751339936943*q + 0.2279687217114118)*q + 1.697592457770869)*q + 1.802933168781950)*q + -3.093354679843504)*q - 2.077595676404383) / 
					 ((((0.007784695709041462*q + 0.3224671290700398)*q + 2.445134137142996)*q + 3.754408661907416)*q + 1.0);
			}

			// One iteration of Halley's rational method (third order) gives full machine precision.
			double u = (erfc (x) - y) / (-2.0 / Math.Sqrt (Math.PI) * Math.Exp (-x * x));
			x = x - u / (1.0 + x * u);

			// done!
			return x;
		}
		#endregion

		#region One dimensional Phi and N functions
		/// <summary>
		/// Computes the cummulative Gaussian distribution at a specified point of interest.
		/// </summary>
		/// <param name="t">The point of interest.</param>
		/// <returns>The cummulative Gaussian distribution at the point of interest.</returns>
		public static double Phi (double t)
		{
			const double dSqrt2 = 1.4142135623730951;

			return erfc (-t / dSqrt2) / 2.0;
		}

		/// <summary>
		/// Computes the inverse of the cummulative Gaussian distribution (qunatile function) at a specified point of interest.
		/// </summary>
		/// <param name="p">The cummulative probability or point of interest in [0,1].</param>
		/// <returns>The quantile at the specified point.</returns>
		public static double PhiInverse (double p)
		{
			const double dSqrt2 = 1.4142135623730951;

			return -dSqrt2 * erfcinv (2 * p);
		}

		/// <summary>
		/// Computes the normal density at a specified point of interest.
		/// </summary>
		/// <param name="t">The point of interest.</param>
		/// <returns>The normal density at the point of interest.</returns>
		public static double N (double t)
		{
			const double dSqrt2Pi = 2.5066282746310002;
			return 1 / dSqrt2Pi * Math.Exp (-t*t / 2);
		}
		#endregion

		#region One dimensional corrector functions of a truncated Gaussian
		/// <summary>
		/// Computes the additive correction of a single-sided truncated Gaussian with unit variance.
		/// </summary>
		/// <param name="t">The mean of the non-truncated Gaussian.</param>
		/// <param name="epsilon">The truncation point.</param>
		/// <returns>The additive correction.</returns>
		public static double v (double t, double epsilon)
		{
			double dNumerator = N (t - epsilon);
			double dDenominator = Phi (t - epsilon);
			if (dDenominator < Math.Sqrt (double.Epsilon))
				return -t + epsilon;
			else
				return dNumerator / dDenominator;
		}

		/// <summary>
		/// Computes the multiplicative correction of a single-sided truncated Gaussian with unit variance.
		/// </summary>
		/// <param name="t">The mean of the non-truncated Gaussian.</param>
		/// <param name="epsilon">The truncation point.</param>
		/// <returns>The multiplicative correction.</returns>
		public static double w (double t, double epsilon)
		{
			double dNumerator = (t - epsilon) * N (t - epsilon);
			double dDenominator = Phi (t - epsilon);
			if (dDenominator < Math.Sqrt (double.Epsilon))
				return (t < 0.0)?1.0:0.0;
			else
			{
				double aV0 = v (t, epsilon);
				return aV0 * aV0 + dNumerator / dDenominator;
			}
		}

		/// <summary>
		/// Computes the additive correction of a symmetrical double-sided truncated Gaussian with unit variance.
		/// </summary>
		/// <param name="t">The mean of the non-truncated Gaussian.</param>
		/// <param name="epsilon">The truncation point.</param>
		/// <returns>The additive correction.</returns>
		public static double v0 (double t, double epsilon)
		{
			double v = Math.Abs (t);
			double dNumerator = N (-epsilon - v) - N (epsilon - v);
			double dDenominator = Phi (epsilon - v) - Phi (-epsilon - v);
			if (dDenominator < Math.Sqrt (double.Epsilon))
				return (t < 0.0)?-t - epsilon:-t + epsilon;
			else		
				return (t < 0.0)?-dNumerator / dDenominator:dNumerator / dDenominator;
		}

		/// <summary>
		/// Computes the multiplicative correction of a symmetrical double-sided truncated Gaussian with unit variance.
		/// </summary>
		/// <param name="t">The mean of the non-truncated Gaussian.</param>
		/// <param name="epsilon">The truncation point.</param>
		/// <returns>The multiplicative correction.</returns>
		public static double w0 (double t, double epsilon)
		{
			double v = Math.Abs (t);
			double dNumerator = (epsilon - v) * N (epsilon - v) - (-epsilon - v) * N (-epsilon - v);
			double dDenominator = Phi (epsilon - v) - Phi (-epsilon - v);
			if (dDenominator < Math.Sqrt (double.Epsilon))
				return 1.0;
			else
			{
				double aV0 = v0 (v, epsilon);
				return aV0 * aV0 + dNumerator / dDenominator;
			}
		}

		/// <summary>
		/// Computes the additive correction of a general double-sided truncated Gaussian with unit variance.
		/// </summary>
		/// <param name="t">The mean of the non-truncated Gaussian.</param>
		/// <param name="l">The lower truncation point.</param>
		/// <param name="u">The upper truncation point.</param>
		/// <returns>The additive correction.</returns>
		/// <remarks>This routine has not been tested in all regimes of t for a given l and u. It will throw an exception
		/// if the computation is not numerically stable.</remarks>
		public static double v (double t, double l, double u)
		{
			double dNumerator = N (t - l) - N (t - u);
			double dDenominator = Phi (u - t) - Phi (l - t);
			if (dDenominator < Math.Sqrt (double.Epsilon))
				throw new ArithmeticException ("Unsafe computation of v");
			else
				return dNumerator / dDenominator;
		}

		/// <summary>
		/// Computes the multiplicative correction of a general double-sided truncated Gaussian with unit variance.
		/// </summary>
		/// <param name="t">The mean of the non-truncated Gaussian.</param>
		/// <param name="l">The lower truncation point.</param>
		/// <param name="u">The upper truncation point.</param>
		/// <returns>The multiplicative correction.</returns>
		/// <remarks>This routine has not been tested in all regimes of t for a given l and u. It will throw an exception
		/// if the computation is not numerically stable.</remarks>
		public static double w (double t, double l, double u)
		{
			double dNumerator = (u - t) * N (u - t) - (l - t) * N (l - t);
			double dDenominator = Phi (u - t) - Phi (l - t);
			if (dDenominator < Math.Sqrt (double.Epsilon))
				throw new ArithmeticException ("Unsafe computation of v");
			else
			{
				double aV0 = v (t, l, u);
				return aV0 * aV0 + dNumerator / dDenominator;
			}
		}
		#endregion

		#region Multi dimensional Phi and moment functions (using Genz algorithm)
		/// <summary>
		/// A structure holding moments of truncated multi-variate Gaussian. This structure is only used by
		/// <c>CalculateTGMoments</c>.
		/// </summary>
		public struct TGMoments
		{
			/// <summary>
			/// Normalisation constant of the truncated Gaussian.
			/// </summary>
			public double M0;
			/// <summary>
			/// Vector of first moments.
			/// </summary>
			public Matrix M1;
			/// <summary>
			/// Square matrix of second moments.
			/// </summary>
			public Matrix M2;
		}	

		/// <summary>
		/// Computes a Niederreither series of coefficients.
		/// </summary>
		/// <param name="iNumberOfDimensions">Number of dimensions.</param>
		/// <returns>A Niederreiter series with as many elements as dimensions.</returns>
		private static double [] ComputeNiederreiterSeries (int iNumberOfDimensions)
		{
			double [] dNiederreiter = new double [iNumberOfDimensions];
			for (int i = 0; i < iNumberOfDimensions; i++)
				dNiederreiter [i] = Math.Pow (2.0, (double) (i + 1) / (double) (iNumberOfDimensions + 1));
			return dNiederreiter;
		}

		/// <summary>
		/// Computes the transformed integrand of a multi-variate Gaussian.
		/// </summary>
		/// <param name="mu">Mean of the Gaussian.</param>
		/// <param name="C">Cholesky factor of the covariance of the Gaussian.</param>
		/// <param name="a">Lower integration boundary.</param>
		/// <param name="b">Upper integration boundary.</param>
		/// <param name="dSample">The uniform random sample.</param>
		/// <param name="tmp">A temporary matrix of the size of <c>M1</c>.</param>
		/// <param name="M0">The volume sample (zeroth moment).</param>
		/// <param name="M1">The mean sample (first moment).</param>
		/// <param name="M2">The second moment sample.</param>
		/// <remarks>This function is implemented to minimise the number of allocations of memory and may thus be hard to 
		/// read.</remarks>
		private static void TransformSample (Matrix mu, Matrix C, Matrix a, Matrix b, double [] dSample, ref Matrix tmp, ref double M0, ref Matrix M1, ref Matrix M2)
		{
			// re-adjusts the lower and upper integration limits of the Gaussian
			int iNumberOfDimensions = a.NoRows;
			
			// initialise the lower and upper integration limits of the uniform
			double dLowerLimit = Phi ((a [0] - mu [0]) / C [0, 0]);
			double dUpperLimit = Phi ((b [0] - mu [0]) / C [0, 0]);
			M0 = dUpperLimit - dLowerLimit;

			// loop over all dimensions and compute the volume at y
			for (int i = 1; i < iNumberOfDimensions; i++) 
			{
				M1 [i - 1] = PhiInverse (dLowerLimit + dSample [i - 1] * (dUpperLimit - dLowerLimit));
				double dTmp = 0.0;
				for (int j = 0; j < i; j++) 
					dTmp += C [i, j] * M1 [j];
				dLowerLimit = Phi (((a [i] - mu [i]) - dTmp) / C [i, i]);
				dUpperLimit = Phi (((b [i] - mu [i]) - dTmp) / C [i, i]);
				M0 *= dUpperLimit - dLowerLimit;
			}
			M1 [iNumberOfDimensions - 1] = PhiInverse (dLowerLimit + dSample [iNumberOfDimensions - 1] * (dUpperLimit - dLowerLimit));
			
			// compute the moments at the random sample
			for (int i = 0; i < C.NoRows; i++) 
			{
				tmp [i] = 0.0;
				for (int j = 0; j <= i; j++)
					tmp [i] += C [i, j] * M1 [j];
				tmp [i] += mu [i];
			}
			for (int i = 0; i < M1.NoRows; i++) 
				M1 [i] = M0 * tmp [i];
			for (int i = 0; i < M2.NoRows; i++) 
				for (int j = 0; j< M2.NoRows; j++) 
					M2 [i, j] = M0 * tmp [i] * tmp [j];
		}

		/// <summary>
		/// Computes a multivariate partial Gaussian integral.
		/// </summary>
		/// <param name="mu">Mean of the Gaussian distribution.</param>
		/// <param name="Sigma">Covariance of the Gaussian distribution.</param>
		/// <param name="a">Lower integration limits.</param>
		/// <param name="b">Upper integration limits.</param>
		/// <param name="iMaxNumberOfPoints">Number of quasi-random points.</param>
		/// <returns>The normalisation constant, mean and second moment matrix of a multivariate Gaussian density between <c>a</c> and <b>b</b>.</returns>
		/// <remarks>This function implements a variant of the algorithm as described in <i>A. Genz. Numerical Computation of Multivariate 
		/// Normal Probabilities.</i> 1992 using a quais-random lattice generator based on Niederreiter point sets. However, for one-dimensional
		/// integrals of a certain sort if resorts to use the fast <c>v</c>, <c>w</c>, <c>v0</c> and <c>w0</c> function.</remarks>
		public static TGMoments CalculateTGMoments (Matrix mu, Matrix Sigma, Matrix a, Matrix b, int iMaxNumberOfPoints)
		{
			/////////////////////////////////////////////////////////////////////////
			// Parameter checks
			/////////////////////////////////////////////////////////////////////////
			if (!mu.IsVector || !a.IsVector || !b.IsVector)
				throw new Exception ("mu, a and b must be vectors.");
			if (Sigma.NoColumns != Sigma.NoRows)
				throw new Exception ("Sigma must be a square matrix.");
			if (mu.NoRows != Sigma.NoRows || a.NoRows != Sigma.NoRows || b.NoRows != Sigma.NoRows)
				throw new Exception ("Number of dimensions of a, b, mu and Sigma do not match.");
			if (mu.NoRows > 20)
				throw new Exception ("This method may not work for more than 20 dimensions.");

			// introduce a shorthand for the number of dimensions
			int iNumberOfDimensions = mu.NoRows;

			/////////////////////////////////////////////////////////////////////////
			// allocate the return variable and initialise the squared purely random samples 
			/////////////////////////////////////////////////////////////////////////
			TGMoments aResult;
			aResult.M0 = 0.0;
			aResult.M1 = new Matrix (iNumberOfDimensions, 1);
			aResult.M2 = new Matrix (iNumberOfDimensions, iNumberOfDimensions);

			/////////////////////////////////////////////////////////////////////////
			// check if the quick function can be applied.
			/////////////////////////////////////////////////////////////////////////
			if (mu.NoElements == 1) 
			{
				if (b [0] == double.PositiveInfinity) 
				{
					double dSigma = Math.Sqrt (Sigma [0, 0]);
					aResult.M0 = Phi ((mu [0] - a [0]) / dSigma);
					aResult.M1 = mu [0] + dSigma * v (mu [0] / dSigma, a [0] / dSigma);
					aResult.M2 = dSigma * dSigma * (1 - w (mu [0] / dSigma, a [0] / dSigma)) + aResult.M1 * aResult.M1;
					return aResult;
				}
				if (a [0] == -b [0])
				{
					double dSigma = Math.Sqrt (Sigma [0, 0]);
					aResult.M0 = Phi ((b [0] - mu [0]) / dSigma) - Phi ((a [0] - mu [0]) / dSigma);
					aResult.M1 = mu [0] + dSigma * v0 (mu [0] / dSigma, b [0] / dSigma);
					aResult.M2 = dSigma * dSigma * (1 - w0 (mu [0] / dSigma, b [0] / dSigma)) + aResult.M1 * aResult.M1;
					return aResult;
				}
			}

			// TODO: This code could also do a resorting of the indicies based on the integration limits. 
			// This may speed up the code by orders of magnitudes (according to Genz, 1992).

			////////////////////////////////////////////////////////////
			// Compute the lower triangular Cholesky decomposition and
			// intialise the quasi-random deviates and
			// precompute the Niederreiter point series
			/////////////////////////////////////////////////////////////
			Matrix C = Sigma.Cholesky ();
			double [] dQuasiRandom = new double [iNumberOfDimensions];
			double [] dNiederreiter = ComputeNiederreiterSeries (iNumberOfDimensions);

			double QuasiM0 = 0.0;
			Matrix QuasiM1 = new Matrix (iNumberOfDimensions, 1);
			Matrix QuasiM2 = new Matrix (iNumberOfDimensions, iNumberOfDimensions);
			Matrix Tmp = new Matrix (iNumberOfDimensions, 1);

			///////////////////////////////////////
			// Loop over the number of quasi-random points
			///////////////////////////////////////
			for (int iNumberOfPoints = 0; iNumberOfPoints < iMaxNumberOfPoints; iNumberOfPoints++) 
			{
				// compute a new quasi-random sample and update the a quasi moments
				for (int i = 0; i < iNumberOfDimensions; i++) 
				{
					double t = (double) (iNumberOfPoints + 1) * dNiederreiter [i]; 
					dQuasiRandom [i] = Math.Abs (2.0 * (t - Math.Floor (t)) - 1.0);
				}

				TransformSample (mu, C, a, b, dQuasiRandom, ref Tmp, ref QuasiM0, ref QuasiM1, ref QuasiM2);
				aResult.M0 += (QuasiM0 - aResult.M0) / (double) (2 * iNumberOfPoints + 1);
				QuasiM1.Substract (aResult.M1);
				QuasiM1.Divide ((double) (2 * iNumberOfPoints + 1));
				aResult.M1.Add (QuasiM1);
				QuasiM2.Substract (aResult.M2);
				QuasiM2.Divide ((double) (2 * iNumberOfPoints + 1));
				aResult.M2.Add (QuasiM2);

				// compute a new quasi-random sample and update the average quasi moments (mirrored)
				for (int i = 0; i < iNumberOfDimensions; i++) 
					dQuasiRandom [i] = 1.0 - dQuasiRandom [i];

				TransformSample (mu, C, a, b, dQuasiRandom, ref Tmp, ref QuasiM0, ref QuasiM1, ref QuasiM2);
				aResult.M0 = aResult.M0 + (QuasiM0 - aResult.M0) / (double) (2 * iNumberOfPoints + 1);
				QuasiM1.Substract (aResult.M1);
				QuasiM1.Divide ((double) (2 * (iNumberOfPoints + 1)));
				aResult.M1.Add (QuasiM1);
				QuasiM2.Substract (aResult.M2);
				QuasiM2.Divide ((double) (2 * (iNumberOfPoints + 1)));
				aResult.M2.Add (QuasiM2);
			}

			////////////////////////////////////////////////
			// renormalise the moments
			////////////////////////////////////////////////
			aResult.M1.Divide (aResult.M0);
			aResult.M2.Divide (aResult.M0);
			if (aResult.M1.IsNaN () || aResult.M2.IsNaN () ||
				aResult.M1.IsInfinity () || aResult.M2.IsInfinity ())
				throw new ArithmeticException ("Normalisation constant is too small");

			// return the result
			return aResult;
		}
		
		/// <summary>
		/// Computes a multivariate partial Gaussian integral.
		/// </summary>
		/// <param name="mu">Mean of the Gaussian distribution.</param>
		/// <param name="Sigma">Covariance of the Gaussian distribution.</param>
		/// <param name="a">Lower integration limits.</param>
		/// <param name="b">Upper integration limits.</param>
		/// <param name="iMaxNumberOfPoints">Number of quasi-random points.</param>
		/// <returns>The integal of the multivariate Gaussian density between <c>a</c> and <b>b</b>.</returns>
		/// <remarks>This function implements a variant of the algorithm as described in <i>A. Genz. Numerical Computation of 
		/// Multivariate Normal Probabilities.</i> 1992. However, fast functions based on <c>erfc</c> are used for one-dimensional
		/// integrals.</remarks>
		public static double Phi (Matrix mu, Matrix Sigma, Matrix a, Matrix b, int iMaxNumberOfPoints)
		{
			return CalculateTGMoments (mu, Sigma, a, b, iMaxNumberOfPoints).M0;
		}
		#endregion

		#region Multi dimensional Phi and parameter functions (using Gaussian EP)
		/// <summary>
		/// A structure holding the parameters of truncated multi-variate Gaussian approximation. This structure is only used by
		/// <c>CalculateTGAParameters</c>. 
		/// </summary>
		/// <remarks>Note that the parameters of a truncated Gaussian approximation are closely related to the moments of a truncated Gaussian. 
		/// In particular, we have that TGParameters.Z \approx TGMoments.M0, TGParameters.mu \approx TGMoments.M1 and 
		/// TGParameters.Sigma \approx TGMoments.M2 - TGMoments.M1 * TGMoments.M1.Transpose ().</remarks>
		public struct TGAParameters
		{
			/// <summary>
			/// Approximative normalisation constant of the truncated Gaussian.
			/// </summary>
			public double Z;
			/// <summary>
			/// Mean vector of the Gaussian approximation.
			/// </summary>
			public Matrix mu;
			/// <summary>
			/// Covariance matrix of the Gaussian approximation.
			/// </summary>
			public Matrix Sigma;
		}	

		/// <summary>
		/// Computes the parameter of the best Gaussian approximation of a multivariate truncated Gaussian.
		/// </summary>
		/// <param name="mu">Mean of the Gaussian distribution.</param>
		/// <param name="Sigma">Covariance of the Gaussian distribution.</param>
		/// <param name="l">Lower integration limits.</param>
		/// <param name="u">Upper integration limits.</param>
		/// <param name="iNumberOfIterations">Number of iterations over the list of integration limits. Usually, a value of 5 - 10 will work fine.</param>
		/// <returns>The normalisation constant, mean and covariance matrix of the best Gaussian approxiamtion to the truncated multivariate Gaussian density 
		/// between <c>l</c> and <b>u</b>.</returns>
		/// <remarks>This function implements the EP algorithm og Thomas P. Minka described in <i>T. P. Minka. A family of algorithms for approximate Bayesian 
		/// inference.</i> PhD thesis. MIT. 2001. Note that in the case of scalars, the number of iterations is automatically reduced to 1.</remarks>
		public static TGAParameters CalculateTGAParameters (Matrix mu, Matrix Sigma, Matrix l, Matrix u, int iNumberOfIterations)
		{
			/////////////////////////////////////////////////////////////////////////
			// Parameter checks
			/////////////////////////////////////////////////////////////////////////
			if (!mu.IsVector || !l.IsVector || !u.IsVector)
				throw new Exception ("mu, l and u must be vectors.");
			if (Sigma.NoColumns != Sigma.NoRows)
				throw new Exception ("Sigma must be a square matrix.");
			if (mu.NoRows != Sigma.NoRows || l.NoRows != Sigma.NoRows || u.NoRows != Sigma.NoRows)
				throw new Exception ("Number of dimensions of l, u, mu and Sigma do not match.");
			if (iNumberOfIterations < 1)
				throw new Exception ("Number of iterations must be at least 1.");

			// introduce a shorthand for the number of dimensions
			int iNumberOfDimensions = mu.NoRows;

			/////////////////////////////////////////////////////////////////////////
			// allocate the return variable and initialise the squared purely random samples 
			/////////////////////////////////////////////////////////////////////////
			TGAParameters aResult;
			aResult.mu = new Matrix (mu);
			aResult.Sigma = new Matrix (Sigma);

			/////////////////////////////////////////////////////////////////////////
			// check if the quick function can be applied.
			/////////////////////////////////////////////////////////////////////////
			if (mu.NoElements == 1) 
			{
				double dSigma = Math.Sqrt (Sigma [0, 0]);
				if (u [0] == double.PositiveInfinity) 
				{
					aResult.Z = Phi ((mu [0] - l [0]) / dSigma);
					aResult.mu = mu [0] + dSigma * v (mu [0] / dSigma, l [0] / dSigma);
					aResult.Sigma = Sigma [0, 0] * (1 - w (mu [0] / dSigma, l [0] / dSigma));
					return aResult;
				}
				if (l [0] == -u [0])
				{
					aResult.Z = Phi ((u [0] - mu [0]) / dSigma) - Phi ((l [0] - mu [0]) / dSigma);
					aResult.mu = mu [0] + dSigma * v0 (mu [0] / dSigma, u [0] / dSigma);
					aResult.Sigma = Sigma [0, 0] * (1 - w0 (mu [0] / dSigma, u [0] / dSigma));
					return aResult;
				}

				// general case
				aResult.Z = Phi ((u [0] - mu [0]) / dSigma) - Phi ((l [0] - mu [0]) / dSigma);
				aResult.mu = mu [0] + dSigma * v (mu [0] / dSigma, l [0] / dSigma, u [0] / dSigma);
				aResult.Sigma = Sigma [0, 0] * (1 - w (mu [0] / dSigma, l [0] / dSigma, u [0] / dSigma));
				return aResult;
			}

			////////////////////////////////////////////////////////////
			// Initialise
			/////////////////////////////////////////////////////////////
			double [] dSiteMu = new double [iNumberOfDimensions];
			double [] dSitePrecision = new double [iNumberOfDimensions];
			double [] dSiteScaling = new double [iNumberOfDimensions];
			Matrix t = new Matrix (iNumberOfDimensions, 1);
			Matrix T = new Matrix (iNumberOfDimensions, iNumberOfDimensions);
 
			////////////////////////////////////////////////////////////
			// Main loop
			/////////////////////////////////////////////////////////////			
			for (int iIterations = 0; iIterations < iNumberOfIterations; iIterations++) 
				for (int iDimension = 0; iDimension < iNumberOfDimensions; iDimension++) 
				{
					// Pre-computations
					for (int i = 0; i < iNumberOfDimensions; i++)
						t [i] = aResult.Sigma [i, iDimension];
					for (int i = 0; i < iNumberOfDimensions; i++)
						for (int j = 0; j < iNumberOfDimensions; j++)
							T [i, j] = t [i] * t [j];
					double dD = dSitePrecision [iDimension] * aResult.Sigma [iDimension, iDimension];
					double dE = 1.0 - dD;
					double dPhi = aResult.mu [iDimension] + dD * (aResult.mu [iDimension] - dSiteMu [iDimension]) / dE;
					double dPsi = aResult.Sigma [iDimension, iDimension] / dE;
					double dSqrtPsi = Math.Sqrt (dPsi);
					double dAlpha = 0.0, dBeta = 0.0;

					if (u [iDimension] == double.PositiveInfinity) 
					{
						dAlpha = v (dPhi / dSqrtPsi, l [iDimension] / dSqrtPsi) / dSqrtPsi;
						dBeta = w (dPhi / dSqrtPsi, l [iDimension] / dSqrtPsi) / dPsi;
					} 
					else if (l [iDimension] == -u [iDimension])
					{
						dAlpha = v0 (dPhi / dSqrtPsi, u [iDimension] / dSqrtPsi) / dSqrtPsi;
						dBeta = w0 (dPhi / dSqrtPsi, u [iDimension] / dSqrtPsi) / dPsi;
					} 
					else 
					{
						dAlpha = v (dPhi / dSqrtPsi, l [iDimension] / dSqrtPsi, u [iDimension] / dSqrtPsi) / dSqrtPsi;
						dBeta = w (dPhi / dSqrtPsi, l [iDimension] / dSqrtPsi, u [iDimension] / dSqrtPsi) / dPsi;
					}

					// ADF update
					t.Mulitply ((dSitePrecision [iDimension] * (aResult.mu [iDimension] - dSiteMu [iDimension]) + dAlpha)/ dE);
					T.Mulitply ((dSitePrecision [iDimension] * dE - dBeta) / (dE * dE));
					aResult.mu.Add (t);
					aResult.Sigma.Add (T);

					// Factor update
					dSitePrecision [iDimension] = 1.0 / (1.0 / dBeta - dPsi);
					dSiteMu [iDimension] = dAlpha / dBeta + dPhi;
					dSiteScaling [iDimension] = (Phi ((u [iDimension] - dPhi) / dSqrtPsi) - Phi ((l [iDimension] - dPhi) / dSqrtPsi)) * 
						Math.Exp (dAlpha * dAlpha / (2.0 * dBeta)) / Math.Sqrt (1.0 - dPsi * dBeta);
				}

			// Compute the final normalisation constant
			Matrix SigmaInverse = Sigma.Inverse ();
			Matrix NewSigmaInverse = aResult.Sigma.Inverse ();
			double dB = (double) (mu.Transpose () * SigmaInverse * mu - aResult.mu.Transpose () * NewSigmaInverse * aResult.mu);
			double dS = 1.0;
			for (int i = 0; i < iNumberOfDimensions; i++) 
			{
				dB += dSitePrecision [i] * dSiteMu [i] * dSiteMu [i];
				dS *= dSiteScaling [i];
			}
			aResult.Z = dS * Math.Sqrt (aResult.Sigma.Determinant () / Sigma.Determinant ()) * Math.Exp (-1.0 / 2.0 * dB);

			// return the result
			return aResult;
		}

		/// <summary>
		/// Approximates a multivariate partial Gaussian integral.
		/// </summary>
		/// <param name="mu">Mean of the Gaussian distribution.</param>
		/// <param name="Sigma">Covariance of the Gaussian distribution.</param>
		/// <param name="l">Lower integration limits.</param>
		/// <param name="u">Upper integration limits.</param>
		/// <param name="iNumberOfIterations">Number of iterations over the list of integration limits. Usually, a value of 5 - 10 will work fine.</param>
		/// <returns>The integal of the multivariate Gaussian density between <c>l</c> and <b>u</b>.</returns>
		/// <remarks>This function implements the EP algorithm og Thomas P. Minka described in <i>T. P. Minka. A family of algorithms for approximate Bayesian 
		/// inference.</i> PhD thesis. MIT. 2001. Note that in the case of scalars, the number of iterations is automatically reduced to 1.</remarks>
		public static double PhiEP (Matrix mu, Matrix Sigma, Matrix l, Matrix u, int iNumberOfIterations)
		{
			return CalculateTGAParameters (mu, Sigma, l, u, iNumberOfIterations).Z;
		}
		#endregion

		#region Test code
		/// <summary>
		/// Tests the N function implementation. 
		/// </summary>
		/// <remark>The following lines should appear on the console
		///	<code>
		///	
		///		N (-infinity) = 0
		///		N (-0.5) = 0.3520653267643
		///		N (0) = 0.398942280401433
		///		N (+0.5) = 0.3520653267643
		///		N (+infinity) = 0
		///			
		///	</code>
		///	</remark>
		public static void TestN()
		{
			// check that the boundary cases work for N
			Console.WriteLine ("N (-infinity) = " + N (double.NegativeInfinity).ToString ());
			Console.WriteLine ("N (-0.5) = " + N (-0.5).ToString ());
			Console.WriteLine ("N (0) = " + N (0.0).ToString ());
			Console.WriteLine ("N (+0.5) = " + N (+0.5).ToString ());
			Console.WriteLine ("N (+infinity) = " + N (double.PositiveInfinity).ToString ());
		}

		/// <summary>
		/// Tests the Phi function implementation. 
		/// </summary>
		/// <remark>The following lines should appear on the console
		///	<code>
		///	
		///			Phi (-infinity) = 0
		///			Phi (0) = 0.500000015
		///			Phi (+infinity) = 1
		///			PhiInverse (0) = -Infinity
		///			PhiInverse (0.5) = -3.75994247258305E-08
		///			PhiInverse (1.0) = Infinity
		///			Phi([0,0]; [0, 0], [[1 1/2];[1/2 1]]) = 0.333285860675662
		///			PhiEP([0,0]; [0, 0], [[1 1/2];[1/2 1]]) = 0.332728571526972
		///			Phi([-1,2]; [0, 0], [[1 1/2];[1/2 1]]) = 0.158508382726622
		///			PhiEP([-1,2]; [0, 0], [[1 1/2];[1/2 1]]) = 0.158495948730996
		///			Phi('8 dimensions') = 0.0605339437759201
		///			Phi('16 dimensions') = 0.037377307074928
		///			
		///	</code>
		///	Note that all lines should be exactly the same since the numerical integration uses quasi-random samples. 
		///	</remark>
		public static void TestPhi()
		{
			// check that the boundary cases work for Phi and PhiInverse
			Console.WriteLine ("Phi (-infinity) = " + Phi (double.NegativeInfinity).ToString ());
			Console.WriteLine ("Phi (0) = " + Phi (0).ToString ());
			Console.WriteLine ("Phi (+infinity) = " + Phi (double.PositiveInfinity).ToString ());
			Console.WriteLine ("PhiInverse (0) = " + PhiInverse (0.0).ToString ());
			Console.WriteLine ("PhiInverse (0.5) = " + PhiInverse (0.5).ToString ());
			Console.WriteLine ("PhiInverse (1.0) = " + PhiInverse (1.0).ToString ());

			/////////////////////////////////////////////////////////
			// check the numerical integration code
			Matrix mu, Sigma, a, b;

			// 2 dimensions
			mu = new Matrix (2, 1);
			a = new Matrix (2, 1);
			b = new Matrix (2, 1);
			Sigma = new Matrix (2, 2);

			Sigma [0, 0] = Sigma [1, 1] = 1.0;
			Sigma [0, 1] = Sigma [1, 0] = 1.0 / 2.0;
			// HACK: The following line should be this "a [0] = a [1] = double.NegativeInfinity;"
			// This can only be done once the three parameter version of v and w function can handle any input!
			a [0] = a [1] = -1000.0;
			b [0] = b [1] = 0.0;
			Console.WriteLine ("Phi([0,0]; [0, 0], [[1 1/2];[1/2 1]]) = " + Phi (mu, Sigma, a, b, 1000));
			Console.WriteLine ("PhiEP([0,0]; [0, 0], [[1 1/2];[1/2 1]]) = " + PhiEP (mu, Sigma, a, b, 10));
			b [0] = -1.0;
			b [1] = 2.0;
			Console.WriteLine ("Phi([-1,2]; [0, 0], [[1 1/2];[1/2 1]]) = " + Phi (mu, Sigma, a, b, 1000));
			Console.WriteLine ("PhiEP([-1,2]; [0, 0], [[1 1/2];[1/2 1]]) = " + PhiEP (mu, Sigma, a, b, 10));

			// 8 dimensions
			mu = new Matrix (8, 1);
			a = new Matrix (8, 1);
			Sigma = new Matrix (8, 8);

			for (int i = 0; i < Sigma.NoRows; i++) 
			{
				for (int j = 0; j < Sigma.NoColumns; j++)
					Sigma [i, j] = (i == j)?1.0:1.0/2.0;
				a [i] = double.NegativeInfinity;
			}
			b = new Matrix (new double [8, 1] {{-1.0}, {+1.0/2.0}, {-1.0/3.0}, {+1.0/4.0}, {-1.0/5.0}, {+1.0/6.0}, {-1.0/7.0}, {+1.0/8.0}});
			Console.WriteLine ("Phi('8 dimensions') = " + Phi (mu, Sigma, a, b, 1000));

			// 16 dimensions
			mu = new Matrix (16, 1);
			a = new Matrix (16, 1);
			Sigma = new Matrix (16, 16);

			for (int i = 0; i < Sigma.NoRows; i++) 
			{
				for (int j = 0; j < Sigma.NoColumns; j++)
					Sigma [i, j] = (i == j)?1.0:1.0/2.0;
				a [i] = double.NegativeInfinity;
			}
			b = new Matrix (new double [16, 1] {{-1.0/1.0}, {+1.0/2.0}, {-1.0/3.0}, {+1.0/4.0}, {-1.0/5.0}, {+1.0/6.0}, {-1.0/7.0}, {+1.0/8.0},
												{-1.0/9.0}, {+1.0/10.0}, {-1.0/11.0}, {+1.0/12.0}, {-1.0/13.0}, {+1.0/14.0}, {-1.0/15.0}, {+1.0/16.0}});
			Console.WriteLine ("Phi('16 dimensions') = " + Phi (mu, Sigma, a, b, 1000));
		}

		/// <summary>
		/// Generates example files which can be check with MATLAB.
		/// </summary>
		/// <example>In order to test this code, run the following lines in MATLAB after this function has produced 
		/// its output in the several files:
		/// <code>
		/// 
		///			load -ascii erfc.txt; clf; plot (erfc(:,1),erfc(:,2), 'b-');
		///			load -ascii erfcinv.txt; clf; plot (erfcinv(:,1),erfcinv(:,2), 'b-');
		///			load -ascii Phi.txt; clf; plot (Phi(:,1),Phi(:,2), 'b-');
		///			load -ascii PhiInv.txt; clf; plot (PhiInv(:,1),PhiInv(:,2), 'b-');
		///			load -ascii v.txt; clf; plot (v(:,1),v(:,2), 'b-');
		///			load -ascii w.txt; clf; plot (w(:,1),w(:,2), 'b-');
		///			load -ascii v0.txt; clf; plot (v0(:,1),v0(:,2), 'b-');
		///			load -ascii w0.txt; clf; plot (w0(:,1),w0(:,2), 'b-');
		///			load -ascii vApprox.txt; clf; plot (vApprox(:,1),vApprox(:,2), 'b-');
		///			
		///	</code>	
		///	</example>	
		public static void TestWithMatlab ()
		{
			StreamWriter aWriter;
			const double dRange = 20.0;
			// dumps the a function to disk
			aWriter = new StreamWriter("erfc.txt", false);
			for (double x = -dRange; x <= dRange; x += 0.001)
				aWriter.WriteLine (x.ToString () + ", " + erfc (x).ToString ());
			aWriter.Close ();

			// dumps the a function to disk
			aWriter = new StreamWriter("erfcinv.txt", false);
			for (double x = 0.001; x < 2.0; x += 0.001)
				aWriter.WriteLine (x.ToString () + ", " + erfcinv (x).ToString ());
			aWriter.Close ();

			// dumps the a function to disk
			aWriter = new StreamWriter("Phi.txt", false);
			for (double x = -dRange; x <= dRange; x += 0.001)
				aWriter.WriteLine (x.ToString () + ", " + Phi (x).ToString ());
			aWriter.Close ();

			// dumps the a function to disk
			aWriter = new StreamWriter("PhiInv.txt", false);
			for (double x = 0.001; x < 1.0; x += 0.001)
				aWriter.WriteLine (x.ToString () + ", " + PhiInverse (x).ToString ());
			aWriter.Close ();

			// dumps the a function to disk
			aWriter = new StreamWriter("v.txt", false);
			for (double x = -dRange; x <= dRange; x += 0.001)
				aWriter.WriteLine (x.ToString () + ", " + v (x, 4.0).ToString ());
			aWriter.Close ();

			// dumps the a function to disk
			aWriter = new StreamWriter("w.txt", false);
			for (double x = -dRange; x <= dRange; x += 0.001)
				aWriter.WriteLine (x.ToString () + ", " + w (x, 4.0).ToString ());
			aWriter.Close ();

			// dumps the a function to disk
			aWriter = new StreamWriter("v0.txt", false);
			for (double x = -dRange; x <= dRange; x += 0.001)
				aWriter.WriteLine (x.ToString () + ", " + v0 (x, 4.0).ToString ());
			aWriter.Close ();

			// dumps the a function to disk
			aWriter = new StreamWriter("w0.txt", false);
			for (double x = -dRange; x <= dRange; x += 0.001)
				aWriter.WriteLine (x.ToString () + ", " + w0 (x, 4.0).ToString ());
			aWriter.Close ();

			// dumps the a function to disk
			aWriter = new StreamWriter("vApprox.txt", false);
			for (double x = -10.0; x <= 10.0; x += 0.01) 
			{
				try 
				{
					TGMoments dResult = CalculateTGMoments (x, 1.0, 4.0, double.PositiveInfinity, 100);
					double vA = ((double) dResult.M1) - x;
					double wA = 1.0 - ((double) dResult.M2 - (double) dResult.M1 * (double) dResult.M1);
					aWriter.WriteLine (x.ToString () + ", " + vA.ToString () + ", " + wA.ToString () + ", " + v (x, 4.0) + ", " + w (x, 4.0));
				}
				catch (ArithmeticException)
				{
				}
			}
			aWriter.Close ();
		}

		/// <summary>
		/// Tests the Gaussian approximations.
		/// </summary>
		/// <remarks>In order to see the screen output, look at <c>TestN</c>, <c>TestPhi</c> and <c>TestWithMatlab</c>.</remarks>
		public static void TestGaussianApproximations ()
		{
			// check the N function
			TestN ();

			// check the Phi 
			TestPhi ();

			// check with MATLAB code
			TestWithMatlab ();
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MuSigma\RankCalculator\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("RankCalculator")]
[assembly: AssemblyDescription("Table Calculator for Ranking Systems")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft Reseatch Ltd.")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("2005 (c) Microsoft Research Ltd.")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MuSigma\RankCalculator\RankCalculator.cs ===
/////////////////////////////////////////////////////////////////////////////////////////////
// RankCalculator.cs	A table calculator for ranking games.
//
// 2005 written by Ralf Herbrich
// Microsoft Research Ltd.
/////////////////////////////////////////////////////////////////////////////////////////////

using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Data;
using MSRanking;
using MSRanking.RankingSystems;
using MSRanking.Skills;
using System.Diagnostics;

namespace RankCalculator
{
	/// <summary>
	/// The RankCalculator allows to interactively perform rank calculations for 
	/// single games. 
	/// </summary>
	public class frmRankCalculator : System.Windows.Forms.Form
	{
		#region Application variable declarations
		/// <summary>
		/// The game that is considered.
		/// </summary>
		Game m_aGame;
		/// <summary>
		/// The list of players.
		/// </summary>
		PlayerList m_aPlayerList;
		/// <summary>
		/// The ranking system.
		/// </summary>
		MuSigmaRankingSystem m_aMuSigmaRankingSystem;
		/// <summary>
		/// The labels for each player in the input panel.
		/// </summary>
		Label [] m_lblPlayerNameInput;
		/// <summary>
		/// The labels for the plus/minus sign for each player in the input panel.
		/// </summary>
		Label [] m_lblPlusMinusInput;
		/// <summary>
		/// The numerical input fields for \mu for each player.
		/// </summary>
		NumericUpDown [] m_numMuInput;
		/// <summary>
		/// The numerical input fields for \sigma for each player.
		/// </summary>
		NumericUpDown [] m_numSigmaInput;
		/// <summary>
		/// The labels for each player in the output panel.
		/// </summary>
		Label [] m_lblPlayerNameOutput;
		/// <summary>
		/// The labels for the plus/minus sign for each player in the output panel.
		/// </summary>
		Label [] m_lblPlusMinusOutput;
		/// <summary>
		/// The output fields for \mu for each player.
		/// </summary>
		Label [] m_lblMuOutput;
		/// <summary>
		/// The output fields for \sigma for each player.
		/// </summary>
		Label [] m_lblSigmaOutput;
		/// <summary>
		/// A variable indicating whether or not the output should be updated.
		/// </summary>
		bool m_bUpdateOutput;
		#endregion

		#region Form varaible declarations

		private System.Windows.Forms.Button btnQuit;
		private System.Windows.Forms.TreeView tvTeamRanking;
		private System.Windows.Forms.Label label1;
		private System.Windows.Forms.ContextMenu cmTeamRanking;
		private System.Windows.Forms.Panel pnlOutput;
		private System.Windows.Forms.Panel pnlInput;
		private System.Windows.Forms.Label label2;
		private System.Windows.Forms.Label label3;
		private System.Windows.Forms.Button btnNewPlayer;
		private System.Windows.Forms.Button btnDeletePlayer;
		private System.Windows.Forms.Button btnAfterGameToBeforeGame;
		private System.Windows.Forms.Label label4;
		private System.Windows.Forms.GroupBox gbCalculator;
		private System.Windows.Forms.GroupBox gbMuSigmaParameter;
		private System.Windows.Forms.NumericUpDown numMuSigmaBeta;
		private System.Windows.Forms.Label label5;
		private System.Windows.Forms.NumericUpDown numMuSigmaDrawProbability;
		private System.Windows.Forms.NumericUpDown numMuSigmaTau;
		private System.Windows.Forms.Label label6;
		private System.Windows.Forms.Button btnResetSkills;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;
		#endregion

		#region Constructor and Destructor
		/// <summary>
		/// Standard constructor for the rank calculator application.
		/// </summary>
		public frmRankCalculator ()
		{
			// Required for Windows Form Designer support
			InitializeComponent();

			// add a version number
			Version aVersion = typeof (frmRankCalculator).Assembly.GetName ().Version;
			this.Text = "RankCalculator (v " + aVersion.ToString () + ")";

			// set-up the ranking system
			m_aMuSigmaRankingSystem = new MuSigmaRankingSystem (new PlayerSkillsList (), 250.0, 45.0, 3.0, Algorithm.EPAlgorithm, 20);
			PlayerSkillsList aPlayerSkillsList = m_aMuSigmaRankingSystem.PlayerSkillsList;

			// set-up the player-list
			m_aPlayerList = new PlayerList ();
			aPlayerSkillsList.AddPlayerSkills (new PlayerSkills (2), m_aPlayerList.AddPlayer ("Alice")); 
			aPlayerSkillsList.AddPlayerSkills (new PlayerSkills (2), m_aPlayerList.AddPlayer ("Bob"));
			aPlayerSkillsList.AddPlayerSkills (new PlayerSkills (2), m_aPlayerList.AddPlayer ("Chris"));
			aPlayerSkillsList.AddPlayerSkills (new PlayerSkills (2), m_aPlayerList.AddPlayer ("Darren"));
			aPlayerSkillsList.AddPlayerSkills (new PlayerSkills (2), m_aPlayerList.AddPlayer ("Eve"));
			aPlayerSkillsList.AddPlayerSkills (new PlayerSkills (2), m_aPlayerList.AddPlayer ("Fabian"));
			aPlayerSkillsList.AddPlayerSkills (new PlayerSkills (2), m_aPlayerList.AddPlayer ("George"));
			aPlayerSkillsList.AddPlayerSkills (new PlayerSkills (2), m_aPlayerList.AddPlayer ("Hillary"));
			aPlayerSkillsList.AddPlayerSkills (new PlayerSkills (2), m_aPlayerList.AddPlayer ("Ian"));
			aPlayerSkillsList.AddPlayerSkills (new PlayerSkills (2), m_aPlayerList.AddPlayer ("John"));
			aPlayerSkillsList.AddPlayerSkills (new PlayerSkills (2), m_aPlayerList.AddPlayer ("Kurt"));
			aPlayerSkillsList.AddPlayerSkills (new PlayerSkills (2), m_aPlayerList.AddPlayer ("Leo"));
			aPlayerSkillsList.AddPlayerSkills (new PlayerSkills (2), m_aPlayerList.AddPlayer ("Michael"));
			aPlayerSkillsList.AddPlayerSkills (new PlayerSkills (2), m_aPlayerList.AddPlayer ("Nathan"));
			aPlayerSkillsList.AddPlayerSkills (new PlayerSkills (2), m_aPlayerList.AddPlayer ("Ora"));
			aPlayerSkillsList.AddPlayerSkills (new PlayerSkills (2), m_aPlayerList.AddPlayer ("Paul"));
			aPlayerSkillsList.AddPlayerSkills (new PlayerSkills (2), m_aPlayerList.AddPlayer ("Quentin"));
			aPlayerSkillsList.AddPlayerSkills (new PlayerSkills (2), m_aPlayerList.AddPlayer ("Ralf"));
			aPlayerSkillsList.AddPlayerSkills (new PlayerSkills (2), m_aPlayerList.AddPlayer ("Steve"));
			aPlayerSkillsList.AddPlayerSkills (new PlayerSkills (2), m_aPlayerList.AddPlayer ("Thore"));
			aPlayerSkillsList.AddPlayerSkills (new PlayerSkills (2), m_aPlayerList.AddPlayer ("Ursula"));
			aPlayerSkillsList.AddPlayerSkills (new PlayerSkills (2), m_aPlayerList.AddPlayer ("Vincent"));
			aPlayerSkillsList.AddPlayerSkills (new PlayerSkills (2), m_aPlayerList.AddPlayer ("Walter"));
			aPlayerSkillsList.AddPlayerSkills (new PlayerSkills (2), m_aPlayerList.AddPlayer ("Xena"));
			aPlayerSkillsList.AddPlayerSkills (new PlayerSkills (2), m_aPlayerList.AddPlayer ("Yasmine"));
			aPlayerSkillsList.AddPlayerSkills (new PlayerSkills (2), m_aPlayerList.AddPlayer ("Zach"));

			// generate the input and output panel
			GenerateInputOutputPanel ();
			m_bUpdateOutput = true;

			// set-up a game
			m_aGame = new Game (DateTime.Now);
			btnNewPlayer_Click (null, null);
			btnNewPlayer_Click (null, null);

			// redraw the ranking
			UpdateTreeView ();
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose (bool disposing)
		{
			if (disposing)
			{
				if (components != null) 
				{
					components.Dispose ();
				}
			}
			base.Dispose (disposing);
		}
		#endregion

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(frmRankCalculator));
			this.label3 = new System.Windows.Forms.Label();
			this.label2 = new System.Windows.Forms.Label();
			this.pnlOutput = new System.Windows.Forms.Panel();
			this.label1 = new System.Windows.Forms.Label();
			this.tvTeamRanking = new System.Windows.Forms.TreeView();
			this.cmTeamRanking = new System.Windows.Forms.ContextMenu();
			this.pnlInput = new System.Windows.Forms.Panel();
			this.btnQuit = new System.Windows.Forms.Button();
			this.btnNewPlayer = new System.Windows.Forms.Button();
			this.btnDeletePlayer = new System.Windows.Forms.Button();
			this.btnAfterGameToBeforeGame = new System.Windows.Forms.Button();
			this.label4 = new System.Windows.Forms.Label();
			this.gbCalculator = new System.Windows.Forms.GroupBox();
			this.gbMuSigmaParameter = new System.Windows.Forms.GroupBox();
			this.numMuSigmaBeta = new System.Windows.Forms.NumericUpDown();
			this.numMuSigmaDrawProbability = new System.Windows.Forms.NumericUpDown();
			this.label5 = new System.Windows.Forms.Label();
			this.numMuSigmaTau = new System.Windows.Forms.NumericUpDown();
			this.label6 = new System.Windows.Forms.Label();
			this.btnResetSkills = new System.Windows.Forms.Button();
			this.gbCalculator.SuspendLayout();
			this.gbMuSigmaParameter.SuspendLayout();
			((System.ComponentModel.ISupportInitialize)(this.numMuSigmaBeta)).BeginInit();
			((System.ComponentModel.ISupportInitialize)(this.numMuSigmaDrawProbability)).BeginInit();
			((System.ComponentModel.ISupportInitialize)(this.numMuSigmaTau)).BeginInit();
			this.SuspendLayout();
			// 
			// label3
			// 
			this.label3.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.label3.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Italic, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.label3.Location = new System.Drawing.Point(440, 16);
			this.label3.Name = "label3";
			this.label3.Size = new System.Drawing.Size(112, 16);
			this.label3.TabIndex = 5;
			this.label3.Text = "Skills after game";
			this.label3.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
			// 
			// label2
			// 
			this.label2.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Italic, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.label2.Location = new System.Drawing.Point(16, 16);
			this.label2.Name = "label2";
			this.label2.Size = new System.Drawing.Size(112, 16);
			this.label2.TabIndex = 4;
			this.label2.Text = "Skills before game";
			this.label2.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
			// 
			// pnlOutput
			// 
			this.pnlOutput.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
				| System.Windows.Forms.AnchorStyles.Right)));
			this.pnlOutput.AutoScroll = true;
			this.pnlOutput.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
			this.pnlOutput.Location = new System.Drawing.Point(440, 32);
			this.pnlOutput.Name = "pnlOutput";
			this.pnlOutput.Size = new System.Drawing.Size(256, 360);
			this.pnlOutput.TabIndex = 2;
			// 
			// label1
			// 
			this.label1.Anchor = System.Windows.Forms.AnchorStyles.Top;
			this.label1.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Italic, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.label1.Location = new System.Drawing.Point(280, 16);
			this.label1.Name = "label1";
			this.label1.Size = new System.Drawing.Size(112, 16);
			this.label1.TabIndex = 1;
			this.label1.Text = "Team Ranking ";
			this.label1.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
			// 
			// tvTeamRanking
			// 
			this.tvTeamRanking.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)));
			this.tvTeamRanking.ContextMenu = this.cmTeamRanking;
			this.tvTeamRanking.ImageIndex = -1;
			this.tvTeamRanking.Location = new System.Drawing.Point(280, 32);
			this.tvTeamRanking.Name = "tvTeamRanking";
			this.tvTeamRanking.SelectedImageIndex = -1;
			this.tvTeamRanking.Size = new System.Drawing.Size(152, 360);
			this.tvTeamRanking.TabIndex = 0;
			this.tvTeamRanking.MouseDown += new System.Windows.Forms.MouseEventHandler(this.tvTeamRanking_MouseDown);
			// 
			// pnlInput
			// 
			this.pnlInput.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
				| System.Windows.Forms.AnchorStyles.Left)));
			this.pnlInput.AutoScroll = true;
			this.pnlInput.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
			this.pnlInput.Location = new System.Drawing.Point(16, 32);
			this.pnlInput.Name = "pnlInput";
			this.pnlInput.Size = new System.Drawing.Size(256, 360);
			this.pnlInput.TabIndex = 3;
			// 
			// btnQuit
			// 
			this.btnQuit.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
			this.btnQuit.Location = new System.Drawing.Point(624, 472);
			this.btnQuit.Name = "btnQuit";
			this.btnQuit.Size = new System.Drawing.Size(80, 24);
			this.btnQuit.TabIndex = 1;
			this.btnQuit.Text = "Quit";
			this.btnQuit.Click += new System.EventHandler(this.btnQuit_Click);
			// 
			// btnNewPlayer
			// 
			this.btnNewPlayer.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
			this.btnNewPlayer.Location = new System.Drawing.Point(8, 472);
			this.btnNewPlayer.Name = "btnNewPlayer";
			this.btnNewPlayer.Size = new System.Drawing.Size(80, 24);
			this.btnNewPlayer.TabIndex = 2;
			this.btnNewPlayer.Text = "New player";
			this.btnNewPlayer.Click += new System.EventHandler(this.btnNewPlayer_Click);
			// 
			// btnDeletePlayer
			// 
			this.btnDeletePlayer.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
			this.btnDeletePlayer.Location = new System.Drawing.Point(104, 472);
			this.btnDeletePlayer.Name = "btnDeletePlayer";
			this.btnDeletePlayer.Size = new System.Drawing.Size(80, 24);
			this.btnDeletePlayer.TabIndex = 3;
			this.btnDeletePlayer.Text = "Delete player";
			this.btnDeletePlayer.Click += new System.EventHandler(this.btnDeletePlayer_Click);
			// 
			// btnAfterGameToBeforeGame
			// 
			this.btnAfterGameToBeforeGame.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
			this.btnAfterGameToBeforeGame.Location = new System.Drawing.Point(224, 472);
			this.btnAfterGameToBeforeGame.Name = "btnAfterGameToBeforeGame";
			this.btnAfterGameToBeforeGame.Size = new System.Drawing.Size(160, 24);
			this.btnAfterGameToBeforeGame.TabIndex = 4;
			this.btnAfterGameToBeforeGame.Text = "After game -> Before game";
			this.btnAfterGameToBeforeGame.Click += new System.EventHandler(this.btnAfterGameToBeforeGame_Click);
			// 
			// label4
			// 
			this.label4.Location = new System.Drawing.Point(40, 16);
			this.label4.Name = "label4";
			this.label4.Size = new System.Drawing.Size(64, 23);
			this.label4.TabIndex = 0;
			this.label4.Text = "Beta";
			this.label4.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
			// 
			// gbCalculator
			// 
			this.gbCalculator.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
				| System.Windows.Forms.AnchorStyles.Left) 
				| System.Windows.Forms.AnchorStyles.Right)));
			this.gbCalculator.Controls.Add(this.tvTeamRanking);
			this.gbCalculator.Controls.Add(this.label1);
			this.gbCalculator.Controls.Add(this.pnlOutput);
			this.gbCalculator.Controls.Add(this.label2);
			this.gbCalculator.Controls.Add(this.label3);
			this.gbCalculator.Controls.Add(this.pnlInput);
			this.gbCalculator.Location = new System.Drawing.Point(8, 8);
			this.gbCalculator.Name = "gbCalculator";
			this.gbCalculator.Size = new System.Drawing.Size(712, 400);
			this.gbCalculator.TabIndex = 0;
			this.gbCalculator.TabStop = false;
			this.gbCalculator.Text = "Calculator";
			// 
			// gbMuSigmaParameter
			// 
			this.gbMuSigmaParameter.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left) 
				| System.Windows.Forms.AnchorStyles.Right)));
			this.gbMuSigmaParameter.Controls.Add(this.numMuSigmaTau);
			this.gbMuSigmaParameter.Controls.Add(this.label6);
			this.gbMuSigmaParameter.Controls.Add(this.numMuSigmaDrawProbability);
			this.gbMuSigmaParameter.Controls.Add(this.label5);
			this.gbMuSigmaParameter.Controls.Add(this.numMuSigmaBeta);
			this.gbMuSigmaParameter.Controls.Add(this.label4);
			this.gbMuSigmaParameter.Location = new System.Drawing.Point(8, 416);
			this.gbMuSigmaParameter.Name = "gbMuSigmaParameter";
			this.gbMuSigmaParameter.Size = new System.Drawing.Size(712, 48);
			this.gbMuSigmaParameter.TabIndex = 6;
			this.gbMuSigmaParameter.TabStop = false;
			this.gbMuSigmaParameter.Text = "MuSigma Parameters";
			// 
			// numMuSigmaBeta
			// 
			this.numMuSigmaBeta.DecimalPlaces = 1;
			this.numMuSigmaBeta.Location = new System.Drawing.Point(112, 16);
			this.numMuSigmaBeta.Maximum = new System.Decimal(new int[] {
																		   1000,
																		   0,
																		   0,
																		   0});
			this.numMuSigmaBeta.Name = "numMuSigmaBeta";
			this.numMuSigmaBeta.TabIndex = 1;
			this.numMuSigmaBeta.Value = new System.Decimal(new int[] {
																		 250,
																		 0,
																		 0,
																		 0});
			this.numMuSigmaBeta.ValueChanged += new System.EventHandler(this.MuSigma_Changed);
			// 
			// numMuSigmaDrawProbability
			// 
			this.numMuSigmaDrawProbability.DecimalPlaces = 2;
			this.numMuSigmaDrawProbability.Increment = new System.Decimal(new int[] {
																						1,
																						0,
																						0,
																						131072});
			this.numMuSigmaDrawProbability.Location = new System.Drawing.Point(352, 16);
			this.numMuSigmaDrawProbability.Maximum = new System.Decimal(new int[] {
																					  99,
																					  0,
																					  0,
																					  131072});
			this.numMuSigmaDrawProbability.Name = "numMuSigmaDrawProbability";
			this.numMuSigmaDrawProbability.Size = new System.Drawing.Size(96, 20);
			this.numMuSigmaDrawProbability.TabIndex = 3;
			this.numMuSigmaDrawProbability.Value = new System.Decimal(new int[] {
																					1,
																					0,
																					0,
																					65536});
			this.numMuSigmaDrawProbability.ValueChanged += new System.EventHandler(this.MuSigma_Changed);
			// 
			// label5
			// 
			this.label5.Location = new System.Drawing.Point(256, 16);
			this.label5.Name = "label5";
			this.label5.Size = new System.Drawing.Size(88, 23);
			this.label5.TabIndex = 2;
			this.label5.Text = "Draw Probability";
			this.label5.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
			// 
			// numMuSigmaTau
			// 
			this.numMuSigmaTau.DecimalPlaces = 1;
			this.numMuSigmaTau.Increment = new System.Decimal(new int[] {
																			1,
																			0,
																			0,
																			65536});
			this.numMuSigmaTau.Location = new System.Drawing.Point(552, 16);
			this.numMuSigmaTau.Name = "numMuSigmaTau";
			this.numMuSigmaTau.TabIndex = 5;
			this.numMuSigmaTau.Value = new System.Decimal(new int[] {
																		3,
																		0,
																		0,
																		0});
			this.numMuSigmaTau.ValueChanged += new System.EventHandler(this.MuSigma_Changed);
			// 
			// label6
			// 
			this.label6.Location = new System.Drawing.Point(480, 16);
			this.label6.Name = "label6";
			this.label6.Size = new System.Drawing.Size(64, 23);
			this.label6.TabIndex = 4;
			this.label6.Text = "Tau";
			this.label6.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
			// 
			// btnResetSkills
			// 
			this.btnResetSkills.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
			this.btnResetSkills.Location = new System.Drawing.Point(392, 472);
			this.btnResetSkills.Name = "btnResetSkills";
			this.btnResetSkills.Size = new System.Drawing.Size(96, 24);
			this.btnResetSkills.TabIndex = 7;
			this.btnResetSkills.Text = "Reset Skills";
			this.btnResetSkills.Click += new System.EventHandler(this.btnResetSkills_Click);
			// 
			// frmRankCalculator
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(728, 518);
			this.Controls.Add(this.btnResetSkills);
			this.Controls.Add(this.gbMuSigmaParameter);
			this.Controls.Add(this.btnAfterGameToBeforeGame);
			this.Controls.Add(this.btnDeletePlayer);
			this.Controls.Add(this.btnNewPlayer);
			this.Controls.Add(this.btnQuit);
			this.Controls.Add(this.gbCalculator);
			this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
			this.MaximumSize = new System.Drawing.Size(736, 1800);
			this.MinimumSize = new System.Drawing.Size(736, 550);
			this.Name = "frmRankCalculator";
			this.Text = "RankCalculator";
			this.gbCalculator.ResumeLayout(false);
			this.gbMuSigmaParameter.ResumeLayout(false);
			((System.ComponentModel.ISupportInitialize)(this.numMuSigmaBeta)).EndInit();
			((System.ComponentModel.ISupportInitialize)(this.numMuSigmaDrawProbability)).EndInit();
			((System.ComponentModel.ISupportInitialize)(this.numMuSigmaTau)).EndInit();
			this.ResumeLayout(false);

		}
		#endregion

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main () 
		{
			Application.Run (new frmRankCalculator ());
		}

		#region Input/Output Panel code
		/// <summary>
		/// Recomputes the rankings and shows them in the output panel.
		/// </summary>
		private void UpdateOutputPanel ()
		{
			// copy the MuSigma parameters
			m_aMuSigmaRankingSystem.Beta = (double) numMuSigmaBeta.Value;
			m_aMuSigmaRankingSystem.DrawProbability = (double) numMuSigmaDrawProbability.Value;
			m_aMuSigmaRankingSystem.Tau = (double) numMuSigmaTau.Value;

			// clear the player skills
			m_aMuSigmaRankingSystem.ClearPlayerSkills ();
			PlayerSkillsList aPlayerSkillsList = m_aMuSigmaRankingSystem.PlayerSkillsList;

			// initialise the player skills with the values set in the fields
			for (int iPlayerID = 0; iPlayerID < m_aGame.NumberOfPlayers; iPlayerID++) 
			{
				MuSigmaSkill aMuSigmaSkill = new MuSigmaSkill ((double) m_numMuInput [iPlayerID].Value, (double) m_numSigmaInput [iPlayerID].Value);
				aPlayerSkillsList.GetPlayerSkills (iPlayerID).AddSkill (aMuSigmaSkill, m_aGame.Date);
			}

			// update the player skills 
			m_aMuSigmaRankingSystem.Update (m_aGame);

			// compute the transition factors
			double [] dDifferences = new double [m_aGame.NumberOfPlayers];
			double dMinimum = double.MaxValue, dMaximum = double.MinValue;
			for (int iPlayerID = 0; iPlayerID < m_aGame.NumberOfPlayers; iPlayerID++) 
			{
				dDifferences [iPlayerID] = ((MuSigmaSkill) aPlayerSkillsList.GetPlayerSkills (iPlayerID).LatestSkill).Mu - (double) m_numMuInput [iPlayerID].Value; 
				if (dDifferences [iPlayerID] < dMinimum) dMinimum = dDifferences [iPlayerID];
				if (dDifferences [iPlayerID] > dMaximum) dMaximum = dDifferences [iPlayerID];
			}

			// read the new player skills 
			for (int iPlayerID = 0; iPlayerID < m_aGame.NumberOfPlayers; iPlayerID++) 
			{
				MuSigmaSkill aMuSigmaSkill = (MuSigmaSkill) aPlayerSkillsList.GetPlayerSkills (iPlayerID).LatestSkill;
				if (dMinimum < 0.0) 
					if (dDifferences [iPlayerID] > 0)
						m_lblMuOutput [iPlayerID].ForeColor = 
							Color.FromArgb (0, (int) (64 + 127 * dDifferences [iPlayerID] / dMaximum), 0);
					else
						m_lblMuOutput [iPlayerID].ForeColor = 
							Color.FromArgb ((int) (64 + 191 * dDifferences [iPlayerID] / dMinimum), 0, 0);
				else
					m_lblMuOutput [iPlayerID].ForeColor = Color.Black;
				m_lblMuOutput [iPlayerID].Font = new Font ("Arial", 8, FontStyle.Bold);
				m_lblMuOutput [iPlayerID].Text = aMuSigmaSkill.Mu.ToString ("f");
				m_lblSigmaOutput [iPlayerID].Text = aMuSigmaSkill.Sigma.ToString ("f");
			}
		}

		/// <summary>
		/// Generates the entire input and output data panel.
		/// </summary>
		private void GenerateInputOutputPanel ()
		{
			// suspense the layout of the panels 
			pnlInput.SuspendLayout ();
			pnlOutput.SuspendLayout ();

			// allocate the arrays
			m_lblPlayerNameInput = new Label [m_aPlayerList.NumberOfPlayers];
			m_lblPlusMinusInput = new Label [m_aPlayerList.NumberOfPlayers];
			m_numMuInput = new NumericUpDown [m_aPlayerList.NumberOfPlayers];
			m_numSigmaInput = new NumericUpDown [m_aPlayerList.NumberOfPlayers];
			m_lblPlayerNameOutput = new Label [m_aPlayerList.NumberOfPlayers];
			m_lblPlusMinusOutput = new Label [m_aPlayerList.NumberOfPlayers];
			m_lblMuOutput = new Label [m_aPlayerList.NumberOfPlayers];
			m_lblSigmaOutput = new Label [m_aPlayerList.NumberOfPlayers];

			for (int iPlayerID = 0; iPlayerID < m_aPlayerList.NumberOfPlayers; iPlayerID++) 
			{
				// allocate control elements
				m_lblPlayerNameInput [iPlayerID] = new Label ();
				m_lblPlusMinusInput [iPlayerID] = new Label ();
				m_numMuInput [iPlayerID] = new NumericUpDown ();
				m_numSigmaInput [iPlayerID] = new NumericUpDown ();

				m_lblPlayerNameOutput [iPlayerID] = new Label ();
				m_lblPlusMinusOutput [iPlayerID] = new Label ();
				m_lblMuOutput [iPlayerID] = new Label ();
				m_lblSigmaOutput [iPlayerID] = new Label ();

				// add the control elements to the input panel
				pnlInput.Controls.Add (m_lblPlayerNameInput [iPlayerID]);
				pnlInput.Controls.Add (m_lblPlusMinusInput [iPlayerID]);
				pnlInput.Controls.Add (m_numMuInput [iPlayerID]);
				pnlInput.Controls.Add (m_numSigmaInput [iPlayerID]);

				// add the control elements to the input panel
				pnlOutput.Controls.Add (m_lblPlayerNameOutput [iPlayerID]);
				pnlOutput.Controls.Add (m_lblPlusMinusOutput [iPlayerID]);
				pnlOutput.Controls.Add (m_lblMuOutput [iPlayerID]);
				pnlOutput.Controls.Add (m_lblSigmaOutput [iPlayerID]);

				// configure the input player name label
				m_lblPlayerNameInput [iPlayerID].Text = m_aPlayerList.GetPlayerName (iPlayerID);
				m_lblPlayerNameInput [iPlayerID].Location = new Point (10, iPlayerID * 30 + 5);
				m_lblPlayerNameInput [iPlayerID].Size = new Size (80, 25);
				m_lblPlayerNameInput [iPlayerID].TextAlign = ContentAlignment.MiddleLeft;
				m_lblPlayerNameInput [iPlayerID].Font = new Font ("Arial", 8, FontStyle.Bold);
				m_lblPlayerNameInput [iPlayerID].Visible = false;

				// configure the output player name label
				m_lblPlayerNameOutput [iPlayerID].Text = m_aPlayerList.GetPlayerName (iPlayerID);
				m_lblPlayerNameOutput [iPlayerID].Location = new Point (10, iPlayerID * 30 + 5);
				m_lblPlayerNameOutput [iPlayerID].Size = new Size (80, 25);
				m_lblPlayerNameOutput [iPlayerID].TextAlign = ContentAlignment.MiddleLeft;
				m_lblPlayerNameOutput [iPlayerID].Font = new Font ("Arial", 8, FontStyle.Bold);
				m_lblPlayerNameOutput [iPlayerID].Visible = false;

				// configure the input plus/minus label
				m_lblPlusMinusInput [iPlayerID].Text = "+/-";
				m_lblPlusMinusInput [iPlayerID].Location = new Point (150, iPlayerID * 30 + 5);
				m_lblPlusMinusInput [iPlayerID].Size = new Size (20, 25);
				m_lblPlusMinusInput [iPlayerID].TextAlign = ContentAlignment.TopCenter;
				m_lblPlusMinusInput [iPlayerID].Font = new Font ("Arial", 8, FontStyle.Bold);
				m_lblPlusMinusInput [iPlayerID].Visible = false;

				// configure the output plus/minus label
				m_lblPlusMinusOutput [iPlayerID].Text = "+/-";
				m_lblPlusMinusOutput [iPlayerID].Location = new Point (150, iPlayerID * 30 + 5);
				m_lblPlusMinusOutput [iPlayerID].Size = new Size (20, 25);
				m_lblPlusMinusOutput [iPlayerID].TextAlign = ContentAlignment.MiddleCenter;
				m_lblPlusMinusOutput [iPlayerID].Font = new Font ("Arial", 8, FontStyle.Bold);
				m_lblPlusMinusOutput [iPlayerID].Visible = false;

				// configure the input \mu field
				m_numMuInput [iPlayerID].Location = new Point (90, iPlayerID * 30 + 5);
				m_numMuInput [iPlayerID].Size = new Size (60, 25);
				m_numMuInput [iPlayerID].Minimum = -5000;
				m_numMuInput [iPlayerID].Maximum = 10000;
				m_numMuInput [iPlayerID].Value = 1200;
				m_numMuInput [iPlayerID].Increment = 1;
				m_numMuInput [iPlayerID].DecimalPlaces = 1;
				m_numMuInput [iPlayerID].ValueChanged += new EventHandler (MuSigma_Changed);
				m_numMuInput [iPlayerID].Visible = false;

				// configure the output \mu field
				m_lblMuOutput [iPlayerID].Location = new Point (90, iPlayerID * 30 + 5);
				m_lblMuOutput [iPlayerID].Size = new Size (60, 25);
				m_lblMuOutput [iPlayerID].BorderStyle = BorderStyle.FixedSingle;
				m_lblMuOutput [iPlayerID].Text = "1200.0";
				m_lblMuOutput [iPlayerID].TextAlign = ContentAlignment.MiddleLeft;
				m_lblMuOutput [iPlayerID].Visible = false;

				// configure the input \mu field
				m_numSigmaInput [iPlayerID].Location = new Point (170, iPlayerID * 30 + 5);
				m_numSigmaInput [iPlayerID].Size = new Size (60, 25);
				m_numSigmaInput [iPlayerID].Minimum = 0;
				m_numSigmaInput [iPlayerID].Maximum = 2000;
				m_numSigmaInput [iPlayerID].Value = 400;
				m_numSigmaInput [iPlayerID].Increment = (decimal) 0.1;
				m_numSigmaInput [iPlayerID].DecimalPlaces = 2;
				m_numSigmaInput [iPlayerID].ValueChanged += new EventHandler (MuSigma_Changed);
				m_numSigmaInput [iPlayerID].Visible = false;

				// configure the output \sigma field
				m_lblSigmaOutput [iPlayerID].Location = new Point (170, iPlayerID * 30 + 5);
				m_lblSigmaOutput [iPlayerID].Size = new Size (60, 25);
				m_lblSigmaOutput [iPlayerID].BorderStyle = BorderStyle.FixedSingle;
				m_lblSigmaOutput [iPlayerID].Text = "400.00";
				m_lblSigmaOutput [iPlayerID].TextAlign = ContentAlignment.MiddleLeft;
				m_lblSigmaOutput [iPlayerID].Visible = false;
			}

			// resume the layout after all controls are added
			pnlOutput.ResumeLayout ();
			pnlInput.ResumeLayout ();

			// done!
			return;
		}
		#endregion

		#region Treeview code
		/// <summary>
		/// Rebuilds the tree view from the game data.
		/// </summary>
		private void UpdateTreeView ()
		{
			// re-compute the ranking
			Ranking aRanking = m_aGame.Ranking;
			int [] iTeamID = aRanking.Indicies;

			// suspend the layout of the treeview
			tvTeamRanking.SuspendLayout ();

			// empty the tree-view
			tvTeamRanking.Nodes.Clear ();

			// set the tree view font size
			tvTeamRanking.Font = new Font ("Arial", 8, FontStyle.Bold);

			// build up the new view
			TreeNode aRankNode = null;
			for (int iRankCounter = 0; iRankCounter < aRanking.NumberOfElements; iRankCounter++)
			{
				// possibly allocate a new rank node
				if (iRankCounter == 0 || aRanking.GetWinner (iTeamID [iRankCounter], iTeamID [iRankCounter - 1]) != 0) 
					aRankNode = NewRankNode (iRankCounter);

				TreeNode aTeamNode = NewTeamNode (iTeamID [iRankCounter]);
				aRankNode.Nodes.Add (aTeamNode);

				int [] iPlayerIDs = m_aGame.GetTeam (iTeamID [iRankCounter]).PlayerIDs;
				for (int iPlayerIndex = 0; iPlayerIndex < iPlayerIDs.Length; iPlayerIndex++) 
					aTeamNode.Nodes.Add (NewPlayerNode (m_aPlayerList.GetPlayerName (iPlayerIDs [iPlayerIndex])));

				// possibly add the new node to the rank tree view
				if (iRankCounter == 0 || aRanking.GetWinner (iTeamID [iRankCounter], iTeamID [iRankCounter - 1]) != 0)
					tvTeamRanking.Nodes.Add (aRankNode);
			}
			tvTeamRanking.ExpandAll ();

			// resume the layout of the treeview
			tvTeamRanking.ResumeLayout ();

			// done!
			return;
		}

		/// <summary>
		/// Rebuilds the game data from the tree view.
		/// </summary>
		private void UpdateGameData ()
		{	
			// start a new game
			m_aGame = new Game (DateTime.Now);

			// parse the list one by one
			for (int iRankIdx = 0; iRankIdx < tvTeamRanking.Nodes.Count; iRankIdx++)
			{
				TreeNode aCurrentRankNode = tvTeamRanking.Nodes [iRankIdx];

				for (int iTeamIdx = 0; iTeamIdx < aCurrentRankNode.Nodes.Count; iTeamIdx++)
				{
					TreeNode aCurrentTeamNode = aCurrentRankNode.Nodes [iTeamIdx];
					int iTeamID = GetTeamID (aCurrentTeamNode);
					
					// insert as many empty teams as necessary to match the team ID
					for (int i = m_aGame.NumberOfTeams; i <= iTeamID; i++)
						m_aGame.AddTeam (new Team ());
					Team aCurrentTeam = m_aGame.GetTeam (iTeamID);

					// add all the players to the team (and make sure the team score equals minus the rank
					for (int iPlayerIdx = 0; iPlayerIdx < aCurrentTeamNode.Nodes.Count; iPlayerIdx++)
						if (iPlayerIdx == 0)
							aCurrentTeam.AddPlayer (m_aPlayerList.GetPlayerID (GetPlayerName (aCurrentTeamNode.Nodes [iPlayerIdx])), -1 - GetRank (aCurrentRankNode));
						else
							aCurrentTeam.AddPlayer (m_aPlayerList.GetPlayerID (GetPlayerName (aCurrentTeamNode.Nodes [iPlayerIdx])), 0);					
				}
			}

			// remove the empty teams
			m_aGame.RemoveEmptyTeams ();

			// done!
			return;
		}
		#endregion

		#region Helper function
		/// <summary>
		/// Creates a new rank tree node for the tree view.
		/// </summary>
		/// <param name="iRank">The zero-based rank to insert into.</param>
		/// <returns>A new tree node that has all relevant rank information.</returns>
		private TreeNode NewRankNode (int iRank)
		{
			TreeNode aRankNode = new TreeNode ("Rank " + (iRank + 1));
			aRankNode.NodeFont = new Font ("Arial", 8, FontStyle.Regular);
			aRankNode.ForeColor = Color.Blue;
			aRankNode.Tag = (string) ("Rank " + iRank);

			return aRankNode;
		}

		/// <summary>
		/// Creates a new team tree node for the tree view.
		/// </summary>
		/// <param name="iTeamID">The zero-based team ID to insert into.</param>
		/// <returns>A new tree node that has all relevant team ID information.</returns>
		private TreeNode NewTeamNode (int iTeamID)
		{
			TreeNode aTeamNode = new TreeNode ("Team " + (iTeamID + 1));
			aTeamNode.NodeFont = new Font ("Arial", 8, FontStyle.Italic);
			aTeamNode.ForeColor = Color.Firebrick;
			aTeamNode.Tag = (string) ("Team " + iTeamID);

			return aTeamNode;
		}

		/// <summary>
		/// Creates a new player tree node for the tree view.
		/// </summary>
		/// <param name="szPlayerName">The name of the player to insert.</param>
		/// <returns>A new tree node that has all relevant player information.</returns>
		private TreeNode NewPlayerNode (string szPlayerName)
		{
			TreeNode aPlayerNode = new TreeNode (szPlayerName);
			aPlayerNode.NodeFont = new Font ("Arial", 8, FontStyle.Bold);
			aPlayerNode.ForeColor = Color.Black;
			aPlayerNode.Tag = (string) ("Player " + szPlayerName);

			return aPlayerNode;
		}

		/// <summary>
		/// Checks whether or not the current node is a rank node.
		/// </summary>
		/// <param name="aTreeNode">The tree node in the tree view.</param>
		/// <returns><c>True</c> if the node was a rank node or false otherwise.</returns>
		private bool IsRankNode (TreeNode aTreeNode)
		{
			return (((string) aTreeNode.Tag).Substring (0, 4).CompareTo ("Rank") == 0);
		}

		/// <summary>
		/// Checks whether or not the current node is a team node.
		/// </summary>
		/// <param name="aTreeNode">The tree node in the tree view.</param>
		/// <returns><c>True</c> if the node was a team node or false otherwise.</returns>
		private bool IsTeamNode (TreeNode aTreeNode)
		{
			return (((string) aTreeNode.Tag).Substring (0, 4).CompareTo ("Team") == 0);
		}

		/// <summary>
		/// Checks whether or not the current node is a player node.
		/// </summary>
		/// <param name="aTreeNode">The tree node in the tree view.</param>
		/// <returns><c>True</c> if the node was a player node or false otherwise.</returns>
		private bool IsPlayerNode (TreeNode aTreeNode)
		{
			return (((string) aTreeNode.Tag).Substring (0, 6).CompareTo ("Player") == 0);
		}

		/// <summary>
		/// Gets the zero=based rank from a rank node.
		/// </summary>
		/// <param name="aRankNode">The rank tree node in the tree view.</param>
		/// <returns>The zero-based rank.</returns>
		/// <remarks>This function assumes that the node passed in is indeed a rank tree node!</remarks>
		private int GetRank (TreeNode aRankNode)
		{
			return (Convert.ToInt32 (((string) aRankNode.Tag).Substring (5)));
		}

		/// <summary>
		/// Gets the zero-based team ID from a rank node.
		/// </summary>
		/// <param name="aTeamNode">The team tree node in the tree view.</param>
		/// <returns>The zero-based team ID.</returns>
		/// <remarks>This function assumes that the node passed in is indeed a team tree node!</remarks>
		private int GetTeamID (TreeNode aTeamNode)
		{
			return (Convert.ToInt32 (((string) aTeamNode.Tag).Substring (5)));
		}

		/// <summary>
		/// Gets the player name from a player node.
		/// </summary>
		/// <param name="aPlayerNode">The player tree node in the tree view.</param>
		/// <returns>The player name.</returns>
		/// <remarks>This function assumes that the node passed in is indeed a player tree node!</remarks>
		private string GetPlayerName (TreeNode aPlayerNode)
		{
			return (((string) aPlayerNode.Tag).Substring (7));
		}
		#endregion

		#region Event Handlers
		/// <summary>
		/// Handles a click on the "Quit" button.
		/// </summary>
		/// <param name="sender">Control element that sends the event.</param>
		/// <param name="e">Event parameter.</param>
		private void btnQuit_Click (object sender, System.EventArgs e)
		{
			this.Close ();
			return;
		}

		/// <summary>
		/// Handles a click on the "New Player" button.
		/// </summary>
		/// <param name="sender">Control element that sends the event.</param>
		/// <param name="e">Event parameter.</param>
		private void btnNewPlayer_Click (object sender, System.EventArgs e)
		{
			// add the player in a new team
			Team aTeam = new Team ();
			aTeam.AddPlayer (m_aGame.NumberOfPlayers, -1 - m_aGame.NumberOfTeams);
			m_aGame.AddTeam (aTeam);

			// update the tree view 
			UpdateTreeView ();
			UpdateGameData ();

			// update the output panel
			UpdateOutputPanel ();

			// enable all the player input data
			m_lblPlayerNameInput [m_aGame.NumberOfPlayers - 1].Visible = true;
			m_lblPlusMinusInput [m_aGame.NumberOfPlayers - 1].Visible = true;
			m_numMuInput [m_aGame.NumberOfPlayers - 1].Visible = true;
			m_numSigmaInput [m_aGame.NumberOfPlayers - 1].Visible = true;

			// enable all the player output data
			m_lblPlayerNameOutput [m_aGame.NumberOfPlayers - 1].Visible = true;
			m_lblPlusMinusOutput [m_aGame.NumberOfPlayers - 1].Visible = true;
			m_lblMuOutput [m_aGame.NumberOfPlayers - 1].Visible = true;
			m_lblSigmaOutput [m_aGame.NumberOfPlayers - 1].Visible = true;

			// possibly disable the button "New player"
			if (m_aGame.NumberOfPlayers == m_aPlayerList.NumberOfPlayers)
				btnNewPlayer.Enabled = false;
			else
				btnDeletePlayer.Enabled = true;

			// done!
			return;
		}

		/// <summary>
		/// Handles a click on the "Delete Player" button.
		/// </summary>
		/// <param name="sender">Control element that sends the event.</param>
		/// <param name="e">Event parameter.</param>
		private void btnDeletePlayer_Click(object sender, System.EventArgs e)
		{
			// find the player node
			TreeNode aPlayerNode = null;
			string szPlayer = m_aPlayerList.GetPlayerName (m_aGame.NumberOfPlayers - 1);

			for (int iRankIdx = 0; iRankIdx < tvTeamRanking.Nodes.Count; iRankIdx++)
			{
				TreeNode aCurrentRankNode = tvTeamRanking.Nodes [iRankIdx];
				for (int iTeamIdx = 0; iTeamIdx < aCurrentRankNode.Nodes.Count; iTeamIdx++) 
				{
					TreeNode aCurrentTeamNode = aCurrentRankNode.Nodes [iTeamIdx];
					for (int iPlayerIdx = 0; iPlayerIdx < aCurrentTeamNode.Nodes.Count; iPlayerIdx++)
						if (GetPlayerName (aCurrentTeamNode.Nodes [iPlayerIdx]).CompareTo (szPlayer) == 0) 
						{
							aPlayerNode = aCurrentTeamNode.Nodes [iPlayerIdx];
							break;
						}
				}
			}
			Debug.Assert (aPlayerNode != null, "Player node not found.");

			// remove the player node from the team node it was in
			TreeNode aSourceTeamNode = aPlayerNode.Parent;
			aSourceTeamNode.Nodes.Remove (aPlayerNode);

			//////////////////////////////////////////////////////////////////
			// remove the team if there are no more players left in it
			if (aSourceTeamNode.Nodes.Count == 0) 
			{
				TreeNode aSourceRankNode = aSourceTeamNode.Parent;
				aSourceRankNode.Nodes.Remove (aSourceTeamNode);

				// remove the rank if there are no more teams at it
				if (aSourceRankNode.Nodes.Count == 0)
					tvTeamRanking.Nodes.Remove (aSourceRankNode);
			}

			// enable all the player input data
			m_lblPlayerNameInput [m_aGame.NumberOfPlayers - 1].Visible = false;
			m_lblPlusMinusInput [m_aGame.NumberOfPlayers - 1].Visible = false;
			m_numMuInput [m_aGame.NumberOfPlayers - 1].Visible = false;
			m_numSigmaInput [m_aGame.NumberOfPlayers - 1].Visible = false;

			// enable all the player output data
			m_lblPlayerNameOutput [m_aGame.NumberOfPlayers - 1].Visible = false;
			m_lblPlusMinusOutput [m_aGame.NumberOfPlayers - 1].Visible = false;
			m_lblMuOutput [m_aGame.NumberOfPlayers - 1].Visible = false;
			m_lblSigmaOutput [m_aGame.NumberOfPlayers - 1].Visible = false;

			// finally, synchronise the treeview with the game data
			UpdateGameData ();
			UpdateTreeView ();

			// update the output panel
			UpdateOutputPanel ();

			// possibly disable the button
			if (m_aGame.NumberOfPlayers == 2)
				btnDeletePlayer.Enabled = false;
			else
				btnNewPlayer.Enabled = true;
		}

		/// <summary>
		/// Handles a click on the "After Game -> Before Game" button.
		/// </summary>
		/// <param name="sender">Control element that sends the event.</param>
		/// <param name="e">Event parameter.</param>
		private void btnAfterGameToBeforeGame_Click(object sender, System.EventArgs e)
		{
			// suspend updates
			m_bUpdateOutput = false;

			// copy the Mu/Sigma parameter one-by-one
			for (int iPlayerID = 0; iPlayerID < m_aGame.NumberOfPlayers; iPlayerID++) 
			{
				m_numMuInput [iPlayerID].Value = Convert.ToDecimal (m_lblMuOutput [iPlayerID].Text); 
				m_numSigmaInput [iPlayerID].Value = Convert.ToDecimal (m_lblSigmaOutput [iPlayerID].Text); 
			}

			// resume updates
			m_bUpdateOutput = true;
			UpdateOutputPanel ();

			// done!
			return;
		}

		/// <summary>
		/// Handles a click on the "Reset Skills" button.
		/// </summary>
		/// <param name="sender">Control element that sends the event.</param>
		/// <param name="e">Event parameter.</param>
		private void btnResetSkills_Click(object sender, System.EventArgs e)
		{		
			// suspend updates
			m_bUpdateOutput = false;

			// copy the Mu/Sigma parameter one-by-one
			for (int iPlayerID = 0; iPlayerID < m_aPlayerList.NumberOfPlayers; iPlayerID++) 
			{
				m_numMuInput [iPlayerID].Value = 1200; 
				m_numSigmaInput [iPlayerID].Value = 400; 
			}

			// resume updates
			m_bUpdateOutput = true;
			UpdateOutputPanel ();

			// done!
			return;
		}

		/// <summary>
		/// Handles a mouse click down for the various context menus.
		/// </summary>
		/// <param name="sender">Control element that sends the event.</param>
		/// <param name="e">Event parameter.</param>
		private void tvTeamRanking_MouseDown (object sender, System.Windows.Forms.MouseEventArgs e)
		{
			// check that the right mouse button was clicked
			if (e.Button == MouseButtons.Right)
			{
				TreeNode aSelectedNode = tvTeamRanking.GetNodeAt (e.X, e.Y);
				if (aSelectedNode != null) 
				{
					// select the node by hand
					tvTeamRanking.SelectedNode = aSelectedNode;

					// Clear all previously added MenuItems.
					cmTeamRanking.MenuItems.Clear();

					/////////////////////////////////////////////////////////////////////////////
					// prepare the menu that will be displayed if we click on a rank node
					/////////////////////////////////////////////////////////////////////////////
					if (IsRankNode (aSelectedNode)) 
					{
						// mark teams that are already on this rank
						bool [] bInRankAlready = new bool [m_aGame.NumberOfTeams];

						for (int i = 0; i < m_aGame.NumberOfTeams; i++)
							bInRankAlready [i] = false;
						for (int i = 0; i < aSelectedNode.Nodes.Count; i++)
							bInRankAlready [GetTeamID (aSelectedNode.Nodes [i])] = true;

						// add the appropriate team IDs
						for (int i = 0; i < m_aGame.NumberOfTeams; i++) 
							if (!bInRankAlready [i]) 
							{
								MenuItem aMenuItem = new MenuItem ("Move team " + (i + 1) + " to " + aSelectedNode.Text.ToLower ());
								cmTeamRanking.MenuItems.Add (aMenuItem);
								aMenuItem.Click += new EventHandler (aTeamToRank_Click);
							}
					}

					/////////////////////////////////////////////////////////////////////////////
					// prepare the menu that will be displayed if we click on a team node
					/////////////////////////////////////////////////////////////////////////////
					if (((string) aSelectedNode.Tag).Substring (0, 4).CompareTo ("Team") == 0) 
					{
						int iCurrentRank = GetRank (aSelectedNode.Parent);

						// go over all possible ranks
						for (int iRank = 0; iRank < m_aGame.NumberOfTeams; iRank++)
							if (iRank != iCurrentRank) 
							{
								MenuItem aMenuItem = new MenuItem ("Move " + aSelectedNode.Text.ToLower () + " to rank " + (iRank + 1));
								cmTeamRanking.MenuItems.Add (aMenuItem);
								aMenuItem.Click += new EventHandler (aTeamToRank_Click);
							}
					} 

					/////////////////////////////////////////////////////////////////////////////
					// prepare the menu that will be displayed if we click on a team node
					/////////////////////////////////////////////////////////////////////////////
					if (((string) aSelectedNode.Tag).Substring (0, 6).CompareTo ("Player") == 0) 
					{
						int iCurrentTeamID = GetTeamID (aSelectedNode.Parent);

						// go over all possible ranks
						int iTotalNumberOfTeams = Math.Min (m_aGame.NumberOfTeams + 1, m_aGame.NumberOfPlayers);
						for (int iTeamID = 0; iTeamID < iTotalNumberOfTeams; iTeamID++)
							if (iTeamID != iCurrentTeamID) 
							{
								MenuItem aMenuItem = null;
								if (iTeamID == m_aGame.NumberOfTeams)
									aMenuItem = new MenuItem ("Move " + aSelectedNode.Text + " to team " + (iTeamID + 1) + " (new team)");
								else
									aMenuItem = new MenuItem ("Move " + aSelectedNode.Text + " to team " + (iTeamID + 1));
								cmTeamRanking.MenuItems.Add (aMenuItem);
								aMenuItem.Click += new EventHandler (aPlayerToTeam_Click);
							}
					}
				}					
			}
		}

		/// <summary>
		/// Handles a click on the "Move 'player' to team 'no'" context menu item.
		/// </summary>
		/// <param name="sender">Control element that sends the event.</param>
		/// <param name="e">Event parameter.</param>
		private void aPlayerToTeam_Click (object sender, EventArgs e)
		{
			MenuItem aSelectedMenuItem = (MenuItem) sender;
			string [] szTmp  = aSelectedMenuItem.Text.Split (' ');
			string szPlayer = szTmp [1];
			int iTeamID = Convert.ToInt32 (szTmp [4]) - 1;

			// find the source and target node
			TreeNode aSourceNode = null;
			TreeNode aTargetNode = null;
			for (int iRankIdx = 0; iRankIdx < tvTeamRanking.Nodes.Count; iRankIdx++)
			{
				TreeNode aCurrentRankNode = tvTeamRanking.Nodes [iRankIdx];
				for (int iTeamIdx = 0; iTeamIdx < aCurrentRankNode.Nodes.Count; iTeamIdx++) 
				{
					TreeNode aCurrentTeamNode = aCurrentRankNode.Nodes [iTeamIdx];
					if (GetTeamID (aCurrentTeamNode) == iTeamID)
						aTargetNode = aCurrentTeamNode;
					for (int iPlayerIdx = 0; iPlayerIdx < aCurrentTeamNode.Nodes.Count; iPlayerIdx++)
						if (GetPlayerName (aCurrentTeamNode.Nodes [iPlayerIdx]).CompareTo (szPlayer) == 0)
							aSourceNode = aCurrentTeamNode.Nodes [iPlayerIdx];
				}
			}
			Debug.Assert (aSourceNode != null, "Source node not found.");

			// remove the player node from the team node it was in
			TreeNode aSourceTeamNode = aSourceNode.Parent;
			aSourceTeamNode.Nodes.Remove (aSourceNode);

			//////////////////////////////////////////////////////////////////
			// remove the team if there are no more players left in it
			if (aSourceTeamNode.Nodes.Count == 0) 
			{
				TreeNode aSourceRankNode = aSourceTeamNode.Parent;
				aSourceRankNode.Nodes.Remove (aSourceTeamNode);

				// remove the rank if there are no more teams at it
				if (aSourceRankNode.Nodes.Count == 0)
					tvTeamRanking.Nodes.Remove (aSourceRankNode);
			}

			///////////////////////////////////////////////////////////////////
			// add the player node to the new team node
			if (aTargetNode == null) 
			{
				// create a new team node
				TreeNode aNewRankNode = NewRankNode (m_aGame.NumberOfTeams);
				tvTeamRanking.Nodes.Add (aNewRankNode);
				aTargetNode = NewTeamNode (Convert.ToInt32 (szTmp [4]) - 1);
				aNewRankNode.Nodes.Add (aTargetNode);
			}

			aTargetNode.Nodes.Add (aSourceNode);

			///////////////////////////////////////////////////////////////////
			// take the new data from the treeview and synchronise with the game representation
			UpdateGameData ();
			UpdateTreeView ();

			// update the output panel
			UpdateOutputPanel ();
		}

		/// <summary>
		/// Handles a click on the "Move team 'team' to rank 'no'" context menu item.
		/// </summary>
		/// <param name="sender">Control element that sends the event.</param>
		/// <param name="e">Event parameter.</param>
		private void aTeamToRank_Click (object sender, EventArgs e)
		{
			MenuItem aSelectedMenuItem = (MenuItem) sender;
			string [] szTmp  = aSelectedMenuItem.Text.Split (' ');
			int iTeamID = Convert.ToInt32 (szTmp [2]) - 1;
			int iRank = Convert.ToInt32 (szTmp [5]) - 1;

			// find the source and target node
			TreeNode aSourceNode = null;
			TreeNode aTargetNode = null;
			for (int iRankIdx = 0; iRankIdx < tvTeamRanking.Nodes.Count; iRankIdx++)
			{
				TreeNode aCurrentRankNode = tvTeamRanking.Nodes [iRankIdx];
				if (iRank == GetRank (aCurrentRankNode))
					aTargetNode = aCurrentRankNode;

				for (int iTeamIdx = 0; iTeamIdx < aCurrentRankNode.Nodes.Count; iTeamIdx++) 
					if (GetTeamID (aCurrentRankNode.Nodes [iTeamIdx]) == iTeamID)
						aSourceNode = aCurrentRankNode.Nodes [iTeamIdx];
			}
			Debug.Assert (aSourceNode != null, "Source node not found.");

			// remove the player node from the team node it was in
			TreeNode aSourceRankNode = aSourceNode.Parent;
			aSourceRankNode.Nodes.Remove (aSourceNode);

			// remove the rank if there are no more teams at it
			if (aSourceRankNode.Nodes.Count == 0)
				tvTeamRanking.Nodes.Remove (aSourceRankNode);

			///////////////////////////////////////////////////////////////////
			// add the team node to the new rank node
			if (aTargetNode == null) 
			{
				// create a new team node
				aTargetNode = NewRankNode (iRank);
				tvTeamRanking.Nodes.Add (aTargetNode);
			}

			aTargetNode.Nodes.Add (aSourceNode);

			///////////////////////////////////////////////////////////////////
			// take the new data from the treeview and synchronise with the game representation
			UpdateGameData ();
			UpdateTreeView ();

			// update the output panel
			UpdateOutputPanel ();
		}

		/// <summary>
		/// Handles a change of any input parameter.
		/// </summary>
		/// <param name="sender">Control element that sends the event.</param>
		/// <param name="e">Event parameter.</param>
		private void MuSigma_Changed (object sender, EventArgs e)
		{
			// update the output panel
			if (m_bUpdateOutput)
				UpdateOutputPanel ();

			// done!
			return;
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MuSigma\Sampling\NormalSample.cs ===
/////////////////////////////////////////////////////////////////////////////////////////////
// NormalSample.cs		Sampling routines for normal deviates (using the Box-Muller formula)
//
// 2004 written by Ralf Herbrich
// Microsoft Research Ltd.
/////////////////////////////////////////////////////////////////////////////////////////////

using System;

namespace Sampling
{
	/// <summary>
	/// This class provides the functionality to generate a normally distributed random deviate.
	/// </summary>
	public class NormalSample
	{
		/// <summary>
		/// The mean of the normal deviate.
		/// </summary>
		double m_dMu;	
		/// <summary>
		/// The standard deviation of the normal deviate.
		/// </summary>	
		double m_dSigma;			
		/// <summary>
		/// Indicator whether or not the Box-Mueller formula has already pre-computed a sample.
		/// </summary>
		bool m_bBuffered;
		/// <summary>
		/// A standard normal deviate pre-domputed in the Box-Mueller formula.
		/// </summary>
		double m_dBuffer;
		/// <summary>
		/// A uniform random number generator (necessary in the Box-Mueller algorithm).
		/// </summary>
		UniformSample	m_aUniformSample;	

		/// <summary>
		/// Construcuts a random number generator to generate normal deviates with given mean and standard deviation.
		/// </summary>
		/// <param name="dMu">The mean of the normal deviates.</param>
		/// <param name="dSigma">The standard deviation of the normal deviates.</param>
		public NormalSample (double dMu, double dSigma)
		{
			// parameter check
			if (dSigma < 0.0)
				throw new Exception ("dSigma must be positive");

			// copy parameter
			m_dMu = dMu;
			m_dSigma = dSigma;
			m_bBuffered = false;
			m_aUniformSample = new UniformSample ();
		}

		/// <summary>
		/// Construcuts a random number generator to generate normal deviates with a given mean and unit standard deviation.
		/// </summary>
		/// <param name="dMu">The mean of the normal deviates.</param>
		public NormalSample (double dMu) : this (dMu, 1.0)
		{
		}

		/// <summary>
		/// Construcuts a random number generator to generate normal deviates with zero mean and unit standard deviation.
		/// </summary>
		public NormalSample () : this (0.0, 1.0)
		{
		}

		/// <summary>
		/// Computes a new normal deviate.
		/// </summary>
		/// <returns>The normal deviate.</returns>
		public double Next ()
		{
			return Sample () * m_dSigma + m_dMu;
		}

		/// <summary>
		/// Computes a new normal standard deviate with given mean and unit standard deviation. 
		/// </summary>
		/// <param name="dMu">The mean of the normal deviate.</param>
		/// <returns>The normal deviate.</returns>
		/// <remarks>This function temporarily overrides the values given in the constructor.</remarks>
		public double Next (double dMu)
		{
			return Sample () + dMu;
		}

		/// <summary>
		/// Computes a new normal standard deviate with given mean and standard deviation. 
		/// </summary>
		/// <param name="dMu">The mean of the normal deviate.</param>
		/// <param name="dSigma">The standard deviation of the normal deviate.</param>
		/// <returns>The normal deviate.</returns>
		/// <remarks>This function temporarily overrides the values given in the constructor.</remarks>
		public double Next (double dMu, double dSigma)
		{
			return Sample () * dSigma + dMu;
		}

		/// <summary>
		/// Computes a new normal deviate with the Box-Mueller formula and possibly fills the buffer.
		/// </summary>
		/// <returns>A normal deviate.</returns>
		protected double Sample ()
		{
			double dRandomSample, dU, dV;

			if (m_bBuffered == false) 
			{
				// sample two non-zero uniforms
				do 	
				{
					dU = m_aUniformSample.Next ();
					dV = m_aUniformSample.Next ();
				} while (dU == 0.0 || dV == 0.0);

				// fill the buffer and deliver the remaining number
				dRandomSample = Math.Sqrt (-2.0 * Math.Log (dU));
				m_dBuffer = dRandomSample * Math.Sin (2.0 * Math.PI * dV);
				m_bBuffered = true;
				dRandomSample = dRandomSample * Math.Cos (2.0 * Math.PI * dV);
			} 
			else 
			{
				m_bBuffered = false;
				dRandomSample = m_dBuffer;
			}
			
			return (dRandomSample);
		}

		/// <summary>
		/// The mean of the normal deviate.
		/// </summary>
		public double Mu 
		{
			get 
			{
				return m_dMu;
			}
		}

		/// <summary>
		/// The standard deviation of the normal deviate.
		/// </summary>
		public double Sigma 
		{
			get 
			{
				return m_dSigma;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MuSigma\Sampling\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("Sampling")]
[assembly: AssemblyDescription("A light-weight library of sampling routines for various distributions.")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft Research Ltd.")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("2004 (c) Microsoft Research Ltd.")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MuSigma\Sampling\MultiNomialSample.cs ===
/////////////////////////////////////////////////////////////////////////////////////////////
// MultiNomialSample.cs		Sampling routines for multinomial deviates 
//
// 2004 written by Ralf Herbrich
// Microsoft Research Ltd.
/////////////////////////////////////////////////////////////////////////////////////////////

using System;
using System.Diagnostics;

namespace Sampling
{
	/// <summary>
	/// This class provides the functionality to generate a multinomial deviate.
	/// </summary>
	public class MultiNomialSample
	{
		/// <summary>
		/// Number of items from which to generate a random index.
		/// </summary>
		long m_lNoItems;			
		/// <summary>
		/// The probability of each item.
		/// </summary>
		double [] m_dProbability;		
		/// <summary>
		/// A random number generator for uniformly distributed deviates.
		/// </summary>
		UniformSample m_aUniformSample;	

		/// <summary>
		/// Construcuts a random number generator which gives multinomial deviates with equal probability.
		/// </summary>
		/// <param name="lNoItems">Number of items.</param>
		public MultiNomialSample (long lNoItems)
		{
			// parameter checks
			if (lNoItems <= 0)
				throw new Exception ("Number of items must be positive.");

			// copy parameters
			m_lNoItems = lNoItems;
			m_dProbability = null;
			m_aUniformSample = new UniformSample ((double) m_lNoItems);
		}

		/// <summary>
		/// Construcuts a random number generator which gives multinomial deviates with a specified probability.
		/// </summary>
		/// <param name="dProbability">A vector of probabilities.</param>
		/// <remarks>No test are made whether or not the parameter is a valid distribuion!</remarks>
		public MultiNomialSample (double [] dProbability)
		{
			m_lNoItems = dProbability.Length;
			m_dProbability = dProbability;
			m_aUniformSample = new UniformSample ((double) m_lNoItems);
		}

		/// <summary>
		/// Samples a new zero-based random index.
		/// </summary>
		/// <returns>A random index in the zero-based range specified in the constructor.</returns>
		public long Next ()
		{
			long lSample = 0; 

			if (m_dProbability == null)
			{
				do 
				{
					lSample = (long) (Math.Floor (m_aUniformSample.Next ()));
				} while (lSample == m_lNoItems);
			} 
			else
			{
				// TODO: Implement the sampling code for the mulit-nomial probability distribution.
				Debug.Assert (false, "Not yet implemented.");
			}

			return lSample;
		}

		/// <summary>
		/// Samples a new zero-based index from in a specified range. 
		/// </summary>
		/// <param name="lNoItems">Number of items.</param>
		/// <returns>A random zero based index.</returns>
		/// <remarks>This method temporarily overrides the settings in the constructor. Each index 
		/// has the same probability.</remarks>
		public long Next (long lNoItems)
		{
			long lSample; 
			do 
			{
				lSample = (long) (Math.Floor (m_aUniformSample.Next ()/(double) m_lNoItems * lNoItems));
			} while (lSample == lNoItems);
			return lSample;
		}

		/// <summary>
		/// The number of items from which to sample a random zero-based index.
		/// </summary>
		public long NumberOfItems 
		{
			get 
			{
				return m_lNoItems;
			}
		}

		/// <summary>
		/// The probability vector for each zero-based index.
		/// </summary>
		/// <remarks>No checks are made if the probability vector is valid (sums up to one and is only positive).</remarks>
		public double [] Probability
		{
			get 
			{
				return m_dProbability;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MuSigma\Sampling\UniformSample.cs ===
/////////////////////////////////////////////////////////////////////////////////////////////
// UniformSample.cs		Sampling routines for uniform deviates (using the CLR functions)
//
// 2004 written by Ralf Herbrich
// Microsoft Research Ltd.
/////////////////////////////////////////////////////////////////////////////////////////////

using System;

namespace Sampling
{
	/// <summary>
	/// This class provides the functionality to generate a uniformly distributed random deviate.
	/// </summary>
	public class UniformSample
	{
		/// <summary>
		/// Samllest value of the uniform deviate.
		/// </summary>
		double	m_dMin;		
		/// <summary>
		/// The range of the uniform deviate.
		/// </summary>
		double	m_dScale;	
		/// <summary>
		/// The random number generator (taken from the CLR) which actually generates the samples.
		/// </summary>
		Random	m_aRandom;

		/// <summary>
		/// Construcuts a random number generator to generate uniform deviates between two bounds.
		/// </summary>
		/// <param name="dMin">Lower bound of the uniform deviate.</param>
		/// <param name="dMax">Upper bound of the uniform deviate.</param>
		public UniformSample (double dMin, double dMax)
		{
			// parameter check
			if (dMin > dMax)
				throw new Exception ("Lower bound must be smaller than upper bound.");

			// parameter copying
			m_dMin = dMin;
			m_dScale = dMax - dMin;

			// intialise the random number generator
			m_aRandom = new Random ();
		}

		/// <summary>
		/// Construcuts a random number generator to generate uniform deviates between 0 and an upper bound.
		/// </summary>
		/// <param name="dMax">Upper bound of the uniform deviate.</param>
		public UniformSample (double dMax) : this (0.0, dMax)
		{
		}

		/// <summary>
		/// Construcuts the random number generator to generate uniform deviates between 0 and 1.
		/// </summary>
		public UniformSample () : this (0.0, 1.0)
		{
		}

		/// <summary>
		/// Computes a new uniform deviate between the pre-defined bounds.
		/// </summary>
		/// <returns>The uniform standard deviate.</returns>
		public double Next ()
		{
			return Sample () * m_dScale + m_dMin;;
		}

		/// <summary>
		/// Computes a new uniform deviate between 0 and an upper bound.
		/// </summary>
		/// <param name="dMax">The upper bound of the uniform standard deviate.</param>
		/// <returns>The uniform deviate.</returns>
		/// <remarks>This method temporariliy overrides the values given in the constructor.</remarks>
		public double Next (double dMax)
		{
			return Sample () * dMax;
		}

		/// <summary>
		/// Computes a new uniform deviate between two bounds. 
		/// </summary>
		/// <param name="dMin">The lower bound of the uniform standard deviate.</param>
		/// <param name="dMax">The upper bound of the uniform standard deviate.</param>
		/// <returns>The uniform deviate.</returns>
		/// <remarks>This method temporariliy overrides the values of the constructor.</remarks>
		public double Next (double dMin, double dMax)
		{
			// parameter check
			if (dMin > dMax)
				throw new Exception ("Lower bound must be smaller than upper bound.");

			// compute!
			return Sample () * (dMax - dMin) + dMin;
		}

		/// <summary>
		/// Computes a new uniform deviate between 0 and 1.
		/// </summary>
		/// <returns>The uniform deviate.</returns>
		protected double Sample () 
		{
			return (m_aRandom.NextDouble ());
		}

		/// <summary>
		/// The smallest value of the uniform deviate.
		/// </summary>
		public double LowerBound 
		{
			get 
			{
				return m_dMin;
			}
		}

		/// <summary>
		/// The largest value of the uniform deviate.
		/// </summary>
		public double UpperBound
		{
			get 
			{
				return m_dMin + m_dScale;
			}
		}

		/// <summary>
		/// The range of the uniform deviate.
		/// </summary>
		public double Range
		{
			get 
			{
				return m_dScale;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MuSigma\TestSuite\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MuSigma\TestSuite\SQLImportDialog.cs ===
/////////////////////////////////////////////////////////////////////////////////////////////
// SQLImportData.cs		Dialog window for the SQL parameters.
//
// 2004 written by Ralf Herbrich
// Microsoft Research Ltd.
/////////////////////////////////////////////////////////////////////////////////////////////

using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;

namespace TestSuite
{
	/// <summary>
	/// A class that represents a dialog form for obtaining SQL import parameters such as the server name, the database name
	/// and HALO 2 specific information such at the hopper and variant types.
	/// </summary>
	public class SQLImportDialog : System.Windows.Forms.Form
	{
		private System.Windows.Forms.Label label2;
		private System.Windows.Forms.ComboBox cbGameHopper;
		private System.Windows.Forms.Label label3;
		private System.Windows.Forms.ComboBox cbGameVariant;
		private System.Windows.Forms.Label label4;
		private System.Windows.Forms.Button bntOK;
		private System.Windows.Forms.Button btnCancel;
		private System.Windows.Forms.ComboBox cbMap;
		private System.Windows.Forms.Label label5;
		private System.Windows.Forms.TextBox txtSQLServerName;
		private System.Windows.Forms.Label label6;
		private System.Windows.Forms.TextBox txtDatabaseName;
		private System.Windows.Forms.GroupBox groupBox1;
		private System.Windows.Forms.Label label1;
		private System.Windows.Forms.GroupBox groupBox2;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		/// <summary>
		/// A variable sized string array of game hopper names.
		/// </summary>
		string [] m_szGameHoppers = {"Arranged Games", "Free For All", "Small Teams", "Large Teams", 
									 "1 vs. 1", "Team vs. Team", "Unranked Large Teams", "Unranked Small Teams",
									 "Multi Team", "Hopper 14"};
		/// <summary>
		/// A variable sized list of database indicies representing these hoppers.
		/// </summary>
		int [] m_iGameHoppers = {0, 1, 2, 3, 
								 5, 6, 7, 8, 
								 9, 14};

		/// <summary>
		/// A variable sized string array of game variant names.
		/// </summary>
		string [] m_szGameVariants = {"CTF", "Slayer", "Assault", "Variant 4"};
		/// <summary>
		/// A variable sized list of database indicies representing these variants.
		/// </summary>
		int [] m_iGameVariants = {1, 2, 9, 4};
		
		/// <summary>
		/// A variable sized string array of game map names.
		/// </summary>
		string [] m_szGameMaps = {"Ivory Tower", "Midship", "Zanzibar", "Waterworks", "Lockout"};
		/// <summary>
		/// A variable sized list of database indicies representing these game maps.
		/// </summary>
		int [] m_iGameMaps = {10, 20, 30, 40, 50};

		/// <summary>
		/// Constructs an instance of a dialog for importing data from a SQL database.
		/// </summary>
		public SQLImportDialog()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			/////////////////////////////////////////////////////////////
			// populate the game hopper checkbox
			cbGameHopper.Items.Clear ();
			cbGameHopper.Items.Add ("Any hopper");
			cbGameHopper.Items.AddRange (m_szGameHoppers);
			cbGameHopper.Text = (string) cbGameHopper.Items [0];

			/////////////////////////////////////////////////////////////
			// populate the game variants checkbox
			cbGameVariant.Items.Clear ();
			cbGameVariant.Items.Add ("Any variant");
			cbGameVariant.Items.AddRange (m_szGameVariants);
			cbGameVariant.Text = (string) cbGameVariant.Items [0];

			/////////////////////////////////////////////////////////////
			// populate the game maps checkbox
			cbMap.Items.Clear ();
			cbMap.Items.Add ("Any map");
			cbMap.Items.AddRange (m_szGameMaps);
			cbMap.Text = (string) cbMap.Items [0];
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(SQLImportDialog));
			this.cbGameHopper = new System.Windows.Forms.ComboBox();
			this.label2 = new System.Windows.Forms.Label();
			this.label3 = new System.Windows.Forms.Label();
			this.cbGameVariant = new System.Windows.Forms.ComboBox();
			this.label4 = new System.Windows.Forms.Label();
			this.cbMap = new System.Windows.Forms.ComboBox();
			this.bntOK = new System.Windows.Forms.Button();
			this.btnCancel = new System.Windows.Forms.Button();
			this.label5 = new System.Windows.Forms.Label();
			this.txtSQLServerName = new System.Windows.Forms.TextBox();
			this.txtDatabaseName = new System.Windows.Forms.TextBox();
			this.label6 = new System.Windows.Forms.Label();
			this.groupBox1 = new System.Windows.Forms.GroupBox();
			this.label1 = new System.Windows.Forms.Label();
			this.groupBox2 = new System.Windows.Forms.GroupBox();
			this.groupBox1.SuspendLayout();
			this.groupBox2.SuspendLayout();
			this.SuspendLayout();
			// 
			// cbGameHopper
			// 
			this.cbGameHopper.Location = new System.Drawing.Point(120, 24);
			this.cbGameHopper.Name = "cbGameHopper";
			this.cbGameHopper.Size = new System.Drawing.Size(121, 21);
			this.cbGameHopper.TabIndex = 2;
			this.cbGameHopper.Text = "Any";
			// 
			// label2
			// 
			this.label2.Location = new System.Drawing.Point(8, 24);
			this.label2.Name = "label2";
			this.label2.TabIndex = 2;
			this.label2.Text = "Game Hopper";
			this.label2.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
			// 
			// label3
			// 
			this.label3.Location = new System.Drawing.Point(8, 56);
			this.label3.Name = "label3";
			this.label3.TabIndex = 4;
			this.label3.Text = "Game Variant";
			this.label3.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
			// 
			// cbGameVariant
			// 
			this.cbGameVariant.Location = new System.Drawing.Point(120, 56);
			this.cbGameVariant.Name = "cbGameVariant";
			this.cbGameVariant.Size = new System.Drawing.Size(121, 21);
			this.cbGameVariant.TabIndex = 3;
			this.cbGameVariant.Text = "Any";
			// 
			// label4
			// 
			this.label4.Location = new System.Drawing.Point(8, 88);
			this.label4.Name = "label4";
			this.label4.TabIndex = 6;
			this.label4.Text = "Map";
			this.label4.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
			// 
			// cbMap
			// 
			this.cbMap.Location = new System.Drawing.Point(120, 88);
			this.cbMap.Name = "cbMap";
			this.cbMap.Size = new System.Drawing.Size(121, 21);
			this.cbMap.TabIndex = 4;
			this.cbMap.Text = "Any";
			// 
			// bntOK
			// 
			this.bntOK.DialogResult = System.Windows.Forms.DialogResult.OK;
			this.bntOK.Location = new System.Drawing.Point(40, 304);
			this.bntOK.Name = "bntOK";
			this.bntOK.Size = new System.Drawing.Size(88, 32);
			this.bntOK.TabIndex = 0;
			this.bntOK.Text = "OK";
			// 
			// btnCancel
			// 
			this.btnCancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
			this.btnCancel.Location = new System.Drawing.Point(168, 304);
			this.btnCancel.Name = "btnCancel";
			this.btnCancel.Size = new System.Drawing.Size(88, 32);
			this.btnCancel.TabIndex = 1;
			this.btnCancel.Text = "Cancel";
			// 
			// label5
			// 
			this.label5.Location = new System.Drawing.Point(16, 24);
			this.label5.Name = "label5";
			this.label5.TabIndex = 7;
			this.label5.Text = "SQL Server";
			this.label5.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
			// 
			// txtSQLServerName
			// 
			this.txtSQLServerName.Location = new System.Drawing.Point(128, 24);
			this.txtSQLServerName.Name = "txtSQLServerName";
			this.txtSQLServerName.Size = new System.Drawing.Size(112, 20);
			this.txtSQLServerName.TabIndex = 8;
			this.txtSQLServerName.Text = "msrc-mlpsql";
			// 
			// txtDatabaseName
			// 
			this.txtDatabaseName.Location = new System.Drawing.Point(128, 56);
			this.txtDatabaseName.Name = "txtDatabaseName";
			this.txtDatabaseName.Size = new System.Drawing.Size(112, 20);
			this.txtDatabaseName.TabIndex = 10;
			this.txtDatabaseName.Text = "Halo2Beta";
			// 
			// label6
			// 
			this.label6.Location = new System.Drawing.Point(16, 56);
			this.label6.Name = "label6";
			this.label6.TabIndex = 9;
			this.label6.Text = "Database";
			this.label6.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
			// 
			// groupBox1
			// 
			this.groupBox1.Controls.Add(this.txtDatabaseName);
			this.groupBox1.Controls.Add(this.label6);
			this.groupBox1.Controls.Add(this.label5);
			this.groupBox1.Controls.Add(this.txtSQLServerName);
			this.groupBox1.Location = new System.Drawing.Point(24, 56);
			this.groupBox1.Name = "groupBox1";
			this.groupBox1.Size = new System.Drawing.Size(248, 88);
			this.groupBox1.TabIndex = 11;
			this.groupBox1.TabStop = false;
			this.groupBox1.Text = "SQL Server Information";
			// 
			// label1
			// 
			this.label1.Font = new System.Drawing.Font("Microsoft Sans Serif", 14F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.label1.Location = new System.Drawing.Point(64, 16);
			this.label1.Name = "label1";
			this.label1.Size = new System.Drawing.Size(168, 24);
			this.label1.TabIndex = 0;
			this.label1.Text = "Import Parameters";
			this.label1.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
			// 
			// groupBox2
			// 
			this.groupBox2.Controls.Add(this.cbGameHopper);
			this.groupBox2.Controls.Add(this.label2);
			this.groupBox2.Controls.Add(this.label3);
			this.groupBox2.Controls.Add(this.cbGameVariant);
			this.groupBox2.Controls.Add(this.label4);
			this.groupBox2.Controls.Add(this.cbMap);
			this.groupBox2.Location = new System.Drawing.Point(24, 168);
			this.groupBox2.Name = "groupBox2";
			this.groupBox2.Size = new System.Drawing.Size(248, 120);
			this.groupBox2.TabIndex = 12;
			this.groupBox2.TabStop = false;
			this.groupBox2.Text = "Game Type Filters";
			// 
			// SQLImportDialog
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(298, 360);
			this.Controls.Add(this.groupBox2);
			this.Controls.Add(this.groupBox1);
			this.Controls.Add(this.btnCancel);
			this.Controls.Add(this.bntOK);
			this.Controls.Add(this.label1);
			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
			this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
			this.KeyPreview = true;
			this.MaximizeBox = false;
			this.Name = "SQLImportDialog";
			this.ShowInTaskbar = false;
			this.Text = "SQL Import Dialog";
			this.groupBox1.ResumeLayout(false);
			this.groupBox2.ResumeLayout(false);
			this.ResumeLayout(false);

		}
		#endregion

		/// <summary>
		/// The SQL filter string corresponding to the settings of the dialog box.
		/// </summary>
		public string SQLFilterString 
		{
			get 
			{
				string szSQLFilterString = "";

				// game hopper
				if (cbGameHopper.SelectedIndex > 0)
					szSQLFilterString += "game_hopper = " + m_iGameHoppers [cbGameHopper.SelectedIndex - 1].ToString ();

				// game variants
				if (cbGameVariant.SelectedIndex > 0) 
				{
					if (szSQLFilterString.Length > 0)
						szSQLFilterString += " and ";
					szSQLFilterString += "game_variant = " + m_iGameVariants [cbGameVariant.SelectedIndex - 1].ToString ();
				}

				// game maps
				if (cbMap.SelectedIndex > 0) 
				{
					if (szSQLFilterString.Length > 0)
						szSQLFilterString += " and ";
					szSQLFilterString += "game_map = " + m_iGameMaps [cbMap.SelectedIndex - 1].ToString ();
				}

				// possibly add the keyword
				if (szSQLFilterString.Length > 0)
					szSQLFilterString = "where " + szSQLFilterString;

				return szSQLFilterString;
			}
		}

		/// <summary>
		/// The HALO 2 internal ID of the currently selected hopper (or -1 if no hopper is selected).
		/// </summary>
		public int CurrentHopperID
		{
			get 
			{
				if (cbGameHopper.SelectedIndex > 0)
					return m_iGameHoppers [cbGameHopper.SelectedIndex - 1];
				else
					return -1;
			}
		}

		/// <summary>
		/// The HALO 2 internal ID of the currently selected map (or -1 if no map is selected).
		/// </summary>
		public int CurrentMapID
		{
			get 
			{
				if (cbMap.SelectedIndex > 0)
					return m_iGameMaps [cbMap.SelectedIndex - 1];
				else
					return -1;
			}
		}

		/// <summary>
		/// The HALO 2 internal ID of the currently selected variant (or -1 if no variant is selected).
		/// </summary>
		public int CurrentVariantID
		{
			get 
			{
				if (cbGameVariant.SelectedIndex > 0)
					return m_iGameVariants [cbGameVariant.SelectedIndex - 1];
				else
					return -1;
			}
		}

		/// <summary>
		/// The name of the SQL server as currently entered.
		/// </summary>
		public string SQLServerName 
		{
			get 
			{
				return txtSQLServerName.Text;
			}
			set 
			{
				txtSQLServerName.Text = value;
			}
		}

		/// <summary>
		/// The name of the database as currently entered.
		/// </summary>
		public string DatabaseName
		{
			get 
			{
				return txtDatabaseName.Text;
			}
			set 
			{
				txtDatabaseName.Text = value;
			}
		}

		/// <summary>
		/// Gets the name of a map for a given map ID.
		/// </summary>
		/// <param name="iMapID">The HALO 2 internal map ID.</param>
		/// <returns>The map name or null if the map ID does not exist.</returns>
		public string GetMapName (int iMapID)
		{
			// linear search through all possible game maps
			for (int i = 0; i < m_iGameMaps.Length; i++)
				if (iMapID == m_iGameMaps [i])
					return m_szGameMaps [i];

			return null;
		}

		/// <summary>
		/// Gets the name of a variant for a given variant ID.
		/// </summary>
		/// <param name="iVariantID">The HALO 2 internal variant ID.</param>
		/// <returns>The variant name or null if the variant ID does not exist.</returns>
		public string GetVariantName (int iVariantID)
		{
			// linear search through all possible game variant
			for (int i = 0; i < m_iGameVariants.Length; i++)
				if (iVariantID == m_iGameVariants [i])
					return m_szGameVariants [i];

			return null;
		}

		/// <summary>
		/// Gets the name of a hopper for a given hopper ID.
		/// </summary>
		/// <param name="iHopperID">The HALO 2 internal hopper ID.</param>
		/// <returns>The hopper name or null if the hopper ID does not exists.</returns>
		public string GetHopperName (int iHopperID)
		{
			// linear search through all possible game hoppers
			for (int i = 0; i < m_iGameHoppers.Length; i++)
				if (iHopperID == m_iGameHoppers [i])
					return m_szGameHoppers [i];

			return null;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MuSigma\TestSuite\PlotWindow.cs ===
/////////////////////////////////////////////////////////////////////////////////////////////
// PlotWindow.cs		Dialog window that shows a simple plot.
//
// 2004 written by Ralf Herbrich
// Microsoft Research Ltd.
/////////////////////////////////////////////////////////////////////////////////////////////

using System;
using System.Text;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using Microsoft.Office.Interop.Owc11;

namespace TestSuite
{
	/// <summary>
	/// A class that represents a window for plotting several one-dimensional functions. The class supports up to 256 different
	/// functions at any one time. Functions will be re-sampled before drawn to improve speed. The window also has a menu to configure 
	/// the plot once it is drawn on screen. This class makes heavy use of the Office 11 Chart COM ActiveX component.
	/// </summary>
	public class PlotWindow : System.Windows.Forms.Form
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;			

		/// <summary>
		/// A variable-sized array of literal strings for the X data of each function.
		/// </summary>
		private ArrayList m_szDataX;
		/// <summary>
		/// A variable-sized array of literal strings for the Y data of each function.
		/// </summary>
		private ArrayList m_szDataY;
		/// <summary>
		/// A variable-sized array of literal strings for the error bar data of each function.
		/// </summary>
		private ArrayList m_szErrorBar;
		/// <summary>
		/// A variable-sized array of literal strings for the names of each function.
		/// </summary>
		private ArrayList m_szDataNames;

		private System.Windows.Forms.MainMenu mainMenu1;
		private System.Windows.Forms.MenuItem menuItem1;
		private System.Windows.Forms.MenuItem cbLegend;
		private System.Windows.Forms.MenuItem cbYAxis;
		private System.Windows.Forms.MenuItem menuItem4;
		private System.Windows.Forms.MenuItem menuItem5;
		private System.Windows.Forms.MenuItem cbXAxis;
		private AxMicrosoft.Office.Interop.Owc11.AxChartSpace axChartSpace;		// the names of the data series
		private ChChart   m_aChart;

		/// <summary>
		/// Constructs a new instance of a plot window. This will make the window visible.
		/// </summary>
		public PlotWindow()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			// initialises the data arrays			
			m_aChart = this.axChartSpace.Charts.Add (0);
			m_szDataX = new ArrayList ();
			m_szDataY = new ArrayList ();
			m_szErrorBar = new ArrayList ();
			m_szDataNames = new ArrayList ();
			this.Visible = true;
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(PlotWindow));
			this.mainMenu1 = new System.Windows.Forms.MainMenu();
			this.menuItem1 = new System.Windows.Forms.MenuItem();
			this.cbXAxis = new System.Windows.Forms.MenuItem();
			this.menuItem4 = new System.Windows.Forms.MenuItem();
			this.cbYAxis = new System.Windows.Forms.MenuItem();
			this.menuItem5 = new System.Windows.Forms.MenuItem();
			this.cbLegend = new System.Windows.Forms.MenuItem();
			this.axChartSpace = new AxMicrosoft.Office.Interop.Owc11.AxChartSpace();
			((System.ComponentModel.ISupportInitialize)(this.axChartSpace)).BeginInit();
			this.SuspendLayout();
			// 
			// mainMenu1
			// 
			this.mainMenu1.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
																					  this.menuItem1});
			// 
			// menuItem1
			// 
			this.menuItem1.Index = 0;
			this.menuItem1.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
																					  this.cbXAxis,
																					  this.menuItem4,
																					  this.cbYAxis,
																					  this.menuItem5,
																					  this.cbLegend});
			this.menuItem1.Text = "&View";
			// 
			// cbXAxis
			// 
			this.cbXAxis.Checked = true;
			this.cbXAxis.Index = 0;
			this.cbXAxis.Text = "X";
			this.cbXAxis.Click += new System.EventHandler(this.cbXAxis_Click);
			// 
			// menuItem4
			// 
			this.menuItem4.Index = 1;
			this.menuItem4.Text = "-";
			// 
			// cbYAxis
			// 
			this.cbYAxis.Checked = true;
			this.cbYAxis.Index = 2;
			this.cbYAxis.Text = "Y";
			this.cbYAxis.Click += new System.EventHandler(this.cbYAxis_Click);
			// 
			// menuItem5
			// 
			this.menuItem5.Index = 3;
			this.menuItem5.Text = "-";
			// 
			// cbLegend
			// 
			this.cbLegend.Checked = true;
			this.cbLegend.Index = 4;
			this.cbLegend.Text = "&Legend";
			this.cbLegend.Click += new System.EventHandler(this.cbLegend_Click);
			// 
			// axChartSpace
			// 
			this.axChartSpace.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
				| System.Windows.Forms.AnchorStyles.Left) 
				| System.Windows.Forms.AnchorStyles.Right)));
			this.axChartSpace.DataSource = null;
			this.axChartSpace.Enabled = true;
			this.axChartSpace.Location = new System.Drawing.Point(8, 8);
			this.axChartSpace.Name = "axChartSpace";
			this.axChartSpace.OcxState = ((System.Windows.Forms.AxHost.State)(resources.GetObject("axChartSpace.OcxState")));
			this.axChartSpace.Size = new System.Drawing.Size(776, 504);
			this.axChartSpace.TabIndex = 0;
			// 
			// PlotWindow
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(792, 518);
			this.Controls.Add(this.axChartSpace);
			this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
			this.Menu = this.mainMenu1;
			this.Name = "PlotWindow";
			this.Text = "Plot Output";
			((System.ComponentModel.ISupportInitialize)(this.axChartSpace)).EndInit();
			this.ResumeLayout(false);

		}
		#endregion

		/// <summary>
		/// Adds one data series to the plot window.
		/// </summary>
		/// <param name="dDataX">The <c>x</c> values as a double array.</param>
		/// <param name="dDataY">The <c>y</c> values as a double array.</param>
		/// <param name="dErrorBar">The <c>errorBar</c> values as a double array.</param>
		/// <param name="szName">The name of the data series.</param>
		/// <returns>True, if the data was subsampled.</returns>
		/// <remarks>If the <c>dErrorBar</c> parameter is <c>null</c> then no error bars are added.</remarks>
		public bool AddData (double [] dDataX, double [] dDataY, double [] dErrorBar, string szName)
		{
			// check that the right sized arrays are passed
			if (dDataX.Length != dDataY.Length)
				throw new Exception ("dDataX and dDataY should be of equal length.");

			// add the name of the data series
			m_szDataNames.Add (szName);

			// possibly subsample the data
			const int iMaxLength = 2000;
			bool bSubsampled = (dDataX.Length > iMaxLength);

			// construct the series strings
			StringBuilder szX = new StringBuilder (iMaxLength * 10);
			StringBuilder szY = new StringBuilder (iMaxLength * 10);
			StringBuilder szErrorBar = new StringBuilder (iMaxLength * 10);

			// build the strings
			int iIndex;
			int iLength = (bSubsampled)?iMaxLength:dDataX.Length;
			for (int i = 0; i < iLength; i++) 
			{
				if (bSubsampled)
					iIndex = (i * dDataX.Length) / iMaxLength;
				else
					iIndex = i;
				szX.AppendFormat ("{0,9},", dDataX [iIndex]);
				szY.AppendFormat ("{0,9},", dDataY [iIndex]);
				if (dErrorBar != null)
					szErrorBar.AppendFormat ("{0,9}\t", dErrorBar [iIndex]);
			}

			// add the strings to the series
			m_szDataX.Add (szX.ToString ());
			m_szDataY.Add (szY.ToString ());
			m_szErrorBar.Add ((dErrorBar == null)?null:szErrorBar.ToString ());

			// return whether or not the series was subsampled
			return bSubsampled;
		}

		/// <summary>
		/// Adds one data series to the plot window.
		/// </summary>
		/// <param name="dDataX">The <c>x</c> values as a double array.</param>
		/// <param name="dDataY">The <c>y</c> values as a double array.</param>
		/// <param name="szName">The name of the data series.</param>
		/// <returns>True, if the data was subsampled.</returns>
		public bool AddData (double [] dDataX, double [] dDataY, string szName)
		{
			return AddData (dDataX, dDataY, null, szName);
		}

		/// <summary>
		/// Adds one data series.
		/// </summary>
		/// <param name="dDataX">The <c>x</c> values as a double array.</param>
		/// <param name="dDataY">The <c>y</c> values as a double array.</param>
		/// <returns>True, if the data was subsampled.</returns>
		/// <remarks>The series will be assigned a standard name 'Series <c>n</c>' where <c>n</c> is the internal 
		/// zero-based index of the series.</remarks>
		public bool AddData (double [] dDataX, double [] dDataY)
		{
			return AddData (dDataX, dDataY, "Series " + m_szDataNames.Count.ToString ());
		}

		/// <summary>
		/// Clears all data series.
		/// </summary>
		public void Clear ()
		{
			m_szDataX.Clear ();
			m_szDataY.Clear ();
			m_szErrorBar.Clear ();
			m_szDataNames.Clear ();
		}

		/// <summary>
		/// Title of the x-axis.
		/// </summary>
		public string XAxisTitle 
		{
			get 
			{
				return cbXAxis.Text;
			}
			set 
			{
				cbXAxis.Text = value;
			}
		}

		/// <summary>
		/// Title of the y-axis.
		/// </summary>
		public string YAxisTitle 
		{
			get 
			{
				return cbYAxis.Text;
			}
			set 
			{
				cbYAxis.Text = value;
			}
		}

		/// <summary>
		/// Plot has a legend?
		/// </summary>
		public bool Legend
		{
			get 
			{
				return cbLegend.Checked;
			}
			set 
			{
				cbLegend.Checked = value;
			}
		}

		/// <summary>
		/// Plot has a Y axis title?
		/// </summary>
		public bool YAxis
		{
			get 
			{
				return cbYAxis.Checked;
			}
			set 
			{
				cbYAxis.Checked = value;
			}
		}

		/// <summary>
		/// Plot has an X axis title?
		/// </summary>
		public bool XAxis
		{
			get 
			{
				return cbXAxis.Checked;
			}
			set 
			{
				cbXAxis.Checked = value;
			}
		}

		/// <summary>
		/// The chart space on which is drawn.
		/// </summary>
		public AxMicrosoft.Office.Interop.Owc11.AxChartSpace ChartSpace
		{
			get 
			{
				return this.axChartSpace;
			}
		}

		/// <summary>
		/// Updates the chart on the plot. No series will be displayed until this method is called.
		/// </summary>
		public void UpdateChart ()
		{
			// delete the current chart
			this.axChartSpace.Charts.Delete (0);

			m_aChart = this.axChartSpace.Charts.Add (0);
			for (int i = 0; i < m_szDataX.Count; i++) 
			{
				try 
				{
					// add the series to the chart space
					ChSeries aSeries = m_aChart.SeriesCollection.Add (i);
					aSeries.Type = ChartChartTypeEnum.chChartTypeScatterLine;
					aSeries.SetData (ChartDimensionsEnum.chDimSeriesNames, (int) ChartSpecialDataSourcesEnum.chDataLiteral, m_szDataNames [i]);
					aSeries.SetData (ChartDimensionsEnum.chDimXValues, (int) ChartSpecialDataSourcesEnum.chDataLiteral, m_szDataX [i]);
					aSeries.SetData (ChartDimensionsEnum.chDimYValues, (int) ChartSpecialDataSourcesEnum.chDataLiteral, m_szDataY [i]);

					// add error bars
					if (m_szErrorBar [i] != null) 
					{
						ChErrorBars aErrorBars = aSeries.ErrorBarsCollection.Add ();
						aErrorBars.SetData (ChartErrorBarCustomValuesEnum.chErrorBarMinusValues, (int) ChartSpecialDataSourcesEnum.chDataLiteral, m_szErrorBar [i]);
						aErrorBars.SetData (ChartErrorBarCustomValuesEnum.chErrorBarPlusValues, (int) ChartSpecialDataSourcesEnum.chDataLiteral, m_szErrorBar [i]);
					}
				}
				catch 
				{
					MessageBox.Show ("Too many series to plot. Please reduce the number.");
					i = m_szDataX.Count;
				}
			}

			// "nicify" the plot
			if (cbLegend.Checked) 
			{
				m_aChart.HasLegend = true;
				m_aChart.Legend.Position = ChartLegendPositionEnum.chLegendPositionRight;
			}
			if (cbXAxis.Checked) 
			{
				m_aChart.Axes [1].HasTitle = true;
				m_aChart.Axes [1].Title.Caption = cbXAxis.Text;
			}
			if (cbYAxis.Checked) 
			{
				m_aChart.Axes [0].HasTitle = true;
				m_aChart.Axes [0].Title.Caption = cbYAxis.Text;
			}
		}

		/// <summary>
		/// Handles a click on the "Legend" menu entry. This method redraws the plot.
		/// </summary>
		/// <param name="sender">Sender of the message.</param>
		/// <param name="e">Event arguments from the event handler.</param>
		private void cbLegend_Click(object sender, System.EventArgs e)
		{
			cbLegend.Checked = !cbLegend.Checked;
			UpdateChart ();
		}

		/// <summary>
		/// Handles a click on the "X Axis" menu entry. This method redraws the plot.
		/// </summary>
		/// <param name="sender">Sender of the message.</param>
		/// <param name="e">Event arguments from the event handler.</param>
		private void cbXAxis_Click(object sender, System.EventArgs e)
		{
			cbXAxis.Checked = !cbXAxis.Checked;
			UpdateChart ();
		}

		/// <summary>
		/// Handles a click on the "Y Axis" menu entry. This method redraws the plot.
		/// </summary>
		/// <param name="sender">Sender of the message.</param>
		/// <param name="e">Event arguments from the event handler.</param>
		private void cbYAxis_Click(object sender, System.EventArgs e)
		{
			cbYAxis.Checked = !cbYAxis.Checked;
			UpdateChart ();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\MuSigma\TestSuite\TestSuite.cs ===
/////////////////////////////////////////////////////////////////////////////////////////////
// TestSuite.cs		A test suite for the library calls.
//
// 2004 written y Ralf Herbrich
// Microsoft Research Ltd.
/////////////////////////////////////////////////////////////////////////////////////////////

using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Text;
using System.Reflection;
using System.Diagnostics;
using LinearAlgebra;
using Numerics;

namespace TestSuite
{
	/// <summary>
	/// An application which tests several project related packages such as linear algebra, numerics, etc. This application is mainly of use 
	/// during development but should also be used to check that the CLR supports all functionality required in the packages. Moreover,
	/// it allows to profile certain computationally intensive routines such as matrix inversion.
	/// </summary>
	public class TestSuite : System.Windows.Forms.Form
	{
		private System.Windows.Forms.TabControl tbMain;
		private System.Windows.Forms.Button btnQuit;
		private System.Windows.Forms.TabPage tbLinearAlgebra;
		private System.Windows.Forms.TabPage tbNumerics;
		private System.Windows.Forms.RichTextBox rtLinearAlgebra;
		private System.Windows.Forms.Button btnMatrix;
		private System.Windows.Forms.Button btnPhiFunction;
		private System.Windows.Forms.RichTextBox rtNumerics;
		private System.Windows.Forms.Button btnNFunction;
		private System.Windows.Forms.Button btnMATLAB;
		private System.Windows.Forms.TabPage tMuSigma;
		private System.Windows.Forms.Button btnIterationsAnalysis;
		private System.Windows.Forms.ProgressBar pbProcessing;
		private System.Windows.Forms.GroupBox groupBox1;
		private System.Windows.Forms.GroupBox groupBox2;
		private System.Windows.Forms.RadioButton rbCumulativeError;
		private System.Windows.Forms.RadioButton rbInstantError;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		/// <summary>
		/// Constructs a new test suite.
		/// </summary>
		public TestSuite ()
		{
			// Required for Windows Form Designer support
			InitializeComponent();

			// add a version number
			Version aVersion = typeof (TestSuite).Assembly.GetName ().Version;
			this.Text += " ( v" + aVersion.ToString () + ")";
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if (components != null) 
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.tbMain = new System.Windows.Forms.TabControl();
			this.tbLinearAlgebra = new System.Windows.Forms.TabPage();
			this.btnMatrix = new System.Windows.Forms.Button();
			this.rtLinearAlgebra = new System.Windows.Forms.RichTextBox();
			this.tbNumerics = new System.Windows.Forms.TabPage();
			this.btnMATLAB = new System.Windows.Forms.Button();
			this.btnNFunction = new System.Windows.Forms.Button();
			this.btnPhiFunction = new System.Windows.Forms.Button();
			this.rtNumerics = new System.Windows.Forms.RichTextBox();
			this.tMuSigma = new System.Windows.Forms.TabPage();
			this.pbProcessing = new System.Windows.Forms.ProgressBar();
			this.btnIterationsAnalysis = new System.Windows.Forms.Button();
			this.btnQuit = new System.Windows.Forms.Button();
			this.groupBox1 = new System.Windows.Forms.GroupBox();
			this.groupBox2 = new System.Windows.Forms.GroupBox();
			this.rbCumulativeError = new System.Windows.Forms.RadioButton();
			this.rbInstantError = new System.Windows.Forms.RadioButton();
			this.tbMain.SuspendLayout();
			this.tbLinearAlgebra.SuspendLayout();
			this.tbNumerics.SuspendLayout();
			this.tMuSigma.SuspendLayout();
			this.groupBox1.SuspendLayout();
			this.groupBox2.SuspendLayout();
			this.SuspendLayout();
			// 
			// tbMain
			// 
			this.tbMain.Controls.Add(this.tbLinearAlgebra);
			this.tbMain.Controls.Add(this.tbNumerics);
			this.tbMain.Controls.Add(this.tMuSigma);
			this.tbMain.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.tbMain.Location = new System.Drawing.Point(24, 16);
			this.tbMain.Name = "tbMain";
			this.tbMain.SelectedIndex = 0;
			this.tbMain.Size = new System.Drawing.Size(752, 448);
			this.tbMain.TabIndex = 0;
			// 
			// tbLinearAlgebra
			// 
			this.tbLinearAlgebra.Controls.Add(this.btnMatrix);
			this.tbLinearAlgebra.Controls.Add(this.rtLinearAlgebra);
			this.tbLinearAlgebra.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.tbLinearAlgebra.Location = new System.Drawing.Point(4, 22);
			this.tbLinearAlgebra.Name = "tbLinearAlgebra";
			this.tbLinearAlgebra.Size = new System.Drawing.Size(744, 422);
			this.tbLinearAlgebra.TabIndex = 0;
			this.tbLinearAlgebra.Text = "Linear Algebra";
			// 
			// btnMatrix
			// 
			this.btnMatrix.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.btnMatrix.Location = new System.Drawing.Point(16, 368);
			this.btnMatrix.Name = "btnMatrix";
			this.btnMatrix.Size = new System.Drawing.Size(120, 40);
			this.btnMatrix.TabIndex = 1;
			this.btnMatrix.Text = "Matrix Class";
			this.btnMatrix.Click += new System.EventHandler(this.btnMatrix_Click);
			// 
			// rtLinearAlgebra
			// 
			this.rtLinearAlgebra.Font = new System.Drawing.Font("Courier New", 9.75F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.rtLinearAlgebra.Location = new System.Drawing.Point(16, 8);
			this.rtLinearAlgebra.Name = "rtLinearAlgebra";
			this.rtLinearAlgebra.ReadOnly = true;
			this.rtLinearAlgebra.Size = new System.Drawing.Size(712, 352);
			this.rtLinearAlgebra.TabIndex = 0;
			this.rtLinearAlgebra.Text = "";
			// 
			// tbNumerics
			// 
			this.tbNumerics.Controls.Add(this.btnMATLAB);
			this.tbNumerics.Controls.Add(this.btnNFunction);
			this.tbNumerics.Controls.Add(this.btnPhiFunction);
			this.tbNumerics.Controls.Add(this.rtNumerics);
			this.tbNumerics.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.tbNumerics.Location = new System.Drawing.Point(4, 22);
			this.tbNumerics.Name = "tbNumerics";
			this.tbNumerics.Size = new System.Drawing.Size(744, 422);
			this.tbNumerics.TabIndex = 1;
			this.tbNumerics.Text = "Numerics";
			// 
			// btnMATLAB
			// 
			this.btnMATLAB.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.btnMATLAB.Location = new System.Drawing.Point(272, 368);
			this.btnMATLAB.Name = "btnMATLAB";
			this.btnMATLAB.Size = new System.Drawing.Size(120, 40);
			this.btnMATLAB.TabIndex = 5;
			this.btnMATLAB.Text = "MATLAB test";
			this.btnMATLAB.Click += new System.EventHandler(this.btnMATLAB_Click);
			// 
			// btnNFunction
			// 
			this.btnNFunction.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.btnNFunction.Location = new System.Drawing.Point(16, 368);
			this.btnNFunction.Name = "btnNFunction";
			this.btnNFunction.Size = new System.Drawing.Size(120, 40);
			this.btnNFunction.TabIndex = 4;
			this.btnNFunction.Text = "N Function";
			this.btnNFunction.Click += new System.EventHandler(this.btnNFunction_Click);
			// 
			// btnPhiFunction
			// 
			this.btnPhiFunction.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.btnPhiFunction.Location = new System.Drawing.Point(144, 368);
			this.btnPhiFunction.Name = "btnPhiFunction";
			this.btnPhiFunction.Size = new System.Drawing.Size(120, 40);
			this.btnPhiFunction.TabIndex = 3;
			this.btnPhiFunction.Text = "Phi Function";
			this.btnPhiFunction.Click += new System.EventHandler(this.btnPhiFunction_Click);
			// 
			// rtNumerics
			// 
			this.rtNumerics.Font = new System.Drawing.Font("Courier New", 9.75F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.rtNumerics.Location = new System.Drawing.Point(16, 8);
			this.rtNumerics.Name = "rtNumerics";
			this.rtNumerics.ReadOnly = true;
			this.rtNumerics.Size = new System.Drawing.Size(712, 352);
			this.rtNumerics.TabIndex = 2;
			this.rtNumerics.Text = "";
			// 
			// tMuSigma
			// 
			this.tMuSigma.Controls.Add(this.groupBox1);
			this.tMuSigma.Controls.Add(this.pbProcessing);
			this.tMuSigma.Location = new System.Drawing.Point(4, 22);
			this.tMuSigma.Name = "tMuSigma";
			this.tMuSigma.Size = new System.Drawing.Size(744, 422);
			this.tMuSigma.TabIndex = 2;
			this.tMuSigma.Text = "MuSigma";
			// 
			// pbProcessing
			// 
			this.pbProcessing.Location = new System.Drawing.Point(16, 8);
			this.pbProcessing.Name = "pbProcessing";
			this.pbProcessing.Size = new System.Drawing.Size(712, 16);
			this.pbProcessing.TabIndex = 7;
			this.pbProcessing.Visible = false;
			// 
			// btnIterationsAnalysis
			// 
			this.btnIterationsAnalysis.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.btnIterationsAnalysis.Location = new System.Drawing.Point(56, 128);
			this.btnIterationsAnalysis.Name = "btnIterationsAnalysis";
			this.btnIterationsAnalysis.Size = new System.Drawing.Size(120, 40);
			this.btnIterationsAnalysis.TabIndex = 6;
			this.btnIterationsAnalysis.Text = "Run ...";
			this.btnIterationsAnalysis.Click += new System.EventHandler(this.btnIterationsAnalysis_Click);
			// 
			// btnQuit
			// 
			this.btnQuit.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.btnQuit.Location = new System.Drawing.Point(672, 480);
			this.btnQuit.Name = "btnQuit";
			this.btnQuit.Size = new System.Drawing.Size(104, 32);
			this.btnQuit.TabIndex = 1;
			this.btnQuit.Text = "Quit";
			this.btnQuit.Click += new System.EventHandler(this.btnQuit_Click);
			// 
			// groupBox1
			// 
			this.groupBox1.Controls.Add(this.groupBox2);
			this.groupBox1.Controls.Add(this.btnIterationsAnalysis);
			this.groupBox1.Location = new System.Drawing.Point(16, 40);
			this.groupBox1.Name = "groupBox1";
			this.groupBox1.Size = new System.Drawing.Size(248, 184);
			this.groupBox1.TabIndex = 8;
			this.groupBox1.TabStop = false;
			this.groupBox1.Text = "Iterations Analysis";
			// 
			// groupBox2
			// 
			this.groupBox2.Controls.Add(this.rbInstantError);
			this.groupBox2.Controls.Add(this.rbCumulativeError);
			this.groupBox2.Location = new System.Drawing.Point(24, 24);
			this.groupBox2.Name = "groupBox2";
			this.groupBox2.Size = new System.Drawing.Size(192, 88);
			this.groupBox2.TabIndex = 7;
			this.groupBox2.TabStop = false;
			this.groupBox2.Text = "Summary ";
			// 
			// rbCumulativeError
			// 
			this.rbCumulativeError.Checked = true;
			this.rbCumulativeError.Location = new System.Drawing.Point(8, 16);
			this.rbCumulativeError.Name = "rbCumulativeError";
			this.rbCumulativeError.Size = new System.Drawing.Size(176, 24);
			this.rbCumulativeError.TabIndex = 0;
			this.rbCumulativeError.TabStop = true;
			this.rbCumulativeError.Text = "Cummulative Error";
			// 
			// rbInstantError
			// 
			this.rbInstantError.Location = new System.Drawing.Point(8, 48);
			this.rbInstantError.Name = "rbInstantError";
			this.rbInstantError.Size = new System.Drawing.Size(176, 24);
			this.rbInstantError.TabIndex = 1;
			this.rbInstantError.Text = "Instant Error";
			// 
			// TestSuite
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(8, 16);
			this.ClientSize = new System.Drawing.Size(800, 534);
			this.Controls.Add(this.btnQuit);
			this.Controls.Add(this.tbMain);
			this.Font = new System.Drawing.Font("Courier New", 10F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.Name = "TestSuite";
			this.Text = "Test Suite";
			this.tbMain.ResumeLayout(false);
			this.tbLinearAlgebra.ResumeLayout(false);
			this.tbNumerics.ResumeLayout(false);
			this.tMuSigma.ResumeLayout(false);
			this.groupBox1.ResumeLayout(false);
			this.groupBox2.ResumeLayout(false);
			this.ResumeLayout(false);

		}
		#endregion

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main() 
		{
			Application.Run(new TestSuite ());
		}

		/// <summary>
		/// Handles a click on the quite button.
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		private void btnQuit_Click(object sender, System.EventArgs e)
		{
			this.Close ();
		}

		/// <summary>
		/// Handles a click on the "Test Matrix Class" button.
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		private void btnMatrix_Click(object sender, System.EventArgs e)
		{
			TextWriter aOut = Console.Out;
			StringBuilder aOutput = new StringBuilder ();
			StringWriter aStringWriter = new StringWriter (aOutput);
			Console.SetOut (aStringWriter);
			Matrix.TestMatrixClass ();
			aStringWriter.Close ();
			rtLinearAlgebra.Text = aOutput.ToString ();
			Console.SetOut (aOut);
		}

		/// <summary>
		/// Handles a click on the "Test Phi Function" button.
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		private void btnPhiFunction_Click(object sender, System.EventArgs e)
		{
			TextWriter aOut = Console.Out;
			StringBuilder aOutput = new StringBuilder ();
			StringWriter aStringWriter = new StringWriter (aOutput);
			Console.SetOut (aStringWriter);
			GaussianApproximations.TestPhi ();
			aStringWriter.Close ();
			rtNumerics.Text = aOutput.ToString ();
			Console.SetOut (aOut);		
		}

		/// <summary>
		/// Handles a click on the "Test N Function" button.
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		private void btnNFunction_Click(object sender, System.EventArgs e)
		{		
			TextWriter aOut = Console.Out;
			StringBuilder aOutput = new StringBuilder ();
			StringWriter aStringWriter = new StringWriter (aOutput);
			Console.SetOut (aStringWriter);
			GaussianApproximations.TestN ();
			aStringWriter.Close ();
			rtNumerics.Text = aOutput.ToString ();
			Console.SetOut (aOut);		
		}

		/// <summary>
		/// Handles a click on the "Test MATLAB" button.
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		private void btnMATLAB_Click(object sender, System.EventArgs e)
		{
			GaussianApproximations.TestWithMatlab ();
			rtNumerics.Text = "Files written to the current directory. Please call MATLAB with\n\n" + 
					"\tload -ascii erfc.txt; clf; plot (erfc(:,1),erfc(:,2), 'b-');\n" + 
					"\tload -ascii erfcinv.txt; clf; plot (erfcinv(:,1),erfcinv(:,2), 'b-');\n" + 
					"\tload -ascii Phi.txt; clf; plot (Phi(:,1),Phi(:,2), 'b-');\n" + 
					"\tload -ascii PhiInv.txt; clf; plot (PhiInv(:,1),PhiInv(:,2), 'b-');\n" + 
					"\tload -ascii v.txt; clf; plot (v(:,1),v(:,2), 'b-');\n" + 
					"\tload -ascii w.txt; clf; plot (w(:,1),w(:,2), 'b-');\n" + 
					"\tload -ascii v0.txt; clf; plot (v0(:,1),v0(:,2), 'b-');\n" + 
					"\tload -ascii w0.txt; clf; plot (w0(:,1),w0(:,2), 'b-');\n" + 
					"\tload -ascii vApprox.txt; clf; plot (vApprox(:,1),vApprox(:,2), 'b-');\n";
		}

		/// <summary>
		/// Handles a click on the "Iterations Analysis" button.
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		private void btnIterationsAnalysis_Click(object sender, System.EventArgs e)
		{
			SQLImportDialog aSQLImportDialog = new SQLImportDialog ();

			if (aSQLImportDialog.ShowDialog () == DialogResult.OK) 
			{
				/////////////////////////////////////////////////////////////////////////////
				// get the number of available results
				/////////////////////////////////////////////////////////////////////////////

				// open the SQL connection
				SqlConnection aSQLConnection = new SqlConnection ("Initial Catalog = " + aSQLImportDialog.DatabaseName + "; Data Source = " + 
					aSQLImportDialog.SQLServerName + "; Integrated Security = SSPI");
				aSQLConnection.Open ();

				// get the number of results that match
				SqlCommand aResultsTableCommand = new 
					SqlCommand ("select tParameters.res_id,param_value from tParameters " +
								"join tResults on tResults.res_id = tParameters.res_id " +
								aSQLImportDialog.SQLFilterString + "and param_name = 'iterations'", aSQLConnection);
				SqlDataAdapter aResultsTableAdapter = new SqlDataAdapter (aResultsTableCommand);
				DataSet aResultsTable = new DataSet ();
				aResultsTableAdapter.Fill (aResultsTable);

				// close the SQL connection
				aSQLConnection.Close ();
				
				// if there are not enough results then do not do anything
				if (aResultsTable.Tables [0].Rows.Count < 2) 
				{
					MessageBox.Show ("There are not enough results computed.");
					return;
				}

				// extract the iterations sizes and sort them in increasing order
				int [] iIterations = new int [aResultsTable.Tables [0].Rows.Count];
				int [] iResultIDs = new int [aResultsTable.Tables [0].Rows.Count];
				for (int i = 0; i < aResultsTable.Tables [0].Rows.Count; i++) 
				{
					iIterations [i] = Convert.ToInt32 (aResultsTable.Tables [0].Rows [i] ["param_value"]);
					iResultIDs [i] = (int) aResultsTable.Tables [0].Rows [i] ["res_id"];
				}
				Array.Sort (iIterations, iResultIDs);
				Hashtable aResultIDToIterations = new Hashtable (iIterations.Length);
				for (int i = 0; i  < iIterations.Length; i++) 
					aResultIDToIterations [iResultIDs [i].ToString ()] = i;

				// prepare the mu and sigma error lists
				ArrayList [] dMuError = new ArrayList [iIterations.Length];
				ArrayList [] dSigmaError = new ArrayList [iIterations.Length];
				ArrayList [] iNumberOfSamples = new ArrayList [iIterations.Length];
				for (int i = 0; i < iIterations.Length; i++) 
				{
					dMuError [i] = new ArrayList ();
					dSigmaError [i] = new ArrayList ();
					iNumberOfSamples [i] = new ArrayList ();
				}

				// prepare the buffers for the online estimators
				double [] dMuBuffer = new double [iIterations.Length];
				double [] dMeanMuError = new double [iIterations.Length];
				double [] dSigmaBuffer = new double [iIterations.Length];
				double [] dMeanSigmaError = new double [iIterations.Length];
				int [] N = new int [iIterations.Length];

				/////////////////////////////////////////////////////////////////////////////
				// get the results (one after the other)
				/////////////////////////////////////////////////////////////////////////////

				// open the SQL connection
				aSQLConnection = new SqlConnection ("Initial Catalog = " + aSQLImportDialog.DatabaseName + "; Data Source = " + 
					aSQLImportDialog.SQLServerName + "; Integrated Security = SSPI");
				aSQLConnection.Open ();

				// get the list of players
				SqlCommand aPlayerListCommand = new 
					SqlCommand ("select distinct player_id,player_flags from tMSRankings " + 
								"join tResults on tResults.res_id = tMSRankings.res_id " + 
								"join tParameters on tParameters.res_id = tMSRankings.res_id " + 
								aSQLImportDialog.SQLFilterString + " and param_name = 'iterations'", aSQLConnection);
				SqlDataAdapter aPlayerListAdapter = new SqlDataAdapter (aPlayerListCommand);
				DataSet aPlayerList = new DataSet ();
				aPlayerListAdapter.Fill (aPlayerList);
	
				// prepare the progress bar
				pbProcessing.Visible = true;
				pbProcessing.Minimum = 0;
				pbProcessing.Maximum = aPlayerList.Tables [0].Rows.Count;
				pbProcessing.Step = 1;
				
				// handle one player after the other
				foreach (DataRow aRow in aPlayerList.Tables [0].Rows)
				{
					SqlCommand aPlayerDataCommand = new 
						SqlCommand ("select tMSRankings.res_id,mu,sigma from tMSRankings " +
									"join tResults on tResults.res_id = tMSRankings.res_id " + 
									"join tParameters on tParameters.res_id = tMSRankings.res_id " + 
									aSQLImportDialog.SQLFilterString + " and tParameters.param_name = 'iterations' " + 
									"and player_id = " + aRow ["player_id"].ToString () + " " + 
									"and player_flags = " + aRow ["player_flags"].ToString () + " " + 
									"order by rank_date,tMSRankings.res_id asc", aSQLConnection);
					SqlDataReader aPlayerDataReader = aPlayerDataCommand.ExecuteReader ();

					// prepare the online estimates
					for (int i = 0; i < dMeanMuError.Length; i++) 
					{
						dMeanMuError [i] = 0.0;
						dMeanSigmaError [i] = 0.0;
						N [i] = -1;
					}

					// process this line by line
					int iLastResultID = int.MaxValue;
					bool bDataRead = false;
					do 
					{
						// try to read the next entry
						bDataRead = aPlayerDataReader.Read ();

						// check if we need to update our online estimator
						if (bDataRead == false  || (int) aPlayerDataReader.GetValue (0) < iLastResultID)
						{
							// do not update the online estimators if there is no data collected yet
							if (iLastResultID != int.MaxValue) 
							{
								// determine the maximum to compare against
								int iMaxIndex = dMuBuffer.Length - 1;
								while (double.IsNaN (dMuBuffer [iMaxIndex])) iMaxIndex--;

								for (int i = 0; i < dMuBuffer.Length; i++) 
									if (!double.IsNaN (dMuBuffer [i]))
									{
										if (N [i] > -1) 
										{
											if (rbCumulativeError.Checked) 
											{
												// update the online estimators
												dMeanMuError [i] = ((double) N [i] * dMeanMuError [i] + 
													Math.Abs (dMuBuffer [i] - dMuBuffer [iMaxIndex]))/(double) (N [i] + 1);
												dMeanSigmaError [i] = ((double) N [i] * dMeanSigmaError [i] + 
													Math.Abs (dSigmaBuffer [i] - dSigmaBuffer [iMaxIndex]))/(double) (N [i] + 1);
											}

											if  (rbInstantError.Checked) 
											{
												// just take the instant error
												dMeanMuError [i] = Math.Abs (dMuBuffer [i] - dMuBuffer [iMaxIndex]);
												dMeanSigmaError [i] = Math.Abs (dSigmaBuffer [i] - dSigmaBuffer [iMaxIndex]);
											}

											// update the global list
											while (dMuError [i].Count <= N [i]) 
											{
												dMuError [i].Add (0.0);
												dSigmaError [i].Add (0.0);
												iNumberOfSamples [i].Add (0);
											}
											dMuError [i] [N [i]] = ((double) ((int) iNumberOfSamples [i] [N [i]]) * (double) dMuError [i] [N [i]] + 
												dMeanMuError [i]) / (double) (((int) iNumberOfSamples [i] [N [i]]) + 1);
											dSigmaError [i] [N [i]] = ((double) ((int) iNumberOfSamples [i] [N [i]]) * (double) dSigmaError [i] [N [i]] + 
												dMeanSigmaError [i]) / (double) (((int) iNumberOfSamples [i] [N [i]]) + 1);
											iNumberOfSamples [i] [N [i]] = ((int) iNumberOfSamples [i] [N [i]] + 1);
										}

										// update the local counter
										N [i]++;
									}

							}

							// fill all the buffers with impossible values
							for (int i = 0; i < dMuBuffer.Length; i++) 
							{
								dMuBuffer [i] = double.NaN;
								dSigmaBuffer [i] = double.NaN;
							}
						}

						// put the values into the buffer
						if (bDataRead) 
						{
							iLastResultID = (int) aPlayerDataReader.GetValue (0);
							int iIndex = (int) aResultIDToIterations [iLastResultID.ToString ()];
							dMuBuffer [iIndex] = (double) aPlayerDataReader.GetValue (1);
							dSigmaBuffer [iIndex] = (double) aPlayerDataReader.GetValue (2);
						}
					} while (bDataRead);

					// update the progress bar
					pbProcessing.PerformStep ();

					// close the reader
					aPlayerDataReader.Close ();
				}

				// prepare the progress bar
				pbProcessing.Visible = false;

				// close the SQL connection
				aSQLConnection.Close ();

				/////////////////////////////////////////////////////////////////////////////
				// plot the result on the screen
				/////////////////////////////////////////////////////////////////////////////
				
				PlotWindow aMuResultsWindow = new PlotWindow ();
				PlotWindow aSigmaResultsWindow = new PlotWindow ();
				for (int i = 0; i < iIterations.Length; i++) 
				{
					// create a simple index
					double [] dIndex = new double [dMuError [i].Count];
					for (int j = 0; j < dIndex.Length; j++) 
						dIndex [j] = (double) j;

					aMuResultsWindow.AddData (dIndex, (double []) dMuError [i].ToArray (typeof (double)), iIterations [i].ToString ());
					aSigmaResultsWindow.AddData (dIndex, (double []) dSigmaError [i].ToArray (typeof (double)), iIterations [i].ToString ());
				}
				aMuResultsWindow.XAxisTitle = "Number of games played";
				aSigmaResultsWindow.XAxisTitle = "Number of games played";
				if (rbCumulativeError.Checked) 
				{
					aMuResultsWindow.YAxisTitle = "Average cumulative error in Mu";
					aSigmaResultsWindow.YAxisTitle = "Average cumulative error in Sigma";
					aMuResultsWindow.Text = "Average Cumulative Mu Error Plot on " + aSQLImportDialog.GetHopperName (aSQLImportDialog.CurrentHopperID);
					aSigmaResultsWindow.Text = "Average Cumulative Sigma Error Plot on " + aSQLImportDialog.GetHopperName (aSQLImportDialog.CurrentHopperID);
				}
				if (rbInstantError.Checked) 
				{
					aMuResultsWindow.YAxisTitle = "Instant error in Mu";
					aSigmaResultsWindow.YAxisTitle = "Instant error in Sigma";
					aMuResultsWindow.Text = "Instant Mu Error Plot on " + aSQLImportDialog.GetHopperName (aSQLImportDialog.CurrentHopperID);
					aSigmaResultsWindow.Text = "Instant Sigma Error Plot on " + aSQLImportDialog.GetHopperName (aSQLImportDialog.CurrentHopperID);
				}
				aMuResultsWindow.UpdateChart ();
				aSigmaResultsWindow.UpdateChart ();
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\NamedArgParser\code\Properties\AssemblyInfo.cs ===
//-----------------------------------------------------------------------
// <copyright file="AssemblyInfo.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   assembly info
// </summary>
//-----------------------------------------------------------------------
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("NamedArgParser")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("NamedArgParser")]
[assembly: AssemblyCopyright("Copyright (c) Microsoft Corporation.  All rights reserved.")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("e240167e-4a96-4504-85a0-7b9fcda509dc")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("2.0.0.0")]
[assembly: AssemblyFileVersion("2.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nfast\inc\dlist.h ===
/**/
/*   Copyright (C) 1996-1998 nCipher Corporation Ltd.
 *   All rights reserved.  Company Confidential.
 */

#ifndef DLIST_H
#define DLIST_H

#define DLIST_UNLINK(node,head,tail) \
  do { \
    if ((node)->back) (node)->back->next= (node)->next; else (head)= (node)->next; \
    if ((node)->next) (node)->next->back= (node)->back; else (tail)= (node)->back; \
  } while(0)

#define DLIST_LINKTAIL(node,head,tail) \
  do { \
    (node)->next= 0; \
    (node)->back= (tail); \
    if (tail) (tail)->next= (node); else (head)= (node); \
    (tail)= (node); \
  } while(0)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\NamedArgParser\code\NamedArgParser.cs ===
//-----------------------------------------------------------------------
// <copyright file="NamedArgParser.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   common library for parsing command line parameters as named arguments
// </summary>
//-----------------------------------------------------------------------

// Assembly marked as compliant.
[assembly: System.CLSCompliant(true)]

// Assembly marked as security transparent
[assembly: System.Security.SecurityTransparent]

namespace NamedArgParser
{
    using System;
    using System.Collections.Generic;
    using System.Collections.Specialized;
    using System.IO;
    using System.Reflection;
    using System.Text;
    using System.Xml;
    using System.Xml.Schema;
    using System.Xml.XPath;

    /// <summary>
    /// The declaration of the callback function to display the usage
    /// </summary>
    /// <param name="usage">The usage to display</param>
    public delegate void DisplayUsageCallback(string usage);

    /// <summary>
    /// Class to parse command line arguments
    /// </summary>
    [CLSCompliant(true)]
    public class NamedArgsCollection : StringDictionary
    {
        /// <summary>
        /// The array of characters that would proceed an argument
        /// </summary>
        private static readonly char[] delimsVariable = { '/', '-' };

        /// <summary>
        /// The array of characters that would split an variable/value pait
        /// </summary>
        private static readonly char[] delimsValue = { ':', '=' };

        /// <summary>
        /// The array of strings that specify a help argument
        /// </summary>
        private static readonly string[] variablesHelp = { "?", "h", "help" };

        /// <summary>
        /// The xml schema set defining the schema for the usage xml
        /// </summary>
        private static XmlSchemaSet xmlSchemaSet;

        /// <summary>
        /// The xml document defining the named arg groups and their named arguments
        /// </summary>
        private XPathNavigator xpathNavigatorRoot;

        /// <summary>
        /// The XmlNamespaceManager object providing scope management for the XmlDocument object
        /// </summary>
        private XmlNamespaceManager xmlNamespaceManagerRoot;

        /// <summary>
        /// The NamedArgGroup representing the empty named arg group (no named arguments)
        /// </summary>
        private NamedArgGroup namedArgGroupEmpty;

        /// <summary>
        /// The collection of NamedArgGroups for this class
        /// </summary>
        private NamedArgGroupCollection namedArgGroupCollection;

        /// <summary>
        /// Initializes a new instance of the NamedArgsCollection class that is empty
        /// </summary>
        public NamedArgsCollection()
        {
            if (null == NamedArgsCollection.xmlSchemaSet)
            {
                // load the xsd
                NamedArgsCollection.xmlSchemaSet = new XmlSchemaSet();

                Stream stream = Assembly.GetExecutingAssembly().GetManifestResourceStream("NamedArgParser.Resources.NamedArgParser.xsd");
                using (StreamReader streamReader = new StreamReader(stream))
                {
                    NamedArgsCollection.xmlSchemaSet.Add(XmlSchema.Read(streamReader, null));
                }
            }
        }

        /// <summary>
        /// Defines the allowed types for a variable: required or optional
        /// </summary>
        private enum VariableType
        {
            /// <summary>
            /// The variable is required
            /// </summary>
            Required,

            /// <summary>
            /// The variable is optional
            /// </summary>
            Optional
        }

        /// <summary>
        /// Defines the allowed types for a value: required, optional or empty
        /// </summary>
        private enum ValueType
        {
            /// <summary>
            /// The value is required
            /// </summary>
            Required,

            /// <summary>
            /// The value is optional
            /// </summary>
            Optional,

            /// <summary>
            /// The value must be empty
            /// </summary>
            Empty
        }

        /// <summary>
        /// Displays the usage
        /// </summary>
        /// <param name="duc">The callback function to display the usage</param>
        public void DisplayUsage(DisplayUsageCallback duc)
        {
            // stringBuilderUsage is the usage string
            StringBuilder stringBuilderUsage = new StringBuilder();

            // get usage lines
            XPathNodeIterator xpathNodeIterator = this.xpathNavigatorRoot.Select(".//ns:NamedArgParser/ns:Usage/ns:Line", this.xmlNamespaceManagerRoot);
            while (true == xpathNodeIterator.MoveNext())
            {
                stringBuilderUsage.AppendLine(xpathNodeIterator.Current.Value);
            }

            duc(stringBuilderUsage.ToString());
        }

        /// <summary>
        /// Parses the arguments into variable/value pairs
        ///   Given the xml document, returns the matching named arg group for the variable/value pairs
        ///   If no matching named arg group is found, displays the usage
        /// </summary>
        /// <param name="stream">The stream containing the xml defining the named arg groups and their named arguments</param>
        /// <param name="args">The array of arguments to parse</param>
        /// <param name="duc">The callback function to display the usage if no named arg group is found</param>
        /// <returns>The name of the NamedArgGroup representing the arguments; otherwise, null</returns>
        public string Parse(Stream stream, string[] args, DisplayUsageCallback duc)
        {
            if (0 != this.Count)
            {
                throw new InvalidOperationException("There are variable/value pairs within this object.  Calling Parse again without clearing the pairs can result in undefined behavior.");
            }

            if (null == stream)
            {
                throw new ArgumentNullException("stream");
            }

            if (null == args)
            {
                throw new ArgumentNullException("args");
            }

            if (null == duc)
            {
                throw new ArgumentNullException("duc");
            }

            // load and validate the xml
            this.LoadXml(stream);

            // build the tables of named arg groups and named args
            this.BuildNamedArgGroupsAndNamedArgs();

            // check each named arg group is unique
            this.CheckNamedArgGroups();

            // parse the variable/value pairs
            try
            {
                this.Parse(args);
            }
            catch (ArgumentException)
            {
                this.DisplayUsage(duc);

                return null;
            }

            // check if help was requested
            for (int argIndex = 0; argIndex < variablesHelp.Length; argIndex++)
            {
                if (null != this[variablesHelp[argIndex]])
                {
                    this.DisplayUsage(duc);

                    return null;
                }
            }

            // find the named arg group
            NamedArgGroup namedArgGroup = this.FindNamedArgGroup();
            if (null == namedArgGroup)
            {
                this.DisplayUsage(duc);

                return null;
            }

            // check the values
            if (false == this.CheckNamedArgs(namedArgGroup))
            {
                this.DisplayUsage(duc);

                return null;
            }

            return namedArgGroup.ToString();
        }

        /// <summary>
        /// Builds the named argument
        /// </summary>
        /// <param name="namedArgGroup">The NamedArgGroup to which the named arguments will be added</param>
        /// <param name="xpathNavigator">The xml element with the named argument</param>
        /// <param name="requiredCount">The number of required arguments within the NamedArgGroup</param>
        /// <returns>The newly created NamedArgVariable</returns>
        private static NamedArgVariable BuildNamedArgVariable(NamedArgGroup namedArgGroup, XPathNavigator xpathNavigator, ref int requiredCount)
        {
            string namedArgName = xpathNavigator.Value;

            // check if this named arg has already been defined
            if (true == namedArgGroup.Contains(namedArgName))
            {
                throw new XmlException(String.Format("NamedArg {0} within NamedArgGroup {1} is defined multiple times.", namedArgName, namedArgGroup));
            }

            VariableType variableType = VariableType.Required;

            // check if this named arg variable is required or optional
            if ("optional" == xpathNavigator.GetAttribute("variable", String.Empty))
            {
                variableType = VariableType.Optional;
            }

            if (variableType == VariableType.Required)
            {
                requiredCount++;
            }

            ValueType valueType = ValueType.Required;

            // check if this named arg value is required, optional or empty
            if ("optional" == xpathNavigator.GetAttribute("value", String.Empty))
            {
                valueType = ValueType.Optional;
            }
            else if ("empty" == xpathNavigator.GetAttribute("value", String.Empty))
            {
                valueType = ValueType.Empty;
            }

            // add this named arg
            return namedArgGroup.Add(namedArgName, variableType, valueType);
        }

        /// <summary>
        /// Builds the tables of named arg groups to named args and variabletypes and named arg groups to named args and valuetypes
        ///   Validates each named arg group is unique
        ///   Validates each named arg within a named arg group is unique
        /// </summary>
        private void BuildNamedArgGroupsAndNamedArgs()
        {
            this.namedArgGroupCollection = new NamedArgGroupCollection();

            // get named arg groups
            XPathNodeIterator xpathNodeIterator = this.xpathNavigatorRoot.Select(".//ns:NamedArgParser/ns:NamedArgGroups/ns:NamedArgGroup", this.xmlNamespaceManagerRoot);
            while (true == xpathNodeIterator.MoveNext())
            {
                // get the name of the named arg group
                string namedArgGroupName = xpathNodeIterator.Current.SelectSingleNode("ns:Name", this.xmlNamespaceManagerRoot).Value;

                // check if this named arg group has already been defined
                if (true == this.namedArgGroupCollection.Contains(namedArgGroupName))
                {
                    throw new XmlException(String.Format("NamedArgGroup {0} is defined multiple times.", namedArgGroupName));
                }

                NamedArgGroup namedArgGroup = this.namedArgGroupCollection.Add(namedArgGroupName);

                // build the list of named args
                int requiredCount = 0;

                this.BuildNamedArgsFromName(namedArgGroup, xpathNodeIterator.Current, ref requiredCount);
                this.BuildNamedArgsFromNamedArg(namedArgGroup, xpathNodeIterator.Current, ref requiredCount);

                if ((0 == requiredCount) && (null == this.namedArgGroupEmpty))
                {
                    this.namedArgGroupEmpty = namedArgGroup;
                }
            }
        }

        /// <summary>
        /// Builds the named arguments from a Name element
        /// </summary>
        /// <param name="namedArgGroup">The NamedArgGroup to which the named arguments will be added</param>
        /// <param name="xpathNavigator">The current xml element containing a Name element</param>
        /// <param name="requiredCount">The number of required arguments within the NamedArgGroup</param>
        private void BuildNamedArgsFromName(NamedArgGroup namedArgGroup, XPathNavigator xpathNavigator, ref int requiredCount)
        {
            XPathNodeIterator xpathNodeIterator = xpathNavigator.Select("ns:NamedArgs/ns:Name", this.xmlNamespaceManagerRoot);
            while (true == xpathNodeIterator.MoveNext())
            {
                NamedArgsCollection.BuildNamedArgVariable(namedArgGroup, xpathNodeIterator.Current, ref requiredCount);
            }
        }

        /// <summary>
        /// Builds the named arguments from a NamedArg element
        /// </summary>
        /// <param name="namedArgGroup">The NamedArgGroup to which the named arguments will be added</param>
        /// <param name="xpathNavigator">The current xml element containing a NamedArg element</param>
        /// <param name="requiredCount">The number of required arguments within the NamedArgGroup</param>
        private void BuildNamedArgsFromNamedArg(NamedArgGroup namedArgGroup, XPathNavigator xpathNavigator, ref int requiredCount)
        {
            XPathNodeIterator xpathNodeIterator = xpathNavigator.Select("ns:NamedArgs/ns:NamedArg", this.xmlNamespaceManagerRoot);
            while (true == xpathNodeIterator.MoveNext())
            {
                XPathNavigator xpathNavigatorName = xpathNodeIterator.Current.SelectSingleNode("ns:Name", this.xmlNamespaceManagerRoot);

                NamedArgVariable namedArgVariable = NamedArgsCollection.BuildNamedArgVariable(namedArgGroup, xpathNavigatorName, ref requiredCount);

                // check for any specific values
                XPathNodeIterator xpathNodeIteratorValues = xpathNavigator.Select("ns:Values/ns:Value", this.xmlNamespaceManagerRoot);

                if ((ValueType.Empty == namedArgVariable.ValueType) && (0 < xpathNodeIteratorValues.Count))
                {
                    throw new XmlException(String.Format("NamedArg {0} within NamedArgGroup {1} is specified with an empty value but values are defined.", namedArgVariable, namedArgGroup));
                }

                while (true == xpathNodeIteratorValues.MoveNext())
                {
                    namedArgVariable.Add(xpathNodeIteratorValues.Current.Value);
                }
            }
        }

        /// <summary>
        /// Checks that each named arg group is distinctive from other named arg groups
        /// </summary>
        private void CheckNamedArgGroups()
        {
            List<string> listNamedArgGroups = new List<string>(this.namedArgGroupCollection.Keys);

            // enumerate each named arg group as left
            for (int indexLeft = 0; indexLeft < (listNamedArgGroups.Count - 1); indexLeft++)
            {
                NamedArgGroup namedArgGroupLeft = this.namedArgGroupCollection[listNamedArgGroups[indexLeft]];

                // enumerate each named arg group as right
                for (int indexRight = (indexLeft + 1); indexRight < listNamedArgGroups.Count; indexRight++)
                {
                    NamedArgGroup namedArgGroupRight = this.namedArgGroupCollection[listNamedArgGroups[indexRight]];

                    if ((0 == namedArgGroupLeft.Variables.Count) && (0 == namedArgGroupRight.Variables.Count))
                    {
                        throw new XmlException(String.Format("NamedArgGroup {0} and NamedArgGroup {1} are not distinctive.", namedArgGroupLeft, namedArgGroupRight));
                    }
                    else
                    {
                        // build a copy of the list of named args
                        NamedArgVariableCollection namedArgVariablesLeft = new NamedArgVariableCollection(namedArgGroupLeft.Variables);
                        NamedArgVariableCollection namedArgVariablesRight = new NamedArgVariableCollection(namedArgGroupRight.Variables);

                        // enumerate the named args left - remove any named args found in right from right
                        foreach (NamedArgVariable namedArgVariableLeft in namedArgGroupLeft.Variables)
                        {
                            namedArgVariablesRight.Remove(namedArgVariableLeft);
                        }

                        // enumerate the named args right - remove any named args found in left from left
                        foreach (NamedArgVariable namedArgVariableRight in namedArgGroupRight.Variables)
                        {
                            namedArgVariablesLeft.Remove(namedArgVariableRight);
                        }

                        // if the list of named args contains only optional variables it means the named arg group can be represented by the other named arg group, i.e. the usage is not well defined
                        bool required = false;

                        foreach (NamedArgVariable namedArgVariableLeft in namedArgVariablesLeft)
                        {
                            if (VariableType.Required == namedArgVariableLeft.VariableType)
                            {
                                required = true;
                                break;
                            }
                        }

                        foreach (NamedArgVariable namedArgVariableRight in namedArgVariablesRight)
                        {
                            if (VariableType.Required == namedArgVariableRight.VariableType)
                            {
                                required = true;
                                break;
                            }
                        }

                        if (false == required)
                        {
                            throw new XmlException(String.Format("NamedArgGroup {0} and NamedArgGroup {1} are not distinctive.", namedArgGroupLeft, namedArgGroupRight));
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Validates the values are specified correctly for each variable
        /// </summary>
        /// <param name="namedArgGroup">The NamedArgGroup defining its variables and values</param>
        /// <returns>true if the values are specified correctly for each variable; otherwise, false</returns>
        private bool CheckNamedArgs(NamedArgGroup namedArgGroup)
        {
            foreach (NamedArgVariable namedArgVariable in namedArgGroup.Variables)
            {
                // check if variable type is optional and if the variable is not specified
                // if both true, nothing else to do
                if ((VariableType.Optional == namedArgVariable.VariableType) && (false == this.ContainsKey(namedArgVariable.ToString())))
                {
                    continue;
                }

                // variable type is required
                if (ValueType.Required == namedArgVariable.ValueType)
                {
                    // value type is required, check if null or empty
                    if (true == String.IsNullOrEmpty(this[namedArgVariable.ToString()]))
                    {
                        return false;
                    }
                }
                else if (ValueType.Empty == namedArgVariable.ValueType)
                {
                    // value types is null, check if non-null and not empty
                    if (false == String.IsNullOrEmpty(this[namedArgVariable.ToString()]))
                    {
                        return false;
                    }
                }

                // check if the value is restricted
                if (0 == namedArgVariable.Values.Count)
                {
                    continue;
                }

                // check if value type is optional and if the value is not specified
                // if both true, nothing else to do
                if ((ValueType.Optional == namedArgVariable.ValueType) && (true == String.IsNullOrEmpty(this[namedArgVariable.ToString()])))
                {
                    continue;
                }

                // check if the value is an allowed value
                if (false == namedArgVariable.Values.Contains(this[namedArgVariable.ToString()]))
                {
                    return false;
                }
            }

            return true;
        }

        /// <summary>
        /// Finds the named arg group that matches the variables
        /// </summary>
        /// <returns>The NamedArgGroup that matches the variables; otherwise, null</returns>
        private NamedArgGroup FindNamedArgGroup()
        {
            if (0 == this.Count)
            {
                return this.namedArgGroupEmpty;
            }

            List<NamedArgGroup> listNamedArgGroups = new List<NamedArgGroup>();

            // enumerate each named arg as right
            foreach (NamedArgGroup namedArgGroup in this.namedArgGroupCollection)
            {
                List<string> namedArgVariablesLeft = new List<string>();
                NamedArgVariableCollection namedArgVariablesRight = new NamedArgVariableCollection(namedArgGroup.Variables);

                // enumerate the named args left - remove any named args found in right from right
                foreach (string namedArgVariableLeft in this.Keys)
                {
                    namedArgVariablesLeft.Add(namedArgVariableLeft);
                    namedArgVariablesRight.Remove(namedArgVariableLeft);
                }

                // enumerate the named args right - remove any named args found in left from left
                foreach (NamedArgVariable namedArgVariableRight in namedArgGroup.Variables)
                {
                    namedArgVariablesLeft.Remove(namedArgVariableRight.ToString());
                }

                // if there are any remaining named args left this is not the named arg group
                if (0 != namedArgVariablesLeft.Count)
                {
                    continue;
                }

                // if there are any remaining named args right check if they are optional
                if (0 != namedArgVariablesRight.Count)
                {
                    bool required = false;

                    foreach (NamedArgVariable namedArgVariableRight in namedArgVariablesRight)
                    {
                        if (VariableType.Required == namedArgVariableRight.VariableType)
                        {
                            required = true;
                            break;
                        }
                    }

                    if (true == required)
                    {
                        continue;
                    }
                }

                // this is the named arg group
                if (false == listNamedArgGroups.Contains(namedArgGroup))
                {
                    listNamedArgGroups.Add(namedArgGroup);
                }
            }

            if (1 != listNamedArgGroups.Count)
            {
                return null;
            }

            return listNamedArgGroups[0];
        }

        /// <summary>
        /// Validates the xml string against the NamedArgParser schema
        /// </summary>
        /// <param name="stream">The stream containing the xml defining the named arg groups and their named arguments</param>
        private void LoadXml(Stream stream)
        {
            // set the validation
            XmlReaderSettings xmlReaderSettings = new XmlReaderSettings();
            xmlReaderSettings.Schemas.Add(NamedArgsCollection.xmlSchemaSet);
            xmlReaderSettings.ValidationType = ValidationType.Schema;

            // load the file
            XPathNavigator xpathNavigator = null;
            using (XmlReader xmlReader = XmlReader.Create(stream, xmlReaderSettings))
            {
                xpathNavigator = new XPathDocument(xmlReader).CreateNavigator();
            }

            // get the document element
            XPathNavigator xpathNavigatorElement = xpathNavigator.SelectSingleNode("*");

            // check if the document element namespace exists in the schema set
            if (0 == xmlSchemaSet.Schemas(xpathNavigatorElement.NamespaceURI).Count)
            {
                throw new XmlSchemaValidationException(String.Format("Namespace '{0}' is not defined.", xpathNavigatorElement.NamespaceURI));
            }

            this.xpathNavigatorRoot = xpathNavigator;

            this.xmlNamespaceManagerRoot = new XmlNamespaceManager(this.xpathNavigatorRoot.NameTable);
            this.xmlNamespaceManagerRoot.AddNamespace("ns", xpathNavigatorElement.NamespaceURI);
        }

        /// <summary>
        /// Parses the arguments into variable/value pairs
        /// </summary>
        /// <param name="args">The array of arguments to parse</param>
        private void Parse(string[] args)
        {
            int argIndex;

            for (argIndex = 0; argIndex < args.Length; argIndex++)
            {
                string arg = args[argIndex];

                int delimVariableIndex = -1;
                int delimValueIndex = -1;
                string variable;
                string value;

                // find the variable delimeter
                for (int index = 0; index < delimsVariable.Length; index++)
                {
                    if (arg[0] == delimsVariable[index])
                    {
                        delimVariableIndex = index;
                        break;
                    }
                }

                if (-1 == delimVariableIndex)
                {
                    continue;
                }

                // find the value delimeter
                for (int index = 0; index < delimsValue.Length; index++)
                {
                    delimValueIndex = arg.IndexOf(delimsValue[index]);

                    if (0 < delimValueIndex)
                    {
                        break;
                    }
                }

                // add the variable/value pair
                if (-1 == delimValueIndex)
                {
                    // remove the variable delimeter
                    variable = arg.Substring(1);

                    this.Add(variable, String.Empty);
                }
                else if (1 < delimValueIndex)
                {
                    variable = arg.Substring(1, (delimValueIndex - 1));
                    value = arg.Substring(delimValueIndex + 1);

                    if (true == String.IsNullOrEmpty(value))
                    {
                        value = String.Empty;
                    }

                    this.Add(variable, value);
                }
            }
        }

        /// <summary>
        /// Represents a named argument group and its collection of NamedArgVariables
        /// </summary>
        private class NamedArgGroup
        {
            /// <summary>
            /// The name of the NamedArgGroup
            /// </summary>
            private string name;

            /// <summary>
            /// The NamedArgVariableCollection containing the NamedArgVariables of this class
            /// </summary>
            private NamedArgVariableCollection namedArgVariableCollection = new NamedArgVariableCollection();

            /// <summary>
            /// Initializes a new instance of the NamedArgGroup class that is empty
            /// </summary>
            /// <param name="name">The name of the new NamedArgGroup</param>
            public NamedArgGroup(string name)
            {
                this.name = name;
            }

            /// <summary>
            /// Gets the name of the NamedArgGroup
            /// </summary>
            public string Name
            {
                get { return this.name; }
            }

            /// <summary>
            /// Gets the NamedArgVariableCollection containing the NamedArgVariables in the collection
            /// </summary>
            public NamedArgVariableCollection Variables
            {
                get { return this.namedArgVariableCollection; }
            }

            /// <summary>
            /// Determines whether a NamedArgVariable is in the collection
            /// </summary>
            /// <param name="name">The name of the NamedArgVariable to locate in the collection</param>
            /// <returns>true if NamedArgVariable is found in the collection; otherwise, false</returns>
            public bool Contains(string name)
            {
                return this.namedArgVariableCollection.Contains(name.ToLower());
            }

            /// <summary>
            /// Adds a new NamedArgVariable to the collection
            /// </summary>
            /// <param name="name">The name of the new NamedArgVariable</param>
            /// <param name="variableType">The type of the new NamedArgVariable variable: required or optional</param>
            /// <param name="valueType">The type of the new NamedArgVariable value: required, optional, or empty</param>
            /// <returns>The newly created NamedArgVariable</returns>
            public NamedArgVariable Add(string name, VariableType variableType, ValueType valueType)
            {
                return this.namedArgVariableCollection.Add(name, variableType, valueType);
            }

            /// <summary>
            /// Converts the value of the current NamedArgGroup object to its equivalent string representation
            /// </summary>
            /// <returns>A string representation of the value of the current NamedArgGroup object</returns>
            public override string ToString()
            {
                return this.Name;
            }
        }

        /// <summary>
        /// Represents the collection of NamedArgGroups
        /// </summary>
        private class NamedArgGroupCollection : IEnumerable<NamedArgGroup>
        {
            /// <summary>
            /// The underlying collection of the NamedArgGroupCollection class
            /// TKey is the name of the NamedArgGroup
            /// TValue is the NamedArgGroup object
            /// </summary>
            private Dictionary<string, NamedArgGroup> dictionaryNamedArgGroups = new Dictionary<string, NamedArgGroup>();

            /// <summary>
            /// Initializes a new instance of the NamedArgGroupCollection class that is empty
            /// </summary>
            public NamedArgGroupCollection()
            {
            }

            /// <summary>
            /// Gets the KeyCollection containing the keys in the collection
            /// </summary>
            public Dictionary<string, NamedArgGroup>.KeyCollection Keys
            {
                get { return this.dictionaryNamedArgGroups.Keys; }
            }

            /// <summary>
            /// Returns the NamedArgGroup at the specified index in the collection
            /// </summary>
            /// <param name="index">The name of the NamedArgGroup to return</param>
            /// <returns>The NamedArgGroup at the specified index if it exists; otherwise, null</returns>
            public NamedArgGroup this[string index]
            {
                get
                {
                    if (false == this.dictionaryNamedArgGroups.ContainsKey(index))
                    {
                        return null;
                    }

                    return this.dictionaryNamedArgGroups[index];
                }
            }

            /// <summary>
            /// Adds a new NamedArgGroup to the collection
            /// </summary>
            /// <param name="name">The name of the new NamedArgGroup</param>
            /// <returns>The newly created NamedArgGroup</returns>
            public NamedArgGroup Add(string name)
            {
                NamedArgGroup namedArgGroup = new NamedArgGroup(name);
                this.dictionaryNamedArgGroups[namedArgGroup.ToString().ToLower()] = namedArgGroup;

                return namedArgGroup;
            }

            /// <summary>
            /// Determines whether a NamedArgGroup is in the collection
            /// </summary>
            /// <param name="name">The name of the NamedArgGroup to locate in the collection</param>
            /// <returns>true if NamedArgGroup is found in the collection; otherwise, false</returns>
            public bool Contains(string name)
            {
                return this.dictionaryNamedArgGroups.ContainsKey(name.ToLower());
            }

            /// <summary>
            /// Returns an enumerator that iterates through the collection
            /// </summary>
            /// <returns>An IEnumerator object that can be used to iterate through the collection</returns>
            IEnumerator<NamedArgGroup> IEnumerable<NamedArgGroup>.GetEnumerator()
            {
                foreach (string key in this.dictionaryNamedArgGroups.Keys)
                {
                    yield return this.dictionaryNamedArgGroups[key];
                }
            }

            /// <summary>
            /// Returns an enumerator that iterates through the collection
            /// </summary>
            /// <returns>An IEnumerator object that can be used to iterate through the collection</returns>
            System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
            {
                return this.dictionaryNamedArgGroups.GetEnumerator();
            }
        }

        /// <summary>
        /// Represents a named argument variable
        /// </summary>
        private class NamedArgVariable
        {
            /// <summary>
            /// The name of the NamedArgVariable
            /// </summary>
            private string name;

            /// <summary>
            /// The list of allowed values for the NamedArgVariable
            /// </summary>
            private List<string> values = new List<string>();

            /// <summary>
            /// The type of the NamedArgVariable value: required, optional or empty
            /// </summary>
            private ValueType valueType;

            /// <summary>
            /// The type of the NamedArgVariable variable: required or optional
            /// </summary>
            private VariableType variableType;

            /// <summary>
            /// Initializes a new instance of the NamedArgVariable class
            /// </summary>
            /// <param name="name">The name of the new NamedArgVariable</param>
            /// <param name="variableType">The type of the new NamedArgVariable variable: required or optional</param>
            /// <param name="valueType">The type of the new NamedArgVariable value: required, optional, or empty</param>
            public NamedArgVariable(string name, VariableType variableType, ValueType valueType)
            {
                this.name = name.ToLower();
                this.variableType = variableType;
                this.valueType = valueType;
            }

            /// <summary>
            /// Gets the name of the NamedArgVariable
            /// </summary>
            public string Name
            {
                get { return this.name; }
            }

            /// <summary>
            /// Gets the list of allowed values for this NamedArgVariable
            /// </summary>
            public List<string> Values
            {
                get { return this.values; }
            }

            /// <summary>
            /// Gets the type of the NamedArgVariable value: required, optional or empty
            /// </summary>
            public ValueType ValueType
            {
                get { return this.valueType; }
            }

            /// <summary>
            /// Gets the type of the NamedArgVariable variable: required or optional
            /// </summary>
            public VariableType VariableType
            {
                get { return this.variableType; }
            }

            /// <summary>
            /// Adds the specified value to the list of allowed values for this NamedArgVariable
            /// </summary>
            /// <param name="value">The specified value to add to the list</param>
            public void Add(string value)
            {
                this.values.Add(value.ToLower());
            }

            /// <summary>
            /// Converts the value of the current NamedArgVariable object to its equivalent string representation
            /// </summary>
            /// <returns>A string representation of the value of the current NamedArgVariable object</returns>
            public override string ToString()
            {
                return this.Name;
            }
        }

        /// <summary>
        /// Represents the collection of NamedArgVariables
        /// </summary>
        private class NamedArgVariableCollection : IEnumerable<NamedArgVariable>
        {
            /// <summary>
            /// The underlying collection of the NamedArgVariableCollection class
            /// TKey is the name of the NamedArgVariable
            /// TValue is the NamedArgVariable object
            /// </summary>
            private Dictionary<string, NamedArgVariable> dictionaryNamedArgVariables = new Dictionary<string, NamedArgVariable>();

            /// <summary>
            /// Initializes a new instance of the NamedArgVariableCollection class that is empty
            /// </summary>
            public NamedArgVariableCollection()
            {
            }

            /// <summary>
            /// Initializes a new instance of the NamedArgVariableCollection class that contains NamedArgVariables copied from the specified collection
            /// </summary>
            /// <param name="namedArgVariableCollection">The collection whose NamedArgVariables are copied to the new collection</param>
            public NamedArgVariableCollection(NamedArgVariableCollection namedArgVariableCollection)
            {
                foreach (NamedArgVariable namedArgVariable in namedArgVariableCollection)
                {
                    this.Add(namedArgVariable.Name, namedArgVariable.VariableType, namedArgVariable.ValueType);
                }
            }

            /// <summary>
            /// Gets the number of NamedArgVariables in the collection
            /// </summary>
            public int Count
            {
                get { return this.dictionaryNamedArgVariables.Count; }
            }

            /// <summary>
            /// Adds a new NamedArgVariable to the collection
            /// </summary>
            /// <param name="name">The name of the new NamedArgVariable</param>
            /// <param name="variableType">The type of the new NamedArgVariable variable: required or optional</param>
            /// <param name="valueType">The type of the new NamedArgVariable value: required, optional, or empty</param>
            /// <returns>The newly created NamedArgVariable</returns>
            public NamedArgVariable Add(string name, VariableType variableType, ValueType valueType)
            {
                NamedArgVariable namedArgVariable = new NamedArgVariable(name, variableType, valueType);
                this.dictionaryNamedArgVariables[namedArgVariable.ToString()] = namedArgVariable;

                return namedArgVariable;
            }

            /// <summary>
            /// Determines whether a NamedArgVariable is in the collection
            /// </summary>
            /// <param name="name">The name of the NamedArgVariable to locate in the collection</param>
            /// <returns>true if NamedArgVariable is found in the collection; otherwise, false</returns>
            public bool Contains(string name)
            {
                return this.dictionaryNamedArgVariables.ContainsKey(name.ToLower());
            }

            /// <summary>
            /// Removes the specified NamedArgVariable from the collection
            /// </summary>
            /// <param name="namedArgVarible">The NamedArgVariable to remove from the collection</param>
            public void Remove(NamedArgVariable namedArgVarible)
            {
                this.dictionaryNamedArgVariables.Remove(namedArgVarible.ToString());
            }

            /// <summary>
            /// Removes the specified NamedArgVariable from the collection
            /// </summary>
            /// <param name="namedArgVariable">The name of the NamedArgVariable to remove from the collection</param>
            public void Remove(string namedArgVariable)
            {
                this.dictionaryNamedArgVariables.Remove(namedArgVariable.ToLower());
            }

            /// <summary>
            /// Returns an enumerator that iterates through the collection
            /// </summary>
            /// <returns>An IEnumerator object that can be used to iterate through the collection</returns>
            IEnumerator<NamedArgVariable> IEnumerable<NamedArgVariable>.GetEnumerator()
            {
                foreach (string key in this.dictionaryNamedArgVariables.Keys)
                {
                    yield return this.dictionaryNamedArgVariables[key];
                }
            }

            /// <summary>
            /// Returns an enumerator that iterates through the collection
            /// </summary>
            /// <returns>An IEnumerator object that can be used to iterate through the collection</returns>
            System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
            {
                return this.dictionaryNamedArgVariables.GetEnumerator();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nfast\inc\messages-a-eh.h ===
/* -*-c-*-
 *
 * Generated by Marshmallow at 2003-04-16T17:13:56
 */

#ifndef MESSAGES_A_EH_H
#define MESSAGES_A_EH_H

struct NF_UserData;

/* --- Required functions --- */

extern void *NF_Malloc(size_t sz, struct NF_UserData *u);
extern int NF_Free(void *p, struct NF_UserData *u);
extern int NFErr_EnumRange_Status(const char *ty, const char *mem, M_Word val, int max, struct NF_UserData *u);
extern int NFErr_EnumRange(const char *ty, const char *mem, const char *e, M_Word val, int max, struct NF_UserData *u);
extern int NFErr_UnknownFlag(const char *ty, const char *mem, M_Word f, struct NF_UserData *u);
extern int NFErr_TableTooLarge(const char *ty, const char *mem, const char *tab, M_Word n, int max, struct NF_UserData *u);
extern int NFErr_VarFormNotFound_Status(const char *v, M_Status tag, struct NF_UserData *u);
extern int NFErr_VarFormNotFound(const char *e, const char *v, M_Word tag, struct NF_UserData *u);
extern int NFErr_EnumRange_Cmd(const char *ty, const char *mem, M_Word val, int max, struct NF_UserData *u);
extern int NFErr_VarFormNotFound_Cmd(const char *v, M_Cmd tag, struct NF_UserData *u);

/*----- That's all, folks -------------------------------------------------*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nfast\inc\messages-a-free.h ===
/* -*-c-*-
 *
 * Generated by Marshmallow at 2003-04-16T17:14:00
 */

#ifndef MESSAGES_A_FREE_H
#define MESSAGES_A_FREE_H

/* --- Freeing context --- */

#ifndef NF_FREE_CONTEXT
#define NF_FREE_CONTEXT

typedef struct NF_Free_Context {
  struct NF_UserData *u;
} NF_Free_Context;

#endif

/* --- Exported types --- */

extern int NF_Free_Word(NF_Free_Context *c, M_Word *msg);
extern int NF_Free_ByteBlock(NF_Free_Context *c, M_ByteBlock *msg);
extern int NF_Free_ASCIIString(NF_Free_Context *c, M_ASCIIString *msg);
extern int NF_Free_MustBeZeroWord(NF_Free_Context *c, M_MustBeZeroWord *msg);
extern int NF_Free_Hash(NF_Free_Context *c, M_Hash *msg);
extern int NF_Free_Status(NF_Free_Context *c, M_Status *msg);
extern int NF_Free_nCErrno(NF_Free_Context *c, M_nCErrno *msg);
extern int NF_Free_Status_nCErrno_ErrorInfo(NF_Free_Context *c, M_Status_nCErrno_ErrorInfo *msg);
extern int NF_Free_KeyHash(NF_Free_Context *c, M_KeyHash *msg);
extern int NF_Free_Status__ErrorInfo(NF_Free_Context *c, M_Status__ErrorInfo *msg, M_Status *tag);
extern int NF_Free_StatusErrorInfo(NF_Free_Context *c, M_StatusErrorInfo *msg);
extern int NF_Free_NetworkAddress(NF_Free_Context *c, M_NetworkAddress *msg);
extern int NF_Free_KeyID(NF_Free_Context *c, M_KeyID *msg);
extern int NF_Free_ModuleID(NF_Free_Context *c, M_ModuleID *msg);
extern int NF_Free_ClientID(NF_Free_Context *c, M_ClientID *msg);
extern int NF_Free_SlotID(NF_Free_Context *c, M_SlotID *msg);
extern int NF_Free_LimitID(NF_Free_Context *c, M_LimitID *msg);
extern int NF_Free_TokenHash(NF_Free_Context *c, M_TokenHash *msg);
extern int NF_Free_KMHash(NF_Free_Context *c, M_KMHash *msg);
extern int NF_Free_PhysToken(NF_Free_Context *c, M_PhysToken *msg);
extern int NF_Free_SlotType(NF_Free_Context *c, M_SlotType *msg);
extern int NF_Free_SlotType__SlotExData(NF_Free_Context *c, M_SlotType__SlotExData *msg, M_SlotType *tag);
extern int NF_Free_ClientChannelOpenInfo(NF_Free_Context *c, M_ClientChannelOpenInfo *msg);
extern int NF_Free_ChannelOpenInfo(NF_Free_Context *c, M_ChannelOpenInfo *msg);
extern int NF_Free_Bignum(NF_Free_Context *c, M_Bignum *msg);
extern int NF_Free_KeyData(NF_Free_Context *c, M_KeyData *msg);
extern int NF_Free_CipherText(NF_Free_Context *c, M_CipherText *msg);
extern int NF_Free_Certificate(NF_Free_Context *c, M_Certificate *msg);
extern int NF_Free_ImpathKXGroup(NF_Free_Context *c, M_ImpathKXGroup *msg);
extern int NF_Free_Nonce(NF_Free_Context *c, M_Nonce *msg);
extern int NF_Free_PlainText(NF_Free_Context *c, M_PlainText *msg);
extern int NF_Free_KeyGenParams(NF_Free_Context *c, M_KeyGenParams *msg);
extern int NF_Free_IV(NF_Free_Context *c, M_IV *msg);
extern int NF_Free_DeriveMech(NF_Free_Context *c, M_DeriveMech *msg);
extern int NF_Free_DeriveMech__DKParams(NF_Free_Context *c, M_DeriveMech__DKParams *msg, M_DeriveMech *tag);
extern int NF_Free_ImpathKXGroupSelection(NF_Free_Context *c, M_ImpathKXGroupSelection *msg);
extern int NF_Free_RemoteModule(NF_Free_Context *c, M_RemoteModule *msg);
extern int NF_Free_CertificateList(NF_Free_Context *c, M_CertificateList *msg);
extern int NF_Free_ACL(NF_Free_Context *c, M_ACL *msg);
extern int NF_Free_Command(NF_Free_Context *c, M_Command *msg);
extern int NF_Free_ModuleAttribList(NF_Free_Context *c, M_ModuleAttribList *msg);
extern int NF_Free_KeyHashAndMech(NF_Free_Context *c, M_KeyHashAndMech *msg);
extern int NF_Free_PermissionGroup(NF_Free_Context *c, M_PermissionGroup *msg);
extern int NF_Free_EnquiryDataOne(NF_Free_Context *c, M_EnquiryDataOne *msg);
extern int NF_Free_EnquiryDataTwo(NF_Free_Context *c, M_EnquiryDataTwo *msg);
extern int NF_Free_EnquiryDataThree(NF_Free_Context *c, M_EnquiryDataThree *msg);
extern int NF_Free_EnquiryDataFour(NF_Free_Context *c, M_EnquiryDataFour *msg);
extern int NF_Free_EnquiryDataFive(NF_Free_Context *c, M_EnquiryDataFive *msg);
extern int NF_Free_EnquiryDataSix(NF_Free_Context *c, M_EnquiryDataSix *msg);
extern int NF_Free_ModuleAttrib(NF_Free_Context *c, M_ModuleAttrib *msg);
extern int NF_Free_UseLimit(NF_Free_Context *c, M_UseLimit *msg);
extern int NF_Free_Action(NF_Free_Context *c, M_Action *msg);
extern int NF_Free_KeyHashAttrib(NF_Free_Context *c, M_KeyHashAttrib *msg);
extern int NF_Free_ModuleCert(NF_Free_Context *c, M_ModuleCert *msg);
extern int NF_Free_Reply(NF_Free_Context *c, M_Reply *msg);
extern int NF_Free_ImageMetaDataHeader(NF_Free_Context *c, M_ImageMetaDataHeader *msg);
extern int NF_Free_ImageMetaData(NF_Free_Context *c, M_ImageMetaData *msg);
extern int NF_Free_OldProgrammingSignedData(NF_Free_Context *c, M_OldProgrammingSignedData *msg);
extern int NF_Free_ProgrammingSignedData(NF_Free_Context *c, M_ProgrammingSignedData *msg);
extern int NF_Free_FirmwareFileHeader(NF_Free_Context *c, M_FirmwareFileHeader *msg);
extern int NF_Free_FirmwareFileData(NF_Free_Context *c, M_FirmwareFileData *msg);
extern int NF_Free_SigningKeys(NF_Free_Context *c, M_SigningKeys *msg);
extern int NF_Free_CertSignMessage(NF_Free_Context *c, M_CertSignMessage *msg);
extern int NF_Free_ModCertMsg(NF_Free_Context *c, M_ModCertMsg *msg);
extern int NF_Free_StandaloneCert(NF_Free_Context *c, M_StandaloneCert *msg);
extern int NF_Free_Warrant(NF_Free_Context *c, M_Warrant *msg);
extern int NF_Free_ModuleAttribProof(NF_Free_Context *c, M_ModuleAttribProof *msg);
extern int NF_Free_BlobData(NF_Free_Context *c, M_BlobData *msg);
extern int NF_Free_ModuleChannelOpenInfo(NF_Free_Context *c, M_ModuleChannelOpenInfo *msg);
extern int NF_Free_ImpathKXMessage(NF_Free_Context *c, M_ImpathKXMessage *msg);
extern int NF_Free_ImpathMessage(NF_Free_Context *c, M_ImpathMessage *msg);
extern int NF_Free_ImpathCipherText(NF_Free_Context *c, M_ImpathCipherText *msg);
extern int NF_Free_SignedImage(NF_Free_Context *c, M_SignedImage *msg);
extern int NF_Free_SEECertData(NF_Free_Context *c, M_SEECertData *msg);
extern int NF_Free_HashedSignedImage(NF_Free_Context *c, M_HashedSignedImage *msg);
extern int NF_Free_CodeSignMessage(NF_Free_Context *c, M_CodeSignMessage *msg);
extern int NF_Free_SEEJobArgs(NF_Free_Context *c, M_SEEJobArgs *msg);
extern int NF_Free_SEEJobRes(NF_Free_Context *c, M_SEEJobRes *msg);
extern int NF_Free_TicketInfo(NF_Free_Context *c, M_TicketInfo *msg);
extern int NF_Free_Ticket(NF_Free_Context *c, M_Ticket *msg);
extern int NF_Free_SKYCertList(NF_Free_Context *c, M_SKYCertList *msg);
extern int NF_Free_KeyCert(NF_Free_Context *c, M_KeyCert *msg);

/* --- External dependencies --- */


/*----- That's all, folks -------------------------------------------------*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nfast\inc\messages-a-dh.h ===
/* -*-c-*-
 *
 * Generated by Marshmallow at 2003-04-16T17:13:55
 */

#ifndef MESSAGES_A_DH_H
#define MESSAGES_A_DH_H

/*----- Enumeration constants ---------------------------------------------*/

/* --- Status codes --- */

#define Status_OK                                                        0
#define Status_UnknownCommand                                            1
#define Status_NotYetImplemented                                         2
#define Status_Malformed                                                 3
#define Status_UnknownID                                                 4
#define Status_AccessDenied                                              5
#define Status_ObjectInUse                                               6
#define Status_UseLimitExceeded                                          7
#define Status_TimeLimitExceeded                                         8
#define Status_BadCertKeyHash                                            9
#define Status_BadCertSignature                                         10
#define Status_VerifyFailed                                             11
#define Status_TypeMismatch                                             12
#define Status_BadShareState                                            13
#define Status_BadTokenData                                             14
#define Status_NoMemory                                                 15
#define Status_Failed                                                   16
#define Status_UnknownParameter                                         17
#define Status_UnknownFlag                                              18
#define Status_BlobTypeUnknown                                          19
#define Status_BufferFull                                               20
#define Status_UnitReset                                                21
#define Status_ClientUnknown                                            22
#define Status_CrossModule                                              23
#define Status_InvalidParameter                                         24
#define Status_InvalidState                                             25
#define Status_InvalidModule                                            26
#define Status_TokenAssemblyFailed                                      27
#define Status_UnknownKM                                                28
#define Status_LogTokenNotPresent                                       29
#define Status_InvalidMonitorMultiple                                   30
#define Status_DecryptFailed                                            31
#define Status_WriteProtected                                           33
#define Status_OutOfRange                                               34
#define Status_PrivilegedCommand                                        35
#define Status_UnknownSlot                                              36
#define Status_UnknownKeyHash                                           37
#define Status_TokenAuthFailed                                          38
#define Status_UnknownMechanism                                         39
#define Status_NoSpaceOnToken                                           40
#define Status_TokenNotFormatted                                        41
#define Status_UnknownTokenType                                         42
#define Status_TokenIOError                                             43
#define Status_EncryptFailed                                            44
#define Status_InvalidACL                                               45
#define Status_MetaDataProtection                                       46
#define Status_PhysTokenNotPresent                                      47
#define Status_MechanismNotExpected                                     48
#define Status_UnknownDefault                                           49
#define Status_AttemptedDowngrade                                       50
#define Status_SlotFull                                                 51
#define Status_UnknownChallenge                                         52
#define Status_AsynchNotification                                       53
#define Status_InvalidData                                              54
#define Status_HardwareFailed                                           55
#define Status_ServerNotRunning                                         56
#define Status_OSErrorErrno                                             57
#define Status_TransactionNotFound                                      58
#define Status_TransactionNotYetComplete                                59
#define Status_ServerConnectionLost                                     60
#define Status_ServerFailed                                             61
#define Status_StrictFIPS140                                            62
#define Status_UnknownStatus                                            63
#define Status_Cancelled                                                64
#define Status_UnsupportedChannelType                                   65
#define Status_ArithmeticError                                          66
#define Status_OpStackOverflow                                          67
#define Status_OpStackUnderflow                                         68
#define Status_NegativeResult                                           69
#define Status_HostDataInvalid                                          70
#define Status_HostDataAccessFailed                                     71
#define Status_NoUpcall                                                 72
#define Status_NotAvailable                                             73
#define Status_MalformedCertificate                                     74
#define Status_InvalidCertificate                                       75
#define Status_ObjectNotReady                                           76
#define Status_BadMachineImage                                          77
#define Status_BadWorldImage                                            78
#define Status_SEEWorldFailed                                           79
#define Status_SoftwareFailed                                           80
#define Status_NoHostMemory                                             81
#define Status_NoModuleMemory                                           82
#define Status_IncorrectToken                                           83
#define Status_OperationFailed                                          84
#define Status_HostDataAccessDenied                                     86
#define Status_InvalidMergedKey                                         87
#define Status_AlreadyExists                                            88
#define Status_ReadOnly                                                 89
#define Status_RemoteServerFailed                                       90
#define Status_SlotUnconnected                                          91
#define Status_NSTBadMessage                                            92
#define Status_nCErrno                                                  93
#define Status_ImpathNotReady                                           94
#define Status_ImpathTimeLimitExceeded                                  95
#define Status_ImpathDataLimitExceeded                                  96
#define Status_ImpathReplay                                             97
#define Status_ImpathMsgTypeMismatch                                    98
#define Status_NoKXGroup                                                99
#define Status_ServerAccessDenied                                      100
#define Status_InProgress                                              101
#define Status_InvalidRM                                               102
#define Status_InvalidSlot                                             103
#define Status_UnknownPermID                                           104
#define Status_ForeignTokenLocked                                      105
#define Status_OperationTimeout                                        106
#define Status_SSLUnexpectedMessage                                    107
#define Status_SSLBadRecordMac                                         108
#define Status_SSLDecryptionFailed                                     109
#define Status_SSLRecordOverFlow                                       110
#define Status_SSLDecompressionFailure                                 111
#define Status_SSLHandshakeFailure                                     112
#define Status_SSLNoCertificate                                        113
#define Status_SSLBadCertificate                                       114
#define Status_SSLUnsupportedCertificate                               115
#define Status_SSLCertificateRevoked                                   116
#define Status_SSLCertificateExpired                                   117
#define Status_SSLCertificateUnknown                                   118
#define Status_SSLIllegalParameter                                     119
#define Status_SSLUnknownCA                                            120
#define Status_SSLAccessDenied                                         121
#define Status_SSLDecodeError                                          122
#define Status_SSLDecryptError                                         123
#define Status_SSLExportRestriction                                    124
#define Status_SSLProtocolVersion                                      125
#define Status_SSLInsufficientSecurity                                 126
#define Status_SSLInternalError                                        127
#define Status_SSLUserCanceled                                         128
#define Status_SSLNoRenogotiation                                      129
#define Status_UnknownKey                                              130
#define Status_UserCancelled                                           131
#define Status_KeyNotLoaded                                            132
#define Status_HostUnknownKeyType                                      133
#define Status_IncorrectRepositoryName                                 134
#define Status_InvalidHostDataIdentifier                               136

/* --- nCErrno codes --- */

#define nCErrno_UNKNOWN                                                  1
#define nCErrno_EPERM                                                    2
#define nCErrno_ENOENT                                                   3
#define nCErrno_ESRCH                                                    4
#define nCErrno_EINTR                                                    5
#define nCErrno_EIO                                                      6
#define nCErrno_ENXIO                                                    7
#define nCErrno_E2BIG                                                    8
#define nCErrno_ENOEXEC                                                  9
#define nCErrno_EBADF                                                   10
#define nCErrno_ECHILD                                                  11
#define nCErrno_EAGAIN                                                  12
#define nCErrno_ENOMEM                                                  13
#define nCErrno_EACCES                                                  14
#define nCErrno_EFAULT                                                  15
#define nCErrno_ENOTBLK                                                 16
#define nCErrno_EBUSY                                                   17
#define nCErrno_EEXIST                                                  18
#define nCErrno_EXDEV                                                   19
#define nCErrno_ENODEV                                                  20
#define nCErrno_ENOTDIR                                                 21
#define nCErrno_EISDIR                                                  22
#define nCErrno_EINVAL                                                  23
#define nCErrno_ENFILE                                                  24
#define nCErrno_EMFILE                                                  25
#define nCErrno_ENOTTY                                                  26
#define nCErrno_ETXTBSY                                                 27
#define nCErrno_EFBIG                                                   28
#define nCErrno_ENOSPC                                                  29
#define nCErrno_ESPIPE                                                  30
#define nCErrno_EROFS                                                   31
#define nCErrno_EMLINK                                                  32
#define nCErrno_EPIPE                                                   33
#define nCErrno_EDOM                                                    34
#define nCErrno_ERANGE                                                  35
#define nCErrno_EDEADLK                                                 36
#define nCErrno_ENAMETOOLONG                                            37
#define nCErrno_ENOLCK                                                  38
#define nCErrno_ENOSYS                                                  39
#define nCErrno_ENOTEMPTY                                               40
#define nCErrno_ELOOP                                                   41
#define nCErrno_EWOULDBLOCK                                             42
#define nCErrno_ENOMSG                                                  43
#define nCErrno_EIDRM                                                   44
#define nCErrno_EDEADLOCK                                               45
#define nCErrno_EREMOTE                                                 46
#define nCErrno_EOVERFLOW                                               47
#define nCErrno_EBADFD                                                  48
#define nCErrno_EILSEQ                                                  49
#define nCErrno_EUSERS                                                  50
#define nCErrno_ENOTSOCK                                                51
#define nCErrno_EDESTADDRREQ                                            52
#define nCErrno_EMSGSIZE                                                53
#define nCErrno_EPROTOTYPE                                              54
#define nCErrno_ENOPROTOOPT                                             55
#define nCErrno_EPROTONOSUPPORT                                         56
#define nCErrno_ESOCKTNOSUPPORT                                         57
#define nCErrno_EOPNOTSUPP                                              58
#define nCErrno_EPFNOSUPPORT                                            59
#define nCErrno_EAFNOSUPPORT                                            60
#define nCErrno_EADDRINUSE                                              61
#define nCErrno_EADDRNOTAVAIL                                           62
#define nCErrno_ENETDOWN                                                63
#define nCErrno_ENETUNREACH                                             64
#define nCErrno_ENETRESET                                               65
#define nCErrno_ECONNABORTED                                            66
#define nCErrno_ECONNRESET                                              67
#define nCErrno_ENOBUFS                                                 68
#define nCErrno_EISCONN                                                 69
#define nCErrno_ENOTCONN                                                70
#define nCErrno_ESHUTDOWN                                               71
#define nCErrno_ETOOMANYREFS                                            72
#define nCErrno_ETIMEDOUT                                               73
#define nCErrno_ECONNREFUSED                                            74
#define nCErrno_EHOSTDOWN                                               75
#define nCErrno_EHOSTUNREACH                                            76
#define nCErrno_EALREADY                                                77
#define nCErrno_EINPROGRESS                                             78
#define nCErrno_ESTALE                                                  79
#define nCErrno_EREMOTEIO                                               80
#define nCErrno_EDQUOT                                                  81

/* --- NetworkAddressFamily codes --- */

#define NetworkAddressFamily_INET                                        2
#define NetworkAddressFamily_INET6                                      10

/* --- CrossModReason codes --- */

#define CrossModReason_ExplicitRequest                                   1
#define CrossModReason_Key                                               2
#define CrossModReason_Mode                                              4
#define CrossModReason_HardwareFailed                                    5
#define CrossModReason_UnitReset                                         6
#define CrossModReason_ServerKey                                         7
#define CrossModReason_ServerUnitReset                                   8

/* --- SlotType codes --- */

#define SlotType_Unknown                                                 0
#define SlotType_DataKey                                                 1
#define SlotType_SmartCard                                               2
#define SlotType_Emulated                                                3
#define SlotType_SoftToken                                               4
#define SlotType_Unconnected                                             5

/* --- ChannelType codes --- */

#define ChannelType_Any                                                  0
#define ChannelType_Simple                                               1
#define ChannelType_DriverDirect                                         2

/* --- CertType codes --- */

#define CertType_Invalid                                                 0
#define CertType_SigningKey                                              1
#define CertType_SingleCert                                              2
#define CertType_SEECert                                                 3

/* --- KeyType codes --- */

#define KeyType_Any                                                      0
#define KeyType_RSAPublic                                                1
#define KeyType_RSAPrivate                                               2
#define KeyType_DSAPublic                                                3
#define KeyType_DHPublic                                                 5
#define KeyType_DHPrivate                                                6
#define KeyType_Random                                                   7
#define KeyType_DES                                                     11
#define KeyType_DES3                                                    12
#define KeyType_None                                                    13
#define KeyType_RC2                                                     14
#define KeyType_ArcFour                                                 15
#define KeyType_RC5                                                     16
#define KeyType_IDEA                                                    17
#define KeyType_CAST                                                    18
#define KeyType_DSAPrivate                                              19
#define KeyType_DSAComm                                                 20
#define KeyType_Void                                                    21
#define KeyType_Skipjack                                                22
#define KeyType_Wrapped                                                 23
#define KeyType_DKTemplate                                              24
#define KeyType_HMACMD2                                                 25
#define KeyType_HMACMD5                                                 26
#define KeyType_HMACSHA1                                                27
#define KeyType_HMACRIPEMD160                                           28
#define KeyType_Serpent                                                 29
#define KeyType_Rijndael                                                30
#define KeyType_Twofish                                                 31
#define KeyType_CAST256                                                 32
#define KeyType_Blowfish                                                33
#define KeyType_HMACSHA256                                              34
#define KeyType_HMACSHA384                                              35
#define KeyType_HMACSHA512                                              36
#define KeyType_HMACTiger                                               37
#define KeyType_SSLMasterSecret                                         38
#define KeyType_KCDSAPublic                                             39
#define KeyType_KCDSAPrivate                                            40
#define KeyType_DES2                                                    41
#define KeyType_KCDSAComm                                               42
#define KeyType_SEED                                                    43

/* --- Mech codes --- */

#define Mech_Any                                                         0
#define Mech_DESmCBCi64pPKCS5                                            1
#define Mech_RSApPKCS1                                                   2
#define Mech_DES3OldFwConf                                               3
#define Mech_RC2mCBCi64pPKCS5                                            4
#define Mech_RC5mCBCi64pPKCS5                                            5
#define Mech_RC2mECBpPKCS5                                               6
#define Mech_DESmECBpPKCS5                                               7
#define Mech_RC5mECBpPKCS5                                               9
#define Mech_DSA                                                        10
#define Mech_ArcFourpNONE                                               11
#define Mech_IDEAmCBCi64pPKCS5                                          12
#define Mech_IDEAmECBpPKCS5                                             13
#define Mech_RC2mCBCMACi64pPKCS5                                        14
#define Mech_RC5mCBCMACi64pPKCS5                                        15
#define Mech_IDEAmCBCMACi64pPKCS5                                       16
#define Mech_DESmCBCMACi64pPKCS5                                        17
#define Mech_CASTmCBCi64pPKCS5                                          19
#define Mech_CASTmECBpPKCS5                                             20
#define Mech_CASTmCBCMACi64pPKCS5                                       21
#define Mech_DESmECBpNONE                                               22
#define Mech_DESmCBCpNONE                                               24
#define Mech_DHKeyExchange                                              26
#define Mech_ElGamal                                                    27
#define Mech_IDEAmECBpNONE                                              28
#define Mech_CASTmECBpNONE                                              29
#define Mech_RC2mECBpNONE                                               30
#define Mech_RC5mECBpNONE                                               31
#define Mech_CASTmCBCpNONE                                              32
#define Mech_IDEAmCBCpNONE                                              33
#define Mech_Generic64                                                  34
#define Mech_Generic64MAC                                               35
#define Mech_RSApSETOAEP                                                36
#define Mech_DES3mCBCi64pPKCS5                                          37
#define Mech_DES3mECBpPKCS5                                             38
#define Mech_DES3mCBCMACi64pPKCS5                                       39
#define Mech_DES3mECBpNONE                                              40
#define Mech_DES3mCBCpNONE                                              41
#define Mech_RC2mCBCpNONE                                               42
#define Mech_RC5mCBCpNONE                                               43
#define Mech_SHA1Hash                                                   44
#define Mech_MD5Hash                                                    45
#define Mech_MD2Hash                                                    46
#define Mech_SkipjackmECBpNONE                                          47
#define Mech_SkipjackmECBpPKCS5                                         48
#define Mech_SkipjackmCBCpNONE                                          49
#define Mech_SkipjackmCBCi64pPKCS5                                      50
#define Mech_SkipjackmCBCMACi64pPKCS5                                   51
#define Mech_RIPEMD160Hash                                              52
#define Mech_HMACMD2                                                    53
#define Mech_HMACMD5                                                    54
#define Mech_HMACSHA1                                                   55
#define Mech_HMACRIPEMD160                                              56
#define Mech_RSAhASCIIHexSHA1pPKCS1                                     57
#define Mech_RSAhMD5pPKCS1                                              58
#define Mech_RSAhSHA1pPKCS1                                             59
#define Mech_RSAhRIPEMD160pPKCS1                                        60
#define Mech_RSApPKCS1OAEP                                              61
#define Mech_Generic128                                                 62
#define Mech_Generic128MAC                                              63
#define Mech_Generic192                                                 64
#define Mech_Generic192MAC                                              65
#define Mech_Generic256                                                 66
#define Mech_Generic256MAC                                              67
#define Mech_SerpentmCBCi128pPKCS5                                      68
#define Mech_SerpentmECBpPKCS5                                          69
#define Mech_SerpentmCBCpNONE                                           70
#define Mech_SerpentmECBpNONE                                           71
#define Mech_SerpentmCBCMACi128pPKCS5                                   72
#define Mech_RijndaelmCBCi128pPKCS5                                     73
#define Mech_RijndaelmECBpPKCS5                                         74
#define Mech_RijndaelmCBCpNONE                                          75
#define Mech_RijndaelmECBpNONE                                          76
#define Mech_RijndaelmCBCMACi128pPKCS5                                  77
#define Mech_TwofishmCBCi128pPKCS5                                      78
#define Mech_TwofishmECBpPKCS5                                          79
#define Mech_TwofishmCBCpNONE                                           80
#define Mech_TwofishmECBpNONE                                           81
#define Mech_TwofishmCBCMACi128pPKCS5                                   82
#define Mech_CAST256mCBCi128pPKCS5                                      83
#define Mech_CAST256mECBpPKCS5                                          84
#define Mech_CAST256mCBCpNONE                                           85
#define Mech_CAST256mECBpNONE                                           86
#define Mech_CAST256mCBCMACi128pPKCS5                                   87
#define Mech_BlowfishmCBCi64pPKCS5                                      88
#define Mech_BlowfishmECBpPKCS5                                         89
#define Mech_BlowfishmCBCpNONE                                          90
#define Mech_BlowfishmECBpNONE                                          91
#define Mech_BlowfishmCBCMACi64pPKCS5                                   92
#define Mech_SHA256Hash                                                 93
#define Mech_SHA384Hash                                                 94
#define Mech_SHA512Hash                                                 95
#define Mech_TigerHash                                                  96
#define Mech_HMACSHA256                                                 97
#define Mech_HMACSHA384                                                 98
#define Mech_HMACSHA512                                                 99
#define Mech_HMACTiger                                                 100
#define Mech_Imech                                                     101
#define Mech_DES3wSHA1                                                 102
#define Mech_DES3wCRC32                                                103
#define Mech_DES3AltwSHA1                                              104
#define Mech_DES3AltwCRC32                                             105
#define Mech_SSLRecordLayer                                            106
#define Mech_SSL3FinishedMsg                                           107
#define Mech_TLSFinishedMsg                                            108
#define Mech_HAS160Hash                                                109
#define Mech_KCDSAHAS160                                               110
#define Mech_KCDSASHA1                                                 111
#define Mech_KCDSARIPEMD160                                            112
#define Mech_DES2mCBCi64pPKCS5                                         113
#define Mech_DES2mCBCpNONE                                             114
#define Mech_DES2mECBpPKCS5                                            115
#define Mech_DES2mCBCMACi64pPKCS5                                      116
#define Mech_DES2mECBpNONE                                             117
#define Mech_RSApPKCS1pPKCS11                                          118
#define Mech_SEEDmECBpNONE                                             119
#define Mech_SEEDmECBpPKCS5                                            120
#define Mech_SEEDmCBCpNONE                                             121
#define Mech_SEEDmCBCi128pPKCS5                                        122
#define Mech_SEEDmCBCMACi128pPKCS5                                     123
#define Mech_DLIESe3DEShSHA1                                           124
#define Mech_DLIESeAEShSHA1                                            125

/* --- SSLCipherSuite codes --- */

#define SSLCipherSuite_SSL3_NULL_MD5                                     1
#define SSLCipherSuite_SSL3_NULL_SHA                                     2
#define SSLCipherSuite_SSL3_RC4_40_MD5                                   3
#define SSLCipherSuite_SSL3_RC4_128_MD5                                  4
#define SSLCipherSuite_SSL3_RC4_128_SHA                                  5
#define SSLCipherSuite_SSL3_DES_40_SHA                                   8
#define SSLCipherSuite_SSL3_DES_SHA                                      9
#define SSLCipherSuite_SSL3_DES3_SHA                                    10
#define SSLCipherSuite_TLS_NULL_MD5                                     17
#define SSLCipherSuite_TLS_NULL_SHA                                     18
#define SSLCipherSuite_TLS_RC4_40_MD5                                   19
#define SSLCipherSuite_TLS_RC4_128_MD5                                  20
#define SSLCipherSuite_TLS_RC4_128_SHA                                  21
#define SSLCipherSuite_TLS_DES_40_SHA                                   24
#define SSLCipherSuite_TLS_DES_SHA                                      25
#define SSLCipherSuite_TLS_DES3_SHA                                     26

/* --- ImpathKXGroup codes --- */

#define ImpathKXGroup_DHPrime1024                                        1

/* --- PlainTextType codes --- */

#define PlainTextType_Bytes                                              1
#define PlainTextType_Hash                                               2
#define PlainTextType_Bignum                                             3
#define PlainTextType_Hash16                                             4

/* --- DeriveMech codes --- */

#define DeriveMech_Any                                                   0
#define DeriveMech_DESsplitXOR                                           1
#define DeriveMech_DESjoinXOR                                            2
#define DeriveMech_DES3splitXOR                                          3
#define DeriveMech_DES3joinXOR                                           4
#define DeriveMech_DESjoinXORsetParity                                   5
#define DeriveMech_DES3joinXORsetParity                                  6
#define DeriveMech_RandsplitXOR                                          7
#define DeriveMech_RandjoinXOR                                           8
#define DeriveMech_CASTsplitXOR                                          9
#define DeriveMech_CASTjoinXOR                                          10
#define DeriveMech_EncryptMarshalled                                    11
#define DeriveMech_DecryptMarshalled                                    12
#define DeriveMech_SSL3withRSA                                          13
#define DeriveMech_TLSwithRSA                                           14
#define DeriveMech_SSL3withDH                                           15
#define DeriveMech_TLSwithDH                                            16
#define DeriveMech_RawEncrypt                                           17
#define DeriveMech_RawDecrypt                                           18
#define DeriveMech_DES2splitXOR                                         19
#define DeriveMech_DES2joinXOR                                          20
#define DeriveMech_DES2joinXORsetParity                                 21
#define DeriveMech_PKCS8Encrypt                                         22
#define DeriveMech_PKCS8Decrypt                                         23
#define DeriveMech_RSAComponents                                        24

/* --- Cmd codes --- */

#define Cmd_ErrorReturn                                                  0
#define Cmd_ModExp                                                       1
#define Cmd_ModExpCrt                                                    2
#define Cmd_ModExpCrtPar                                                 3
#define Cmd_GeneratePrime                                                5
#define Cmd_OldEnquiry                                                   6
#define Cmd_OldClearUnit                                                 7
#define Cmd_GenerateRandom                                               8
#define Cmd_GenerateKey                                                  9
#define Cmd_GenerateKeyPair                                             10
#define Cmd_Import                                                      11
#define Cmd_Duplicate                                                   12
#define Cmd_GetKeyInfo                                                  13
#define Cmd_Destroy                                                     14
#define Cmd_Encrypt                                                     15
#define Cmd_Decrypt                                                     16
#define Cmd_Verify                                                      17
#define Cmd_Export                                                      18
#define Cmd_GetAppData                                                  19
#define Cmd_SetAppData                                                  20
#define Cmd_NewClient                                                   21
#define Cmd_ExistingClient                                              22
#define Cmd_GetWhichModule                                              23
#define Cmd_MergeKeyIDs                                                 24
#define Cmd_GenerateLogicalToken                                        26
#define Cmd_WriteShare                                                  27
#define Cmd_GetSlotList                                                 28
#define Cmd_GetSlotInfo                                                 29
#define Cmd_ReadShare                                                   30
#define Cmd_OldExtEnquiry                                               31
#define Cmd_LoadBlob                                                    32
#define Cmd_OldMakeBlob                                                 33
#define Cmd_LoadLogicalToken                                            34
#define Cmd_EraseShare                                                  35
#define Cmd_ChangeSharePIN                                              36
#define Cmd_WriteFile                                                   37
#define Cmd_ReadFile                                                    38
#define Cmd_EraseFile                                                   39
#define Cmd_ProgrammingBegin                                            40
#define Cmd_ProgrammingBeginChunk                                       41
#define Cmd_ProgrammingLoadBlock                                        42
#define Cmd_ProgrammingEndChunk                                         43
#define Cmd_ProgrammingEnd                                              44
#define Cmd_FormatToken                                                 45
#define Cmd_SetKNSO                                                     46
#define Cmd_SetKM                                                       47
#define Cmd_RemoveKM                                                    48
#define Cmd_GetKMList                                                   49
#define Cmd_InitialiseUnit                                              50
#define Cmd_Maintenance                                                 51
#define Cmd_Fail                                                        52
#define Cmd_NewEnquiry                                                  53
#define Cmd_NoOp                                                        54
#define Cmd_Sign                                                        55
#define Cmd_ModuleInfo                                                  56
#define Cmd_ProgrammingGetKeyList                                       57
#define Cmd_InsertSoftToken                                             58
#define Cmd_RemoveSoftToken                                             59
#define Cmd_GetChallenge                                                60
#define Cmd_ANModuleReset                                               61
#define Cmd_MakeBlob                                                    62
#define Cmd_GetLogicalTokenInfo                                         63
#define Cmd_GetKML                                                      64
#define Cmd_ANReadTerminated                                            65
#define Cmd_ANPleaseClearUnitSoon                                       66
#define Cmd_ANPleaseClearUnitNow                                        67
#define Cmd_PauseForNotifications                                       68
#define Cmd_Hash                                                        69
#define Cmd_ClearUnit                                                   70
#define Cmd_ChannelOpen                                                 71
#define Cmd_ChannelUpdate                                               72
#define Cmd_GetACL                                                      73
#define Cmd_SetACL                                                      74
#define Cmd_DeriveKey                                                   75
#define Cmd_RetryFailedModule                                           76
#define Cmd_BignumOp                                                    77
#define Cmd_RSAImmedSignDecrypt                                         78
#define Cmd_RSAImmedVerifyEncrypt                                       79
#define Cmd_StatEnumTree                                                80
#define Cmd_StatGetValues                                               81
#define Cmd_LoadRaw                                                     87
#define Cmd_NVMemAlloc                                                  88
#define Cmd_NVMemList                                                   89
#define Cmd_NVMemOp                                                     90
#define Cmd_NVMemFree                                                   91
#define Cmd_GetRTC                                                      92
#define Cmd_SetRTC                                                      93
#define Cmd_CreateSEEWorld                                              94
#define Cmd_SEEJob                                                      95
#define Cmd_CreateBuffer                                                96
#define Cmd_LoadBuffer                                                  97
#define Cmd_SetSEEMachine                                               98
#define Cmd_TraceSEEWorld                                               99
#define Cmd_GetTicket                                                  100
#define Cmd_RedeemTicket                                               101
#define Cmd_SetNSOPerms                                                102
#define Cmd_PollModuleState                                            103
#define Cmd_PollSlotList                                               104
#define Cmd_ANModuleChangeEvent                                        105
#define Cmd_ANSlotChangeEvent                                          106
#define Cmd_ImpathKXBegin                                              107
#define Cmd_ImpathKXFinish                                             108
#define Cmd_ImpathGetInfo                                              109
#define Cmd_ImpathSend                                                 110
#define Cmd_ImpathReceive                                              111
#define Cmd_SendShare                                                  112
#define Cmd_ReceiveShare                                               113
#define Cmd_ImportSlot                                                 119
#define Cmd_UnimportSlot                                               120
#define Cmd_ExportSlot                                                 121
#define Cmd_ServerSendShare                                            122
#define Cmd_GetClientHash                                              123
#define Cmd_UpdateMergedKey                                            124
#define Cmd_GetWorldSigners                                            125
#define Cmd_ForeignTokenOpen                                           126
#define Cmd_ForeignTokenCmd                                            127
#define Cmd_GetKeyInfoEx                                               129
#define Cmd_FirmwareAuthenticate                                       130
#define Cmd_SignModuleState                                            131
#define Cmd_GenerateKLF                                                132
#define Cmd_GetKLF                                                     133
#define Cmd_AddRemoteServerPermission                                  134
#define Cmd_RemoveRemoteServerPermission                               135
#define Cmd_ListRemoteServerPermission                                 136
#define Cmd_ANRemoteSlotDisconnected                                   137
#define Cmd_GetLogicalTokenInfoEx                                      138
#define Cmd_GetShareACL                                                139
#define Cmd_StaticFeatureEnable                                        140
#define Cmd_CheckUserAction                                            142

/* --- PhysTokenType codes --- */

#define PhysTokenType_Invalid                                            0
#define PhysTokenType_ISO7816                                            1

/* --- BlobFormat codes --- */

#define BlobFormat_Module                                                5
#define BlobFormat_Token                                                 6
#define BlobFormat_Direct                                                7
#define BlobFormat_Indirect                                              8

/* --- RemoteServerOp codes --- */

#define RemoteServerOp_All                                               1
#define RemoteServerOp_ExportSlot                                        2

/* --- TicketDestination codes --- */

#define TicketDestination_Any                                            0
#define TicketDestination_AnyClient                                      1
#define TicketDestination_NamedClient                                    2
#define TicketDestination_AnySEEWorld                                    3
#define TicketDestination_NamedSEEWorld                                  4

/* --- ChannelMode codes --- */

#define ChannelMode_Encrypt                                              1
#define ChannelMode_Decrypt                                              2
#define ChannelMode_Sign                                                 3
#define ChannelMode_Verify                                               4

/* --- NVMemOpType codes --- */

#define NVMemOpType_Read                                                 1
#define NVMemOpType_Write                                                2
#define NVMemOpType_Incr                                                 3
#define NVMemOpType_Decr                                                 4
#define NVMemOpType_BitSet                                               5
#define NVMemOpType_BitClear                                             6
#define NVMemOpType_Free                                                 7
#define NVMemOpType_IncrRead                                             8
#define NVMemOpType_DecrRead                                             9
#define NVMemOpType_BitSetRead                                          10
#define NVMemOpType_BitClearRead                                        11
#define NVMemOpType_GetACL                                              12

/* --- FwAuthType codes --- */

#define FwAuthType_NFFHMAC1                                              1
#define FwAuthType_PRNG1                                                 2

/* --- SignerType codes --- */

#define SignerType_KLF                                                   1
#define SignerType_KML                                                   2
#define SignerType_AppKey                                                3

/* --- StackOp codes --- */

#define StackOp_NoOp                                                     0
#define StackOp_Add                                                      1
#define StackOp_Sub                                                      2
#define StackOp_RSub                                                     3
#define StackOp_Mul                                                      4
#define StackOp_Div                                                      5
#define StackOp_Mod                                                      6
#define StackOp_DivMod                                                   7
#define StackOp_ModExp                                                   8
#define StackOp_ModInv                                                   9
#define StackOp_Dup                                                     10
#define StackOp_Drop                                                    11
#define StackOp_Rot                                                     12
#define StackOp_Set                                                     13
#define StackOp_Test                                                    14
#define StackOp_TestPrime                                               15
#define StackOp_Neg                                                     16
#define StackOp_Abs                                                     17
#define StackOp_GCD                                                     18
#define StackOp_LCM                                                     19

/* --- ModuleAttribTag codes --- */

#define ModuleAttribTag_None                                             0
#define ModuleAttribTag_Challenge                                        1
#define ModuleAttribTag_ESN                                              2
#define ModuleAttribTag_KML                                              3
#define ModuleAttribTag_KLF                                              4
#define ModuleAttribTag_KNSO                                             5
#define ModuleAttribTag_KMList                                           6
#define ModuleAttribTag_PhysSerial                                       7
#define ModuleAttribTag_PhysFIPSl3                                       8
#define ModuleAttribTag_FeatureGoldCert                                  9
#define ModuleAttribTag_Enquiry                                         10
#define ModuleAttribTag_AdditionalInfo                                  11

/* --- FeatureGoldCertVendor codes --- */

#define FeatureGoldCertVendor_VeriSign                                   1
#define FeatureGoldCertVendor_InternalTestingOnly                        2

/* --- ModuleType codes --- */

#define ModuleType_None                                                  0
#define ModuleType_Clyde                                                 2
#define ModuleType_Chili                                                 4
#define ModuleType_Ariel                                                 5
#define ModuleType_Persil                                                6
#define ModuleType_Dorris                                                7
#define ModuleType_Morris                                                8
#define ModuleType_Unknown                                             999

/* --- UseLim codes --- */

#define UseLim_Global                                                    1
#define UseLim_Auth                                                      2
#define UseLim_Time                                                      3
#define UseLim_NonVolatile                                               4

/* --- Act codes --- */

#define Act_NoAction                                                     0
#define Act_OpPermissions                                                1
#define Act_MakeBlob                                                     2
#define Act_MakeArchiveBlob                                              3
#define Act_NSOPermissions                                               4
#define Act_DeriveKey                                                    5
#define Act_NVMemOpPerms                                                 6
#define Act_FeatureEnable                                                7
#define Act_NVMemUseLimit                                                8
#define Act_SendShare                                                    9
#define Act_ReadShare                                                   10
#define Act_StaticFeatureEnable                                         11
#define Act_UserAction                                                  12

/* --- DeriveRole codes --- */

#define DeriveRole_TemplateKey                                           0
#define DeriveRole_BaseKey                                               1
#define DeriveRole_WrapKey                                               2

/* --- OldExtEnqVer codes --- */

#define OldExtEnqVer_Zero                                                0
#define OldExtEnqVer_One                                                 1

/* --- LogTokenState codes --- */

#define LogTokenState_Present                                            1
#define LogTokenState_Reading                                            2
#define LogTokenState_Writing                                            3
#define LogTokenState_TokenAssemblyFailed                                5
#define LogTokenState_PhysTokenNotPresent                                6
#define LogTokenState_TimeLimitExceeded                                  7

/* --- ImpathState codes --- */

#define ImpathState_Exchange                                             1
#define ImpathState_UpAndRunning                                         2
#define ImpathState_Expired                                              3

/* --- EnqVer codes --- */

#define EnqVer_Zero                                                      0
#define EnqVer_One                                                       1
#define EnqVer_Two                                                       2
#define EnqVer_Three                                                     3
#define EnqVer_Four                                                      4
#define EnqVer_Five                                                      5
#define EnqVer_Six                                                       6

/* --- InfoFormat codes --- */

#define InfoFormat_HardwareRev1                                          1
#define InfoFormat_HardwareRev2                                          2

/* --- LogTokenShareState codes --- */

#define LogTokenShareState_OK                                            1
#define LogTokenShareState_NotYetWritten                                 2
#define LogTokenShareState_NotYetRead                                    3

/* --- StatID codes --- */

#define StatID_Uptime                                                    1
#define StatID_CmdCount                                                  2
#define StatID_ReplyCount                                                3
#define StatID_CmdBytes                                                  4
#define StatID_ReplyBytes                                                5
#define StatID_CmdMarshalErrors                                          6
#define StatID_ReplyMarshalErrors                                        7
#define StatID_HostWriteCount                                            8
#define StatID_HostWriteErrors                                           9
#define StatID_HostWriteOverruns                                        10
#define StatID_HostWriteNoMemory                                        11
#define StatID_HostReadCount                                            12
#define StatID_HostReadErrors                                           13
#define StatID_HostReadEmpty                                            14
#define StatID_HostReadUnderruns                                        15
#define StatID_HostReadDeferred                                         16
#define StatID_HostReadTerminated                                       17
#define StatID_PFNIssued                                                19
#define StatID_PFNRejected                                              20
#define StatID_PFNCompleted                                             21
#define StatID_ANIssued                                                 22
#define StatID_ChanJobsIssued                                           23
#define StatID_ChanJobsCompleted                                        24
#define StatID_CPULoadPercent                                           25
#define StatID_HostIRQs                                                 26
#define StatID_ChanJobErrors                                            27
#define StatID_HostDebugIRQs                                            28
#define StatID_HostUnhandledIRQs                                        29
#define StatID_HostReadReconnect                                        30
#define StatID_SCSIConnections                                          31
#define StatID_SCSICommands                                             32
#define StatID_SCSIInquiries                                            33
#define StatID_SCSIDisconnects                                          34
#define StatID_SCSIReconnects                                           35
#define StatID_SCSILUN0Use                                              36
#define StatID_SCSILUN1Use                                              37
#define StatID_SCSICmdErrors                                            38
#define StatID_SCSIBusResets                                            39
#define StatID_SCSICtrlErrors                                           40
#define StatID_SCSITagQUse                                              41
#define StatID_SCSIReconFailures                                        42
#define StatID_HostWriteBadData                                         43
#define StatID_ClientCount                                              44
#define StatID_MaxClients                                               45
#define StatID_QOutstanding                                             46
#define StatID_DeviceFails                                              47
#define StatID_DeviceRestarts                                           48
#define StatID_DevOutstanding                                           49
#define StatID_ObjectsCreated                                           50
#define StatID_ObjectsDestroyed                                         51
#define StatID_ObjectCount                                              52
#define StatID_SCSIWideNeg                                              53
#define StatID_SCSISyncNeg                                              54
#define StatID_CurrentTempC                                             55
#define StatID_MaxTempC                                                 56
#define StatID_MinTempC                                                 57
#define StatID_MemTotal                                                 58
#define StatID_MemAllocKernel                                           59
#define StatID_MemAllocUser                                             60
#define StatID_ReservedMax                                            1000

/* --- BusType codes --- */

#define BusType_SCSI                                                     0
#define BusType_PCI                                                      1
#define BusType_USB                                                      2
#define BusType_Local                                                    3
#define BusType_Serial                                                   4
#define BusType_I2C                                                      5
#define BusType_OneWire                                                  6
#define BusType_XBus                                                     7
#define BusType_PS2                                                      8

/* --- ProgSigDatFormat codes --- */

#define ProgSigDatFormat_Two                                             2

/* --- FirmwareFileType codes --- */

#define FirmwareFileType_OldNFast1                                       1
#define FirmwareFileType_NFast2                                          2
#define FirmwareFileType_NFast3                                          3
#define FirmwareFileType_TestVectors                                     4

/* --- FTVType codes --- */

#define FTVType_PRNG1                                                    2

/* --- MagicValue codes --- */

#define MagicValue_CertMsgFooter                                 588742808
#define MagicValue_KeyCertFooter                                1015097956
#define MagicValue_KeyCertHeader                                1256304304
#define MagicValue_CodeMsgHeader                                1336710885
#define MagicValue_CodeMsgFooter                                1601734260
#define MagicValue_CertMsgHeader                                1979675204

/* --- ModCertType codes --- */

#define ModCertType_OldKeyGen                                            1
#define ModCertType_KeyGen                                               2
#define ModCertType_ImpathKX                                             3
#define ModCertType_StateCert                                            4
#define ModCertType_KWARv0                                               5

/* --- ImpathMsgType codes --- */

#define ImpathMsgType_UserData                                           1
#define ImpathMsgType_Share                                              2

/* --- CodeAttribTag codes --- */

#define CodeAttribTag_IsSEEMachine                                       1
#define CodeAttribTag_IsSEEWorld                                         2

/* --- SEEMachineType codes --- */

#define SEEMachineType_None                                              0
#define SEEMachineType_gen1AIF                                           1
#define SEEMachineType_PowerPCSXF                                        2

/* --- SEEOpType codes --- */

#define SEEOpType_JavaSEECmdInstantiateObject                            1
#define SEEOpType_JavaSEECmdInvokeMethod                                 2
#define SEEOpType_JavaSEECmdDeleteObject                                 3
#define SEEOpType_JavaSEECmdError                                        4

/* --- TicketType codes --- */

#define TicketType_Invalid                                               0
#define TicketType_Hardserver                                            1
#define TicketType_Module                                                2

/* --- KeyCertType codes --- */

#define KeyCertType_NextSigner                                           1
#define KeyCertType_AppSigner                                            2

/* --- StatNodeTag codes --- */

#define StatNodeTag_ServerGlobals                                        1
#define StatNodeTag_Connections                                          2
#define StatNodeTag_PerModule                                            3
#define StatNodeTag_ModuleJobStats                                       4
#define StatNodeTag_ModuleSCSIStats                                      5
#define StatNodeTag_ModulePCIStats                                       6
#define StatNodeTag_ModuleObjStats                                       7
#define StatNodeTag_ModuleEnvStats                                       8
#define StatNodeTag_ReservedMax                                       1000

/* --- TestVal codes --- */

#define TestVal_LT                                                       1
#define TestVal_EQ                                                       2
#define TestVal_LE                                                       3
#define TestVal_GT                                                       4
#define TestVal_NE                                                       5
#define TestVal_GE                                                       6

/* --- SEEInitStatus codes --- */

#define SEEInitStatus_OK                                                 0
#define SEEInitStatus_MachineFailed                                      1
#define SEEInitStatus_JavaMalformedJAR                                   2
#define SEEInitStatus_InvalidCertificate                                 3

/*----- Flag constants ----------------------------------------------------*/

/* --- Status_RemoteServerFailed_ErrorInfo_flags --- */

#define Status_RemoteServerFailed_ErrorInfo_flags_addr_present  0x00000001
#define Status_RemoteServerFailed_ErrorInfo_flags__reserved     0xffff0000
#define Status_RemoteServerFailed_ErrorInfo_flags__allflags     0x00000001
#define Status_RemoteServerFailed_ErrorInfo_flags__presentflags 0x00000001

/* --- Mech_SSLRecordLayer_IV_flags --- */

#define Mech_SSLRecordLayer_IV_flags_IsClient                   0x00000001
#define Mech_SSLRecordLayer_IV_flags__reserved                  0xffff0000
#define Mech_SSLRecordLayer_IV_flags__allflags                  0x00000001
#define Mech_SSLRecordLayer_IV_flags__presentflags              0x00000000

/* --- KeyType_Wrapped_GenParams_flags --- */

#define KeyType_Wrapped_GenParams_flags__reserved               0xffff0000
#define KeyType_Wrapped_GenParams_flags__allflags               0x00000000
#define KeyType_Wrapped_GenParams_flags__presentflags           0x00000000

/* --- KeyType_DSAPrivate_GenParams_flags --- */

#define KeyType_DSAPrivate_GenParams_flags_dlg_present          0x00000001
#define KeyType_DSAPrivate_GenParams_flags_Strict               0x00000002
#define KeyType_DSAPrivate_GenParams_flags__allflags            0x00000003
#define KeyType_DSAPrivate_GenParams_flags__presentflags        0x00000001

/* --- KeyType_DHPrivate_GenParams_flags --- */

#define KeyType_DHPrivate_GenParams_flags_dlg_present           0x00000001
#define KeyType_DHPrivate_GenParams_flags__allflags             0x00000001
#define KeyType_DHPrivate_GenParams_flags__presentflags         0x00000001

/* --- KeyType_KCDSAPrivate_GenParams_flags --- */

#define KeyType_KCDSAPrivate_GenParams_flags_dlg_present        0x00000001
#define KeyType_KCDSAPrivate_GenParams_flags__allflags          0x00000001
#define KeyType_KCDSAPrivate_GenParams_flags__presentflags      0x00000001

/* --- KeyType_RSAPrivate_GenParams_flags --- */

#define KeyType_RSAPrivate_GenParams_flags_given_e_present      0x00000001
#define KeyType_RSAPrivate_GenParams_flags_nchecks_present      0x00000002
#define KeyType_RSAPrivate_GenParams_flags_UseStrongPrimes      0x00000004
#define KeyType_RSAPrivate_GenParams_flags__allflags            0x00000007
#define KeyType_RSAPrivate_GenParams_flags__presentflags        0x00000003

/* --- KeyType_KCDSAComm_GenParams_flags --- */

#define KeyType_KCDSAComm_GenParams_flags_iv_present            0x00000001
#define KeyType_KCDSAComm_GenParams_flags__allflags             0x00000001
#define KeyType_KCDSAComm_GenParams_flags__presentflags         0x00000001

/* --- KeyType_DSAComm_GenParams_flags --- */

#define KeyType_DSAComm_GenParams_flags_iv_present              0x00000001
#define KeyType_DSAComm_GenParams_flags__allflags               0x00000001
#define KeyType_DSAComm_GenParams_flags__presentflags           0x00000001

/* --- Command_flags --- */

#define Command_flags_BignumMSBitFirst                          0x00000001
#define Command_flags_BignumMSWordFirst                         0x00000002
#define Command_flags_certs_present                             0x00000004
#define Command_flags__reserved                                 0xffff0000
#define Command_flags__allflags                                 0x00000007
#define Command_flags__presentflags                             0x00000004

/* --- Cmd_BignumOp_Args_flags --- */

#define Cmd_BignumOp_Args_flags_AllowNegative                   0x00000001
#define Cmd_BignumOp_Args_flags__reserved                       0xffff0000
#define Cmd_BignumOp_Args_flags__allflags                       0x00000001
#define Cmd_BignumOp_Args_flags__presentflags                   0x00000000

/* --- Cmd_Encrypt_Args_flags --- */

#define Cmd_Encrypt_Args_flags_given_iv_present                 0x00000001
#define Cmd_Encrypt_Args_flags__reserved                        0xffff0000
#define Cmd_Encrypt_Args_flags__allflags                        0x00000001
#define Cmd_Encrypt_Args_flags__presentflags                    0x00000001

/* --- Cmd_GetRTC_Args_flags --- */

#define Cmd_GetRTC_Args_flags__allflags                         0x00000000
#define Cmd_GetRTC_Args_flags__presentflags                     0x00000000

/* --- Cmd_UnimportSlot_Args_flags --- */

#define Cmd_UnimportSlot_Args_flags__reserved                   0xffff0000
#define Cmd_UnimportSlot_Args_flags__allflags                   0x00000000
#define Cmd_UnimportSlot_Args_flags__presentflags               0x00000000

/* --- Cmd_ChangeSharePIN_Args_flags --- */

#define Cmd_ChangeSharePIN_Args_flags_oldpin_present            0x00000001
#define Cmd_ChangeSharePIN_Args_flags_newpin_present            0x00000002
#define Cmd_ChangeSharePIN_Args_flags__reserved                 0xffff0000
#define Cmd_ChangeSharePIN_Args_flags__allflags                 0x00000003
#define Cmd_ChangeSharePIN_Args_flags__presentflags             0x00000003

/* --- Cmd_ImportSlot_Args_flags --- */

#define Cmd_ImportSlot_Args_flags__reserved                     0xffff0000
#define Cmd_ImportSlot_Args_flags__allflags                     0x00000000
#define Cmd_ImportSlot_Args_flags__presentflags                 0x00000000

/* --- RemoteModule_flags --- */

#define RemoteModule_flags_ma_present                           0x00000001
#define RemoteModule_flags_addr_present                         0x00000002
#define RemoteModule_flags_hks_present                          0x00000004
#define RemoteModule_flags_groups_present                       0x00000008
#define RemoteModule_flags_agelimit_present                     0x00000010
#define RemoteModule_flags_datalimit_present                    0x00000020
#define RemoteModule_flags__allflags                            0x0000003f
#define RemoteModule_flags__presentflags                        0x0000003f

/* --- Cmd_ReceiveShare_Args_flags --- */

#define Cmd_ReceiveShare_Args_flags_pin_present                 0x00000001
#define Cmd_ReceiveShare_Args_flags__allflags                   0x00000001
#define Cmd_ReceiveShare_Args_flags__presentflags               0x00000001

/* --- Cmd_ForeignTokenCmd_Args_flags --- */

#define Cmd_ForeignTokenCmd_Args_flags__reserved                0xffff0000
#define Cmd_ForeignTokenCmd_Args_flags__allflags                0x00000000
#define Cmd_ForeignTokenCmd_Args_flags__presentflags            0x00000000

/* --- Cmd_MakeBlob_Args_flags --- */

#define Cmd_MakeBlob_Args_flags_acl_present                     0x00000001
#define Cmd_MakeBlob_Args_flags__reserved                       0xffff0000
#define Cmd_MakeBlob_Args_flags__allflags                       0x00000001
#define Cmd_MakeBlob_Args_flags__presentflags                   0x00000001

/* --- Cmd_RemoveKM_Args_flags --- */

#define Cmd_RemoveKM_Args_flags__reserved                       0xffff0000
#define Cmd_RemoveKM_Args_flags__allflags                       0x00000000
#define Cmd_RemoveKM_Args_flags__presentflags                   0x00000000

/* --- TokenParams_flags --- */

#define TokenParams_flags_AllTokensRemovable                    0x00000001
#define TokenParams_flags_AllButOneRemovable                    0x00000002
#define TokenParams_flags_AllowSoftSlots                        0x00000004
#define TokenParams_flags__reserved                             0xffff0000
#define TokenParams_flags__allflags                             0x00000007
#define TokenParams_flags__presentflags                         0x00000000

/* --- Cmd_ImpathSend_Args_flags --- */

#define Cmd_ImpathSend_Args_flags__reserved                     0xffff0000
#define Cmd_ImpathSend_Args_flags__allflags                     0x00000000
#define Cmd_ImpathSend_Args_flags__presentflags                 0x00000000

/* --- Cmd_SetSEEMachine_Args_flags --- */

#define Cmd_SetSEEMachine_Args_flags__reserved                  0xffff0000
#define Cmd_SetSEEMachine_Args_flags__allflags                  0x00000000
#define Cmd_SetSEEMachine_Args_flags__presentflags              0x00000000

/* --- Cmd_GetKeyInfoEx_Args_flags --- */

#define Cmd_GetKeyInfoEx_Args_flags__reserved                   0xffff0000
#define Cmd_GetKeyInfoEx_Args_flags__allflags                   0x00000000
#define Cmd_GetKeyInfoEx_Args_flags__presentflags               0x00000000

/* --- Cmd_ReadFile_Args_flags --- */

#define Cmd_ReadFile_Args_flags__reserved                       0xffff0000
#define Cmd_ReadFile_Args_flags__allflags                       0x00000000
#define Cmd_ReadFile_Args_flags__presentflags                   0x00000000

/* --- FileInfo_flags --- */

#define FileInfo_flags__reserved                                0xffff0000
#define FileInfo_flags__allflags                                0x00000000
#define FileInfo_flags__presentflags                            0x00000000

/* --- Cmd_GetKMList_Args_flags --- */

#define Cmd_GetKMList_Args_flags__reserved                      0xffff0000
#define Cmd_GetKMList_Args_flags__allflags                      0x00000000
#define Cmd_GetKMList_Args_flags__presentflags                  0x00000000

/* --- Cmd_OldEnquiry_Args_flags --- */

#define Cmd_OldEnquiry_Args_flags_module_present                0x00000001
#define Cmd_OldEnquiry_Args_flags__allflags                     0x00000001
#define Cmd_OldEnquiry_Args_flags__presentflags                 0x00000001

/* --- Cmd_InsertSoftToken_Args_flags --- */

#define Cmd_InsertSoftToken_Args_flags__reserved                0xffff0000
#define Cmd_InsertSoftToken_Args_flags__allflags                0x00000000
#define Cmd_InsertSoftToken_Args_flags__presentflags            0x00000000

/* --- Cmd_WriteFile_Args_flags --- */

#define Cmd_WriteFile_Args_flags__reserved                      0xffff0000
#define Cmd_WriteFile_Args_flags__allflags                      0x00000000
#define Cmd_WriteFile_Args_flags__presentflags                  0x00000000

/* --- Cmd_WriteShare_Args_flags --- */

#define Cmd_WriteShare_Args_flags_pin_present                   0x00000001
#define Cmd_WriteShare_Args_flags_UseProtectedPINPath           0x00000002
#define Cmd_WriteShare_Args_flags_acl_present                   0x00000004
#define Cmd_WriteShare_Args_flags__reserved                     0xffff0000
#define Cmd_WriteShare_Args_flags__allflags                     0x00000007
#define Cmd_WriteShare_Args_flags__presentflags                 0x00000005

/* --- NSOPerms_ops --- */

#define NSOPerms_ops_LoadLogicalToken                           0x00000001
#define NSOPerms_ops_ReadFile                                   0x00000002
#define NSOPerms_ops_WriteShare                                 0x00000004
#define NSOPerms_ops_WriteFile                                  0x00000008
#define NSOPerms_ops_EraseShare                                 0x00000010
#define NSOPerms_ops_EraseFile                                  0x00000020
#define NSOPerms_ops_FormatToken                                0x00000040
#define NSOPerms_ops_SetKM                                      0x00000080
#define NSOPerms_ops_RemoveKM                                   0x00000100
#define NSOPerms_ops_GenerateLogToken                           0x00000200
#define NSOPerms_ops_ChangeSharePIN                             0x00000400
#define NSOPerms_ops_OriginateKey                               0x00000800
#define NSOPerms_ops_NVMemAlloc                                 0x00001000
#define NSOPerms_ops_NVMemFree                                  0x00002000
#define NSOPerms_ops_GetRTC                                     0x00004000
#define NSOPerms_ops_SetRTC                                     0x00008000
#define NSOPerms_ops_DebugSEEWorld                              0x00010000
#define NSOPerms_ops_SendShare                                  0x00020000
#define NSOPerms_ops_ForeignTokenOpen                           0x00040000
#define NSOPerms_ops__reserved                                  0xfffff000
#define NSOPerms_ops__allflags                                  0x0007ffff
#define NSOPerms_ops__presentflags                              0x00000000

/* --- Cmd_LoadRaw_Args_flags --- */

#define Cmd_LoadRaw_Args_flags_StartChunk                       0x00000001
#define Cmd_LoadRaw_Args_flags_EndChunk                         0x00000002
#define Cmd_LoadRaw_Args_flags__allflags                        0x00000003
#define Cmd_LoadRaw_Args_flags__presentflags                    0x00000000

/* --- Cmd_GetLogicalTokenInfoEx_Args_flags --- */

#define Cmd_GetLogicalTokenInfoEx_Args_flags__reserved          0xffff0000
#define Cmd_GetLogicalTokenInfoEx_Args_flags__allflags          0x00000000
#define Cmd_GetLogicalTokenInfoEx_Args_flags__presentflags      0x00000000

/* --- Cmd_StatGetValues_Args_flags --- */

#define Cmd_StatGetValues_Args_flags_Privileged                 0x00000001
#define Cmd_StatGetValues_Args_flags__reserved                  0xffff0000
#define Cmd_StatGetValues_Args_flags__allflags                  0x00000001
#define Cmd_StatGetValues_Args_flags__presentflags              0x00000000

/* --- Cmd_ChannelUpdate_Args_flags --- */

#define Cmd_ChannelUpdate_Args_flags_final                      0x00000001
#define Cmd_ChannelUpdate_Args_flags__allflags                  0x00000001
#define Cmd_ChannelUpdate_Args_flags__presentflags              0x00000000

/* --- RemoteServerPermission_flags --- */

#define RemoteServerPermission_flags__reserved                  0xffff0000
#define RemoteServerPermission_flags__allflags                  0x00000000
#define RemoteServerPermission_flags__presentflags              0x00000000

/* --- Cmd_CreateSEEWorld_Args_flags --- */

#define Cmd_CreateSEEWorld_Args_flags_EnableDebug               0x00010000
#define Cmd_CreateSEEWorld_Args_flags__reserved                 0xffff0000
#define Cmd_CreateSEEWorld_Args_flags__allflags                 0x00010000
#define Cmd_CreateSEEWorld_Args_flags__presentflags             0x00000000

/* --- Cmd_GetACL_Args_flags --- */

#define Cmd_GetACL_Args_flags__reserved                         0xffff0000
#define Cmd_GetACL_Args_flags__allflags                         0x00000000
#define Cmd_GetACL_Args_flags__presentflags                     0x00000000

/* --- Cmd_RedeemTicket_Args_flags --- */

#define Cmd_RedeemTicket_Args_flags__reserved                   0xffff0000
#define Cmd_RedeemTicket_Args_flags__allflags                   0x00000000
#define Cmd_RedeemTicket_Args_flags__presentflags               0x00000000

/* --- Cmd_ImpathKXFinish_Args_flags --- */

#define Cmd_ImpathKXFinish_Args_flags_addr_present              0x00000001
#define Cmd_ImpathKXFinish_Args_flags__allflags                 0x00000001
#define Cmd_ImpathKXFinish_Args_flags__presentflags             0x00000001

/* --- Cmd_GetTicket_Args_flags --- */

#define Cmd_GetTicket_Args_flags_Reusable                       0x00000001
#define Cmd_GetTicket_Args_flags__reserved                      0xffff0000
#define Cmd_GetTicket_Args_flags__allflags                      0x00000001
#define Cmd_GetTicket_Args_flags__presentflags                  0x00000000

/* --- Cmd_NVMemAlloc_Args_flags --- */

#define Cmd_NVMemAlloc_Args_flags__allflags                     0x00000000
#define Cmd_NVMemAlloc_Args_flags__presentflags                 0x00000000

/* --- Cmd_RemoveSoftToken_Args_flags --- */

#define Cmd_RemoveSoftToken_Args_flags_NoRetData                0x00000001
#define Cmd_RemoveSoftToken_Args_flags_Examine                  0x00000002
#define Cmd_RemoveSoftToken_Args_flags__reserved                0xffff0000
#define Cmd_RemoveSoftToken_Args_flags__allflags                0x00000003
#define Cmd_RemoveSoftToken_Args_flags__presentflags            0x00000000

/* --- Cmd_ModuleInfo_Args_flags --- */

#define Cmd_ModuleInfo_Args_flags__reserved                     0xffff0000
#define Cmd_ModuleInfo_Args_flags__allflags                     0x00000000
#define Cmd_ModuleInfo_Args_flags__presentflags                 0x00000000

/* --- Cmd_ExportSlot_Args_flags --- */

#define Cmd_ExportSlot_Args_flags__reserved                     0xffff0000
#define Cmd_ExportSlot_Args_flags__allflags                     0x00000000
#define Cmd_ExportSlot_Args_flags__presentflags                 0x00000000

/* --- Cmd_Decrypt_Args_flags --- */

#define Cmd_Decrypt_Args_flags__reserved                        0xffff0000
#define Cmd_Decrypt_Args_flags__allflags                        0x00000000
#define Cmd_Decrypt_Args_flags__presentflags                    0x00000000

/* --- Cmd_ServerSendShare_Args_flags --- */

#define Cmd_ServerSendShare_Args_flags_pin_present              0x00000001
#define Cmd_ServerSendShare_Args_flags_UseProtectedPINPath      0x00000002
#define Cmd_ServerSendShare_Args_flags__allflags                0x00000003
#define Cmd_ServerSendShare_Args_flags__presentflags            0x00000001

/* --- Cmd_NewEnquiry_Args_flags --- */

#define Cmd_NewEnquiry_Args_flags__reserved                     0xffff0000
#define Cmd_NewEnquiry_Args_flags__allflags                     0x00000000
#define Cmd_NewEnquiry_Args_flags__presentflags                 0x00000000

/* --- Cmd_UpdateMergedKey_Args_flags --- */

#define Cmd_UpdateMergedKey_Args_flags_ListWorking              0x00000001
#define Cmd_UpdateMergedKey_Args_flags_ListNonworking           0x00000002
#define Cmd_UpdateMergedKey_Args_flags__allflags                0x00000003
#define Cmd_UpdateMergedKey_Args_flags__presentflags            0x00000000

/* --- Cmd_ChannelOpen_Args_flags --- */

#define Cmd_ChannelOpen_Args_flags_key_present                  0x00000001
#define Cmd_ChannelOpen_Args_flags_given_iv_present             0x00000002
#define Cmd_ChannelOpen_Args_flags__reserved                    0xffff0000
#define Cmd_ChannelOpen_Args_flags__allflags                    0x00000003
#define Cmd_ChannelOpen_Args_flags__presentflags                0x00000003

/* --- Cmd_SetRTC_Args_flags --- */

#define Cmd_SetRTC_Args_flags_adjust                            0x00000001
#define Cmd_SetRTC_Args_flags__allflags                         0x00000001
#define Cmd_SetRTC_Args_flags__presentflags                     0x00000000

/* --- Cmd_ReadShare_Args_flags --- */

#define Cmd_ReadShare_Args_flags_pin_present                    0x00000001
#define Cmd_ReadShare_Args_flags__reserved                      0xffff0000
#define Cmd_ReadShare_Args_flags__allflags                      0x00000001
#define Cmd_ReadShare_Args_flags__presentflags                  0x00000001

/* --- Cmd_Sign_Args_flags --- */

#define Cmd_Sign_Args_flags_given_iv_present                    0x00000001
#define Cmd_Sign_Args_flags__reserved                           0xffff0000
#define Cmd_Sign_Args_flags__allflags                           0x00000001
#define Cmd_Sign_Args_flags__presentflags                       0x00000001

/* --- Cmd_ExistingClient_Args_flags --- */

#define Cmd_ExistingClient_Args_flags__allflags                 0x00000000
#define Cmd_ExistingClient_Args_flags__presentflags             0x00000000

/* --- Cmd_SendShare_Args_flags --- */

#define Cmd_SendShare_Args_flags_pin_present                    0x00000001
#define Cmd_SendShare_Args_flags_UseProtectedPINPath            0x00000002
#define Cmd_SendShare_Args_flags__allflags                      0x00000003
#define Cmd_SendShare_Args_flags__presentflags                  0x00000001

/* --- Cmd_ImpathKXBegin_Args_flags --- */

#define Cmd_ImpathKXBegin_Args_flags__allflags                  0x00000000
#define Cmd_ImpathKXBegin_Args_flags__presentflags              0x00000000

/* --- Cmd_ForeignTokenOpen_Args_flags --- */

#define Cmd_ForeignTokenOpen_Args_flags__reserved               0xffff0000
#define Cmd_ForeignTokenOpen_Args_flags__allflags               0x00000000
#define Cmd_ForeignTokenOpen_Args_flags__presentflags           0x00000000

/* --- Cmd_CheckUserAction_Args_flags --- */

#define Cmd_CheckUserAction_Args_flags__reserved                0xffff0000
#define Cmd_CheckUserAction_Args_flags__allflags                0x00000000
#define Cmd_CheckUserAction_Args_flags__presentflags            0x00000000

/* --- Cmd_EraseFile_Args_flags --- */

#define Cmd_EraseFile_Args_flags__reserved                      0xffff0000
#define Cmd_EraseFile_Args_flags__allflags                      0x00000000
#define Cmd_EraseFile_Args_flags__presentflags                  0x00000000

/* --- Cmd_Hash_Args_flags --- */

#define Cmd_Hash_Args_flags__reserved                           0xffff0000
#define Cmd_Hash_Args_flags__allflags                           0x00000000
#define Cmd_Hash_Args_flags__presentflags                       0x00000000

/* --- Cmd_FormatToken_Args_flags --- */

#define Cmd_FormatToken_Args_flags_auth_key_present             0x00000001
#define Cmd_FormatToken_Args_flags__reserved                    0xffff0000
#define Cmd_FormatToken_Args_flags__allflags                    0x00000001
#define Cmd_FormatToken_Args_flags__presentflags                0x00000001

/* --- Cmd_PollSlotList_Args_flags --- */

#define Cmd_PollSlotList_Args_flags__reserved                   0xffff0000
#define Cmd_PollSlotList_Args_flags__allflags                   0x00000000
#define Cmd_PollSlotList_Args_flags__presentflags               0x00000000

/* --- Cmd_PollModuleState_Args_flags --- */

#define Cmd_PollModuleState_Args_flags__reserved                0xffff0000
#define Cmd_PollModuleState_Args_flags__allflags                0x00000000
#define Cmd_PollModuleState_Args_flags__presentflags            0x00000000

/* --- Cmd_NVMemFree_Args_flags --- */

#define Cmd_NVMemFree_Args_flags__allflags                      0x00000000
#define Cmd_NVMemFree_Args_flags__presentflags                  0x00000000

/* --- Cmd_SetKM_Args_flags --- */

#define Cmd_SetKM_Args_flags__reserved                          0xffff0000
#define Cmd_SetKM_Args_flags__allflags                          0x00000000
#define Cmd_SetKM_Args_flags__presentflags                      0x00000000

/* --- Cmd_GenerateKLF_Args_flags --- */

#define Cmd_GenerateKLF_Args_flags__allflags                    0x00000000
#define Cmd_GenerateKLF_Args_flags__presentflags                0x00000000

/* --- Cmd_DeriveKey_Args_flags --- */

#define Cmd_DeriveKey_Args_flags__reserved                      0xffff0000
#define Cmd_DeriveKey_Args_flags__allflags                      0x00000000
#define Cmd_DeriveKey_Args_flags__presentflags                  0x00000000

/* --- Cmd_StatEnumTree_Args_flags --- */

#define Cmd_StatEnumTree_Args_flags__reserved                   0xffff0000
#define Cmd_StatEnumTree_Args_flags__allflags                   0x00000000
#define Cmd_StatEnumTree_Args_flags__presentflags               0x00000000

/* --- Cmd_NVMemOp_Args_flags --- */

#define Cmd_NVMemOp_Args_flags_range_present                    0x00000001
#define Cmd_NVMemOp_Args_flags__allflags                        0x00000001
#define Cmd_NVMemOp_Args_flags__presentflags                    0x00000001

/* --- Cmd_LoadBlob_Args_flags --- */

#define Cmd_LoadBlob_Args_flags_idkb_present                    0x00000001
#define Cmd_LoadBlob_Args_flags__reserved                       0xffff0000
#define Cmd_LoadBlob_Args_flags__allflags                       0x00000001
#define Cmd_LoadBlob_Args_flags__presentflags                   0x00000001

/* --- FeatureInfo_ctrl --- */

#define FeatureInfo_ctrl_Add                                    0x00000001
#define FeatureInfo_ctrl_LongTerm                               0x00000002
#define FeatureInfo_ctrl__allflags                              0x00000003
#define FeatureInfo_ctrl__presentflags                          0x00000000

/* --- FeatureInfo_features --- */

#define FeatureInfo_features_ForeignTokenOpen                   0x00000001
#define FeatureInfo_features_RemoteShare                        0x00000002
#define FeatureInfo_features_GeneralSEE                         0x00000004
#define FeatureInfo_features_ExportCGEA                         0x00000008
#define FeatureInfo_features_KISAAlgorithms                     0x00000010
#define FeatureInfo_features_StandardKM                         0x00000020
#define FeatureInfo_features_PayShield                          0x00000040
#define FeatureInfo_features_reserved7                          0x00000080
#define FeatureInfo_features_reserved8                          0x00000100
#define FeatureInfo_features_reserved9                          0x00000200
#define FeatureInfo_features_reserved10                         0x00000400
#define FeatureInfo_features_reserved11                         0x00000800
#define FeatureInfo_features_reserved12                         0x00001000
#define FeatureInfo_features_reserved13                         0x00002000
#define FeatureInfo_features_reserved14                         0x00004000
#define FeatureInfo_features_reserved15                         0x00008000
#define FeatureInfo_features_reserved16                         0x00010000
#define FeatureInfo_features_reserved17                         0x00020000
#define FeatureInfo_features_reserved18                         0x00040000
#define FeatureInfo_features_reserved19                         0x00080000
#define FeatureInfo_features_reserved20                         0x00100000
#define FeatureInfo_features_reserved21                         0x00200000
#define FeatureInfo_features_reserved22                         0x00400000
#define FeatureInfo_features_reserved23                         0x00800000
#define FeatureInfo_features_reserved24                         0x01000000
#define FeatureInfo_features_reserved25                         0x02000000
#define FeatureInfo_features_reserved26                         0x04000000
#define FeatureInfo_features_reserved27                         0x08000000
#define FeatureInfo_features_reserved28                         0x10000000
#define FeatureInfo_features_reserved29                         0x20000000
#define FeatureInfo_features_reserved30                         0x40000000
#define FeatureInfo_features_reserved31                         0x80000000
#define FeatureInfo_features__reserved                          0xffffffff
#define FeatureInfo_features__allflags                          0xffffffff
#define FeatureInfo_features__presentflags                      0x00000000

/* --- FeatureInfo versioning --- */

#define FeatureInfo_ver__maxversion                                      0

/* --- Cmd_GenerateKey_Args_flags --- */

#define Cmd_GenerateKey_Args_flags_Certify                      0x00000001
#define Cmd_GenerateKey_Args_flags_appdata_present              0x00000002
#define Cmd_GenerateKey_Args_flags_PairwiseCheck                0x00000004
#define Cmd_GenerateKey_Args_flags__reserved                    0xffff0000
#define Cmd_GenerateKey_Args_flags__allflags                    0x00000007
#define Cmd_GenerateKey_Args_flags__presentflags                0x00000002

/* --- Cmd_NVMemList_Args_flags --- */

#define Cmd_NVMemList_Args_flags__allflags                      0x00000000
#define Cmd_NVMemList_Args_flags__presentflags                  0x00000000

/* --- Cmd_CreateBuffer_Args_flags --- */

#define Cmd_CreateBuffer_Args_flags_params_present              0x00000001
#define Cmd_CreateBuffer_Args_flags__reserved                   0xffff0000
#define Cmd_CreateBuffer_Args_flags__allflags                   0x00000001
#define Cmd_CreateBuffer_Args_flags__presentflags               0x00000001

/* --- Cmd_GetShareACL_Args_flags --- */

#define Cmd_GetShareACL_Args_flags__reserved                    0xffff0000
#define Cmd_GetShareACL_Args_flags__allflags                    0x00000000
#define Cmd_GetShareACL_Args_flags__presentflags                0x00000000

/* --- Cmd_GenerateKeyPair_Args_flags --- */

#define Cmd_GenerateKeyPair_Args_flags_Certify                  0x00000001
#define Cmd_GenerateKeyPair_Args_flags_appdatapriv_present      0x00000002
#define Cmd_GenerateKeyPair_Args_flags_appdatapub_present       0x00000004
#define Cmd_GenerateKeyPair_Args_flags_PairwiseCheck            0x00000008
#define Cmd_GenerateKeyPair_Args_flags__reserved                0xffff0000
#define Cmd_GenerateKeyPair_Args_flags__allflags                0x0000000f
#define Cmd_GenerateKeyPair_Args_flags__presentflags            0x00000006

/* --- Cmd_FirmwareAuthenticate_Args_flags --- */

#define Cmd_FirmwareAuthenticate_Args_flags_Monitor             0x00000001
#define Cmd_FirmwareAuthenticate_Args_flags_Applic              0x00000002
#define Cmd_FirmwareAuthenticate_Args_flags__allflags           0x00000003
#define Cmd_FirmwareAuthenticate_Args_flags__presentflags       0x00000000

/* --- Cmd_SetNSOPerms_Args_flags --- */

#define Cmd_SetNSOPerms_Args_flags_FIPS140Level3                0x00000001
#define Cmd_SetNSOPerms_Args_flags__reserved                    0xffff0000
#define Cmd_SetNSOPerms_Args_flags__allflags                    0x00000001
#define Cmd_SetNSOPerms_Args_flags__presentflags                0x00000000

/* --- Cmd_SignModuleState_Args_flags --- */

#define Cmd_SignModuleState_Args_flags_challenge_present        0x00000001
#define Cmd_SignModuleState_Args_flags__allflags                0x00000001
#define Cmd_SignModuleState_Args_flags__presentflags            0x00000001

/* --- Cmd_NewClient_Args_flags --- */

#define Cmd_NewClient_Args_flags__allflags                      0x00000000
#define Cmd_NewClient_Args_flags__presentflags                  0x00000000

/* --- Cmd_Verify_Args_flags --- */

#define Cmd_Verify_Args_flags__reserved                         0xffff0000
#define Cmd_Verify_Args_flags__allflags                         0x00000000
#define Cmd_Verify_Args_flags__presentflags                     0x00000000

/* --- Cmd_GetWorldSigners_Args_flags --- */

#define Cmd_GetWorldSigners_Args_flags__allflags                0x00000000
#define Cmd_GetWorldSigners_Args_flags__presentflags            0x00000000

/* --- Cmd_PauseForNotifications_Args_flags --- */

#define Cmd_PauseForNotifications_Args_flags__reserved          0xffff0000
#define Cmd_PauseForNotifications_Args_flags__allflags          0x00000000
#define Cmd_PauseForNotifications_Args_flags__presentflags      0x00000000

/* --- Cmd_LoadBuffer_Args_flags --- */

#define Cmd_LoadBuffer_Args_flags_Final                         0x00000001
#define Cmd_LoadBuffer_Args_flags__reserved                     0xffff0000
#define Cmd_LoadBuffer_Args_flags__allflags                     0x00000001
#define Cmd_LoadBuffer_Args_flags__presentflags                 0x00000000

/* --- Cmd_SetACL_Args_flags --- */

#define Cmd_SetACL_Args_flags_reduce                            0x00000001
#define Cmd_SetACL_Args_flags__reserved                         0xffff0000
#define Cmd_SetACL_Args_flags__allflags                         0x00000001
#define Cmd_SetACL_Args_flags__presentflags                     0x00000000

/* --- PermissionGroup_flags --- */

#define PermissionGroup_flags_certifier_present                 0x00000001
#define PermissionGroup_flags_FreshCerts                        0x00000002
#define PermissionGroup_flags_certmech_present                  0x00000004
#define PermissionGroup_flags_moduleserial_present              0x00000008
#define PermissionGroup_flags_NSOCertified                      0x00000010
#define PermissionGroup_flags__reserved                         0xffff0000
#define PermissionGroup_flags__allflags                         0x0000001f
#define PermissionGroup_flags__presentflags                     0x0000000d

/* --- EnquiryDataOne_flags --- */

#define EnquiryDataOne_flags_Hardware                           0x00000001
#define EnquiryDataOne_flags_HasTokens                          0x00000002
#define EnquiryDataOne_flags_MaintenanceMode                    0x00000004
#define EnquiryDataOne_flags_InitialisationMode                 0x00000008
#define EnquiryDataOne_flags_PreMaintInitMode                   0x00000010
#define EnquiryDataOne_flags_Uninitialised                      0x00000020
#define EnquiryDataOne_flags_TestingFirmware                    0x00000040
#define EnquiryDataOne_flags__reserved                          0xffff0000
#define EnquiryDataOne_flags__allflags                          0x0000007f
#define EnquiryDataOne_flags__presentflags                      0x00000000

/* --- EnquiryDataTwo_flags --- */

#define EnquiryDataTwo_flags_Fragmentation                      0x00000001
#define EnquiryDataTwo_flags__allflags                          0x00000001
#define EnquiryDataTwo_flags__presentflags                      0x00000000

/* --- EnquiryDataThree_flags --- */

#define EnquiryDataThree_flags_KeyStorage                       0x00000001
#define EnquiryDataThree_flags__allflags                        0x00000001
#define EnquiryDataThree_flags__presentflags                    0x00000000

/* --- EnquiryDataFour_flags --- */

#define EnquiryDataFour_flags_OrderlyClearUnit                  0x00000010
#define EnquiryDataFour_flags_HasRTC                            0x00000020
#define EnquiryDataFour_flags_HasNVRAM                          0x00000040
#define EnquiryDataFour_flags_HasNSOPermsCmd                    0x00000080
#define EnquiryDataFour_flags_ServerHasPollCmds                 0x00000100
#define EnquiryDataFour_flags_FastPollSlotList                  0x00000200
#define EnquiryDataFour_flags_HasSEE                            0x00000400
#define EnquiryDataFour_flags_HasKLF                            0x00000800
#define EnquiryDataFour_flags_HasShareACL                       0x00001000
#define EnquiryDataFour_flags_HasFeatureEnable                  0x00002000
#define EnquiryDataFour_flags__reserved                         0xfffffff0
#define EnquiryDataFour_flags__allflags                         0x00003ff0
#define EnquiryDataFour_flags__presentflags                     0x00000000

/* --- EnquiryDataSix versioning --- */

#define EnquiryDataSix_v__maxversion                                     1

/* --- ModuleAttribTag_AdditionalInfo_Value versioning --- */

#define ModuleAttribTag_AdditionalInfo_Value_v__maxversion               0

/* --- UseLim_NonVolatile_Details_flags --- */

#define UseLim_NonVolatile_Details_flags__allflags              0x00000000
#define UseLim_NonVolatile_Details_flags__presentflags          0x00000000

/* --- Act_FeatureEnable_Details_flags --- */

#define Act_FeatureEnable_Details_flags_SetSEEMachine           0x00000001
#define Act_FeatureEnable_Details_flags_GenerateKLF             0x00000002
#define Act_FeatureEnable_Details_flags__reserved               0xfffffffe
#define Act_FeatureEnable_Details_flags__allflags               0x00000003
#define Act_FeatureEnable_Details_flags__presentflags           0x00000000

/* --- Act_DeriveKey_Details_flags --- */

#define Act_DeriveKey_Details_flags__allflags                   0x00000000
#define Act_DeriveKey_Details_flags__presentflags               0x00000000

/* --- Act_SendShare_Details_flags --- */

#define Act_SendShare_Details_flags_rm_present                  0x00000001
#define Act_SendShare_Details_flags_rsd_present                 0x00000002
#define Act_SendShare_Details_flags__allflags                   0x00000003
#define Act_SendShare_Details_flags__presentflags               0x00000003

/* --- Act_NVMemUseLimit_Details_flags --- */

#define Act_NVMemUseLimit_Details_flags__allflags               0x00000000
#define Act_NVMemUseLimit_Details_flags__presentflags           0x00000000

/* --- Act_NVMemOpPerms_Details_perms --- */

#define Act_NVMemOpPerms_Details_perms_Read                     0x00000001
#define Act_NVMemOpPerms_Details_perms_Write                    0x00000002
#define Act_NVMemOpPerms_Details_perms_Incr                     0x00000004
#define Act_NVMemOpPerms_Details_perms_Decr                     0x00000008
#define Act_NVMemOpPerms_Details_perms_BitSet                   0x00000010
#define Act_NVMemOpPerms_Details_perms_BitClear                 0x00000020
#define Act_NVMemOpPerms_Details_perms_Free                     0x00000040
#define Act_NVMemOpPerms_Details_perms_subrange_present         0x00000080
#define Act_NVMemOpPerms_Details_perms_exactrange_present       0x00000100
#define Act_NVMemOpPerms_Details_perms_incdeclimit_present      0x00000200
#define Act_NVMemOpPerms_Details_perms_GetACL                   0x00000400
#define Act_NVMemOpPerms_Details_perms__allflags                0x000007ff
#define Act_NVMemOpPerms_Details_perms__presentflags            0x00000380

/* --- Act_OpPermissions_Details_perms --- */

#define Act_OpPermissions_Details_perms_DuplicateHandle         0x00000001
#define Act_OpPermissions_Details_perms_UseAsCertificate        0x00000002
#define Act_OpPermissions_Details_perms_ExportAsPlain           0x00000004
#define Act_OpPermissions_Details_perms_GetAppData              0x00000008
#define Act_OpPermissions_Details_perms_SetAppData              0x00000010
#define Act_OpPermissions_Details_perms_ReduceACL               0x00000020
#define Act_OpPermissions_Details_perms_ExpandACL               0x00000040
#define Act_OpPermissions_Details_perms_Encrypt                 0x00000080
#define Act_OpPermissions_Details_perms_Decrypt                 0x00000100
#define Act_OpPermissions_Details_perms_Verify                  0x00000200
#define Act_OpPermissions_Details_perms_UseAsBlobKey            0x00000400
#define Act_OpPermissions_Details_perms_UseAsKM                 0x00000800
#define Act_OpPermissions_Details_perms_Sign                    0x00001000
#define Act_OpPermissions_Details_perms_GetACL                  0x00002000
#define Act_OpPermissions_Details_perms_UseAsLoaderKey          0x00004000
#define Act_OpPermissions_Details_perms_SignModuleCert          0x00008000
#define Act_OpPermissions_Details_perms__allflags               0x0000ffff
#define Act_OpPermissions_Details_perms__presentflags           0x00000000

/* --- Act_MakeArchiveBlob_Details_flags --- */

#define Act_MakeArchiveBlob_Details_flags_kahash_present        0x00000001
#define Act_MakeArchiveBlob_Details_flags__reserved             0xffff0000
#define Act_MakeArchiveBlob_Details_flags__allflags             0x00000001
#define Act_MakeArchiveBlob_Details_flags__presentflags         0x00000001

/* --- Act_MakeBlob_Details_flags --- */

#define Act_MakeBlob_Details_flags_AllowKmOnly                  0x00000001
#define Act_MakeBlob_Details_flags_AllowNonKm0                  0x00000002
#define Act_MakeBlob_Details_flags_kmhash_present               0x00000004
#define Act_MakeBlob_Details_flags_kthash_present               0x00000008
#define Act_MakeBlob_Details_flags_ktparams_present             0x00000010
#define Act_MakeBlob_Details_flags_AllowNullKmToken             0x00000020
#define Act_MakeBlob_Details_flags__reserved                    0xff000000
#define Act_MakeBlob_Details_flags__allflags                    0x0000003f
#define Act_MakeBlob_Details_flags__presentflags                0x0000001c

/* --- ReadShareDetails_flags --- */

#define ReadShareDetails_flags__allflags                        0x00000000
#define ReadShareDetails_flags__presentflags                    0x00000000

/* --- Reply_flags --- */

#define Reply_flags_BignumMSBitFirst                            0x00000001
#define Reply_flags_BignumMSWordFirst                           0x00000002
#define Reply_flags__reserved                                   0xffff0000
#define Reply_flags__allflags                                   0x00000003
#define Reply_flags__presentflags                               0x00000000

/* --- Cmd_GetKMList_Reply_flags --- */

#define Cmd_GetKMList_Reply_flags_KNSOset                       0x00000001
#define Cmd_GetKMList_Reply_flags__reserved                     0xffff0000
#define Cmd_GetKMList_Reply_flags__allflags                     0x00000001
#define Cmd_GetKMList_Reply_flags__presentflags                 0x00000000

/* --- Cmd_GetLogicalTokenInfoEx_Reply_flags --- */

#define Cmd_GetLogicalTokenInfoEx_Reply_flags__reserved         0xffff0000
#define Cmd_GetLogicalTokenInfoEx_Reply_flags__allflags         0x00000000
#define Cmd_GetLogicalTokenInfoEx_Reply_flags__presentflags     0x00000000

/* --- Cmd_GetLogicalTokenInfoEx_Reply versioning --- */

#define Cmd_GetLogicalTokenInfoEx_Reply_ver__maxversion                  0

/* --- ImpathInfo versioning --- */

#define ImpathInfo_v__maxversion                                         0

/* --- Cmd_ANSlotChangeEvent_Reply_flags --- */

#define Cmd_ANSlotChangeEvent_Reply_flags_PhysToken             0x01000000
#define Cmd_ANSlotChangeEvent_Reply_flags_Data                  0x02000000
#define Cmd_ANSlotChangeEvent_Reply_flags__reserved             0xff000000
#define Cmd_ANSlotChangeEvent_Reply_flags__allflags             0x03000000
#define Cmd_ANSlotChangeEvent_Reply_flags__presentflags         0x00000000

/* --- Cmd_ProgrammingEndChunk_Reply_flags --- */

#define Cmd_ProgrammingEndChunk_Reply_flags_Unchanged           0x00000001
#define Cmd_ProgrammingEndChunk_Reply_flags__reserved           0xffff0000
#define Cmd_ProgrammingEndChunk_Reply_flags__allflags           0x00000001
#define Cmd_ProgrammingEndChunk_Reply_flags__presentflags       0x00000000

/* --- SlotListData_flags --- */

#define SlotListData_flags_ProtectedPINPath                     0x00000001
#define SlotListData_flags_SupportsAuthentication               0x00000002
#define SlotListData_flags_NotSoftSlot                          0x00010000
#define SlotListData_flags_ReadOnly                             0x00020000
#define SlotListData_flags_RemoteSlot                           0x00040000
#define SlotListData_flags__reserved                            0xffff0000
#define SlotListData_flags__allflags                            0x00070003
#define SlotListData_flags__presentflags                        0x00000000

/* --- Cmd_ServerSendShare_Reply_flags --- */

#define Cmd_ServerSendShare_Reply_flags_PINProtected            0x00000001
#define Cmd_ServerSendShare_Reply_flags__reserved               0xffff0000
#define Cmd_ServerSendShare_Reply_flags__allflags               0x00000001
#define Cmd_ServerSendShare_Reply_flags__presentflags           0x00000000

/* --- Cmd_NewEnquiry_Reply_flags --- */

#define Cmd_NewEnquiry_Reply_flags_Failed                       0x00010000
#define Cmd_NewEnquiry_Reply_flags__reserved                    0xffff0000
#define Cmd_NewEnquiry_Reply_flags__allflags                    0x00010000
#define Cmd_NewEnquiry_Reply_flags__presentflags                0x00000000

/* --- Cmd_ChannelOpen_Reply_flags --- */

#define Cmd_ChannelOpen_Reply_flags_new_iv_present              0x00000001
#define Cmd_ChannelOpen_Reply_flags__allflags                   0x00000001
#define Cmd_ChannelOpen_Reply_flags__presentflags               0x00000001

/* --- Cmd_ExistingClient_Reply_flags --- */

#define Cmd_ExistingClient_Reply_flags__allflags                0x00000000
#define Cmd_ExistingClient_Reply_flags__presentflags            0x00000000

/* --- Cmd_PollSlotList_Reply_flags --- */

#define Cmd_PollSlotList_Reply_flags__reserved                  0xffff0000
#define Cmd_PollSlotList_Reply_flags__allflags                  0x00000000
#define Cmd_PollSlotList_Reply_flags__presentflags              0x00000000

/* --- Cmd_NVMemList_Reply_flags --- */

#define Cmd_NVMemList_Reply_flags__allflags                     0x00000000
#define Cmd_NVMemList_Reply_flags__presentflags                 0x00000000

/* --- Cmd_GetSlotInfo_Reply_flags --- */

#define Cmd_GetSlotInfo_Reply_flags_Unformatted                 0x00000001
#define Cmd_GetSlotInfo_Reply_flags_Authenticated               0x00000002
#define Cmd_GetSlotInfo_Reply_flags__reserved                   0xffff0000
#define Cmd_GetSlotInfo_Reply_flags__allflags                   0x00000003
#define Cmd_GetSlotInfo_Reply_flags__presentflags               0x00000000

/* --- Cmd_FirmwareAuthenticate_Reply_flags --- */

#define Cmd_FirmwareAuthenticate_Reply_flags__allflags          0x00000000
#define Cmd_FirmwareAuthenticate_Reply_flags__presentflags      0x00000000

/* --- Cmd_TraceSEEWorld_Reply_flags --- */

#define Cmd_TraceSEEWorld_Reply_flags_Failed                    0x00000001
#define Cmd_TraceSEEWorld_Reply_flags__reserved                 0xffff0000
#define Cmd_TraceSEEWorld_Reply_flags__allflags                 0x00000001
#define Cmd_TraceSEEWorld_Reply_flags__presentflags             0x00000000

/* --- Cmd_GetKeyInfoEx_Reply_flags --- */

#define Cmd_GetKeyInfoEx_Reply_flags__reserved                  0xffff0000
#define Cmd_GetKeyInfoEx_Reply_flags__allflags                  0x00000000
#define Cmd_GetKeyInfoEx_Reply_flags__presentflags              0x00000000

/* --- Cmd_GetKeyInfoEx_Reply versioning --- */

#define Cmd_GetKeyInfoEx_Reply_ver__maxversion                           0

/* --- Cmd_StatGetValues_Reply_flags --- */

#define Cmd_StatGetValues_Reply_flags__reserved                 0xffff0000
#define Cmd_StatGetValues_Reply_flags__allflags                 0x00000000
#define Cmd_StatGetValues_Reply_flags__presentflags             0x00000000

/* --- Cmd_ANModuleChangeEvent_Reply_flags --- */

#define Cmd_ANModuleChangeEvent_Reply_flags_NVKeys              0x01000000
#define Cmd_ANModuleChangeEvent_Reply_flags_NVMem               0x02000000
#define Cmd_ANModuleChangeEvent_Reply_flags_RTC                 0x04000000
#define Cmd_ANModuleChangeEvent_Reply_flags__reserved           0xff000000
#define Cmd_ANModuleChangeEvent_Reply_flags__allflags           0x07000000
#define Cmd_ANModuleChangeEvent_Reply_flags__presentflags       0x00000000

/* --- InfoFormat_HardwareRev1_Info_flags --- */

#define InfoFormat_HardwareRev1_Info_flags_RTCPresent           0x00010000
#define InfoFormat_HardwareRev1_Info_flags_KLFPresent           0x00020000
#define InfoFormat_HardwareRev1_Info_flags__reserved            0xffff0000
#define InfoFormat_HardwareRev1_Info_flags__allflags            0x00030000
#define InfoFormat_HardwareRev1_Info_flags__presentflags        0x00000000

/* --- Cmd_SendShare_Reply_flags --- */

#define Cmd_SendShare_Reply_flags_PINProtected                  0x00000001
#define Cmd_SendShare_Reply_flags__reserved                     0xffff0000
#define Cmd_SendShare_Reply_flags__allflags                     0x00000001
#define Cmd_SendShare_Reply_flags__presentflags                 0x00000000

/* --- Cmd_PollModuleState_Reply_flags --- */

#define Cmd_PollModuleState_Reply_flags__reserved               0xffff0000
#define Cmd_PollModuleState_Reply_flags__allflags               0x00000000
#define Cmd_PollModuleState_Reply_flags__presentflags           0x00000000

/* --- Cmd_PollModuleState_Reply versioning --- */

#define Cmd_PollModuleState_Reply_version__maxversion                    0

/* --- Cmd_StatEnumTree_Reply_flags --- */

#define Cmd_StatEnumTree_Reply_flags_Privileged                 0x00000001
#define Cmd_StatEnumTree_Reply_flags_Expensive                  0x00000002
#define Cmd_StatEnumTree_Reply_flags_InstanceSubnodes           0x00000004
#define Cmd_StatEnumTree_Reply_flags__reserved                  0xffff0000
#define Cmd_StatEnumTree_Reply_flags__allflags                  0x00000007
#define Cmd_StatEnumTree_Reply_flags__presentflags              0x00000000

/* --- Cmd_GenerateKey_Reply_flags --- */

#define Cmd_GenerateKey_Reply_flags_cert_present                0x00000001
#define Cmd_GenerateKey_Reply_flags__reserved                   0xffff0000
#define Cmd_GenerateKey_Reply_flags__allflags                   0x00000001
#define Cmd_GenerateKey_Reply_flags__presentflags               0x00000001

/* --- Cmd_GenerateKeyPair_Reply_flags --- */

#define Cmd_GenerateKeyPair_Reply_flags_certpriv_present        0x00000001
#define Cmd_GenerateKeyPair_Reply_flags_certpub_present         0x00000002
#define Cmd_GenerateKeyPair_Reply_flags__reserved               0xffff0000
#define Cmd_GenerateKeyPair_Reply_flags__allflags               0x00000003
#define Cmd_GenerateKeyPair_Reply_flags__presentflags           0x00000003

/* --- Cmd_NewClient_Reply_flags --- */

#define Cmd_NewClient_Reply_flags__allflags                     0x00000000
#define Cmd_NewClient_Reply_flags__presentflags                 0x00000000

/* --- Cmd_PauseForNotifications_Reply_flags --- */

#define Cmd_PauseForNotifications_Reply_flags_RequestedDelayTooShort 0x00000001
#define Cmd_PauseForNotifications_Reply_flags_RequestedDelayTooLong 0x00000002
#define Cmd_PauseForNotifications_Reply_flags_AlreadyInProgress 0x00000004
#define Cmd_PauseForNotifications_Reply_flags__reserved         0xffff0000
#define Cmd_PauseForNotifications_Reply_flags__allflags         0x00000007
#define Cmd_PauseForNotifications_Reply_flags__presentflags     0x00000000

/* --- TokenInfo_flags --- */

#define TokenInfo_flags_RequiresPIN                             0x00000001
#define TokenInfo_flags_NewFormat                               0x00010000
#define TokenInfo_flags__reserved                               0xffff0000
#define TokenInfo_flags__allflags                               0x00010001
#define TokenInfo_flags__presentflags                           0x00000000

/* --- StatInfo_flags --- */

#define StatInfo_flags_Counter                                  0x00000001
#define StatInfo_flags_Fraction                                 0x00000002
#define StatInfo_flags_Synchronous                              0x00000004
#define StatInfo_flags_Inexact                                  0x00000008
#define StatInfo_flags__reserved                                0xffffffff
#define StatInfo_flags__allflags                                0x0000000f
#define StatInfo_flags__presentflags                            0x00000000

/* --- ProgSigDatFormat_Two_Data_flags --- */

#define ProgSigDatFormat_Two_Data_flags_Execute                 0x00000001
#define ProgSigDatFormat_Two_Data_flags__reserved               0xffff0000
#define ProgSigDatFormat_Two_Data_flags__allflags               0x00000001
#define ProgSigDatFormat_Two_Data_flags__presentflags           0x00000000

/* --- FirmwareFileInfo_flags --- */

#define FirmwareFileInfo_flags_MonitorImage                     0x00000001
#define FirmwareFileInfo_flags__allflags                        0x00000001
#define FirmwareFileInfo_flags__presentflags                    0x00000000

/* --- SigningKeyEntry_flags --- */

#define SigningKeyEntry_flags_HashValid                         0x00000001
#define SigningKeyEntry_flags__allflags                         0x00000001
#define SigningKeyEntry_flags__presentflags                     0x00000000

/* --- CertSignMessage_flags --- */

#define CertSignMessage_flags_nonce_present                     0x00000001
#define CertSignMessage_flags_acl_present                       0x00000002
#define CertSignMessage_flags__reserved                         0xffff0000
#define CertSignMessage_flags__allflags                         0x00000003
#define CertSignMessage_flags__presentflags                     0x00000003

/* --- ModCertType_KWARv0_ModCertData_flags --- */

#define ModCertType_KWARv0_ModCertData_flags__reserved          0xffff0000
#define ModCertType_KWARv0_ModCertData_flags__allflags          0x00000000
#define ModCertType_KWARv0_ModCertData_flags__presentflags      0x00000000

/* --- ModCertType_StateCert_ModCertData_flags --- */

#define ModCertType_StateCert_ModCertData_flags__reserved       0xffff0000
#define ModCertType_StateCert_ModCertData_flags__allflags       0x00000000
#define ModCertType_StateCert_ModCertData_flags__presentflags   0x00000000

/* --- ModCertType_KeyGen_ModCertData_flags --- */

#define ModCertType_KeyGen_ModCertData_flags_Public             0x00000001
#define ModCertType_KeyGen_ModCertData_flags__reserved          0xffff0000
#define ModCertType_KeyGen_ModCertData_flags__allflags          0x00000001
#define ModCertType_KeyGen_ModCertData_flags__presentflags      0x00000000

/* --- ImpathKXMessage_flags --- */

#define ImpathKXMessage_flags__allflags                         0x00000000
#define ImpathKXMessage_flags__presentflags                     0x00000000

/* --- ImpathMsgType_UserData_Body_flags --- */

#define ImpathMsgType_UserData_Body_flags__reserved             0xffff0000
#define ImpathMsgType_UserData_Body_flags__allflags             0x00000000
#define ImpathMsgType_UserData_Body_flags__presentflags         0x00000000

/* --- ImpathMsgType_Share_Body_flags --- */

#define ImpathMsgType_Share_Body_flags_PINProtected             0x00000001
#define ImpathMsgType_Share_Body_flags__allflags                0x00000001
#define ImpathMsgType_Share_Body_flags__presentflags            0x00000000

/* --- SEEOpType_JavaSEECmdInstantiateObject_SEEArgs_flags --- */

#define SEEOpType_JavaSEECmdInstantiateObject_SEEArgs_flags_Class 0x00000001
#define SEEOpType_JavaSEECmdInstantiateObject_SEEArgs_flags__reserved 0xffff0000
#define SEEOpType_JavaSEECmdInstantiateObject_SEEArgs_flags__allflags 0x00000001
#define SEEOpType_JavaSEECmdInstantiateObject_SEEArgs_flags__presentflags 0x00000000

/* --- SEEOpType_JavaSEECmdDeleteObject_SEEArgs_flags --- */

#define SEEOpType_JavaSEECmdDeleteObject_SEEArgs_flags__reserved 0xffff0000
#define SEEOpType_JavaSEECmdDeleteObject_SEEArgs_flags__allflags 0x00000000
#define SEEOpType_JavaSEECmdDeleteObject_SEEArgs_flags__presentflags 0x00000000

/* --- SEEOpType_JavaSEECmdInvokeMethod_SEEArgs_flags --- */

#define SEEOpType_JavaSEECmdInvokeMethod_SEEArgs_flags__reserved 0xffff0000
#define SEEOpType_JavaSEECmdInvokeMethod_SEEArgs_flags__allflags 0x00000000
#define SEEOpType_JavaSEECmdInvokeMethod_SEEArgs_flags__presentflags 0x00000000

/* --- SEEOpType_JavaSEECmdInstantiateObject_SEERes_flags --- */

#define SEEOpType_JavaSEECmdInstantiateObject_SEERes_flags_exception_present 0x00000001
#define SEEOpType_JavaSEECmdInstantiateObject_SEERes_flags__reserved 0xffff0000
#define SEEOpType_JavaSEECmdInstantiateObject_SEERes_flags__allflags 0x00000001
#define SEEOpType_JavaSEECmdInstantiateObject_SEERes_flags__presentflags 0x00000001

/* --- SEEOpType_JavaSEECmdInvokeMethod_SEERes_flags --- */

#define SEEOpType_JavaSEECmdInvokeMethod_SEERes_flags_exception_present 0x00000001
#define SEEOpType_JavaSEECmdInvokeMethod_SEERes_flags__reserved 0xffff0000
#define SEEOpType_JavaSEECmdInvokeMethod_SEERes_flags__allflags 0x00000001
#define SEEOpType_JavaSEECmdInvokeMethod_SEERes_flags__presentflags 0x00000001

/* --- TicketInfo_flags --- */

#define TicketInfo_flags_hclientid_present                      0x00000001
#define TicketInfo_flags_destspace_present                      0x00000002
#define TicketInfo_flags_challenge_present                      0x00000004
#define TicketInfo_flags_AllowClient                            0x00000008
#define TicketInfo_flags_AllowSEEWorld                          0x00000010
#define TicketInfo_flags__allflags                              0x0000001f
#define TicketInfo_flags__presentflags                          0x00000007

/*----- Data structure formats --------------------------------------------*
 *
 * ERRORINFO for Status = nCErrno
 *   WORD (enum `nCErrno')                    err
 *   ASCIISTRING                              strerr
 *
 * ERRORINFO for Status = RemoteServerFailed
 *   WORD (flags)                             flags
 *   OPT_STATUSERRORINFO                      stinfo
 *   NETWORKADDRESS                           addr
 *     (if flag set in `flags')
 *
 * ERRORINFO for Status = SlotUnconnected
 *   OPT_STATUSERRORINFO                      stinfo
 *
 * ERRORINFO for Status = CrossModule
 *   WORD                                     n_reasons
 *   n_reasons * CROSSMODULEREASON            reasons
 *
 * ERRORINFO for Status = AttemptedDowngrade
 *   WORD                                     oldvsn
 *   WORD                                     newvsn
 *
 * ERRORINFO for Status = UnknownKeyHash
 *   KEYHASH                                  hk
 *
 * STATUSERRORINFO:
 *   WORD (enum `Status')                     st
 *   ERRORINFO (based on `st')                einfo
 *
 * VALUE for NetworkAddressFamily = INET
 *   IPV4ADDRESS                              addr
 *   WORD                                     port
 *
 * VALUE for NetworkAddressFamily = INET6
 *   IPV6ADDRESS                              addr
 *   WORD                                     port
 *
 * NETWORKADDRESS:
 *   WORD (enum `NetworkAddressFamily')       af
 *   VALUE (based on `af')                    addr
 *
 * INFO for CrossModReason = Key
 *   KEYID                                    key
 *
 * CROSSMODULEREASON:
 *   WORD (enum `CrossModReason')             type
 *   INFO (based on `type')                   info
 *
 * PHYSTOKEN:
 *   MODULEID                                 module
 *   SLOTID                                   slot
 *   WORD                                     ic
 *
 * SLOTEXDATA for SlotType = Unconnected
 *   STATUSERRORINFO                          stinfo
 *
 * EXTRACCOI for ChannelType = DriverDirect
 *   MODULECHANNELID                          mcid
 *   ASCIISTRING                              drivername
 *
 * CLIENTCHANNELOPENINFO:
 *   WORD (enum `ChannelType')                type
 *   EXTRACCOI (based on `type')              info
 *
 * DATA for KeyType = DES3
 *   DES3KEY                                  k
 *
 * DATA for KeyType = RSAPublic
 *   BIGNUM                                   e
 *   BIGNUM                                   n
 *
 * DSADISCRETELOGGROUP:
 *   BIGNUM                                   p
 *   BIGNUM                                   q
 *   BIGNUM                                   g
 *
 * DATA for KeyType = DSAPublic
 *   DSADISCRETELOGGROUP                      dlg
 *   BIGNUM                                   y
 *
 * DATA for KeyType = DSAPrivate
 *   DSADISCRETELOGGROUP                      dlg
 *   BIGNUM                                   x
 *
 * DATA for KeyType = DKTemplate
 *   BYTEBLOCK                                appdata
 *   BYTEBLOCK                                nested_acl
 *
 * DATA for KeyType = DES
 *   DESKEY                                   k
 *
 * DISCRETELOGGROUP:
 *   BIGNUM                                   p
 *   BIGNUM                                   g
 *
 * DATA for KeyType = DHPrivate
 *   DISCRETELOGGROUP                         dlg
 *   BIGNUM                                   x
 *
 * DATA for KeyType = KCDSAPrivate
 *   KCDSADISCRETELOGGROUP                    dlg
 *   BIGNUM                                   y
 *   BIGNUM                                   x
 *
 * DATA for KeyType = RC2
 *   WORD                                     kbits
 *   BYTEBLOCK                                k
 *
 * DATA for KeyType = RSAPrivate
 *   BIGNUM                                   p
 *   BIGNUM                                   q
 *   BIGNUM                                   dmp1
 *   BIGNUM                                   dmq1
 *   BIGNUM                                   iqmp
 *   BIGNUM                                   e
 *
 * DATA for KeyType = RC5
 *   WORD                                     rounds
 *   BYTEBLOCK                                k
 *
 * DATA for KeyType = SSLMasterSecret
 *   SSLMASTERSECRET                          secret
 *
 * DATA for KeyType = KCDSAPublic
 *   KCDSADISCRETELOGGROUP                    dlg
 *   BIGNUM                                   y
 *
 * KCDSAINITVALUES:
 *   BYTEBLOCK                                seed
 *   WORD                                     counter
 *
 * DATA for KeyType = KCDSAComm
 *   KCDSAINITVALUES                          iv
 *   KCDSADISCRETELOGGROUP                    dlg
 *
 * DSAINITVALUES:
 *   HASH                                     seed
 *   WORD                                     counter
 *   WORD                                     h
 *
 * DATA for KeyType = DSAComm
 *   DSAINITVALUES                            iv
 *   DSADISCRETELOGGROUP                      dlg
 *
 * DATA for KeyType = Random
 *   BYTEBLOCK                                k
 *
 * DATA for KeyType = DHPublic
 *   DISCRETELOGGROUP                         dlg
 *   BIGNUM                                   gx
 *
 * DATA for KeyType = DES2
 *   DES2KEY                                  k
 *
 * KEYDATA:
 *   WORD (enum `KeyType')                    type
 *   DATA (based on `type')                   data
 *
 * CIPHER for Mech = HAS160Hash
 *   HASH20                                   h
 *
 * CIPHER for Mech = Generic64
 *   BYTEBLOCK                                cipher
 *
 * CIPHER for Mech = Generic64MAC
 *   BLOCK64                                  mac
 *
 * CIPHER for Mech = SHA1Hash
 *   HASH20                                   h
 *
 * CIPHER for Mech = ArcFourpNONE
 *   BYTEBLOCK                                cipher
 *
 * CIPHER for Mech = TLSFinishedMsg
 *   HASH12                                   msg
 *
 * CIPHER for Mech = DSA
 *   BIGNUM                                   r
 *   BIGNUM                                   s
 *
 * CIPHER for Mech = Generic256MAC
 *   BLOCK256                                 mac
 *
 * CIPHER for Mech = RSApSETOAEP
 *   BIGNUM                                   m
 *
 * CIPHER for Mech = SHA512Hash
 *   HASH64                                   h
 *
 * CIPHER for Mech = SHA384Hash
 *   HASH48                                   h
 *
 * CIPHER for Mech = MD2Hash
 *   HASH16                                   h
 *
 * CIPHER for Mech = RSApPKCS1
 *   BIGNUM                                   m
 *
 * CIPHER for Mech = DLIESe3DEShSHA1
 *   BYTEBLOCK                                cipher
 *
 * CIPHER for Mech = Generic192MAC
 *   BLOCK192                                 mac
 *
 * CIPHER for Mech = Generic256
 *   BYTEBLOCK                                cipher
 *
 * CIPHER for Mech = SSLRecordLayer
 *   BYTEBLOCK                                records
 *
 * CIPHER for Mech = RIPEMD160Hash
 *   HASH20                                   h
 *
 * CIPHER for Mech = Imech
 *   BYTEBLOCK                                c
 *   WORD                                     len
 *
 * CIPHER for Mech = TigerHash
 *   HASH24                                   h
 *
 * CIPHER for Mech = Generic192
 *   BYTEBLOCK                                cipher
 *
 * CIPHER for Mech = SHA256Hash
 *   HASH32                                   h
 *
 * CIPHER for Mech = KCDSAHAS160
 *   BYTEBLOCK                                r
 *   BIGNUM                                   s
 *
 * CIPHER for Mech = SSL3FinishedMsg
 *   HASH16                                   md5hash
 *   HASH20                                   sha1hash
 *
 * CIPHER for Mech = RSApPKCS1pPKCS11
 *   BYTEBLOCK                                cipher
 *
 * CIPHER for Mech = Generic128MAC
 *   BLOCK128                                 mac
 *
 * CIPHER for Mech = DHKeyExchange
 *   BIGNUM                                   gx
 *
 * CIPHER for Mech = Generic128
 *   BYTEBLOCK                                cipher
 *
 * CIPHER for Mech = ElGamal
 *   BIGNUM                                   a
 *   BIGNUM                                   b
 *
 * CIPHER for Mech = MD5Hash
 *   HASH16                                   h
 *
 * IV for Mech = Generic64
 *   BLOCK64                                  iv
 *
 * IV for Mech = Generic64MAC
 *   BLOCK64                                  iv
 *
 * IV for Mech = Generic256MAC
 *   BLOCK256                                 iv
 *
 * IV for Mech = RSApPKCS1OAEP
 *   BYTEBLOCK                                p
 *
 * IV for Mech = Generic192MAC
 *   BLOCK192                                 iv
 *
 * IV for Mech = Generic256
 *   BLOCK256                                 iv
 *
 * IV for Mech = SSLRecordLayer
 *   WORD (flags)                             flags
 *   SSLCLIENTRANDOM                          crnd
 *   SSLSERVERRANDOM                          srnd
 *   WORD (enum `SSLCipherSuite')             algs
 *
 * IV for Mech = Generic192
 *   BLOCK192                                 iv
 *
 * IV for Mech = Generic128MAC
 *   BLOCK128                                 iv
 *
 * IV for Mech = Generic128
 *   BLOCK128                                 iv
 *
 * CIPHERTEXT:
 *   WORD (enum `Mech')                       mech
 *   CIPHER (based on `mech')                 data
 *   IV (based on `mech')                     iv
 *
 * CERTBODY for CertType = SingleCert
 *   KEYDATA                                  pubkeydata
 *   CIPHERTEXT                               signature
 *   BYTEBLOCK                                certsignmsg
 *
 * CERTBODY for CertType = SigningKey
 *   KEYID                                    key
 *
 * CERTIFICATE:
 *   KEYHASH                                  keyhash
 *   WORD (enum `CertType')                   type
 *   CERTBODY (based on `type')               body
 *
 * DATA for PlainTextType = Hash16
 *   HASH16                                   data
 *
 * DATA for PlainTextType = Bignum
 *   BIGNUM                                   m
 *
 * DATA for PlainTextType = Hash
 *   HASH                                     data
 *
 * DATA for PlainTextType = Bytes
 *   BYTEBLOCK                                data
 *
 * PLAINTEXT:
 *   WORD (enum `PlainTextType')              type
 *   DATA (based on `type')                   data
 *
 * GENPARAMS for KeyType = Wrapped
 *   WORD (flags)                             flags
 *   WORD                                     length
 *
 * GENPARAMS for KeyType = DSAPrivate
 *   WORD (flags)                             flags
 *   WORD                                     lenbits
 *   DSADISCRETELOGGROUP                      dlg
 *     (if flag set in `flags')
 *
 * GENPARAMS for KeyType = DHPrivate
 *   WORD (flags)                             flags
 *   WORD                                     plength
 *   WORD                                     xlength
 *   DISCRETELOGGROUP                         dlg
 *     (if flag set in `flags')
 *
 * GENPARAMS for KeyType = KCDSAPrivate
 *   WORD (flags)                             flags
 *   WORD                                     plen
 *   WORD                                     qlen
 *   KCDSADISCRETELOGGROUP                    dlg
 *     (if flag set in `flags')
 *
 * GENPARAMS for KeyType = RC2
 *   WORD                                     kbits
 *   WORD                                     lenbytes
 *
 * GENPARAMS for KeyType = RSAPrivate
 *   WORD (flags)                             flags
 *   WORD                                     lenbits
 *   BIGNUM                                   given_e
 *     (if flag set in `flags')
 *   WORD                                     nchecks
 *     (if flag set in `flags')
 *
 * GENPARAMS for KeyType = RC5
 *   WORD                                     rounds
 *   WORD                                     lenbytes
 *
 * GENPARAMS for KeyType = KCDSAComm
 *   WORD (flags)                             flags
 *   WORD                                     plen
 *   WORD                                     qlen
 *   KCDSAINITVALUES                          iv
 *     (if flag set in `flags')
 *
 * GENPARAMS for KeyType = DSAComm
 *   WORD (flags)                             flags
 *   WORD                                     lenbits
 *   DSAINITVALUES                            iv
 *     (if flag set in `flags')
 *
 * GENPARAMS for KeyType = Random
 *   WORD                                     lenbytes
 *
 * KEYGENPARAMS:
 *   WORD (enum `KeyType')                    type
 *   GENPARAMS (based on `type')              params
 *
 * IV:
 *   WORD (enum `Mech')                       mech
 *   IV (based on `mech')                     iv
 *
 * DKPARAMS for DeriveMech = RawEncrypt
 *   IV                                       iv
 *
 * DKPARAMS for DeriveMech = RawDecrypt
 *   IV                                       iv
 *   WORD (enum `KeyType')                    dst_type
 *
 * DKPARAMS for DeriveMech = SSL3withRSA
 *   BIGNUM                                   ct
 *   SSLCLIENTRANDOM                          crnd
 *   SSLSERVERRANDOM                          srnd
 *
 * DKPARAMS for DeriveMech = PKCS8Encrypt
 *   IV                                       iv
 *
 * DKPARAMS for DeriveMech = PKCS8Decrypt
 *   IV                                       iv
 *
 * DKPARAMS for DeriveMech = RSAComponents
 *   WORD                                     n_ivs
 *   n_ivs * IV                               ivs
 *
 * DKPARAMS for DeriveMech = SSL3withDH
 *   BIGNUM                                   y
 *   SSLCLIENTRANDOM                          crnd
 *   SSLSERVERRANDOM                          srnd
 *
 * ARGS for Cmd = BignumOp
 *   WORD (flags)                             flags
 *   WORD                                     n_stackin
 *   n_stackin * BIGNUM                       stackin
 *   WORD                                     n_ops
 *   n_ops * STACKOPVAL                       ops
 *
 * ARGS for Cmd = GetAppData
 *   KEYID                                    key
 *
 * ARGS for Cmd = Fail
 *   MODULEID                                 module
 *
 * ARGS for Cmd = Encrypt
 *   WORD (flags)                             flags
 *   KEYID                                    key
 *   WORD (enum `Mech')                       mech
 *   PLAINTEXT                                plain
 *   IV                                       given_iv
 *     (if flag set in `flags')
 *
 * ARGS for Cmd = GetSlotList
 *   MODULEID                                 module
 *
 * ARGS for Cmd = GetRTC
 *   MODULEID                                 module
 *   WORD (flags)                             flags
 *
 * ARGS for Cmd = RetryFailedModule
 *   MODULEID                                 module
 *
 * ARGS for Cmd = UnimportSlot
 *   WORD (flags)                             flags
 *   MODULEID                                 module
 *   SLOTID                                   slot
 *
 * ARGS for Cmd = ChangeSharePIN
 *   WORD (flags)                             flags
 *   PHYSTOKEN                                token
 *   KMHASH                                   hkm
 *   SHORTHASH                                hkt
 *   WORD                                     i
 *   PIN                                      oldpin
 *     (if flag set in `flags')
 *   PIN                                      newpin
 *     (if flag set in `flags')
 *
 * ARGS for Cmd = OldExtEnquiry
 *   WORD                                     version
 *
 * WRAP_VEC_KEYHASHANDMECH:
 *   WORD                                     n
 *   n * KEYHASHANDMECH                       v
 *
 * WRAP_VEC_WORD:
 *   WORD                                     n
 *   n * WORD                                 v
 *
 * REMOTEMODULE:
 *   WORD (flags)                             flags
 *   MODULEATTRIBLIST                         ma
 *     (if flag set in `flags')
 *   NETWORKADDRESS                           addr
 *     (if flag set in `flags')
 *   WRAP_VEC_KEYHASHANDMECH                  hks
 *     (if flag set in `flags')
 *   IMPATHKXGROUPSELECTION                   groups
 *     (if flag set in `flags')
 *   WORD                                     agelimit
 *     (if flag set in `flags')
 *   WORD                                     datalimit
 *     (if flag set in `flags')
 *
 * CERTIFICATELIST:
 *   WORD                                     n_certs
 *   n_certs * CERTIFICATE                    certs
 *
 * ARGS for Cmd = ImportSlot
 *   WORD (flags)                             flags
 *   REMOTEMODULE                             to
 *   REMOTEMODULE                             from
 *   REMOTESLOTID                             rslot
 *   CERTIFICATELIST                          sendcert
 *
 * ARGS for Cmd = ReceiveShare
 *   WORD (flags)                             flags
 *   IMPATHID                                 imp
 *   KEYID                                    idkt
 *   BYTEBLOCK                                share
 *   PIN                                      pin
 *     (if flag set in `flags')
 *
 * ARGS for PhysTokenType = ISO7816
 *   WORD                                     header
 *   BYTEBLOCK                                datain
 *   WORD                                     le
 *
 * ARGS for Cmd = ForeignTokenCmd
 *   WORD (flags)                             flags
 *   KEYID                                    lock
 *   WORD (enum `PhysTokenType')              type
 *   ARGS (based on `type')                   args
 *
 * MKBLOBPARAMS for BlobFormat = Module
 *   KMHASH                                   hkm
 *
 * MKBLOBPARAMS for BlobFormat = Direct
 *   KEYID                                    idki
 *
 * MKBLOBPARAMS for BlobFormat = Token
 *   KEYID                                    idkt
 *
 * MKBLOBPARAMS for BlobFormat = Indirect
 *   KEYID                                    idkr
 *   WORD (enum `Mech')                       mech
 *
 * ARGS for Cmd = MakeBlob
 *   WORD (flags)                             flags
 *   WORD (enum `BlobFormat')                 format
 *   KEYID                                    idka
 *   MKBLOBPARAMS (based on `format')         blobkey
 *   ACL                                      acl
 *     (if flag set in `flags')
 *
 * ARGS for Cmd = RemoveKM
 *   MODULEID                                 module
 *   WORD (flags)                             flags
 *   KMHASH                                   hkm
 *
 * ARGS for Cmd = ProgrammingLoadBlock
 *   MODULEID                                 module
 *   WORD                                     offsetincipher
 *   BYTEBLOCK                                data
 *
 * TOKENPARAMS:
 *   WORD (flags)                             flags
 *   WORD                                     sharesneeded
 *   WORD                                     sharestotal
 *   WORD                                     timelimit
 *
 * ARGS for Cmd = GenerateLogicalToken
 *   MODULEID                                 module
 *   KMHASH                                   hkm
 *   TOKENPARAMS                              params
 *
 * ARGS for Cmd = ImpathSend
 *   WORD (flags)                             flags
 *   IMPATHID                                 imp
 *   BYTEBLOCK                                data
 *
 * ARGS for Cmd = SetSEEMachine
 *   WORD (flags)                             flags
 *   KEYID                                    buffer
 *
 * ARGS for Cmd = GetKeyInfoEx
 *   WORD (flags)                             flags
 *   KEYID                                    key
 *
 * FILEINFO:
 *   WORD (flags)                             flags
 *   WORD                                     length
 *   FILEID                                   id
 *
 * ARGS for Cmd = ReadFile
 *   WORD (flags)                             flags
 *   PHYSTOKEN                                token
 *   FILEINFO                                 file
 *
 * ARGS for Cmd = GetKMList
 *   MODULEID                                 module
 *   WORD (flags)                             flags
 *
 * ARGS for Cmd = OldEnquiry
 *   WORD (flags)                             flags
 *   MODULEID                                 module
 *     (if flag set in `flags')
 *
 * ARGS for Cmd = InsertSoftToken
 *   WORD (flags)                             flags
 *   PHYSTOKEN                                token
 *   BYTEBLOCK                                data
 *
 * ARGS for Cmd = ProgrammingGetKeyList
 *   MODULEID                                 module
 *
 * ARGS for Cmd = ModExpCrt
 *   BIGNUM                                   a
 *   BIGNUM                                   p
 *   BIGNUM                                   q
 *   BIGNUM                                   dmp1
 *   BIGNUM                                   dmq1
 *   BIGNUM                                   iqmp
 *
 * ARGS for Cmd = WriteFile
 *   WORD (flags)                             flags
 *   PHYSTOKEN                                token
 *   FILEINFO                                 file
 *   BYTEBLOCK                                data
 *
 * ARGS for Cmd = ClearUnit
 *   MODULEID                                 module
 *
 * ARGS for Cmd = NoOp
 *   MODULEID                                 module
 *
 * ARGS for Cmd = GetKeyInfo
 *   KEYID                                    key
 *
 * ARGS for Cmd = WriteShare
 *   WORD (flags)                             flags
 *   PHYSTOKEN                                token
 *   KEYID                                    idkt
 *   WORD                                     i
 *   PIN                                      pin
 *     (if flag set in `flags')
 *   ACL                                      acl
 *     (if flag set in `flags')
 *
 * NSOPERMS:
 *   WORD (flags)                             ops
 *
 * ARGS for Cmd = SetKNSO
 *   MODULEID                                 module
 *   NSOPERMS                                 needcertperms
 *   KEYHASH                                  hknso
 *
 * ARGS for Cmd = LoadRaw
 *   MODULEID                                 module
 *   WORD (flags)                             flags
 *   WORD                                     absoluteaddr
 *   BYTEBLOCK                                data
 *
 * ARGS for Cmd = Duplicate
 *   KEYID                                    key
 *
 * ARGS for Cmd = GetLogicalTokenInfoEx
 *   WORD (flags)                             flags
 *   KEYID                                    idkt
 *
 * ARGS for Cmd = StatGetValues
 *   WORD (flags)                             flags
 *   WORD                                     n_path_tags
 *   n_path_tags * WORD                       path_tags
 *
 * ARGS for Cmd = ListRemoteServerPermission
 *   WORD (enum `RemoteServerOp')             op
 *
 * ARGS for Cmd = ChannelUpdate
 *   WORD (flags)                             flags
 *   KEYID                                    idch
 *   BYTEBLOCK                                input
 *
 * DETAILS for RemoteServerOp = ExportSlot
 *   SLOTID                                   slot
 *
 * REMOTESERVERPERMISSION:
 *   WORD (flags)                             flags
 *   WORD                                     permid
 *   MODULEID                                 module
 *   WORD (enum `RemoteServerOp')             op
 *   DETAILS (based on `op')                  details
 *   REMOTEMODULE                             rm
 *
 * ARGS for Cmd = AddRemoteServerPermission
 *   REMOTESERVERPERMISSION                   permission
 *
 * ARGS for Cmd = Export
 *   KEYID                                    key
 *
 * ARGS for Cmd = GetWhichModule
 *   KEYID                                    key
 *
 * ARGS for Cmd = GetLogicalTokenInfo
 *   KEYID                                    idkt
 *
 * ARGS for Cmd = CreateSEEWorld
 *   WORD (flags)                             flags
 *   KEYID                                    buffer
 *
 * ARGS for Cmd = GetACL
 *   WORD (flags)                             flags
 *   KEYID                                    key
 *
 * ARGS for Cmd = RSAImmedSignDecrypt
 *   BIGNUM                                   m
 *   BIGNUM                                   k_p
 *   BIGNUM                                   k_q
 *   BIGNUM                                   k_dmp1
 *   BIGNUM                                   k_dmq1
 *   BIGNUM                                   k_iqmp
 *
 * ARGS for Cmd = RedeemTicket
 *   WORD (flags)                             flags
 *   MODULEID                                 module
 *   NEST_TICKET                              ticket
 *
 * ARGS for Cmd = ImpathKXFinish
 *   WORD (flags)                             flags
 *   IMPATHID                                 imp
 *   NETWORKADDRESS                           addr
 *     (if flag set in `flags')
 *   WORD                                     n_keys
 *   n_keys * KEYID                           keys
 *   BYTEBLOCK                                kx
 *
 * DETAILS for TicketDestination = NamedClient
 *   HASH                                     hclientid
 *
 * DETAILS for TicketDestination = NamedSEEWorld
 *   KEYID                                    world
 *
 * ARGS for Cmd = GetTicket
 *   WORD (flags)                             flags
 *   KEYID                                    obj
 *   WORD (enum `TicketDestination')          dest
 *   DETAILS (based on `dest')                destspec
 *
 * ARGS for Cmd = GetKLF
 *   MODULEID                                 module
 *
 * ARGS for Cmd = RSAImmedVerifyEncrypt
 *   BIGNUM                                   m
 *   BIGNUM                                   k_e
 *   BIGNUM                                   k_n
 *
 * ACL:
 *   WORD                                     n_groups
 *   n_groups * PERMISSIONGROUP               groups
 *
 * ARGS for Cmd = NVMemAlloc
 *   MODULEID                                 module
 *   WORD (flags)                             flags
 *   FILEINFO                                 info
 *   ACL                                      acl
 *
 * ARGS for Cmd = ImpathGetInfo
 *   IMPATHID                                 imp
 *
 * ARGS for Cmd = RemoveSoftToken
 *   WORD (flags)                             flags
 *   PHYSTOKEN                                token
 *
 * ARGS for Cmd = ModuleInfo
 *   MODULEID                                 module
 *   WORD (flags)                             flags
 *   WORD                                     format
 *
 * ARGS for Cmd = ProgrammingEndChunk
 *   MODULEID                                 module
 *
 * ARGS for Cmd = Maintenance
 *   MODULEID                                 module
 *
 * ARGS for Cmd = ExportSlot
 *   WORD (flags)                             flags
 *   MODULEID                                 module
 *   SLOTID                                   slot
 *
 * ARGS for Cmd = Decrypt
 *   WORD (flags)                             flags
 *   KEYID                                    key
 *   WORD (enum `Mech')                       mech
 *   CIPHERTEXT                               cipher
 *   WORD (enum `PlainTextType')              reply_type
 *
 * ARGS for Cmd = ServerSendShare
 *   WORD (flags)                             flags
 *   MUSTBEZEROWORD                           imp
 *   PHYSTOKEN                                token
 *   WORD                                     i
 *   KMHASH                                   hkm
 *   TOKENHASH                                hkt
 *   PIN                                      pin
 *     (if flag set in `flags')
 *
 * ARGS for Cmd = EraseShare
 *   PHYSTOKEN                                token
 *   SHORTHASH                                hkt
 *   WORD                                     i
 *
 * ARGS for Cmd = NewEnquiry
 *   WORD (flags)                             flags
 *   WORD                                     version
 *   MODULEID                                 module
 *
 * ARGS for Cmd = UpdateMergedKey
 *   KEYID                                    mkey
 *   WORD (flags)                             flags
 *   WORD                                     n_addkeys
 *   n_addkeys * KEYID                        addkeys
 *   WORD                                     n_delkeys
 *   n_delkeys * KEYID                        delkeys
 *
 * ARGS for Cmd = ModExp
 *   BIGNUM                                   a
 *   BIGNUM                                   p
 *   BIGNUM                                   n
 *
 * ARGS for Cmd = ChannelOpen
 *   MODULEID                                 module
 *   WORD (enum `ChannelType')                type
 *   WORD (flags)                             flags
 *   WORD (enum `ChannelMode')                mode
 *   WORD (enum `Mech')                       mech
 *   KEYID                                    key
 *     (if flag set in `flags')
 *   IV                                       given_iv
 *     (if flag set in `flags')
 *
 * ARGS for Cmd = SEEJob
 *   KEYID                                    worldid
 *   BYTEBLOCK                                seeargs
 *
 * RTCTIME:
 *   WORD                                     currenttimehigh
 *   WORD                                     currenttimelow
 *   WORD                                     currenttimenanos
 *   WORD                                     precision
 *
 * ARGS for Cmd = SetRTC
 *   MODULEID                                 module
 *   WORD (flags)                             flags
 *   RTCTIME                                  time
 *
 * ARGS for Cmd = Destroy
 *   KEYID                                    key
 *
 * ARGS for Cmd = ReadShare
 *   WORD (flags)                             flags
 *   PHYSTOKEN                                token
 *   KEYID                                    idkt
 *   WORD                                     i
 *   PIN                                      pin
 *     (if flag set in `flags')
 *
 * ARGS for Cmd = Sign
 *   WORD (flags)                             flags
 *   KEYID                                    key
 *   WORD (enum `Mech')                       mech
 *   PLAINTEXT                                plain
 *   IV                                       given_iv
 *     (if flag set in `flags')
 *
 * ARGS for Cmd = Import
 *   MODULEID                                 module
 *   KEYDATA                                  data
 *   ACL                                      acl
 *   APPDATA                                  appdata
 *
 * ARGS for Cmd = ProgrammingBegin
 *   MODULEID                                 module
 *   KEYHASH                                  hkfi
 *   KEYHASH                                  hkfc
 *   HASH                                     sdhash
 *   BYTEBLOCK                                sd
 *   CIPHERTEXT                               sig
 *
 * ARGS for Cmd = RemoveRemoteServerPermission
 *   WORD                                     permid
 *
 * ARGS for Cmd = GeneratePrime
 *   WORD                                     lenbits
 *
 * ARGS for Cmd = ExistingClient
 *   WORD (flags)                             flags
 *   CLIENTID                                 client
 *
 * ARGS for Cmd = SendShare
 *   WORD (flags)                             flags
 *   IMPATHID                                 imp
 *   PHYSTOKEN                                token
 *   WORD                                     i
 *   KMHASH                                   hkm
 *   TOKENHASH                                hkt
 *   PIN                                      pin
 *     (if flag set in `flags')
 *
 * ARGS for Cmd = ImpathKXBegin
 *   WORD (flags)                             flags
 *   MODULEID                                 module
 *   REMOTEMODULE                             me
 *   REMOTEMODULE                             him
 *   IMPATHKXGROUPSELECTION                   hisgroups
 *   NONCE                                    n
 *   WORD                                     n_keys
 *   n_keys * KEYID                           keys
 *
 * ARGS for Cmd = ForeignTokenOpen
 *   WORD (flags)                             flags
 *   PHYSTOKEN                                token
 *
 * USERACTIONINFO:
 *   USERACTIONID                             id
 *   WORD                                     perms
 *   BYTEBLOCK                                restriction
 *
 * ARGS for Cmd = CheckUserAction
 *   WORD (flags)                             flags
 *   KEYID                                    key
 *   USERACTIONINFO                           request
 *
 * ARGS for Cmd = EraseFile
 *   WORD (flags)                             flags
 *   PHYSTOKEN                                token
 *   FILEINFO                                 file
 *
 * ARGS for Cmd = InitialiseUnit
 *   MODULEID                                 module
 *
 * ARGS for Cmd = ProgrammingBeginChunk
 *   MODULEID                                 module
 *   WORD                                     index
 *   HASH                                     sdhash
 *   IV                                       iv
 *
 * ARGS for Cmd = Hash
 *   WORD (flags)                             flags
 *   WORD (enum `Mech')                       mech
 *   PLAINTEXT                                plain
 *
 * ARGS for Cmd = FormatToken
 *   WORD (flags)                             flags
 *   PHYSTOKEN                                token
 *   KMHASH                                   auth_key
 *     (if flag set in `flags')
 *
 * ARGS for Cmd = PollSlotList
 *   WORD (flags)                             flags
 *   MODULEID                                 module
 *
 * ARGS for Cmd = PollModuleState
 *   WORD (flags)                             flags
 *   MODULEID                                 module
 *
 * ARGS for Cmd = NVMemFree
 *   MODULEID                                 module
 *   WORD (flags)                             flags
 *   FILEID                                   name
 *
 * ARGS for Cmd = LoadLogicalToken
 *   MODULEID                                 module
 *   TOKENHASH                                hkt
 *   KMHASH                                   hkm
 *   TOKENPARAMS                              params
 *
 * ARGS for Cmd = SetKM
 *   MODULEID                                 module
 *   WORD (flags)                             flags
 *   KEYID                                    idka
 *
 * ARGS for Cmd = GenerateKLF
 *   MODULEID                                 module
 *   WORD (flags)                             flags
 *
 * ARGS for Cmd = DeriveKey
 *   WORD (flags)                             flags
 *   WORD (enum `DeriveMech')                 mech
 *   WORD                                     n_keys
 *   n_keys * KEYID                           keys
 *   DKPARAMS (based on `mech')               params
 *
 * ARGS for Cmd = StatEnumTree
 *   WORD (flags)                             flags
 *   WORD                                     n_path_tags
 *   n_path_tags * WORD                       path_tags
 *
 * OPVAL for NVMemOpType = BitClear
 *   BYTEBLOCK                                data
 *
 * OPVAL for NVMemOpType = Incr
 *   WORD                                     count
 *
 * OPVAL for NVMemOpType = Decr
 *   WORD                                     count
 *
 * OPVAL for NVMemOpType = BitSet
 *   BYTEBLOCK                                data
 *
 * OPVAL for NVMemOpType = Write
 *   BYTEBLOCK                                data
 *
 * ARGS for Cmd = NVMemOp
 *   MODULEID                                 module
 *   WORD (flags)                             flags
 *   FILEID                                   name
 *   NVMEMRANGE                               range
 *     (if flag set in `flags')
 *   WORD (enum `NVMemOpType')                op
 *   OPVAL (based on `op')                    val
 *
 * ARGS for Cmd = LoadBlob
 *   WORD (flags)                             flags
 *   MODULEID                                 module
 *   BYTEBLOCK                                blob
 *   KEYID                                    idkb
 *     (if flag set in `flags')
 *
 * FEATUREINFO:
 *   WORD (version tag)                       ver
 *   WORD (flags)                             ctrl
 *   WORD (flags)                             features
 *
 * ARGS for Cmd = StaticFeatureEnable
 *   MODULEID                                 module
 *   FEATUREINFO                              info
 *
 * ARGS for Cmd = GenerateKey
 *   WORD (flags)                             flags
 *   MODULEID                                 module
 *   KEYGENPARAMS                             params
 *   ACL                                      acl
 *   APPDATA                                  appdata
 *     (if flag set in `flags')
 *
 * ARGS for Cmd = NVMemList
 *   MODULEID                                 module
 *   WORD (flags)                             flags
 *
 * ARGS for Cmd = GetSlotInfo
 *   MODULEID                                 module
 *   SLOTID                                   slot
 *
 * ARGS for Cmd = CreateBuffer
 *   MODULEID                                 module
 *   WORD (flags)                             flags
 *   WORD                                     size
 *   ENCRYPTIONPARAMS                         params
 *     (if flag set in `flags')
 *
 * ARGS for Cmd = GetKML
 *   MODULEID                                 module
 *
 * ARGS for Cmd = GetShareACL
 *   WORD (flags)                             flags
 *   PHYSTOKEN                                token
 *   SHORTHASH                                hkt
 *   WORD                                     i
 *
 * ARGS for Cmd = GenerateKeyPair
 *   WORD (flags)                             flags
 *   MODULEID                                 module
 *   KEYGENPARAMS                             params
 *   ACL                                      aclpriv
 *   ACL                                      aclpub
 *   APPDATA                                  appdatapriv
 *     (if flag set in `flags')
 *   APPDATA                                  appdatapub
 *     (if flag set in `flags')
 *
 * ARGS for Cmd = GenerateRandom
 *   WORD                                     lenbytes
 *
 * PARAMS for FwAuthType = PRNG1
 *   WORD                                     variant
 *   WORD                                     index
 *
 * PARAMS for FwAuthType = NFFHMAC1
 *   KEYHASH                                  hkfc
 *   IV                                       iv
 *   WORD                                     chunk
 *   BYTEBLOCK                                mackey
 *
 * ARGS for Cmd = FirmwareAuthenticate
 *   MODULEID                                 module
 *   WORD (flags)                             flags
 *   WORD (enum `FwAuthType')                 type
 *   PARAMS (based on `type')                 challenge
 *
 * ARGS for Cmd = SetNSOPerms
 *   MODULEID                                 module
 *   WORD (flags)                             flags
 *   KEYHASH                                  hknso
 *   NSOPERMS                                 publicperms
 *
 * ARGS for Cmd = GetChallenge
 *   MODULEID                                 module
 *
 * SIGNERINFO for SignerType = AppKey
 *   KEYID                                    key
 *   WORD (enum `Mech')                       mech
 *
 * ARGS for Cmd = SignModuleState
 *   MODULEID                                 module
 *   WORD (flags)                             flags
 *   WORD (enum `SignerType')                 signer
 *   SIGNERINFO (based on `signer')           siginfo
 *   NONCE                                    challenge
 *     (if flag set in `flags')
 *
 * ARGS for Cmd = TraceSEEWorld
 *   KEYID                                    worldid
 *
 * ARGS for Cmd = MergeKeyIDs
 *   WORD                                     n_keys
 *   n_keys * KEYID                           keys
 *
 * ARGS for Cmd = ImpathReceive
 *   IMPATHID                                 imp
 *   BYTEBLOCK                                cipher
 *
 * ARGS for Cmd = NewClient
 *   WORD (flags)                             flags
 *
 * ARGS for Cmd = Verify
 *   WORD (flags)                             flags
 *   KEYID                                    key
 *   WORD (enum `Mech')                       mech
 *   PLAINTEXT                                plain
 *   CIPHERTEXT                               sig
 *
 * ARGS for Cmd = GetWorldSigners
 *   WORD (flags)                             flags
 *
 * ARGS for Cmd = PauseForNotifications
 *   MODULEID                                 module
 *   WORD (flags)                             flags
 *   WORD                                     ms
 *
 * ARGS for Cmd = SetAppData
 *   KEYID                                    key
 *   APPDATA                                  appdata
 *
 * ARGS for Cmd = LoadBuffer
 *   KEYID                                    id
 *   WORD (flags)                             flags
 *   BYTEBLOCK                                chunk
 *
 * ARGS for Cmd = ProgrammingEnd
 *   MODULEID                                 module
 *
 * ARGS for Cmd = SetACL
 *   WORD (flags)                             flags
 *   KEYID                                    key
 *   ACL                                      newacl
 *
 * COMMAND:
 *   TAG                                      tag
 *   WORD (enum `Cmd')                        cmd
 *   MUSTBEZEROWORD                           status
 *   WORD (flags)                             flags
 *   ARGS (based on `cmd')                    args
 *   CERTIFICATELIST                          certs
 *     (if flag set in `flags')
 *
 * STACKOPVAL:
 *   WORD (enum `StackOp')                    op
 *   WORD                                     val
 *
 * MODULEATTRIBLIST:
 *   WORD                                     n_attribs
 *   n_attribs * MODULEATTRIB                 attribs
 *
 * KEYHASHANDMECH:
 *   KEYHASH                                  hash
 *   WORD (enum `Mech')                       mech
 *
 * PERMISSIONGROUP:
 *   WORD (flags)                             flags
 *   WORD                                     n_limits
 *   n_limits * USELIMIT                      limits
 *   WORD                                     n_actions
 *   n_actions * ACTION                       actions
 *   KEYHASH                                  certifier
 *     (if flag set in `flags')
 *   KEYHASHANDMECH                           certmech
 *     (if flag set in `flags')
 *   ASCIISTRING                              moduleserial
 *     (if flag set in `flags')
 *
 * NVMEMRANGE:
 *   WORD                                     first
 *   WORD                                     last
 *
 * ENCRYPTIONPARAMS:
 *   KEYID                                    key
 *   IV                                       iv
 *
 * VALUE for ModuleAttribTag = PhysSerial
 *   ASCIISTRING                              physserial
 *
 * VALUE for ModuleAttribTag = Challenge
 *   NONCE                                    nonce
 *
 * VALUE for ModuleAttribTag = FeatureGoldCert
 *   WORD (enum `FeatureGoldCertVendor')      vendor
 *
 * VALUE for ModuleAttribTag = KNSO
 *   KEYHASH                                  hknso
 *   NSOPERMS                                 publicperms
 *
 * VALUE for ModuleAttribTag = KLF
 *   KEYHASH                                  hklf
 *   KEYDATA                                  klfpub
 *   WORD (enum `Mech')                       mech_i
 *
 * VALUE for ModuleAttribTag = KMList
 *   WORD                                     n_hkms
 *   n_hkms * KEYHASHATTRIB                   hkms
 *
 * VALUE for ModuleAttribTag = ESN
 *   ASCIISTRING                              esn
 *
 * VALUE for ModuleAttribTag = KML
 *   KEYHASH                                  hkml
 *   KEYDATA                                  kmlpub
 *   WORD (enum `Mech')                       mech_i
 *
 * ENQUIRYDATAONE:
 *   WORD                                     releasemajor
 *   WORD                                     releaseminor
 *   WORD                                     releasepatch
 *   WORD                                     checkintimehigh
 *   WORD                                     checkintimelow
 *   WORD (flags)                             flags
 *   WORD                                     speedindex
 *   WORD                                     recommendedminq
 *   WORD                                     recommendedmaxq
 *   ASCIISTRING                              hardwareserial
 *   ASCIISTRING                              softwaredetails
 *
 * ENQUIRYDATATWO:
 *   WORD (flags)                             flags
 *   WORD                                     maxwrite
 *
 * ENQUIRYDATATHREE:
 *   WORD (flags)                             flags
 *
 * ENQUIRYDATAFOUR:
 *   WORD (flags)                             flags
 *
 * ENQUIRYDATAFIVE:
 *   WORD (enum `ModuleType')                 moduletype
 *   ASCIISTRING                              productname
 *   ASCIISTRING                              devicename
 *
 * ENQUIRYDATASIX:
 *   WORD (version tag)                       v
 *   IMPATHKXGROUPSELECTION                   supportedgroups
 * (if v >= 1)
 *   FEATUREINFO                              features
 *
 * VALUE for ModuleAttribTag = Enquiry
 *   ENQUIRYDATAONE                           one
 *   ENQUIRYDATATWO                           two
 *   ENQUIRYDATATHREE                         three
 *   ENQUIRYDATAFOUR                          four
 *   ENQUIRYDATAFIVE                          five
 *   ENQUIRYDATASIX                           six
 *
 * VALUE for ModuleAttribTag = AdditionalInfo
 *   WORD (version tag)                       v
 *
 * MODULEATTRIB:
 *   WORD (enum `ModuleAttribTag')            tag
 *   VALUE (based on `tag')                   value
 *
 * DETAILS for UseLim = Global
 *   LIMITID                                  id
 *   WORD                                     max
 *
 * DETAILS for UseLim = Time
 *   WORD                                     seconds
 *
 * DETAILS for UseLim = Auth
 *   LIMITID                                  id
 *   WORD                                     max
 *
 * DETAILS for UseLim = NonVolatile
 *   WORD (flags)                             flags
 *   FILEID                                   file
 *   NVMEMRANGE                               range
 *   WORD                                     maxlo
 *   WORD                                     maxhi
 *   WORD                                     prefetch
 *
 * USELIMIT:
 *   WORD (enum `UseLim')                     type
 *   DETAILS (based on `type')                details
 *
 * DETAILS for Act = FeatureEnable
 *   WORD (flags)                             flags
 *
 * DETAILS for Act = DeriveKey
 *   WORD (flags)                             flags
 *   WORD (enum `DeriveRole')                 role
 *   WORD (enum `DeriveMech')                 mech
 *   WORD                                     n_otherkeys
 *   n_otherkeys * KEYROLEID                  otherkeys
 *
 * DETAILS for Act = SendShare
 *   WORD (flags)                             flags
 *   REMOTEMODULE                             rm
 *     (if flag set in `flags')
 *   READSHAREDETAILS                         rsd
 *     (if flag set in `flags')
 *
 * DETAILS for Act = NVMemUseLimit
 *   WORD (flags)                             flags
 *   NVMEMRANGE                               range
 *   WORD                                     n_hks
 *   n_hks * KEYHASH                          hks
 *
 * DETAILS for Act = NVMemOpPerms
 *   WORD (flags)                             perms
 *   NVMEMRANGE                               subrange
 *     (if flag set in `perms')
 *   NVMEMRANGE                               exactrange
 *     (if flag set in `perms')
 *   WORD                                     incdeclimit
 *     (if flag set in `perms')
 *
 * DETAILS for Act = StaticFeatureEnable
 *   FEATUREINFO                              info
 *
 * DETAILS for Act = NSOPermissions
 *   NSOPERMS                                 perms
 *
 * DETAILS for Act = OpPermissions
 *   WORD (flags)                             perms
 *
 * DETAILS for Act = MakeArchiveBlob
 *   WORD (flags)                             flags
 *   WORD (enum `Mech')                       mech
 *   KEYHASH                                  kahash
 *     (if flag set in `flags')
 *
 * DETAILS for Act = MakeBlob
 *   WORD (flags)                             flags
 *   KMHASH                                   kmhash
 *     (if flag set in `flags')
 *   TOKENHASH                                kthash
 *     (if flag set in `flags')
 *   TOKENPARAMS                              ktparams
 *     (if flag set in `flags')
 *
 * DETAILS for Act = UserAction
 *   USERACTIONINFO                           allow
 *
 * READSHAREDETAILS:
 *   WORD (flags)                             flags
 *
 * DETAILS for Act = ReadShare
 *   READSHAREDETAILS                         rsd
 *
 * ACTION:
 *   WORD (enum `Act')                        type
 *   DETAILS (based on `type')                details
 *
 * KEYHASHATTRIB:
 *   KEYHASH                                  hk
 *   WORD (enum `Mech')                       mech_i
 *   WORD (enum `Mech')                       mech_c
 *
 * KEYROLEID:
 *   WORD (enum `DeriveRole')                 role
 *   KEYHASH                                  hash
 *
 * REPLY for Cmd = Encrypt
 *   CIPHERTEXT                               cipher
 *
 * REPLY for Cmd = GetRTC
 *   RTCTIME                                  time
 *
 * REPLY for PhysTokenType = ISO7816
 *   BYTEBLOCK                                dataout
 *   WORD                                     sw1sw2
 *
 * REPLY for Cmd = ForeignTokenCmd
 *   WORD (enum `PhysTokenType')              type
 *   REPLY (based on `type')                  reply
 *
 * REPLY for Cmd = ImportSlot
 *   SLOTID                                   slot
 *
 * DATA for OldExtEnqVer = One
 *   ENQUIRYDATATWO                           two
 *
 * REPLY for Cmd = OldExtEnquiry
 *   WORD (enum `OldExtEnqVer')               version
 *   DATA (based on `version')                data
 *
 * REPLY for Cmd = MakeBlob
 *   BYTEBLOCK                                blob
 *
 * REPLY for Cmd = GenerateLogicalToken
 *   KEYID                                    idkt
 *   TOKENHASH                                hkt
 *
 * REPLY for Cmd = GetKMList
 *   WORD (flags)                             flags
 *   KEYHASH                                  hknso
 *   WORD                                     n_hkms
 *   n_hkms * KMHASH                          hkms
 *
 * REPLY for Cmd = Duplicate
 *   KEYID                                    newkey
 *
 * REPLY for Cmd = GetLogicalTokenInfoEx
 *   WORD (version tag)                       ver
 *   WORD (flags)                             flags
 *   WORD (enum `LogTokenState')              state
 *   TOKENHASH                                hkt
 *   KMHASH                                   hkm
 *   WORD                                     n_shares
 *   n_shares * LOGTOKENSHAREINFO             shares
 *   WORD                                     sharesneeded
 *
 * REPLY for Cmd = ListRemoteServerPermission
 *   WORD                                     n_permission
 *   n_permission * REMOTESERVERPERMISSION    permission
 *
 * REPLY for Cmd = ChannelUpdate
 *   BYTEBLOCK                                output
 *
 * REPLY for Cmd = GetWhichModule
 *   WORD                                     n_module
 *   n_module * MODULEID                      module
 *
 * REPLY for Cmd = GetACL
 *   NEST_ACL                                 acl
 *
 * REPLY for Cmd = RSAImmedSignDecrypt
 *   BIGNUM                                   r
 *
 * REPLY for Cmd = ANRemoteSlotDisconnected
 *   PHYSTOKEN                                slot
 *   WORD (enum `Status')                     st
 *   ERRORINFO (based on `st')                einfo
 *
 * REPLY for Cmd = RedeemTicket
 *   KEYID                                    obj
 *
 * REPLY for Cmd = GetTicket
 *   NEST_TICKET                              ticket
 *
 * REPLY for Cmd = GetKLF
 *   KEYID                                    idka
 *
 * IMPATHINFO:
 *   WORD (version tag)                       v
 *   WORD (enum `ImpathState')                state
 *   REMOTEMODULE                             rm
 *
 * REPLY for Cmd = ImpathGetInfo
 *   IMPATHINFO                               info
 *
 * REPLY for Cmd = RemoveSoftToken
 *   BYTEBLOCK                                data
 *
 * REPLY for Cmd = ANSlotChangeEvent
 *   WORD (flags)                             flags
 *   PHYSTOKEN                                slot
 *
 * REPLY for Cmd = ProgrammingEndChunk
 *   WORD (flags)                             flags
 *
 * SLOTLISTDATA:
 *   WORD (enum `SlotType')                   type
 *   WORD (flags)                             flags
 *   PHYSTOKEN                                token
 *   SLOTEXDATA (based on `type')             exdata
 *
 * POLLSLOTDATA:
 *   WORD                                     changeevents
 *   SLOTLISTDATA                             sld
 *
 * REPLY for Cmd = ExportSlot
 *   POLLSLOTDATA                             psd
 *
 * REPLY for Cmd = Decrypt
 *   PLAINTEXT                                plain
 *
 * REPLY for Cmd = ServerSendShare
 *   WORD (flags)                             flags
 *   BYTEBLOCK                                share
 *
 * DATA for EnqVer = Three
 *   ENQUIRYDATAONE                           one
 *   ENQUIRYDATATWO                           two
 *   ENQUIRYDATATHREE                         three
 *
 * DATA for EnqVer = Five
 *   ENQUIRYDATAONE                           one
 *   ENQUIRYDATATWO                           two
 *   ENQUIRYDATATHREE                         three
 *   ENQUIRYDATAFOUR                          four
 *   ENQUIRYDATAFIVE                          five
 *
 * DATA for EnqVer = Two
 *   ENQUIRYDATAONE                           one
 *   ENQUIRYDATATWO                           two
 *
 * DATA for EnqVer = Six
 *   ENQUIRYDATAONE                           one
 *   ENQUIRYDATATWO                           two
 *   ENQUIRYDATATHREE                         three
 *   ENQUIRYDATAFOUR                          four
 *   ENQUIRYDATAFIVE                          five
 *   ENQUIRYDATASIX                           six
 *
 * DATA for EnqVer = Four
 *   ENQUIRYDATAONE                           one
 *   ENQUIRYDATATWO                           two
 *   ENQUIRYDATATHREE                         three
 *   ENQUIRYDATAFOUR                          four
 *
 * DATA for EnqVer = One
 *   ENQUIRYDATAONE                           one
 *
 * REPLY for Cmd = NewEnquiry
 *   WORD (flags)                             flags
 *   MODULEID                                 module
 *   WORD (enum `EnqVer')                     version
 *   DATA (based on `version')                data
 *
 * REPLY for Cmd = ChannelOpen
 *   WORD (flags)                             flags
 *   KEYID                                    idch
 *   IV                                       new_iv
 *     (if flag set in `flags')
 *   CHANNELOPENINFO                          openinfo
 *
 * REPLY for Cmd = Import
 *   KEYID                                    key
 *
 * REPLY for Cmd = Sign
 *   CIPHERTEXT                               sig
 *
 * REPLY for Cmd = GeneratePrime
 *   BIGNUM                                   r
 *
 * REPLY for Cmd = ExistingClient
 *   WORD (flags)                             flags
 *
 * INFO for PhysTokenType = ISO7816
 *   BYTEBLOCK                                atr
 *
 * REPLY for Cmd = ForeignTokenOpen
 *   KEYID                                    lock
 *   WORD (enum `PhysTokenType')              type
 *   INFO (based on `type')                   info
 *
 * REPLY for Cmd = Hash
 *   CIPHERTEXT                               sig
 *
 * REPLY for Cmd = PollSlotList
 *   WORD (flags)                             flags
 *   WORD                                     n_slots
 *   n_slots * POLLSLOTDATA                   slots
 *
 * OPRES for NVMemOpType = GetACL
 *   ACL                                      acl
 *
 * OPRES for NVMemOpType = Read
 *   BYTEBLOCK                                data
 *
 * REPLY for Cmd = NVMemOp
 *   WORD (enum `NVMemOpType')                op
 *   OPRES (based on `op')                    res
 *
 * REPLY for Cmd = LoadBlob
 *   KEYID                                    idka
 *
 * REPLY for Cmd = NVMemList
 *   WORD (flags)                             flags
 *   WORD                                     n_infos
 *   n_infos * FILEINFO                       infos
 *
 * REPLY for Cmd = GetSlotInfo
 *   WORD                                     ic
 *   WORD (flags)                             flags
 *   WORD                                     n_tokens
 *   n_tokens * TOKENINFO                     tokens
 *   WORD                                     n_files
 *   n_files * FILEINFO                       files
 *   WORD                                     freespace
 *   KMHASH                                   auth_key
 *
 * REPLY for Cmd = CreateBuffer
 *   KEYID                                    id
 *
 * REPLY for Cmd = GetKML
 *   KEYID                                    idka
 *
 * RESP for FwAuthType = PRNG1
 *   BYTEBLOCK                                data
 *
 * RESP for FwAuthType = NFFHMAC1
 *   BYTEBLOCK                                mac
 *
 * REPLY for Cmd = FirmwareAuthenticate
 *   WORD (flags)                             flags
 *   WORD (enum `FwAuthType')                 type
 *   RESP (based on `type')                   response
 *
 * REPLY for Cmd = GetChallenge
 *   NONCE                                    nonce
 *
 * MODULECERT:
 *   CIPHERTEXT                               signature
 *   BYTEBLOCK                                modcertmsg
 *
 * REPLY for Cmd = SignModuleState
 *   MODULECERT                               cert
 *
 * REPLY for Cmd = TraceSEEWorld
 *   WORD (flags)                             flags
 *   BYTEBLOCK                                data
 *
 * REPLY for Cmd = MergeKeyIDs
 *   KEYID                                    newkey
 *
 * REPLY for Cmd = ImpathReceive
 *   BYTEBLOCK                                data
 *
 * REPLY for Cmd = BignumOp
 *   WORD                                     n_stackout
 *   n_stackout * BIGNUM                      stackout
 *
 * REPLY for Cmd = GetAppData
 *   APPDATA                                  appdata
 *
 * REPLY for Cmd = GetSlotList
 *   WORD                                     n_slots
 *   n_slots * SLOTLISTDATA                   slots
 *
 * REPLY for Cmd = ReceiveShare
 *   WORD                                     sharesleft
 *
 * REPLY for Cmd = ImpathSend
 *   BYTEBLOCK                                cipher
 *
 * REPLY for Cmd = GetKeyInfoEx
 *   WORD (version tag)                       ver
 *   WORD (flags)                             flags
 *   WORD (enum `KeyType')                    type
 *   WORD                                     length
 *   KEYHASH                                  hash
 *
 * REPLY for Cmd = ReadFile
 *   BYTEBLOCK                                data
 *
 * REPLY for Cmd = OldEnquiry
 *   ENQUIRYDATAONE                           one
 *
 * REPLY for Cmd = InsertSoftToken
 *   WORD                                     ic
 *
 * REPLY for Cmd = ProgrammingGetKeyList
 *   WORD                                     vsn
 *   WORD                                     n_kfcs
 *   n_kfcs * PROGRAMMINGKEYLISTENTRY         kfcs
 *   WORD                                     n_kfis
 *   n_kfis * PROGRAMMINGKEYLISTENTRY         kfis
 *
 * REPLY for Cmd = GetKeyInfo
 *   WORD (enum `KeyType')                    type
 *   KEYHASH                                  hash
 *
 * REPLY for Cmd = StatGetValues
 *   WORD (flags)                             flags
 *   WORD                                     n_statinfos
 *   n_statinfos * STATINFO                   statinfos
 *   WORD                                     n_values
 *   n_values * WORD                          values
 *
 * REPLY for Cmd = AddRemoteServerPermission
 *   WORD                                     permid
 *
 * REPLY for Cmd = Export
 *   KEYDATA                                  data
 *
 * REPLY for Cmd = GetLogicalTokenInfo
 *   WORD (enum `LogTokenState')              state
 *   TOKENHASH                                hkt
 *   WORD                                     n_shares
 *   n_shares * LOGTOKENSHAREINFO             shares
 *   WORD                                     sharesneeded
 *
 * REPLY for Cmd = CreateSEEWorld
 *   WORD                                     initstatus
 *   KEYID                                    worldid
 *
 * REPLY for Cmd = ANModuleChangeEvent
 *   WORD (flags)                             flags
 *   MODULEID                                 module
 *
 * INFO for InfoFormat = HardwareRev2
 *   WORD                                     n_devices
 *   n_devices * DEVICEID                     devices
 *
 * INFO for InfoFormat = HardwareRev1
 *   WORD (flags)                             flags
 *   WORD                                     base_code
 *   WORD                                     io_code
 *   WORD                                     scsi_id
 *   WORD                                     links
 *   WORD                                     n_cpus
 *   WORD                                     ram_size
 *
 * REPLY for Cmd = ModuleInfo
 *   WORD (enum `InfoFormat')                 format
 *   INFO (based on `format')                 info
 *
 * REPLY for Cmd = ModExp
 *   BIGNUM                                   r
 *
 * REPLY for Cmd = UpdateMergedKey
 *   WORD                                     n_keys
 *   n_keys * KEYID                           keys
 *
 * REPLY for Cmd = SEEJob
 *   BYTEBLOCK                                seereply
 *
 * REPLY for Cmd = ReadShare
 *   WORD                                     sharesleft
 *
 * REPLY for Cmd = SendShare
 *   WORD (flags)                             flags
 *   BYTEBLOCK                                share
 *
 * REPLY for Cmd = ImpathKXBegin
 *   IMPATHID                                 imp
 *   BYTEBLOCK                                kx
 *
 * REPLY for Cmd = GetClientHash
 *   HASH                                     hclientid
 *
 * REPLY for Cmd = ProgrammingBeginChunk
 *   WORD                                     maxblocksize
 *
 * REPLY for Cmd = PollModuleState
 *   WORD (version tag)                       version
 *   WORD (flags)                             flags
 *   WORD                                     stateevents
 *   WORD                                     nvmemevents
 *   WORD                                     rtcadjusts
 *
 * REPLY for Cmd = LoadLogicalToken
 *   KEYID                                    idkt
 *
 * REPLY for Cmd = DeriveKey
 *   KEYID                                    key
 *
 * REPLY for Cmd = StatEnumTree
 *   WORD (flags)                             flags
 *   WORD                                     n_statinfos
 *   n_statinfos * STATINFO                   statinfos
 *   WORD                                     n_subnodetags
 *   n_subnodetags * WORD                     subnodetags
 *
 * REPLY for Cmd = GenerateKey
 *   WORD (flags)                             flags
 *   KEYID                                    key
 *   MODULECERT                               cert
 *     (if flag set in `flags')
 *
 * REPLY for Cmd = GenerateKeyPair
 *   WORD (flags)                             flags
 *   KEYID                                    keypriv
 *   KEYID                                    keypub
 *   MODULECERT                               certpriv
 *     (if flag set in `flags')
 *   MODULECERT                               certpub
 *     (if flag set in `flags')
 *
 * REPLY for Cmd = GetShareACL
 *   ACL                                      acl
 *
 * REPLY for Cmd = GenerateRandom
 *   BYTEBLOCK                                data
 *
 * REPLY for Cmd = NewClient
 *   WORD (flags)                             flags
 *   CLIENTID                                 client
 *
 * REPLY for Cmd = GetWorldSigners
 *   WORD                                     n_sigs
 *   n_sigs * KEYHASHANDMECH                  sigs
 *
 * REPLY for Cmd = PauseForNotifications
 *   WORD (flags)                             flags
 *
 * REPLY:
 *   TAG                                      tag
 *   WORD (enum `Cmd')                        cmd
 *   WORD (enum `Status')                     status
 *   WORD (flags)                             flags
 *   REPLY (based on `cmd')                   reply
 *   ERRORINFO (based on `status')            errorinfo
 *
 * LOGTOKENSHAREINFO:
 *   WORD (enum `LogTokenShareState')         state
 *
 * TOKENINFO:
 *   WORD (flags)                             flags
 *   SHORTHASH                                hkt
 *   WORD                                     i
 *
 * PROGRAMMINGKEYLISTENTRY:
 *   WORD (enum `KeyType')                    type
 *   KEYHASH                                  hash
 *
 * STATINFO:
 *   WORD (enum `StatID')                     id
 *   WORD (flags)                             flags
 *
 * DEVICEID:
 *   WORD (enum `BusType')                    bus
 *   WORD                                     id
 *   WORD                                     other
 *
 * IMAGEMETADATAHEADER:
 *   WORD                                     len
 *   HASH                                     hash
 *
 * IMAGEMETADATA:
 *   HASH                                     imagehash
 *   WORD                                     vsn
 *   WORD                                     n_kfcs
 *   n_kfcs * KEYENTRY                        kfcs
 *   WORD                                     n_kfis
 *   n_kfis * KEYENTRY                        kfis
 *
 * KEYENTRY:
 *   HASH                                     hk
 *   KEYDATA                                  k
 *
 * OLDPROGRAMMINGSIGNEDDATA:
 *   WORD                                     n_chunks
 *   n_chunks * PROGRAMMINGCHUNKMETADATA      chunks
 *
 * PROGRAMMINGCHUNKMETADATA:
 *   WORD                                     size
 *   WORD                                     begin
 *   HASH                                     hash
 *
 * DATA for ProgSigDatFormat = Two
 *   WORD                                     vsn
 *   WORD (flags)                             flags
 *   OLDPROGRAMMINGSIGNEDDATA                 chunks
 *
 * PROGRAMMINGSIGNEDDATA:
 *   WORD                                     newpsdmagic
 *   WORD (enum `ProgSigDatFormat')           format
 *   DATA (based on `format')                 data
 *
 * FIRMWAREFILEHEADER:
 *   HASH                                     magic
 *   WORD                                     datalen
 *   HASH                                     datahash
 *
 * FIRMWAREFILEINFO:
 *   WORD                                     moduletype
 *   ASCIISTRING                              comment
 *   WORD (flags)                             flags
 *
 * DATA for FTVType = PRNG1
 *   WORD                                     variant
 *   WORD                                     maxindex
 *   HASH                                     hresult
 *
 * FIRMWARETESTVECTORS:
 *   WORD (enum `FTVType')                    type
 *   DATA (based on `type')                   data
 *
 * DATA for FirmwareFileType = TestVectors
 *   FIRMWAREFILEINFO                         infohdr
 *   FIRMWARETESTVECTORS                      tv
 *
 * FIRMWAREFILECOMMON:
 *   KEYHASH                                  hkfc
 *   WORD                                     n_sigs
 *   n_sigs * FIRMWARESIGNATURE               sigs
 *   WORD                                     n_chunks
 *   n_chunks * CIPHERTEXT                    chunks
 *
 * DATA for FirmwareFileType = NFast2
 *   FIRMWAREFILECOMMON                       common
 *
 * DATA for FirmwareFileType = NFast3
 *   FIRMWAREFILEINFO                         infohdr
 *   FIRMWAREFILECOMMON                       common
 *
 * FIRMWAREFILEDATA:
 *   WORD (enum `FirmwareFileType')           type
 *   DATA (based on `type')                   data
 *
 * FIRMWARESIGNATURE:
 *   HASH                                     sdhash
 *   KEYHASH                                  hkfi
 *   CIPHERTEXT                               sig
 *   BYTEBLOCK                                sd
 *
 * SIGNINGKEYENTRY:
 *   WORD (flags)                             flags
 *   WORD (enum `Mech')                       mech
 *   KEYHASH                                  hk
 *   KEYDATA                                  k
 *
 * SIGNINGKEYS:
 *   SIGNINGKEYENTRY                          kfc
 *   WORD                                     n_kfis
 *   n_kfis * SIGNINGKEYENTRY                 kfis
 *
 * CERTSIGNMESSAGE:
 *   WORD (enum `MagicValue')                 header
 *   WORD (flags)                             flags
 *   WORD                                     n_hks
 *   n_hks * KEYHASH                          hks
 *   NONCE                                    nonce
 *     (if flag set in `flags')
 *   ACL                                      acl
 *     (if flag set in `flags')
 *   WORD (enum `MagicValue')                 footer
 *
 * MODCERTDATA for ModCertType = KWARv0
 *   WORD (flags)                             flags
 *   KEYHASH                                  hkwa
 *
 * MODCERTDATA for ModCertType = OldKeyGen
 *   KEYGENPARAMS                             genparams
 *   ACL                                      acl
 *   HASH                                     hka
 *
 * MODCERTDATA for ModCertType = StateCert
 *   WORD (flags)                             flags
 *   MODULEATTRIBLIST                         state
 *
 * MODCERTDATA for ModCertType = KeyGen
 *   WORD (flags)                             flags
 *   KEYGENPARAMS                             genparams
 *   ACL                                      acl
 *   HASH                                     hka
 *
 * MODCERTDATA for ModCertType = ImpathKX
 *   NONCE                                    n
 *   CIPHERTEXT                               gx
 *   WORD (enum `ImpathKXGroup')              group
 *   IMPATHKXGROUPSELECTION                   mygroups
 *   ASCIISTRING                              esn
 *   REMOTEMODULE                             me
 *   REMOTEMODULE                             you
 *
 * MODCERTMSG:
 *   WORD (enum `ModCertType')                type
 *   MODCERTDATA (based on `type')            data
 *
 * STANDALONECERT:
 *   BYTEBLOCK                                message
 *   CIPHERTEXT                               signature
 *   KEYDATA                                  publickey
 *
 * WRAP_VEC_STANDALONECERT:
 *   WORD                                     n
 *   n * STANDALONECERT                       v
 *
 * WRAP_VEC_MODULEATTRIBSIG:
 *   WORD                                     n
 *   n * MODULEATTRIBSIG                      v
 *
 * MODULEATTRIBSIG:
 *   WORD (enum `ModuleAttribTag')            tag
 *   KEYHASH                                  hk
 *   CIPHERTEXT                               c
 *
 * BLOBEXDATA for BlobFormat = Module
 *   KMHASH                                   hkm
 *
 * BLOBEXDATA for BlobFormat = Direct
 *   KEYHASH                                  hki
 *
 * BLOBEXDATA for BlobFormat = Token
 *   KMHASH                                   hkm
 *   TOKENHASH                                hkt
 *
 * BLOBEXDATA for BlobFormat = Indirect
 *   KEYHASH                                  hkar
 *   CIPHERTEXT                               ktr_crypted
 *
 * BLOBDATA:
 *   WORD (enum `BlobFormat')                 format
 *   WORD                                     datalen
 *   BYTEBLOCK                                ka_data
 *   BLOBEXDATA (based on `format')           exdata
 *   WORD                                     imech
 *
 * EXTRAMCOI for ChannelType = DriverDirect
 *   MODULECHANNELID                          mcid
 *
 * MODULECHANNELOPENINFO:
 *   WORD (enum `ChannelType')                type
 *   EXTRAMCOI (based on `type')              info
 *
 * IMPATHKXMESSAGE:
 *   WORD (flags)                             flags
 *   BYTEBLOCK                                pubmsg
 *   MODULEATTRIBPROOF                        map
 *   WORD                                     n_sigs
 *   n_sigs * KEYHASHANDCIPHERTEXT            sigs
 *
 * KEYHASHANDCIPHERTEXT:
 *   KEYHASH                                  hash
 *   CIPHERTEXT                               c
 *
 * BODY for ImpathMsgType = UserData
 *   WORD (flags)                             flags
 *   BYTEBLOCK                                data
 *
 * BODY for ImpathMsgType = Share
 *   WORD (flags)                             flags
 *   BYTEBLOCK                                share
 *   WORD                                     i
 *   TOKENUNIQUEID                            tkid
 *   HASH                                     hacl
 *   WORD                                     imech
 *   WORD                                     len
 *
 * IMPATHMESSAGE:
 *   WORD (enum `ImpathMsgType')              type
 *   WORD                                     seq
 *   BODY (based on `type')                   body
 *
 * IMPATHCIPHERTEXT:
 *   BYTEBLOCK                                c
 *   CIPHERTEXT                               mac
 *
 * SIGNEDIMAGE:
 *   WORD                                     n_certs
 *   n_certs * SEECERTDATA                    certs
 *   BYTEBLOCK                                image
 *
 * SEECERTDATA:
 *   KEYHASH                                  hash
 *   KEYDATA                                  pubkey
 *   CIPHERTEXT                               signature
 *   BYTEBLOCK                                signmsg
 *
 * HASHEDSIGNEDIMAGE:
 *   BYTEBLOCK                                signedimage
 *   HASH                                     hash
 *
 * CODESIGNMESSAGE:
 *   WORD (enum `MagicValue')                 header
 *   CIPHERTEXT                               codehash
 *   WORD                                     n_attributes
 *   n_attributes * CODEATTRIBUTES            attributes
 *   WORD (enum `MagicValue')                 footer
 *
 * CODEATTRIBVALUE for CodeAttribTag = IsSEEWorld
 *   KEYHASH                                  machinekey
 *
 * CODEATTRIBVALUE for CodeAttribTag = IsSEEMachine
 *   WORD (enum `SEEMachineType')             type
 *
 * CODEATTRIBUTES:
 *   WORD (enum `CodeAttribTag')              tag
 *   CODEATTRIBVALUE (based on `tag')         value
 *
 * SEEARGS for SEEOpType = JavaSEECmdInstantiateObject
 *   WORD (flags)                             flags
 *   ASCIISTRING                              classname
 *   ASCIISTRING                              signature
 *   BYTEBLOCK                                args
 *
 * SEEARGS for SEEOpType = JavaSEECmdDeleteObject
 *   WORD (flags)                             flags
 *   JOBJID                                   jobjid
 *
 * SEEARGS for SEEOpType = JavaSEECmdInvokeMethod
 *   WORD (flags)                             flags
 *   JOBJID                                   jobjid
 *   ASCIISTRING                              signature
 *   BYTEBLOCK                                args
 *
 * SEEJOBARGS:
 *   WORD (enum `SEEOpType')                  op
 *   SEEARGS (based on `op')                  args
 *
 * SEERES for SEEOpType = JavaSEECmdInstantiateObject
 *   WORD (flags)                             flags
 *   JOBJID                                   jobjid
 *   SEEPASSBACKEXCEPTION                     exception
 *     (if flag set in `flags')
 *
 * SEEPASSBACKEXCEPTION:
 *   ASCIISTRING                              name
 *   ASCIISTRING                              string
 *
 * SEERES for SEEOpType = JavaSEECmdError
 *   SEEPASSBACKEXCEPTION                     exception
 *
 * SEERES for SEEOpType = JavaSEECmdInvokeMethod
 *   WORD (flags)                             flags
 *   BYTEBLOCK                                res
 *   SEEPASSBACKEXCEPTION                     exception
 *     (if flag set in `flags')
 *
 * SEEJOBRES:
 *   WORD (enum `SEEOpType')                  op
 *   SEERES (based on `op')                   res
 *
 * TICKETOBJSPEC for TicketType = Module
 *   WORD                                     space
 *   WORD                                     objid
 *
 * TICKETOBJSPEC for TicketType = Hardserver
 *   HASH                                     hclientid
 *   WORD                                     objid
 *
 * TICKETINFO:
 *   WORD (enum `TicketType')                 type
 *   TICKETOBJSPEC (based on `type')          target
 *   WORD (flags)                             flags
 *   HASH                                     hclientid
 *     (if flag set in `flags')
 *   WORD                                     destspace
 *     (if flag set in `flags')
 *   NONCE                                    challenge
 *     (if flag set in `flags')
 *
 * TICKET:
 *   NEST_TICKETINFO                          info
 *   HASH                                     mac
 *
 * SKYCERTLIST:
 *   WORD                                     n_certs
 *   n_certs * SKYCERT                        certs
 *
 * SKYCERT:
 *   BYTEBLOCK                                blobpubka
 *   CIPHERTEXT                               signature
 *   BYTEBLOCK                                certsignmsg
 *
 * KEYCERT:
 *   WORD (enum `MagicValue')                 header
 *   WORD (enum `KeyCertType')                type
 *   KEYHASH                                  nexthk
 *   WORD (enum `MagicValue')                 footer
 *
 * The following message variants are empty.
 *
 *   ERRORINFO for Status = NoModuleMemory
 *   ERRORINFO for Status = AlreadyExists
 *   ERRORINFO for Status = OSErrorErrno
 *   ERRORINFO for Status = UnknownPermID
 *   ERRORINFO for Status = Failed
 *   ERRORINFO for Status = SSLIllegalParameter
 *   ERRORINFO for Status = SSLDecryptionFailed
 *   ERRORINFO for Status = MechanismNotExpected
 *   ERRORINFO for Status = SSLUnexpectedMessage
 *   ERRORINFO for Status = SSLDecompressionFailure
 *   ERRORINFO for Status = SSLUserCanceled
 *   ERRORINFO for Status = Malformed
 *   ERRORINFO for Status = InvalidRM
 *   ERRORINFO for Status = DecryptFailed
 *   ERRORINFO for Status = SSLCertificateRevoked
 *   ERRORINFO for Status = InvalidSlot
 *   ERRORINFO for Status = NoKXGroup
 *   ERRORINFO for Status = UnknownCommand
 *   ERRORINFO for Status = SSLBadRecordMac
 *   ERRORINFO for Status = AccessDenied
 *   ERRORINFO for Status = TokenAuthFailed
 *   ERRORINFO for Status = UnknownID
 *   ERRORINFO for Status = SSLCertificateExpired
 *   ERRORINFO for Status = MetaDataProtection
 *   ERRORINFO for Status = TransactionNotFound
 *   ERRORINFO for Status = BlobTypeUnknown
 *   ERRORINFO for Status = SlotFull
 *   ERRORINFO for Status = OpStackOverflow
 *   ERRORINFO for Status = WriteProtected
 *   ERRORINFO for Status = UnknownDefault
 *   ERRORINFO for Status = TokenIOError
 *   ERRORINFO for Status = TokenAssemblyFailed
 *   ERRORINFO for Status = InvalidState
 *   ERRORINFO for Status = NoSpaceOnToken
 *   ERRORINFO for Status = TokenNotFormatted
 *   ERRORINFO for Status = UnknownParameter
 *   ERRORINFO for Status = PhysTokenNotPresent
 *   ERRORINFO for Status = SSLDecryptError
 *   ERRORINFO for Status = InvalidHostDataIdentifier
 *   ERRORINFO for Status = SSLBadCertificate
 *   ERRORINFO for Status = NotAvailable
 *   ERRORINFO for Status = ClientUnknown
 *   ERRORINFO for Status = NoMemory
 *   ERRORINFO for Status = ObjectInUse
 *   ERRORINFO for Status = BadMachineImage
 *   ERRORINFO for Status = BadWorldImage
 *   ERRORINFO for Status = UserCancelled
 *   ERRORINFO for Status = TransactionNotYetComplete
 *   ERRORINFO for Status = ObjectNotReady
 *   ERRORINFO for Status = BufferFull
 *   ERRORINFO for Status = TypeMismatch
 *   ERRORINFO for Status = BadCertSignature
 *   ERRORINFO for Status = ServerFailed
 *   ERRORINFO for Status = UnknownSlot
 *   ERRORINFO for Status = SSLCertificateUnknown
 *   ERRORINFO for Status = ServerConnectionLost
 *   ERRORINFO for Status = ImpathReplay
 *   ERRORINFO for Status = VerifyFailed
 *   ERRORINFO for Status = StrictFIPS140
 *   ERRORINFO for Status = SSLDecodeError
 *   ERRORINFO for Status = SSLNoCertificate
 *   ERRORINFO for Status = SSLInsufficientSecurity
 *   ERRORINFO for Status = SSLRecordOverFlow
 *   ERRORINFO for Status = LogTokenNotPresent
 *   ERRORINFO for Status = InvalidModule
 *   ERRORINFO for Status = UnknownChallenge
 *   ERRORINFO for Status = InvalidParameter
 *   ERRORINFO for Status = MalformedCertificate
 *   ERRORINFO for Status = ImpathMsgTypeMismatch
 *   ERRORINFO for Status = ReadOnly
 *   ERRORINFO for Status = UnknownStatus
 *   ERRORINFO for Status = UnknownKM
 *   ERRORINFO for Status = HostDataAccessDenied
 *   ERRORINFO for Status = ImpathDataLimitExceeded
 *   ERRORINFO for Status = ImpathTimeLimitExceeded
 *   ERRORINFO for Status = UnknownTokenType
 *   ERRORINFO for Status = SSLProtocolVersion
 *   ERRORINFO for Status = BadShareState
 *   ERRORINFO for Status = OperationFailed
 *   ERRORINFO for Status = UnitReset
 *   ERRORINFO for Status = UnknownFlag
 *   ERRORINFO for Status = HostDataAccessFailed
 *   ERRORINFO for Status = UnknownMechanism
 *   ERRORINFO for Status = TimeLimitExceeded
 *   ERRORINFO for Status = ImpathNotReady
 *   ERRORINFO for Status = NoUpcall
 *   ERRORINFO for Status = NoHostMemory
 *   ERRORINFO for Status = EncryptFailed
 *   ERRORINFO for Status = IncorrectRepositoryName
 *   ERRORINFO for Status = InvalidMergedKey
 *   ERRORINFO for Status = ServerAccessDenied
 *   ERRORINFO for Status = InvalidACL
 *   ERRORINFO for Status = BadTokenData
 *   ERRORINFO for Status = SSLExportRestriction
 *   ERRORINFO for Status = Cancelled
 *   ERRORINFO for Status = OpStackUnderflow
 *   ERRORINFO for Status = HostDataInvalid
 *   ERRORINFO for Status = BadCertKeyHash
 *   ERRORINFO for Status = SSLUnknownCA
 *   ERRORINFO for Status = ArithmeticError
 *   ERRORINFO for Status = SEEWorldFailed
 *   ERRORINFO for Status = UnsupportedChannelType
 *   ERRORINFO for Status = AsynchNotification
 *   ERRORINFO for Status = HardwareFailed
 *   ERRORINFO for Status = OK
 *   ERRORINFO for Status = KeyNotLoaded
 *   ERRORINFO for Status = NotYetImplemented
 *   ERRORINFO for Status = InvalidMonitorMultiple
 *   ERRORINFO for Status = NSTBadMessage
 *   ERRORINFO for Status = UseLimitExceeded
 *   ERRORINFO for Status = PrivilegedCommand
 *   ERRORINFO for Status = SSLInternalError
 *   ERRORINFO for Status = ForeignTokenLocked
 *   ERRORINFO for Status = SSLUnsupportedCertificate
 *   ERRORINFO for Status = SoftwareFailed
 *   ERRORINFO for Status = SSLNoRenogotiation
 *   ERRORINFO for Status = InProgress
 *   ERRORINFO for Status = InvalidCertificate
 *   ERRORINFO for Status = IncorrectToken
 *   ERRORINFO for Status = SSLHandshakeFailure
 *   ERRORINFO for Status = UnknownKey
 *   ERRORINFO for Status = ServerNotRunning
 *   ERRORINFO for Status = SSLAccessDenied
 *   ERRORINFO for Status = NegativeResult
 *   ERRORINFO for Status = OutOfRange
 *   ERRORINFO for Status = InvalidData
 *   ERRORINFO for Status = HostUnknownKeyType
 *   ERRORINFO for Status = OperationTimeout
 *   INFO for CrossModReason = ServerUnitReset
 *   INFO for CrossModReason = Mode
 *   INFO for CrossModReason = ExplicitRequest
 *   INFO for CrossModReason = HardwareFailed
 *   INFO for CrossModReason = ServerKey
 *   SLOTEXDATA for SlotType = SoftToken
 *   SLOTEXDATA for SlotType = DataKey
 *   SLOTEXDATA for SlotType = Emulated
 *   SLOTEXDATA for SlotType = SmartCard
 *   SLOTEXDATA for SlotType = Unknown
 *   EXTRACCOI for ChannelType = Simple
 *   IV for Mech = KCDSARIPEMD160
 *   IV for Mech = HAS160Hash
 *   IV for Mech = HMACMD2
 *   IV for Mech = TwofishmECBpNONE
 *   IV for Mech = DES2mECBpNONE
 *   IV for Mech = RC5mECBpPKCS5
 *   IV for Mech = HMACMD5
 *   IV for Mech = CAST256mECBpPKCS5
 *   IV for Mech = DES3AltwSHA1
 *   IV for Mech = SHA1Hash
 *   IV for Mech = ArcFourpNONE
 *   IV for Mech = DES3AltwCRC32
 *   IV for Mech = DSA
 *   IV for Mech = CAST256mECBpNONE
 *   IV for Mech = CASTmECBpNONE
 *   IV for Mech = SEEDmECBpNONE
 *   IV for Mech = SerpentmECBpNONE
 *   IV for Mech = RSApSETOAEP
 *   IV for Mech = SEEDmECBpPKCS5
 *   IV for Mech = SHA512Hash
 *   IV for Mech = HMACSHA256
 *   IV for Mech = DES3wCRC32
 *   IV for Mech = SkipjackmECBpPKCS5
 *   IV for Mech = SHA384Hash
 *   IV for Mech = MD2Hash
 *   IV for Mech = DES3mECBpNONE
 *   IV for Mech = RSApPKCS1
 *   IV for Mech = HMACSHA1
 *   IV for Mech = DLIESe3DEShSHA1
 *   IV for Mech = RC5mECBpNONE
 *   IV for Mech = RC2mECBpNONE
 *   IV for Mech = DLIESeAEShSHA1
 *   IV for Mech = HMACRIPEMD160
 *   IV for Mech = DES3mECBpPKCS5
 *   IV for Mech = BlowfishmECBpPKCS5
 *   IV for Mech = HMACSHA512
 *   IV for Mech = RC2mECBpPKCS5
 *   IV for Mech = RIPEMD160Hash
 *   IV for Mech = SerpentmECBpPKCS5
 *   IV for Mech = RSAhRIPEMD160pPKCS1
 *   IV for Mech = RSAhMD5pPKCS1
 *   IV for Mech = Imech
 *   IV for Mech = TwofishmECBpPKCS5
 *   IV for Mech = IDEAmECBpPKCS5
 *   IV for Mech = RijndaelmECBpNONE
 *   IV for Mech = TigerHash
 *   IV for Mech = DESmECBpNONE
 *   IV for Mech = DES2mECBpPKCS5
 *   IV for Mech = IDEAmECBpNONE
 *   IV for Mech = HMACTiger
 *   IV for Mech = SHA256Hash
 *   IV for Mech = KCDSAHAS160
 *   IV for Mech = DES3wSHA1
 *   IV for Mech = BlowfishmECBpNONE
 *   IV for Mech = RSApPKCS1pPKCS11
 *   IV for Mech = CASTmECBpPKCS5
 *   IV for Mech = DHKeyExchange
 *   IV for Mech = HMACSHA384
 *   IV for Mech = RSAhASCIIHexSHA1pPKCS1
 *   IV for Mech = DESmECBpPKCS5
 *   IV for Mech = KCDSASHA1
 *   IV for Mech = RSAhSHA1pPKCS1
 *   IV for Mech = RijndaelmECBpPKCS5
 *   IV for Mech = ElGamal
 *   IV for Mech = SkipjackmECBpNONE
 *   IV for Mech = MD5Hash
 *   CERTBODY for CertType = SEECert
 *   CERTBODY for CertType = Invalid
 *   GENPARAMS for KeyType = DES3
 *   GENPARAMS for KeyType = Skipjack
 *   GENPARAMS for KeyType = DES
 *   GENPARAMS for KeyType = SSLMasterSecret
 *   GENPARAMS for KeyType = IDEA
 *   GENPARAMS for KeyType = SEED
 *   GENPARAMS for KeyType = DES2
 *   DKPARAMS for DeriveMech = DESjoinXOR
 *   DKPARAMS for DeriveMech = DES2joinXORsetParity
 *   DKPARAMS for DeriveMech = CASTsplitXOR
 *   DKPARAMS for DeriveMech = DecryptMarshalled
 *   DKPARAMS for DeriveMech = RandjoinXOR
 *   DKPARAMS for DeriveMech = EncryptMarshalled
 *   DKPARAMS for DeriveMech = DES2splitXOR
 *   DKPARAMS for DeriveMech = DESsplitXOR
 *   DKPARAMS for DeriveMech = CASTjoinXOR
 *   DKPARAMS for DeriveMech = DES2joinXOR
 *   DKPARAMS for DeriveMech = DES3splitXOR
 *   DKPARAMS for DeriveMech = DES3joinXORsetParity
 *   DKPARAMS for DeriveMech = DESjoinXORsetParity
 *   DKPARAMS for DeriveMech = DES3joinXOR
 *   DKPARAMS for DeriveMech = RandsplitXOR
 *   ARGS for PhysTokenType = Invalid
 *   DETAILS for TicketDestination = Any
 *   DETAILS for TicketDestination = AnySEEWorld
 *   DETAILS for TicketDestination = AnyClient
 *   OPVAL for NVMemOpType = GetACL
 *   OPVAL for NVMemOpType = Read
 *   OPVAL for NVMemOpType = Free
 *   SIGNERINFO for SignerType = KLF
 *   SIGNERINFO for SignerType = KML
 *   ARGS for Cmd = ErrorReturn
 *   ARGS for Cmd = GetClientHash
 *   VALUE for ModuleAttribTag = PhysFIPSl3
 *   DETAILS for Act = NoAction
 *   REPLY for PhysTokenType = Invalid
 *   DATA for OldExtEnqVer = Zero
 *   DATA for EnqVer = Zero
 *   INFO for PhysTokenType = Invalid
 *   OPRES for NVMemOpType = BitClear
 *   OPRES for NVMemOpType = Incr
 *   OPRES for NVMemOpType = Decr
 *   OPRES for NVMemOpType = BitSet
 *   OPRES for NVMemOpType = Write
 *   OPRES for NVMemOpType = Free
 *   REPLY for Cmd = RetryFailedModule
 *   REPLY for Cmd = ErrorReturn
 *   REPLY for Cmd = RemoveKM
 *   REPLY for Cmd = SetSEEMachine
 *   REPLY for Cmd = WriteFile
 *   REPLY for Cmd = ClearUnit
 *   REPLY for Cmd = WriteShare
 *   REPLY for Cmd = SetKNSO
 *   REPLY for Cmd = LoadRaw
 *   REPLY for Cmd = Maintenance
 *   REPLY for Cmd = EraseShare
 *   REPLY for Cmd = Destroy
 *   REPLY for Cmd = ProgrammingBegin
 *   REPLY for Cmd = RemoveRemoteServerPermission
 *   REPLY for Cmd = CheckUserAction
 *   REPLY for Cmd = InitialiseUnit
 *   REPLY for Cmd = EraseFile
 *   REPLY for Cmd = FormatToken
 *   REPLY for Cmd = NVMemFree
 *   REPLY for Cmd = GenerateKLF
 *   REPLY for Cmd = ANModuleReset
 *   REPLY for Cmd = StaticFeatureEnable
 *   REPLY for Cmd = Verify
 *   REPLY for Cmd = SetAppData
 *   REPLY for Cmd = ProgrammingEnd
 *   REPLY for Cmd = Fail
 *   REPLY for Cmd = UnimportSlot
 *   REPLY for Cmd = ChangeSharePIN
 *   REPLY for Cmd = ProgrammingLoadBlock
 *   REPLY for Cmd = NoOp
 *   REPLY for Cmd = ANPleaseClearUnitNow
 *   REPLY for Cmd = ANReadTerminated
 *   REPLY for Cmd = ImpathKXFinish
 *   REPLY for Cmd = ANPleaseClearUnitSoon
 *   REPLY for Cmd = NVMemAlloc
 *   REPLY for Cmd = SetRTC
 *   REPLY for Cmd = SetKM
 *   REPLY for Cmd = SetNSOPerms
 *   REPLY for Cmd = LoadBuffer
 *   REPLY for Cmd = SetACL
 *   EXTRAMCOI for ChannelType = Simple
 *   SEEARGS for SEEOpType = JavaSEECmdError
 *   SEERES for SEEOpType = JavaSEECmdDeleteObject
 *   TICKETOBJSPEC for TicketType = Invalid
 */

/*----- That's all, folks -------------------------------------------------*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nfast\inc\messages-a-enstr.h ===
/* -*-c-*-
 *
 * Generated by Marshmallow at 2003-04-16T17:13:58
 */

#ifndef MESSAGES_A_ENSTR_H
#define MESSAGES_A_ENSTR_H

/* --- Table format --- */

#ifndef NF_VALINFO
#define NF_VALINFO

typedef struct NF_ValInfo {
  M_Word code;
  const char *string;
} NF_ValInfo;

#endif

/* --- Required functions --- */

const char *NF_Lookup(M_Word val, const NF_ValInfo *vit);
int NF_LookupString(const char *string, M_Word *result, const NF_ValInfo *vit);

/* --- Enumeration and flag tables --- */

extern const NF_ValInfo NF_Status_enumtable[];
extern const NF_ValInfo NF_nCErrno_enumtable[];
extern const NF_ValInfo NF_NetworkAddressFamily_enumtable[];
extern const NF_ValInfo NF_CrossModReason_enumtable[];
extern const NF_ValInfo NF_SlotType_enumtable[];
extern const NF_ValInfo NF_ChannelType_enumtable[];
extern const NF_ValInfo NF_CertType_enumtable[];
extern const NF_ValInfo NF_KeyType_enumtable[];
extern const NF_ValInfo NF_Mech_enumtable[];
extern const NF_ValInfo NF_SSLCipherSuite_enumtable[];
extern const NF_ValInfo NF_ImpathKXGroup_enumtable[];
extern const NF_ValInfo NF_PlainTextType_enumtable[];
extern const NF_ValInfo NF_DeriveMech_enumtable[];
extern const NF_ValInfo NF_Cmd_enumtable[];
extern const NF_ValInfo NF_PhysTokenType_enumtable[];
extern const NF_ValInfo NF_BlobFormat_enumtable[];
extern const NF_ValInfo NF_RemoteServerOp_enumtable[];
extern const NF_ValInfo NF_TicketDestination_enumtable[];
extern const NF_ValInfo NF_ChannelMode_enumtable[];
extern const NF_ValInfo NF_NVMemOpType_enumtable[];
extern const NF_ValInfo NF_FwAuthType_enumtable[];
extern const NF_ValInfo NF_SignerType_enumtable[];
extern const NF_ValInfo NF_StackOp_enumtable[];
extern const NF_ValInfo NF_ModuleAttribTag_enumtable[];
extern const NF_ValInfo NF_FeatureGoldCertVendor_enumtable[];
extern const NF_ValInfo NF_ModuleType_enumtable[];
extern const NF_ValInfo NF_UseLim_enumtable[];
extern const NF_ValInfo NF_Act_enumtable[];
extern const NF_ValInfo NF_DeriveRole_enumtable[];
extern const NF_ValInfo NF_OldExtEnqVer_enumtable[];
extern const NF_ValInfo NF_LogTokenState_enumtable[];
extern const NF_ValInfo NF_ImpathState_enumtable[];
extern const NF_ValInfo NF_EnqVer_enumtable[];
extern const NF_ValInfo NF_InfoFormat_enumtable[];
extern const NF_ValInfo NF_LogTokenShareState_enumtable[];
extern const NF_ValInfo NF_StatID_enumtable[];
extern const NF_ValInfo NF_BusType_enumtable[];
extern const NF_ValInfo NF_ProgSigDatFormat_enumtable[];
extern const NF_ValInfo NF_FirmwareFileType_enumtable[];
extern const NF_ValInfo NF_FTVType_enumtable[];
extern const NF_ValInfo NF_MagicValue_enumtable[];
extern const NF_ValInfo NF_ModCertType_enumtable[];
extern const NF_ValInfo NF_ImpathMsgType_enumtable[];
extern const NF_ValInfo NF_CodeAttribTag_enumtable[];
extern const NF_ValInfo NF_SEEMachineType_enumtable[];
extern const NF_ValInfo NF_SEEOpType_enumtable[];
extern const NF_ValInfo NF_TicketType_enumtable[];
extern const NF_ValInfo NF_KeyCertType_enumtable[];
extern const NF_ValInfo NF_StatNodeTag_enumtable[];
extern const NF_ValInfo NF_TestVal_enumtable[];
extern const NF_ValInfo NF_SEEInitStatus_enumtable[];

extern const NF_ValInfo NF_Status_RemoteServerFailed_ErrorInfo_flags_table[];
extern const NF_ValInfo NF_Mech_SSLRecordLayer_IV_flags_table[];
extern const NF_ValInfo NF_KeyType_Wrapped_GenParams_flags_table[];
extern const NF_ValInfo NF_KeyType_DSAPrivate_GenParams_flags_table[];
extern const NF_ValInfo NF_KeyType_DHPrivate_GenParams_flags_table[];
extern const NF_ValInfo NF_KeyType_KCDSAPrivate_GenParams_flags_table[];
extern const NF_ValInfo NF_KeyType_RSAPrivate_GenParams_flags_table[];
extern const NF_ValInfo NF_KeyType_KCDSAComm_GenParams_flags_table[];
extern const NF_ValInfo NF_KeyType_DSAComm_GenParams_flags_table[];
extern const NF_ValInfo NF_Command_flags_table[];
extern const NF_ValInfo NF_Cmd_BignumOp_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_Encrypt_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_GetRTC_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_UnimportSlot_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_ChangeSharePIN_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_ImportSlot_Args_flags_table[];
extern const NF_ValInfo NF_RemoteModule_flags_table[];
extern const NF_ValInfo NF_Cmd_ReceiveShare_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_ForeignTokenCmd_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_MakeBlob_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_RemoveKM_Args_flags_table[];
extern const NF_ValInfo NF_TokenParams_flags_table[];
extern const NF_ValInfo NF_Cmd_ImpathSend_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_SetSEEMachine_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_GetKeyInfoEx_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_ReadFile_Args_flags_table[];
extern const NF_ValInfo NF_FileInfo_flags_table[];
extern const NF_ValInfo NF_Cmd_GetKMList_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_OldEnquiry_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_InsertSoftToken_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_WriteFile_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_WriteShare_Args_flags_table[];
extern const NF_ValInfo NF_NSOPerms_ops_table[];
extern const NF_ValInfo NF_Cmd_LoadRaw_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_GetLogicalTokenInfoEx_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_StatGetValues_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_ChannelUpdate_Args_flags_table[];
extern const NF_ValInfo NF_RemoteServerPermission_flags_table[];
extern const NF_ValInfo NF_Cmd_CreateSEEWorld_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_GetACL_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_RedeemTicket_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_ImpathKXFinish_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_GetTicket_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_NVMemAlloc_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_RemoveSoftToken_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_ModuleInfo_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_ExportSlot_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_Decrypt_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_ServerSendShare_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_NewEnquiry_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_UpdateMergedKey_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_ChannelOpen_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_SetRTC_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_ReadShare_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_Sign_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_ExistingClient_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_SendShare_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_ImpathKXBegin_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_ForeignTokenOpen_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_CheckUserAction_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_EraseFile_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_Hash_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_FormatToken_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_PollSlotList_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_PollModuleState_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_NVMemFree_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_SetKM_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_GenerateKLF_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_DeriveKey_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_StatEnumTree_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_NVMemOp_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_LoadBlob_Args_flags_table[];
extern const NF_ValInfo NF_FeatureInfo_ctrl_table[];
extern const NF_ValInfo NF_FeatureInfo_features_table[];
extern const NF_ValInfo NF_Cmd_GenerateKey_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_NVMemList_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_CreateBuffer_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_GetShareACL_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_GenerateKeyPair_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_FirmwareAuthenticate_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_SetNSOPerms_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_SignModuleState_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_NewClient_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_Verify_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_GetWorldSigners_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_PauseForNotifications_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_LoadBuffer_Args_flags_table[];
extern const NF_ValInfo NF_Cmd_SetACL_Args_flags_table[];
extern const NF_ValInfo NF_PermissionGroup_flags_table[];
extern const NF_ValInfo NF_EnquiryDataOne_flags_table[];
extern const NF_ValInfo NF_EnquiryDataTwo_flags_table[];
extern const NF_ValInfo NF_EnquiryDataThree_flags_table[];
extern const NF_ValInfo NF_EnquiryDataFour_flags_table[];
extern const NF_ValInfo NF_UseLim_NonVolatile_Details_flags_table[];
extern const NF_ValInfo NF_Act_FeatureEnable_Details_flags_table[];
extern const NF_ValInfo NF_Act_DeriveKey_Details_flags_table[];
extern const NF_ValInfo NF_Act_SendShare_Details_flags_table[];
extern const NF_ValInfo NF_Act_NVMemUseLimit_Details_flags_table[];
extern const NF_ValInfo NF_Act_NVMemOpPerms_Details_perms_table[];
extern const NF_ValInfo NF_Act_OpPermissions_Details_perms_table[];
extern const NF_ValInfo NF_Act_MakeArchiveBlob_Details_flags_table[];
extern const NF_ValInfo NF_Act_MakeBlob_Details_flags_table[];
extern const NF_ValInfo NF_ReadShareDetails_flags_table[];
extern const NF_ValInfo NF_Reply_flags_table[];
extern const NF_ValInfo NF_Cmd_GetKMList_Reply_flags_table[];
extern const NF_ValInfo NF_Cmd_GetLogicalTokenInfoEx_Reply_flags_table[];
extern const NF_ValInfo NF_Cmd_ANSlotChangeEvent_Reply_flags_table[];
extern const NF_ValInfo NF_Cmd_ProgrammingEndChunk_Reply_flags_table[];
extern const NF_ValInfo NF_SlotListData_flags_table[];
extern const NF_ValInfo NF_Cmd_ServerSendShare_Reply_flags_table[];
extern const NF_ValInfo NF_Cmd_NewEnquiry_Reply_flags_table[];
extern const NF_ValInfo NF_Cmd_ChannelOpen_Reply_flags_table[];
extern const NF_ValInfo NF_Cmd_ExistingClient_Reply_flags_table[];
extern const NF_ValInfo NF_Cmd_PollSlotList_Reply_flags_table[];
extern const NF_ValInfo NF_Cmd_NVMemList_Reply_flags_table[];
extern const NF_ValInfo NF_Cmd_GetSlotInfo_Reply_flags_table[];
extern const NF_ValInfo NF_Cmd_FirmwareAuthenticate_Reply_flags_table[];
extern const NF_ValInfo NF_Cmd_TraceSEEWorld_Reply_flags_table[];
extern const NF_ValInfo NF_Cmd_GetKeyInfoEx_Reply_flags_table[];
extern const NF_ValInfo NF_Cmd_StatGetValues_Reply_flags_table[];
extern const NF_ValInfo NF_Cmd_ANModuleChangeEvent_Reply_flags_table[];
extern const NF_ValInfo NF_InfoFormat_HardwareRev1_Info_flags_table[];
extern const NF_ValInfo NF_Cmd_SendShare_Reply_flags_table[];
extern const NF_ValInfo NF_Cmd_PollModuleState_Reply_flags_table[];
extern const NF_ValInfo NF_Cmd_StatEnumTree_Reply_flags_table[];
extern const NF_ValInfo NF_Cmd_GenerateKey_Reply_flags_table[];
extern const NF_ValInfo NF_Cmd_GenerateKeyPair_Reply_flags_table[];
extern const NF_ValInfo NF_Cmd_NewClient_Reply_flags_table[];
extern const NF_ValInfo NF_Cmd_PauseForNotifications_Reply_flags_table[];
extern const NF_ValInfo NF_TokenInfo_flags_table[];
extern const NF_ValInfo NF_StatInfo_flags_table[];
extern const NF_ValInfo NF_ProgSigDatFormat_Two_Data_flags_table[];
extern const NF_ValInfo NF_FirmwareFileInfo_flags_table[];
extern const NF_ValInfo NF_SigningKeyEntry_flags_table[];
extern const NF_ValInfo NF_CertSignMessage_flags_table[];
extern const NF_ValInfo NF_ModCertType_KWARv0_ModCertData_flags_table[];
extern const NF_ValInfo NF_ModCertType_StateCert_ModCertData_flags_table[];
extern const NF_ValInfo NF_ModCertType_KeyGen_ModCertData_flags_table[];
extern const NF_ValInfo NF_ImpathKXMessage_flags_table[];
extern const NF_ValInfo NF_ImpathMsgType_UserData_Body_flags_table[];
extern const NF_ValInfo NF_ImpathMsgType_Share_Body_flags_table[];
extern const NF_ValInfo NF_SEEOpType_JavaSEECmdInstantiateObject_SEEArgs_flags_table[];
extern const NF_ValInfo NF_SEEOpType_JavaSEECmdDeleteObject_SEEArgs_flags_table[];
extern const NF_ValInfo NF_SEEOpType_JavaSEECmdInvokeMethod_SEEArgs_flags_table[];
extern const NF_ValInfo NF_SEEOpType_JavaSEECmdInstantiateObject_SEERes_flags_table[];
extern const NF_ValInfo NF_SEEOpType_JavaSEECmdInvokeMethod_SEERes_flags_table[];
extern const NF_ValInfo NF_TicketInfo_flags_table[];

/*----- That's all, folks -------------------------------------------------*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nfast\inc\messages-a-en.h ===
/* -*-c-*-
 *
 * Generated by Marshmallow at 2003-04-16T17:13:57
 */

#ifndef MESSAGES_A_EN_H
#define MESSAGES_A_EN_H

/*----- Enumeration constants ---------------------------------------------*/

/* --- Notes on enumeration naming --- *
 *
 * Each enumeration `Foo' has a `Foo__Max' constant defined, which is the 
 * smallest integer greater than all members of the enumeration.  This is 
 * useful if you're trying to make arrays of things.
 */

/* --- Status codes --- */

typedef enum M_Status {
  Status_OK =                                                           0,
  Status_UnknownCommand =                                               1,
  Status_NotYetImplemented =                                            2,
  Status_Malformed =                                                    3,
  Status_UnknownID =                                                    4,
  Status_AccessDenied =                                                 5,
  Status_ObjectInUse =                                                  6,
  Status_UseLimitExceeded =                                             7,
  Status_TimeLimitExceeded =                                            8,
  Status_BadCertKeyHash =                                               9,
  Status_BadCertSignature =                                            10,
  Status_VerifyFailed =                                                11,
  Status_TypeMismatch =                                                12,
  Status_BadShareState =                                               13,
  Status_BadTokenData =                                                14,
  Status_NoMemory =                                                    15,
  Status_Failed =                                                      16,
  Status_UnknownParameter =                                            17,
  Status_UnknownFlag =                                                 18,
  Status_BlobTypeUnknown =                                             19,
  Status_BufferFull =                                                  20,
  Status_UnitReset =                                                   21,
  Status_ClientUnknown =                                               22,
  Status_CrossModule =                                                 23,
  Status_InvalidParameter =                                            24,
  Status_InvalidState =                                                25,
  Status_InvalidModule =                                               26,
  Status_TokenAssemblyFailed =                                         27,
  Status_UnknownKM =                                                   28,
  Status_LogTokenNotPresent =                                          29,
  Status_InvalidMonitorMultiple =                                      30,
  Status_DecryptFailed =                                               31,
  Status_WriteProtected =                                              33,
  Status_OutOfRange =                                                  34,
  Status_PrivilegedCommand =                                           35,
  Status_UnknownSlot =                                                 36,
  Status_UnknownKeyHash =                                              37,
  Status_TokenAuthFailed =                                             38,
  Status_UnknownMechanism =                                            39,
  Status_NoSpaceOnToken =                                              40,
  Status_TokenNotFormatted =                                           41,
  Status_UnknownTokenType =                                            42,
  Status_TokenIOError =                                                43,
  Status_EncryptFailed =                                               44,
  Status_InvalidACL =                                                  45,
  Status_MetaDataProtection =                                          46,
  Status_PhysTokenNotPresent =                                         47,
  Status_MechanismNotExpected =                                        48,
  Status_UnknownDefault =                                              49,
  Status_AttemptedDowngrade =                                          50,
  Status_SlotFull =                                                    51,
  Status_UnknownChallenge =                                            52,
  Status_AsynchNotification =                                          53,
  Status_InvalidData =                                                 54,
  Status_HardwareFailed =                                              55,
  Status_ServerNotRunning =                                            56,
  Status_OSErrorErrno =                                                57,
  Status_TransactionNotFound =                                         58,
  Status_TransactionNotYetComplete =                                   59,
  Status_ServerConnectionLost =                                        60,
  Status_ServerFailed =                                                61,
  Status_StrictFIPS140 =                                               62,
  Status_UnknownStatus =                                               63,
  Status_Cancelled =                                                   64,
  Status_UnsupportedChannelType =                                      65,
  Status_ArithmeticError =                                             66,
  Status_OpStackOverflow =                                             67,
  Status_OpStackUnderflow =                                            68,
  Status_NegativeResult =                                              69,
  Status_HostDataInvalid =                                             70,
  Status_HostDataAccessFailed =                                        71,
  Status_NoUpcall =                                                    72,
  Status_NotAvailable =                                                73,
  Status_MalformedCertificate =                                        74,
  Status_InvalidCertificate =                                          75,
  Status_ObjectNotReady =                                              76,
  Status_BadMachineImage =                                             77,
  Status_BadWorldImage =                                               78,
  Status_SEEWorldFailed =                                              79,
  Status_SoftwareFailed =                                              80,
  Status_NoHostMemory =                                                81,
  Status_NoModuleMemory =                                              82,
  Status_IncorrectToken =                                              83,
  Status_OperationFailed =                                             84,
  Status_HostDataAccessDenied =                                        86,
  Status_InvalidMergedKey =                                            87,
  Status_AlreadyExists =                                               88,
  Status_ReadOnly =                                                    89,
  Status_RemoteServerFailed =                                          90,
  Status_SlotUnconnected =                                             91,
  Status_NSTBadMessage =                                               92,
  Status_nCErrno =                                                     93,
  Status_ImpathNotReady =                                              94,
  Status_ImpathTimeLimitExceeded =                                     95,
  Status_ImpathDataLimitExceeded =                                     96,
  Status_ImpathReplay =                                                97,
  Status_ImpathMsgTypeMismatch =                                       98,
  Status_NoKXGroup =                                                   99,
  Status_ServerAccessDenied =                                         100,
  Status_InProgress =                                                 101,
  Status_InvalidRM =                                                  102,
  Status_InvalidSlot =                                                103,
  Status_UnknownPermID =                                              104,
  Status_ForeignTokenLocked =                                         105,
  Status_OperationTimeout =                                           106,
  Status_SSLUnexpectedMessage =                                       107,
  Status_SSLBadRecordMac =                                            108,
  Status_SSLDecryptionFailed =                                        109,
  Status_SSLRecordOverFlow =                                          110,
  Status_SSLDecompressionFailure =                                    111,
  Status_SSLHandshakeFailure =                                        112,
  Status_SSLNoCertificate =                                           113,
  Status_SSLBadCertificate =                                          114,
  Status_SSLUnsupportedCertificate =                                  115,
  Status_SSLCertificateRevoked =                                      116,
  Status_SSLCertificateExpired =                                      117,
  Status_SSLCertificateUnknown =                                      118,
  Status_SSLIllegalParameter =                                        119,
  Status_SSLUnknownCA =                                               120,
  Status_SSLAccessDenied =                                            121,
  Status_SSLDecodeError =                                             122,
  Status_SSLDecryptError =                                            123,
  Status_SSLExportRestriction =                                       124,
  Status_SSLProtocolVersion =                                         125,
  Status_SSLInsufficientSecurity =                                    126,
  Status_SSLInternalError =                                           127,
  Status_SSLUserCanceled =                                            128,
  Status_SSLNoRenogotiation =                                         129,
  Status_UnknownKey =                                                 130,
  Status_UserCancelled =                                              131,
  Status_KeyNotLoaded =                                               132,
  Status_HostUnknownKeyType =                                         133,
  Status_IncorrectRepositoryName =                                    134,
  Status_InvalidHostDataIdentifier =                                  136,
  Status__Max =                                                       137 
} M_Status;

/* --- nCErrno codes --- */

typedef enum M_nCErrno {
  nCErrno_UNKNOWN =                                                     1,
  nCErrno_EPERM =                                                       2,
  nCErrno_ENOENT =                                                      3,
  nCErrno_ESRCH =                                                       4,
  nCErrno_EINTR =                                                       5,
  nCErrno_EIO =                                                         6,
  nCErrno_ENXIO =                                                       7,
  nCErrno_E2BIG =                                                       8,
  nCErrno_ENOEXEC =                                                     9,
  nCErrno_EBADF =                                                      10,
  nCErrno_ECHILD =                                                     11,
  nCErrno_EAGAIN =                                                     12,
  nCErrno_ENOMEM =                                                     13,
  nCErrno_EACCES =                                                     14,
  nCErrno_EFAULT =                                                     15,
  nCErrno_ENOTBLK =                                                    16,
  nCErrno_EBUSY =                                                      17,
  nCErrno_EEXIST =                                                     18,
  nCErrno_EXDEV =                                                      19,
  nCErrno_ENODEV =                                                     20,
  nCErrno_ENOTDIR =                                                    21,
  nCErrno_EISDIR =                                                     22,
  nCErrno_EINVAL =                                                     23,
  nCErrno_ENFILE =                                                     24,
  nCErrno_EMFILE =                                                     25,
  nCErrno_ENOTTY =                                                     26,
  nCErrno_ETXTBSY =                                                    27,
  nCErrno_EFBIG =                                                      28,
  nCErrno_ENOSPC =                                                     29,
  nCErrno_ESPIPE =                                                     30,
  nCErrno_EROFS =                                                      31,
  nCErrno_EMLINK =                                                     32,
  nCErrno_EPIPE =                                                      33,
  nCErrno_EDOM =                                                       34,
  nCErrno_ERANGE =                                                     35,
  nCErrno_EDEADLK =                                                    36,
  nCErrno_ENAMETOOLONG =                                               37,
  nCErrno_ENOLCK =                                                     38,
  nCErrno_ENOSYS =                                                     39,
  nCErrno_ENOTEMPTY =                                                  40,
  nCErrno_ELOOP =                                                      41,
  nCErrno_EWOULDBLOCK =                                                42,
  nCErrno_ENOMSG =                                                     43,
  nCErrno_EIDRM =                                                      44,
  nCErrno_EDEADLOCK =                                                  45,
  nCErrno_EREMOTE =                                                    46,
  nCErrno_EOVERFLOW =                                                  47,
  nCErrno_EBADFD =                                                     48,
  nCErrno_EILSEQ =                                                     49,
  nCErrno_EUSERS =                                                     50,
  nCErrno_ENOTSOCK =                                                   51,
  nCErrno_EDESTADDRREQ =                                               52,
  nCErrno_EMSGSIZE =                                                   53,
  nCErrno_EPROTOTYPE =                                                 54,
  nCErrno_ENOPROTOOPT =                                                55,
  nCErrno_EPROTONOSUPPORT =                                            56,
  nCErrno_ESOCKTNOSUPPORT =                                            57,
  nCErrno_EOPNOTSUPP =                                                 58,
  nCErrno_EPFNOSUPPORT =                                               59,
  nCErrno_EAFNOSUPPORT =                                               60,
  nCErrno_EADDRINUSE =                                                 61,
  nCErrno_EADDRNOTAVAIL =                                              62,
  nCErrno_ENETDOWN =                                                   63,
  nCErrno_ENETUNREACH =                                                64,
  nCErrno_ENETRESET =                                                  65,
  nCErrno_ECONNABORTED =                                               66,
  nCErrno_ECONNRESET =                                                 67,
  nCErrno_ENOBUFS =                                                    68,
  nCErrno_EISCONN =                                                    69,
  nCErrno_ENOTCONN =                                                   70,
  nCErrno_ESHUTDOWN =                                                  71,
  nCErrno_ETOOMANYREFS =                                               72,
  nCErrno_ETIMEDOUT =                                                  73,
  nCErrno_ECONNREFUSED =                                               74,
  nCErrno_EHOSTDOWN =                                                  75,
  nCErrno_EHOSTUNREACH =                                               76,
  nCErrno_EALREADY =                                                   77,
  nCErrno_EINPROGRESS =                                                78,
  nCErrno_ESTALE =                                                     79,
  nCErrno_EREMOTEIO =                                                  80,
  nCErrno_EDQUOT =                                                     81,
  nCErrno__Max =                                                       82 
} M_nCErrno;

/* --- NetworkAddressFamily codes --- */

typedef enum M_NetworkAddressFamily {
  NetworkAddressFamily_INET =                                           2,
  NetworkAddressFamily_INET6 =                                         10,
  NetworkAddressFamily__Max =                                          11 
} M_NetworkAddressFamily;

/* --- CrossModReason codes --- */

typedef enum M_CrossModReason {
  CrossModReason_ExplicitRequest =                                      1,
  CrossModReason_Key =                                                  2,
  CrossModReason_Mode =                                                 4,
  CrossModReason_HardwareFailed =                                       5,
  CrossModReason_UnitReset =                                            6,
  CrossModReason_ServerKey =                                            7,
  CrossModReason_ServerUnitReset =                                      8,
  CrossModReason__Max =                                                 9 
} M_CrossModReason;

/* --- SlotType codes --- */

typedef enum M_SlotType {
  SlotType_Unknown =                                                    0,
  SlotType_DataKey =                                                    1,
  SlotType_SmartCard =                                                  2,
  SlotType_Emulated =                                                   3,
  SlotType_SoftToken =                                                  4,
  SlotType_Unconnected =                                                5,
  SlotType__Max =                                                       6 
} M_SlotType;

/* --- ChannelType codes --- */

typedef enum M_ChannelType {
  ChannelType_Any =                                                     0,
  ChannelType_Simple =                                                  1,
  ChannelType_DriverDirect =                                            2,
  ChannelType__Max =                                                    3 
} M_ChannelType;

/* --- CertType codes --- */

typedef enum M_CertType {
  CertType_Invalid =                                                    0,
  CertType_SigningKey =                                                 1,
  CertType_SingleCert =                                                 2,
  CertType_SEECert =                                                    3,
  CertType__Max =                                                       4 
} M_CertType;

/* --- KeyType codes --- */

typedef enum M_KeyType {
  KeyType_Any =                                                         0,
  KeyType_RSAPublic =                                                   1,
  KeyType_RSAPrivate =                                                  2,
  KeyType_DSAPublic =                                                   3,
  KeyType_DHPublic =                                                    5,
  KeyType_DHPrivate =                                                   6,
  KeyType_Random =                                                      7,
  KeyType_DES =                                                        11,
  KeyType_DES3 =                                                       12,
  KeyType_None =                                                       13,
  KeyType_RC2 =                                                        14,
  KeyType_ArcFour =                                                    15,
  KeyType_RC5 =                                                        16,
  KeyType_IDEA =                                                       17,
  KeyType_CAST =                                                       18,
  KeyType_DSAPrivate =                                                 19,
  KeyType_DSAComm =                                                    20,
  KeyType_Void =                                                       21,
  KeyType_Skipjack =                                                   22,
  KeyType_Wrapped =                                                    23,
  KeyType_DKTemplate =                                                 24,
  KeyType_HMACMD2 =                                                    25,
  KeyType_HMACMD5 =                                                    26,
  KeyType_HMACSHA1 =                                                   27,
  KeyType_HMACRIPEMD160 =                                              28,
  KeyType_Serpent =                                                    29,
  KeyType_Rijndael =                                                   30,
  KeyType_Twofish =                                                    31,
  KeyType_CAST256 =                                                    32,
  KeyType_Blowfish =                                                   33,
  KeyType_HMACSHA256 =                                                 34,
  KeyType_HMACSHA384 =                                                 35,
  KeyType_HMACSHA512 =                                                 36,
  KeyType_HMACTiger =                                                  37,
  KeyType_SSLMasterSecret =                                            38,
  KeyType_KCDSAPublic =                                                39,
  KeyType_KCDSAPrivate =                                               40,
  KeyType_DES2 =                                                       41,
  KeyType_KCDSAComm =                                                  42,
  KeyType_SEED =                                                       43,
  KeyType__Max =                                                       44 
} M_KeyType;

/* --- Mech codes --- */

typedef enum M_Mech {
  Mech_Any =                                                            0,
  Mech_DESmCBCi64pPKCS5 =                                               1,
  Mech_RSApPKCS1 =                                                      2,
  Mech_DES3OldFwConf =                                                  3,
  Mech_RC2mCBCi64pPKCS5 =                                               4,
  Mech_RC5mCBCi64pPKCS5 =                                               5,
  Mech_RC2mECBpPKCS5 =                                                  6,
  Mech_DESmECBpPKCS5 =                                                  7,
  Mech_RC5mECBpPKCS5 =                                                  9,
  Mech_DSA =                                                           10,
  Mech_ArcFourpNONE =                                                  11,
  Mech_IDEAmCBCi64pPKCS5 =                                             12,
  Mech_IDEAmECBpPKCS5 =                                                13,
  Mech_RC2mCBCMACi64pPKCS5 =                                           14,
  Mech_RC5mCBCMACi64pPKCS5 =                                           15,
  Mech_IDEAmCBCMACi64pPKCS5 =                                          16,
  Mech_DESmCBCMACi64pPKCS5 =                                           17,
  Mech_CASTmCBCi64pPKCS5 =                                             19,
  Mech_CASTmECBpPKCS5 =                                                20,
  Mech_CASTmCBCMACi64pPKCS5 =                                          21,
  Mech_DESmECBpNONE =                                                  22,
  Mech_DESmCBCpNONE =                                                  24,
  Mech_DHKeyExchange =                                                 26,
  Mech_ElGamal =                                                       27,
  Mech_IDEAmECBpNONE =                                                 28,
  Mech_CASTmECBpNONE =                                                 29,
  Mech_RC2mECBpNONE =                                                  30,
  Mech_RC5mECBpNONE =                                                  31,
  Mech_CASTmCBCpNONE =                                                 32,
  Mech_IDEAmCBCpNONE =                                                 33,
  Mech_Generic64 =                                                     34,
  Mech_Generic64MAC =                                                  35,
  Mech_RSApSETOAEP =                                                   36,
  Mech_DES3mCBCi64pPKCS5 =                                             37,
  Mech_DES3mECBpPKCS5 =                                                38,
  Mech_DES3mCBCMACi64pPKCS5 =                                          39,
  Mech_DES3mECBpNONE =                                                 40,
  Mech_DES3mCBCpNONE =                                                 41,
  Mech_RC2mCBCpNONE =                                                  42,
  Mech_RC5mCBCpNONE =                                                  43,
  Mech_SHA1Hash =                                                      44,
  Mech_MD5Hash =                                                       45,
  Mech_MD2Hash =                                                       46,
  Mech_SkipjackmECBpNONE =                                             47,
  Mech_SkipjackmECBpPKCS5 =                                            48,
  Mech_SkipjackmCBCpNONE =                                             49,
  Mech_SkipjackmCBCi64pPKCS5 =                                         50,
  Mech_SkipjackmCBCMACi64pPKCS5 =                                      51,
  Mech_RIPEMD160Hash =                                                 52,
  Mech_HMACMD2 =                                                       53,
  Mech_HMACMD5 =                                                       54,
  Mech_HMACSHA1 =                                                      55,
  Mech_HMACRIPEMD160 =                                                 56,
  Mech_RSAhASCIIHexSHA1pPKCS1 =                                        57,
  Mech_RSAhMD5pPKCS1 =                                                 58,
  Mech_RSAhSHA1pPKCS1 =                                                59,
  Mech_RSAhRIPEMD160pPKCS1 =                                           60,
  Mech_RSApPKCS1OAEP =                                                 61,
  Mech_Generic128 =                                                    62,
  Mech_Generic128MAC =                                                 63,
  Mech_Generic192 =                                                    64,
  Mech_Generic192MAC =                                                 65,
  Mech_Generic256 =                                                    66,
  Mech_Generic256MAC =                                                 67,
  Mech_SerpentmCBCi128pPKCS5 =                                         68,
  Mech_SerpentmECBpPKCS5 =                                             69,
  Mech_SerpentmCBCpNONE =                                              70,
  Mech_SerpentmECBpNONE =                                              71,
  Mech_SerpentmCBCMACi128pPKCS5 =                                      72,
  Mech_RijndaelmCBCi128pPKCS5 =                                        73,
  Mech_RijndaelmECBpPKCS5 =                                            74,
  Mech_RijndaelmCBCpNONE =                                             75,
  Mech_RijndaelmECBpNONE =                                             76,
  Mech_RijndaelmCBCMACi128pPKCS5 =                                     77,
  Mech_TwofishmCBCi128pPKCS5 =                                         78,
  Mech_TwofishmECBpPKCS5 =                                             79,
  Mech_TwofishmCBCpNONE =                                              80,
  Mech_TwofishmECBpNONE =                                              81,
  Mech_TwofishmCBCMACi128pPKCS5 =                                      82,
  Mech_CAST256mCBCi128pPKCS5 =                                         83,
  Mech_CAST256mECBpPKCS5 =                                             84,
  Mech_CAST256mCBCpNONE =                                              85,
  Mech_CAST256mECBpNONE =                                              86,
  Mech_CAST256mCBCMACi128pPKCS5 =                                      87,
  Mech_BlowfishmCBCi64pPKCS5 =                                         88,
  Mech_BlowfishmECBpPKCS5 =                                            89,
  Mech_BlowfishmCBCpNONE =                                             90,
  Mech_BlowfishmECBpNONE =                                             91,
  Mech_BlowfishmCBCMACi64pPKCS5 =                                      92,
  Mech_SHA256Hash =                                                    93,
  Mech_SHA384Hash =                                                    94,
  Mech_SHA512Hash =                                                    95,
  Mech_TigerHash =                                                     96,
  Mech_HMACSHA256 =                                                    97,
  Mech_HMACSHA384 =                                                    98,
  Mech_HMACSHA512 =                                                    99,
  Mech_HMACTiger =                                                    100,
  Mech_Imech =                                                        101,
  Mech_DES3wSHA1 =                                                    102,
  Mech_DES3wCRC32 =                                                   103,
  Mech_DES3AltwSHA1 =                                                 104,
  Mech_DES3AltwCRC32 =                                                105,
  Mech_SSLRecordLayer =                                               106,
  Mech_SSL3FinishedMsg =                                              107,
  Mech_TLSFinishedMsg =                                               108,
  Mech_HAS160Hash =                                                   109,
  Mech_KCDSAHAS160 =                                                  110,
  Mech_KCDSASHA1 =                                                    111,
  Mech_KCDSARIPEMD160 =                                               112,
  Mech_DES2mCBCi64pPKCS5 =                                            113,
  Mech_DES2mCBCpNONE =                                                114,
  Mech_DES2mECBpPKCS5 =                                               115,
  Mech_DES2mCBCMACi64pPKCS5 =                                         116,
  Mech_DES2mECBpNONE =                                                117,
  Mech_RSApPKCS1pPKCS11 =                                             118,
  Mech_SEEDmECBpNONE =                                                119,
  Mech_SEEDmECBpPKCS5 =                                               120,
  Mech_SEEDmCBCpNONE =                                                121,
  Mech_SEEDmCBCi128pPKCS5 =                                           122,
  Mech_SEEDmCBCMACi128pPKCS5 =                                        123,
  Mech_DLIESe3DEShSHA1 =                                              124,
  Mech_DLIESeAEShSHA1 =                                               125,
  Mech__Max =                                                         126 
} M_Mech;

/* --- SSLCipherSuite codes --- */

typedef enum M_SSLCipherSuite {
  SSLCipherSuite_SSL3_NULL_MD5 =                                        1,
  SSLCipherSuite_SSL3_NULL_SHA =                                        2,
  SSLCipherSuite_SSL3_RC4_40_MD5 =                                      3,
  SSLCipherSuite_SSL3_RC4_128_MD5 =                                     4,
  SSLCipherSuite_SSL3_RC4_128_SHA =                                     5,
  SSLCipherSuite_SSL3_DES_40_SHA =                                      8,
  SSLCipherSuite_SSL3_DES_SHA =                                         9,
  SSLCipherSuite_SSL3_DES3_SHA =                                       10,
  SSLCipherSuite_TLS_NULL_MD5 =                                        17,
  SSLCipherSuite_TLS_NULL_SHA =                                        18,
  SSLCipherSuite_TLS_RC4_40_MD5 =                                      19,
  SSLCipherSuite_TLS_RC4_128_MD5 =                                     20,
  SSLCipherSuite_TLS_RC4_128_SHA =                                     21,
  SSLCipherSuite_TLS_DES_40_SHA =                                      24,
  SSLCipherSuite_TLS_DES_SHA =                                         25,
  SSLCipherSuite_TLS_DES3_SHA =                                        26,
  SSLCipherSuite__Max =                                                27 
} M_SSLCipherSuite;

/* --- ImpathKXGroup codes --- */

typedef enum M_ImpathKXGroup {
  ImpathKXGroup_DHPrime1024 =                                           1,
  ImpathKXGroup__Max =                                                  2 
} M_ImpathKXGroup;

/* --- PlainTextType codes --- */

typedef enum M_PlainTextType {
  PlainTextType_Bytes =                                                 1,
  PlainTextType_Hash =                                                  2,
  PlainTextType_Bignum =                                                3,
  PlainTextType_Hash16 =                                                4,
  PlainTextType__Max =                                                  5 
} M_PlainTextType;

/* --- DeriveMech codes --- */

typedef enum M_DeriveMech {
  DeriveMech_Any =                                                      0,
  DeriveMech_DESsplitXOR =                                              1,
  DeriveMech_DESjoinXOR =                                               2,
  DeriveMech_DES3splitXOR =                                             3,
  DeriveMech_DES3joinXOR =                                              4,
  DeriveMech_DESjoinXORsetParity =                                      5,
  DeriveMech_DES3joinXORsetParity =                                     6,
  DeriveMech_RandsplitXOR =                                             7,
  DeriveMech_RandjoinXOR =                                              8,
  DeriveMech_CASTsplitXOR =                                             9,
  DeriveMech_CASTjoinXOR =                                             10,
  DeriveMech_EncryptMarshalled =                                       11,
  DeriveMech_DecryptMarshalled =                                       12,
  DeriveMech_SSL3withRSA =                                             13,
  DeriveMech_TLSwithRSA =                                              14,
  DeriveMech_SSL3withDH =                                              15,
  DeriveMech_TLSwithDH =                                               16,
  DeriveMech_RawEncrypt =                                              17,
  DeriveMech_RawDecrypt =                                              18,
  DeriveMech_DES2splitXOR =                                            19,
  DeriveMech_DES2joinXOR =                                             20,
  DeriveMech_DES2joinXORsetParity =                                    21,
  DeriveMech_PKCS8Encrypt =                                            22,
  DeriveMech_PKCS8Decrypt =                                            23,
  DeriveMech_RSAComponents =                                           24,
  DeriveMech__Max =                                                    25 
} M_DeriveMech;

/* --- Cmd codes --- */

typedef enum M_Cmd {
  Cmd_ErrorReturn =                                                     0,
  Cmd_ModExp =                                                          1,
  Cmd_ModExpCrt =                                                       2,
  Cmd_ModExpCrtPar =                                                    3,
  Cmd_GeneratePrime =                                                   5,
  Cmd_OldEnquiry =                                                      6,
  Cmd_OldClearUnit =                                                    7,
  Cmd_GenerateRandom =                                                  8,
  Cmd_GenerateKey =                                                     9,
  Cmd_GenerateKeyPair =                                                10,
  Cmd_Import =                                                         11,
  Cmd_Duplicate =                                                      12,
  Cmd_GetKeyInfo =                                                     13,
  Cmd_Destroy =                                                        14,
  Cmd_Encrypt =                                                        15,
  Cmd_Decrypt =                                                        16,
  Cmd_Verify =                                                         17,
  Cmd_Export =                                                         18,
  Cmd_GetAppData =                                                     19,
  Cmd_SetAppData =                                                     20,
  Cmd_NewClient =                                                      21,
  Cmd_ExistingClient =                                                 22,
  Cmd_GetWhichModule =                                                 23,
  Cmd_MergeKeyIDs =                                                    24,
  Cmd_GenerateLogicalToken =                                           26,
  Cmd_WriteShare =                                                     27,
  Cmd_GetSlotList =                                                    28,
  Cmd_GetSlotInfo =                                                    29,
  Cmd_ReadShare =                                                      30,
  Cmd_OldExtEnquiry =                                                  31,
  Cmd_LoadBlob =                                                       32,
  Cmd_OldMakeBlob =                                                    33,
  Cmd_LoadLogicalToken =                                               34,
  Cmd_EraseShare =                                                     35,
  Cmd_ChangeSharePIN =                                                 36,
  Cmd_WriteFile =                                                      37,
  Cmd_ReadFile =                                                       38,
  Cmd_EraseFile =                                                      39,
  Cmd_ProgrammingBegin =                                               40,
  Cmd_ProgrammingBeginChunk =                                          41,
  Cmd_ProgrammingLoadBlock =                                           42,
  Cmd_ProgrammingEndChunk =                                            43,
  Cmd_ProgrammingEnd =                                                 44,
  Cmd_FormatToken =                                                    45,
  Cmd_SetKNSO =                                                        46,
  Cmd_SetKM =                                                          47,
  Cmd_RemoveKM =                                                       48,
  Cmd_GetKMList =                                                      49,
  Cmd_InitialiseUnit =                                                 50,
  Cmd_Maintenance =                                                    51,
  Cmd_Fail =                                                           52,
  Cmd_NewEnquiry =                                                     53,
  Cmd_NoOp =                                                           54,
  Cmd_Sign =                                                           55,
  Cmd_ModuleInfo =                                                     56,
  Cmd_ProgrammingGetKeyList =                                          57,
  Cmd_InsertSoftToken =                                                58,
  Cmd_RemoveSoftToken =                                                59,
  Cmd_GetChallenge =                                                   60,
  Cmd_ANModuleReset =                                                  61,
  Cmd_MakeBlob =                                                       62,
  Cmd_GetLogicalTokenInfo =                                            63,
  Cmd_GetKML =                                                         64,
  Cmd_ANReadTerminated =                                               65,
  Cmd_ANPleaseClearUnitSoon =                                          66,
  Cmd_ANPleaseClearUnitNow =                                           67,
  Cmd_PauseForNotifications =                                          68,
  Cmd_Hash =                                                           69,
  Cmd_ClearUnit =                                                      70,
  Cmd_ChannelOpen =                                                    71,
  Cmd_ChannelUpdate =                                                  72,
  Cmd_GetACL =                                                         73,
  Cmd_SetACL =                                                         74,
  Cmd_DeriveKey =                                                      75,
  Cmd_RetryFailedModule =                                              76,
  Cmd_BignumOp =                                                       77,
  Cmd_RSAImmedSignDecrypt =                                            78,
  Cmd_RSAImmedVerifyEncrypt =                                          79,
  Cmd_StatEnumTree =                                                   80,
  Cmd_StatGetValues =                                                  81,
  Cmd_LoadRaw =                                                        87,
  Cmd_NVMemAlloc =                                                     88,
  Cmd_NVMemList =                                                      89,
  Cmd_NVMemOp =                                                        90,
  Cmd_NVMemFree =                                                      91,
  Cmd_GetRTC =                                                         92,
  Cmd_SetRTC =                                                         93,
  Cmd_CreateSEEWorld =                                                 94,
  Cmd_SEEJob =                                                         95,
  Cmd_CreateBuffer =                                                   96,
  Cmd_LoadBuffer =                                                     97,
  Cmd_SetSEEMachine =                                                  98,
  Cmd_TraceSEEWorld =                                                  99,
  Cmd_GetTicket =                                                     100,
  Cmd_RedeemTicket =                                                  101,
  Cmd_SetNSOPerms =                                                   102,
  Cmd_PollModuleState =                                               103,
  Cmd_PollSlotList =                                                  104,
  Cmd_ANModuleChangeEvent =                                           105,
  Cmd_ANSlotChangeEvent =                                             106,
  Cmd_ImpathKXBegin =                                                 107,
  Cmd_ImpathKXFinish =                                                108,
  Cmd_ImpathGetInfo =                                                 109,
  Cmd_ImpathSend =                                                    110,
  Cmd_ImpathReceive =                                                 111,
  Cmd_SendShare =                                                     112,
  Cmd_ReceiveShare =                                                  113,
  Cmd_ImportSlot =                                                    119,
  Cmd_UnimportSlot =                                                  120,
  Cmd_ExportSlot =                                                    121,
  Cmd_ServerSendShare =                                               122,
  Cmd_GetClientHash =                                                 123,
  Cmd_UpdateMergedKey =                                               124,
  Cmd_GetWorldSigners =                                               125,
  Cmd_ForeignTokenOpen =                                              126,
  Cmd_ForeignTokenCmd =                                               127,
  Cmd_GetKeyInfoEx =                                                  129,
  Cmd_FirmwareAuthenticate =                                          130,
  Cmd_SignModuleState =                                               131,
  Cmd_GenerateKLF =                                                   132,
  Cmd_GetKLF =                                                        133,
  Cmd_AddRemoteServerPermission =                                     134,
  Cmd_RemoveRemoteServerPermission =                                  135,
  Cmd_ListRemoteServerPermission =                                    136,
  Cmd_ANRemoteSlotDisconnected =                                      137,
  Cmd_GetLogicalTokenInfoEx =                                         138,
  Cmd_GetShareACL =                                                   139,
  Cmd_StaticFeatureEnable =                                           140,
  Cmd_CheckUserAction =                                               142,
  Cmd__Max =                                                          143 
} M_Cmd;

/* --- PhysTokenType codes --- */

typedef enum M_PhysTokenType {
  PhysTokenType_Invalid =                                               0,
  PhysTokenType_ISO7816 =                                               1,
  PhysTokenType__Max =                                                  2 
} M_PhysTokenType;

/* --- BlobFormat codes --- */

typedef enum M_BlobFormat {
  BlobFormat_Module =                                                   5,
  BlobFormat_Token =                                                    6,
  BlobFormat_Direct =                                                   7,
  BlobFormat_Indirect =                                                 8,
  BlobFormat__Max =                                                     9 
} M_BlobFormat;

/* --- RemoteServerOp codes --- */

typedef enum M_RemoteServerOp {
  RemoteServerOp_All =                                                  1,
  RemoteServerOp_ExportSlot =                                           2,
  RemoteServerOp__Max =                                                 3 
} M_RemoteServerOp;

/* --- TicketDestination codes --- */

typedef enum M_TicketDestination {
  TicketDestination_Any =                                               0,
  TicketDestination_AnyClient =                                         1,
  TicketDestination_NamedClient =                                       2,
  TicketDestination_AnySEEWorld =                                       3,
  TicketDestination_NamedSEEWorld =                                     4,
  TicketDestination__Max =                                              5 
} M_TicketDestination;

/* --- ChannelMode codes --- */

typedef enum M_ChannelMode {
  ChannelMode_Encrypt =                                                 1,
  ChannelMode_Decrypt =                                                 2,
  ChannelMode_Sign =                                                    3,
  ChannelMode_Verify =                                                  4,
  ChannelMode__Max =                                                    5 
} M_ChannelMode;

/* --- NVMemOpType codes --- */

typedef enum M_NVMemOpType {
  NVMemOpType_Read =                                                    1,
  NVMemOpType_Write =                                                   2,
  NVMemOpType_Incr =                                                    3,
  NVMemOpType_Decr =                                                    4,
  NVMemOpType_BitSet =                                                  5,
  NVMemOpType_BitClear =                                                6,
  NVMemOpType_Free =                                                    7,
  NVMemOpType_IncrRead =                                                8,
  NVMemOpType_DecrRead =                                                9,
  NVMemOpType_BitSetRead =                                             10,
  NVMemOpType_BitClearRead =                                           11,
  NVMemOpType_GetACL =                                                 12,
  NVMemOpType__Max =                                                   13 
} M_NVMemOpType;

/* --- FwAuthType codes --- */

typedef enum M_FwAuthType {
  FwAuthType_NFFHMAC1 =                                                 1,
  FwAuthType_PRNG1 =                                                    2,
  FwAuthType__Max =                                                     3 
} M_FwAuthType;

/* --- SignerType codes --- */

typedef enum M_SignerType {
  SignerType_KLF =                                                      1,
  SignerType_KML =                                                      2,
  SignerType_AppKey =                                                   3,
  SignerType__Max =                                                     4 
} M_SignerType;

/* --- StackOp codes --- */

typedef enum M_StackOp {
  StackOp_NoOp =                                                        0,
  StackOp_Add =                                                         1,
  StackOp_Sub =                                                         2,
  StackOp_RSub =                                                        3,
  StackOp_Mul =                                                         4,
  StackOp_Div =                                                         5,
  StackOp_Mod =                                                         6,
  StackOp_DivMod =                                                      7,
  StackOp_ModExp =                                                      8,
  StackOp_ModInv =                                                      9,
  StackOp_Dup =                                                        10,
  StackOp_Drop =                                                       11,
  StackOp_Rot =                                                        12,
  StackOp_Set =                                                        13,
  StackOp_Test =                                                       14,
  StackOp_TestPrime =                                                  15,
  StackOp_Neg =                                                        16,
  StackOp_Abs =                                                        17,
  StackOp_GCD =                                                        18,
  StackOp_LCM =                                                        19,
  StackOp__Max =                                                       20 
} M_StackOp;

/* --- ModuleAttribTag codes --- */

typedef enum M_ModuleAttribTag {
  ModuleAttribTag_None =                                                0,
  ModuleAttribTag_Challenge =                                           1,
  ModuleAttribTag_ESN =                                                 2,
  ModuleAttribTag_KML =                                                 3,
  ModuleAttribTag_KLF =                                                 4,
  ModuleAttribTag_KNSO =                                                5,
  ModuleAttribTag_KMList =                                              6,
  ModuleAttribTag_PhysSerial =                                          7,
  ModuleAttribTag_PhysFIPSl3 =                                          8,
  ModuleAttribTag_FeatureGoldCert =                                     9,
  ModuleAttribTag_Enquiry =                                            10,
  ModuleAttribTag_AdditionalInfo =                                     11,
  ModuleAttribTag__Max =                                               12 
} M_ModuleAttribTag;

/* --- FeatureGoldCertVendor codes --- */

typedef enum M_FeatureGoldCertVendor {
  FeatureGoldCertVendor_VeriSign =                                      1,
  FeatureGoldCertVendor_InternalTestingOnly =                           2,
  FeatureGoldCertVendor__Max =                                          3 
} M_FeatureGoldCertVendor;

/* --- ModuleType codes --- */

typedef enum M_ModuleType {
  ModuleType_None =                                                     0,
  ModuleType_Clyde =                                                    2,
  ModuleType_Chili =                                                    4,
  ModuleType_Ariel =                                                    5,
  ModuleType_Persil =                                                   6,
  ModuleType_Dorris =                                                   7,
  ModuleType_Morris =                                                   8,
  ModuleType_Unknown =                                                999,
  ModuleType__Max =                                                  1000 
} M_ModuleType;

/* --- UseLim codes --- */

typedef enum M_UseLim {
  UseLim_Global =                                                       1,
  UseLim_Auth =                                                         2,
  UseLim_Time =                                                         3,
  UseLim_NonVolatile =                                                  4,
  UseLim__Max =                                                         5 
} M_UseLim;

/* --- Act codes --- */

typedef enum M_Act {
  Act_NoAction =                                                        0,
  Act_OpPermissions =                                                   1,
  Act_MakeBlob =                                                        2,
  Act_MakeArchiveBlob =                                                 3,
  Act_NSOPermissions =                                                  4,
  Act_DeriveKey =                                                       5,
  Act_NVMemOpPerms =                                                    6,
  Act_FeatureEnable =                                                   7,
  Act_NVMemUseLimit =                                                   8,
  Act_SendShare =                                                       9,
  Act_ReadShare =                                                      10,
  Act_StaticFeatureEnable =                                            11,
  Act_UserAction =                                                     12,
  Act__Max =                                                           13 
} M_Act;

/* --- DeriveRole codes --- */

typedef enum M_DeriveRole {
  DeriveRole_TemplateKey =                                              0,
  DeriveRole_BaseKey =                                                  1,
  DeriveRole_WrapKey =                                                  2,
  DeriveRole__Max =                                                     3 
} M_DeriveRole;

/* --- OldExtEnqVer codes --- */

typedef enum M_OldExtEnqVer {
  OldExtEnqVer_Zero =                                                   0,
  OldExtEnqVer_One =                                                    1,
  OldExtEnqVer__Max =                                                   2 
} M_OldExtEnqVer;

/* --- LogTokenState codes --- */

typedef enum M_LogTokenState {
  LogTokenState_Present =                                               1,
  LogTokenState_Reading =                                               2,
  LogTokenState_Writing =                                               3,
  LogTokenState_TokenAssemblyFailed =                                   5,
  LogTokenState_PhysTokenNotPresent =                                   6,
  LogTokenState_TimeLimitExceeded =                                     7,
  LogTokenState__Max =                                                  8 
} M_LogTokenState;

/* --- ImpathState codes --- */

typedef enum M_ImpathState {
  ImpathState_Exchange =                                                1,
  ImpathState_UpAndRunning =                                            2,
  ImpathState_Expired =                                                 3,
  ImpathState__Max =                                                    4 
} M_ImpathState;

/* --- EnqVer codes --- */

typedef enum M_EnqVer {
  EnqVer_Zero =                                                         0,
  EnqVer_One =                                                          1,
  EnqVer_Two =                                                          2,
  EnqVer_Three =                                                        3,
  EnqVer_Four =                                                         4,
  EnqVer_Five =                                                         5,
  EnqVer_Six =                                                          6,
  EnqVer__Max =                                                         7 
} M_EnqVer;

/* --- InfoFormat codes --- */

typedef enum M_InfoFormat {
  InfoFormat_HardwareRev1 =                                             1,
  InfoFormat_HardwareRev2 =                                             2,
  InfoFormat__Max =                                                     3 
} M_InfoFormat;

/* --- LogTokenShareState codes --- */

typedef enum M_LogTokenShareState {
  LogTokenShareState_OK =                                               1,
  LogTokenShareState_NotYetWritten =                                    2,
  LogTokenShareState_NotYetRead =                                       3,
  LogTokenShareState__Max =                                             4 
} M_LogTokenShareState;

/* --- StatID codes --- */

typedef enum M_StatID {
  StatID_Uptime =                                                       1,
  StatID_CmdCount =                                                     2,
  StatID_ReplyCount =                                                   3,
  StatID_CmdBytes =                                                     4,
  StatID_ReplyBytes =                                                   5,
  StatID_CmdMarshalErrors =                                             6,
  StatID_ReplyMarshalErrors =                                           7,
  StatID_HostWriteCount =                                               8,
  StatID_HostWriteErrors =                                              9,
  StatID_HostWriteOverruns =                                           10,
  StatID_HostWriteNoMemory =                                           11,
  StatID_HostReadCount =                                               12,
  StatID_HostReadErrors =                                              13,
  StatID_HostReadEmpty =                                               14,
  StatID_HostReadUnderruns =                                           15,
  StatID_HostReadDeferred =                                            16,
  StatID_HostReadTerminated =                                          17,
  StatID_PFNIssued =                                                   19,
  StatID_PFNRejected =                                                 20,
  StatID_PFNCompleted =                                                21,
  StatID_ANIssued =                                                    22,
  StatID_ChanJobsIssued =                                              23,
  StatID_ChanJobsCompleted =                                           24,
  StatID_CPULoadPercent =                                              25,
  StatID_HostIRQs =                                                    26,
  StatID_ChanJobErrors =                                               27,
  StatID_HostDebugIRQs =                                               28,
  StatID_HostUnhandledIRQs =                                           29,
  StatID_HostReadReconnect =                                           30,
  StatID_SCSIConnections =                                             31,
  StatID_SCSICommands =                                                32,
  StatID_SCSIInquiries =                                               33,
  StatID_SCSIDisconnects =                                             34,
  StatID_SCSIReconnects =                                              35,
  StatID_SCSILUN0Use =                                                 36,
  StatID_SCSILUN1Use =                                                 37,
  StatID_SCSICmdErrors =                                               38,
  StatID_SCSIBusResets =                                               39,
  StatID_SCSICtrlErrors =                                              40,
  StatID_SCSITagQUse =                                                 41,
  StatID_SCSIReconFailures =                                           42,
  StatID_HostWriteBadData =                                            43,
  StatID_ClientCount =                                                 44,
  StatID_MaxClients =                                                  45,
  StatID_QOutstanding =                                                46,
  StatID_DeviceFails =                                                 47,
  StatID_DeviceRestarts =                                              48,
  StatID_DevOutstanding =                                              49,
  StatID_ObjectsCreated =                                              50,
  StatID_ObjectsDestroyed =                                            51,
  StatID_ObjectCount =                                                 52,
  StatID_SCSIWideNeg =                                                 53,
  StatID_SCSISyncNeg =                                                 54,
  StatID_CurrentTempC =                                                55,
  StatID_MaxTempC =                                                    56,
  StatID_MinTempC =                                                    57,
  StatID_MemTotal =                                                    58,
  StatID_MemAllocKernel =                                              59,
  StatID_MemAllocUser =                                                60,
  StatID_ReservedMax =                                               1000,
  StatID__Max =                                                      1001 
} M_StatID;

/* --- BusType codes --- */

typedef enum M_BusType {
  BusType_SCSI =                                                        0,
  BusType_PCI =                                                         1,
  BusType_USB =                                                         2,
  BusType_Local =                                                       3,
  BusType_Serial =                                                      4,
  BusType_I2C =                                                         5,
  BusType_OneWire =                                                     6,
  BusType_XBus =                                                        7,
  BusType_PS2 =                                                         8,
  BusType__Max =                                                        9 
} M_BusType;

/* --- ProgSigDatFormat codes --- */

typedef enum M_ProgSigDatFormat {
  ProgSigDatFormat_Two =                                                2,
  ProgSigDatFormat__Max =                                               3 
} M_ProgSigDatFormat;

/* --- FirmwareFileType codes --- */

typedef enum M_FirmwareFileType {
  FirmwareFileType_OldNFast1 =                                          1,
  FirmwareFileType_NFast2 =                                             2,
  FirmwareFileType_NFast3 =                                             3,
  FirmwareFileType_TestVectors =                                        4,
  FirmwareFileType__Max =                                               5 
} M_FirmwareFileType;

/* --- FTVType codes --- */

typedef enum M_FTVType {
  FTVType_PRNG1 =                                                       2,
  FTVType__Max =                                                        3 
} M_FTVType;

/* --- MagicValue codes --- */

typedef enum M_MagicValue {
  MagicValue_CertMsgFooter =                                    588742808,
  MagicValue_KeyCertFooter =                                   1015097956,
  MagicValue_KeyCertHeader =                                   1256304304,
  MagicValue_CodeMsgHeader =                                   1336710885,
  MagicValue_CodeMsgFooter =                                   1601734260,
  MagicValue_CertMsgHeader =                                   1979675204,
  MagicValue__Max =                                            1979675205 
} M_MagicValue;

/* --- ModCertType codes --- */

typedef enum M_ModCertType {
  ModCertType_OldKeyGen =                                               1,
  ModCertType_KeyGen =                                                  2,
  ModCertType_ImpathKX =                                                3,
  ModCertType_StateCert =                                               4,
  ModCertType_KWARv0 =                                                  5,
  ModCertType__Max =                                                    6 
} M_ModCertType;

/* --- ImpathMsgType codes --- */

typedef enum M_ImpathMsgType {
  ImpathMsgType_UserData =                                              1,
  ImpathMsgType_Share =                                                 2,
  ImpathMsgType__Max =                                                  3 
} M_ImpathMsgType;

/* --- CodeAttribTag codes --- */

typedef enum M_CodeAttribTag {
  CodeAttribTag_IsSEEMachine =                                          1,
  CodeAttribTag_IsSEEWorld =                                            2,
  CodeAttribTag__Max =                                                  3 
} M_CodeAttribTag;

/* --- SEEMachineType codes --- */

typedef enum M_SEEMachineType {
  SEEMachineType_None =                                                 0,
  SEEMachineType_gen1AIF =                                              1,
  SEEMachineType_PowerPCSXF =                                           2,
  SEEMachineType__Max =                                                 3 
} M_SEEMachineType;

/* --- SEEOpType codes --- */

typedef enum M_SEEOpType {
  SEEOpType_JavaSEECmdInstantiateObject =                               1,
  SEEOpType_JavaSEECmdInvokeMethod =                                    2,
  SEEOpType_JavaSEECmdDeleteObject =                                    3,
  SEEOpType_JavaSEECmdError =                                           4,
  SEEOpType__Max =                                                      5 
} M_SEEOpType;

/* --- TicketType codes --- */

typedef enum M_TicketType {
  TicketType_Invalid =                                                  0,
  TicketType_Hardserver =                                               1,
  TicketType_Module =                                                   2,
  TicketType__Max =                                                     3 
} M_TicketType;

/* --- KeyCertType codes --- */

typedef enum M_KeyCertType {
  KeyCertType_NextSigner =                                              1,
  KeyCertType_AppSigner =                                               2,
  KeyCertType__Max =                                                    3 
} M_KeyCertType;

/* --- StatNodeTag codes --- */

typedef enum M_StatNodeTag {
  StatNodeTag_ServerGlobals =                                           1,
  StatNodeTag_Connections =                                             2,
  StatNodeTag_PerModule =                                               3,
  StatNodeTag_ModuleJobStats =                                          4,
  StatNodeTag_ModuleSCSIStats =                                         5,
  StatNodeTag_ModulePCIStats =                                          6,
  StatNodeTag_ModuleObjStats =                                          7,
  StatNodeTag_ModuleEnvStats =                                          8,
  StatNodeTag_ReservedMax =                                          1000,
  StatNodeTag__Max =                                                 1001 
} M_StatNodeTag;

/* --- TestVal codes --- */

typedef enum M_TestVal {
  TestVal_LT =                                                          1,
  TestVal_EQ =                                                          2,
  TestVal_LE =                                                          3,
  TestVal_GT =                                                          4,
  TestVal_NE =                                                          5,
  TestVal_GE =                                                          6,
  TestVal__Max =                                                        7 
} M_TestVal;

/* --- SEEInitStatus codes --- */

typedef enum M_SEEInitStatus {
  SEEInitStatus_OK =                                                    0,
  SEEInitStatus_MachineFailed =                                         1,
  SEEInitStatus_JavaMalformedJAR =                                      2,
  SEEInitStatus_InvalidCertificate =                                    3,
  SEEInitStatus__Max =                                                  4 
} M_SEEInitStatus;

/*----- Flag constants ----------------------------------------------------*/

/* --- Notes on flag naming --- *
 *
 * For each flagset `Foo_flags', we define some useful masks:
 *
 *   * `Foo_flags__reserved', if defined, is the mask of `harmless' flags,
 *     which may be set without upsetting existing software.
 *
 *   * `Foo_flags__allflags' is the mask of all currently-defined flags.
 *
 *   * `Foo_flags__presentflags' is the mask of flags which enable optional
 *     parts of data structures.
 */

/* --- Status_RemoteServerFailed_ErrorInfo_flags --- */

#define Status_RemoteServerFailed_ErrorInfo_flags_addr_present  0x00000001
#define Status_RemoteServerFailed_ErrorInfo_flags__reserved     0xffff0000
#define Status_RemoteServerFailed_ErrorInfo_flags__allflags     0x00000001
#define Status_RemoteServerFailed_ErrorInfo_flags__presentflags 0x00000001

/* --- Mech_SSLRecordLayer_IV_flags --- */

#define Mech_SSLRecordLayer_IV_flags_IsClient                   0x00000001
#define Mech_SSLRecordLayer_IV_flags__reserved                  0xffff0000
#define Mech_SSLRecordLayer_IV_flags__allflags                  0x00000001
#define Mech_SSLRecordLayer_IV_flags__presentflags              0x00000000

/* --- KeyType_Wrapped_GenParams_flags --- */

#define KeyType_Wrapped_GenParams_flags__reserved               0xffff0000
#define KeyType_Wrapped_GenParams_flags__allflags               0x00000000
#define KeyType_Wrapped_GenParams_flags__presentflags           0x00000000

/* --- KeyType_DSAPrivate_GenParams_flags --- */

#define KeyType_DSAPrivate_GenParams_flags_dlg_present          0x00000001
#define KeyType_DSAPrivate_GenParams_flags_Strict               0x00000002
#define KeyType_DSAPrivate_GenParams_flags__allflags            0x00000003
#define KeyType_DSAPrivate_GenParams_flags__presentflags        0x00000001

/* --- KeyType_DHPrivate_GenParams_flags --- */

#define KeyType_DHPrivate_GenParams_flags_dlg_present           0x00000001
#define KeyType_DHPrivate_GenParams_flags__allflags             0x00000001
#define KeyType_DHPrivate_GenParams_flags__presentflags         0x00000001

/* --- KeyType_KCDSAPrivate_GenParams_flags --- */

#define KeyType_KCDSAPrivate_GenParams_flags_dlg_present        0x00000001
#define KeyType_KCDSAPrivate_GenParams_flags__allflags          0x00000001
#define KeyType_KCDSAPrivate_GenParams_flags__presentflags      0x00000001

/* --- KeyType_RSAPrivate_GenParams_flags --- */

#define KeyType_RSAPrivate_GenParams_flags_given_e_present      0x00000001
#define KeyType_RSAPrivate_GenParams_flags_nchecks_present      0x00000002
#define KeyType_RSAPrivate_GenParams_flags_UseStrongPrimes      0x00000004
#define KeyType_RSAPrivate_GenParams_flags__allflags            0x00000007
#define KeyType_RSAPrivate_GenParams_flags__presentflags        0x00000003

/* --- KeyType_KCDSAComm_GenParams_flags --- */

#define KeyType_KCDSAComm_GenParams_flags_iv_present            0x00000001
#define KeyType_KCDSAComm_GenParams_flags__allflags             0x00000001
#define KeyType_KCDSAComm_GenParams_flags__presentflags         0x00000001

/* --- KeyType_DSAComm_GenParams_flags --- */

#define KeyType_DSAComm_GenParams_flags_iv_present              0x00000001
#define KeyType_DSAComm_GenParams_flags__allflags               0x00000001
#define KeyType_DSAComm_GenParams_flags__presentflags           0x00000001

/* --- Command_flags --- */

#define Command_flags_BignumMSBitFirst                          0x00000001
#define Command_flags_BignumMSWordFirst                         0x00000002
#define Command_flags_certs_present                             0x00000004
#define Command_flags__reserved                                 0xffff0000
#define Command_flags__allflags                                 0x00000007
#define Command_flags__presentflags                             0x00000004

/* --- Cmd_BignumOp_Args_flags --- */

#define Cmd_BignumOp_Args_flags_AllowNegative                   0x00000001
#define Cmd_BignumOp_Args_flags__reserved                       0xffff0000
#define Cmd_BignumOp_Args_flags__allflags                       0x00000001
#define Cmd_BignumOp_Args_flags__presentflags                   0x00000000

/* --- Cmd_Encrypt_Args_flags --- */

#define Cmd_Encrypt_Args_flags_given_iv_present                 0x00000001
#define Cmd_Encrypt_Args_flags__reserved                        0xffff0000
#define Cmd_Encrypt_Args_flags__allflags                        0x00000001
#define Cmd_Encrypt_Args_flags__presentflags                    0x00000001

/* --- Cmd_GetRTC_Args_flags --- */

#define Cmd_GetRTC_Args_flags__allflags                         0x00000000
#define Cmd_GetRTC_Args_flags__presentflags                     0x00000000

/* --- Cmd_UnimportSlot_Args_flags --- */

#define Cmd_UnimportSlot_Args_flags__reserved                   0xffff0000
#define Cmd_UnimportSlot_Args_flags__allflags                   0x00000000
#define Cmd_UnimportSlot_Args_flags__presentflags               0x00000000

/* --- Cmd_ChangeSharePIN_Args_flags --- */

#define Cmd_ChangeSharePIN_Args_flags_oldpin_present            0x00000001
#define Cmd_ChangeSharePIN_Args_flags_newpin_present            0x00000002
#define Cmd_ChangeSharePIN_Args_flags__reserved                 0xffff0000
#define Cmd_ChangeSharePIN_Args_flags__allflags                 0x00000003
#define Cmd_ChangeSharePIN_Args_flags__presentflags             0x00000003

/* --- Cmd_ImportSlot_Args_flags --- */

#define Cmd_ImportSlot_Args_flags__reserved                     0xffff0000
#define Cmd_ImportSlot_Args_flags__allflags                     0x00000000
#define Cmd_ImportSlot_Args_flags__presentflags                 0x00000000

/* --- RemoteModule_flags --- */

#define RemoteModule_flags_ma_present                           0x00000001
#define RemoteModule_flags_addr_present                         0x00000002
#define RemoteModule_flags_hks_present                          0x00000004
#define RemoteModule_flags_groups_present                       0x00000008
#define RemoteModule_flags_agelimit_present                     0x00000010
#define RemoteModule_flags_datalimit_present                    0x00000020
#define RemoteModule_flags__allflags                            0x0000003f
#define RemoteModule_flags__presentflags                        0x0000003f

/* --- Cmd_ReceiveShare_Args_flags --- */

#define Cmd_ReceiveShare_Args_flags_pin_present                 0x00000001
#define Cmd_ReceiveShare_Args_flags__allflags                   0x00000001
#define Cmd_ReceiveShare_Args_flags__presentflags               0x00000001

/* --- Cmd_ForeignTokenCmd_Args_flags --- */

#define Cmd_ForeignTokenCmd_Args_flags__reserved                0xffff0000
#define Cmd_ForeignTokenCmd_Args_flags__allflags                0x00000000
#define Cmd_ForeignTokenCmd_Args_flags__presentflags            0x00000000

/* --- Cmd_MakeBlob_Args_flags --- */

#define Cmd_MakeBlob_Args_flags_acl_present                     0x00000001
#define Cmd_MakeBlob_Args_flags__reserved                       0xffff0000
#define Cmd_MakeBlob_Args_flags__allflags                       0x00000001
#define Cmd_MakeBlob_Args_flags__presentflags                   0x00000001

/* --- Cmd_RemoveKM_Args_flags --- */

#define Cmd_RemoveKM_Args_flags__reserved                       0xffff0000
#define Cmd_RemoveKM_Args_flags__allflags                       0x00000000
#define Cmd_RemoveKM_Args_flags__presentflags                   0x00000000

/* --- TokenParams_flags --- */

#define TokenParams_flags_AllTokensRemovable                    0x00000001
#define TokenParams_flags_AllButOneRemovable                    0x00000002
#define TokenParams_flags_AllowSoftSlots                        0x00000004
#define TokenParams_flags__reserved                             0xffff0000
#define TokenParams_flags__allflags                             0x00000007
#define TokenParams_flags__presentflags                         0x00000000

/* --- Cmd_ImpathSend_Args_flags --- */

#define Cmd_ImpathSend_Args_flags__reserved                     0xffff0000
#define Cmd_ImpathSend_Args_flags__allflags                     0x00000000
#define Cmd_ImpathSend_Args_flags__presentflags                 0x00000000

/* --- Cmd_SetSEEMachine_Args_flags --- */

#define Cmd_SetSEEMachine_Args_flags__reserved                  0xffff0000
#define Cmd_SetSEEMachine_Args_flags__allflags                  0x00000000
#define Cmd_SetSEEMachine_Args_flags__presentflags              0x00000000

/* --- Cmd_GetKeyInfoEx_Args_flags --- */

#define Cmd_GetKeyInfoEx_Args_flags__reserved                   0xffff0000
#define Cmd_GetKeyInfoEx_Args_flags__allflags                   0x00000000
#define Cmd_GetKeyInfoEx_Args_flags__presentflags               0x00000000

/* --- Cmd_ReadFile_Args_flags --- */

#define Cmd_ReadFile_Args_flags__reserved                       0xffff0000
#define Cmd_ReadFile_Args_flags__allflags                       0x00000000
#define Cmd_ReadFile_Args_flags__presentflags                   0x00000000

/* --- FileInfo_flags --- */

#define FileInfo_flags__reserved                                0xffff0000
#define FileInfo_flags__allflags                                0x00000000
#define FileInfo_flags__presentflags                            0x00000000

/* --- Cmd_GetKMList_Args_flags --- */

#define Cmd_GetKMList_Args_flags__reserved                      0xffff0000
#define Cmd_GetKMList_Args_flags__allflags                      0x00000000
#define Cmd_GetKMList_Args_flags__presentflags                  0x00000000

/* --- Cmd_OldEnquiry_Args_flags --- */

#define Cmd_OldEnquiry_Args_flags_module_present                0x00000001
#define Cmd_OldEnquiry_Args_flags__allflags                     0x00000001
#define Cmd_OldEnquiry_Args_flags__presentflags                 0x00000001

/* --- Cmd_InsertSoftToken_Args_flags --- */

#define Cmd_InsertSoftToken_Args_flags__reserved                0xffff0000
#define Cmd_InsertSoftToken_Args_flags__allflags                0x00000000
#define Cmd_InsertSoftToken_Args_flags__presentflags            0x00000000

/* --- Cmd_WriteFile_Args_flags --- */

#define Cmd_WriteFile_Args_flags__reserved                      0xffff0000
#define Cmd_WriteFile_Args_flags__allflags                      0x00000000
#define Cmd_WriteFile_Args_flags__presentflags                  0x00000000

/* --- Cmd_WriteShare_Args_flags --- */

#define Cmd_WriteShare_Args_flags_pin_present                   0x00000001
#define Cmd_WriteShare_Args_flags_UseProtectedPINPath           0x00000002
#define Cmd_WriteShare_Args_flags_acl_present                   0x00000004
#define Cmd_WriteShare_Args_flags__reserved                     0xffff0000
#define Cmd_WriteShare_Args_flags__allflags                     0x00000007
#define Cmd_WriteShare_Args_flags__presentflags                 0x00000005

/* --- NSOPerms_ops --- */

#define NSOPerms_ops_LoadLogicalToken                           0x00000001
#define NSOPerms_ops_ReadFile                                   0x00000002
#define NSOPerms_ops_WriteShare                                 0x00000004
#define NSOPerms_ops_WriteFile                                  0x00000008
#define NSOPerms_ops_EraseShare                                 0x00000010
#define NSOPerms_ops_EraseFile                                  0x00000020
#define NSOPerms_ops_FormatToken                                0x00000040
#define NSOPerms_ops_SetKM                                      0x00000080
#define NSOPerms_ops_RemoveKM                                   0x00000100
#define NSOPerms_ops_GenerateLogToken                           0x00000200
#define NSOPerms_ops_ChangeSharePIN                             0x00000400
#define NSOPerms_ops_OriginateKey                               0x00000800
#define NSOPerms_ops_NVMemAlloc                                 0x00001000
#define NSOPerms_ops_NVMemFree                                  0x00002000
#define NSOPerms_ops_GetRTC                                     0x00004000
#define NSOPerms_ops_SetRTC                                     0x00008000
#define NSOPerms_ops_DebugSEEWorld                              0x00010000
#define NSOPerms_ops_SendShare                                  0x00020000
#define NSOPerms_ops_ForeignTokenOpen                           0x00040000
#define NSOPerms_ops__reserved                                  0xfffff000
#define NSOPerms_ops__allflags                                  0x0007ffff
#define NSOPerms_ops__presentflags                              0x00000000

/* --- Cmd_LoadRaw_Args_flags --- */

#define Cmd_LoadRaw_Args_flags_StartChunk                       0x00000001
#define Cmd_LoadRaw_Args_flags_EndChunk                         0x00000002
#define Cmd_LoadRaw_Args_flags__allflags                        0x00000003
#define Cmd_LoadRaw_Args_flags__presentflags                    0x00000000

/* --- Cmd_GetLogicalTokenInfoEx_Args_flags --- */

#define Cmd_GetLogicalTokenInfoEx_Args_flags__reserved          0xffff0000
#define Cmd_GetLogicalTokenInfoEx_Args_flags__allflags          0x00000000
#define Cmd_GetLogicalTokenInfoEx_Args_flags__presentflags      0x00000000

/* --- Cmd_StatGetValues_Args_flags --- */

#define Cmd_StatGetValues_Args_flags_Privileged                 0x00000001
#define Cmd_StatGetValues_Args_flags__reserved                  0xffff0000
#define Cmd_StatGetValues_Args_flags__allflags                  0x00000001
#define Cmd_StatGetValues_Args_flags__presentflags              0x00000000

/* --- Cmd_ChannelUpdate_Args_flags --- */

#define Cmd_ChannelUpdate_Args_flags_final                      0x00000001
#define Cmd_ChannelUpdate_Args_flags__allflags                  0x00000001
#define Cmd_ChannelUpdate_Args_flags__presentflags              0x00000000

/* --- RemoteServerPermission_flags --- */

#define RemoteServerPermission_flags__reserved                  0xffff0000
#define RemoteServerPermission_flags__allflags                  0x00000000
#define RemoteServerPermission_flags__presentflags              0x00000000

/* --- Cmd_CreateSEEWorld_Args_flags --- */

#define Cmd_CreateSEEWorld_Args_flags_EnableDebug               0x00010000
#define Cmd_CreateSEEWorld_Args_flags__reserved                 0xffff0000
#define Cmd_CreateSEEWorld_Args_flags__allflags                 0x00010000
#define Cmd_CreateSEEWorld_Args_flags__presentflags             0x00000000

/* --- Cmd_GetACL_Args_flags --- */

#define Cmd_GetACL_Args_flags__reserved                         0xffff0000
#define Cmd_GetACL_Args_flags__allflags                         0x00000000
#define Cmd_GetACL_Args_flags__presentflags                     0x00000000

/* --- Cmd_RedeemTicket_Args_flags --- */

#define Cmd_RedeemTicket_Args_flags__reserved                   0xffff0000
#define Cmd_RedeemTicket_Args_flags__allflags                   0x00000000
#define Cmd_RedeemTicket_Args_flags__presentflags               0x00000000

/* --- Cmd_ImpathKXFinish_Args_flags --- */

#define Cmd_ImpathKXFinish_Args_flags_addr_present              0x00000001
#define Cmd_ImpathKXFinish_Args_flags__allflags                 0x00000001
#define Cmd_ImpathKXFinish_Args_flags__presentflags             0x00000001

/* --- Cmd_GetTicket_Args_flags --- */

#define Cmd_GetTicket_Args_flags_Reusable                       0x00000001
#define Cmd_GetTicket_Args_flags__reserved                      0xffff0000
#define Cmd_GetTicket_Args_flags__allflags                      0x00000001
#define Cmd_GetTicket_Args_flags__presentflags                  0x00000000

/* --- Cmd_NVMemAlloc_Args_flags --- */

#define Cmd_NVMemAlloc_Args_flags__allflags                     0x00000000
#define Cmd_NVMemAlloc_Args_flags__presentflags                 0x00000000

/* --- Cmd_RemoveSoftToken_Args_flags --- */

#define Cmd_RemoveSoftToken_Args_flags_NoRetData                0x00000001
#define Cmd_RemoveSoftToken_Args_flags_Examine                  0x00000002
#define Cmd_RemoveSoftToken_Args_flags__reserved                0xffff0000
#define Cmd_RemoveSoftToken_Args_flags__allflags                0x00000003
#define Cmd_RemoveSoftToken_Args_flags__presentflags            0x00000000

/* --- Cmd_ModuleInfo_Args_flags --- */

#define Cmd_ModuleInfo_Args_flags__reserved                     0xffff0000
#define Cmd_ModuleInfo_Args_flags__allflags                     0x00000000
#define Cmd_ModuleInfo_Args_flags__presentflags                 0x00000000

/* --- Cmd_ExportSlot_Args_flags --- */

#define Cmd_ExportSlot_Args_flags__reserved                     0xffff0000
#define Cmd_ExportSlot_Args_flags__allflags                     0x00000000
#define Cmd_ExportSlot_Args_flags__presentflags                 0x00000000

/* --- Cmd_Decrypt_Args_flags --- */

#define Cmd_Decrypt_Args_flags__reserved                        0xffff0000
#define Cmd_Decrypt_Args_flags__allflags                        0x00000000
#define Cmd_Decrypt_Args_flags__presentflags                    0x00000000

/* --- Cmd_ServerSendShare_Args_flags --- */

#define Cmd_ServerSendShare_Args_flags_pin_present              0x00000001
#define Cmd_ServerSendShare_Args_flags_UseProtectedPINPath      0x00000002
#define Cmd_ServerSendShare_Args_flags__allflags                0x00000003
#define Cmd_ServerSendShare_Args_flags__presentflags            0x00000001

/* --- Cmd_NewEnquiry_Args_flags --- */

#define Cmd_NewEnquiry_Args_flags__reserved                     0xffff0000
#define Cmd_NewEnquiry_Args_flags__allflags                     0x00000000
#define Cmd_NewEnquiry_Args_flags__presentflags                 0x00000000

/* --- Cmd_UpdateMergedKey_Args_flags --- */

#define Cmd_UpdateMergedKey_Args_flags_ListWorking              0x00000001
#define Cmd_UpdateMergedKey_Args_flags_ListNonworking           0x00000002
#define Cmd_UpdateMergedKey_Args_flags__allflags                0x00000003
#define Cmd_UpdateMergedKey_Args_flags__presentflags            0x00000000

/* --- Cmd_ChannelOpen_Args_flags --- */

#define Cmd_ChannelOpen_Args_flags_key_present                  0x00000001
#define Cmd_ChannelOpen_Args_flags_given_iv_present             0x00000002
#define Cmd_ChannelOpen_Args_flags__reserved                    0xffff0000
#define Cmd_ChannelOpen_Args_flags__allflags                    0x00000003
#define Cmd_ChannelOpen_Args_flags__presentflags                0x00000003

/* --- Cmd_SetRTC_Args_flags --- */

#define Cmd_SetRTC_Args_flags_adjust                            0x00000001
#define Cmd_SetRTC_Args_flags__allflags                         0x00000001
#define Cmd_SetRTC_Args_flags__presentflags                     0x00000000

/* --- Cmd_ReadShare_Args_flags --- */

#define Cmd_ReadShare_Args_flags_pin_present                    0x00000001
#define Cmd_ReadShare_Args_flags__reserved                      0xffff0000
#define Cmd_ReadShare_Args_flags__allflags                      0x00000001
#define Cmd_ReadShare_Args_flags__presentflags                  0x00000001

/* --- Cmd_Sign_Args_flags --- */

#define Cmd_Sign_Args_flags_given_iv_present                    0x00000001
#define Cmd_Sign_Args_flags__reserved                           0xffff0000
#define Cmd_Sign_Args_flags__allflags                           0x00000001
#define Cmd_Sign_Args_flags__presentflags                       0x00000001

/* --- Cmd_ExistingClient_Args_flags --- */

#define Cmd_ExistingClient_Args_flags__allflags                 0x00000000
#define Cmd_ExistingClient_Args_flags__presentflags             0x00000000

/* --- Cmd_SendShare_Args_flags --- */

#define Cmd_SendShare_Args_flags_pin_present                    0x00000001
#define Cmd_SendShare_Args_flags_UseProtectedPINPath            0x00000002
#define Cmd_SendShare_Args_flags__allflags                      0x00000003
#define Cmd_SendShare_Args_flags__presentflags                  0x00000001

/* --- Cmd_ImpathKXBegin_Args_flags --- */

#define Cmd_ImpathKXBegin_Args_flags__allflags                  0x00000000
#define Cmd_ImpathKXBegin_Args_flags__presentflags              0x00000000

/* --- Cmd_ForeignTokenOpen_Args_flags --- */

#define Cmd_ForeignTokenOpen_Args_flags__reserved               0xffff0000
#define Cmd_ForeignTokenOpen_Args_flags__allflags               0x00000000
#define Cmd_ForeignTokenOpen_Args_flags__presentflags           0x00000000

/* --- Cmd_CheckUserAction_Args_flags --- */

#define Cmd_CheckUserAction_Args_flags__reserved                0xffff0000
#define Cmd_CheckUserAction_Args_flags__allflags                0x00000000
#define Cmd_CheckUserAction_Args_flags__presentflags            0x00000000

/* --- Cmd_EraseFile_Args_flags --- */

#define Cmd_EraseFile_Args_flags__reserved                      0xffff0000
#define Cmd_EraseFile_Args_flags__allflags                      0x00000000
#define Cmd_EraseFile_Args_flags__presentflags                  0x00000000

/* --- Cmd_Hash_Args_flags --- */

#define Cmd_Hash_Args_flags__reserved                           0xffff0000
#define Cmd_Hash_Args_flags__allflags                           0x00000000
#define Cmd_Hash_Args_flags__presentflags                       0x00000000

/* --- Cmd_FormatToken_Args_flags --- */

#define Cmd_FormatToken_Args_flags_auth_key_present             0x00000001
#define Cmd_FormatToken_Args_flags__reserved                    0xffff0000
#define Cmd_FormatToken_Args_flags__allflags                    0x00000001
#define Cmd_FormatToken_Args_flags__presentflags                0x00000001

/* --- Cmd_PollSlotList_Args_flags --- */

#define Cmd_PollSlotList_Args_flags__reserved                   0xffff0000
#define Cmd_PollSlotList_Args_flags__allflags                   0x00000000
#define Cmd_PollSlotList_Args_flags__presentflags               0x00000000

/* --- Cmd_PollModuleState_Args_flags --- */

#define Cmd_PollModuleState_Args_flags__reserved                0xffff0000
#define Cmd_PollModuleState_Args_flags__allflags                0x00000000
#define Cmd_PollModuleState_Args_flags__presentflags            0x00000000

/* --- Cmd_NVMemFree_Args_flags --- */

#define Cmd_NVMemFree_Args_flags__allflags                      0x00000000
#define Cmd_NVMemFree_Args_flags__presentflags                  0x00000000

/* --- Cmd_SetKM_Args_flags --- */

#define Cmd_SetKM_Args_flags__reserved                          0xffff0000
#define Cmd_SetKM_Args_flags__allflags                          0x00000000
#define Cmd_SetKM_Args_flags__presentflags                      0x00000000

/* --- Cmd_GenerateKLF_Args_flags --- */

#define Cmd_GenerateKLF_Args_flags__allflags                    0x00000000
#define Cmd_GenerateKLF_Args_flags__presentflags                0x00000000

/* --- Cmd_DeriveKey_Args_flags --- */

#define Cmd_DeriveKey_Args_flags__reserved                      0xffff0000
#define Cmd_DeriveKey_Args_flags__allflags                      0x00000000
#define Cmd_DeriveKey_Args_flags__presentflags                  0x00000000

/* --- Cmd_StatEnumTree_Args_flags --- */

#define Cmd_StatEnumTree_Args_flags__reserved                   0xffff0000
#define Cmd_StatEnumTree_Args_flags__allflags                   0x00000000
#define Cmd_StatEnumTree_Args_flags__presentflags               0x00000000

/* --- Cmd_NVMemOp_Args_flags --- */

#define Cmd_NVMemOp_Args_flags_range_present                    0x00000001
#define Cmd_NVMemOp_Args_flags__allflags                        0x00000001
#define Cmd_NVMemOp_Args_flags__presentflags                    0x00000001

/* --- Cmd_LoadBlob_Args_flags --- */

#define Cmd_LoadBlob_Args_flags_idkb_present                    0x00000001
#define Cmd_LoadBlob_Args_flags__reserved                       0xffff0000
#define Cmd_LoadBlob_Args_flags__allflags                       0x00000001
#define Cmd_LoadBlob_Args_flags__presentflags                   0x00000001

/* --- FeatureInfo_ctrl --- */

#define FeatureInfo_ctrl_Add                                    0x00000001
#define FeatureInfo_ctrl_LongTerm                               0x00000002
#define FeatureInfo_ctrl__allflags                              0x00000003
#define FeatureInfo_ctrl__presentflags                          0x00000000

/* --- FeatureInfo_features --- */

#define FeatureInfo_features_ForeignTokenOpen                   0x00000001
#define FeatureInfo_features_RemoteShare                        0x00000002
#define FeatureInfo_features_GeneralSEE                         0x00000004
#define FeatureInfo_features_ExportCGEA                         0x00000008
#define FeatureInfo_features_KISAAlgorithms                     0x00000010
#define FeatureInfo_features_StandardKM                         0x00000020
#define FeatureInfo_features_PayShield                          0x00000040
#define FeatureInfo_features_reserved7                          0x00000080
#define FeatureInfo_features_reserved8                          0x00000100
#define FeatureInfo_features_reserved9                          0x00000200
#define FeatureInfo_features_reserved10                         0x00000400
#define FeatureInfo_features_reserved11                         0x00000800
#define FeatureInfo_features_reserved12                         0x00001000
#define FeatureInfo_features_reserved13                         0x00002000
#define FeatureInfo_features_reserved14                         0x00004000
#define FeatureInfo_features_reserved15                         0x00008000
#define FeatureInfo_features_reserved16                         0x00010000
#define FeatureInfo_features_reserved17                         0x00020000
#define FeatureInfo_features_reserved18                         0x00040000
#define FeatureInfo_features_reserved19                         0x00080000
#define FeatureInfo_features_reserved20                         0x00100000
#define FeatureInfo_features_reserved21                         0x00200000
#define FeatureInfo_features_reserved22                         0x00400000
#define FeatureInfo_features_reserved23                         0x00800000
#define FeatureInfo_features_reserved24                         0x01000000
#define FeatureInfo_features_reserved25                         0x02000000
#define FeatureInfo_features_reserved26                         0x04000000
#define FeatureInfo_features_reserved27                         0x08000000
#define FeatureInfo_features_reserved28                         0x10000000
#define FeatureInfo_features_reserved29                         0x20000000
#define FeatureInfo_features_reserved30                         0x40000000
#define FeatureInfo_features_reserved31                         0x80000000
#define FeatureInfo_features__reserved                          0xffffffff
#define FeatureInfo_features__allflags                          0xffffffff
#define FeatureInfo_features__presentflags                      0x00000000

/* --- FeatureInfo versioning --- */

#define FeatureInfo__maxversion                                          0

/* --- Cmd_GenerateKey_Args_flags --- */

#define Cmd_GenerateKey_Args_flags_Certify                      0x00000001
#define Cmd_GenerateKey_Args_flags_appdata_present              0x00000002
#define Cmd_GenerateKey_Args_flags_PairwiseCheck                0x00000004
#define Cmd_GenerateKey_Args_flags__reserved                    0xffff0000
#define Cmd_GenerateKey_Args_flags__allflags                    0x00000007
#define Cmd_GenerateKey_Args_flags__presentflags                0x00000002

/* --- Cmd_NVMemList_Args_flags --- */

#define Cmd_NVMemList_Args_flags__allflags                      0x00000000
#define Cmd_NVMemList_Args_flags__presentflags                  0x00000000

/* --- Cmd_CreateBuffer_Args_flags --- */

#define Cmd_CreateBuffer_Args_flags_params_present              0x00000001
#define Cmd_CreateBuffer_Args_flags__reserved                   0xffff0000
#define Cmd_CreateBuffer_Args_flags__allflags                   0x00000001
#define Cmd_CreateBuffer_Args_flags__presentflags               0x00000001

/* --- Cmd_GetShareACL_Args_flags --- */

#define Cmd_GetShareACL_Args_flags__reserved                    0xffff0000
#define Cmd_GetShareACL_Args_flags__allflags                    0x00000000
#define Cmd_GetShareACL_Args_flags__presentflags                0x00000000

/* --- Cmd_GenerateKeyPair_Args_flags --- */

#define Cmd_GenerateKeyPair_Args_flags_Certify                  0x00000001
#define Cmd_GenerateKeyPair_Args_flags_appdatapriv_present      0x00000002
#define Cmd_GenerateKeyPair_Args_flags_appdatapub_present       0x00000004
#define Cmd_GenerateKeyPair_Args_flags_PairwiseCheck            0x00000008
#define Cmd_GenerateKeyPair_Args_flags__reserved                0xffff0000
#define Cmd_GenerateKeyPair_Args_flags__allflags                0x0000000f
#define Cmd_GenerateKeyPair_Args_flags__presentflags            0x00000006

/* --- Cmd_FirmwareAuthenticate_Args_flags --- */

#define Cmd_FirmwareAuthenticate_Args_flags_Monitor             0x00000001
#define Cmd_FirmwareAuthenticate_Args_flags_Applic              0x00000002
#define Cmd_FirmwareAuthenticate_Args_flags__allflags           0x00000003
#define Cmd_FirmwareAuthenticate_Args_flags__presentflags       0x00000000

/* --- Cmd_SetNSOPerms_Args_flags --- */

#define Cmd_SetNSOPerms_Args_flags_FIPS140Level3                0x00000001
#define Cmd_SetNSOPerms_Args_flags__reserved                    0xffff0000
#define Cmd_SetNSOPerms_Args_flags__allflags                    0x00000001
#define Cmd_SetNSOPerms_Args_flags__presentflags                0x00000000

/* --- Cmd_SignModuleState_Args_flags --- */

#define Cmd_SignModuleState_Args_flags_challenge_present        0x00000001
#define Cmd_SignModuleState_Args_flags__allflags                0x00000001
#define Cmd_SignModuleState_Args_flags__presentflags            0x00000001

/* --- Cmd_NewClient_Args_flags --- */

#define Cmd_NewClient_Args_flags__allflags                      0x00000000
#define Cmd_NewClient_Args_flags__presentflags                  0x00000000

/* --- Cmd_Verify_Args_flags --- */

#define Cmd_Verify_Args_flags__reserved                         0xffff0000
#define Cmd_Verify_Args_flags__allflags                         0x00000000
#define Cmd_Verify_Args_flags__presentflags                     0x00000000

/* --- Cmd_GetWorldSigners_Args_flags --- */

#define Cmd_GetWorldSigners_Args_flags__allflags                0x00000000
#define Cmd_GetWorldSigners_Args_flags__presentflags            0x00000000

/* --- Cmd_PauseForNotifications_Args_flags --- */

#define Cmd_PauseForNotifications_Args_flags__reserved          0xffff0000
#define Cmd_PauseForNotifications_Args_flags__allflags          0x00000000
#define Cmd_PauseForNotifications_Args_flags__presentflags      0x00000000

/* --- Cmd_LoadBuffer_Args_flags --- */

#define Cmd_LoadBuffer_Args_flags_Final                         0x00000001
#define Cmd_LoadBuffer_Args_flags__reserved                     0xffff0000
#define Cmd_LoadBuffer_Args_flags__allflags                     0x00000001
#define Cmd_LoadBuffer_Args_flags__presentflags                 0x00000000

/* --- Cmd_SetACL_Args_flags --- */

#define Cmd_SetACL_Args_flags_reduce                            0x00000001
#define Cmd_SetACL_Args_flags__reserved                         0xffff0000
#define Cmd_SetACL_Args_flags__allflags                         0x00000001
#define Cmd_SetACL_Args_flags__presentflags                     0x00000000

/* --- PermissionGroup_flags --- */

#define PermissionGroup_flags_certifier_present                 0x00000001
#define PermissionGroup_flags_FreshCerts                        0x00000002
#define PermissionGroup_flags_certmech_present                  0x00000004
#define PermissionGroup_flags_moduleserial_present              0x00000008
#define PermissionGroup_flags_NSOCertified                      0x00000010
#define PermissionGroup_flags__reserved                         0xffff0000
#define PermissionGroup_flags__allflags                         0x0000001f
#define PermissionGroup_flags__presentflags                     0x0000000d

/* --- EnquiryDataOne_flags --- */

#define EnquiryDataOne_flags_Hardware                           0x00000001
#define EnquiryDataOne_flags_HasTokens                          0x00000002
#define EnquiryDataOne_flags_MaintenanceMode                    0x00000004
#define EnquiryDataOne_flags_InitialisationMode                 0x00000008
#define EnquiryDataOne_flags_PreMaintInitMode                   0x00000010
#define EnquiryDataOne_flags_Uninitialised                      0x00000020
#define EnquiryDataOne_flags_TestingFirmware                    0x00000040
#define EnquiryDataOne_flags__reserved                          0xffff0000
#define EnquiryDataOne_flags__allflags                          0x0000007f
#define EnquiryDataOne_flags__presentflags                      0x00000000

/* --- EnquiryDataTwo_flags --- */

#define EnquiryDataTwo_flags_Fragmentation                      0x00000001
#define EnquiryDataTwo_flags__allflags                          0x00000001
#define EnquiryDataTwo_flags__presentflags                      0x00000000

/* --- EnquiryDataThree_flags --- */

#define EnquiryDataThree_flags_KeyStorage                       0x00000001
#define EnquiryDataThree_flags__allflags                        0x00000001
#define EnquiryDataThree_flags__presentflags                    0x00000000

/* --- EnquiryDataFour_flags --- */

#define EnquiryDataFour_flags_OrderlyClearUnit                  0x00000010
#define EnquiryDataFour_flags_HasRTC                            0x00000020
#define EnquiryDataFour_flags_HasNVRAM                          0x00000040
#define EnquiryDataFour_flags_HasNSOPermsCmd                    0x00000080
#define EnquiryDataFour_flags_ServerHasPollCmds                 0x00000100
#define EnquiryDataFour_flags_FastPollSlotList                  0x00000200
#define EnquiryDataFour_flags_HasSEE                            0x00000400
#define EnquiryDataFour_flags_HasKLF                            0x00000800
#define EnquiryDataFour_flags_HasShareACL                       0x00001000
#define EnquiryDataFour_flags_HasFeatureEnable                  0x00002000
#define EnquiryDataFour_flags__reserved                         0xfffffff0
#define EnquiryDataFour_flags__allflags                         0x00003ff0
#define EnquiryDataFour_flags__presentflags                     0x00000000

/* --- EnquiryDataSix versioning --- */

#define EnquiryDataSix__maxversion                                       1

/* --- ModuleAttribTag_AdditionalInfo_Value versioning --- */

#define ModuleAttribTag_AdditionalInfo_Value__maxversion                 0

/* --- UseLim_NonVolatile_Details_flags --- */

#define UseLim_NonVolatile_Details_flags__allflags              0x00000000
#define UseLim_NonVolatile_Details_flags__presentflags          0x00000000

/* --- Act_FeatureEnable_Details_flags --- */

#define Act_FeatureEnable_Details_flags_SetSEEMachine           0x00000001
#define Act_FeatureEnable_Details_flags_GenerateKLF             0x00000002
#define Act_FeatureEnable_Details_flags__reserved               0xfffffffe
#define Act_FeatureEnable_Details_flags__allflags               0x00000003
#define Act_FeatureEnable_Details_flags__presentflags           0x00000000

/* --- Act_DeriveKey_Details_flags --- */

#define Act_DeriveKey_Details_flags__allflags                   0x00000000
#define Act_DeriveKey_Details_flags__presentflags               0x00000000

/* --- Act_SendShare_Details_flags --- */

#define Act_SendShare_Details_flags_rm_present                  0x00000001
#define Act_SendShare_Details_flags_rsd_present                 0x00000002
#define Act_SendShare_Details_flags__allflags                   0x00000003
#define Act_SendShare_Details_flags__presentflags               0x00000003

/* --- Act_NVMemUseLimit_Details_flags --- */

#define Act_NVMemUseLimit_Details_flags__allflags               0x00000000
#define Act_NVMemUseLimit_Details_flags__presentflags           0x00000000

/* --- Act_NVMemOpPerms_Details_perms --- */

#define Act_NVMemOpPerms_Details_perms_Read                     0x00000001
#define Act_NVMemOpPerms_Details_perms_Write                    0x00000002
#define Act_NVMemOpPerms_Details_perms_Incr                     0x00000004
#define Act_NVMemOpPerms_Details_perms_Decr                     0x00000008
#define Act_NVMemOpPerms_Details_perms_BitSet                   0x00000010
#define Act_NVMemOpPerms_Details_perms_BitClear                 0x00000020
#define Act_NVMemOpPerms_Details_perms_Free                     0x00000040
#define Act_NVMemOpPerms_Details_perms_subrange_present         0x00000080
#define Act_NVMemOpPerms_Details_perms_exactrange_present       0x00000100
#define Act_NVMemOpPerms_Details_perms_incdeclimit_present      0x00000200
#define Act_NVMemOpPerms_Details_perms_GetACL                   0x00000400
#define Act_NVMemOpPerms_Details_perms__allflags                0x000007ff
#define Act_NVMemOpPerms_Details_perms__presentflags            0x00000380

/* --- Act_OpPermissions_Details_perms --- */

#define Act_OpPermissions_Details_perms_DuplicateHandle         0x00000001
#define Act_OpPermissions_Details_perms_UseAsCertificate        0x00000002
#define Act_OpPermissions_Details_perms_ExportAsPlain           0x00000004
#define Act_OpPermissions_Details_perms_GetAppData              0x00000008
#define Act_OpPermissions_Details_perms_SetAppData              0x00000010
#define Act_OpPermissions_Details_perms_ReduceACL               0x00000020
#define Act_OpPermissions_Details_perms_ExpandACL               0x00000040
#define Act_OpPermissions_Details_perms_Encrypt                 0x00000080
#define Act_OpPermissions_Details_perms_Decrypt                 0x00000100
#define Act_OpPermissions_Details_perms_Verify                  0x00000200
#define Act_OpPermissions_Details_perms_UseAsBlobKey            0x00000400
#define Act_OpPermissions_Details_perms_UseAsKM                 0x00000800
#define Act_OpPermissions_Details_perms_Sign                    0x00001000
#define Act_OpPermissions_Details_perms_GetACL                  0x00002000
#define Act_OpPermissions_Details_perms_UseAsLoaderKey          0x00004000
#define Act_OpPermissions_Details_perms_SignModuleCert          0x00008000
#define Act_OpPermissions_Details_perms__allflags               0x0000ffff
#define Act_OpPermissions_Details_perms__presentflags           0x00000000

/* --- Act_MakeArchiveBlob_Details_flags --- */

#define Act_MakeArchiveBlob_Details_flags_kahash_present        0x00000001
#define Act_MakeArchiveBlob_Details_flags__reserved             0xffff0000
#define Act_MakeArchiveBlob_Details_flags__allflags             0x00000001
#define Act_MakeArchiveBlob_Details_flags__presentflags         0x00000001

/* --- Act_MakeBlob_Details_flags --- */

#define Act_MakeBlob_Details_flags_AllowKmOnly                  0x00000001
#define Act_MakeBlob_Details_flags_AllowNonKm0                  0x00000002
#define Act_MakeBlob_Details_flags_kmhash_present               0x00000004
#define Act_MakeBlob_Details_flags_kthash_present               0x00000008
#define Act_MakeBlob_Details_flags_ktparams_present             0x00000010
#define Act_MakeBlob_Details_flags_AllowNullKmToken             0x00000020
#define Act_MakeBlob_Details_flags__reserved                    0xff000000
#define Act_MakeBlob_Details_flags__allflags                    0x0000003f
#define Act_MakeBlob_Details_flags__presentflags                0x0000001c

/* --- ReadShareDetails_flags --- */

#define ReadShareDetails_flags__allflags                        0x00000000
#define ReadShareDetails_flags__presentflags                    0x00000000

/* --- Reply_flags --- */

#define Reply_flags_BignumMSBitFirst                            0x00000001
#define Reply_flags_BignumMSWordFirst                           0x00000002
#define Reply_flags__reserved                                   0xffff0000
#define Reply_flags__allflags                                   0x00000003
#define Reply_flags__presentflags                               0x00000000

/* --- Cmd_GetKMList_Reply_flags --- */

#define Cmd_GetKMList_Reply_flags_KNSOset                       0x00000001
#define Cmd_GetKMList_Reply_flags__reserved                     0xffff0000
#define Cmd_GetKMList_Reply_flags__allflags                     0x00000001
#define Cmd_GetKMList_Reply_flags__presentflags                 0x00000000

/* --- Cmd_GetLogicalTokenInfoEx_Reply_flags --- */

#define Cmd_GetLogicalTokenInfoEx_Reply_flags__reserved         0xffff0000
#define Cmd_GetLogicalTokenInfoEx_Reply_flags__allflags         0x00000000
#define Cmd_GetLogicalTokenInfoEx_Reply_flags__presentflags     0x00000000

/* --- Cmd_GetLogicalTokenInfoEx_Reply versioning --- */

#define Cmd_GetLogicalTokenInfoEx_Reply__maxversion                      0

/* --- ImpathInfo versioning --- */

#define ImpathInfo__maxversion                                           0

/* --- Cmd_ANSlotChangeEvent_Reply_flags --- */

#define Cmd_ANSlotChangeEvent_Reply_flags_PhysToken             0x01000000
#define Cmd_ANSlotChangeEvent_Reply_flags_Data                  0x02000000
#define Cmd_ANSlotChangeEvent_Reply_flags__reserved             0xff000000
#define Cmd_ANSlotChangeEvent_Reply_flags__allflags             0x03000000
#define Cmd_ANSlotChangeEvent_Reply_flags__presentflags         0x00000000

/* --- Cmd_ProgrammingEndChunk_Reply_flags --- */

#define Cmd_ProgrammingEndChunk_Reply_flags_Unchanged           0x00000001
#define Cmd_ProgrammingEndChunk_Reply_flags__reserved           0xffff0000
#define Cmd_ProgrammingEndChunk_Reply_flags__allflags           0x00000001
#define Cmd_ProgrammingEndChunk_Reply_flags__presentflags       0x00000000

/* --- SlotListData_flags --- */

#define SlotListData_flags_ProtectedPINPath                     0x00000001
#define SlotListData_flags_SupportsAuthentication               0x00000002
#define SlotListData_flags_NotSoftSlot                          0x00010000
#define SlotListData_flags_ReadOnly                             0x00020000
#define SlotListData_flags_RemoteSlot                           0x00040000
#define SlotListData_flags__reserved                            0xffff0000
#define SlotListData_flags__allflags                            0x00070003
#define SlotListData_flags__presentflags                        0x00000000

/* --- Cmd_ServerSendShare_Reply_flags --- */

#define Cmd_ServerSendShare_Reply_flags_PINProtected            0x00000001
#define Cmd_ServerSendShare_Reply_flags__reserved               0xffff0000
#define Cmd_ServerSendShare_Reply_flags__allflags               0x00000001
#define Cmd_ServerSendShare_Reply_flags__presentflags           0x00000000

/* --- Cmd_NewEnquiry_Reply_flags --- */

#define Cmd_NewEnquiry_Reply_flags_Failed                       0x00010000
#define Cmd_NewEnquiry_Reply_flags__reserved                    0xffff0000
#define Cmd_NewEnquiry_Reply_flags__allflags                    0x00010000
#define Cmd_NewEnquiry_Reply_flags__presentflags                0x00000000

/* --- Cmd_ChannelOpen_Reply_flags --- */

#define Cmd_ChannelOpen_Reply_flags_new_iv_present              0x00000001
#define Cmd_ChannelOpen_Reply_flags__allflags                   0x00000001
#define Cmd_ChannelOpen_Reply_flags__presentflags               0x00000001

/* --- Cmd_ExistingClient_Reply_flags --- */

#define Cmd_ExistingClient_Reply_flags__allflags                0x00000000
#define Cmd_ExistingClient_Reply_flags__presentflags            0x00000000

/* --- Cmd_PollSlotList_Reply_flags --- */

#define Cmd_PollSlotList_Reply_flags__reserved                  0xffff0000
#define Cmd_PollSlotList_Reply_flags__allflags                  0x00000000
#define Cmd_PollSlotList_Reply_flags__presentflags              0x00000000

/* --- Cmd_NVMemList_Reply_flags --- */

#define Cmd_NVMemList_Reply_flags__allflags                     0x00000000
#define Cmd_NVMemList_Reply_flags__presentflags                 0x00000000

/* --- Cmd_GetSlotInfo_Reply_flags --- */

#define Cmd_GetSlotInfo_Reply_flags_Unformatted                 0x00000001
#define Cmd_GetSlotInfo_Reply_flags_Authenticated               0x00000002
#define Cmd_GetSlotInfo_Reply_flags__reserved                   0xffff0000
#define Cmd_GetSlotInfo_Reply_flags__allflags                   0x00000003
#define Cmd_GetSlotInfo_Reply_flags__presentflags               0x00000000

/* --- Cmd_FirmwareAuthenticate_Reply_flags --- */

#define Cmd_FirmwareAuthenticate_Reply_flags__allflags          0x00000000
#define Cmd_FirmwareAuthenticate_Reply_flags__presentflags      0x00000000

/* --- Cmd_TraceSEEWorld_Reply_flags --- */

#define Cmd_TraceSEEWorld_Reply_flags_Failed                    0x00000001
#define Cmd_TraceSEEWorld_Reply_flags__reserved                 0xffff0000
#define Cmd_TraceSEEWorld_Reply_flags__allflags                 0x00000001
#define Cmd_TraceSEEWorld_Reply_flags__presentflags             0x00000000

/* --- Cmd_GetKeyInfoEx_Reply_flags --- */

#define Cmd_GetKeyInfoEx_Reply_flags__reserved                  0xffff0000
#define Cmd_GetKeyInfoEx_Reply_flags__allflags                  0x00000000
#define Cmd_GetKeyInfoEx_Reply_flags__presentflags              0x00000000

/* --- Cmd_GetKeyInfoEx_Reply versioning --- */

#define Cmd_GetKeyInfoEx_Reply__maxversion                               0

/* --- Cmd_StatGetValues_Reply_flags --- */

#define Cmd_StatGetValues_Reply_flags__reserved                 0xffff0000
#define Cmd_StatGetValues_Reply_flags__allflags                 0x00000000
#define Cmd_StatGetValues_Reply_flags__presentflags             0x00000000

/* --- Cmd_ANModuleChangeEvent_Reply_flags --- */

#define Cmd_ANModuleChangeEvent_Reply_flags_NVKeys              0x01000000
#define Cmd_ANModuleChangeEvent_Reply_flags_NVMem               0x02000000
#define Cmd_ANModuleChangeEvent_Reply_flags_RTC                 0x04000000
#define Cmd_ANModuleChangeEvent_Reply_flags__reserved           0xff000000
#define Cmd_ANModuleChangeEvent_Reply_flags__allflags           0x07000000
#define Cmd_ANModuleChangeEvent_Reply_flags__presentflags       0x00000000

/* --- InfoFormat_HardwareRev1_Info_flags --- */

#define InfoFormat_HardwareRev1_Info_flags_RTCPresent           0x00010000
#define InfoFormat_HardwareRev1_Info_flags_KLFPresent           0x00020000
#define InfoFormat_HardwareRev1_Info_flags__reserved            0xffff0000
#define InfoFormat_HardwareRev1_Info_flags__allflags            0x00030000
#define InfoFormat_HardwareRev1_Info_flags__presentflags        0x00000000

/* --- Cmd_SendShare_Reply_flags --- */

#define Cmd_SendShare_Reply_flags_PINProtected                  0x00000001
#define Cmd_SendShare_Reply_flags__reserved                     0xffff0000
#define Cmd_SendShare_Reply_flags__allflags                     0x00000001
#define Cmd_SendShare_Reply_flags__presentflags                 0x00000000

/* --- Cmd_PollModuleState_Reply_flags --- */

#define Cmd_PollModuleState_Reply_flags__reserved               0xffff0000
#define Cmd_PollModuleState_Reply_flags__allflags               0x00000000
#define Cmd_PollModuleState_Reply_flags__presentflags           0x00000000

/* --- Cmd_PollModuleState_Reply versioning --- */

#define Cmd_PollModuleState_Reply__maxversion                            0

/* --- Cmd_StatEnumTree_Reply_flags --- */

#define Cmd_StatEnumTree_Reply_flags_Privileged                 0x00000001
#define Cmd_StatEnumTree_Reply_flags_Expensive                  0x00000002
#define Cmd_StatEnumTree_Reply_flags_InstanceSubnodes           0x00000004
#define Cmd_StatEnumTree_Reply_flags__reserved                  0xffff0000
#define Cmd_StatEnumTree_Reply_flags__allflags                  0x00000007
#define Cmd_StatEnumTree_Reply_flags__presentflags              0x00000000

/* --- Cmd_GenerateKey_Reply_flags --- */

#define Cmd_GenerateKey_Reply_flags_cert_present                0x00000001
#define Cmd_GenerateKey_Reply_flags__reserved                   0xffff0000
#define Cmd_GenerateKey_Reply_flags__allflags                   0x00000001
#define Cmd_GenerateKey_Reply_flags__presentflags               0x00000001

/* --- Cmd_GenerateKeyPair_Reply_flags --- */

#define Cmd_GenerateKeyPair_Reply_flags_certpriv_present        0x00000001
#define Cmd_GenerateKeyPair_Reply_flags_certpub_present         0x00000002
#define Cmd_GenerateKeyPair_Reply_flags__reserved               0xffff0000
#define Cmd_GenerateKeyPair_Reply_flags__allflags               0x00000003
#define Cmd_GenerateKeyPair_Reply_flags__presentflags           0x00000003

/* --- Cmd_NewClient_Reply_flags --- */

#define Cmd_NewClient_Reply_flags__allflags                     0x00000000
#define Cmd_NewClient_Reply_flags__presentflags                 0x00000000

/* --- Cmd_PauseForNotifications_Reply_flags --- */

#define Cmd_PauseForNotifications_Reply_flags_RequestedDelayTooShort 0x00000001
#define Cmd_PauseForNotifications_Reply_flags_RequestedDelayTooLong 0x00000002
#define Cmd_PauseForNotifications_Reply_flags_AlreadyInProgress 0x00000004
#define Cmd_PauseForNotifications_Reply_flags__reserved         0xffff0000
#define Cmd_PauseForNotifications_Reply_flags__allflags         0x00000007
#define Cmd_PauseForNotifications_Reply_flags__presentflags     0x00000000

/* --- TokenInfo_flags --- */

#define TokenInfo_flags_RequiresPIN                             0x00000001
#define TokenInfo_flags_NewFormat                               0x00010000
#define TokenInfo_flags__reserved                               0xffff0000
#define TokenInfo_flags__allflags                               0x00010001
#define TokenInfo_flags__presentflags                           0x00000000

/* --- StatInfo_flags --- */

#define StatInfo_flags_Counter                                  0x00000001
#define StatInfo_flags_Fraction                                 0x00000002
#define StatInfo_flags_Synchronous                              0x00000004
#define StatInfo_flags_Inexact                                  0x00000008
#define StatInfo_flags__reserved                                0xffffffff
#define StatInfo_flags__allflags                                0x0000000f
#define StatInfo_flags__presentflags                            0x00000000

/* --- ProgSigDatFormat_Two_Data_flags --- */

#define ProgSigDatFormat_Two_Data_flags_Execute                 0x00000001
#define ProgSigDatFormat_Two_Data_flags__reserved               0xffff0000
#define ProgSigDatFormat_Two_Data_flags__allflags               0x00000001
#define ProgSigDatFormat_Two_Data_flags__presentflags           0x00000000

/* --- FirmwareFileInfo_flags --- */

#define FirmwareFileInfo_flags_MonitorImage                     0x00000001
#define FirmwareFileInfo_flags__allflags                        0x00000001
#define FirmwareFileInfo_flags__presentflags                    0x00000000

/* --- SigningKeyEntry_flags --- */

#define SigningKeyEntry_flags_HashValid                         0x00000001
#define SigningKeyEntry_flags__allflags                         0x00000001
#define SigningKeyEntry_flags__presentflags                     0x00000000

/* --- CertSignMessage_flags --- */

#define CertSignMessage_flags_nonce_present                     0x00000001
#define CertSignMessage_flags_acl_present                       0x00000002
#define CertSignMessage_flags__reserved                         0xffff0000
#define CertSignMessage_flags__allflags                         0x00000003
#define CertSignMessage_flags__presentflags                     0x00000003

/* --- ModCertType_KWARv0_ModCertData_flags --- */

#define ModCertType_KWARv0_ModCertData_flags__reserved          0xffff0000
#define ModCertType_KWARv0_ModCertData_flags__allflags          0x00000000
#define ModCertType_KWARv0_ModCertData_flags__presentflags      0x00000000

/* --- ModCertType_StateCert_ModCertData_flags --- */

#define ModCertType_StateCert_ModCertData_flags__reserved       0xffff0000
#define ModCertType_StateCert_ModCertData_flags__allflags       0x00000000
#define ModCertType_StateCert_ModCertData_flags__presentflags   0x00000000

/* --- ModCertType_KeyGen_ModCertData_flags --- */

#define ModCertType_KeyGen_ModCertData_flags_Public             0x00000001
#define ModCertType_KeyGen_ModCertData_flags__reserved          0xffff0000
#define ModCertType_KeyGen_ModCertData_flags__allflags          0x00000001
#define ModCertType_KeyGen_ModCertData_flags__presentflags      0x00000000

/* --- ImpathKXMessage_flags --- */

#define ImpathKXMessage_flags__allflags                         0x00000000
#define ImpathKXMessage_flags__presentflags                     0x00000000

/* --- ImpathMsgType_UserData_Body_flags --- */

#define ImpathMsgType_UserData_Body_flags__reserved             0xffff0000
#define ImpathMsgType_UserData_Body_flags__allflags             0x00000000
#define ImpathMsgType_UserData_Body_flags__presentflags         0x00000000

/* --- ImpathMsgType_Share_Body_flags --- */

#define ImpathMsgType_Share_Body_flags_PINProtected             0x00000001
#define ImpathMsgType_Share_Body_flags__allflags                0x00000001
#define ImpathMsgType_Share_Body_flags__presentflags            0x00000000

/* --- SEEOpType_JavaSEECmdInstantiateObject_SEEArgs_flags --- */

#define SEEOpType_JavaSEECmdInstantiateObject_SEEArgs_flags_Class 0x00000001
#define SEEOpType_JavaSEECmdInstantiateObject_SEEArgs_flags__reserved 0xffff0000
#define SEEOpType_JavaSEECmdInstantiateObject_SEEArgs_flags__allflags 0x00000001
#define SEEOpType_JavaSEECmdInstantiateObject_SEEArgs_flags__presentflags 0x00000000

/* --- SEEOpType_JavaSEECmdDeleteObject_SEEArgs_flags --- */

#define SEEOpType_JavaSEECmdDeleteObject_SEEArgs_flags__reserved 0xffff0000
#define SEEOpType_JavaSEECmdDeleteObject_SEEArgs_flags__allflags 0x00000000
#define SEEOpType_JavaSEECmdDeleteObject_SEEArgs_flags__presentflags 0x00000000

/* --- SEEOpType_JavaSEECmdInvokeMethod_SEEArgs_flags --- */

#define SEEOpType_JavaSEECmdInvokeMethod_SEEArgs_flags__reserved 0xffff0000
#define SEEOpType_JavaSEECmdInvokeMethod_SEEArgs_flags__allflags 0x00000000
#define SEEOpType_JavaSEECmdInvokeMethod_SEEArgs_flags__presentflags 0x00000000

/* --- SEEOpType_JavaSEECmdInstantiateObject_SEERes_flags --- */

#define SEEOpType_JavaSEECmdInstantiateObject_SEERes_flags_exception_present 0x00000001
#define SEEOpType_JavaSEECmdInstantiateObject_SEERes_flags__reserved 0xffff0000
#define SEEOpType_JavaSEECmdInstantiateObject_SEERes_flags__allflags 0x00000001
#define SEEOpType_JavaSEECmdInstantiateObject_SEERes_flags__presentflags 0x00000001

/* --- SEEOpType_JavaSEECmdInvokeMethod_SEERes_flags --- */

#define SEEOpType_JavaSEECmdInvokeMethod_SEERes_flags_exception_present 0x00000001
#define SEEOpType_JavaSEECmdInvokeMethod_SEERes_flags__reserved 0xffff0000
#define SEEOpType_JavaSEECmdInvokeMethod_SEERes_flags__allflags 0x00000001
#define SEEOpType_JavaSEECmdInvokeMethod_SEERes_flags__presentflags 0x00000001

/* --- TicketInfo_flags --- */

#define TicketInfo_flags_hclientid_present                      0x00000001
#define TicketInfo_flags_destspace_present                      0x00000002
#define TicketInfo_flags_challenge_present                      0x00000004
#define TicketInfo_flags_AllowClient                            0x00000008
#define TicketInfo_flags_AllowSEEWorld                          0x00000010
#define TicketInfo_flags__allflags                              0x0000001f
#define TicketInfo_flags__presentflags                          0x00000007

/*----- That's all, folks -------------------------------------------------*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nfast\inc\messages-a-im.h ===
/* -*-c-*-
 *
 * Generated by Marshmallow at 2003-04-16T17:14:00
 */

#ifndef MESSAGES_A_IM_H
#define MESSAGES_A_IM_H

/* --- Octet array Hash --- */

typedef union M_Hash {
  unsigned char bytes[20];
  M_Word words[5];
} M_Hash;

/* --- Union Status__ErrorInfo --- */

typedef union M_Status__ErrorInfo M_Status__ErrorInfo;

/* --- Structure Status_nCErrno_ErrorInfo --- */

typedef struct M_Status_nCErrno_ErrorInfo M_Status_nCErrno_ErrorInfo;

/* --- Structure Status_nCErrno_ErrorInfo --- */

struct M_Status_nCErrno_ErrorInfo {
  M_nCErrno err;
  M_ASCIIString strerr;
};

/* --- Structure Status_RemoteServerFailed_ErrorInfo --- */

typedef struct M_Status_RemoteServerFailed_ErrorInfo M_Status_RemoteServerFailed_ErrorInfo;

/* --- Flags word Status_RemoteServerFailed_ErrorInfo_flags --- */

typedef M_Word M_Status_RemoteServerFailed_ErrorInfo_flags;

/* --- Structure StatusErrorInfo --- */

typedef struct M_StatusErrorInfo M_StatusErrorInfo;

/* --- Optional opt_StatusErrorInfo --- */

typedef M_StatusErrorInfo *M_opt_StatusErrorInfo;

/* --- Structure NetworkAddress --- */

typedef struct M_NetworkAddress M_NetworkAddress;

/* --- Structure Status_RemoteServerFailed_ErrorInfo --- */

struct M_Status_RemoteServerFailed_ErrorInfo {
  M_Status_RemoteServerFailed_ErrorInfo_flags flags;
  M_opt_StatusErrorInfo stinfo;
  M_NetworkAddress *addr;
};

/* --- Structure Status_SlotUnconnected_ErrorInfo --- */

typedef struct M_Status_SlotUnconnected_ErrorInfo M_Status_SlotUnconnected_ErrorInfo;

/* --- Structure Status_SlotUnconnected_ErrorInfo --- */

struct M_Status_SlotUnconnected_ErrorInfo {
  M_opt_StatusErrorInfo stinfo;
};

/* --- Structure Status_CrossModule_ErrorInfo --- */

typedef struct M_Status_CrossModule_ErrorInfo M_Status_CrossModule_ErrorInfo;

/* --- Structure CrossModuleReason --- */

typedef struct M_CrossModuleReason M_CrossModuleReason;

/* --- Vector vec_CrossModuleReason --- */

typedef M_CrossModuleReason *M_vec_CrossModuleReason;

/* --- Structure Status_CrossModule_ErrorInfo --- */

struct M_Status_CrossModule_ErrorInfo {
  int n_reasons;
  M_vec_CrossModuleReason reasons;
};

/* --- Structure Status_AttemptedDowngrade_ErrorInfo --- */

typedef struct M_Status_AttemptedDowngrade_ErrorInfo M_Status_AttemptedDowngrade_ErrorInfo;

/* --- Structure Status_AttemptedDowngrade_ErrorInfo --- */

struct M_Status_AttemptedDowngrade_ErrorInfo {
  M_Word oldvsn;
  M_Word newvsn;
};

/* --- Structure Status_UnknownKeyHash_ErrorInfo --- */

typedef struct M_Status_UnknownKeyHash_ErrorInfo M_Status_UnknownKeyHash_ErrorInfo;

/* --- Synonym KeyHash --- */

typedef M_Hash M_KeyHash;

/* --- Structure Status_UnknownKeyHash_ErrorInfo --- */

struct M_Status_UnknownKeyHash_ErrorInfo {
  M_KeyHash hk;
};

/* --- Union Status__ErrorInfo --- */

union M_Status__ErrorInfo {
  M_Status_nCErrno_ErrorInfo ncerrno;
  M_Status_RemoteServerFailed_ErrorInfo remoteserverfailed;
  M_Status_SlotUnconnected_ErrorInfo slotunconnected;
  M_Status_CrossModule_ErrorInfo crossmodule;
  M_Status_AttemptedDowngrade_ErrorInfo attempteddowngrade;
  M_Status_UnknownKeyHash_ErrorInfo unknownkeyhash;
};

/* --- Structure StatusErrorInfo --- */

struct M_StatusErrorInfo {
  M_Status st;
  union M_Status__ErrorInfo einfo;
};

/* --- Union NetworkAddressFamily__Value --- */

typedef union M_NetworkAddressFamily__Value M_NetworkAddressFamily__Value;

/* --- Structure NetworkAddressFamily_INET_Value --- */

typedef struct M_NetworkAddressFamily_INET_Value M_NetworkAddressFamily_INET_Value;

/* --- Octet array IPv4Address --- */

typedef union M_IPv4Address {
  unsigned char bytes[4];
  M_Word words[1];
} M_IPv4Address;

/* --- Structure NetworkAddressFamily_INET_Value --- */

struct M_NetworkAddressFamily_INET_Value {
  M_IPv4Address addr;
  M_Word port;
};

/* --- Structure NetworkAddressFamily_INET6_Value --- */

typedef struct M_NetworkAddressFamily_INET6_Value M_NetworkAddressFamily_INET6_Value;

/* --- Octet array IPv6Address --- */

typedef union M_IPv6Address {
  unsigned char bytes[16];
  M_Word words[4];
} M_IPv6Address;

/* --- Structure NetworkAddressFamily_INET6_Value --- */

struct M_NetworkAddressFamily_INET6_Value {
  M_IPv6Address addr;
  M_Word port;
};

/* --- Union NetworkAddressFamily__Value --- */

union M_NetworkAddressFamily__Value {
  M_NetworkAddressFamily_INET_Value inet;
  M_NetworkAddressFamily_INET6_Value inet6;
};

/* --- Structure NetworkAddress --- */

struct M_NetworkAddress {
  M_NetworkAddressFamily af;
  union M_NetworkAddressFamily__Value addr;
};

/* --- Union CrossModReason__Info --- */

typedef union M_CrossModReason__Info M_CrossModReason__Info;

/* --- Structure CrossModReason_Key_Info --- */

typedef struct M_CrossModReason_Key_Info M_CrossModReason_Key_Info;

/* --- Structure CrossModReason_Key_Info --- */

struct M_CrossModReason_Key_Info {
  M_KeyID key;
};

/* --- Union CrossModReason__Info --- */

union M_CrossModReason__Info {
  M_CrossModReason_Key_Info key;
};

/* --- Structure CrossModuleReason --- */

struct M_CrossModuleReason {
  M_CrossModReason type;
  union M_CrossModReason__Info info;
};

/* --- Synonym ClientID --- */

typedef M_Hash M_ClientID;

/* --- Synonym LimitID --- */

typedef M_Hash M_LimitID;

/* --- Synonym TokenHash --- */

typedef M_Hash M_TokenHash;

/* --- Synonym KMHash --- */

typedef M_Hash M_KMHash;

/* --- Structure PhysToken --- */

typedef struct M_PhysToken M_PhysToken;

/* --- Structure PhysToken --- */

struct M_PhysToken {
  M_ModuleID module;
  M_SlotID slot;
  M_Word ic;
};

/* --- Union SlotType__SlotExData --- */

typedef union M_SlotType__SlotExData M_SlotType__SlotExData;

/* --- Structure SlotType_Unconnected_SlotExData --- */

typedef struct M_SlotType_Unconnected_SlotExData M_SlotType_Unconnected_SlotExData;

/* --- Structure SlotType_Unconnected_SlotExData --- */

struct M_SlotType_Unconnected_SlotExData {
  M_StatusErrorInfo stinfo;
};

/* --- Union SlotType__SlotExData --- */

union M_SlotType__SlotExData {
  M_SlotType_Unconnected_SlotExData unconnected;
};

/* --- Structure ClientChannelOpenInfo --- */

typedef struct M_ClientChannelOpenInfo M_ClientChannelOpenInfo;

/* --- Union ChannelType__ExtraCCOI --- */

typedef union M_ChannelType__ExtraCCOI M_ChannelType__ExtraCCOI;

/* --- Structure ChannelType_DriverDirect_ExtraCCOI --- */

typedef struct M_ChannelType_DriverDirect_ExtraCCOI M_ChannelType_DriverDirect_ExtraCCOI;

/* --- Octet array ModuleChannelID --- */

typedef union M_ModuleChannelID {
  unsigned char bytes[24];
  M_Word words[6];
} M_ModuleChannelID;

/* --- Structure ChannelType_DriverDirect_ExtraCCOI --- */

struct M_ChannelType_DriverDirect_ExtraCCOI {
  M_ModuleChannelID mcid;
  M_ASCIIString drivername;
};

/* --- Union ChannelType__ExtraCCOI --- */

union M_ChannelType__ExtraCCOI {
  M_ChannelType_DriverDirect_ExtraCCOI driverdirect;
};

/* --- Structure ClientChannelOpenInfo --- */

struct M_ClientChannelOpenInfo {
  M_ChannelType type;
  union M_ChannelType__ExtraCCOI info;
};

/* --- Synonym ChannelOpenInfo --- */

typedef M_ClientChannelOpenInfo M_ChannelOpenInfo;

/* --- Structure Certificate --- */

typedef struct M_Certificate M_Certificate;

/* --- Union CertType__CertBody --- */

typedef union M_CertType__CertBody M_CertType__CertBody;

/* --- Structure CertType_SingleCert_CertBody --- */

typedef struct M_CertType_SingleCert_CertBody M_CertType_SingleCert_CertBody;

/* --- Structure KeyData --- */

typedef struct M_KeyData M_KeyData;

/* --- Union KeyType__Data --- */

typedef union M_KeyType__Data M_KeyType__Data;

/* --- Structure KeyType_DES3_Data --- */

typedef struct M_KeyType_DES3_Data M_KeyType_DES3_Data;

/* --- Octet array DES3Key --- */

typedef union M_DES3Key {
  unsigned char bytes[24];
  M_Word words[6];
} M_DES3Key;

/* --- Structure KeyType_DES3_Data --- */

struct M_KeyType_DES3_Data {
  M_DES3Key k;
};

/* --- Structure KeyType_RSAPublic_Data --- */

typedef struct M_KeyType_RSAPublic_Data M_KeyType_RSAPublic_Data;

/* --- Structure KeyType_RSAPublic_Data --- */

struct M_KeyType_RSAPublic_Data {
  M_Bignum e;
  M_Bignum n;
};

/* --- Structure KeyType_DSAPublic_Data --- */

typedef struct M_KeyType_DSAPublic_Data M_KeyType_DSAPublic_Data;

/* --- Structure DSADiscreteLogGroup --- */

typedef struct M_DSADiscreteLogGroup M_DSADiscreteLogGroup;

/* --- Structure DSADiscreteLogGroup --- */

struct M_DSADiscreteLogGroup {
  M_Bignum p;
  M_Bignum q;
  M_Bignum g;
};

/* --- Structure KeyType_DSAPublic_Data --- */

struct M_KeyType_DSAPublic_Data {
  M_DSADiscreteLogGroup dlg;
  M_Bignum y;
};

/* --- Structure KeyType_DSAPrivate_Data --- */

typedef struct M_KeyType_DSAPrivate_Data M_KeyType_DSAPrivate_Data;

/* --- Structure KeyType_DSAPrivate_Data --- */

struct M_KeyType_DSAPrivate_Data {
  M_DSADiscreteLogGroup dlg;
  M_Bignum x;
};

/* --- Structure KeyType_DKTemplate_Data --- */

typedef struct M_KeyType_DKTemplate_Data M_KeyType_DKTemplate_Data;

/* --- Structure KeyType_DKTemplate_Data --- */

struct M_KeyType_DKTemplate_Data {
  M_ByteBlock appdata;
  M_ByteBlock nested_acl;
};

/* --- Structure KeyType_DES_Data --- */

typedef struct M_KeyType_DES_Data M_KeyType_DES_Data;

/* --- Octet array DESKey --- */

typedef union M_DESKey {
  unsigned char bytes[8];
  M_Word words[2];
} M_DESKey;

/* --- Structure KeyType_DES_Data --- */

struct M_KeyType_DES_Data {
  M_DESKey k;
};

/* --- Structure KeyType_DHPrivate_Data --- */

typedef struct M_KeyType_DHPrivate_Data M_KeyType_DHPrivate_Data;

/* --- Structure DiscreteLogGroup --- */

typedef struct M_DiscreteLogGroup M_DiscreteLogGroup;

/* --- Structure DiscreteLogGroup --- */

struct M_DiscreteLogGroup {
  M_Bignum p;
  M_Bignum g;
};

/* --- Structure KeyType_DHPrivate_Data --- */

struct M_KeyType_DHPrivate_Data {
  M_DiscreteLogGroup dlg;
  M_Bignum x;
};

/* --- Structure KeyType_KCDSAPrivate_Data --- */

typedef struct M_KeyType_KCDSAPrivate_Data M_KeyType_KCDSAPrivate_Data;

/* --- Synonym KCDSADiscreteLogGroup --- */

typedef M_DSADiscreteLogGroup M_KCDSADiscreteLogGroup;

/* --- Structure KeyType_KCDSAPrivate_Data --- */

struct M_KeyType_KCDSAPrivate_Data {
  M_KCDSADiscreteLogGroup dlg;
  M_Bignum y;
  M_Bignum x;
};

/* --- Structure KeyType_RC2_Data --- */

typedef struct M_KeyType_RC2_Data M_KeyType_RC2_Data;

/* --- Structure KeyType_RC2_Data --- */

struct M_KeyType_RC2_Data {
  M_Word kbits;
  M_ByteBlock k;
};

/* --- Structure KeyType_RSAPrivate_Data --- */

typedef struct M_KeyType_RSAPrivate_Data M_KeyType_RSAPrivate_Data;

/* --- Structure KeyType_RSAPrivate_Data --- */

struct M_KeyType_RSAPrivate_Data {
  M_Bignum p;
  M_Bignum q;
  M_Bignum dmp1;
  M_Bignum dmq1;
  M_Bignum iqmp;
  M_Bignum e;
};

/* --- Structure KeyType_RC5_Data --- */

typedef struct M_KeyType_RC5_Data M_KeyType_RC5_Data;

/* --- Structure KeyType_RC5_Data --- */

struct M_KeyType_RC5_Data {
  M_Word rounds;
  M_ByteBlock k;
};

/* --- Structure KeyType_SSLMasterSecret_Data --- */

typedef struct M_KeyType_SSLMasterSecret_Data M_KeyType_SSLMasterSecret_Data;

/* --- Octet array SSLMasterSecret --- */

typedef union M_SSLMasterSecret {
  unsigned char bytes[48];
  M_Word words[12];
} M_SSLMasterSecret;

/* --- Structure KeyType_SSLMasterSecret_Data --- */

struct M_KeyType_SSLMasterSecret_Data {
  M_SSLMasterSecret secret;
};

/* --- Structure KeyType_KCDSAPublic_Data --- */

typedef struct M_KeyType_KCDSAPublic_Data M_KeyType_KCDSAPublic_Data;

/* --- Structure KeyType_KCDSAPublic_Data --- */

struct M_KeyType_KCDSAPublic_Data {
  M_KCDSADiscreteLogGroup dlg;
  M_Bignum y;
};

/* --- Structure KeyType_KCDSAComm_Data --- */

typedef struct M_KeyType_KCDSAComm_Data M_KeyType_KCDSAComm_Data;

/* --- Structure KCDSAInitValues --- */

typedef struct M_KCDSAInitValues M_KCDSAInitValues;

/* --- Structure KCDSAInitValues --- */

struct M_KCDSAInitValues {
  M_ByteBlock seed;
  M_Word counter;
};

/* --- Structure KeyType_KCDSAComm_Data --- */

struct M_KeyType_KCDSAComm_Data {
  M_KCDSAInitValues iv;
  M_KCDSADiscreteLogGroup dlg;
};

/* --- Structure KeyType_DSAComm_Data --- */

typedef struct M_KeyType_DSAComm_Data M_KeyType_DSAComm_Data;

/* --- Structure DSAInitValues --- */

typedef struct M_DSAInitValues M_DSAInitValues;

/* --- Structure DSAInitValues --- */

struct M_DSAInitValues {
  M_Hash seed;
  M_Word counter;
  M_Word h;
};

/* --- Structure KeyType_DSAComm_Data --- */

struct M_KeyType_DSAComm_Data {
  M_DSAInitValues iv;
  M_DSADiscreteLogGroup dlg;
};

/* --- Structure KeyType_Random_Data --- */

typedef struct M_KeyType_Random_Data M_KeyType_Random_Data;

/* --- Structure KeyType_Random_Data --- */

struct M_KeyType_Random_Data {
  M_ByteBlock k;
};

/* --- Structure KeyType_DHPublic_Data --- */

typedef struct M_KeyType_DHPublic_Data M_KeyType_DHPublic_Data;

/* --- Structure KeyType_DHPublic_Data --- */

struct M_KeyType_DHPublic_Data {
  M_DiscreteLogGroup dlg;
  M_Bignum gx;
};

/* --- Structure KeyType_DES2_Data --- */

typedef struct M_KeyType_DES2_Data M_KeyType_DES2_Data;

/* --- Octet array DES2Key --- */

typedef union M_DES2Key {
  unsigned char bytes[16];
  M_Word words[4];
} M_DES2Key;

/* --- Structure KeyType_DES2_Data --- */

struct M_KeyType_DES2_Data {
  M_DES2Key k;
};

/* --- Union KeyType__Data --- */

union M_KeyType__Data {
  M_KeyType_DES3_Data des3;
  M_KeyType_RSAPublic_Data rsapublic;
  M_KeyType_DSAPublic_Data dsapublic;
  M_KeyType_DSAPrivate_Data dsaprivate;
  M_KeyType_DKTemplate_Data dktemplate;
  M_KeyType_DES_Data des;
  M_KeyType_DHPrivate_Data dhprivate;
  M_KeyType_KCDSAPrivate_Data kcdsaprivate;
  M_KeyType_RC2_Data rc2;
  M_KeyType_RSAPrivate_Data rsaprivate;
  M_KeyType_RC5_Data rc5;
  M_KeyType_SSLMasterSecret_Data sslmastersecret;
  M_KeyType_KCDSAPublic_Data kcdsapublic;
  M_KeyType_KCDSAComm_Data kcdsacomm;
  M_KeyType_DSAComm_Data dsacomm;
  M_KeyType_Random_Data random;
  M_KeyType_DHPublic_Data dhpublic;
  M_KeyType_DES2_Data des2;
};

/* --- Structure KeyData --- */

struct M_KeyData {
  M_KeyType type;
  union M_KeyType__Data data;
};

/* --- Structure CipherText --- */

typedef struct M_CipherText M_CipherText;

/* --- Union Mech__Cipher --- */

typedef union M_Mech__Cipher M_Mech__Cipher;

/* --- Structure Mech_HAS160Hash_Cipher --- */

typedef struct M_Mech_HAS160Hash_Cipher M_Mech_HAS160Hash_Cipher;

/* --- Synonym Hash20 --- */

typedef M_Hash M_Hash20;

/* --- Structure Mech_HAS160Hash_Cipher --- */

struct M_Mech_HAS160Hash_Cipher {
  M_Hash20 h;
};

/* --- Structure Mech_Generic64_Cipher --- */

typedef struct M_Mech_Generic64_Cipher M_Mech_Generic64_Cipher;

/* --- Structure Mech_Generic64_Cipher --- */

struct M_Mech_Generic64_Cipher {
  M_ByteBlock cipher;
};

/* --- Structure Mech_Generic64MAC_Cipher --- */

typedef struct M_Mech_Generic64MAC_Cipher M_Mech_Generic64MAC_Cipher;

/* --- Octet array Block64 --- */

typedef union M_Block64 {
  unsigned char bytes[8];
  M_Word words[2];
} M_Block64;

/* --- Structure Mech_Generic64MAC_Cipher --- */

struct M_Mech_Generic64MAC_Cipher {
  M_Block64 mac;
};

/* --- Structure Mech_SHA1Hash_Cipher --- */

typedef struct M_Mech_SHA1Hash_Cipher M_Mech_SHA1Hash_Cipher;

/* --- Structure Mech_SHA1Hash_Cipher --- */

struct M_Mech_SHA1Hash_Cipher {
  M_Hash20 h;
};

/* --- Structure Mech_ArcFourpNONE_Cipher --- */

typedef struct M_Mech_ArcFourpNONE_Cipher M_Mech_ArcFourpNONE_Cipher;

/* --- Structure Mech_ArcFourpNONE_Cipher --- */

struct M_Mech_ArcFourpNONE_Cipher {
  M_ByteBlock cipher;
};

/* --- Structure Mech_TLSFinishedMsg_Cipher --- */

typedef struct M_Mech_TLSFinishedMsg_Cipher M_Mech_TLSFinishedMsg_Cipher;

/* --- Octet array Hash12 --- */

typedef union M_Hash12 {
  unsigned char bytes[12];
  M_Word words[3];
} M_Hash12;

/* --- Structure Mech_TLSFinishedMsg_Cipher --- */

struct M_Mech_TLSFinishedMsg_Cipher {
  M_Hash12 msg;
};

/* --- Structure Mech_DSA_Cipher --- */

typedef struct M_Mech_DSA_Cipher M_Mech_DSA_Cipher;

/* --- Structure Mech_DSA_Cipher --- */

struct M_Mech_DSA_Cipher {
  M_Bignum r;
  M_Bignum s;
};

/* --- Structure Mech_Generic256MAC_Cipher --- */

typedef struct M_Mech_Generic256MAC_Cipher M_Mech_Generic256MAC_Cipher;

/* --- Octet array Block256 --- */

typedef union M_Block256 {
  unsigned char bytes[32];
  M_Word words[8];
} M_Block256;

/* --- Structure Mech_Generic256MAC_Cipher --- */

struct M_Mech_Generic256MAC_Cipher {
  M_Block256 mac;
};

/* --- Structure Mech_RSApSETOAEP_Cipher --- */

typedef struct M_Mech_RSApSETOAEP_Cipher M_Mech_RSApSETOAEP_Cipher;

/* --- Structure Mech_RSApSETOAEP_Cipher --- */

struct M_Mech_RSApSETOAEP_Cipher {
  M_Bignum m;
};

/* --- Structure Mech_SHA512Hash_Cipher --- */

typedef struct M_Mech_SHA512Hash_Cipher M_Mech_SHA512Hash_Cipher;

/* --- Octet array Hash64 --- */

typedef union M_Hash64 {
  unsigned char bytes[64];
  M_Word words[16];
} M_Hash64;

/* --- Structure Mech_SHA512Hash_Cipher --- */

struct M_Mech_SHA512Hash_Cipher {
  M_Hash64 h;
};

/* --- Structure Mech_SHA384Hash_Cipher --- */

typedef struct M_Mech_SHA384Hash_Cipher M_Mech_SHA384Hash_Cipher;

/* --- Octet array Hash48 --- */

typedef union M_Hash48 {
  unsigned char bytes[48];
  M_Word words[12];
} M_Hash48;

/* --- Structure Mech_SHA384Hash_Cipher --- */

struct M_Mech_SHA384Hash_Cipher {
  M_Hash48 h;
};

/* --- Structure Mech_MD2Hash_Cipher --- */

typedef struct M_Mech_MD2Hash_Cipher M_Mech_MD2Hash_Cipher;

/* --- Octet array Hash16 --- */

typedef union M_Hash16 {
  unsigned char bytes[16];
  M_Word words[4];
} M_Hash16;

/* --- Structure Mech_MD2Hash_Cipher --- */

struct M_Mech_MD2Hash_Cipher {
  M_Hash16 h;
};

/* --- Structure Mech_RSApPKCS1_Cipher --- */

typedef struct M_Mech_RSApPKCS1_Cipher M_Mech_RSApPKCS1_Cipher;

/* --- Structure Mech_RSApPKCS1_Cipher --- */

struct M_Mech_RSApPKCS1_Cipher {
  M_Bignum m;
};

/* --- Structure Mech_DLIESe3DEShSHA1_Cipher --- */

typedef struct M_Mech_DLIESe3DEShSHA1_Cipher M_Mech_DLIESe3DEShSHA1_Cipher;

/* --- Structure Mech_DLIESe3DEShSHA1_Cipher --- */

struct M_Mech_DLIESe3DEShSHA1_Cipher {
  M_ByteBlock cipher;
};

/* --- Structure Mech_Generic192MAC_Cipher --- */

typedef struct M_Mech_Generic192MAC_Cipher M_Mech_Generic192MAC_Cipher;

/* --- Octet array Block192 --- */

typedef union M_Block192 {
  unsigned char bytes[24];
  M_Word words[6];
} M_Block192;

/* --- Structure Mech_Generic192MAC_Cipher --- */

struct M_Mech_Generic192MAC_Cipher {
  M_Block192 mac;
};

/* --- Structure Mech_Generic256_Cipher --- */

typedef struct M_Mech_Generic256_Cipher M_Mech_Generic256_Cipher;

/* --- Structure Mech_Generic256_Cipher --- */

struct M_Mech_Generic256_Cipher {
  M_ByteBlock cipher;
};

/* --- Structure Mech_SSLRecordLayer_Cipher --- */

typedef struct M_Mech_SSLRecordLayer_Cipher M_Mech_SSLRecordLayer_Cipher;

/* --- Structure Mech_SSLRecordLayer_Cipher --- */

struct M_Mech_SSLRecordLayer_Cipher {
  M_ByteBlock records;
};

/* --- Structure Mech_RIPEMD160Hash_Cipher --- */

typedef struct M_Mech_RIPEMD160Hash_Cipher M_Mech_RIPEMD160Hash_Cipher;

/* --- Structure Mech_RIPEMD160Hash_Cipher --- */

struct M_Mech_RIPEMD160Hash_Cipher {
  M_Hash20 h;
};

/* --- Structure Mech_Imech_Cipher --- */

typedef struct M_Mech_Imech_Cipher M_Mech_Imech_Cipher;

/* --- Structure Mech_Imech_Cipher --- */

struct M_Mech_Imech_Cipher {
  M_ByteBlock c;
  M_Word len;
};

/* --- Structure Mech_TigerHash_Cipher --- */

typedef struct M_Mech_TigerHash_Cipher M_Mech_TigerHash_Cipher;

/* --- Octet array Hash24 --- */

typedef union M_Hash24 {
  unsigned char bytes[24];
  M_Word words[6];
} M_Hash24;

/* --- Structure Mech_TigerHash_Cipher --- */

struct M_Mech_TigerHash_Cipher {
  M_Hash24 h;
};

/* --- Structure Mech_Generic192_Cipher --- */

typedef struct M_Mech_Generic192_Cipher M_Mech_Generic192_Cipher;

/* --- Structure Mech_Generic192_Cipher --- */

struct M_Mech_Generic192_Cipher {
  M_ByteBlock cipher;
};

/* --- Structure Mech_SHA256Hash_Cipher --- */

typedef struct M_Mech_SHA256Hash_Cipher M_Mech_SHA256Hash_Cipher;

/* --- Octet array Hash32 --- */

typedef union M_Hash32 {
  unsigned char bytes[32];
  M_Word words[8];
} M_Hash32;

/* --- Structure Mech_SHA256Hash_Cipher --- */

struct M_Mech_SHA256Hash_Cipher {
  M_Hash32 h;
};

/* --- Structure Mech_KCDSAHAS160_Cipher --- */

typedef struct M_Mech_KCDSAHAS160_Cipher M_Mech_KCDSAHAS160_Cipher;

/* --- Structure Mech_KCDSAHAS160_Cipher --- */

struct M_Mech_KCDSAHAS160_Cipher {
  M_ByteBlock r;
  M_Bignum s;
};

/* --- Structure Mech_SSL3FinishedMsg_Cipher --- */

typedef struct M_Mech_SSL3FinishedMsg_Cipher M_Mech_SSL3FinishedMsg_Cipher;

/* --- Structure Mech_SSL3FinishedMsg_Cipher --- */

struct M_Mech_SSL3FinishedMsg_Cipher {
  M_Hash16 md5hash;
  M_Hash20 sha1hash;
};

/* --- Structure Mech_RSApPKCS1pPKCS11_Cipher --- */

typedef struct M_Mech_RSApPKCS1pPKCS11_Cipher M_Mech_RSApPKCS1pPKCS11_Cipher;

/* --- Structure Mech_RSApPKCS1pPKCS11_Cipher --- */

struct M_Mech_RSApPKCS1pPKCS11_Cipher {
  M_ByteBlock cipher;
};

/* --- Structure Mech_Generic128MAC_Cipher --- */

typedef struct M_Mech_Generic128MAC_Cipher M_Mech_Generic128MAC_Cipher;

/* --- Octet array Block128 --- */

typedef union M_Block128 {
  unsigned char bytes[16];
  M_Word words[4];
} M_Block128;

/* --- Structure Mech_Generic128MAC_Cipher --- */

struct M_Mech_Generic128MAC_Cipher {
  M_Block128 mac;
};

/* --- Structure Mech_DHKeyExchange_Cipher --- */

typedef struct M_Mech_DHKeyExchange_Cipher M_Mech_DHKeyExchange_Cipher;

/* --- Structure Mech_DHKeyExchange_Cipher --- */

struct M_Mech_DHKeyExchange_Cipher {
  M_Bignum gx;
};

/* --- Structure Mech_Generic128_Cipher --- */

typedef struct M_Mech_Generic128_Cipher M_Mech_Generic128_Cipher;

/* --- Structure Mech_Generic128_Cipher --- */

struct M_Mech_Generic128_Cipher {
  M_ByteBlock cipher;
};

/* --- Structure Mech_ElGamal_Cipher --- */

typedef struct M_Mech_ElGamal_Cipher M_Mech_ElGamal_Cipher;

/* --- Structure Mech_ElGamal_Cipher --- */

struct M_Mech_ElGamal_Cipher {
  M_Bignum a;
  M_Bignum b;
};

/* --- Structure Mech_MD5Hash_Cipher --- */

typedef struct M_Mech_MD5Hash_Cipher M_Mech_MD5Hash_Cipher;

/* --- Structure Mech_MD5Hash_Cipher --- */

struct M_Mech_MD5Hash_Cipher {
  M_Hash16 h;
};

/* --- Union Mech__Cipher --- */

union M_Mech__Cipher {
  M_Mech_HAS160Hash_Cipher has160hash;
  M_Mech_Generic64_Cipher generic64;
  M_Mech_Generic64MAC_Cipher generic64mac;
  M_Mech_SHA1Hash_Cipher sha1hash;
  M_Mech_ArcFourpNONE_Cipher arcfourpnone;
  M_Mech_TLSFinishedMsg_Cipher tlsfinishedmsg;
  M_Mech_DSA_Cipher dsa;
  M_Mech_Generic256MAC_Cipher generic256mac;
  M_Mech_RSApSETOAEP_Cipher rsapsetoaep;
  M_Mech_SHA512Hash_Cipher sha512hash;
  M_Mech_SHA384Hash_Cipher sha384hash;
  M_Mech_MD2Hash_Cipher md2hash;
  M_Mech_RSApPKCS1_Cipher rsappkcs1;
  M_Mech_DLIESe3DEShSHA1_Cipher dliese3deshsha1;
  M_Mech_Generic192MAC_Cipher generic192mac;
  M_Mech_Generic256_Cipher generic256;
  M_Mech_SSLRecordLayer_Cipher sslrecordlayer;
  M_Mech_RIPEMD160Hash_Cipher ripemd160hash;
  M_Mech_Imech_Cipher imech;
  M_Mech_TigerHash_Cipher tigerhash;
  M_Mech_Generic192_Cipher generic192;
  M_Mech_SHA256Hash_Cipher sha256hash;
  M_Mech_KCDSAHAS160_Cipher kcdsahas160;
  M_Mech_SSL3FinishedMsg_Cipher ssl3finishedmsg;
  M_Mech_RSApPKCS1pPKCS11_Cipher rsappkcs1ppkcs11;
  M_Mech_Generic128MAC_Cipher generic128mac;
  M_Mech_DHKeyExchange_Cipher dhkeyexchange;
  M_Mech_Generic128_Cipher generic128;
  M_Mech_ElGamal_Cipher elgamal;
  M_Mech_MD5Hash_Cipher md5hash;
};

/* --- Union Mech__IV --- */

typedef union M_Mech__IV M_Mech__IV;

/* --- Structure Mech_Generic64_IV --- */

typedef struct M_Mech_Generic64_IV M_Mech_Generic64_IV;

/* --- Structure Mech_Generic64_IV --- */

struct M_Mech_Generic64_IV {
  M_Block64 iv;
};

/* --- Structure Mech_Generic64MAC_IV --- */

typedef struct M_Mech_Generic64MAC_IV M_Mech_Generic64MAC_IV;

/* --- Structure Mech_Generic64MAC_IV --- */

struct M_Mech_Generic64MAC_IV {
  M_Block64 iv;
};

/* --- Structure Mech_Generic256MAC_IV --- */

typedef struct M_Mech_Generic256MAC_IV M_Mech_Generic256MAC_IV;

/* --- Structure Mech_Generic256MAC_IV --- */

struct M_Mech_Generic256MAC_IV {
  M_Block256 iv;
};

/* --- Structure Mech_RSApPKCS1OAEP_IV --- */

typedef struct M_Mech_RSApPKCS1OAEP_IV M_Mech_RSApPKCS1OAEP_IV;

/* --- Structure Mech_RSApPKCS1OAEP_IV --- */

struct M_Mech_RSApPKCS1OAEP_IV {
  M_ByteBlock p;
};

/* --- Structure Mech_Generic192MAC_IV --- */

typedef struct M_Mech_Generic192MAC_IV M_Mech_Generic192MAC_IV;

/* --- Structure Mech_Generic192MAC_IV --- */

struct M_Mech_Generic192MAC_IV {
  M_Block192 iv;
};

/* --- Structure Mech_Generic256_IV --- */

typedef struct M_Mech_Generic256_IV M_Mech_Generic256_IV;

/* --- Structure Mech_Generic256_IV --- */

struct M_Mech_Generic256_IV {
  M_Block256 iv;
};

/* --- Structure Mech_SSLRecordLayer_IV --- */

typedef struct M_Mech_SSLRecordLayer_IV M_Mech_SSLRecordLayer_IV;

/* --- Flags word Mech_SSLRecordLayer_IV_flags --- */

typedef M_Word M_Mech_SSLRecordLayer_IV_flags;

/* --- Octet array SSLClientRandom --- */

typedef union M_SSLClientRandom {
  unsigned char bytes[32];
  M_Word words[8];
} M_SSLClientRandom;

/* --- Octet array SSLServerRandom --- */

typedef union M_SSLServerRandom {
  unsigned char bytes[32];
  M_Word words[8];
} M_SSLServerRandom;

/* --- Structure Mech_SSLRecordLayer_IV --- */

struct M_Mech_SSLRecordLayer_IV {
  M_Mech_SSLRecordLayer_IV_flags flags;
  M_SSLClientRandom crnd;
  M_SSLServerRandom srnd;
  M_SSLCipherSuite algs;
};

/* --- Structure Mech_Generic192_IV --- */

typedef struct M_Mech_Generic192_IV M_Mech_Generic192_IV;

/* --- Structure Mech_Generic192_IV --- */

struct M_Mech_Generic192_IV {
  M_Block192 iv;
};

/* --- Structure Mech_Generic128MAC_IV --- */

typedef struct M_Mech_Generic128MAC_IV M_Mech_Generic128MAC_IV;

/* --- Structure Mech_Generic128MAC_IV --- */

struct M_Mech_Generic128MAC_IV {
  M_Block128 iv;
};

/* --- Structure Mech_Generic128_IV --- */

typedef struct M_Mech_Generic128_IV M_Mech_Generic128_IV;

/* --- Structure Mech_Generic128_IV --- */

struct M_Mech_Generic128_IV {
  M_Block128 iv;
};

/* --- Union Mech__IV --- */

union M_Mech__IV {
  M_Mech_Generic64_IV generic64;
  M_Mech_Generic64MAC_IV generic64mac;
  M_Mech_Generic256MAC_IV generic256mac;
  M_Mech_RSApPKCS1OAEP_IV rsappkcs1oaep;
  M_Mech_Generic192MAC_IV generic192mac;
  M_Mech_Generic256_IV generic256;
  M_Mech_SSLRecordLayer_IV sslrecordlayer;
  M_Mech_Generic192_IV generic192;
  M_Mech_Generic128MAC_IV generic128mac;
  M_Mech_Generic128_IV generic128;
};

/* --- Structure CipherText --- */

struct M_CipherText {
  M_Mech mech;
  union M_Mech__Cipher data;
  union M_Mech__IV iv;
};

/* --- Structure CertType_SingleCert_CertBody --- */

struct M_CertType_SingleCert_CertBody {
  M_KeyData pubkeydata;
  M_CipherText signature;
  M_ByteBlock certsignmsg;
};

/* --- Structure CertType_SigningKey_CertBody --- */

typedef struct M_CertType_SigningKey_CertBody M_CertType_SigningKey_CertBody;

/* --- Structure CertType_SigningKey_CertBody --- */

struct M_CertType_SigningKey_CertBody {
  M_KeyID key;
};

/* --- Union CertType__CertBody --- */

union M_CertType__CertBody {
  M_CertType_SingleCert_CertBody singlecert;
  M_CertType_SigningKey_CertBody signingkey;
};

/* --- Structure Certificate --- */

struct M_Certificate {
  M_KeyHash keyhash;
  M_CertType type;
  union M_CertType__CertBody body;
};

/* --- Synonym Nonce --- */

typedef M_Hash M_Nonce;

/* --- Structure PlainText --- */

typedef struct M_PlainText M_PlainText;

/* --- Union PlainTextType__Data --- */

typedef union M_PlainTextType__Data M_PlainTextType__Data;

/* --- Structure PlainTextType_Hash16_Data --- */

typedef struct M_PlainTextType_Hash16_Data M_PlainTextType_Hash16_Data;

/* --- Structure PlainTextType_Hash16_Data --- */

struct M_PlainTextType_Hash16_Data {
  M_Hash16 data;
};

/* --- Structure PlainTextType_Bignum_Data --- */

typedef struct M_PlainTextType_Bignum_Data M_PlainTextType_Bignum_Data;

/* --- Structure PlainTextType_Bignum_Data --- */

struct M_PlainTextType_Bignum_Data {
  M_Bignum m;
};

/* --- Structure PlainTextType_Hash_Data --- */

typedef struct M_PlainTextType_Hash_Data M_PlainTextType_Hash_Data;

/* --- Structure PlainTextType_Hash_Data --- */

struct M_PlainTextType_Hash_Data {
  M_Hash data;
};

/* --- Structure PlainTextType_Bytes_Data --- */

typedef struct M_PlainTextType_Bytes_Data M_PlainTextType_Bytes_Data;

/* --- Structure PlainTextType_Bytes_Data --- */

struct M_PlainTextType_Bytes_Data {
  M_ByteBlock data;
};

/* --- Union PlainTextType__Data --- */

union M_PlainTextType__Data {
  M_PlainTextType_Hash16_Data hash16;
  M_PlainTextType_Bignum_Data bignum;
  M_PlainTextType_Hash_Data hash;
  M_PlainTextType_Bytes_Data bytes;
};

/* --- Structure PlainText --- */

struct M_PlainText {
  M_PlainTextType type;
  union M_PlainTextType__Data data;
};

/* --- Structure KeyGenParams --- */

typedef struct M_KeyGenParams M_KeyGenParams;

/* --- Union KeyType__GenParams --- */

typedef union M_KeyType__GenParams M_KeyType__GenParams;

/* --- Structure KeyType_Wrapped_GenParams --- */

typedef struct M_KeyType_Wrapped_GenParams M_KeyType_Wrapped_GenParams;

/* --- Flags word KeyType_Wrapped_GenParams_flags --- */

typedef M_Word M_KeyType_Wrapped_GenParams_flags;

/* --- Structure KeyType_Wrapped_GenParams --- */

struct M_KeyType_Wrapped_GenParams {
  M_KeyType_Wrapped_GenParams_flags flags;
  M_Word length;
};

/* --- Structure KeyType_DSAPrivate_GenParams --- */

typedef struct M_KeyType_DSAPrivate_GenParams M_KeyType_DSAPrivate_GenParams;

/* --- Flags word KeyType_DSAPrivate_GenParams_flags --- */

typedef M_Word M_KeyType_DSAPrivate_GenParams_flags;

/* --- Structure KeyType_DSAPrivate_GenParams --- */

struct M_KeyType_DSAPrivate_GenParams {
  M_KeyType_DSAPrivate_GenParams_flags flags;
  M_Word lenbits;
  M_DSADiscreteLogGroup *dlg;
};

/* --- Structure KeyType_DHPrivate_GenParams --- */

typedef struct M_KeyType_DHPrivate_GenParams M_KeyType_DHPrivate_GenParams;

/* --- Flags word KeyType_DHPrivate_GenParams_flags --- */

typedef M_Word M_KeyType_DHPrivate_GenParams_flags;

/* --- Structure KeyType_DHPrivate_GenParams --- */

struct M_KeyType_DHPrivate_GenParams {
  M_KeyType_DHPrivate_GenParams_flags flags;
  M_Word plength;
  M_Word xlength;
  M_DiscreteLogGroup *dlg;
};

/* --- Structure KeyType_KCDSAPrivate_GenParams --- */

typedef struct M_KeyType_KCDSAPrivate_GenParams M_KeyType_KCDSAPrivate_GenParams;

/* --- Flags word KeyType_KCDSAPrivate_GenParams_flags --- */

typedef M_Word M_KeyType_KCDSAPrivate_GenParams_flags;

/* --- Structure KeyType_KCDSAPrivate_GenParams --- */

struct M_KeyType_KCDSAPrivate_GenParams {
  M_KeyType_KCDSAPrivate_GenParams_flags flags;
  M_Word plen;
  M_Word qlen;
  M_KCDSADiscreteLogGroup *dlg;
};

/* --- Structure KeyType_RC2_GenParams --- */

typedef struct M_KeyType_RC2_GenParams M_KeyType_RC2_GenParams;

/* --- Structure KeyType_RC2_GenParams --- */

struct M_KeyType_RC2_GenParams {
  M_Word kbits;
  M_Word lenbytes;
};

/* --- Structure KeyType_RSAPrivate_GenParams --- */

typedef struct M_KeyType_RSAPrivate_GenParams M_KeyType_RSAPrivate_GenParams;

/* --- Flags word KeyType_RSAPrivate_GenParams_flags --- */

typedef M_Word M_KeyType_RSAPrivate_GenParams_flags;

/* --- Structure KeyType_RSAPrivate_GenParams --- */

struct M_KeyType_RSAPrivate_GenParams {
  M_KeyType_RSAPrivate_GenParams_flags flags;
  M_Word lenbits;
  M_Bignum *given_e;
  M_Word *nchecks;
};

/* --- Structure KeyType_RC5_GenParams --- */

typedef struct M_KeyType_RC5_GenParams M_KeyType_RC5_GenParams;

/* --- Structure KeyType_RC5_GenParams --- */

struct M_KeyType_RC5_GenParams {
  M_Word rounds;
  M_Word lenbytes;
};

/* --- Structure KeyType_KCDSAComm_GenParams --- */

typedef struct M_KeyType_KCDSAComm_GenParams M_KeyType_KCDSAComm_GenParams;

/* --- Flags word KeyType_KCDSAComm_GenParams_flags --- */

typedef M_Word M_KeyType_KCDSAComm_GenParams_flags;

/* --- Structure KeyType_KCDSAComm_GenParams --- */

struct M_KeyType_KCDSAComm_GenParams {
  M_KeyType_KCDSAComm_GenParams_flags flags;
  M_Word plen;
  M_Word qlen;
  M_KCDSAInitValues *iv;
};

/* --- Structure KeyType_DSAComm_GenParams --- */

typedef struct M_KeyType_DSAComm_GenParams M_KeyType_DSAComm_GenParams;

/* --- Flags word KeyType_DSAComm_GenParams_flags --- */

typedef M_Word M_KeyType_DSAComm_GenParams_flags;

/* --- Structure KeyType_DSAComm_GenParams --- */

struct M_KeyType_DSAComm_GenParams {
  M_KeyType_DSAComm_GenParams_flags flags;
  M_Word lenbits;
  M_DSAInitValues *iv;
};

/* --- Structure KeyType_Random_GenParams --- */

typedef struct M_KeyType_Random_GenParams M_KeyType_Random_GenParams;

/* --- Structure KeyType_Random_GenParams --- */

struct M_KeyType_Random_GenParams {
  M_Word lenbytes;
};

/* --- Union KeyType__GenParams --- */

union M_KeyType__GenParams {
  M_KeyType_Wrapped_GenParams wrapped;
  M_KeyType_DSAPrivate_GenParams dsaprivate;
  M_KeyType_DHPrivate_GenParams dhprivate;
  M_KeyType_KCDSAPrivate_GenParams kcdsaprivate;
  M_KeyType_RC2_GenParams rc2;
  M_KeyType_RSAPrivate_GenParams rsaprivate;
  M_KeyType_RC5_GenParams rc5;
  M_KeyType_KCDSAComm_GenParams kcdsacomm;
  M_KeyType_DSAComm_GenParams dsacomm;
  M_KeyType_Random_GenParams random;
};

/* --- Structure KeyGenParams --- */

struct M_KeyGenParams {
  M_KeyType type;
  union M_KeyType__GenParams params;
};

/* --- Structure IV --- */

typedef struct M_IV M_IV;

/* --- Structure IV --- */

struct M_IV {
  M_Mech mech;
  union M_Mech__IV iv;
};

/* --- Union DeriveMech__DKParams --- */

typedef union M_DeriveMech__DKParams M_DeriveMech__DKParams;

/* --- Structure DeriveMech_RawEncrypt_DKParams --- */

typedef struct M_DeriveMech_RawEncrypt_DKParams M_DeriveMech_RawEncrypt_DKParams;

/* --- Structure DeriveMech_RawEncrypt_DKParams --- */

struct M_DeriveMech_RawEncrypt_DKParams {
  M_IV iv;
};

/* --- Structure DeriveMech_RawDecrypt_DKParams --- */

typedef struct M_DeriveMech_RawDecrypt_DKParams M_DeriveMech_RawDecrypt_DKParams;

/* --- Structure DeriveMech_RawDecrypt_DKParams --- */

struct M_DeriveMech_RawDecrypt_DKParams {
  M_IV iv;
  M_KeyType dst_type;
};

/* --- Structure DeriveMech_SSL3withRSA_DKParams --- */

typedef struct M_DeriveMech_SSL3withRSA_DKParams M_DeriveMech_SSL3withRSA_DKParams;

/* --- Structure DeriveMech_SSL3withRSA_DKParams --- */

struct M_DeriveMech_SSL3withRSA_DKParams {
  M_Bignum ct;
  M_SSLClientRandom crnd;
  M_SSLServerRandom srnd;
};

/* --- Structure DeriveMech_PKCS8Encrypt_DKParams --- */

typedef struct M_DeriveMech_PKCS8Encrypt_DKParams M_DeriveMech_PKCS8Encrypt_DKParams;

/* --- Structure DeriveMech_PKCS8Encrypt_DKParams --- */

struct M_DeriveMech_PKCS8Encrypt_DKParams {
  M_IV iv;
};

/* --- Structure DeriveMech_PKCS8Decrypt_DKParams --- */

typedef struct M_DeriveMech_PKCS8Decrypt_DKParams M_DeriveMech_PKCS8Decrypt_DKParams;

/* --- Structure DeriveMech_PKCS8Decrypt_DKParams --- */

struct M_DeriveMech_PKCS8Decrypt_DKParams {
  M_IV iv;
};

/* --- Structure DeriveMech_RSAComponents_DKParams --- */

typedef struct M_DeriveMech_RSAComponents_DKParams M_DeriveMech_RSAComponents_DKParams;

/* --- Vector vec_IV --- */

typedef M_IV *M_vec_IV;

/* --- Structure DeriveMech_RSAComponents_DKParams --- */

struct M_DeriveMech_RSAComponents_DKParams {
  int n_ivs;
  M_vec_IV ivs;
};

/* --- Structure DeriveMech_SSL3withDH_DKParams --- */

typedef struct M_DeriveMech_SSL3withDH_DKParams M_DeriveMech_SSL3withDH_DKParams;

/* --- Structure DeriveMech_SSL3withDH_DKParams --- */

struct M_DeriveMech_SSL3withDH_DKParams {
  M_Bignum y;
  M_SSLClientRandom crnd;
  M_SSLServerRandom srnd;
};

/* --- Union DeriveMech__DKParams --- */

union M_DeriveMech__DKParams {
  M_DeriveMech_RawEncrypt_DKParams rawencrypt;
  M_DeriveMech_RawDecrypt_DKParams rawdecrypt;
  M_DeriveMech_SSL3withRSA_DKParams ssl3withrsa;
  M_DeriveMech_PKCS8Encrypt_DKParams pkcs8encrypt;
  M_DeriveMech_PKCS8Decrypt_DKParams pkcs8decrypt;
  M_DeriveMech_RSAComponents_DKParams rsacomponents;
  M_DeriveMech_SSL3withDH_DKParams ssl3withdh;
};

/* --- Structure Command --- */

typedef struct M_Command M_Command;

/* --- Flags word Command_flags --- */

typedef M_Word M_Command_flags;

/* --- Union Cmd__Args --- */

typedef union M_Cmd__Args M_Cmd__Args;

/* --- Structure Cmd_BignumOp_Args --- */

typedef struct M_Cmd_BignumOp_Args M_Cmd_BignumOp_Args;

/* --- Flags word Cmd_BignumOp_Args_flags --- */

typedef M_Word M_Cmd_BignumOp_Args_flags;

/* --- Vector vec_Bignum --- */

typedef M_Bignum *M_vec_Bignum;

/* --- Structure StackOpVal --- */

typedef struct M_StackOpVal M_StackOpVal;

/* --- Vector vec_StackOpVal --- */

typedef M_StackOpVal *M_vec_StackOpVal;

/* --- Structure Cmd_BignumOp_Args --- */

struct M_Cmd_BignumOp_Args {
  M_Cmd_BignumOp_Args_flags flags;
  int n_stackin;
  M_vec_Bignum stackin;
  int n_ops;
  M_vec_StackOpVal ops;
};

/* --- Structure Cmd_GetAppData_Args --- */

typedef struct M_Cmd_GetAppData_Args M_Cmd_GetAppData_Args;

/* --- Structure Cmd_GetAppData_Args --- */

struct M_Cmd_GetAppData_Args {
  M_KeyID key;
};

/* --- Structure Cmd_Fail_Args --- */

typedef struct M_Cmd_Fail_Args M_Cmd_Fail_Args;

/* --- Structure Cmd_Fail_Args --- */

struct M_Cmd_Fail_Args {
  M_ModuleID module;
};

/* --- Structure Cmd_Encrypt_Args --- */

typedef struct M_Cmd_Encrypt_Args M_Cmd_Encrypt_Args;

/* --- Flags word Cmd_Encrypt_Args_flags --- */

typedef M_Word M_Cmd_Encrypt_Args_flags;

/* --- Structure Cmd_Encrypt_Args --- */

struct M_Cmd_Encrypt_Args {
  M_Cmd_Encrypt_Args_flags flags;
  M_KeyID key;
  M_Mech mech;
  M_PlainText plain;
  M_IV *given_iv;
};

/* --- Structure Cmd_GetSlotList_Args --- */

typedef struct M_Cmd_GetSlotList_Args M_Cmd_GetSlotList_Args;

/* --- Structure Cmd_GetSlotList_Args --- */

struct M_Cmd_GetSlotList_Args {
  M_ModuleID module;
};

/* --- Structure Cmd_GetRTC_Args --- */

typedef struct M_Cmd_GetRTC_Args M_Cmd_GetRTC_Args;

/* --- Flags word Cmd_GetRTC_Args_flags --- */

typedef M_Word M_Cmd_GetRTC_Args_flags;

/* --- Structure Cmd_GetRTC_Args --- */

struct M_Cmd_GetRTC_Args {
  M_ModuleID module;
  M_Cmd_GetRTC_Args_flags flags;
};

/* --- Structure Cmd_RetryFailedModule_Args --- */

typedef struct M_Cmd_RetryFailedModule_Args M_Cmd_RetryFailedModule_Args;

/* --- Structure Cmd_RetryFailedModule_Args --- */

struct M_Cmd_RetryFailedModule_Args {
  M_ModuleID module;
};

/* --- Structure Cmd_UnimportSlot_Args --- */

typedef struct M_Cmd_UnimportSlot_Args M_Cmd_UnimportSlot_Args;

/* --- Flags word Cmd_UnimportSlot_Args_flags --- */

typedef M_Word M_Cmd_UnimportSlot_Args_flags;

/* --- Structure Cmd_UnimportSlot_Args --- */

struct M_Cmd_UnimportSlot_Args {
  M_Cmd_UnimportSlot_Args_flags flags;
  M_ModuleID module;
  M_SlotID slot;
};

/* --- Structure Cmd_ChangeSharePIN_Args --- */

typedef struct M_Cmd_ChangeSharePIN_Args M_Cmd_ChangeSharePIN_Args;

/* --- Flags word Cmd_ChangeSharePIN_Args_flags --- */

typedef M_Word M_Cmd_ChangeSharePIN_Args_flags;

/* --- Octet array ShortHash --- */

typedef union M_ShortHash {
  unsigned char bytes[10];
} M_ShortHash;

/* --- Octet array PIN --- */

typedef union M_PIN {
  unsigned char bytes[20];
  M_Word words[5];
} M_PIN;

/* --- Structure Cmd_ChangeSharePIN_Args --- */

struct M_Cmd_ChangeSharePIN_Args {
  M_Cmd_ChangeSharePIN_Args_flags flags;
  M_PhysToken token;
  M_KMHash hkm;
  M_ShortHash hkt;
  M_Word i;
  M_PIN *oldpin;
  M_PIN *newpin;
};

/* --- Structure Cmd_OldExtEnquiry_Args --- */

typedef struct M_Cmd_OldExtEnquiry_Args M_Cmd_OldExtEnquiry_Args;

/* --- Structure Cmd_OldExtEnquiry_Args --- */

struct M_Cmd_OldExtEnquiry_Args {
  M_Word version;
};

/* --- Structure Cmd_ImportSlot_Args --- */

typedef struct M_Cmd_ImportSlot_Args M_Cmd_ImportSlot_Args;

/* --- Flags word Cmd_ImportSlot_Args_flags --- */

typedef M_Word M_Cmd_ImportSlot_Args_flags;

/* --- Structure RemoteModule --- */

typedef struct M_RemoteModule M_RemoteModule;

/* --- Flags word RemoteModule_flags --- */

typedef M_Word M_RemoteModule_flags;

/* --- Structure ModuleAttribList --- */

typedef struct M_ModuleAttribList M_ModuleAttribList;

/* --- Structure KeyHashAndMech --- */

typedef struct M_KeyHashAndMech M_KeyHashAndMech;

/* --- Vector vec_KeyHashAndMech --- */

typedef M_KeyHashAndMech *M_vec_KeyHashAndMech;

/* --- Structure wrap_vec_KeyHashAndMech --- */

typedef struct M_wrap_vec_KeyHashAndMech M_wrap_vec_KeyHashAndMech;

/* --- Structure wrap_vec_KeyHashAndMech --- */

struct M_wrap_vec_KeyHashAndMech {
  int n;
  M_vec_KeyHashAndMech v;
};

/* --- Vector vec_Word --- */

typedef M_Word *M_vec_Word;

/* --- Structure wrap_vec_Word --- */

typedef struct M_wrap_vec_Word M_wrap_vec_Word;

/* --- Structure wrap_vec_Word --- */

struct M_wrap_vec_Word {
  int n;
  M_vec_Word v;
};

/* --- Synonym ImpathKXGroupSelection --- */

typedef M_wrap_vec_Word M_ImpathKXGroupSelection;

/* --- Structure RemoteModule --- */

struct M_RemoteModule {
  M_RemoteModule_flags flags;
  M_ModuleAttribList *ma;
  M_NetworkAddress *addr;
  M_wrap_vec_KeyHashAndMech *hks;
  M_ImpathKXGroupSelection *groups;
  M_Word *agelimit;
  M_Word *datalimit;
};

/* --- Synonym RemoteSlotID --- */

typedef M_Word M_RemoteSlotID;

/* --- Structure CertificateList --- */

typedef struct M_CertificateList M_CertificateList;

/* --- Vector vec_Certificate --- */

typedef M_Certificate *M_vec_Certificate;

/* --- Structure CertificateList --- */

struct M_CertificateList {
  int n_certs;
  M_vec_Certificate certs;
};

/* --- Structure Cmd_ImportSlot_Args --- */

struct M_Cmd_ImportSlot_Args {
  M_Cmd_ImportSlot_Args_flags flags;
  M_RemoteModule to;
  M_RemoteModule from;
  M_RemoteSlotID rslot;
  M_CertificateList sendcert;
};

/* --- Structure Cmd_ReceiveShare_Args --- */

typedef struct M_Cmd_ReceiveShare_Args M_Cmd_ReceiveShare_Args;

/* --- Flags word Cmd_ReceiveShare_Args_flags --- */

typedef M_Word M_Cmd_ReceiveShare_Args_flags;

/* --- Synonym ImpathID --- */

typedef M_KeyID M_ImpathID;

/* --- Structure Cmd_ReceiveShare_Args --- */

struct M_Cmd_ReceiveShare_Args {
  M_Cmd_ReceiveShare_Args_flags flags;
  M_ImpathID imp;
  M_KeyID idkt;
  M_ByteBlock share;
  M_PIN *pin;
};

/* --- Structure Cmd_ForeignTokenCmd_Args --- */

typedef struct M_Cmd_ForeignTokenCmd_Args M_Cmd_ForeignTokenCmd_Args;

/* --- Flags word Cmd_ForeignTokenCmd_Args_flags --- */

typedef M_Word M_Cmd_ForeignTokenCmd_Args_flags;

/* --- Union PhysTokenType__Args --- */

typedef union M_PhysTokenType__Args M_PhysTokenType__Args;

/* --- Structure PhysTokenType_ISO7816_Args --- */

typedef struct M_PhysTokenType_ISO7816_Args M_PhysTokenType_ISO7816_Args;

/* --- Structure PhysTokenType_ISO7816_Args --- */

struct M_PhysTokenType_ISO7816_Args {
  M_Word header;
  M_ByteBlock datain;
  M_Word le;
};

/* --- Union PhysTokenType__Args --- */

union M_PhysTokenType__Args {
  M_PhysTokenType_ISO7816_Args iso7816;
};

/* --- Structure Cmd_ForeignTokenCmd_Args --- */

struct M_Cmd_ForeignTokenCmd_Args {
  M_Cmd_ForeignTokenCmd_Args_flags flags;
  M_KeyID lock;
  M_PhysTokenType type;
  union M_PhysTokenType__Args args;
};

/* --- Structure Cmd_MakeBlob_Args --- */

typedef struct M_Cmd_MakeBlob_Args M_Cmd_MakeBlob_Args;

/* --- Flags word Cmd_MakeBlob_Args_flags --- */

typedef M_Word M_Cmd_MakeBlob_Args_flags;

/* --- Union BlobFormat__MkBlobParams --- */

typedef union M_BlobFormat__MkBlobParams M_BlobFormat__MkBlobParams;

/* --- Structure BlobFormat_Module_MkBlobParams --- */

typedef struct M_BlobFormat_Module_MkBlobParams M_BlobFormat_Module_MkBlobParams;

/* --- Structure BlobFormat_Module_MkBlobParams --- */

struct M_BlobFormat_Module_MkBlobParams {
  M_KMHash hkm;
};

/* --- Structure BlobFormat_Direct_MkBlobParams --- */

typedef struct M_BlobFormat_Direct_MkBlobParams M_BlobFormat_Direct_MkBlobParams;

/* --- Structure BlobFormat_Direct_MkBlobParams --- */

struct M_BlobFormat_Direct_MkBlobParams {
  M_KeyID idki;
};

/* --- Structure BlobFormat_Token_MkBlobParams --- */

typedef struct M_BlobFormat_Token_MkBlobParams M_BlobFormat_Token_MkBlobParams;

/* --- Structure BlobFormat_Token_MkBlobParams --- */

struct M_BlobFormat_Token_MkBlobParams {
  M_KeyID idkt;
};

/* --- Structure BlobFormat_Indirect_MkBlobParams --- */

typedef struct M_BlobFormat_Indirect_MkBlobParams M_BlobFormat_Indirect_MkBlobParams;

/* --- Structure BlobFormat_Indirect_MkBlobParams --- */

struct M_BlobFormat_Indirect_MkBlobParams {
  M_KeyID idkr;
  M_Mech mech;
};

/* --- Union BlobFormat__MkBlobParams --- */

union M_BlobFormat__MkBlobParams {
  M_BlobFormat_Module_MkBlobParams module;
  M_BlobFormat_Direct_MkBlobParams direct;
  M_BlobFormat_Token_MkBlobParams token;
  M_BlobFormat_Indirect_MkBlobParams indirect;
};

/* --- Structure ACL --- */

typedef struct M_ACL M_ACL;

/* --- Structure Cmd_MakeBlob_Args --- */

struct M_Cmd_MakeBlob_Args {
  M_Cmd_MakeBlob_Args_flags flags;
  M_BlobFormat format;
  M_KeyID idka;
  union M_BlobFormat__MkBlobParams blobkey;
  M_ACL *acl;
};

/* --- Structure Cmd_RemoveKM_Args --- */

typedef struct M_Cmd_RemoveKM_Args M_Cmd_RemoveKM_Args;

/* --- Flags word Cmd_RemoveKM_Args_flags --- */

typedef M_Word M_Cmd_RemoveKM_Args_flags;

/* --- Structure Cmd_RemoveKM_Args --- */

struct M_Cmd_RemoveKM_Args {
  M_ModuleID module;
  M_Cmd_RemoveKM_Args_flags flags;
  M_KMHash hkm;
};

/* --- Structure Cmd_ProgrammingLoadBlock_Args --- */

typedef struct M_Cmd_ProgrammingLoadBlock_Args M_Cmd_ProgrammingLoadBlock_Args;

/* --- Structure Cmd_ProgrammingLoadBlock_Args --- */

struct M_Cmd_ProgrammingLoadBlock_Args {
  M_ModuleID module;
  M_Word offsetincipher;
  M_ByteBlock data;
};

/* --- Structure Cmd_GenerateLogicalToken_Args --- */

typedef struct M_Cmd_GenerateLogicalToken_Args M_Cmd_GenerateLogicalToken_Args;

/* --- Structure TokenParams --- */

typedef struct M_TokenParams M_TokenParams;

/* --- Flags word TokenParams_flags --- */

typedef M_Word M_TokenParams_flags;

/* --- Structure TokenParams --- */

struct M_TokenParams {
  M_TokenParams_flags flags;
  M_Word sharesneeded;
  M_Word sharestotal;
  M_Word timelimit;
};

/* --- Structure Cmd_GenerateLogicalToken_Args --- */

struct M_Cmd_GenerateLogicalToken_Args {
  M_ModuleID module;
  M_KMHash hkm;
  M_TokenParams params;
};

/* --- Structure Cmd_ImpathSend_Args --- */

typedef struct M_Cmd_ImpathSend_Args M_Cmd_ImpathSend_Args;

/* --- Flags word Cmd_ImpathSend_Args_flags --- */

typedef M_Word M_Cmd_ImpathSend_Args_flags;

/* --- Structure Cmd_ImpathSend_Args --- */

struct M_Cmd_ImpathSend_Args {
  M_Cmd_ImpathSend_Args_flags flags;
  M_ImpathID imp;
  M_ByteBlock data;
};

/* --- Structure Cmd_SetSEEMachine_Args --- */

typedef struct M_Cmd_SetSEEMachine_Args M_Cmd_SetSEEMachine_Args;

/* --- Flags word Cmd_SetSEEMachine_Args_flags --- */

typedef M_Word M_Cmd_SetSEEMachine_Args_flags;

/* --- Structure Cmd_SetSEEMachine_Args --- */

struct M_Cmd_SetSEEMachine_Args {
  M_Cmd_SetSEEMachine_Args_flags flags;
  M_KeyID buffer;
};

/* --- Structure Cmd_GetKeyInfoEx_Args --- */

typedef struct M_Cmd_GetKeyInfoEx_Args M_Cmd_GetKeyInfoEx_Args;

/* --- Flags word Cmd_GetKeyInfoEx_Args_flags --- */

typedef M_Word M_Cmd_GetKeyInfoEx_Args_flags;

/* --- Structure Cmd_GetKeyInfoEx_Args --- */

struct M_Cmd_GetKeyInfoEx_Args {
  M_Cmd_GetKeyInfoEx_Args_flags flags;
  M_KeyID key;
};

/* --- Structure Cmd_ReadFile_Args --- */

typedef struct M_Cmd_ReadFile_Args M_Cmd_ReadFile_Args;

/* --- Flags word Cmd_ReadFile_Args_flags --- */

typedef M_Word M_Cmd_ReadFile_Args_flags;

/* --- Structure FileInfo --- */

typedef struct M_FileInfo M_FileInfo;

/* --- Flags word FileInfo_flags --- */

typedef M_Word M_FileInfo_flags;

/* --- Octet array FileID --- */

typedef union M_FileID {
  unsigned char bytes[11];
} M_FileID;

/* --- Structure FileInfo --- */

struct M_FileInfo {
  M_FileInfo_flags flags;
  M_Word length;
  M_FileID id;
};

/* --- Structure Cmd_ReadFile_Args --- */

struct M_Cmd_ReadFile_Args {
  M_Cmd_ReadFile_Args_flags flags;
  M_PhysToken token;
  M_FileInfo file;
};

/* --- Structure Cmd_GetKMList_Args --- */

typedef struct M_Cmd_GetKMList_Args M_Cmd_GetKMList_Args;

/* --- Flags word Cmd_GetKMList_Args_flags --- */

typedef M_Word M_Cmd_GetKMList_Args_flags;

/* --- Structure Cmd_GetKMList_Args --- */

struct M_Cmd_GetKMList_Args {
  M_ModuleID module;
  M_Cmd_GetKMList_Args_flags flags;
};

/* --- Structure Cmd_OldEnquiry_Args --- */

typedef struct M_Cmd_OldEnquiry_Args M_Cmd_OldEnquiry_Args;

/* --- Flags word Cmd_OldEnquiry_Args_flags --- */

typedef M_Word M_Cmd_OldEnquiry_Args_flags;

/* --- Structure Cmd_OldEnquiry_Args --- */

struct M_Cmd_OldEnquiry_Args {
  M_Cmd_OldEnquiry_Args_flags flags;
  M_ModuleID *module;
};

/* --- Structure Cmd_InsertSoftToken_Args --- */

typedef struct M_Cmd_InsertSoftToken_Args M_Cmd_InsertSoftToken_Args;

/* --- Flags word Cmd_InsertSoftToken_Args_flags --- */

typedef M_Word M_Cmd_InsertSoftToken_Args_flags;

/* --- Structure Cmd_InsertSoftToken_Args --- */

struct M_Cmd_InsertSoftToken_Args {
  M_Cmd_InsertSoftToken_Args_flags flags;
  M_PhysToken token;
  M_ByteBlock data;
};

/* --- Structure Cmd_ProgrammingGetKeyList_Args --- */

typedef struct M_Cmd_ProgrammingGetKeyList_Args M_Cmd_ProgrammingGetKeyList_Args;

/* --- Structure Cmd_ProgrammingGetKeyList_Args --- */

struct M_Cmd_ProgrammingGetKeyList_Args {
  M_ModuleID module;
};

/* --- Structure Cmd_ModExpCrt_Args --- */

typedef struct M_Cmd_ModExpCrt_Args M_Cmd_ModExpCrt_Args;

/* --- Structure Cmd_ModExpCrt_Args --- */

struct M_Cmd_ModExpCrt_Args {
  M_Bignum a;
  M_Bignum p;
  M_Bignum q;
  M_Bignum dmp1;
  M_Bignum dmq1;
  M_Bignum iqmp;
};

/* --- Structure Cmd_WriteFile_Args --- */

typedef struct M_Cmd_WriteFile_Args M_Cmd_WriteFile_Args;

/* --- Flags word Cmd_WriteFile_Args_flags --- */

typedef M_Word M_Cmd_WriteFile_Args_flags;

/* --- Structure Cmd_WriteFile_Args --- */

struct M_Cmd_WriteFile_Args {
  M_Cmd_WriteFile_Args_flags flags;
  M_PhysToken token;
  M_FileInfo file;
  M_ByteBlock data;
};

/* --- Structure Cmd_ClearUnit_Args --- */

typedef struct M_Cmd_ClearUnit_Args M_Cmd_ClearUnit_Args;

/* --- Structure Cmd_ClearUnit_Args --- */

struct M_Cmd_ClearUnit_Args {
  M_ModuleID module;
};

/* --- Structure Cmd_NoOp_Args --- */

typedef struct M_Cmd_NoOp_Args M_Cmd_NoOp_Args;

/* --- Structure Cmd_NoOp_Args --- */

struct M_Cmd_NoOp_Args {
  M_ModuleID module;
};

/* --- Structure Cmd_GetKeyInfo_Args --- */

typedef struct M_Cmd_GetKeyInfo_Args M_Cmd_GetKeyInfo_Args;

/* --- Structure Cmd_GetKeyInfo_Args --- */

struct M_Cmd_GetKeyInfo_Args {
  M_KeyID key;
};

/* --- Structure Cmd_WriteShare_Args --- */

typedef struct M_Cmd_WriteShare_Args M_Cmd_WriteShare_Args;

/* --- Flags word Cmd_WriteShare_Args_flags --- */

typedef M_Word M_Cmd_WriteShare_Args_flags;

/* --- Structure Cmd_WriteShare_Args --- */

struct M_Cmd_WriteShare_Args {
  M_Cmd_WriteShare_Args_flags flags;
  M_PhysToken token;
  M_KeyID idkt;
  M_Word i;
  M_PIN *pin;
  M_ACL *acl;
};

/* --- Structure Cmd_SetKNSO_Args --- */

typedef struct M_Cmd_SetKNSO_Args M_Cmd_SetKNSO_Args;

/* --- Structure NSOPerms --- */

typedef struct M_NSOPerms M_NSOPerms;

/* --- Flags word NSOPerms_ops --- */

typedef M_Word M_NSOPerms_ops;

/* --- Structure NSOPerms --- */

struct M_NSOPerms {
  M_NSOPerms_ops ops;
};

/* --- Structure Cmd_SetKNSO_Args --- */

struct M_Cmd_SetKNSO_Args {
  M_ModuleID module;
  M_NSOPerms needcertperms;
  M_KeyHash hknso;
};

/* --- Structure Cmd_LoadRaw_Args --- */

typedef struct M_Cmd_LoadRaw_Args M_Cmd_LoadRaw_Args;

/* --- Flags word Cmd_LoadRaw_Args_flags --- */

typedef M_Word M_Cmd_LoadRaw_Args_flags;

/* --- Structure Cmd_LoadRaw_Args --- */

struct M_Cmd_LoadRaw_Args {
  M_ModuleID module;
  M_Cmd_LoadRaw_Args_flags flags;
  M_Word absoluteaddr;
  M_ByteBlock data;
};

/* --- Structure Cmd_Duplicate_Args --- */

typedef struct M_Cmd_Duplicate_Args M_Cmd_Duplicate_Args;

/* --- Structure Cmd_Duplicate_Args --- */

struct M_Cmd_Duplicate_Args {
  M_KeyID key;
};

/* --- Structure Cmd_GetLogicalTokenInfoEx_Args --- */

typedef struct M_Cmd_GetLogicalTokenInfoEx_Args M_Cmd_GetLogicalTokenInfoEx_Args;

/* --- Flags word Cmd_GetLogicalTokenInfoEx_Args_flags --- */

typedef M_Word M_Cmd_GetLogicalTokenInfoEx_Args_flags;

/* --- Structure Cmd_GetLogicalTokenInfoEx_Args --- */

struct M_Cmd_GetLogicalTokenInfoEx_Args {
  M_Cmd_GetLogicalTokenInfoEx_Args_flags flags;
  M_KeyID idkt;
};

/* --- Structure Cmd_StatGetValues_Args --- */

typedef struct M_Cmd_StatGetValues_Args M_Cmd_StatGetValues_Args;

/* --- Flags word Cmd_StatGetValues_Args_flags --- */

typedef M_Word M_Cmd_StatGetValues_Args_flags;

/* --- Structure Cmd_StatGetValues_Args --- */

struct M_Cmd_StatGetValues_Args {
  M_Cmd_StatGetValues_Args_flags flags;
  int n_path_tags;
  M_vec_Word path_tags;
};

/* --- Structure Cmd_ListRemoteServerPermission_Args --- */

typedef struct M_Cmd_ListRemoteServerPermission_Args M_Cmd_ListRemoteServerPermission_Args;

/* --- Structure Cmd_ListRemoteServerPermission_Args --- */

struct M_Cmd_ListRemoteServerPermission_Args {
  M_RemoteServerOp op;
};

/* --- Structure Cmd_ChannelUpdate_Args --- */

typedef struct M_Cmd_ChannelUpdate_Args M_Cmd_ChannelUpdate_Args;

/* --- Flags word Cmd_ChannelUpdate_Args_flags --- */

typedef M_Word M_Cmd_ChannelUpdate_Args_flags;

/* --- Structure Cmd_ChannelUpdate_Args --- */

struct M_Cmd_ChannelUpdate_Args {
  M_Cmd_ChannelUpdate_Args_flags flags;
  M_KeyID idch;
  M_ByteBlock input;
};

/* --- Structure Cmd_AddRemoteServerPermission_Args --- */

typedef struct M_Cmd_AddRemoteServerPermission_Args M_Cmd_AddRemoteServerPermission_Args;

/* --- Structure RemoteServerPermission --- */

typedef struct M_RemoteServerPermission M_RemoteServerPermission;

/* --- Flags word RemoteServerPermission_flags --- */

typedef M_Word M_RemoteServerPermission_flags;

/* --- Union RemoteServerOp__Details --- */

typedef union M_RemoteServerOp__Details M_RemoteServerOp__Details;

/* --- Structure RemoteServerOp_ExportSlot_Details --- */

typedef struct M_RemoteServerOp_ExportSlot_Details M_RemoteServerOp_ExportSlot_Details;

/* --- Structure RemoteServerOp_ExportSlot_Details --- */

struct M_RemoteServerOp_ExportSlot_Details {
  M_SlotID slot;
};

/* --- Union RemoteServerOp__Details --- */

union M_RemoteServerOp__Details {
  M_RemoteServerOp_ExportSlot_Details exportslot;
};

/* --- Structure RemoteServerPermission --- */

struct M_RemoteServerPermission {
  M_RemoteServerPermission_flags flags;
  M_Word permid;
  M_ModuleID module;
  M_RemoteServerOp op;
  union M_RemoteServerOp__Details details;
  M_RemoteModule rm;
};

/* --- Structure Cmd_AddRemoteServerPermission_Args --- */

struct M_Cmd_AddRemoteServerPermission_Args {
  M_RemoteServerPermission permission;
};

/* --- Structure Cmd_Export_Args --- */

typedef struct M_Cmd_KeyExport_Args M_Cmd_KeyExport_Args;

/* --- Structure Cmd_Export_Args --- */

struct M_Cmd_KeyExport_Args {
  M_KeyID key;
};

/* --- Structure Cmd_GetWhichModule_Args --- */

typedef struct M_Cmd_GetWhichModule_Args M_Cmd_GetWhichModule_Args;

/* --- Structure Cmd_GetWhichModule_Args --- */

struct M_Cmd_GetWhichModule_Args {
  M_KeyID key;
};

/* --- Structure Cmd_GetLogicalTokenInfo_Args --- */

typedef struct M_Cmd_GetLogicalTokenInfo_Args M_Cmd_GetLogicalTokenInfo_Args;

/* --- Structure Cmd_GetLogicalTokenInfo_Args --- */

struct M_Cmd_GetLogicalTokenInfo_Args {
  M_KeyID idkt;
};

/* --- Structure Cmd_CreateSEEWorld_Args --- */

typedef struct M_Cmd_CreateSEEWorld_Args M_Cmd_CreateSEEWorld_Args;

/* --- Flags word Cmd_CreateSEEWorld_Args_flags --- */

typedef M_Word M_Cmd_CreateSEEWorld_Args_flags;

/* --- Structure Cmd_CreateSEEWorld_Args --- */

struct M_Cmd_CreateSEEWorld_Args {
  M_Cmd_CreateSEEWorld_Args_flags flags;
  M_KeyID buffer;
};

/* --- Structure Cmd_GetACL_Args --- */

typedef struct M_Cmd_GetACL_Args M_Cmd_GetACL_Args;

/* --- Flags word Cmd_GetACL_Args_flags --- */

typedef M_Word M_Cmd_GetACL_Args_flags;

/* --- Structure Cmd_GetACL_Args --- */

struct M_Cmd_GetACL_Args {
  M_Cmd_GetACL_Args_flags flags;
  M_KeyID key;
};

/* --- Structure Cmd_RSAImmedSignDecrypt_Args --- */

typedef struct M_Cmd_RSAImmedSignDecrypt_Args M_Cmd_RSAImmedSignDecrypt_Args;

/* --- Structure Cmd_RSAImmedSignDecrypt_Args --- */

struct M_Cmd_RSAImmedSignDecrypt_Args {
  M_Bignum m;
  M_Bignum k_p;
  M_Bignum k_q;
  M_Bignum k_dmp1;
  M_Bignum k_dmq1;
  M_Bignum k_iqmp;
};

/* --- Structure Cmd_RedeemTicket_Args --- */

typedef struct M_Cmd_RedeemTicket_Args M_Cmd_RedeemTicket_Args;

/* --- Flags word Cmd_RedeemTicket_Args_flags --- */

typedef M_Word M_Cmd_RedeemTicket_Args_flags;

/* --- Synonym nest_Ticket --- */

typedef M_ByteBlock M_nest_Ticket;

/* --- Structure Cmd_RedeemTicket_Args --- */

struct M_Cmd_RedeemTicket_Args {
  M_Cmd_RedeemTicket_Args_flags flags;
  M_ModuleID module;
  M_nest_Ticket ticket;
};

/* --- Structure Cmd_ImpathKXFinish_Args --- */

typedef struct M_Cmd_ImpathKXFinish_Args M_Cmd_ImpathKXFinish_Args;

/* --- Flags word Cmd_ImpathKXFinish_Args_flags --- */

typedef M_Word M_Cmd_ImpathKXFinish_Args_flags;

/* --- Vector vec_KeyID --- */

typedef M_KeyID *M_vec_KeyID;

/* --- Structure Cmd_ImpathKXFinish_Args --- */

struct M_Cmd_ImpathKXFinish_Args {
  M_Cmd_ImpathKXFinish_Args_flags flags;
  M_ImpathID imp;
  M_NetworkAddress *addr;
  int n_keys;
  M_vec_KeyID keys;
  M_ByteBlock kx;
};

/* --- Structure Cmd_GetTicket_Args --- */

typedef struct M_Cmd_GetTicket_Args M_Cmd_GetTicket_Args;

/* --- Flags word Cmd_GetTicket_Args_flags --- */

typedef M_Word M_Cmd_GetTicket_Args_flags;

/* --- Union TicketDestination__Details --- */

typedef union M_TicketDestination__Details M_TicketDestination__Details;

/* --- Structure TicketDestination_NamedClient_Details --- */

typedef struct M_TicketDestination_NamedClient_Details M_TicketDestination_NamedClient_Details;

/* --- Structure TicketDestination_NamedClient_Details --- */

struct M_TicketDestination_NamedClient_Details {
  M_Hash hclientid;
};

/* --- Structure TicketDestination_NamedSEEWorld_Details --- */

typedef struct M_TicketDestination_NamedSEEWorld_Details M_TicketDestination_NamedSEEWorld_Details;

/* --- Structure TicketDestination_NamedSEEWorld_Details --- */

struct M_TicketDestination_NamedSEEWorld_Details {
  M_KeyID world;
};

/* --- Union TicketDestination__Details --- */

union M_TicketDestination__Details {
  M_TicketDestination_NamedClient_Details namedclient;
  M_TicketDestination_NamedSEEWorld_Details namedseeworld;
};

/* --- Structure Cmd_GetTicket_Args --- */

struct M_Cmd_GetTicket_Args {
  M_Cmd_GetTicket_Args_flags flags;
  M_KeyID obj;
  M_TicketDestination dest;
  union M_TicketDestination__Details destspec;
};

/* --- Structure Cmd_GetKLF_Args --- */

typedef struct M_Cmd_GetKLF_Args M_Cmd_GetKLF_Args;

/* --- Structure Cmd_GetKLF_Args --- */

struct M_Cmd_GetKLF_Args {
  M_ModuleID module;
};

/* --- Structure Cmd_RSAImmedVerifyEncrypt_Args --- */

typedef struct M_Cmd_RSAImmedVerifyEncrypt_Args M_Cmd_RSAImmedVerifyEncrypt_Args;

/* --- Structure Cmd_RSAImmedVerifyEncrypt_Args --- */

struct M_Cmd_RSAImmedVerifyEncrypt_Args {
  M_Bignum m;
  M_Bignum k_e;
  M_Bignum k_n;
};

/* --- Structure Cmd_NVMemAlloc_Args --- */

typedef struct M_Cmd_NVMemAlloc_Args M_Cmd_NVMemAlloc_Args;

/* --- Flags word Cmd_NVMemAlloc_Args_flags --- */

typedef M_Word M_Cmd_NVMemAlloc_Args_flags;

/* --- Structure PermissionGroup --- */

typedef struct M_PermissionGroup M_PermissionGroup;

/* --- Vector vec_PermissionGroup --- */

typedef M_PermissionGroup *M_vec_PermissionGroup;

/* --- Structure ACL --- */

struct M_ACL {
  int n_groups;
  M_vec_PermissionGroup groups;
};

/* --- Structure Cmd_NVMemAlloc_Args --- */

struct M_Cmd_NVMemAlloc_Args {
  M_ModuleID module;
  M_Cmd_NVMemAlloc_Args_flags flags;
  M_FileInfo info;
  M_ACL acl;
};

/* --- Structure Cmd_ImpathGetInfo_Args --- */

typedef struct M_Cmd_ImpathGetInfo_Args M_Cmd_ImpathGetInfo_Args;

/* --- Structure Cmd_ImpathGetInfo_Args --- */

struct M_Cmd_ImpathGetInfo_Args {
  M_ImpathID imp;
};

/* --- Structure Cmd_RemoveSoftToken_Args --- */

typedef struct M_Cmd_RemoveSoftToken_Args M_Cmd_RemoveSoftToken_Args;

/* --- Flags word Cmd_RemoveSoftToken_Args_flags --- */

typedef M_Word M_Cmd_RemoveSoftToken_Args_flags;

/* --- Structure Cmd_RemoveSoftToken_Args --- */

struct M_Cmd_RemoveSoftToken_Args {
  M_Cmd_RemoveSoftToken_Args_flags flags;
  M_PhysToken token;
};

/* --- Structure Cmd_ModuleInfo_Args --- */

typedef struct M_Cmd_ModuleInfo_Args M_Cmd_ModuleInfo_Args;

/* --- Flags word Cmd_ModuleInfo_Args_flags --- */

typedef M_Word M_Cmd_ModuleInfo_Args_flags;

/* --- Structure Cmd_ModuleInfo_Args --- */

struct M_Cmd_ModuleInfo_Args {
  M_ModuleID module;
  M_Cmd_ModuleInfo_Args_flags flags;
  M_Word format;
};

/* --- Structure Cmd_ProgrammingEndChunk_Args --- */

typedef struct M_Cmd_ProgrammingEndChunk_Args M_Cmd_ProgrammingEndChunk_Args;

/* --- Structure Cmd_ProgrammingEndChunk_Args --- */

struct M_Cmd_ProgrammingEndChunk_Args {
  M_ModuleID module;
};

/* --- Structure Cmd_Maintenance_Args --- */

typedef struct M_Cmd_Maintenance_Args M_Cmd_Maintenance_Args;

/* --- Structure Cmd_Maintenance_Args --- */

struct M_Cmd_Maintenance_Args {
  M_ModuleID module;
};

/* --- Structure Cmd_ExportSlot_Args --- */

typedef struct M_Cmd_ExportSlot_Args M_Cmd_ExportSlot_Args;

/* --- Flags word Cmd_ExportSlot_Args_flags --- */

typedef M_Word M_Cmd_ExportSlot_Args_flags;

/* --- Structure Cmd_ExportSlot_Args --- */

struct M_Cmd_ExportSlot_Args {
  M_Cmd_ExportSlot_Args_flags flags;
  M_ModuleID module;
  M_SlotID slot;
};

/* --- Structure Cmd_Decrypt_Args --- */

typedef struct M_Cmd_Decrypt_Args M_Cmd_Decrypt_Args;

/* --- Flags word Cmd_Decrypt_Args_flags --- */

typedef M_Word M_Cmd_Decrypt_Args_flags;

/* --- Structure Cmd_Decrypt_Args --- */

struct M_Cmd_Decrypt_Args {
  M_Cmd_Decrypt_Args_flags flags;
  M_KeyID key;
  M_Mech mech;
  M_CipherText cipher;
  M_PlainTextType reply_type;
};

/* --- Structure Cmd_ServerSendShare_Args --- */

typedef struct M_Cmd_ServerSendShare_Args M_Cmd_ServerSendShare_Args;

/* --- Flags word Cmd_ServerSendShare_Args_flags --- */

typedef M_Word M_Cmd_ServerSendShare_Args_flags;

/* --- Structure Cmd_ServerSendShare_Args --- */

struct M_Cmd_ServerSendShare_Args {
  M_Cmd_ServerSendShare_Args_flags flags;
  M_MustBeZeroWord imp;
  M_PhysToken token;
  M_Word i;
  M_KMHash hkm;
  M_TokenHash hkt;
  M_PIN *pin;
};

/* --- Structure Cmd_EraseShare_Args --- */

typedef struct M_Cmd_EraseShare_Args M_Cmd_EraseShare_Args;

/* --- Structure Cmd_EraseShare_Args --- */

struct M_Cmd_EraseShare_Args {
  M_PhysToken token;
  M_ShortHash hkt;
  M_Word i;
};

/* --- Structure Cmd_NewEnquiry_Args --- */

typedef struct M_Cmd_NewEnquiry_Args M_Cmd_NewEnquiry_Args;

/* --- Flags word Cmd_NewEnquiry_Args_flags --- */

typedef M_Word M_Cmd_NewEnquiry_Args_flags;

/* --- Structure Cmd_NewEnquiry_Args --- */

struct M_Cmd_NewEnquiry_Args {
  M_Cmd_NewEnquiry_Args_flags flags;
  M_Word version;
  M_ModuleID module;
};

/* --- Structure Cmd_UpdateMergedKey_Args --- */

typedef struct M_Cmd_UpdateMergedKey_Args M_Cmd_UpdateMergedKey_Args;

/* --- Flags word Cmd_UpdateMergedKey_Args_flags --- */

typedef M_Word M_Cmd_UpdateMergedKey_Args_flags;

/* --- Structure Cmd_UpdateMergedKey_Args --- */

struct M_Cmd_UpdateMergedKey_Args {
  M_KeyID mkey;
  M_Cmd_UpdateMergedKey_Args_flags flags;
  int n_addkeys;
  M_vec_KeyID addkeys;
  int n_delkeys;
  M_vec_KeyID delkeys;
};

/* --- Structure Cmd_ModExp_Args --- */

typedef struct M_Cmd_ModExp_Args M_Cmd_ModExp_Args;

/* --- Structure Cmd_ModExp_Args --- */

struct M_Cmd_ModExp_Args {
  M_Bignum a;
  M_Bignum p;
  M_Bignum n;
};

/* --- Structure Cmd_ChannelOpen_Args --- */

typedef struct M_Cmd_ChannelOpen_Args M_Cmd_ChannelOpen_Args;

/* --- Flags word Cmd_ChannelOpen_Args_flags --- */

typedef M_Word M_Cmd_ChannelOpen_Args_flags;

/* --- Structure Cmd_ChannelOpen_Args --- */

struct M_Cmd_ChannelOpen_Args {
  M_ModuleID module;
  M_ChannelType type;
  M_Cmd_ChannelOpen_Args_flags flags;
  M_ChannelMode mode;
  M_Mech mech;
  M_KeyID *key;
  M_IV *given_iv;
};

/* --- Structure Cmd_SEEJob_Args --- */

typedef struct M_Cmd_SEEJob_Args M_Cmd_SEEJob_Args;

/* --- Structure Cmd_SEEJob_Args --- */

struct M_Cmd_SEEJob_Args {
  M_KeyID worldid;
  M_ByteBlock seeargs;
};

/* --- Structure Cmd_SetRTC_Args --- */

typedef struct M_Cmd_SetRTC_Args M_Cmd_SetRTC_Args;

/* --- Flags word Cmd_SetRTC_Args_flags --- */

typedef M_Word M_Cmd_SetRTC_Args_flags;

/* --- Structure RTCTime --- */

typedef struct M_RTCTime M_RTCTime;

/* --- Structure RTCTime --- */

struct M_RTCTime {
  M_Word currenttimehigh;
  M_Word currenttimelow;
  M_Word currenttimenanos;
  M_Word precision;
};

/* --- Structure Cmd_SetRTC_Args --- */

struct M_Cmd_SetRTC_Args {
  M_ModuleID module;
  M_Cmd_SetRTC_Args_flags flags;
  M_RTCTime time;
};

/* --- Structure Cmd_Destroy_Args --- */

typedef struct M_Cmd_Destroy_Args M_Cmd_Destroy_Args;

/* --- Structure Cmd_Destroy_Args --- */

struct M_Cmd_Destroy_Args {
  M_KeyID key;
};

/* --- Structure Cmd_ReadShare_Args --- */

typedef struct M_Cmd_ReadShare_Args M_Cmd_ReadShare_Args;

/* --- Flags word Cmd_ReadShare_Args_flags --- */

typedef M_Word M_Cmd_ReadShare_Args_flags;

/* --- Structure Cmd_ReadShare_Args --- */

struct M_Cmd_ReadShare_Args {
  M_Cmd_ReadShare_Args_flags flags;
  M_PhysToken token;
  M_KeyID idkt;
  M_Word i;
  M_PIN *pin;
};

/* --- Structure Cmd_Sign_Args --- */

typedef struct M_Cmd_Sign_Args M_Cmd_Sign_Args;

/* --- Flags word Cmd_Sign_Args_flags --- */

typedef M_Word M_Cmd_Sign_Args_flags;

/* --- Structure Cmd_Sign_Args --- */

struct M_Cmd_Sign_Args {
  M_Cmd_Sign_Args_flags flags;
  M_KeyID key;
  M_Mech mech;
  M_PlainText plain;
  M_IV *given_iv;
};

/* --- Structure Cmd_Import_Args --- */

typedef struct M_Cmd_Import_Args M_Cmd_Import_Args;

/* --- Octet array AppData --- */

typedef union M_AppData {
  unsigned char bytes[64];
  M_Word words[16];
} M_AppData;

/* --- Structure Cmd_Import_Args --- */

struct M_Cmd_Import_Args {
  M_ModuleID module;
  M_KeyData data;
  M_ACL acl;
  M_AppData appdata;
};

/* --- Structure Cmd_ProgrammingBegin_Args --- */

typedef struct M_Cmd_ProgrammingBegin_Args M_Cmd_ProgrammingBegin_Args;

/* --- Structure Cmd_ProgrammingBegin_Args --- */

struct M_Cmd_ProgrammingBegin_Args {
  M_ModuleID module;
  M_KeyHash hkfi;
  M_KeyHash hkfc;
  M_Hash sdhash;
  M_ByteBlock sd;
  M_CipherText sig;
};

/* --- Structure Cmd_RemoveRemoteServerPermission_Args --- */

typedef struct M_Cmd_RemoveRemoteServerPermission_Args M_Cmd_RemoveRemoteServerPermission_Args;

/* --- Structure Cmd_RemoveRemoteServerPermission_Args --- */

struct M_Cmd_RemoveRemoteServerPermission_Args {
  M_Word permid;
};

/* --- Structure Cmd_GeneratePrime_Args --- */

typedef struct M_Cmd_GeneratePrime_Args M_Cmd_GeneratePrime_Args;

/* --- Structure Cmd_GeneratePrime_Args --- */

struct M_Cmd_GeneratePrime_Args {
  M_Word lenbits;
};

/* --- Structure Cmd_ExistingClient_Args --- */

typedef struct M_Cmd_ExistingClient_Args M_Cmd_ExistingClient_Args;

/* --- Flags word Cmd_ExistingClient_Args_flags --- */

typedef M_Word M_Cmd_ExistingClient_Args_flags;

/* --- Structure Cmd_ExistingClient_Args --- */

struct M_Cmd_ExistingClient_Args {
  M_Cmd_ExistingClient_Args_flags flags;
  M_ClientID client;
};

/* --- Structure Cmd_SendShare_Args --- */

typedef struct M_Cmd_SendShare_Args M_Cmd_SendShare_Args;

/* --- Flags word Cmd_SendShare_Args_flags --- */

typedef M_Word M_Cmd_SendShare_Args_flags;

/* --- Structure Cmd_SendShare_Args --- */

struct M_Cmd_SendShare_Args {
  M_Cmd_SendShare_Args_flags flags;
  M_ImpathID imp;
  M_PhysToken token;
  M_Word i;
  M_KMHash hkm;
  M_TokenHash hkt;
  M_PIN *pin;
};

/* --- Structure Cmd_ImpathKXBegin_Args --- */

typedef struct M_Cmd_ImpathKXBegin_Args M_Cmd_ImpathKXBegin_Args;

/* --- Flags word Cmd_ImpathKXBegin_Args_flags --- */

typedef M_Word M_Cmd_ImpathKXBegin_Args_flags;

/* --- Structure Cmd_ImpathKXBegin_Args --- */

struct M_Cmd_ImpathKXBegin_Args {
  M_Cmd_ImpathKXBegin_Args_flags flags;
  M_ModuleID module;
  M_RemoteModule me;
  M_RemoteModule him;
  M_ImpathKXGroupSelection hisgroups;
  M_Nonce n;
  int n_keys;
  M_vec_KeyID keys;
};

/* --- Structure Cmd_ForeignTokenOpen_Args --- */

typedef struct M_Cmd_ForeignTokenOpen_Args M_Cmd_ForeignTokenOpen_Args;

/* --- Flags word Cmd_ForeignTokenOpen_Args_flags --- */

typedef M_Word M_Cmd_ForeignTokenOpen_Args_flags;

/* --- Structure Cmd_ForeignTokenOpen_Args --- */

struct M_Cmd_ForeignTokenOpen_Args {
  M_Cmd_ForeignTokenOpen_Args_flags flags;
  M_PhysToken token;
};

/* --- Structure Cmd_CheckUserAction_Args --- */

typedef struct M_Cmd_CheckUserAction_Args M_Cmd_CheckUserAction_Args;

/* --- Flags word Cmd_CheckUserAction_Args_flags --- */

typedef M_Word M_Cmd_CheckUserAction_Args_flags;

/* --- Structure UserActionInfo --- */

typedef struct M_UserActionInfo M_UserActionInfo;

/* --- Synonym UserActionID --- */

typedef M_Hash M_UserActionID;

/* --- Structure UserActionInfo --- */

struct M_UserActionInfo {
  M_UserActionID id;
  M_Word perms;
  M_ByteBlock restriction;
};

/* --- Structure Cmd_CheckUserAction_Args --- */

struct M_Cmd_CheckUserAction_Args {
  M_Cmd_CheckUserAction_Args_flags flags;
  M_KeyID key;
  M_UserActionInfo request;
};

/* --- Structure Cmd_EraseFile_Args --- */

typedef struct M_Cmd_EraseFile_Args M_Cmd_EraseFile_Args;

/* --- Flags word Cmd_EraseFile_Args_flags --- */

typedef M_Word M_Cmd_EraseFile_Args_flags;

/* --- Structure Cmd_EraseFile_Args --- */

struct M_Cmd_EraseFile_Args {
  M_Cmd_EraseFile_Args_flags flags;
  M_PhysToken token;
  M_FileInfo file;
};

/* --- Structure Cmd_InitialiseUnit_Args --- */

typedef struct M_Cmd_InitialiseUnit_Args M_Cmd_InitialiseUnit_Args;

/* --- Structure Cmd_InitialiseUnit_Args --- */

struct M_Cmd_InitialiseUnit_Args {
  M_ModuleID module;
};

/* --- Structure Cmd_ProgrammingBeginChunk_Args --- */

typedef struct M_Cmd_ProgrammingBeginChunk_Args M_Cmd_ProgrammingBeginChunk_Args;

/* --- Structure Cmd_ProgrammingBeginChunk_Args --- */

struct M_Cmd_ProgrammingBeginChunk_Args {
  M_ModuleID module;
  M_Word index;
  M_Hash sdhash;
  M_IV iv;
};

/* --- Structure Cmd_Hash_Args --- */

typedef struct M_Cmd_Hash_Args M_Cmd_Hash_Args;

/* --- Flags word Cmd_Hash_Args_flags --- */

typedef M_Word M_Cmd_Hash_Args_flags;

/* --- Structure Cmd_Hash_Args --- */

struct M_Cmd_Hash_Args {
  M_Cmd_Hash_Args_flags flags;
  M_Mech mech;
  M_PlainText plain;
};

/* --- Structure Cmd_FormatToken_Args --- */

typedef struct M_Cmd_FormatToken_Args M_Cmd_FormatToken_Args;

/* --- Flags word Cmd_FormatToken_Args_flags --- */

typedef M_Word M_Cmd_FormatToken_Args_flags;

/* --- Structure Cmd_FormatToken_Args --- */

struct M_Cmd_FormatToken_Args {
  M_Cmd_FormatToken_Args_flags flags;
  M_PhysToken token;
  M_KMHash *auth_key;
};

/* --- Structure Cmd_PollSlotList_Args --- */

typedef struct M_Cmd_PollSlotList_Args M_Cmd_PollSlotList_Args;

/* --- Flags word Cmd_PollSlotList_Args_flags --- */

typedef M_Word M_Cmd_PollSlotList_Args_flags;

/* --- Structure Cmd_PollSlotList_Args --- */

struct M_Cmd_PollSlotList_Args {
  M_Cmd_PollSlotList_Args_flags flags;
  M_ModuleID module;
};

/* --- Structure Cmd_PollModuleState_Args --- */

typedef struct M_Cmd_PollModuleState_Args M_Cmd_PollModuleState_Args;

/* --- Flags word Cmd_PollModuleState_Args_flags --- */

typedef M_Word M_Cmd_PollModuleState_Args_flags;

/* --- Structure Cmd_PollModuleState_Args --- */

struct M_Cmd_PollModuleState_Args {
  M_Cmd_PollModuleState_Args_flags flags;
  M_ModuleID module;
};

/* --- Structure Cmd_NVMemFree_Args --- */

typedef struct M_Cmd_NVMemFree_Args M_Cmd_NVMemFree_Args;

/* --- Flags word Cmd_NVMemFree_Args_flags --- */

typedef M_Word M_Cmd_NVMemFree_Args_flags;

/* --- Structure Cmd_NVMemFree_Args --- */

struct M_Cmd_NVMemFree_Args {
  M_ModuleID module;
  M_Cmd_NVMemFree_Args_flags flags;
  M_FileID name;
};

/* --- Structure Cmd_LoadLogicalToken_Args --- */

typedef struct M_Cmd_LoadLogicalToken_Args M_Cmd_LoadLogicalToken_Args;

/* --- Structure Cmd_LoadLogicalToken_Args --- */

struct M_Cmd_LoadLogicalToken_Args {
  M_ModuleID module;
  M_TokenHash hkt;
  M_KMHash hkm;
  M_TokenParams params;
};

/* --- Structure Cmd_SetKM_Args --- */

typedef struct M_Cmd_SetKM_Args M_Cmd_SetKM_Args;

/* --- Flags word Cmd_SetKM_Args_flags --- */

typedef M_Word M_Cmd_SetKM_Args_flags;

/* --- Structure Cmd_SetKM_Args --- */

struct M_Cmd_SetKM_Args {
  M_ModuleID module;
  M_Cmd_SetKM_Args_flags flags;
  M_KeyID idka;
};

/* --- Structure Cmd_GenerateKLF_Args --- */

typedef struct M_Cmd_GenerateKLF_Args M_Cmd_GenerateKLF_Args;

/* --- Flags word Cmd_GenerateKLF_Args_flags --- */

typedef M_Word M_Cmd_GenerateKLF_Args_flags;

/* --- Structure Cmd_GenerateKLF_Args --- */

struct M_Cmd_GenerateKLF_Args {
  M_ModuleID module;
  M_Cmd_GenerateKLF_Args_flags flags;
};

/* --- Structure Cmd_DeriveKey_Args --- */

typedef struct M_Cmd_DeriveKey_Args M_Cmd_DeriveKey_Args;

/* --- Flags word Cmd_DeriveKey_Args_flags --- */

typedef M_Word M_Cmd_DeriveKey_Args_flags;

/* --- Structure Cmd_DeriveKey_Args --- */

struct M_Cmd_DeriveKey_Args {
  M_Cmd_DeriveKey_Args_flags flags;
  M_DeriveMech mech;
  int n_keys;
  M_vec_KeyID keys;
  union M_DeriveMech__DKParams params;
};

/* --- Structure Cmd_StatEnumTree_Args --- */

typedef struct M_Cmd_StatEnumTree_Args M_Cmd_StatEnumTree_Args;

/* --- Flags word Cmd_StatEnumTree_Args_flags --- */

typedef M_Word M_Cmd_StatEnumTree_Args_flags;

/* --- Structure Cmd_StatEnumTree_Args --- */

struct M_Cmd_StatEnumTree_Args {
  M_Cmd_StatEnumTree_Args_flags flags;
  int n_path_tags;
  M_vec_Word path_tags;
};

/* --- Structure Cmd_NVMemOp_Args --- */

typedef struct M_Cmd_NVMemOp_Args M_Cmd_NVMemOp_Args;

/* --- Flags word Cmd_NVMemOp_Args_flags --- */

typedef M_Word M_Cmd_NVMemOp_Args_flags;

/* --- Structure NVMemRange --- */

typedef struct M_NVMemRange M_NVMemRange;

/* --- Union NVMemOpType__OpVal --- */

typedef union M_NVMemOpType__OpVal M_NVMemOpType__OpVal;

/* --- Structure NVMemOpType_BitClear_OpVal --- */

typedef struct M_NVMemOpType_BitClear_OpVal M_NVMemOpType_BitClear_OpVal;

/* --- Structure NVMemOpType_BitClear_OpVal --- */

struct M_NVMemOpType_BitClear_OpVal {
  M_ByteBlock data;
};

/* --- Structure NVMemOpType_Incr_OpVal --- */

typedef struct M_NVMemOpType_Incr_OpVal M_NVMemOpType_Incr_OpVal;

/* --- Structure NVMemOpType_Incr_OpVal --- */

struct M_NVMemOpType_Incr_OpVal {
  M_Word count;
};

/* --- Structure NVMemOpType_Decr_OpVal --- */

typedef struct M_NVMemOpType_Decr_OpVal M_NVMemOpType_Decr_OpVal;

/* --- Structure NVMemOpType_Decr_OpVal --- */

struct M_NVMemOpType_Decr_OpVal {
  M_Word count;
};

/* --- Structure NVMemOpType_BitSet_OpVal --- */

typedef struct M_NVMemOpType_BitSet_OpVal M_NVMemOpType_BitSet_OpVal;

/* --- Structure NVMemOpType_BitSet_OpVal --- */

struct M_NVMemOpType_BitSet_OpVal {
  M_ByteBlock data;
};

/* --- Structure NVMemOpType_Write_OpVal --- */

typedef struct M_NVMemOpType_Write_OpVal M_NVMemOpType_Write_OpVal;

/* --- Structure NVMemOpType_Write_OpVal --- */

struct M_NVMemOpType_Write_OpVal {
  M_ByteBlock data;
};

/* --- Union NVMemOpType__OpVal --- */

union M_NVMemOpType__OpVal {
  M_NVMemOpType_BitClear_OpVal bitclear;
  M_NVMemOpType_Incr_OpVal incr;
  M_NVMemOpType_Decr_OpVal decr;
  M_NVMemOpType_BitSet_OpVal bitset;
  M_NVMemOpType_Write_OpVal write;
};

/* --- Structure Cmd_NVMemOp_Args --- */

struct M_Cmd_NVMemOp_Args {
  M_ModuleID module;
  M_Cmd_NVMemOp_Args_flags flags;
  M_FileID name;
  M_NVMemRange *range;
  M_NVMemOpType op;
  union M_NVMemOpType__OpVal val;
};

/* --- Structure Cmd_LoadBlob_Args --- */

typedef struct M_Cmd_LoadBlob_Args M_Cmd_LoadBlob_Args;

/* --- Flags word Cmd_LoadBlob_Args_flags --- */

typedef M_Word M_Cmd_LoadBlob_Args_flags;

/* --- Structure Cmd_LoadBlob_Args --- */

struct M_Cmd_LoadBlob_Args {
  M_Cmd_LoadBlob_Args_flags flags;
  M_ModuleID module;
  M_ByteBlock blob;
  M_KeyID *idkb;
};

/* --- Structure Cmd_StaticFeatureEnable_Args --- */

typedef struct M_Cmd_StaticFeatureEnable_Args M_Cmd_StaticFeatureEnable_Args;

/* --- Structure FeatureInfo --- */

typedef struct M_FeatureInfo M_FeatureInfo;

/* --- Flags word FeatureInfo_ctrl --- */

typedef M_Word M_FeatureInfo_ctrl;

/* --- Flags word FeatureInfo_features --- */

typedef M_Word M_FeatureInfo_features;

/* --- Structure FeatureInfo --- */

struct M_FeatureInfo {
  M_Word ver;
  M_FeatureInfo_ctrl ctrl;
  M_FeatureInfo_features features;
};

/* --- Structure Cmd_StaticFeatureEnable_Args --- */

struct M_Cmd_StaticFeatureEnable_Args {
  M_ModuleID module;
  M_FeatureInfo info;
};

/* --- Structure Cmd_GenerateKey_Args --- */

typedef struct M_Cmd_GenerateKey_Args M_Cmd_GenerateKey_Args;

/* --- Flags word Cmd_GenerateKey_Args_flags --- */

typedef M_Word M_Cmd_GenerateKey_Args_flags;

/* --- Structure Cmd_GenerateKey_Args --- */

struct M_Cmd_GenerateKey_Args {
  M_Cmd_GenerateKey_Args_flags flags;
  M_ModuleID module;
  M_KeyGenParams params;
  M_ACL acl;
  M_AppData *appdata;
};

/* --- Structure Cmd_NVMemList_Args --- */

typedef struct M_Cmd_NVMemList_Args M_Cmd_NVMemList_Args;

/* --- Flags word Cmd_NVMemList_Args_flags --- */

typedef M_Word M_Cmd_NVMemList_Args_flags;

/* --- Structure Cmd_NVMemList_Args --- */

struct M_Cmd_NVMemList_Args {
  M_ModuleID module;
  M_Cmd_NVMemList_Args_flags flags;
};

/* --- Structure Cmd_GetSlotInfo_Args --- */

typedef struct M_Cmd_GetSlotInfo_Args M_Cmd_GetSlotInfo_Args;

/* --- Structure Cmd_GetSlotInfo_Args --- */

struct M_Cmd_GetSlotInfo_Args {
  M_ModuleID module;
  M_SlotID slot;
};

/* --- Structure Cmd_CreateBuffer_Args --- */

typedef struct M_Cmd_CreateBuffer_Args M_Cmd_CreateBuffer_Args;

/* --- Flags word Cmd_CreateBuffer_Args_flags --- */

typedef M_Word M_Cmd_CreateBuffer_Args_flags;

/* --- Structure EncryptionParams --- */

typedef struct M_EncryptionParams M_EncryptionParams;

/* --- Structure Cmd_CreateBuffer_Args --- */

struct M_Cmd_CreateBuffer_Args {
  M_ModuleID module;
  M_Cmd_CreateBuffer_Args_flags flags;
  M_Word size;
  M_EncryptionParams *params;
};

/* --- Structure Cmd_GetKML_Args --- */

typedef struct M_Cmd_GetKML_Args M_Cmd_GetKML_Args;

/* --- Structure Cmd_GetKML_Args --- */

struct M_Cmd_GetKML_Args {
  M_ModuleID module;
};

/* --- Structure Cmd_GetShareACL_Args --- */

typedef struct M_Cmd_GetShareACL_Args M_Cmd_GetShareACL_Args;

/* --- Flags word Cmd_GetShareACL_Args_flags --- */

typedef M_Word M_Cmd_GetShareACL_Args_flags;

/* --- Structure Cmd_GetShareACL_Args --- */

struct M_Cmd_GetShareACL_Args {
  M_Cmd_GetShareACL_Args_flags flags;
  M_PhysToken token;
  M_ShortHash hkt;
  M_Word i;
};

/* --- Structure Cmd_GenerateKeyPair_Args --- */

typedef struct M_Cmd_GenerateKeyPair_Args M_Cmd_GenerateKeyPair_Args;

/* --- Flags word Cmd_GenerateKeyPair_Args_flags --- */

typedef M_Word M_Cmd_GenerateKeyPair_Args_flags;

/* --- Structure Cmd_GenerateKeyPair_Args --- */

struct M_Cmd_GenerateKeyPair_Args {
  M_Cmd_GenerateKeyPair_Args_flags flags;
  M_ModuleID module;
  M_KeyGenParams params;
  M_ACL aclpriv;
  M_ACL aclpub;
  M_AppData *appdatapriv;
  M_AppData *appdatapub;
};

/* --- Structure Cmd_GenerateRandom_Args --- */

typedef struct M_Cmd_GenerateRandom_Args M_Cmd_GenerateRandom_Args;

/* --- Structure Cmd_GenerateRandom_Args --- */

struct M_Cmd_GenerateRandom_Args {
  M_Word lenbytes;
};

/* --- Structure Cmd_FirmwareAuthenticate_Args --- */

typedef struct M_Cmd_FirmwareAuthenticate_Args M_Cmd_FirmwareAuthenticate_Args;

/* --- Flags word Cmd_FirmwareAuthenticate_Args_flags --- */

typedef M_Word M_Cmd_FirmwareAuthenticate_Args_flags;

/* --- Union FwAuthType__Params --- */

typedef union M_FwAuthType__Params M_FwAuthType__Params;

/* --- Structure FwAuthType_PRNG1_Params --- */

typedef struct M_FwAuthType_PRNG1_Params M_FwAuthType_PRNG1_Params;

/* --- Structure FwAuthType_PRNG1_Params --- */

struct M_FwAuthType_PRNG1_Params {
  M_Word variant;
  M_Word index;
};

/* --- Structure FwAuthType_NFFHMAC1_Params --- */

typedef struct M_FwAuthType_NFFHMAC1_Params M_FwAuthType_NFFHMAC1_Params;

/* --- Structure FwAuthType_NFFHMAC1_Params --- */

struct M_FwAuthType_NFFHMAC1_Params {
  M_KeyHash hkfc;
  M_IV iv;
  M_Word chunk;
  M_ByteBlock mackey;
};

/* --- Union FwAuthType__Params --- */

union M_FwAuthType__Params {
  M_FwAuthType_PRNG1_Params prng1;
  M_FwAuthType_NFFHMAC1_Params nffhmac1;
};

/* --- Structure Cmd_FirmwareAuthenticate_Args --- */

struct M_Cmd_FirmwareAuthenticate_Args {
  M_ModuleID module;
  M_Cmd_FirmwareAuthenticate_Args_flags flags;
  M_FwAuthType type;
  union M_FwAuthType__Params challenge;
};

/* --- Structure Cmd_SetNSOPerms_Args --- */

typedef struct M_Cmd_SetNSOPerms_Args M_Cmd_SetNSOPerms_Args;

/* --- Flags word Cmd_SetNSOPerms_Args_flags --- */

typedef M_Word M_Cmd_SetNSOPerms_Args_flags;

/* --- Structure Cmd_SetNSOPerms_Args --- */

struct M_Cmd_SetNSOPerms_Args {
  M_ModuleID module;
  M_Cmd_SetNSOPerms_Args_flags flags;
  M_KeyHash hknso;
  M_NSOPerms publicperms;
};

/* --- Structure Cmd_GetChallenge_Args --- */

typedef struct M_Cmd_GetChallenge_Args M_Cmd_GetChallenge_Args;

/* --- Structure Cmd_GetChallenge_Args --- */

struct M_Cmd_GetChallenge_Args {
  M_ModuleID module;
};

/* --- Structure Cmd_SignModuleState_Args --- */

typedef struct M_Cmd_SignModuleState_Args M_Cmd_SignModuleState_Args;

/* --- Flags word Cmd_SignModuleState_Args_flags --- */

typedef M_Word M_Cmd_SignModuleState_Args_flags;

/* --- Union SignerType__SignerInfo --- */

typedef union M_SignerType__SignerInfo M_SignerType__SignerInfo;

/* --- Structure SignerType_AppKey_SignerInfo --- */

typedef struct M_SignerType_AppKey_SignerInfo M_SignerType_AppKey_SignerInfo;

/* --- Structure SignerType_AppKey_SignerInfo --- */

struct M_SignerType_AppKey_SignerInfo {
  M_KeyID key;
  M_Mech mech;
};

/* --- Union SignerType__SignerInfo --- */

union M_SignerType__SignerInfo {
  M_SignerType_AppKey_SignerInfo appkey;
};

/* --- Structure Cmd_SignModuleState_Args --- */

struct M_Cmd_SignModuleState_Args {
  M_ModuleID module;
  M_Cmd_SignModuleState_Args_flags flags;
  M_SignerType signer;
  union M_SignerType__SignerInfo siginfo;
  M_Nonce *challenge;
};

/* --- Structure Cmd_TraceSEEWorld_Args --- */

typedef struct M_Cmd_TraceSEEWorld_Args M_Cmd_TraceSEEWorld_Args;

/* --- Structure Cmd_TraceSEEWorld_Args --- */

struct M_Cmd_TraceSEEWorld_Args {
  M_KeyID worldid;
};

/* --- Structure Cmd_MergeKeyIDs_Args --- */

typedef struct M_Cmd_MergeKeyIDs_Args M_Cmd_MergeKeyIDs_Args;

/* --- Structure Cmd_MergeKeyIDs_Args --- */

struct M_Cmd_MergeKeyIDs_Args {
  int n_keys;
  M_vec_KeyID keys;
};

/* --- Structure Cmd_ImpathReceive_Args --- */

typedef struct M_Cmd_ImpathReceive_Args M_Cmd_ImpathReceive_Args;

/* --- Structure Cmd_ImpathReceive_Args --- */

struct M_Cmd_ImpathReceive_Args {
  M_ImpathID imp;
  M_ByteBlock cipher;
};

/* --- Structure Cmd_NewClient_Args --- */

typedef struct M_Cmd_NewClient_Args M_Cmd_NewClient_Args;

/* --- Flags word Cmd_NewClient_Args_flags --- */

typedef M_Word M_Cmd_NewClient_Args_flags;

/* --- Structure Cmd_NewClient_Args --- */

struct M_Cmd_NewClient_Args {
  M_Cmd_NewClient_Args_flags flags;
};

/* --- Structure Cmd_Verify_Args --- */

typedef struct M_Cmd_Verify_Args M_Cmd_Verify_Args;

/* --- Flags word Cmd_Verify_Args_flags --- */

typedef M_Word M_Cmd_Verify_Args_flags;

/* --- Structure Cmd_Verify_Args --- */

struct M_Cmd_Verify_Args {
  M_Cmd_Verify_Args_flags flags;
  M_KeyID key;
  M_Mech mech;
  M_PlainText plain;
  M_CipherText sig;
};

/* --- Structure Cmd_GetWorldSigners_Args --- */

typedef struct M_Cmd_GetWorldSigners_Args M_Cmd_GetWorldSigners_Args;

/* --- Flags word Cmd_GetWorldSigners_Args_flags --- */

typedef M_Word M_Cmd_GetWorldSigners_Args_flags;

/* --- Structure Cmd_GetWorldSigners_Args --- */

struct M_Cmd_GetWorldSigners_Args {
  M_Cmd_GetWorldSigners_Args_flags flags;
};

/* --- Structure Cmd_PauseForNotifications_Args --- */

typedef struct M_Cmd_PauseForNotifications_Args M_Cmd_PauseForNotifications_Args;

/* --- Flags word Cmd_PauseForNotifications_Args_flags --- */

typedef M_Word M_Cmd_PauseForNotifications_Args_flags;

/* --- Structure Cmd_PauseForNotifications_Args --- */

struct M_Cmd_PauseForNotifications_Args {
  M_ModuleID module;
  M_Cmd_PauseForNotifications_Args_flags flags;
  M_Word ms;
};

/* --- Structure Cmd_SetAppData_Args --- */

typedef struct M_Cmd_SetAppData_Args M_Cmd_SetAppData_Args;

/* --- Structure Cmd_SetAppData_Args --- */

struct M_Cmd_SetAppData_Args {
  M_KeyID key;
  M_AppData appdata;
};

/* --- Structure Cmd_LoadBuffer_Args --- */

typedef struct M_Cmd_LoadBuffer_Args M_Cmd_LoadBuffer_Args;

/* --- Flags word Cmd_LoadBuffer_Args_flags --- */

typedef M_Word M_Cmd_LoadBuffer_Args_flags;

/* --- Structure Cmd_LoadBuffer_Args --- */

struct M_Cmd_LoadBuffer_Args {
  M_KeyID id;
  M_Cmd_LoadBuffer_Args_flags flags;
  M_ByteBlock chunk;
};

/* --- Structure Cmd_ProgrammingEnd_Args --- */

typedef struct M_Cmd_ProgrammingEnd_Args M_Cmd_ProgrammingEnd_Args;

/* --- Structure Cmd_ProgrammingEnd_Args --- */

struct M_Cmd_ProgrammingEnd_Args {
  M_ModuleID module;
};

/* --- Structure Cmd_SetACL_Args --- */

typedef struct M_Cmd_SetACL_Args M_Cmd_SetACL_Args;

/* --- Flags word Cmd_SetACL_Args_flags --- */

typedef M_Word M_Cmd_SetACL_Args_flags;

/* --- Structure Cmd_SetACL_Args --- */

struct M_Cmd_SetACL_Args {
  M_Cmd_SetACL_Args_flags flags;
  M_KeyID key;
  M_ACL newacl;
};

/* --- Union Cmd__Args --- */

union M_Cmd__Args {
  M_Cmd_BignumOp_Args bignumop;
  M_Cmd_GetAppData_Args getappdata;
  M_Cmd_Fail_Args fail;
  M_Cmd_Encrypt_Args encrypt;
  M_Cmd_GetSlotList_Args getslotlist;
  M_Cmd_GetRTC_Args getrtc;
  M_Cmd_RetryFailedModule_Args retryfailedmodule;
  M_Cmd_UnimportSlot_Args unimportslot;
  M_Cmd_ChangeSharePIN_Args changesharepin;
  M_Cmd_OldExtEnquiry_Args oldextenquiry;
  M_Cmd_ImportSlot_Args importslot;
  M_Cmd_ReceiveShare_Args receiveshare;
  M_Cmd_ForeignTokenCmd_Args foreigntokencmd;
  M_Cmd_MakeBlob_Args makeblob;
  M_Cmd_RemoveKM_Args removekm;
  M_Cmd_ProgrammingLoadBlock_Args programmingloadblock;
  M_Cmd_GenerateLogicalToken_Args generatelogicaltoken;
  M_Cmd_ImpathSend_Args impathsend;
  M_Cmd_SetSEEMachine_Args setseemachine;
  M_Cmd_GetKeyInfoEx_Args getkeyinfoex;
  M_Cmd_ReadFile_Args readfile;
  M_Cmd_GetKMList_Args getkmlist;
  M_Cmd_OldEnquiry_Args oldenquiry;
  M_Cmd_InsertSoftToken_Args insertsofttoken;
  M_Cmd_ProgrammingGetKeyList_Args programminggetkeylist;
  M_Cmd_ModExpCrt_Args modexpcrt;
  M_Cmd_WriteFile_Args writefile;
  M_Cmd_ClearUnit_Args clearunit;
  M_Cmd_NoOp_Args noop;
  M_Cmd_GetKeyInfo_Args getkeyinfo;
  M_Cmd_WriteShare_Args writeshare;
  M_Cmd_SetKNSO_Args setknso;
  M_Cmd_LoadRaw_Args loadraw;
  M_Cmd_Duplicate_Args duplicate;
  M_Cmd_GetLogicalTokenInfoEx_Args getlogicaltokeninfoex;
  M_Cmd_StatGetValues_Args statgetvalues;
  M_Cmd_ListRemoteServerPermission_Args listremoteserverpermission;
  M_Cmd_ChannelUpdate_Args channelupdate;
  M_Cmd_AddRemoteServerPermission_Args addremoteserverpermission;
  M_Cmd_KeyExport_Args keyexport;
  M_Cmd_GetWhichModule_Args getwhichmodule;
  M_Cmd_GetLogicalTokenInfo_Args getlogicaltokeninfo;
  M_Cmd_CreateSEEWorld_Args createseeworld;
  M_Cmd_GetACL_Args getacl;
  M_Cmd_RSAImmedSignDecrypt_Args rsaimmedsigndecrypt;
  M_Cmd_RedeemTicket_Args redeemticket;
  M_Cmd_ImpathKXFinish_Args impathkxfinish;
  M_Cmd_GetTicket_Args getticket;
  M_Cmd_GetKLF_Args getklf;
  M_Cmd_RSAImmedVerifyEncrypt_Args rsaimmedverifyencrypt;
  M_Cmd_NVMemAlloc_Args nvmemalloc;
  M_Cmd_ImpathGetInfo_Args impathgetinfo;
  M_Cmd_RemoveSoftToken_Args removesofttoken;
  M_Cmd_ModuleInfo_Args moduleinfo;
  M_Cmd_ProgrammingEndChunk_Args programmingendchunk;
  M_Cmd_Maintenance_Args maintenance;
  M_Cmd_ExportSlot_Args exportslot;
  M_Cmd_Decrypt_Args decrypt;
  M_Cmd_ServerSendShare_Args serversendshare;
  M_Cmd_EraseShare_Args eraseshare;
  M_Cmd_NewEnquiry_Args newenquiry;
  M_Cmd_UpdateMergedKey_Args updatemergedkey;
  M_Cmd_ModExp_Args modexp;
  M_Cmd_ChannelOpen_Args channelopen;
  M_Cmd_SEEJob_Args seejob;
  M_Cmd_SetRTC_Args setrtc;
  M_Cmd_Destroy_Args destroy;
  M_Cmd_ReadShare_Args readshare;
  M_Cmd_Sign_Args sign;
  M_Cmd_Import_Args import;
  M_Cmd_ProgrammingBegin_Args programmingbegin;
  M_Cmd_RemoveRemoteServerPermission_Args removeremoteserverpermission;
  M_Cmd_GeneratePrime_Args generateprime;
  M_Cmd_ExistingClient_Args existingclient;
  M_Cmd_SendShare_Args sendshare;
  M_Cmd_ImpathKXBegin_Args impathkxbegin;
  M_Cmd_ForeignTokenOpen_Args foreigntokenopen;
  M_Cmd_CheckUserAction_Args checkuseraction;
  M_Cmd_EraseFile_Args erasefile;
  M_Cmd_InitialiseUnit_Args initialiseunit;
  M_Cmd_ProgrammingBeginChunk_Args programmingbeginchunk;
  M_Cmd_Hash_Args hash;
  M_Cmd_FormatToken_Args formattoken;
  M_Cmd_PollSlotList_Args pollslotlist;
  M_Cmd_PollModuleState_Args pollmodulestate;
  M_Cmd_NVMemFree_Args nvmemfree;
  M_Cmd_LoadLogicalToken_Args loadlogicaltoken;
  M_Cmd_SetKM_Args setkm;
  M_Cmd_GenerateKLF_Args generateklf;
  M_Cmd_DeriveKey_Args derivekey;
  M_Cmd_StatEnumTree_Args statenumtree;
  M_Cmd_NVMemOp_Args nvmemop;
  M_Cmd_LoadBlob_Args loadblob;
  M_Cmd_StaticFeatureEnable_Args staticfeatureenable;
  M_Cmd_GenerateKey_Args generatekey;
  M_Cmd_NVMemList_Args nvmemlist;
  M_Cmd_GetSlotInfo_Args getslotinfo;
  M_Cmd_CreateBuffer_Args createbuffer;
  M_Cmd_GetKML_Args getkml;
  M_Cmd_GetShareACL_Args getshareacl;
  M_Cmd_GenerateKeyPair_Args generatekeypair;
  M_Cmd_GenerateRandom_Args generaterandom;
  M_Cmd_FirmwareAuthenticate_Args firmwareauthenticate;
  M_Cmd_SetNSOPerms_Args setnsoperms;
  M_Cmd_GetChallenge_Args getchallenge;
  M_Cmd_SignModuleState_Args signmodulestate;
  M_Cmd_TraceSEEWorld_Args traceseeworld;
  M_Cmd_MergeKeyIDs_Args mergekeyids;
  M_Cmd_ImpathReceive_Args impathreceive;
  M_Cmd_NewClient_Args newclient;
  M_Cmd_Verify_Args verify;
  M_Cmd_GetWorldSigners_Args getworldsigners;
  M_Cmd_PauseForNotifications_Args pausefornotifications;
  M_Cmd_SetAppData_Args setappdata;
  M_Cmd_LoadBuffer_Args loadbuffer;
  M_Cmd_ProgrammingEnd_Args programmingend;
  M_Cmd_SetACL_Args setacl;
};

/* --- Structure Command --- */

struct M_Command {
  M_Tag tag;
  M_Cmd cmd;
  M_MustBeZeroWord status;
  M_Command_flags flags;
  union M_Cmd__Args args;
  M_CertificateList *certs;
};

/* --- Structure StackOpVal --- */

struct M_StackOpVal {
  M_StackOp op;
  M_Word val;
};

/* --- Structure ModuleAttrib --- */

typedef struct M_ModuleAttrib M_ModuleAttrib;

/* --- Vector vec_ModuleAttrib --- */

typedef M_ModuleAttrib *M_vec_ModuleAttrib;

/* --- Structure ModuleAttribList --- */

struct M_ModuleAttribList {
  int n_attribs;
  M_vec_ModuleAttrib attribs;
};

/* --- Structure KeyHashAndMech --- */

struct M_KeyHashAndMech {
  M_KeyHash hash;
  M_Mech mech;
};

/* --- Flags word PermissionGroup_flags --- */

typedef M_Word M_PermissionGroup_flags;

/* --- Structure UseLimit --- */

typedef struct M_UseLimit M_UseLimit;

/* --- Vector vec_UseLimit --- */

typedef M_UseLimit *M_vec_UseLimit;

/* --- Structure Action --- */

typedef struct M_Action M_Action;

/* --- Vector vec_Action --- */

typedef M_Action *M_vec_Action;

/* --- Structure PermissionGroup --- */

struct M_PermissionGroup {
  M_PermissionGroup_flags flags;
  int n_limits;
  M_vec_UseLimit limits;
  int n_actions;
  M_vec_Action actions;
  M_KeyHash *certifier;
  M_KeyHashAndMech *certmech;
  M_ASCIIString *moduleserial;
};

/* --- Structure NVMemRange --- */

struct M_NVMemRange {
  M_Word first;
  M_Word last;
};

/* --- Structure EncryptionParams --- */

struct M_EncryptionParams {
  M_KeyID key;
  M_IV iv;
};

/* --- Union ModuleAttribTag__Value --- */

typedef union M_ModuleAttribTag__Value M_ModuleAttribTag__Value;

/* --- Structure ModuleAttribTag_PhysSerial_Value --- */

typedef struct M_ModuleAttribTag_PhysSerial_Value M_ModuleAttribTag_PhysSerial_Value;

/* --- Structure ModuleAttribTag_PhysSerial_Value --- */

struct M_ModuleAttribTag_PhysSerial_Value {
  M_ASCIIString physserial;
};

/* --- Structure ModuleAttribTag_Challenge_Value --- */

typedef struct M_ModuleAttribTag_Challenge_Value M_ModuleAttribTag_Challenge_Value;

/* --- Structure ModuleAttribTag_Challenge_Value --- */

struct M_ModuleAttribTag_Challenge_Value {
  M_Nonce nonce;
};

/* --- Structure ModuleAttribTag_FeatureGoldCert_Value --- */

typedef struct M_ModuleAttribTag_FeatureGoldCert_Value M_ModuleAttribTag_FeatureGoldCert_Value;

/* --- Structure ModuleAttribTag_FeatureGoldCert_Value --- */

struct M_ModuleAttribTag_FeatureGoldCert_Value {
  M_FeatureGoldCertVendor vendor;
};

/* --- Structure ModuleAttribTag_KNSO_Value --- */

typedef struct M_ModuleAttribTag_KNSO_Value M_ModuleAttribTag_KNSO_Value;

/* --- Structure ModuleAttribTag_KNSO_Value --- */

struct M_ModuleAttribTag_KNSO_Value {
  M_KeyHash hknso;
  M_NSOPerms publicperms;
};

/* --- Structure ModuleAttribTag_KLF_Value --- */

typedef struct M_ModuleAttribTag_KLF_Value M_ModuleAttribTag_KLF_Value;

/* --- Structure ModuleAttribTag_KLF_Value --- */

struct M_ModuleAttribTag_KLF_Value {
  M_KeyHash hklf;
  M_KeyData klfpub;
  M_Mech mech_i;
};

/* --- Structure ModuleAttribTag_KMList_Value --- */

typedef struct M_ModuleAttribTag_KMList_Value M_ModuleAttribTag_KMList_Value;

/* --- Structure KeyHashAttrib --- */

typedef struct M_KeyHashAttrib M_KeyHashAttrib;

/* --- Vector vec_KeyHashAttrib --- */

typedef M_KeyHashAttrib *M_vec_KeyHashAttrib;

/* --- Structure ModuleAttribTag_KMList_Value --- */

struct M_ModuleAttribTag_KMList_Value {
  int n_hkms;
  M_vec_KeyHashAttrib hkms;
};

/* --- Structure ModuleAttribTag_ESN_Value --- */

typedef struct M_ModuleAttribTag_ESN_Value M_ModuleAttribTag_ESN_Value;

/* --- Structure ModuleAttribTag_ESN_Value --- */

struct M_ModuleAttribTag_ESN_Value {
  M_ASCIIString esn;
};

/* --- Structure ModuleAttribTag_KML_Value --- */

typedef struct M_ModuleAttribTag_KML_Value M_ModuleAttribTag_KML_Value;

/* --- Structure ModuleAttribTag_KML_Value --- */

struct M_ModuleAttribTag_KML_Value {
  M_KeyHash hkml;
  M_KeyData kmlpub;
  M_Mech mech_i;
};

/* --- Structure ModuleAttribTag_Enquiry_Value --- */

typedef struct M_ModuleAttribTag_Enquiry_Value M_ModuleAttribTag_Enquiry_Value;

/* --- Structure EnquiryDataOne --- */

typedef struct M_EnquiryDataOne M_EnquiryDataOne;

/* --- Flags word EnquiryDataOne_flags --- */

typedef M_Word M_EnquiryDataOne_flags;

/* --- Structure EnquiryDataOne --- */

struct M_EnquiryDataOne {
  M_Word releasemajor;
  M_Word releaseminor;
  M_Word releasepatch;
  M_Word checkintimehigh;
  M_Word checkintimelow;
  M_EnquiryDataOne_flags flags;
  M_Word speedindex;
  M_Word recommendedminq;
  M_Word recommendedmaxq;
  M_ASCIIString hardwareserial;
  M_ASCIIString softwaredetails;
};

/* --- Structure EnquiryDataTwo --- */

typedef struct M_EnquiryDataTwo M_EnquiryDataTwo;

/* --- Flags word EnquiryDataTwo_flags --- */

typedef M_Word M_EnquiryDataTwo_flags;

/* --- Structure EnquiryDataTwo --- */

struct M_EnquiryDataTwo {
  M_EnquiryDataTwo_flags flags;
  M_Word maxwrite;
};

/* --- Structure EnquiryDataThree --- */

typedef struct M_EnquiryDataThree M_EnquiryDataThree;

/* --- Flags word EnquiryDataThree_flags --- */

typedef M_Word M_EnquiryDataThree_flags;

/* --- Structure EnquiryDataThree --- */

struct M_EnquiryDataThree {
  M_EnquiryDataThree_flags flags;
};

/* --- Structure EnquiryDataFour --- */

typedef struct M_EnquiryDataFour M_EnquiryDataFour;

/* --- Flags word EnquiryDataFour_flags --- */

typedef M_Word M_EnquiryDataFour_flags;

/* --- Structure EnquiryDataFour --- */

struct M_EnquiryDataFour {
  M_EnquiryDataFour_flags flags;
};

/* --- Structure EnquiryDataFive --- */

typedef struct M_EnquiryDataFive M_EnquiryDataFive;

/* --- Structure EnquiryDataFive --- */

struct M_EnquiryDataFive {
  M_ModuleType moduletype;
  M_ASCIIString productname;
  M_ASCIIString devicename;
};

/* --- Structure EnquiryDataSix --- */

typedef struct M_EnquiryDataSix M_EnquiryDataSix;

/* --- Structure EnquiryDataSix --- */

struct M_EnquiryDataSix {
  M_Word v;
  M_ImpathKXGroupSelection supportedgroups;

  /* --- If v >= 1 --- */

  M_FeatureInfo features;
};

/* --- Structure ModuleAttribTag_Enquiry_Value --- */

struct M_ModuleAttribTag_Enquiry_Value {
  M_EnquiryDataOne one;
  M_EnquiryDataTwo two;
  M_EnquiryDataThree three;
  M_EnquiryDataFour four;
  M_EnquiryDataFive five;
  M_EnquiryDataSix six;
};

/* --- Structure ModuleAttribTag_AdditionalInfo_Value --- */

typedef struct M_ModuleAttribTag_AdditionalInfo_Value M_ModuleAttribTag_AdditionalInfo_Value;

/* --- Structure ModuleAttribTag_AdditionalInfo_Value --- */

struct M_ModuleAttribTag_AdditionalInfo_Value {
  M_Word v;
};

/* --- Union ModuleAttribTag__Value --- */

union M_ModuleAttribTag__Value {
  M_ModuleAttribTag_PhysSerial_Value physserial;
  M_ModuleAttribTag_Challenge_Value challenge;
  M_ModuleAttribTag_FeatureGoldCert_Value featuregoldcert;
  M_ModuleAttribTag_KNSO_Value knso;
  M_ModuleAttribTag_KLF_Value klf;
  M_ModuleAttribTag_KMList_Value kmlist;
  M_ModuleAttribTag_ESN_Value esn;
  M_ModuleAttribTag_KML_Value kml;
  M_ModuleAttribTag_Enquiry_Value enquiry;
  M_ModuleAttribTag_AdditionalInfo_Value additionalinfo;
};

/* --- Structure ModuleAttrib --- */

struct M_ModuleAttrib {
  M_ModuleAttribTag tag;
  union M_ModuleAttribTag__Value value;
};

/* --- Union UseLim__Details --- */

typedef union M_UseLim__Details M_UseLim__Details;

/* --- Structure UseLim_Global_Details --- */

typedef struct M_UseLim_Global_Details M_UseLim_Global_Details;

/* --- Structure UseLim_Global_Details --- */

struct M_UseLim_Global_Details {
  M_LimitID id;
  M_Word max;
};

/* --- Structure UseLim_Time_Details --- */

typedef struct M_UseLim_Time_Details M_UseLim_Time_Details;

/* --- Structure UseLim_Time_Details --- */

struct M_UseLim_Time_Details {
  M_Word seconds;
};

/* --- Structure UseLim_Auth_Details --- */

typedef struct M_UseLim_Auth_Details M_UseLim_Auth_Details;

/* --- Structure UseLim_Auth_Details --- */

struct M_UseLim_Auth_Details {
  M_LimitID id;
  M_Word max;
};

/* --- Structure UseLim_NonVolatile_Details --- */

typedef struct M_UseLim_NonVolatile_Details M_UseLim_NonVolatile_Details;

/* --- Flags word UseLim_NonVolatile_Details_flags --- */

typedef M_Word M_UseLim_NonVolatile_Details_flags;

/* --- Structure UseLim_NonVolatile_Details --- */

struct M_UseLim_NonVolatile_Details {
  M_UseLim_NonVolatile_Details_flags flags;
  M_FileID file;
  M_NVMemRange range;
  M_Word maxlo;
  M_Word maxhi;
  M_Word prefetch;
};

/* --- Union UseLim__Details --- */

union M_UseLim__Details {
  M_UseLim_Global_Details global;
  M_UseLim_Time_Details time;
  M_UseLim_Auth_Details auth;
  M_UseLim_NonVolatile_Details nonvolatile;
};

/* --- Structure UseLimit --- */

struct M_UseLimit {
  M_UseLim type;
  union M_UseLim__Details details;
};

/* --- Union Act__Details --- */

typedef union M_Act__Details M_Act__Details;

/* --- Structure Act_FeatureEnable_Details --- */

typedef struct M_Act_FeatureEnable_Details M_Act_FeatureEnable_Details;

/* --- Flags word Act_FeatureEnable_Details_flags --- */

typedef M_Word M_Act_FeatureEnable_Details_flags;

/* --- Structure Act_FeatureEnable_Details --- */

struct M_Act_FeatureEnable_Details {
  M_Act_FeatureEnable_Details_flags flags;
};

/* --- Structure Act_DeriveKey_Details --- */

typedef struct M_Act_DeriveKey_Details M_Act_DeriveKey_Details;

/* --- Flags word Act_DeriveKey_Details_flags --- */

typedef M_Word M_Act_DeriveKey_Details_flags;

/* --- Structure KeyRoleID --- */

typedef struct M_KeyRoleID M_KeyRoleID;

/* --- Vector vec_KeyRoleID --- */

typedef M_KeyRoleID *M_vec_KeyRoleID;

/* --- Structure Act_DeriveKey_Details --- */

struct M_Act_DeriveKey_Details {
  M_Act_DeriveKey_Details_flags flags;
  M_DeriveRole role;
  M_DeriveMech mech;
  int n_otherkeys;
  M_vec_KeyRoleID otherkeys;
};

/* --- Structure Act_SendShare_Details --- */

typedef struct M_Act_SendShare_Details M_Act_SendShare_Details;

/* --- Flags word Act_SendShare_Details_flags --- */

typedef M_Word M_Act_SendShare_Details_flags;

/* --- Structure ReadShareDetails --- */

typedef struct M_ReadShareDetails M_ReadShareDetails;

/* --- Structure Act_SendShare_Details --- */

struct M_Act_SendShare_Details {
  M_Act_SendShare_Details_flags flags;
  M_RemoteModule *rm;
  M_ReadShareDetails *rsd;
};

/* --- Structure Act_NVMemUseLimit_Details --- */

typedef struct M_Act_NVMemUseLimit_Details M_Act_NVMemUseLimit_Details;

/* --- Flags word Act_NVMemUseLimit_Details_flags --- */

typedef M_Word M_Act_NVMemUseLimit_Details_flags;

/* --- Vector vec_KeyHash --- */

typedef M_KeyHash *M_vec_KeyHash;

/* --- Structure Act_NVMemUseLimit_Details --- */

struct M_Act_NVMemUseLimit_Details {
  M_Act_NVMemUseLimit_Details_flags flags;
  M_NVMemRange range;
  int n_hks;
  M_vec_KeyHash hks;
};

/* --- Structure Act_NVMemOpPerms_Details --- */

typedef struct M_Act_NVMemOpPerms_Details M_Act_NVMemOpPerms_Details;

/* --- Flags word Act_NVMemOpPerms_Details_perms --- */

typedef M_Word M_Act_NVMemOpPerms_Details_perms;

/* --- Structure Act_NVMemOpPerms_Details --- */

struct M_Act_NVMemOpPerms_Details {
  M_Act_NVMemOpPerms_Details_perms perms;
  M_NVMemRange *subrange;
  M_NVMemRange *exactrange;
  M_Word *incdeclimit;
};

/* --- Structure Act_StaticFeatureEnable_Details --- */

typedef struct M_Act_StaticFeatureEnable_Details M_Act_StaticFeatureEnable_Details;

/* --- Structure Act_StaticFeatureEnable_Details --- */

struct M_Act_StaticFeatureEnable_Details {
  M_FeatureInfo info;
};

/* --- Structure Act_NSOPermissions_Details --- */

typedef struct M_Act_NSOPermissions_Details M_Act_NSOPermissions_Details;

/* --- Structure Act_NSOPermissions_Details --- */

struct M_Act_NSOPermissions_Details {
  M_NSOPerms perms;
};

/* --- Structure Act_OpPermissions_Details --- */

typedef struct M_Act_OpPermissions_Details M_Act_OpPermissions_Details;

/* --- Flags word Act_OpPermissions_Details_perms --- */

typedef M_Word M_Act_OpPermissions_Details_perms;

/* --- Structure Act_OpPermissions_Details --- */

struct M_Act_OpPermissions_Details {
  M_Act_OpPermissions_Details_perms perms;
};

/* --- Structure Act_MakeArchiveBlob_Details --- */

typedef struct M_Act_MakeArchiveBlob_Details M_Act_MakeArchiveBlob_Details;

/* --- Flags word Act_MakeArchiveBlob_Details_flags --- */

typedef M_Word M_Act_MakeArchiveBlob_Details_flags;

/* --- Structure Act_MakeArchiveBlob_Details --- */

struct M_Act_MakeArchiveBlob_Details {
  M_Act_MakeArchiveBlob_Details_flags flags;
  M_Mech mech;
  M_KeyHash *kahash;
};

/* --- Structure Act_MakeBlob_Details --- */

typedef struct M_Act_MakeBlob_Details M_Act_MakeBlob_Details;

/* --- Flags word Act_MakeBlob_Details_flags --- */

typedef M_Word M_Act_MakeBlob_Details_flags;

/* --- Structure Act_MakeBlob_Details --- */

struct M_Act_MakeBlob_Details {
  M_Act_MakeBlob_Details_flags flags;
  M_KMHash *kmhash;
  M_TokenHash *kthash;
  M_TokenParams *ktparams;
};

/* --- Structure Act_UserAction_Details --- */

typedef struct M_Act_UserAction_Details M_Act_UserAction_Details;

/* --- Structure Act_UserAction_Details --- */

struct M_Act_UserAction_Details {
  M_UserActionInfo allow;
};

/* --- Structure Act_ReadShare_Details --- */

typedef struct M_Act_ReadShare_Details M_Act_ReadShare_Details;

/* --- Flags word ReadShareDetails_flags --- */

typedef M_Word M_ReadShareDetails_flags;

/* --- Structure ReadShareDetails --- */

struct M_ReadShareDetails {
  M_ReadShareDetails_flags flags;
};

/* --- Structure Act_ReadShare_Details --- */

struct M_Act_ReadShare_Details {
  M_ReadShareDetails rsd;
};

/* --- Union Act__Details --- */

union M_Act__Details {
  M_Act_FeatureEnable_Details featureenable;
  M_Act_DeriveKey_Details derivekey;
  M_Act_SendShare_Details sendshare;
  M_Act_NVMemUseLimit_Details nvmemuselimit;
  M_Act_NVMemOpPerms_Details nvmemopperms;
  M_Act_StaticFeatureEnable_Details staticfeatureenable;
  M_Act_NSOPermissions_Details nsopermissions;
  M_Act_OpPermissions_Details oppermissions;
  M_Act_MakeArchiveBlob_Details makearchiveblob;
  M_Act_MakeBlob_Details makeblob;
  M_Act_UserAction_Details useraction;
  M_Act_ReadShare_Details readshare;
};

/* --- Structure Action --- */

struct M_Action {
  M_Act type;
  union M_Act__Details details;
};

/* --- Structure KeyHashAttrib --- */

struct M_KeyHashAttrib {
  M_KeyHash hk;
  M_Mech mech_i;
  M_Mech mech_c;
};

/* --- Structure KeyRoleID --- */

struct M_KeyRoleID {
  M_DeriveRole role;
  M_KeyHash hash;
};

/* --- Structure Reply --- */

typedef struct M_Reply M_Reply;

/* --- Flags word Reply_flags --- */

typedef M_Word M_Reply_flags;

/* --- Union Cmd__Reply --- */

typedef union M_Cmd__Reply M_Cmd__Reply;

/* --- Structure Cmd_Encrypt_Reply --- */

typedef struct M_Cmd_Encrypt_Reply M_Cmd_Encrypt_Reply;

/* --- Structure Cmd_Encrypt_Reply --- */

struct M_Cmd_Encrypt_Reply {
  M_CipherText cipher;
};

/* --- Structure Cmd_GetRTC_Reply --- */

typedef struct M_Cmd_GetRTC_Reply M_Cmd_GetRTC_Reply;

/* --- Structure Cmd_GetRTC_Reply --- */

struct M_Cmd_GetRTC_Reply {
  M_RTCTime time;
};

/* --- Structure Cmd_ForeignTokenCmd_Reply --- */

typedef struct M_Cmd_ForeignTokenCmd_Reply M_Cmd_ForeignTokenCmd_Reply;

/* --- Union PhysTokenType__Reply --- */

typedef union M_PhysTokenType__Reply M_PhysTokenType__Reply;

/* --- Structure PhysTokenType_ISO7816_Reply --- */

typedef struct M_PhysTokenType_ISO7816_Reply M_PhysTokenType_ISO7816_Reply;

/* --- Structure PhysTokenType_ISO7816_Reply --- */

struct M_PhysTokenType_ISO7816_Reply {
  M_ByteBlock dataout;
  M_Word sw1sw2;
};

/* --- Union PhysTokenType__Reply --- */

union M_PhysTokenType__Reply {
  M_PhysTokenType_ISO7816_Reply iso7816;
};

/* --- Structure Cmd_ForeignTokenCmd_Reply --- */

struct M_Cmd_ForeignTokenCmd_Reply {
  M_PhysTokenType type;
  union M_PhysTokenType__Reply reply;
};

/* --- Structure Cmd_ImportSlot_Reply --- */

typedef struct M_Cmd_ImportSlot_Reply M_Cmd_ImportSlot_Reply;

/* --- Structure Cmd_ImportSlot_Reply --- */

struct M_Cmd_ImportSlot_Reply {
  M_SlotID slot;
};

/* --- Structure Cmd_OldExtEnquiry_Reply --- */

typedef struct M_Cmd_OldExtEnquiry_Reply M_Cmd_OldExtEnquiry_Reply;

/* --- Union OldExtEnqVer__Data --- */

typedef union M_OldExtEnqVer__Data M_OldExtEnqVer__Data;

/* --- Structure OldExtEnqVer_One_Data --- */

typedef struct M_OldExtEnqVer_One_Data M_OldExtEnqVer_One_Data;

/* --- Structure OldExtEnqVer_One_Data --- */

struct M_OldExtEnqVer_One_Data {
  M_EnquiryDataTwo two;
};

/* --- Union OldExtEnqVer__Data --- */

union M_OldExtEnqVer__Data {
  M_OldExtEnqVer_One_Data one;
};

/* --- Structure Cmd_OldExtEnquiry_Reply --- */

struct M_Cmd_OldExtEnquiry_Reply {
  M_OldExtEnqVer version;
  union M_OldExtEnqVer__Data data;
};

/* --- Structure Cmd_MakeBlob_Reply --- */

typedef struct M_Cmd_MakeBlob_Reply M_Cmd_MakeBlob_Reply;

/* --- Structure Cmd_MakeBlob_Reply --- */

struct M_Cmd_MakeBlob_Reply {
  M_ByteBlock blob;
};

/* --- Structure Cmd_GenerateLogicalToken_Reply --- */

typedef struct M_Cmd_GenerateLogicalToken_Reply M_Cmd_GenerateLogicalToken_Reply;

/* --- Structure Cmd_GenerateLogicalToken_Reply --- */

struct M_Cmd_GenerateLogicalToken_Reply {
  M_KeyID idkt;
  M_TokenHash hkt;
};

/* --- Structure Cmd_GetKMList_Reply --- */

typedef struct M_Cmd_GetKMList_Reply M_Cmd_GetKMList_Reply;

/* --- Flags word Cmd_GetKMList_Reply_flags --- */

typedef M_Word M_Cmd_GetKMList_Reply_flags;

/* --- Vector vec_KMHash --- */

typedef M_KMHash *M_vec_KMHash;

/* --- Structure Cmd_GetKMList_Reply --- */

struct M_Cmd_GetKMList_Reply {
  M_Cmd_GetKMList_Reply_flags flags;
  M_KeyHash hknso;
  int n_hkms;
  M_vec_KMHash hkms;
};

/* --- Structure Cmd_Duplicate_Reply --- */

typedef struct M_Cmd_Duplicate_Reply M_Cmd_Duplicate_Reply;

/* --- Structure Cmd_Duplicate_Reply --- */

struct M_Cmd_Duplicate_Reply {
  M_KeyID newkey;
};

/* --- Structure Cmd_GetLogicalTokenInfoEx_Reply --- */

typedef struct M_Cmd_GetLogicalTokenInfoEx_Reply M_Cmd_GetLogicalTokenInfoEx_Reply;

/* --- Flags word Cmd_GetLogicalTokenInfoEx_Reply_flags --- */

typedef M_Word M_Cmd_GetLogicalTokenInfoEx_Reply_flags;

/* --- Structure LogTokenShareInfo --- */

typedef struct M_LogTokenShareInfo M_LogTokenShareInfo;

/* --- Vector vec_LogTokenShareInfo --- */

typedef M_LogTokenShareInfo *M_vec_LogTokenShareInfo;

/* --- Structure Cmd_GetLogicalTokenInfoEx_Reply --- */

struct M_Cmd_GetLogicalTokenInfoEx_Reply {
  M_Word ver;
  M_Cmd_GetLogicalTokenInfoEx_Reply_flags flags;
  M_LogTokenState state;
  M_TokenHash hkt;
  M_KMHash hkm;
  int n_shares;
  M_vec_LogTokenShareInfo shares;
  M_Word sharesneeded;
};

/* --- Structure Cmd_ListRemoteServerPermission_Reply --- */

typedef struct M_Cmd_ListRemoteServerPermission_Reply M_Cmd_ListRemoteServerPermission_Reply;

/* --- Vector vec_RemoteServerPermission --- */

typedef M_RemoteServerPermission *M_vec_RemoteServerPermission;

/* --- Structure Cmd_ListRemoteServerPermission_Reply --- */

struct M_Cmd_ListRemoteServerPermission_Reply {
  int n_permission;
  M_vec_RemoteServerPermission permission;
};

/* --- Structure Cmd_ChannelUpdate_Reply --- */

typedef struct M_Cmd_ChannelUpdate_Reply M_Cmd_ChannelUpdate_Reply;

/* --- Structure Cmd_ChannelUpdate_Reply --- */

struct M_Cmd_ChannelUpdate_Reply {
  M_ByteBlock output;
};

/* --- Structure Cmd_GetWhichModule_Reply --- */

typedef struct M_Cmd_GetWhichModule_Reply M_Cmd_GetWhichModule_Reply;

/* --- Vector vec_ModuleID --- */

typedef M_ModuleID *M_vec_ModuleID;

/* --- Structure Cmd_GetWhichModule_Reply --- */

struct M_Cmd_GetWhichModule_Reply {
  int n_module;
  M_vec_ModuleID module;
};

/* --- Structure Cmd_GetACL_Reply --- */

typedef struct M_Cmd_GetACL_Reply M_Cmd_GetACL_Reply;

/* --- Nested nest_ACL --- */

typedef M_ACL M_nest_ACL;

/* --- Structure Cmd_GetACL_Reply --- */

struct M_Cmd_GetACL_Reply {
  M_nest_ACL acl;
};

/* --- Structure Cmd_RSAImmedSignDecrypt_Reply --- */

typedef struct M_Cmd_RSAImmedSignDecrypt_Reply M_Cmd_RSAImmedSignDecrypt_Reply;

/* --- Structure Cmd_RSAImmedSignDecrypt_Reply --- */

struct M_Cmd_RSAImmedSignDecrypt_Reply {
  M_Bignum r;
};

/* --- Structure Cmd_ANRemoteSlotDisconnected_Reply --- */

typedef struct M_Cmd_ANRemoteSlotDisconnected_Reply M_Cmd_ANRemoteSlotDisconnected_Reply;

/* --- Structure Cmd_ANRemoteSlotDisconnected_Reply --- */

struct M_Cmd_ANRemoteSlotDisconnected_Reply {
  M_PhysToken slot;
  M_Status st;
  union M_Status__ErrorInfo einfo;
};

/* --- Structure Cmd_RedeemTicket_Reply --- */

typedef struct M_Cmd_RedeemTicket_Reply M_Cmd_RedeemTicket_Reply;

/* --- Structure Cmd_RedeemTicket_Reply --- */

struct M_Cmd_RedeemTicket_Reply {
  M_KeyID obj;
};

/* --- Structure Cmd_GetTicket_Reply --- */

typedef struct M_Cmd_GetTicket_Reply M_Cmd_GetTicket_Reply;

/* --- Structure Cmd_GetTicket_Reply --- */

struct M_Cmd_GetTicket_Reply {
  M_nest_Ticket ticket;
};

/* --- Structure Cmd_GetKLF_Reply --- */

typedef struct M_Cmd_GetKLF_Reply M_Cmd_GetKLF_Reply;

/* --- Structure Cmd_GetKLF_Reply --- */

struct M_Cmd_GetKLF_Reply {
  M_KeyID idka;
};

/* --- Structure Cmd_ImpathGetInfo_Reply --- */

typedef struct M_Cmd_ImpathGetInfo_Reply M_Cmd_ImpathGetInfo_Reply;

/* --- Structure ImpathInfo --- */

typedef struct M_ImpathInfo M_ImpathInfo;

/* --- Structure ImpathInfo --- */

struct M_ImpathInfo {
  M_Word v;
  M_ImpathState state;
  M_RemoteModule rm;
};

/* --- Structure Cmd_ImpathGetInfo_Reply --- */

struct M_Cmd_ImpathGetInfo_Reply {
  M_ImpathInfo info;
};

/* --- Structure Cmd_RemoveSoftToken_Reply --- */

typedef struct M_Cmd_RemoveSoftToken_Reply M_Cmd_RemoveSoftToken_Reply;

/* --- Structure Cmd_RemoveSoftToken_Reply --- */

struct M_Cmd_RemoveSoftToken_Reply {
  M_ByteBlock data;
};

/* --- Structure Cmd_ANSlotChangeEvent_Reply --- */

typedef struct M_Cmd_ANSlotChangeEvent_Reply M_Cmd_ANSlotChangeEvent_Reply;

/* --- Flags word Cmd_ANSlotChangeEvent_Reply_flags --- */

typedef M_Word M_Cmd_ANSlotChangeEvent_Reply_flags;

/* --- Structure Cmd_ANSlotChangeEvent_Reply --- */

struct M_Cmd_ANSlotChangeEvent_Reply {
  M_Cmd_ANSlotChangeEvent_Reply_flags flags;
  M_PhysToken slot;
};

/* --- Structure Cmd_ProgrammingEndChunk_Reply --- */

typedef struct M_Cmd_ProgrammingEndChunk_Reply M_Cmd_ProgrammingEndChunk_Reply;

/* --- Flags word Cmd_ProgrammingEndChunk_Reply_flags --- */

typedef M_Word M_Cmd_ProgrammingEndChunk_Reply_flags;

/* --- Structure Cmd_ProgrammingEndChunk_Reply --- */

struct M_Cmd_ProgrammingEndChunk_Reply {
  M_Cmd_ProgrammingEndChunk_Reply_flags flags;
};

/* --- Structure Cmd_ExportSlot_Reply --- */

typedef struct M_Cmd_ExportSlot_Reply M_Cmd_ExportSlot_Reply;

/* --- Structure PollSlotData --- */

typedef struct M_PollSlotData M_PollSlotData;

/* --- Structure SlotListData --- */

typedef struct M_SlotListData M_SlotListData;

/* --- Flags word SlotListData_flags --- */

typedef M_Word M_SlotListData_flags;

/* --- Structure SlotListData --- */

struct M_SlotListData {
  M_SlotType type;
  M_SlotListData_flags flags;
  M_PhysToken token;
  union M_SlotType__SlotExData exdata;
};

/* --- Structure PollSlotData --- */

struct M_PollSlotData {
  M_Word changeevents;
  M_SlotListData sld;
};

/* --- Structure Cmd_ExportSlot_Reply --- */

struct M_Cmd_ExportSlot_Reply {
  M_PollSlotData psd;
};

/* --- Structure Cmd_Decrypt_Reply --- */

typedef struct M_Cmd_Decrypt_Reply M_Cmd_Decrypt_Reply;

/* --- Structure Cmd_Decrypt_Reply --- */

struct M_Cmd_Decrypt_Reply {
  M_PlainText plain;
};

/* --- Structure Cmd_ServerSendShare_Reply --- */

typedef struct M_Cmd_ServerSendShare_Reply M_Cmd_ServerSendShare_Reply;

/* --- Flags word Cmd_ServerSendShare_Reply_flags --- */

typedef M_Word M_Cmd_ServerSendShare_Reply_flags;

/* --- Structure Cmd_ServerSendShare_Reply --- */

struct M_Cmd_ServerSendShare_Reply {
  M_Cmd_ServerSendShare_Reply_flags flags;
  M_ByteBlock share;
};

/* --- Structure Cmd_NewEnquiry_Reply --- */

typedef struct M_Cmd_NewEnquiry_Reply M_Cmd_NewEnquiry_Reply;

/* --- Flags word Cmd_NewEnquiry_Reply_flags --- */

typedef M_Word M_Cmd_NewEnquiry_Reply_flags;

/* --- Union EnqVer__Data --- */

typedef union M_EnqVer__Data M_EnqVer__Data;

/* --- Structure EnqVer_Three_Data --- */

typedef struct M_EnqVer_Three_Data M_EnqVer_Three_Data;

/* --- Structure EnqVer_Three_Data --- */

struct M_EnqVer_Three_Data {
  M_EnquiryDataOne one;
  M_EnquiryDataTwo two;
  M_EnquiryDataThree three;
};

/* --- Structure EnqVer_Five_Data --- */

typedef struct M_EnqVer_Five_Data M_EnqVer_Five_Data;

/* --- Structure EnqVer_Five_Data --- */

struct M_EnqVer_Five_Data {
  M_EnquiryDataOne one;
  M_EnquiryDataTwo two;
  M_EnquiryDataThree three;
  M_EnquiryDataFour four;
  M_EnquiryDataFive five;
};

/* --- Structure EnqVer_Two_Data --- */

typedef struct M_EnqVer_Two_Data M_EnqVer_Two_Data;

/* --- Structure EnqVer_Two_Data --- */

struct M_EnqVer_Two_Data {
  M_EnquiryDataOne one;
  M_EnquiryDataTwo two;
};

/* --- Structure EnqVer_Six_Data --- */

typedef struct M_EnqVer_Six_Data M_EnqVer_Six_Data;

/* --- Structure EnqVer_Six_Data --- */

struct M_EnqVer_Six_Data {
  M_EnquiryDataOne one;
  M_EnquiryDataTwo two;
  M_EnquiryDataThree three;
  M_EnquiryDataFour four;
  M_EnquiryDataFive five;
  M_EnquiryDataSix six;
};

/* --- Structure EnqVer_Four_Data --- */

typedef struct M_EnqVer_Four_Data M_EnqVer_Four_Data;

/* --- Structure EnqVer_Four_Data --- */

struct M_EnqVer_Four_Data {
  M_EnquiryDataOne one;
  M_EnquiryDataTwo two;
  M_EnquiryDataThree three;
  M_EnquiryDataFour four;
};

/* --- Structure EnqVer_One_Data --- */

typedef struct M_EnqVer_One_Data M_EnqVer_One_Data;

/* --- Structure EnqVer_One_Data --- */

struct M_EnqVer_One_Data {
  M_EnquiryDataOne one;
};

/* --- Union EnqVer__Data --- */

union M_EnqVer__Data {
  M_EnqVer_Three_Data three;
  M_EnqVer_Five_Data five;
  M_EnqVer_Two_Data two;
  M_EnqVer_Six_Data six;
  M_EnqVer_Four_Data four;
  M_EnqVer_One_Data one;
};

/* --- Structure Cmd_NewEnquiry_Reply --- */

struct M_Cmd_NewEnquiry_Reply {
  M_Cmd_NewEnquiry_Reply_flags flags;
  M_ModuleID module;
  M_EnqVer version;
  union M_EnqVer__Data data;
};

/* --- Structure Cmd_ChannelOpen_Reply --- */

typedef struct M_Cmd_ChannelOpen_Reply M_Cmd_ChannelOpen_Reply;

/* --- Flags word Cmd_ChannelOpen_Reply_flags --- */

typedef M_Word M_Cmd_ChannelOpen_Reply_flags;

/* --- Structure Cmd_ChannelOpen_Reply --- */

struct M_Cmd_ChannelOpen_Reply {
  M_Cmd_ChannelOpen_Reply_flags flags;
  M_KeyID idch;
  M_IV *new_iv;
  M_ChannelOpenInfo openinfo;
};

/* --- Structure Cmd_Import_Reply --- */

typedef struct M_Cmd_Import_Reply M_Cmd_Import_Reply;

/* --- Structure Cmd_Import_Reply --- */

struct M_Cmd_Import_Reply {
  M_KeyID key;
};

/* --- Structure Cmd_Sign_Reply --- */

typedef struct M_Cmd_Sign_Reply M_Cmd_Sign_Reply;

/* --- Structure Cmd_Sign_Reply --- */

struct M_Cmd_Sign_Reply {
  M_CipherText sig;
};

/* --- Structure Cmd_GeneratePrime_Reply --- */

typedef struct M_Cmd_GeneratePrime_Reply M_Cmd_GeneratePrime_Reply;

/* --- Structure Cmd_GeneratePrime_Reply --- */

struct M_Cmd_GeneratePrime_Reply {
  M_Bignum r;
};

/* --- Structure Cmd_ExistingClient_Reply --- */

typedef struct M_Cmd_ExistingClient_Reply M_Cmd_ExistingClient_Reply;

/* --- Flags word Cmd_ExistingClient_Reply_flags --- */

typedef M_Word M_Cmd_ExistingClient_Reply_flags;

/* --- Structure Cmd_ExistingClient_Reply --- */

struct M_Cmd_ExistingClient_Reply {
  M_Cmd_ExistingClient_Reply_flags flags;
};

/* --- Structure Cmd_ForeignTokenOpen_Reply --- */

typedef struct M_Cmd_ForeignTokenOpen_Reply M_Cmd_ForeignTokenOpen_Reply;

/* --- Union PhysTokenType__Info --- */

typedef union M_PhysTokenType__Info M_PhysTokenType__Info;

/* --- Structure PhysTokenType_ISO7816_Info --- */

typedef struct M_PhysTokenType_ISO7816_Info M_PhysTokenType_ISO7816_Info;

/* --- Structure PhysTokenType_ISO7816_Info --- */

struct M_PhysTokenType_ISO7816_Info {
  M_ByteBlock atr;
};

/* --- Union PhysTokenType__Info --- */

union M_PhysTokenType__Info {
  M_PhysTokenType_ISO7816_Info iso7816;
};

/* --- Structure Cmd_ForeignTokenOpen_Reply --- */

struct M_Cmd_ForeignTokenOpen_Reply {
  M_KeyID lock;
  M_PhysTokenType type;
  union M_PhysTokenType__Info info;
};

/* --- Structure Cmd_Hash_Reply --- */

typedef struct M_Cmd_Hash_Reply M_Cmd_Hash_Reply;

/* --- Structure Cmd_Hash_Reply --- */

struct M_Cmd_Hash_Reply {
  M_CipherText sig;
};

/* --- Structure Cmd_PollSlotList_Reply --- */

typedef struct M_Cmd_PollSlotList_Reply M_Cmd_PollSlotList_Reply;

/* --- Flags word Cmd_PollSlotList_Reply_flags --- */

typedef M_Word M_Cmd_PollSlotList_Reply_flags;

/* --- Vector vec_PollSlotData --- */

typedef M_PollSlotData *M_vec_PollSlotData;

/* --- Structure Cmd_PollSlotList_Reply --- */

struct M_Cmd_PollSlotList_Reply {
  M_Cmd_PollSlotList_Reply_flags flags;
  int n_slots;
  M_vec_PollSlotData slots;
};

/* --- Structure Cmd_NVMemOp_Reply --- */

typedef struct M_Cmd_NVMemOp_Reply M_Cmd_NVMemOp_Reply;

/* --- Union NVMemOpType__OpRes --- */

typedef union M_NVMemOpType__OpRes M_NVMemOpType__OpRes;

/* --- Structure NVMemOpType_GetACL_OpRes --- */

typedef struct M_NVMemOpType_GetACL_OpRes M_NVMemOpType_GetACL_OpRes;

/* --- Structure NVMemOpType_GetACL_OpRes --- */

struct M_NVMemOpType_GetACL_OpRes {
  M_ACL acl;
};

/* --- Structure NVMemOpType_Read_OpRes --- */

typedef struct M_NVMemOpType_Read_OpRes M_NVMemOpType_Read_OpRes;

/* --- Structure NVMemOpType_Read_OpRes --- */

struct M_NVMemOpType_Read_OpRes {
  M_ByteBlock data;
};

/* --- Union NVMemOpType__OpRes --- */

union M_NVMemOpType__OpRes {
  M_NVMemOpType_GetACL_OpRes getacl;
  M_NVMemOpType_Read_OpRes read;
};

/* --- Structure Cmd_NVMemOp_Reply --- */

struct M_Cmd_NVMemOp_Reply {
  M_NVMemOpType op;
  union M_NVMemOpType__OpRes res;
};

/* --- Structure Cmd_LoadBlob_Reply --- */

typedef struct M_Cmd_LoadBlob_Reply M_Cmd_LoadBlob_Reply;

/* --- Structure Cmd_LoadBlob_Reply --- */

struct M_Cmd_LoadBlob_Reply {
  M_KeyID idka;
};

/* --- Structure Cmd_NVMemList_Reply --- */

typedef struct M_Cmd_NVMemList_Reply M_Cmd_NVMemList_Reply;

/* --- Flags word Cmd_NVMemList_Reply_flags --- */

typedef M_Word M_Cmd_NVMemList_Reply_flags;

/* --- Vector vec_FileInfo --- */

typedef M_FileInfo *M_vec_FileInfo;

/* --- Structure Cmd_NVMemList_Reply --- */

struct M_Cmd_NVMemList_Reply {
  M_Cmd_NVMemList_Reply_flags flags;
  int n_infos;
  M_vec_FileInfo infos;
};

/* --- Structure Cmd_GetSlotInfo_Reply --- */

typedef struct M_Cmd_GetSlotInfo_Reply M_Cmd_GetSlotInfo_Reply;

/* --- Flags word Cmd_GetSlotInfo_Reply_flags --- */

typedef M_Word M_Cmd_GetSlotInfo_Reply_flags;

/* --- Structure TokenInfo --- */

typedef struct M_TokenInfo M_TokenInfo;

/* --- Vector vec_TokenInfo --- */

typedef M_TokenInfo *M_vec_TokenInfo;

/* --- Structure Cmd_GetSlotInfo_Reply --- */

struct M_Cmd_GetSlotInfo_Reply {
  M_Word ic;
  M_Cmd_GetSlotInfo_Reply_flags flags;
  int n_tokens;
  M_vec_TokenInfo tokens;
  int n_files;
  M_vec_FileInfo files;
  M_Word freespace;
  M_KMHash auth_key;
};

/* --- Structure Cmd_CreateBuffer_Reply --- */

typedef struct M_Cmd_CreateBuffer_Reply M_Cmd_CreateBuffer_Reply;

/* --- Structure Cmd_CreateBuffer_Reply --- */

struct M_Cmd_CreateBuffer_Reply {
  M_KeyID id;
};

/* --- Structure Cmd_GetKML_Reply --- */

typedef struct M_Cmd_GetKML_Reply M_Cmd_GetKML_Reply;

/* --- Structure Cmd_GetKML_Reply --- */

struct M_Cmd_GetKML_Reply {
  M_KeyID idka;
};

/* --- Structure Cmd_FirmwareAuthenticate_Reply --- */

typedef struct M_Cmd_FirmwareAuthenticate_Reply M_Cmd_FirmwareAuthenticate_Reply;

/* --- Flags word Cmd_FirmwareAuthenticate_Reply_flags --- */

typedef M_Word M_Cmd_FirmwareAuthenticate_Reply_flags;

/* --- Union FwAuthType__Resp --- */

typedef union M_FwAuthType__Resp M_FwAuthType__Resp;

/* --- Structure FwAuthType_PRNG1_Resp --- */

typedef struct M_FwAuthType_PRNG1_Resp M_FwAuthType_PRNG1_Resp;

/* --- Structure FwAuthType_PRNG1_Resp --- */

struct M_FwAuthType_PRNG1_Resp {
  M_ByteBlock data;
};

/* --- Structure FwAuthType_NFFHMAC1_Resp --- */

typedef struct M_FwAuthType_NFFHMAC1_Resp M_FwAuthType_NFFHMAC1_Resp;

/* --- Structure FwAuthType_NFFHMAC1_Resp --- */

struct M_FwAuthType_NFFHMAC1_Resp {
  M_ByteBlock mac;
};

/* --- Union FwAuthType__Resp --- */

union M_FwAuthType__Resp {
  M_FwAuthType_PRNG1_Resp prng1;
  M_FwAuthType_NFFHMAC1_Resp nffhmac1;
};

/* --- Structure Cmd_FirmwareAuthenticate_Reply --- */

struct M_Cmd_FirmwareAuthenticate_Reply {
  M_Cmd_FirmwareAuthenticate_Reply_flags flags;
  M_FwAuthType type;
  union M_FwAuthType__Resp response;
};

/* --- Structure Cmd_GetChallenge_Reply --- */

typedef struct M_Cmd_GetChallenge_Reply M_Cmd_GetChallenge_Reply;

/* --- Structure Cmd_GetChallenge_Reply --- */

struct M_Cmd_GetChallenge_Reply {
  M_Nonce nonce;
};

/* --- Structure Cmd_SignModuleState_Reply --- */

typedef struct M_Cmd_SignModuleState_Reply M_Cmd_SignModuleState_Reply;

/* --- Structure ModuleCert --- */

typedef struct M_ModuleCert M_ModuleCert;

/* --- Structure ModuleCert --- */

struct M_ModuleCert {
  M_CipherText signature;
  M_ByteBlock modcertmsg;
};

/* --- Structure Cmd_SignModuleState_Reply --- */

struct M_Cmd_SignModuleState_Reply {
  M_ModuleCert cert;
};

/* --- Structure Cmd_TraceSEEWorld_Reply --- */

typedef struct M_Cmd_TraceSEEWorld_Reply M_Cmd_TraceSEEWorld_Reply;

/* --- Flags word Cmd_TraceSEEWorld_Reply_flags --- */

typedef M_Word M_Cmd_TraceSEEWorld_Reply_flags;

/* --- Structure Cmd_TraceSEEWorld_Reply --- */

struct M_Cmd_TraceSEEWorld_Reply {
  M_Cmd_TraceSEEWorld_Reply_flags flags;
  M_ByteBlock data;
};

/* --- Structure Cmd_MergeKeyIDs_Reply --- */

typedef struct M_Cmd_MergeKeyIDs_Reply M_Cmd_MergeKeyIDs_Reply;

/* --- Structure Cmd_MergeKeyIDs_Reply --- */

struct M_Cmd_MergeKeyIDs_Reply {
  M_KeyID newkey;
};

/* --- Structure Cmd_ImpathReceive_Reply --- */

typedef struct M_Cmd_ImpathReceive_Reply M_Cmd_ImpathReceive_Reply;

/* --- Structure Cmd_ImpathReceive_Reply --- */

struct M_Cmd_ImpathReceive_Reply {
  M_ByteBlock data;
};

/* --- Structure Cmd_BignumOp_Reply --- */

typedef struct M_Cmd_BignumOp_Reply M_Cmd_BignumOp_Reply;

/* --- Structure Cmd_BignumOp_Reply --- */

struct M_Cmd_BignumOp_Reply {
  int n_stackout;
  M_vec_Bignum stackout;
};

/* --- Structure Cmd_GetAppData_Reply --- */

typedef struct M_Cmd_GetAppData_Reply M_Cmd_GetAppData_Reply;

/* --- Structure Cmd_GetAppData_Reply --- */

struct M_Cmd_GetAppData_Reply {
  M_AppData appdata;
};

/* --- Structure Cmd_GetSlotList_Reply --- */

typedef struct M_Cmd_GetSlotList_Reply M_Cmd_GetSlotList_Reply;

/* --- Vector vec_SlotListData --- */

typedef M_SlotListData *M_vec_SlotListData;

/* --- Structure Cmd_GetSlotList_Reply --- */

struct M_Cmd_GetSlotList_Reply {
  int n_slots;
  M_vec_SlotListData slots;
};

/* --- Structure Cmd_ReceiveShare_Reply --- */

typedef struct M_Cmd_ReceiveShare_Reply M_Cmd_ReceiveShare_Reply;

/* --- Structure Cmd_ReceiveShare_Reply --- */

struct M_Cmd_ReceiveShare_Reply {
  M_Word sharesleft;
};

/* --- Structure Cmd_ImpathSend_Reply --- */

typedef struct M_Cmd_ImpathSend_Reply M_Cmd_ImpathSend_Reply;

/* --- Structure Cmd_ImpathSend_Reply --- */

struct M_Cmd_ImpathSend_Reply {
  M_ByteBlock cipher;
};

/* --- Structure Cmd_GetKeyInfoEx_Reply --- */

typedef struct M_Cmd_GetKeyInfoEx_Reply M_Cmd_GetKeyInfoEx_Reply;

/* --- Flags word Cmd_GetKeyInfoEx_Reply_flags --- */

typedef M_Word M_Cmd_GetKeyInfoEx_Reply_flags;

/* --- Structure Cmd_GetKeyInfoEx_Reply --- */

struct M_Cmd_GetKeyInfoEx_Reply {
  M_Word ver;
  M_Cmd_GetKeyInfoEx_Reply_flags flags;
  M_KeyType type;
  M_Word length;
  M_KeyHash hash;
};

/* --- Structure Cmd_ReadFile_Reply --- */

typedef struct M_Cmd_ReadFile_Reply M_Cmd_ReadFile_Reply;

/* --- Structure Cmd_ReadFile_Reply --- */

struct M_Cmd_ReadFile_Reply {
  M_ByteBlock data;
};

/* --- Structure Cmd_OldEnquiry_Reply --- */

typedef struct M_Cmd_OldEnquiry_Reply M_Cmd_OldEnquiry_Reply;

/* --- Structure Cmd_OldEnquiry_Reply --- */

struct M_Cmd_OldEnquiry_Reply {
  M_EnquiryDataOne one;
};

/* --- Structure Cmd_InsertSoftToken_Reply --- */

typedef struct M_Cmd_InsertSoftToken_Reply M_Cmd_InsertSoftToken_Reply;

/* --- Structure Cmd_InsertSoftToken_Reply --- */

struct M_Cmd_InsertSoftToken_Reply {
  M_Word ic;
};

/* --- Structure Cmd_ProgrammingGetKeyList_Reply --- */

typedef struct M_Cmd_ProgrammingGetKeyList_Reply M_Cmd_ProgrammingGetKeyList_Reply;

/* --- Structure ProgrammingKeyListEntry --- */

typedef struct M_ProgrammingKeyListEntry M_ProgrammingKeyListEntry;

/* --- Vector vec_ProgrammingKeyListEntry --- */

typedef M_ProgrammingKeyListEntry *M_vec_ProgrammingKeyListEntry;

/* --- Structure Cmd_ProgrammingGetKeyList_Reply --- */

struct M_Cmd_ProgrammingGetKeyList_Reply {
  M_Word vsn;
  int n_kfcs;
  M_vec_ProgrammingKeyListEntry kfcs;
  int n_kfis;
  M_vec_ProgrammingKeyListEntry kfis;
};

/* --- Structure Cmd_GetKeyInfo_Reply --- */

typedef struct M_Cmd_GetKeyInfo_Reply M_Cmd_GetKeyInfo_Reply;

/* --- Structure Cmd_GetKeyInfo_Reply --- */

struct M_Cmd_GetKeyInfo_Reply {
  M_KeyType type;
  M_KeyHash hash;
};

/* --- Structure Cmd_StatGetValues_Reply --- */

typedef struct M_Cmd_StatGetValues_Reply M_Cmd_StatGetValues_Reply;

/* --- Flags word Cmd_StatGetValues_Reply_flags --- */

typedef M_Word M_Cmd_StatGetValues_Reply_flags;

/* --- Structure StatInfo --- */

typedef struct M_StatInfo M_StatInfo;

/* --- Vector vec_StatInfo --- */

typedef M_StatInfo *M_vec_StatInfo;

/* --- Structure Cmd_StatGetValues_Reply --- */

struct M_Cmd_StatGetValues_Reply {
  M_Cmd_StatGetValues_Reply_flags flags;
  int n_statinfos;
  M_vec_StatInfo statinfos;
  int n_values;
  M_vec_Word values;
};

/* --- Structure Cmd_AddRemoteServerPermission_Reply --- */

typedef struct M_Cmd_AddRemoteServerPermission_Reply M_Cmd_AddRemoteServerPermission_Reply;

/* --- Structure Cmd_AddRemoteServerPermission_Reply --- */

struct M_Cmd_AddRemoteServerPermission_Reply {
  M_Word permid;
};

/* --- Structure Cmd_Export_Reply --- */

typedef struct M_Cmd_KeyExport_Reply M_Cmd_KeyExport_Reply;

/* --- Structure Cmd_Export_Reply --- */

struct M_Cmd_KeyExport_Reply {
  M_KeyData data;
};

/* --- Structure Cmd_GetLogicalTokenInfo_Reply --- */

typedef struct M_Cmd_GetLogicalTokenInfo_Reply M_Cmd_GetLogicalTokenInfo_Reply;

/* --- Structure Cmd_GetLogicalTokenInfo_Reply --- */

struct M_Cmd_GetLogicalTokenInfo_Reply {
  M_LogTokenState state;
  M_TokenHash hkt;
  int n_shares;
  M_vec_LogTokenShareInfo shares;
  M_Word sharesneeded;
};

/* --- Structure Cmd_CreateSEEWorld_Reply --- */

typedef struct M_Cmd_CreateSEEWorld_Reply M_Cmd_CreateSEEWorld_Reply;

/* --- Structure Cmd_CreateSEEWorld_Reply --- */

struct M_Cmd_CreateSEEWorld_Reply {
  M_Word initstatus;
  M_KeyID worldid;
};

/* --- Structure Cmd_ANModuleChangeEvent_Reply --- */

typedef struct M_Cmd_ANModuleChangeEvent_Reply M_Cmd_ANModuleChangeEvent_Reply;

/* --- Flags word Cmd_ANModuleChangeEvent_Reply_flags --- */

typedef M_Word M_Cmd_ANModuleChangeEvent_Reply_flags;

/* --- Structure Cmd_ANModuleChangeEvent_Reply --- */

struct M_Cmd_ANModuleChangeEvent_Reply {
  M_Cmd_ANModuleChangeEvent_Reply_flags flags;
  M_ModuleID module;
};

/* --- Structure Cmd_ModuleInfo_Reply --- */

typedef struct M_Cmd_ModuleInfo_Reply M_Cmd_ModuleInfo_Reply;

/* --- Union InfoFormat__Info --- */

typedef union M_InfoFormat__Info M_InfoFormat__Info;

/* --- Structure InfoFormat_HardwareRev2_Info --- */

typedef struct M_InfoFormat_HardwareRev2_Info M_InfoFormat_HardwareRev2_Info;

/* --- Structure DeviceID --- */

typedef struct M_DeviceID M_DeviceID;

/* --- Vector vec_DeviceID --- */

typedef M_DeviceID *M_vec_DeviceID;

/* --- Structure InfoFormat_HardwareRev2_Info --- */

struct M_InfoFormat_HardwareRev2_Info {
  int n_devices;
  M_vec_DeviceID devices;
};

/* --- Structure InfoFormat_HardwareRev1_Info --- */

typedef struct M_InfoFormat_HardwareRev1_Info M_InfoFormat_HardwareRev1_Info;

/* --- Flags word InfoFormat_HardwareRev1_Info_flags --- */

typedef M_Word M_InfoFormat_HardwareRev1_Info_flags;

/* --- Structure InfoFormat_HardwareRev1_Info --- */

struct M_InfoFormat_HardwareRev1_Info {
  M_InfoFormat_HardwareRev1_Info_flags flags;
  M_Word base_code;
  M_Word io_code;
  M_Word scsi_id;
  M_Word links;
  M_Word n_cpus;
  M_Word ram_size;
};

/* --- Union InfoFormat__Info --- */

union M_InfoFormat__Info {
  M_InfoFormat_HardwareRev2_Info hardwarerev2;
  M_InfoFormat_HardwareRev1_Info hardwarerev1;
};

/* --- Structure Cmd_ModuleInfo_Reply --- */

struct M_Cmd_ModuleInfo_Reply {
  M_InfoFormat format;
  union M_InfoFormat__Info info;
};

/* --- Structure Cmd_ModExp_Reply --- */

typedef struct M_Cmd_ModExp_Reply M_Cmd_ModExp_Reply;

/* --- Structure Cmd_ModExp_Reply --- */

struct M_Cmd_ModExp_Reply {
  M_Bignum r;
};

/* --- Structure Cmd_UpdateMergedKey_Reply --- */

typedef struct M_Cmd_UpdateMergedKey_Reply M_Cmd_UpdateMergedKey_Reply;

/* --- Structure Cmd_UpdateMergedKey_Reply --- */

struct M_Cmd_UpdateMergedKey_Reply {
  int n_keys;
  M_vec_KeyID keys;
};

/* --- Structure Cmd_SEEJob_Reply --- */

typedef struct M_Cmd_SEEJob_Reply M_Cmd_SEEJob_Reply;

/* --- Structure Cmd_SEEJob_Reply --- */

struct M_Cmd_SEEJob_Reply {
  M_ByteBlock seereply;
};

/* --- Structure Cmd_ReadShare_Reply --- */

typedef struct M_Cmd_ReadShare_Reply M_Cmd_ReadShare_Reply;

/* --- Structure Cmd_ReadShare_Reply --- */

struct M_Cmd_ReadShare_Reply {
  M_Word sharesleft;
};

/* --- Structure Cmd_SendShare_Reply --- */

typedef struct M_Cmd_SendShare_Reply M_Cmd_SendShare_Reply;

/* --- Flags word Cmd_SendShare_Reply_flags --- */

typedef M_Word M_Cmd_SendShare_Reply_flags;

/* --- Structure Cmd_SendShare_Reply --- */

struct M_Cmd_SendShare_Reply {
  M_Cmd_SendShare_Reply_flags flags;
  M_ByteBlock share;
};

/* --- Structure Cmd_ImpathKXBegin_Reply --- */

typedef struct M_Cmd_ImpathKXBegin_Reply M_Cmd_ImpathKXBegin_Reply;

/* --- Structure Cmd_ImpathKXBegin_Reply --- */

struct M_Cmd_ImpathKXBegin_Reply {
  M_ImpathID imp;
  M_ByteBlock kx;
};

/* --- Structure Cmd_GetClientHash_Reply --- */

typedef struct M_Cmd_GetClientHash_Reply M_Cmd_GetClientHash_Reply;

/* --- Structure Cmd_GetClientHash_Reply --- */

struct M_Cmd_GetClientHash_Reply {
  M_Hash hclientid;
};

/* --- Structure Cmd_ProgrammingBeginChunk_Reply --- */

typedef struct M_Cmd_ProgrammingBeginChunk_Reply M_Cmd_ProgrammingBeginChunk_Reply;

/* --- Structure Cmd_ProgrammingBeginChunk_Reply --- */

struct M_Cmd_ProgrammingBeginChunk_Reply {
  M_Word maxblocksize;
};

/* --- Structure Cmd_PollModuleState_Reply --- */

typedef struct M_Cmd_PollModuleState_Reply M_Cmd_PollModuleState_Reply;

/* --- Flags word Cmd_PollModuleState_Reply_flags --- */

typedef M_Word M_Cmd_PollModuleState_Reply_flags;

/* --- Structure Cmd_PollModuleState_Reply --- */

struct M_Cmd_PollModuleState_Reply {
  M_Word version;
  M_Cmd_PollModuleState_Reply_flags flags;
  M_Word stateevents;
  M_Word nvmemevents;
  M_Word rtcadjusts;
};

/* --- Structure Cmd_LoadLogicalToken_Reply --- */

typedef struct M_Cmd_LoadLogicalToken_Reply M_Cmd_LoadLogicalToken_Reply;

/* --- Structure Cmd_LoadLogicalToken_Reply --- */

struct M_Cmd_LoadLogicalToken_Reply {
  M_KeyID idkt;
};

/* --- Structure Cmd_DeriveKey_Reply --- */

typedef struct M_Cmd_DeriveKey_Reply M_Cmd_DeriveKey_Reply;

/* --- Structure Cmd_DeriveKey_Reply --- */

struct M_Cmd_DeriveKey_Reply {
  M_KeyID key;
};

/* --- Structure Cmd_StatEnumTree_Reply --- */

typedef struct M_Cmd_StatEnumTree_Reply M_Cmd_StatEnumTree_Reply;

/* --- Flags word Cmd_StatEnumTree_Reply_flags --- */

typedef M_Word M_Cmd_StatEnumTree_Reply_flags;

/* --- Structure Cmd_StatEnumTree_Reply --- */

struct M_Cmd_StatEnumTree_Reply {
  M_Cmd_StatEnumTree_Reply_flags flags;
  int n_statinfos;
  M_vec_StatInfo statinfos;
  int n_subnodetags;
  M_vec_Word subnodetags;
};

/* --- Structure Cmd_GenerateKey_Reply --- */

typedef struct M_Cmd_GenerateKey_Reply M_Cmd_GenerateKey_Reply;

/* --- Flags word Cmd_GenerateKey_Reply_flags --- */

typedef M_Word M_Cmd_GenerateKey_Reply_flags;

/* --- Structure Cmd_GenerateKey_Reply --- */

struct M_Cmd_GenerateKey_Reply {
  M_Cmd_GenerateKey_Reply_flags flags;
  M_KeyID key;
  M_ModuleCert *cert;
};

/* --- Structure Cmd_GenerateKeyPair_Reply --- */

typedef struct M_Cmd_GenerateKeyPair_Reply M_Cmd_GenerateKeyPair_Reply;

/* --- Flags word Cmd_GenerateKeyPair_Reply_flags --- */

typedef M_Word M_Cmd_GenerateKeyPair_Reply_flags;

/* --- Structure Cmd_GenerateKeyPair_Reply --- */

struct M_Cmd_GenerateKeyPair_Reply {
  M_Cmd_GenerateKeyPair_Reply_flags flags;
  M_KeyID keypriv;
  M_KeyID keypub;
  M_ModuleCert *certpriv;
  M_ModuleCert *certpub;
};

/* --- Structure Cmd_GetShareACL_Reply --- */

typedef struct M_Cmd_GetShareACL_Reply M_Cmd_GetShareACL_Reply;

/* --- Structure Cmd_GetShareACL_Reply --- */

struct M_Cmd_GetShareACL_Reply {
  M_ACL acl;
};

/* --- Structure Cmd_GenerateRandom_Reply --- */

typedef struct M_Cmd_GenerateRandom_Reply M_Cmd_GenerateRandom_Reply;

/* --- Structure Cmd_GenerateRandom_Reply --- */

struct M_Cmd_GenerateRandom_Reply {
  M_ByteBlock data;
};

/* --- Structure Cmd_NewClient_Reply --- */

typedef struct M_Cmd_NewClient_Reply M_Cmd_NewClient_Reply;

/* --- Flags word Cmd_NewClient_Reply_flags --- */

typedef M_Word M_Cmd_NewClient_Reply_flags;

/* --- Structure Cmd_NewClient_Reply --- */

struct M_Cmd_NewClient_Reply {
  M_Cmd_NewClient_Reply_flags flags;
  M_ClientID client;
};

/* --- Structure Cmd_GetWorldSigners_Reply --- */

typedef struct M_Cmd_GetWorldSigners_Reply M_Cmd_GetWorldSigners_Reply;

/* --- Structure Cmd_GetWorldSigners_Reply --- */

struct M_Cmd_GetWorldSigners_Reply {
  int n_sigs;
  M_vec_KeyHashAndMech sigs;
};

/* --- Structure Cmd_PauseForNotifications_Reply --- */

typedef struct M_Cmd_PauseForNotifications_Reply M_Cmd_PauseForNotifications_Reply;

/* --- Flags word Cmd_PauseForNotifications_Reply_flags --- */

typedef M_Word M_Cmd_PauseForNotifications_Reply_flags;

/* --- Structure Cmd_PauseForNotifications_Reply --- */

struct M_Cmd_PauseForNotifications_Reply {
  M_Cmd_PauseForNotifications_Reply_flags flags;
};

/* --- Union Cmd__Reply --- */

union M_Cmd__Reply {
  M_Cmd_Encrypt_Reply encrypt;
  M_Cmd_GetRTC_Reply getrtc;
  M_Cmd_ForeignTokenCmd_Reply foreigntokencmd;
  M_Cmd_ImportSlot_Reply importslot;
  M_Cmd_OldExtEnquiry_Reply oldextenquiry;
  M_Cmd_MakeBlob_Reply makeblob;
  M_Cmd_GenerateLogicalToken_Reply generatelogicaltoken;
  M_Cmd_GetKMList_Reply getkmlist;
  M_Cmd_Duplicate_Reply duplicate;
  M_Cmd_GetLogicalTokenInfoEx_Reply getlogicaltokeninfoex;
  M_Cmd_ListRemoteServerPermission_Reply listremoteserverpermission;
  M_Cmd_ChannelUpdate_Reply channelupdate;
  M_Cmd_GetWhichModule_Reply getwhichmodule;
  M_Cmd_GetACL_Reply getacl;
  M_Cmd_RSAImmedSignDecrypt_Reply rsaimmedsigndecrypt;
  M_Cmd_ANRemoteSlotDisconnected_Reply anremoteslotdisconnected;
  M_Cmd_RedeemTicket_Reply redeemticket;
  M_Cmd_GetTicket_Reply getticket;
  M_Cmd_GetKLF_Reply getklf;
  M_Cmd_ImpathGetInfo_Reply impathgetinfo;
  M_Cmd_RemoveSoftToken_Reply removesofttoken;
  M_Cmd_ANSlotChangeEvent_Reply anslotchangeevent;
  M_Cmd_ProgrammingEndChunk_Reply programmingendchunk;
  M_Cmd_ExportSlot_Reply exportslot;
  M_Cmd_Decrypt_Reply decrypt;
  M_Cmd_ServerSendShare_Reply serversendshare;
  M_Cmd_NewEnquiry_Reply newenquiry;
  M_Cmd_ChannelOpen_Reply channelopen;
  M_Cmd_Import_Reply import;
  M_Cmd_Sign_Reply sign;
  M_Cmd_GeneratePrime_Reply generateprime;
  M_Cmd_ExistingClient_Reply existingclient;
  M_Cmd_ForeignTokenOpen_Reply foreigntokenopen;
  M_Cmd_Hash_Reply hash;
  M_Cmd_PollSlotList_Reply pollslotlist;
  M_Cmd_NVMemOp_Reply nvmemop;
  M_Cmd_LoadBlob_Reply loadblob;
  M_Cmd_NVMemList_Reply nvmemlist;
  M_Cmd_GetSlotInfo_Reply getslotinfo;
  M_Cmd_CreateBuffer_Reply createbuffer;
  M_Cmd_GetKML_Reply getkml;
  M_Cmd_FirmwareAuthenticate_Reply firmwareauthenticate;
  M_Cmd_GetChallenge_Reply getchallenge;
  M_Cmd_SignModuleState_Reply signmodulestate;
  M_Cmd_TraceSEEWorld_Reply traceseeworld;
  M_Cmd_MergeKeyIDs_Reply mergekeyids;
  M_Cmd_ImpathReceive_Reply impathreceive;
  M_Cmd_BignumOp_Reply bignumop;
  M_Cmd_GetAppData_Reply getappdata;
  M_Cmd_GetSlotList_Reply getslotlist;
  M_Cmd_ReceiveShare_Reply receiveshare;
  M_Cmd_ImpathSend_Reply impathsend;
  M_Cmd_GetKeyInfoEx_Reply getkeyinfoex;
  M_Cmd_ReadFile_Reply readfile;
  M_Cmd_OldEnquiry_Reply oldenquiry;
  M_Cmd_InsertSoftToken_Reply insertsofttoken;
  M_Cmd_ProgrammingGetKeyList_Reply programminggetkeylist;
  M_Cmd_GetKeyInfo_Reply getkeyinfo;
  M_Cmd_StatGetValues_Reply statgetvalues;
  M_Cmd_AddRemoteServerPermission_Reply addremoteserverpermission;
  M_Cmd_KeyExport_Reply keyexport;
  M_Cmd_GetLogicalTokenInfo_Reply getlogicaltokeninfo;
  M_Cmd_CreateSEEWorld_Reply createseeworld;
  M_Cmd_ANModuleChangeEvent_Reply anmodulechangeevent;
  M_Cmd_ModuleInfo_Reply moduleinfo;
  M_Cmd_ModExp_Reply modexp;
  M_Cmd_UpdateMergedKey_Reply updatemergedkey;
  M_Cmd_SEEJob_Reply seejob;
  M_Cmd_ReadShare_Reply readshare;
  M_Cmd_SendShare_Reply sendshare;
  M_Cmd_ImpathKXBegin_Reply impathkxbegin;
  M_Cmd_GetClientHash_Reply getclienthash;
  M_Cmd_ProgrammingBeginChunk_Reply programmingbeginchunk;
  M_Cmd_PollModuleState_Reply pollmodulestate;
  M_Cmd_LoadLogicalToken_Reply loadlogicaltoken;
  M_Cmd_DeriveKey_Reply derivekey;
  M_Cmd_StatEnumTree_Reply statenumtree;
  M_Cmd_GenerateKey_Reply generatekey;
  M_Cmd_GenerateKeyPair_Reply generatekeypair;
  M_Cmd_GetShareACL_Reply getshareacl;
  M_Cmd_GenerateRandom_Reply generaterandom;
  M_Cmd_NewClient_Reply newclient;
  M_Cmd_GetWorldSigners_Reply getworldsigners;
  M_Cmd_PauseForNotifications_Reply pausefornotifications;
};

/* --- Structure Reply --- */

struct M_Reply {
  M_Tag tag;
  M_Cmd cmd;
  M_Status status;
  M_Reply_flags flags;
  union M_Cmd__Reply reply;
  union M_Status__ErrorInfo errorinfo;
};

/* --- Structure LogTokenShareInfo --- */

struct M_LogTokenShareInfo {
  M_LogTokenShareState state;
};

/* --- Flags word TokenInfo_flags --- */

typedef M_Word M_TokenInfo_flags;

/* --- Structure TokenInfo --- */

struct M_TokenInfo {
  M_TokenInfo_flags flags;
  M_ShortHash hkt;
  M_Word i;
};

/* --- Structure ProgrammingKeyListEntry --- */

struct M_ProgrammingKeyListEntry {
  M_KeyType type;
  M_KeyHash hash;
};

/* --- Flags word StatInfo_flags --- */

typedef M_Word M_StatInfo_flags;

/* --- Structure StatInfo --- */

struct M_StatInfo {
  M_StatID id;
  M_StatInfo_flags flags;
};

/* --- Structure DeviceID --- */

struct M_DeviceID {
  M_BusType bus;
  M_Word id;
  M_Word other;
};

/* --- Structure ImageMetaDataHeader --- */

typedef struct M_ImageMetaDataHeader M_ImageMetaDataHeader;

/* --- Structure ImageMetaDataHeader --- */

struct M_ImageMetaDataHeader {
  M_Word len;
  M_Hash hash;
};

/* --- Structure ImageMetaData --- */

typedef struct M_ImageMetaData M_ImageMetaData;

/* --- Structure KeyEntry --- */

typedef struct M_KeyEntry M_KeyEntry;

/* --- Vector vec_KeyEntry --- */

typedef M_KeyEntry *M_vec_KeyEntry;

/* --- Structure ImageMetaData --- */

struct M_ImageMetaData {
  M_Hash imagehash;
  M_Word vsn;
  int n_kfcs;
  M_vec_KeyEntry kfcs;
  int n_kfis;
  M_vec_KeyEntry kfis;
};

/* --- Structure KeyEntry --- */

struct M_KeyEntry {
  M_Hash hk;
  M_KeyData k;
};

/* --- Structure OldProgrammingSignedData --- */

typedef struct M_OldProgrammingSignedData M_OldProgrammingSignedData;

/* --- Structure ProgrammingChunkMetaData --- */

typedef struct M_ProgrammingChunkMetaData M_ProgrammingChunkMetaData;

/* --- Vector vec_ProgrammingChunkMetaData --- */

typedef M_ProgrammingChunkMetaData *M_vec_ProgrammingChunkMetaData;

/* --- Structure OldProgrammingSignedData --- */

struct M_OldProgrammingSignedData {
  int n_chunks;
  M_vec_ProgrammingChunkMetaData chunks;
};

/* --- Structure ProgrammingChunkMetaData --- */

struct M_ProgrammingChunkMetaData {
  M_Word size;
  M_Word begin;
  M_Hash hash;
};

/* --- Structure ProgrammingSignedData --- */

typedef struct M_ProgrammingSignedData M_ProgrammingSignedData;

/* --- Union ProgSigDatFormat__Data --- */

typedef union M_ProgSigDatFormat__Data M_ProgSigDatFormat__Data;

/* --- Structure ProgSigDatFormat_Two_Data --- */

typedef struct M_ProgSigDatFormat_Two_Data M_ProgSigDatFormat_Two_Data;

/* --- Flags word ProgSigDatFormat_Two_Data_flags --- */

typedef M_Word M_ProgSigDatFormat_Two_Data_flags;

/* --- Structure ProgSigDatFormat_Two_Data --- */

struct M_ProgSigDatFormat_Two_Data {
  M_Word vsn;
  M_ProgSigDatFormat_Two_Data_flags flags;
  M_OldProgrammingSignedData chunks;
};

/* --- Union ProgSigDatFormat__Data --- */

union M_ProgSigDatFormat__Data {
  M_ProgSigDatFormat_Two_Data two;
};

/* --- Structure ProgrammingSignedData --- */

struct M_ProgrammingSignedData {
  M_Word newpsdmagic;
  M_ProgSigDatFormat format;
  union M_ProgSigDatFormat__Data data;
};

/* --- Structure FirmwareFileHeader --- */

typedef struct M_FirmwareFileHeader M_FirmwareFileHeader;

/* --- Structure FirmwareFileHeader --- */

struct M_FirmwareFileHeader {
  M_Hash magic;
  M_Word datalen;
  M_Hash datahash;
};

/* --- Structure FirmwareFileData --- */

typedef struct M_FirmwareFileData M_FirmwareFileData;

/* --- Union FirmwareFileType__Data --- */

typedef union M_FirmwareFileType__Data M_FirmwareFileType__Data;

/* --- Structure FirmwareFileType_TestVectors_Data --- */

typedef struct M_FirmwareFileType_TestVectors_Data M_FirmwareFileType_TestVectors_Data;

/* --- Structure FirmwareFileInfo --- */

typedef struct M_FirmwareFileInfo M_FirmwareFileInfo;

/* --- Flags word FirmwareFileInfo_flags --- */

typedef M_Word M_FirmwareFileInfo_flags;

/* --- Structure FirmwareFileInfo --- */

struct M_FirmwareFileInfo {
  M_Word moduletype;
  M_ASCIIString comment;
  M_FirmwareFileInfo_flags flags;
};

/* --- Structure FirmwareTestVectors --- */

typedef struct M_FirmwareTestVectors M_FirmwareTestVectors;

/* --- Union FTVType__Data --- */

typedef union M_FTVType__Data M_FTVType__Data;

/* --- Structure FTVType_PRNG1_Data --- */

typedef struct M_FTVType_PRNG1_Data M_FTVType_PRNG1_Data;

/* --- Structure FTVType_PRNG1_Data --- */

struct M_FTVType_PRNG1_Data {
  M_Word variant;
  M_Word maxindex;
  M_Hash hresult;
};

/* --- Union FTVType__Data --- */

union M_FTVType__Data {
  M_FTVType_PRNG1_Data prng1;
};

/* --- Structure FirmwareTestVectors --- */

struct M_FirmwareTestVectors {
  M_FTVType type;
  union M_FTVType__Data data;
};

/* --- Structure FirmwareFileType_TestVectors_Data --- */

struct M_FirmwareFileType_TestVectors_Data {
  M_FirmwareFileInfo infohdr;
  M_FirmwareTestVectors tv;
};

/* --- Structure FirmwareFileType_NFast2_Data --- */

typedef struct M_FirmwareFileType_NFast2_Data M_FirmwareFileType_NFast2_Data;

/* --- Structure FirmwareFileCommon --- */

typedef struct M_FirmwareFileCommon M_FirmwareFileCommon;

/* --- Structure FirmwareSignature --- */

typedef struct M_FirmwareSignature M_FirmwareSignature;

/* --- Vector vec_FirmwareSignature --- */

typedef M_FirmwareSignature *M_vec_FirmwareSignature;

/* --- Vector vec_CipherText --- */

typedef M_CipherText *M_vec_CipherText;

/* --- Structure FirmwareFileCommon --- */

struct M_FirmwareFileCommon {
  M_KeyHash hkfc;
  int n_sigs;
  M_vec_FirmwareSignature sigs;
  int n_chunks;
  M_vec_CipherText chunks;
};

/* --- Structure FirmwareFileType_NFast2_Data --- */

struct M_FirmwareFileType_NFast2_Data {
  M_FirmwareFileCommon common;
};

/* --- Structure FirmwareFileType_NFast3_Data --- */

typedef struct M_FirmwareFileType_NFast3_Data M_FirmwareFileType_NFast3_Data;

/* --- Structure FirmwareFileType_NFast3_Data --- */

struct M_FirmwareFileType_NFast3_Data {
  M_FirmwareFileInfo infohdr;
  M_FirmwareFileCommon common;
};

/* --- Union FirmwareFileType__Data --- */

union M_FirmwareFileType__Data {
  M_FirmwareFileType_TestVectors_Data testvectors;
  M_FirmwareFileType_NFast2_Data nfast2;
  M_FirmwareFileType_NFast3_Data nfast3;
};

/* --- Structure FirmwareFileData --- */

struct M_FirmwareFileData {
  M_FirmwareFileType type;
  union M_FirmwareFileType__Data data;
};

/* --- Structure FirmwareSignature --- */

struct M_FirmwareSignature {
  M_Hash sdhash;
  M_KeyHash hkfi;
  M_CipherText sig;
  M_ByteBlock sd;
};

/* --- Structure SigningKeys --- */

typedef struct M_SigningKeys M_SigningKeys;

/* --- Structure SigningKeyEntry --- */

typedef struct M_SigningKeyEntry M_SigningKeyEntry;

/* --- Flags word SigningKeyEntry_flags --- */

typedef M_Word M_SigningKeyEntry_flags;

/* --- Structure SigningKeyEntry --- */

struct M_SigningKeyEntry {
  M_SigningKeyEntry_flags flags;
  M_Mech mech;
  M_KeyHash hk;
  M_KeyData k;
};

/* --- Vector vec_SigningKeyEntry --- */

typedef M_SigningKeyEntry *M_vec_SigningKeyEntry;

/* --- Structure SigningKeys --- */

struct M_SigningKeys {
  M_SigningKeyEntry kfc;
  int n_kfis;
  M_vec_SigningKeyEntry kfis;
};

/* --- Structure CertSignMessage --- */

typedef struct M_CertSignMessage M_CertSignMessage;

/* --- Flags word CertSignMessage_flags --- */

typedef M_Word M_CertSignMessage_flags;

/* --- Structure CertSignMessage --- */

struct M_CertSignMessage {
  M_MagicValue header;
  M_CertSignMessage_flags flags;
  int n_hks;
  M_vec_KeyHash hks;
  M_Nonce *nonce;
  M_ACL *acl;
  M_MagicValue footer;
};

/* --- Structure ModCertMsg --- */

typedef struct M_ModCertMsg M_ModCertMsg;

/* --- Union ModCertType__ModCertData --- */

typedef union M_ModCertType__ModCertData M_ModCertType__ModCertData;

/* --- Structure ModCertType_KWARv0_ModCertData --- */

typedef struct M_ModCertType_KWARv0_ModCertData M_ModCertType_KWARv0_ModCertData;

/* --- Flags word ModCertType_KWARv0_ModCertData_flags --- */

typedef M_Word M_ModCertType_KWARv0_ModCertData_flags;

/* --- Structure ModCertType_KWARv0_ModCertData --- */

struct M_ModCertType_KWARv0_ModCertData {
  M_ModCertType_KWARv0_ModCertData_flags flags;
  M_KeyHash hkwa;
};

/* --- Structure ModCertType_OldKeyGen_ModCertData --- */

typedef struct M_ModCertType_OldKeyGen_ModCertData M_ModCertType_OldKeyGen_ModCertData;

/* --- Structure ModCertType_OldKeyGen_ModCertData --- */

struct M_ModCertType_OldKeyGen_ModCertData {
  M_KeyGenParams genparams;
  M_ACL acl;
  M_Hash hka;
};

/* --- Structure ModCertType_StateCert_ModCertData --- */

typedef struct M_ModCertType_StateCert_ModCertData M_ModCertType_StateCert_ModCertData;

/* --- Flags word ModCertType_StateCert_ModCertData_flags --- */

typedef M_Word M_ModCertType_StateCert_ModCertData_flags;

/* --- Structure ModCertType_StateCert_ModCertData --- */

struct M_ModCertType_StateCert_ModCertData {
  M_ModCertType_StateCert_ModCertData_flags flags;
  M_ModuleAttribList state;
};

/* --- Structure ModCertType_KeyGen_ModCertData --- */

typedef struct M_ModCertType_KeyGen_ModCertData M_ModCertType_KeyGen_ModCertData;

/* --- Flags word ModCertType_KeyGen_ModCertData_flags --- */

typedef M_Word M_ModCertType_KeyGen_ModCertData_flags;

/* --- Structure ModCertType_KeyGen_ModCertData --- */

struct M_ModCertType_KeyGen_ModCertData {
  M_ModCertType_KeyGen_ModCertData_flags flags;
  M_KeyGenParams genparams;
  M_ACL acl;
  M_Hash hka;
};

/* --- Structure ModCertType_ImpathKX_ModCertData --- */

typedef struct M_ModCertType_ImpathKX_ModCertData M_ModCertType_ImpathKX_ModCertData;

/* --- Structure ModCertType_ImpathKX_ModCertData --- */

struct M_ModCertType_ImpathKX_ModCertData {
  M_Nonce n;
  M_CipherText gx;
  M_ImpathKXGroup group;
  M_ImpathKXGroupSelection mygroups;
  M_ASCIIString esn;
  M_RemoteModule me;
  M_RemoteModule you;
};

/* --- Union ModCertType__ModCertData --- */

union M_ModCertType__ModCertData {
  M_ModCertType_KWARv0_ModCertData kwarv0;
  M_ModCertType_OldKeyGen_ModCertData oldkeygen;
  M_ModCertType_StateCert_ModCertData statecert;
  M_ModCertType_KeyGen_ModCertData keygen;
  M_ModCertType_ImpathKX_ModCertData impathkx;
};

/* --- Structure ModCertMsg --- */

struct M_ModCertMsg {
  M_ModCertType type;
  union M_ModCertType__ModCertData data;
};

/* --- Structure StandaloneCert --- */

typedef struct M_StandaloneCert M_StandaloneCert;

/* --- Structure StandaloneCert --- */

struct M_StandaloneCert {
  M_ByteBlock message;
  M_CipherText signature;
  M_KeyData publickey;
};

/* --- Vector vec_StandaloneCert --- */

typedef M_StandaloneCert *M_vec_StandaloneCert;

/* --- Structure wrap_vec_StandaloneCert --- */

typedef struct M_wrap_vec_StandaloneCert M_wrap_vec_StandaloneCert;

/* --- Structure wrap_vec_StandaloneCert --- */

struct M_wrap_vec_StandaloneCert {
  int n;
  M_vec_StandaloneCert v;
};

/* --- Synonym Warrant --- */

typedef M_wrap_vec_StandaloneCert M_Warrant;

/* --- Structure ModuleAttribSig --- */

typedef struct M_ModuleAttribSig M_ModuleAttribSig;

/* --- Vector vec_ModuleAttribSig --- */

typedef M_ModuleAttribSig *M_vec_ModuleAttribSig;

/* --- Structure wrap_vec_ModuleAttribSig --- */

typedef struct M_wrap_vec_ModuleAttribSig M_wrap_vec_ModuleAttribSig;

/* --- Structure wrap_vec_ModuleAttribSig --- */

struct M_wrap_vec_ModuleAttribSig {
  int n;
  M_vec_ModuleAttribSig v;
};

/* --- Synonym ModuleAttribProof --- */

typedef M_wrap_vec_ModuleAttribSig M_ModuleAttribProof;

/* --- Structure ModuleAttribSig --- */

struct M_ModuleAttribSig {
  M_ModuleAttribTag tag;
  M_KeyHash hk;
  M_CipherText c;
};

/* --- Structure BlobData --- */

typedef struct M_BlobData M_BlobData;

/* --- Union BlobFormat__BlobExData --- */

typedef union M_BlobFormat__BlobExData M_BlobFormat__BlobExData;

/* --- Structure BlobFormat_Module_BlobExData --- */

typedef struct M_BlobFormat_Module_BlobExData M_BlobFormat_Module_BlobExData;

/* --- Structure BlobFormat_Module_BlobExData --- */

struct M_BlobFormat_Module_BlobExData {
  M_KMHash hkm;
};

/* --- Structure BlobFormat_Direct_BlobExData --- */

typedef struct M_BlobFormat_Direct_BlobExData M_BlobFormat_Direct_BlobExData;

/* --- Structure BlobFormat_Direct_BlobExData --- */

struct M_BlobFormat_Direct_BlobExData {
  M_KeyHash hki;
};

/* --- Structure BlobFormat_Token_BlobExData --- */

typedef struct M_BlobFormat_Token_BlobExData M_BlobFormat_Token_BlobExData;

/* --- Structure BlobFormat_Token_BlobExData --- */

struct M_BlobFormat_Token_BlobExData {
  M_KMHash hkm;
  M_TokenHash hkt;
};

/* --- Structure BlobFormat_Indirect_BlobExData --- */

typedef struct M_BlobFormat_Indirect_BlobExData M_BlobFormat_Indirect_BlobExData;

/* --- Structure BlobFormat_Indirect_BlobExData --- */

struct M_BlobFormat_Indirect_BlobExData {
  M_KeyHash hkar;
  M_CipherText ktr_crypted;
};

/* --- Union BlobFormat__BlobExData --- */

union M_BlobFormat__BlobExData {
  M_BlobFormat_Module_BlobExData module;
  M_BlobFormat_Direct_BlobExData direct;
  M_BlobFormat_Token_BlobExData token;
  M_BlobFormat_Indirect_BlobExData indirect;
};

/* --- Structure BlobData --- */

struct M_BlobData {
  M_BlobFormat format;
  M_Word datalen;
  M_ByteBlock ka_data;
  union M_BlobFormat__BlobExData exdata;
  M_Word imech;
};

/* --- Structure ModuleChannelOpenInfo --- */

typedef struct M_ModuleChannelOpenInfo M_ModuleChannelOpenInfo;

/* --- Union ChannelType__ExtraMCOI --- */

typedef union M_ChannelType__ExtraMCOI M_ChannelType__ExtraMCOI;

/* --- Structure ChannelType_DriverDirect_ExtraMCOI --- */

typedef struct M_ChannelType_DriverDirect_ExtraMCOI M_ChannelType_DriverDirect_ExtraMCOI;

/* --- Structure ChannelType_DriverDirect_ExtraMCOI --- */

struct M_ChannelType_DriverDirect_ExtraMCOI {
  M_ModuleChannelID mcid;
};

/* --- Union ChannelType__ExtraMCOI --- */

union M_ChannelType__ExtraMCOI {
  M_ChannelType_DriverDirect_ExtraMCOI driverdirect;
};

/* --- Structure ModuleChannelOpenInfo --- */

struct M_ModuleChannelOpenInfo {
  M_ChannelType type;
  union M_ChannelType__ExtraMCOI info;
};

/* --- Structure ImpathKXMessage --- */

typedef struct M_ImpathKXMessage M_ImpathKXMessage;

/* --- Flags word ImpathKXMessage_flags --- */

typedef M_Word M_ImpathKXMessage_flags;

/* --- Structure KeyHashAndCipherText --- */

typedef struct M_KeyHashAndCipherText M_KeyHashAndCipherText;

/* --- Vector vec_KeyHashAndCipherText --- */

typedef M_KeyHashAndCipherText *M_vec_KeyHashAndCipherText;

/* --- Structure ImpathKXMessage --- */

struct M_ImpathKXMessage {
  M_ImpathKXMessage_flags flags;
  M_ByteBlock pubmsg;
  M_ModuleAttribProof map;
  int n_sigs;
  M_vec_KeyHashAndCipherText sigs;
};

/* --- Structure KeyHashAndCipherText --- */

struct M_KeyHashAndCipherText {
  M_KeyHash hash;
  M_CipherText c;
};

/* --- Structure ImpathMessage --- */

typedef struct M_ImpathMessage M_ImpathMessage;

/* --- Union ImpathMsgType__Body --- */

typedef union M_ImpathMsgType__Body M_ImpathMsgType__Body;

/* --- Structure ImpathMsgType_UserData_Body --- */

typedef struct M_ImpathMsgType_UserData_Body M_ImpathMsgType_UserData_Body;

/* --- Flags word ImpathMsgType_UserData_Body_flags --- */

typedef M_Word M_ImpathMsgType_UserData_Body_flags;

/* --- Structure ImpathMsgType_UserData_Body --- */

struct M_ImpathMsgType_UserData_Body {
  M_ImpathMsgType_UserData_Body_flags flags;
  M_ByteBlock data;
};

/* --- Structure ImpathMsgType_Share_Body --- */

typedef struct M_ImpathMsgType_Share_Body M_ImpathMsgType_Share_Body;

/* --- Flags word ImpathMsgType_Share_Body_flags --- */

typedef M_Word M_ImpathMsgType_Share_Body_flags;

/* --- Octet array TokenUniqueID --- */

typedef union M_TokenUniqueID {
  unsigned char bytes[8];
  M_Word words[2];
} M_TokenUniqueID;

/* --- Structure ImpathMsgType_Share_Body --- */

struct M_ImpathMsgType_Share_Body {
  M_ImpathMsgType_Share_Body_flags flags;
  M_ByteBlock share;
  M_Word i;
  M_TokenUniqueID tkid;
  M_Hash hacl;
  M_Word imech;
  M_Word len;
};

/* --- Union ImpathMsgType__Body --- */

union M_ImpathMsgType__Body {
  M_ImpathMsgType_UserData_Body userdata;
  M_ImpathMsgType_Share_Body share;
};

/* --- Structure ImpathMessage --- */

struct M_ImpathMessage {
  M_ImpathMsgType type;
  M_Word seq;
  union M_ImpathMsgType__Body body;
};

/* --- Structure ImpathCipherText --- */

typedef struct M_ImpathCipherText M_ImpathCipherText;

/* --- Structure ImpathCipherText --- */

struct M_ImpathCipherText {
  M_ByteBlock c;
  M_CipherText mac;
};

/* --- Structure SignedImage --- */

typedef struct M_SignedImage M_SignedImage;

/* --- Structure SEECertData --- */

typedef struct M_SEECertData M_SEECertData;

/* --- Vector vec_SEECertData --- */

typedef M_SEECertData *M_vec_SEECertData;

/* --- Structure SignedImage --- */

struct M_SignedImage {
  int n_certs;
  M_vec_SEECertData certs;
  M_ByteBlock image;
};

/* --- Structure SEECertData --- */

struct M_SEECertData {
  M_KeyHash hash;
  M_KeyData pubkey;
  M_CipherText signature;
  M_ByteBlock signmsg;
};

/* --- Structure HashedSignedImage --- */

typedef struct M_HashedSignedImage M_HashedSignedImage;

/* --- Structure HashedSignedImage --- */

struct M_HashedSignedImage {
  M_ByteBlock signedimage;
  M_Hash hash;
};

/* --- Structure CodeSignMessage --- */

typedef struct M_CodeSignMessage M_CodeSignMessage;

/* --- Structure CodeAttributes --- */

typedef struct M_CodeAttributes M_CodeAttributes;

/* --- Vector vec_CodeAttributes --- */

typedef M_CodeAttributes *M_vec_CodeAttributes;

/* --- Structure CodeSignMessage --- */

struct M_CodeSignMessage {
  M_MagicValue header;
  M_CipherText codehash;
  int n_attributes;
  M_vec_CodeAttributes attributes;
  M_MagicValue footer;
};

/* --- Union CodeAttribTag__CodeAttribValue --- */

typedef union M_CodeAttribTag__CodeAttribValue M_CodeAttribTag__CodeAttribValue;

/* --- Structure CodeAttribTag_IsSEEWorld_CodeAttribValue --- */

typedef struct M_CodeAttribTag_IsSEEWorld_CodeAttribValue M_CodeAttribTag_IsSEEWorld_CodeAttribValue;

/* --- Structure CodeAttribTag_IsSEEWorld_CodeAttribValue --- */

struct M_CodeAttribTag_IsSEEWorld_CodeAttribValue {
  M_KeyHash machinekey;
};

/* --- Structure CodeAttribTag_IsSEEMachine_CodeAttribValue --- */

typedef struct M_CodeAttribTag_IsSEEMachine_CodeAttribValue M_CodeAttribTag_IsSEEMachine_CodeAttribValue;

/* --- Structure CodeAttribTag_IsSEEMachine_CodeAttribValue --- */

struct M_CodeAttribTag_IsSEEMachine_CodeAttribValue {
  M_SEEMachineType type;
};

/* --- Union CodeAttribTag__CodeAttribValue --- */

union M_CodeAttribTag__CodeAttribValue {
  M_CodeAttribTag_IsSEEWorld_CodeAttribValue isseeworld;
  M_CodeAttribTag_IsSEEMachine_CodeAttribValue isseemachine;
};

/* --- Structure CodeAttributes --- */

struct M_CodeAttributes {
  M_CodeAttribTag tag;
  union M_CodeAttribTag__CodeAttribValue value;
};

/* --- Structure SEEJobArgs --- */

typedef struct M_SEEJobArgs M_SEEJobArgs;

/* --- Union SEEOpType__SEEArgs --- */

typedef union M_SEEOpType__SEEArgs M_SEEOpType__SEEArgs;

/* --- Structure SEEOpType_JavaSEECmdInstantiateObject_SEEArgs --- */

typedef struct M_SEEOpType_JavaSEECmdInstantiateObject_SEEArgs M_SEEOpType_JavaSEECmdInstantiateObject_SEEArgs;

/* --- Flags word SEEOpType_JavaSEECmdInstantiateObject_SEEArgs_flags --- */

typedef M_Word M_SEEOpType_JavaSEECmdInstantiateObject_SEEArgs_flags;

/* --- Structure SEEOpType_JavaSEECmdInstantiateObject_SEEArgs --- */

struct M_SEEOpType_JavaSEECmdInstantiateObject_SEEArgs {
  M_SEEOpType_JavaSEECmdInstantiateObject_SEEArgs_flags flags;
  M_ASCIIString classname;
  M_ASCIIString signature;
  M_ByteBlock args;
};

/* --- Structure SEEOpType_JavaSEECmdDeleteObject_SEEArgs --- */

typedef struct M_SEEOpType_JavaSEECmdDeleteObject_SEEArgs M_SEEOpType_JavaSEECmdDeleteObject_SEEArgs;

/* --- Flags word SEEOpType_JavaSEECmdDeleteObject_SEEArgs_flags --- */

typedef M_Word M_SEEOpType_JavaSEECmdDeleteObject_SEEArgs_flags;

/* --- Octet array JObjID --- */

typedef union M_JObjID {
  unsigned char bytes[8];
  M_Word words[2];
} M_JObjID;

/* --- Structure SEEOpType_JavaSEECmdDeleteObject_SEEArgs --- */

struct M_SEEOpType_JavaSEECmdDeleteObject_SEEArgs {
  M_SEEOpType_JavaSEECmdDeleteObject_SEEArgs_flags flags;
  M_JObjID jobjid;
};

/* --- Structure SEEOpType_JavaSEECmdInvokeMethod_SEEArgs --- */

typedef struct M_SEEOpType_JavaSEECmdInvokeMethod_SEEArgs M_SEEOpType_JavaSEECmdInvokeMethod_SEEArgs;

/* --- Flags word SEEOpType_JavaSEECmdInvokeMethod_SEEArgs_flags --- */

typedef M_Word M_SEEOpType_JavaSEECmdInvokeMethod_SEEArgs_flags;

/* --- Structure SEEOpType_JavaSEECmdInvokeMethod_SEEArgs --- */

struct M_SEEOpType_JavaSEECmdInvokeMethod_SEEArgs {
  M_SEEOpType_JavaSEECmdInvokeMethod_SEEArgs_flags flags;
  M_JObjID jobjid;
  M_ASCIIString signature;
  M_ByteBlock args;
};

/* --- Union SEEOpType__SEEArgs --- */

union M_SEEOpType__SEEArgs {
  M_SEEOpType_JavaSEECmdInstantiateObject_SEEArgs javaseecmdinstantiateobject;
  M_SEEOpType_JavaSEECmdDeleteObject_SEEArgs javaseecmddeleteobject;
  M_SEEOpType_JavaSEECmdInvokeMethod_SEEArgs javaseecmdinvokemethod;
};

/* --- Structure SEEJobArgs --- */

struct M_SEEJobArgs {
  M_SEEOpType op;
  union M_SEEOpType__SEEArgs args;
};

/* --- Structure SEEJobRes --- */

typedef struct M_SEEJobRes M_SEEJobRes;

/* --- Union SEEOpType__SEERes --- */

typedef union M_SEEOpType__SEERes M_SEEOpType__SEERes;

/* --- Structure SEEOpType_JavaSEECmdInstantiateObject_SEERes --- */

typedef struct M_SEEOpType_JavaSEECmdInstantiateObject_SEERes M_SEEOpType_JavaSEECmdInstantiateObject_SEERes;

/* --- Flags word SEEOpType_JavaSEECmdInstantiateObject_SEERes_flags --- */

typedef M_Word M_SEEOpType_JavaSEECmdInstantiateObject_SEERes_flags;

/* --- Structure SEEPassbackException --- */

typedef struct M_SEEPassbackException M_SEEPassbackException;

/* --- Structure SEEOpType_JavaSEECmdInstantiateObject_SEERes --- */

struct M_SEEOpType_JavaSEECmdInstantiateObject_SEERes {
  M_SEEOpType_JavaSEECmdInstantiateObject_SEERes_flags flags;
  M_JObjID jobjid;
  M_SEEPassbackException *exception;
};

/* --- Structure SEEOpType_JavaSEECmdError_SEERes --- */

typedef struct M_SEEOpType_JavaSEECmdError_SEERes M_SEEOpType_JavaSEECmdError_SEERes;

/* --- Structure SEEPassbackException --- */

struct M_SEEPassbackException {
  M_ASCIIString name;
  M_ASCIIString string;
};

/* --- Structure SEEOpType_JavaSEECmdError_SEERes --- */

struct M_SEEOpType_JavaSEECmdError_SEERes {
  M_SEEPassbackException exception;
};

/* --- Structure SEEOpType_JavaSEECmdInvokeMethod_SEERes --- */

typedef struct M_SEEOpType_JavaSEECmdInvokeMethod_SEERes M_SEEOpType_JavaSEECmdInvokeMethod_SEERes;

/* --- Flags word SEEOpType_JavaSEECmdInvokeMethod_SEERes_flags --- */

typedef M_Word M_SEEOpType_JavaSEECmdInvokeMethod_SEERes_flags;

/* --- Structure SEEOpType_JavaSEECmdInvokeMethod_SEERes --- */

struct M_SEEOpType_JavaSEECmdInvokeMethod_SEERes {
  M_SEEOpType_JavaSEECmdInvokeMethod_SEERes_flags flags;
  M_ByteBlock res;
  M_SEEPassbackException *exception;
};

/* --- Union SEEOpType__SEERes --- */

union M_SEEOpType__SEERes {
  M_SEEOpType_JavaSEECmdInstantiateObject_SEERes javaseecmdinstantiateobject;
  M_SEEOpType_JavaSEECmdError_SEERes javaseecmderror;
  M_SEEOpType_JavaSEECmdInvokeMethod_SEERes javaseecmdinvokemethod;
};

/* --- Structure SEEJobRes --- */

struct M_SEEJobRes {
  M_SEEOpType op;
  union M_SEEOpType__SEERes res;
};

/* --- Structure Ticket --- */

typedef struct M_Ticket M_Ticket;

/* --- Structure TicketInfo --- */

typedef struct M_TicketInfo M_TicketInfo;

/* --- Union TicketType__TicketObjSpec --- */

typedef union M_TicketType__TicketObjSpec M_TicketType__TicketObjSpec;

/* --- Structure TicketType_Module_TicketObjSpec --- */

typedef struct M_TicketType_Module_TicketObjSpec M_TicketType_Module_TicketObjSpec;

/* --- Structure TicketType_Module_TicketObjSpec --- */

struct M_TicketType_Module_TicketObjSpec {
  M_Word space;
  M_Word objid;
};

/* --- Structure TicketType_Hardserver_TicketObjSpec --- */

typedef struct M_TicketType_Hardserver_TicketObjSpec M_TicketType_Hardserver_TicketObjSpec;

/* --- Structure TicketType_Hardserver_TicketObjSpec --- */

struct M_TicketType_Hardserver_TicketObjSpec {
  M_Hash hclientid;
  M_Word objid;
};

/* --- Union TicketType__TicketObjSpec --- */

union M_TicketType__TicketObjSpec {
  M_TicketType_Module_TicketObjSpec module;
  M_TicketType_Hardserver_TicketObjSpec hardserver;
};

/* --- Flags word TicketInfo_flags --- */

typedef M_Word M_TicketInfo_flags;

/* --- Structure TicketInfo --- */

struct M_TicketInfo {
  M_TicketType type;
  union M_TicketType__TicketObjSpec target;
  M_TicketInfo_flags flags;
  M_Hash *hclientid;
  M_Word *destspace;
  M_Nonce *challenge;
};

/* --- Nested nest_TicketInfo --- */

typedef M_TicketInfo M_nest_TicketInfo;

/* --- Structure Ticket --- */

struct M_Ticket {
  M_nest_TicketInfo info;
  M_Hash mac;
};

/* --- Structure SKYCertList --- */

typedef struct M_SKYCertList M_SKYCertList;

/* --- Structure SKYCert --- */

typedef struct M_SKYCert M_SKYCert;

/* --- Vector vec_SKYCert --- */

typedef M_SKYCert *M_vec_SKYCert;

/* --- Structure SKYCertList --- */

struct M_SKYCertList {
  int n_certs;
  M_vec_SKYCert certs;
};

/* --- Structure SKYCert --- */

struct M_SKYCert {
  M_ByteBlock blobpubka;
  M_CipherText signature;
  M_ByteBlock certsignmsg;
};

/* --- Structure KeyCert --- */

typedef struct M_KeyCert M_KeyCert;

/* --- Structure KeyCert --- */

struct M_KeyCert {
  M_MagicValue header;
  M_KeyCertType type;
  M_KeyHash nexthk;
  M_MagicValue footer;
};

/*----- That's all, folks -------------------------------------------------*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nfast\inc\messages-a-print.h ===
/* -*-c-*-
 *
 * Generated by Marshmallow at 2003-04-16T17:14:11
 */

#ifndef MESSAGES_A_PRINT_H
#define MESSAGES_A_PRINT_H

#include <stdio.h>

/* --- Printing context --- */

#ifndef NF_PRINT_CONTEXT
#define NF_PRINT_CONTEXT

typedef struct NF_Print_Context {
  FILE *file;
  struct NF_UserData *u;
} NF_Print_Context;

#endif

/* --- Exported types --- */

extern int NF_Print_Word(NF_Print_Context *c, int ind, const M_Word *msg);
extern int NF_Print_ByteBlock(NF_Print_Context *c, int ind, const M_ByteBlock *msg);
extern int NF_Print_ASCIIString(NF_Print_Context *c, int ind, const M_ASCIIString *msg);
extern int NF_Print_MustBeZeroWord(NF_Print_Context *c, int ind, const M_MustBeZeroWord *msg);
extern int NF_Print_Hash(NF_Print_Context *c, int ind, const M_Hash *msg);
extern int NF_Print_Status(NF_Print_Context *c, int ind, const M_Status *msg);
extern int NF_Print_nCErrno(NF_Print_Context *c, int ind, const M_nCErrno *msg);
extern int NF_Print_Status_nCErrno_ErrorInfo(NF_Print_Context *c, int ind, const M_Status_nCErrno_ErrorInfo *msg);
extern int NF_Print_KeyHash(NF_Print_Context *c, int ind, const M_KeyHash *msg);
extern int NF_Print_Status__ErrorInfo(NF_Print_Context *c, int ind, const M_Status__ErrorInfo *msg, M_Status tag);
extern int NF_Print_StatusErrorInfo(NF_Print_Context *c, int ind, const M_StatusErrorInfo *msg);
extern int NF_Print_NetworkAddress(NF_Print_Context *c, int ind, const M_NetworkAddress *msg);
extern int NF_Print_KeyID(NF_Print_Context *c, int ind, const M_KeyID *msg);
extern int NF_Print_ModuleID(NF_Print_Context *c, int ind, const M_ModuleID *msg);
extern int NF_Print_ClientID(NF_Print_Context *c, int ind, const M_ClientID *msg);
extern int NF_Print_SlotID(NF_Print_Context *c, int ind, const M_SlotID *msg);
extern int NF_Print_LimitID(NF_Print_Context *c, int ind, const M_LimitID *msg);
extern int NF_Print_TokenHash(NF_Print_Context *c, int ind, const M_TokenHash *msg);
extern int NF_Print_KMHash(NF_Print_Context *c, int ind, const M_KMHash *msg);
extern int NF_Print_PhysToken(NF_Print_Context *c, int ind, const M_PhysToken *msg);
extern int NF_Print_SlotType(NF_Print_Context *c, int ind, const M_SlotType *msg);
extern int NF_Print_SlotType__SlotExData(NF_Print_Context *c, int ind, const M_SlotType__SlotExData *msg, M_SlotType tag);
extern int NF_Print_ClientChannelOpenInfo(NF_Print_Context *c, int ind, const M_ClientChannelOpenInfo *msg);
extern int NF_Print_ChannelOpenInfo(NF_Print_Context *c, int ind, const M_ChannelOpenInfo *msg);
extern int NF_Print_Bignum(NF_Print_Context *c, int ind, const M_Bignum *msg);
extern int NF_Print_KeyData(NF_Print_Context *c, int ind, const M_KeyData *msg);
extern int NF_Print_CipherText(NF_Print_Context *c, int ind, const M_CipherText *msg);
extern int NF_Print_Certificate(NF_Print_Context *c, int ind, const M_Certificate *msg);
extern int NF_Print_ImpathKXGroup(NF_Print_Context *c, int ind, const M_ImpathKXGroup *msg);
extern int NF_Print_Nonce(NF_Print_Context *c, int ind, const M_Nonce *msg);
extern int NF_Print_PlainText(NF_Print_Context *c, int ind, const M_PlainText *msg);
extern int NF_Print_KeyGenParams(NF_Print_Context *c, int ind, const M_KeyGenParams *msg);
extern int NF_Print_IV(NF_Print_Context *c, int ind, const M_IV *msg);
extern int NF_Print_DeriveMech(NF_Print_Context *c, int ind, const M_DeriveMech *msg);
extern int NF_Print_DeriveMech__DKParams(NF_Print_Context *c, int ind, const M_DeriveMech__DKParams *msg, M_DeriveMech tag);
extern int NF_Print_Tag(NF_Print_Context *c, int ind, const M_Tag *msg);
extern int NF_Print_ImpathKXGroupSelection(NF_Print_Context *c, int ind, const M_ImpathKXGroupSelection *msg);
extern int NF_Print_RemoteModule(NF_Print_Context *c, int ind, const M_RemoteModule *msg);
extern int NF_Print_CertificateList(NF_Print_Context *c, int ind, const M_CertificateList *msg);
extern int NF_Print_ACL(NF_Print_Context *c, int ind, const M_ACL *msg);
extern int NF_Print_Command(NF_Print_Context *c, int ind, const M_Command *msg);
extern int NF_Print_ModuleAttribList(NF_Print_Context *c, int ind, const M_ModuleAttribList *msg);
extern int NF_Print_KeyHashAndMech(NF_Print_Context *c, int ind, const M_KeyHashAndMech *msg);
extern int NF_Print_PermissionGroup(NF_Print_Context *c, int ind, const M_PermissionGroup *msg);
extern int NF_Print_EnquiryDataOne(NF_Print_Context *c, int ind, const M_EnquiryDataOne *msg);
extern int NF_Print_EnquiryDataTwo(NF_Print_Context *c, int ind, const M_EnquiryDataTwo *msg);
extern int NF_Print_EnquiryDataThree(NF_Print_Context *c, int ind, const M_EnquiryDataThree *msg);
extern int NF_Print_EnquiryDataFour(NF_Print_Context *c, int ind, const M_EnquiryDataFour *msg);
extern int NF_Print_EnquiryDataFive(NF_Print_Context *c, int ind, const M_EnquiryDataFive *msg);
extern int NF_Print_EnquiryDataSix(NF_Print_Context *c, int ind, const M_EnquiryDataSix *msg);
extern int NF_Print_ModuleAttrib(NF_Print_Context *c, int ind, const M_ModuleAttrib *msg);
extern int NF_Print_UseLimit(NF_Print_Context *c, int ind, const M_UseLimit *msg);
extern int NF_Print_Action(NF_Print_Context *c, int ind, const M_Action *msg);
extern int NF_Print_KeyHashAttrib(NF_Print_Context *c, int ind, const M_KeyHashAttrib *msg);
extern int NF_Print_ModuleCert(NF_Print_Context *c, int ind, const M_ModuleCert *msg);
extern int NF_Print_Reply(NF_Print_Context *c, int ind, const M_Reply *msg);
extern int NF_Print_ImageMetaDataHeader(NF_Print_Context *c, int ind, const M_ImageMetaDataHeader *msg);
extern int NF_Print_ImageMetaData(NF_Print_Context *c, int ind, const M_ImageMetaData *msg);
extern int NF_Print_OldProgrammingSignedData(NF_Print_Context *c, int ind, const M_OldProgrammingSignedData *msg);
extern int NF_Print_ProgrammingSignedData(NF_Print_Context *c, int ind, const M_ProgrammingSignedData *msg);
extern int NF_Print_FirmwareFileHeader(NF_Print_Context *c, int ind, const M_FirmwareFileHeader *msg);
extern int NF_Print_FirmwareFileData(NF_Print_Context *c, int ind, const M_FirmwareFileData *msg);
extern int NF_Print_SigningKeys(NF_Print_Context *c, int ind, const M_SigningKeys *msg);
extern int NF_Print_CertSignMessage(NF_Print_Context *c, int ind, const M_CertSignMessage *msg);
extern int NF_Print_ModCertMsg(NF_Print_Context *c, int ind, const M_ModCertMsg *msg);
extern int NF_Print_StandaloneCert(NF_Print_Context *c, int ind, const M_StandaloneCert *msg);
extern int NF_Print_Warrant(NF_Print_Context *c, int ind, const M_Warrant *msg);
extern int NF_Print_ModuleAttribProof(NF_Print_Context *c, int ind, const M_ModuleAttribProof *msg);
extern int NF_Print_BlobData(NF_Print_Context *c, int ind, const M_BlobData *msg);
extern int NF_Print_ModuleChannelOpenInfo(NF_Print_Context *c, int ind, const M_ModuleChannelOpenInfo *msg);
extern int NF_Print_ImpathKXMessage(NF_Print_Context *c, int ind, const M_ImpathKXMessage *msg);
extern int NF_Print_ImpathMessage(NF_Print_Context *c, int ind, const M_ImpathMessage *msg);
extern int NF_Print_ImpathCipherText(NF_Print_Context *c, int ind, const M_ImpathCipherText *msg);
extern int NF_Print_SignedImage(NF_Print_Context *c, int ind, const M_SignedImage *msg);
extern int NF_Print_SEECertData(NF_Print_Context *c, int ind, const M_SEECertData *msg);
extern int NF_Print_HashedSignedImage(NF_Print_Context *c, int ind, const M_HashedSignedImage *msg);
extern int NF_Print_CodeSignMessage(NF_Print_Context *c, int ind, const M_CodeSignMessage *msg);
extern int NF_Print_SEEJobArgs(NF_Print_Context *c, int ind, const M_SEEJobArgs *msg);
extern int NF_Print_SEEJobRes(NF_Print_Context *c, int ind, const M_SEEJobRes *msg);
extern int NF_Print_TicketInfo(NF_Print_Context *c, int ind, const M_TicketInfo *msg);
extern int NF_Print_Ticket(NF_Print_Context *c, int ind, const M_Ticket *msg);
extern int NF_Print_SKYCertList(NF_Print_Context *c, int ind, const M_SKYCertList *msg);
extern int NF_Print_KeyCert(NF_Print_Context *c, int ind, const M_KeyCert *msg);

/* --- External dependencies --- */

extern int NF_Print_fixedoctetstring(NF_Print_Context *c, int ind, const unsigned char *p, int sz);
extern int NF_Print_bitmap(NF_Print_Context *c, M_Word f, const NF_ValInfo *vit);

/*----- That's all, folks -------------------------------------------------*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nfast\inc\messages-a-read.h ===
/* -*-c-*-
 *
 * Generated by Marshmallow at 2003-04-16T17:14:16
 */

#ifndef MESSAGES_A_READ_H
#define MESSAGES_A_READ_H

/* --- Reading context --- */

#ifndef NF_READ_CONTEXT
#define NF_READ_CONTEXT

typedef struct NF_Read_Context {
  FILE *file;
  int (*addprompt)(struct NF_Read_Context *c, const char *string);
  int (*continueindent)(struct NF_Read_Context *c, int indent);
  int (*autonewline)(struct NF_Read_Context *c);
  int comparing;
  struct NF_UserData *u;
} NF_Read_Context;

#endif

/* --- Exported types --- */

extern int NF_Read_Word(NF_Read_Context *c, int ind, M_Word *msg);
extern int NF_Read_ByteBlock(NF_Read_Context *c, int ind, M_ByteBlock *msg);
extern int NF_Read_ASCIIString(NF_Read_Context *c, int ind, M_ASCIIString *msg);
extern int NF_Read_MustBeZeroWord(NF_Read_Context *c, int ind, M_MustBeZeroWord *msg);
extern int NF_Read_Hash(NF_Read_Context *c, int ind, M_Hash *msg);
extern int NF_Read_Status(NF_Read_Context *c, int ind, M_Status *msg);
extern int NF_Read_nCErrno(NF_Read_Context *c, int ind, M_nCErrno *msg);
extern int NF_Read_Status_nCErrno_ErrorInfo(NF_Read_Context *c, int ind, M_Status_nCErrno_ErrorInfo *msg);
extern int NF_Read_KeyHash(NF_Read_Context *c, int ind, M_KeyHash *msg);
extern int NF_Read_Status__ErrorInfo(NF_Read_Context *c, int ind, M_Status__ErrorInfo *msg, M_Status *tag);
extern int NF_Read_StatusErrorInfo(NF_Read_Context *c, int ind, M_StatusErrorInfo *msg);
extern int NF_Read_NetworkAddress(NF_Read_Context *c, int ind, M_NetworkAddress *msg);
extern int NF_Read_KeyID(NF_Read_Context *c, int ind, M_KeyID *msg);
extern int NF_Read_ModuleID(NF_Read_Context *c, int ind, M_ModuleID *msg);
extern int NF_Read_ClientID(NF_Read_Context *c, int ind, M_ClientID *msg);
extern int NF_Read_SlotID(NF_Read_Context *c, int ind, M_SlotID *msg);
extern int NF_Read_LimitID(NF_Read_Context *c, int ind, M_LimitID *msg);
extern int NF_Read_TokenHash(NF_Read_Context *c, int ind, M_TokenHash *msg);
extern int NF_Read_KMHash(NF_Read_Context *c, int ind, M_KMHash *msg);
extern int NF_Read_PhysToken(NF_Read_Context *c, int ind, M_PhysToken *msg);
extern int NF_Read_SlotType(NF_Read_Context *c, int ind, M_SlotType *msg);
extern int NF_Read_SlotType__SlotExData(NF_Read_Context *c, int ind, M_SlotType__SlotExData *msg, M_SlotType *tag);
extern int NF_Read_ClientChannelOpenInfo(NF_Read_Context *c, int ind, M_ClientChannelOpenInfo *msg);
extern int NF_Read_ChannelOpenInfo(NF_Read_Context *c, int ind, M_ChannelOpenInfo *msg);
extern int NF_Read_Bignum(NF_Read_Context *c, int ind, M_Bignum *msg);
extern int NF_Read_KeyData(NF_Read_Context *c, int ind, M_KeyData *msg);
extern int NF_Read_CipherText(NF_Read_Context *c, int ind, M_CipherText *msg);
extern int NF_Read_Certificate(NF_Read_Context *c, int ind, M_Certificate *msg);
extern int NF_Read_ImpathKXGroup(NF_Read_Context *c, int ind, M_ImpathKXGroup *msg);
extern int NF_Read_Nonce(NF_Read_Context *c, int ind, M_Nonce *msg);
extern int NF_Read_PlainText(NF_Read_Context *c, int ind, M_PlainText *msg);
extern int NF_Read_KeyGenParams(NF_Read_Context *c, int ind, M_KeyGenParams *msg);
extern int NF_Read_IV(NF_Read_Context *c, int ind, M_IV *msg);
extern int NF_Read_DeriveMech(NF_Read_Context *c, int ind, M_DeriveMech *msg);
extern int NF_Read_DeriveMech__DKParams(NF_Read_Context *c, int ind, M_DeriveMech__DKParams *msg, M_DeriveMech *tag);
extern int NF_Read_Tag(NF_Read_Context *c, int ind, M_Tag *msg);
extern int NF_Read_ImpathKXGroupSelection(NF_Read_Context *c, int ind, M_ImpathKXGroupSelection *msg);
extern int NF_Read_RemoteModule(NF_Read_Context *c, int ind, M_RemoteModule *msg);
extern int NF_Read_CertificateList(NF_Read_Context *c, int ind, M_CertificateList *msg);
extern int NF_Read_ACL(NF_Read_Context *c, int ind, M_ACL *msg);
extern int NF_Read_Command(NF_Read_Context *c, int ind, M_Command *msg);
extern int NF_Read_ModuleAttribList(NF_Read_Context *c, int ind, M_ModuleAttribList *msg);
extern int NF_Read_KeyHashAndMech(NF_Read_Context *c, int ind, M_KeyHashAndMech *msg);
extern int NF_Read_PermissionGroup(NF_Read_Context *c, int ind, M_PermissionGroup *msg);
extern int NF_Read_EnquiryDataOne(NF_Read_Context *c, int ind, M_EnquiryDataOne *msg);
extern int NF_Read_EnquiryDataTwo(NF_Read_Context *c, int ind, M_EnquiryDataTwo *msg);
extern int NF_Read_EnquiryDataThree(NF_Read_Context *c, int ind, M_EnquiryDataThree *msg);
extern int NF_Read_EnquiryDataFour(NF_Read_Context *c, int ind, M_EnquiryDataFour *msg);
extern int NF_Read_EnquiryDataFive(NF_Read_Context *c, int ind, M_EnquiryDataFive *msg);
extern int NF_Read_EnquiryDataSix(NF_Read_Context *c, int ind, M_EnquiryDataSix *msg);
extern int NF_Read_ModuleAttrib(NF_Read_Context *c, int ind, M_ModuleAttrib *msg);
extern int NF_Read_UseLimit(NF_Read_Context *c, int ind, M_UseLimit *msg);
extern int NF_Read_Action(NF_Read_Context *c, int ind, M_Action *msg);
extern int NF_Read_KeyHashAttrib(NF_Read_Context *c, int ind, M_KeyHashAttrib *msg);
extern int NF_Read_ModuleCert(NF_Read_Context *c, int ind, M_ModuleCert *msg);
extern int NF_Read_Reply(NF_Read_Context *c, int ind, M_Reply *msg);
extern int NF_Read_ImageMetaDataHeader(NF_Read_Context *c, int ind, M_ImageMetaDataHeader *msg);
extern int NF_Read_ImageMetaData(NF_Read_Context *c, int ind, M_ImageMetaData *msg);
extern int NF_Read_OldProgrammingSignedData(NF_Read_Context *c, int ind, M_OldProgrammingSignedData *msg);
extern int NF_Read_ProgrammingSignedData(NF_Read_Context *c, int ind, M_ProgrammingSignedData *msg);
extern int NF_Read_FirmwareFileHeader(NF_Read_Context *c, int ind, M_FirmwareFileHeader *msg);
extern int NF_Read_FirmwareFileData(NF_Read_Context *c, int ind, M_FirmwareFileData *msg);
extern int NF_Read_SigningKeys(NF_Read_Context *c, int ind, M_SigningKeys *msg);
extern int NF_Read_CertSignMessage(NF_Read_Context *c, int ind, M_CertSignMessage *msg);
extern int NF_Read_ModCertMsg(NF_Read_Context *c, int ind, M_ModCertMsg *msg);
extern int NF_Read_StandaloneCert(NF_Read_Context *c, int ind, M_StandaloneCert *msg);
extern int NF_Read_Warrant(NF_Read_Context *c, int ind, M_Warrant *msg);
extern int NF_Read_ModuleAttribProof(NF_Read_Context *c, int ind, M_ModuleAttribProof *msg);
extern int NF_Read_BlobData(NF_Read_Context *c, int ind, M_BlobData *msg);
extern int NF_Read_ModuleChannelOpenInfo(NF_Read_Context *c, int ind, M_ModuleChannelOpenInfo *msg);
extern int NF_Read_ImpathKXMessage(NF_Read_Context *c, int ind, M_ImpathKXMessage *msg);
extern int NF_Read_ImpathMessage(NF_Read_Context *c, int ind, M_ImpathMessage *msg);
extern int NF_Read_ImpathCipherText(NF_Read_Context *c, int ind, M_ImpathCipherText *msg);
extern int NF_Read_SignedImage(NF_Read_Context *c, int ind, M_SignedImage *msg);
extern int NF_Read_SEECertData(NF_Read_Context *c, int ind, M_SEECertData *msg);
extern int NF_Read_HashedSignedImage(NF_Read_Context *c, int ind, M_HashedSignedImage *msg);
extern int NF_Read_CodeSignMessage(NF_Read_Context *c, int ind, M_CodeSignMessage *msg);
extern int NF_Read_SEEJobArgs(NF_Read_Context *c, int ind, M_SEEJobArgs *msg);
extern int NF_Read_SEEJobRes(NF_Read_Context *c, int ind, M_SEEJobRes *msg);
extern int NF_Read_TicketInfo(NF_Read_Context *c, int ind, M_TicketInfo *msg);
extern int NF_Read_Ticket(NF_Read_Context *c, int ind, M_Ticket *msg);
extern int NF_Read_SKYCertList(NF_Read_Context *c, int ind, M_SKYCertList *msg);
extern int NF_Read_KeyCert(NF_Read_Context *c, int ind, M_KeyCert *msg);

/* --- External dependencies --- */

extern int NF_Read_fixedoctetstring(NF_Read_Context *c, int ind, unsigned char *p, int sz);
extern int NF_Read_enum
	(NF_Read_Context *c, int ind, M_Word *w, M_Word max,
	 const NF_ValInfo *vit);
extern int NF_Read_bitmap
	(NF_Read_Context *c, int ind, M_Word *w, M_Word all,
	 const NF_ValInfo *vit);
extern const NF_ValInfo NF_YesNo_enumtable[];
extern int NF_Read_length(NF_Read_Context *c, NF_Read_Context *cc);
extern int NF_Read_padding(NF_Read_Context *c, NF_Read_Context *cc);

/*----- That's all, folks -------------------------------------------------*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nfast\inc\messages-a-trans.h ===
/* -*-c-*-
 *
 * Generated by Marshmallow at 2003-04-16T17:14:20
 */

#ifndef MESSAGES_A_TRANS_H
#define MESSAGES_A_TRANS_H

/* --- Translating context --- */

#ifndef NF_TRANSLATE_CONTEXT
#define NF_TRANSLATE_CONTEXT

typedef struct NF_Translate_Context {
  const unsigned char *ip;
  unsigned char *op;
  int iremain, oremain;
  struct NF_UserData *u;
} NF_Translate_Context;

#endif

/* --- Exported types --- */

extern int NF_Translate_Word(NF_Translate_Context *c);
extern int NF_Translate_ByteBlock(NF_Translate_Context *c);
extern int NF_Translate_ASCIIString(NF_Translate_Context *c);
extern int NF_Translate_MustBeZeroWord(NF_Translate_Context *c);
extern int NF_Translate_Hash(NF_Translate_Context *c);
extern int NF_Translate_Status(NF_Translate_Context *c, M_Word *w);
extern int NF_Translate_nCErrno(NF_Translate_Context *c, M_Word *w);
extern int NF_Translate_Status_nCErrno_ErrorInfo(NF_Translate_Context *c);
extern int NF_Translate_KeyHash(NF_Translate_Context *c);
extern int NF_Translate_Status__ErrorInfo(NF_Translate_Context *c, M_Status tag);
extern int NF_Translate_StatusErrorInfo(NF_Translate_Context *c);
extern int NF_Translate_NetworkAddress(NF_Translate_Context *c);
extern int NF_Translate_KeyID(NF_Translate_Context *c);
extern int NF_Translate_ModuleID(NF_Translate_Context *c);
extern int NF_Translate_ClientID(NF_Translate_Context *c);
extern int NF_Translate_SlotID(NF_Translate_Context *c);
extern int NF_Translate_LimitID(NF_Translate_Context *c);
extern int NF_Translate_TokenHash(NF_Translate_Context *c);
extern int NF_Translate_KMHash(NF_Translate_Context *c);
extern int NF_Translate_PhysToken(NF_Translate_Context *c);
extern int NF_Translate_SlotType(NF_Translate_Context *c, M_Word *w);
extern int NF_Translate_SlotType__SlotExData(NF_Translate_Context *c, M_SlotType tag);
extern int NF_Translate_ClientChannelOpenInfo(NF_Translate_Context *c);
extern int NF_Translate_ChannelOpenInfo(NF_Translate_Context *c);
extern int NF_Translate_Bignum(NF_Translate_Context *c);
extern int NF_Translate_KeyData(NF_Translate_Context *c);
extern int NF_Translate_CipherText(NF_Translate_Context *c);
extern int NF_Translate_Certificate(NF_Translate_Context *c);
extern int NF_Translate_ImpathKXGroup(NF_Translate_Context *c, M_Word *w);
extern int NF_Translate_Nonce(NF_Translate_Context *c);
extern int NF_Translate_PlainText(NF_Translate_Context *c);
extern int NF_Translate_KeyGenParams(NF_Translate_Context *c);
extern int NF_Translate_IV(NF_Translate_Context *c);
extern int NF_Translate_DeriveMech(NF_Translate_Context *c, M_Word *w);
extern int NF_Translate_DeriveMech__DKParams(NF_Translate_Context *c, M_DeriveMech tag);
extern int NF_Translate_Tag(NF_Translate_Context *c);
extern int NF_Translate_ImpathKXGroupSelection(NF_Translate_Context *c);
extern int NF_Translate_RemoteModule(NF_Translate_Context *c);
extern int NF_Translate_CertificateList(NF_Translate_Context *c);
extern int NF_Translate_ACL(NF_Translate_Context *c);
extern int NF_Translate_Command(NF_Translate_Context *c);
extern int NF_Translate_ModuleAttribList(NF_Translate_Context *c);
extern int NF_Translate_KeyHashAndMech(NF_Translate_Context *c);
extern int NF_Translate_PermissionGroup(NF_Translate_Context *c);
extern int NF_Translate_EnquiryDataOne(NF_Translate_Context *c);
extern int NF_Translate_EnquiryDataTwo(NF_Translate_Context *c);
extern int NF_Translate_EnquiryDataThree(NF_Translate_Context *c);
extern int NF_Translate_EnquiryDataFour(NF_Translate_Context *c);
extern int NF_Translate_EnquiryDataFive(NF_Translate_Context *c);
extern int NF_Translate_EnquiryDataSix(NF_Translate_Context *c);
extern int NF_Translate_ModuleAttrib(NF_Translate_Context *c);
extern int NF_Translate_UseLimit(NF_Translate_Context *c);
extern int NF_Translate_Action(NF_Translate_Context *c);
extern int NF_Translate_KeyHashAttrib(NF_Translate_Context *c);
extern int NF_Translate_ModuleCert(NF_Translate_Context *c);
extern int NF_Translate_Reply(NF_Translate_Context *c);
extern int NF_Translate_ImageMetaDataHeader(NF_Translate_Context *c);
extern int NF_Translate_ImageMetaData(NF_Translate_Context *c);
extern int NF_Translate_OldProgrammingSignedData(NF_Translate_Context *c);
extern int NF_Translate_ProgrammingSignedData(NF_Translate_Context *c);
extern int NF_Translate_FirmwareFileHeader(NF_Translate_Context *c);
extern int NF_Translate_FirmwareFileData(NF_Translate_Context *c);
extern int NF_Translate_SigningKeys(NF_Translate_Context *c);
extern int NF_Translate_CertSignMessage(NF_Translate_Context *c);
extern int NF_Translate_ModCertMsg(NF_Translate_Context *c);
extern int NF_Translate_StandaloneCert(NF_Translate_Context *c);
extern int NF_Translate_Warrant(NF_Translate_Context *c);
extern int NF_Translate_ModuleAttribProof(NF_Translate_Context *c);
extern int NF_Translate_BlobData(NF_Translate_Context *c);
extern int NF_Translate_ModuleChannelOpenInfo(NF_Translate_Context *c);
extern int NF_Translate_ImpathKXMessage(NF_Translate_Context *c);
extern int NF_Translate_ImpathMessage(NF_Translate_Context *c);
extern int NF_Translate_ImpathCipherText(NF_Translate_Context *c);
extern int NF_Translate_SignedImage(NF_Translate_Context *c);
extern int NF_Translate_SEECertData(NF_Translate_Context *c);
extern int NF_Translate_HashedSignedImage(NF_Translate_Context *c);
extern int NF_Translate_CodeSignMessage(NF_Translate_Context *c);
extern int NF_Translate_SEEJobArgs(NF_Translate_Context *c);
extern int NF_Translate_SEEJobRes(NF_Translate_Context *c);
extern int NF_Translate_TicketInfo(NF_Translate_Context *c);
extern int NF_Translate_Ticket(NF_Translate_Context *c);
extern int NF_Translate_SKYCertList(NF_Translate_Context *c);
extern int NF_Translate_KeyCert(NF_Translate_Context *c);

/* --- External dependencies --- */

extern int NF_Translate_fixedoctetstring(NF_Translate_Context *c, int sz);
extern int NF_Translate_length(NF_Translate_Context *c, NF_Translate_Context *cc);
extern int NF_Translate_padding(NF_Translate_Context *c, NF_Translate_Context *cc);

/*----- That's all, folks -------------------------------------------------*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nfast\inc\messages-a-mar.h ===
/* -*-c-*-
 *
 * Generated by Marshmallow at 2003-04-16T17:14:06
 */

#ifndef MESSAGES_A_MAR_H
#define MESSAGES_A_MAR_H

/* --- Marshalling context --- */

#ifndef NF_MARSHAL_CONTEXT
#define NF_MARSHAL_CONTEXT

typedef struct NF_Marshal_Context {
  unsigned char *op;
  int remain;
  struct NF_UserData *u;
} NF_Marshal_Context;

#endif

/* --- Exported types --- */

extern int NF_Marshal_Word(NF_Marshal_Context *c, const M_Word *msg);
extern int NF_Marshal_ByteBlock(NF_Marshal_Context *c, const M_ByteBlock *msg);
extern int NF_Marshal_ASCIIString(NF_Marshal_Context *c, const M_ASCIIString *msg);
extern int NF_Marshal_MustBeZeroWord(NF_Marshal_Context *c, const M_MustBeZeroWord *msg);
extern int NF_Marshal_Hash(NF_Marshal_Context *c, const M_Hash *msg);
extern int NF_Marshal_Status(NF_Marshal_Context *c, const M_Status *msg);
extern int NF_Marshal_nCErrno(NF_Marshal_Context *c, const M_nCErrno *msg);
extern int NF_Marshal_Status_nCErrno_ErrorInfo(NF_Marshal_Context *c, const M_Status_nCErrno_ErrorInfo *msg);
extern int NF_Marshal_KeyHash(NF_Marshal_Context *c, const M_KeyHash *msg);
extern int NF_Marshal_Status__ErrorInfo(NF_Marshal_Context *c, const M_Status__ErrorInfo *msg, M_Status tag);
extern int NF_Marshal_StatusErrorInfo(NF_Marshal_Context *c, const M_StatusErrorInfo *msg);
extern int NF_Marshal_NetworkAddress(NF_Marshal_Context *c, const M_NetworkAddress *msg);
extern int NF_Marshal_KeyID(NF_Marshal_Context *c, const M_KeyID *msg);
extern int NF_Marshal_ModuleID(NF_Marshal_Context *c, const M_ModuleID *msg);
extern int NF_Marshal_ClientID(NF_Marshal_Context *c, const M_ClientID *msg);
extern int NF_Marshal_SlotID(NF_Marshal_Context *c, const M_SlotID *msg);
extern int NF_Marshal_LimitID(NF_Marshal_Context *c, const M_LimitID *msg);
extern int NF_Marshal_TokenHash(NF_Marshal_Context *c, const M_TokenHash *msg);
extern int NF_Marshal_KMHash(NF_Marshal_Context *c, const M_KMHash *msg);
extern int NF_Marshal_PhysToken(NF_Marshal_Context *c, const M_PhysToken *msg);
extern int NF_Marshal_SlotType(NF_Marshal_Context *c, const M_SlotType *msg);
extern int NF_Marshal_SlotType__SlotExData(NF_Marshal_Context *c, const M_SlotType__SlotExData *msg, M_SlotType tag);
extern int NF_Marshal_ClientChannelOpenInfo(NF_Marshal_Context *c, const M_ClientChannelOpenInfo *msg);
extern int NF_Marshal_ChannelOpenInfo(NF_Marshal_Context *c, const M_ChannelOpenInfo *msg);
extern int NF_Marshal_Bignum(NF_Marshal_Context *c, const M_Bignum *msg);
extern int NF_Marshal_KeyData(NF_Marshal_Context *c, const M_KeyData *msg);
extern int NF_Marshal_CipherText(NF_Marshal_Context *c, const M_CipherText *msg);
extern int NF_Marshal_Certificate(NF_Marshal_Context *c, const M_Certificate *msg);
extern int NF_Marshal_ImpathKXGroup(NF_Marshal_Context *c, const M_ImpathKXGroup *msg);
extern int NF_Marshal_Nonce(NF_Marshal_Context *c, const M_Nonce *msg);
extern int NF_Marshal_PlainText(NF_Marshal_Context *c, const M_PlainText *msg);
extern int NF_Marshal_KeyGenParams(NF_Marshal_Context *c, const M_KeyGenParams *msg);
extern int NF_Marshal_IV(NF_Marshal_Context *c, const M_IV *msg);
extern int NF_Marshal_DeriveMech(NF_Marshal_Context *c, const M_DeriveMech *msg);
extern int NF_Marshal_DeriveMech__DKParams(NF_Marshal_Context *c, const M_DeriveMech__DKParams *msg, M_DeriveMech tag);
extern int NF_Marshal_Tag(NF_Marshal_Context *c, const M_Tag *msg);
extern int NF_Marshal_ImpathKXGroupSelection(NF_Marshal_Context *c, const M_ImpathKXGroupSelection *msg);
extern int NF_Marshal_RemoteModule(NF_Marshal_Context *c, const M_RemoteModule *msg);
extern int NF_Marshal_CertificateList(NF_Marshal_Context *c, const M_CertificateList *msg);
extern int NF_Marshal_ACL(NF_Marshal_Context *c, const M_ACL *msg);
extern int NF_Marshal_Command(NF_Marshal_Context *c, const M_Command *msg);
extern int NF_Marshal_ModuleAttribList(NF_Marshal_Context *c, const M_ModuleAttribList *msg);
extern int NF_Marshal_KeyHashAndMech(NF_Marshal_Context *c, const M_KeyHashAndMech *msg);
extern int NF_Marshal_PermissionGroup(NF_Marshal_Context *c, const M_PermissionGroup *msg);
extern int NF_Marshal_EnquiryDataOne(NF_Marshal_Context *c, const M_EnquiryDataOne *msg);
extern int NF_Marshal_EnquiryDataTwo(NF_Marshal_Context *c, const M_EnquiryDataTwo *msg);
extern int NF_Marshal_EnquiryDataThree(NF_Marshal_Context *c, const M_EnquiryDataThree *msg);
extern int NF_Marshal_EnquiryDataFour(NF_Marshal_Context *c, const M_EnquiryDataFour *msg);
extern int NF_Marshal_EnquiryDataFive(NF_Marshal_Context *c, const M_EnquiryDataFive *msg);
extern int NF_Marshal_EnquiryDataSix(NF_Marshal_Context *c, const M_EnquiryDataSix *msg);
extern int NF_Marshal_ModuleAttrib(NF_Marshal_Context *c, const M_ModuleAttrib *msg);
extern int NF_Marshal_UseLimit(NF_Marshal_Context *c, const M_UseLimit *msg);
extern int NF_Marshal_Action(NF_Marshal_Context *c, const M_Action *msg);
extern int NF_Marshal_KeyHashAttrib(NF_Marshal_Context *c, const M_KeyHashAttrib *msg);
extern int NF_Marshal_ModuleCert(NF_Marshal_Context *c, const M_ModuleCert *msg);
extern int NF_Marshal_Reply(NF_Marshal_Context *c, const M_Reply *msg);
extern int NF_Marshal_ImageMetaDataHeader(NF_Marshal_Context *c, const M_ImageMetaDataHeader *msg);
extern int NF_Marshal_ImageMetaData(NF_Marshal_Context *c, const M_ImageMetaData *msg);
extern int NF_Marshal_OldProgrammingSignedData(NF_Marshal_Context *c, const M_OldProgrammingSignedData *msg);
extern int NF_Marshal_ProgrammingSignedData(NF_Marshal_Context *c, const M_ProgrammingSignedData *msg);
extern int NF_Marshal_FirmwareFileHeader(NF_Marshal_Context *c, const M_FirmwareFileHeader *msg);
extern int NF_Marshal_FirmwareFileData(NF_Marshal_Context *c, const M_FirmwareFileData *msg);
extern int NF_Marshal_SigningKeys(NF_Marshal_Context *c, const M_SigningKeys *msg);
extern int NF_Marshal_CertSignMessage(NF_Marshal_Context *c, const M_CertSignMessage *msg);
extern int NF_Marshal_ModCertMsg(NF_Marshal_Context *c, const M_ModCertMsg *msg);
extern int NF_Marshal_StandaloneCert(NF_Marshal_Context *c, const M_StandaloneCert *msg);
extern int NF_Marshal_Warrant(NF_Marshal_Context *c, const M_Warrant *msg);
extern int NF_Marshal_ModuleAttribProof(NF_Marshal_Context *c, const M_ModuleAttribProof *msg);
extern int NF_Marshal_BlobData(NF_Marshal_Context *c, const M_BlobData *msg);
extern int NF_Marshal_ModuleChannelOpenInfo(NF_Marshal_Context *c, const M_ModuleChannelOpenInfo *msg);
extern int NF_Marshal_ImpathKXMessage(NF_Marshal_Context *c, const M_ImpathKXMessage *msg);
extern int NF_Marshal_ImpathMessage(NF_Marshal_Context *c, const M_ImpathMessage *msg);
extern int NF_Marshal_ImpathCipherText(NF_Marshal_Context *c, const M_ImpathCipherText *msg);
extern int NF_Marshal_SignedImage(NF_Marshal_Context *c, const M_SignedImage *msg);
extern int NF_Marshal_SEECertData(NF_Marshal_Context *c, const M_SEECertData *msg);
extern int NF_Marshal_HashedSignedImage(NF_Marshal_Context *c, const M_HashedSignedImage *msg);
extern int NF_Marshal_CodeSignMessage(NF_Marshal_Context *c, const M_CodeSignMessage *msg);
extern int NF_Marshal_SEEJobArgs(NF_Marshal_Context *c, const M_SEEJobArgs *msg);
extern int NF_Marshal_SEEJobRes(NF_Marshal_Context *c, const M_SEEJobRes *msg);
extern int NF_Marshal_TicketInfo(NF_Marshal_Context *c, const M_TicketInfo *msg);
extern int NF_Marshal_Ticket(NF_Marshal_Context *c, const M_Ticket *msg);
extern int NF_Marshal_SKYCertList(NF_Marshal_Context *c, const M_SKYCertList *msg);
extern int NF_Marshal_KeyCert(NF_Marshal_Context *c, const M_KeyCert *msg);

/* --- External dependencies --- */

extern int NF_Marshal_fixedoctetstring(NF_Marshal_Context *c, const unsigned char *p, int sz);
extern int NF_Marshal_length(NF_Marshal_Context *c, NF_Marshal_Context *cc);
extern int NF_Marshal_padding(NF_Marshal_Context *c, NF_Marshal_Context *cc);
extern int NF_Marshal_Command_header_callback(NF_Marshal_Context *c, const M_Command *msg);

/*----- That's all, folks -------------------------------------------------*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nfast\inc\messages-a-unmar.h ===
/* -*-c-*-
 *
 * Generated by Marshmallow at 2003-04-16T17:14:24
 */

#ifndef MESSAGES_A_UNMAR_H
#define MESSAGES_A_UNMAR_H

/* --- Unmarshalling context --- */

#ifndef NF_UNMARSHAL_CONTEXT
#define NF_UNMARSHAL_CONTEXT

typedef struct NF_Unmarshal_Context {
  const unsigned char *ip;
  int remain;
  struct NF_UserData *u;
} NF_Unmarshal_Context;

#endif

/* --- Exported types --- */

extern int NF_Unmarshal_Word(NF_Unmarshal_Context *c, M_Word *msg);
extern int NF_Unmarshal_ByteBlock(NF_Unmarshal_Context *c, M_ByteBlock *msg);
extern int NF_Unmarshal_ASCIIString(NF_Unmarshal_Context *c, M_ASCIIString *msg);
extern int NF_Unmarshal_MustBeZeroWord(NF_Unmarshal_Context *c, M_MustBeZeroWord *msg);
extern int NF_Unmarshal_Hash(NF_Unmarshal_Context *c, M_Hash *msg);
extern int NF_Unmarshal_Status(NF_Unmarshal_Context *c, M_Status *msg);
extern int NF_Unmarshal_nCErrno(NF_Unmarshal_Context *c, M_nCErrno *msg);
extern int NF_Unmarshal_Status_nCErrno_ErrorInfo(NF_Unmarshal_Context *c, M_Status_nCErrno_ErrorInfo *msg);
extern int NF_Unmarshal_KeyHash(NF_Unmarshal_Context *c, M_KeyHash *msg);
extern int NF_Unmarshal_Status__ErrorInfo(NF_Unmarshal_Context *c, M_Status__ErrorInfo *msg, M_Status *tag);
extern int NF_Unmarshal_StatusErrorInfo(NF_Unmarshal_Context *c, M_StatusErrorInfo *msg);
extern int NF_Unmarshal_NetworkAddress(NF_Unmarshal_Context *c, M_NetworkAddress *msg);
extern int NF_Unmarshal_KeyID(NF_Unmarshal_Context *c, M_KeyID *msg);
extern int NF_Unmarshal_ModuleID(NF_Unmarshal_Context *c, M_ModuleID *msg);
extern int NF_Unmarshal_ClientID(NF_Unmarshal_Context *c, M_ClientID *msg);
extern int NF_Unmarshal_SlotID(NF_Unmarshal_Context *c, M_SlotID *msg);
extern int NF_Unmarshal_LimitID(NF_Unmarshal_Context *c, M_LimitID *msg);
extern int NF_Unmarshal_TokenHash(NF_Unmarshal_Context *c, M_TokenHash *msg);
extern int NF_Unmarshal_KMHash(NF_Unmarshal_Context *c, M_KMHash *msg);
extern int NF_Unmarshal_PhysToken(NF_Unmarshal_Context *c, M_PhysToken *msg);
extern int NF_Unmarshal_SlotType(NF_Unmarshal_Context *c, M_SlotType *msg);
extern int NF_Unmarshal_SlotType__SlotExData(NF_Unmarshal_Context *c, M_SlotType__SlotExData *msg, M_SlotType *tag);
extern int NF_Unmarshal_ClientChannelOpenInfo(NF_Unmarshal_Context *c, M_ClientChannelOpenInfo *msg);
extern int NF_Unmarshal_ChannelOpenInfo(NF_Unmarshal_Context *c, M_ChannelOpenInfo *msg);
extern int NF_Unmarshal_Bignum(NF_Unmarshal_Context *c, M_Bignum *msg);
extern int NF_Unmarshal_KeyData(NF_Unmarshal_Context *c, M_KeyData *msg);
extern int NF_Unmarshal_CipherText(NF_Unmarshal_Context *c, M_CipherText *msg);
extern int NF_Unmarshal_Certificate(NF_Unmarshal_Context *c, M_Certificate *msg);
extern int NF_Unmarshal_ImpathKXGroup(NF_Unmarshal_Context *c, M_ImpathKXGroup *msg);
extern int NF_Unmarshal_Nonce(NF_Unmarshal_Context *c, M_Nonce *msg);
extern int NF_Unmarshal_PlainText(NF_Unmarshal_Context *c, M_PlainText *msg);
extern int NF_Unmarshal_KeyGenParams(NF_Unmarshal_Context *c, M_KeyGenParams *msg);
extern int NF_Unmarshal_IV(NF_Unmarshal_Context *c, M_IV *msg);
extern int NF_Unmarshal_DeriveMech(NF_Unmarshal_Context *c, M_DeriveMech *msg);
extern int NF_Unmarshal_DeriveMech__DKParams(NF_Unmarshal_Context *c, M_DeriveMech__DKParams *msg, M_DeriveMech *tag);
extern int NF_Unmarshal_Tag(NF_Unmarshal_Context *c, M_Tag *msg);
extern int NF_Unmarshal_ImpathKXGroupSelection(NF_Unmarshal_Context *c, M_ImpathKXGroupSelection *msg);
extern int NF_Unmarshal_RemoteModule(NF_Unmarshal_Context *c, M_RemoteModule *msg);
extern int NF_Unmarshal_CertificateList(NF_Unmarshal_Context *c, M_CertificateList *msg);
extern int NF_Unmarshal_ACL(NF_Unmarshal_Context *c, M_ACL *msg);
extern int NF_Unmarshal_Command(NF_Unmarshal_Context *c, M_Command *msg);
extern int NF_Unmarshal_ModuleAttribList(NF_Unmarshal_Context *c, M_ModuleAttribList *msg);
extern int NF_Unmarshal_KeyHashAndMech(NF_Unmarshal_Context *c, M_KeyHashAndMech *msg);
extern int NF_Unmarshal_PermissionGroup(NF_Unmarshal_Context *c, M_PermissionGroup *msg);
extern int NF_Unmarshal_EnquiryDataOne(NF_Unmarshal_Context *c, M_EnquiryDataOne *msg);
extern int NF_Unmarshal_EnquiryDataTwo(NF_Unmarshal_Context *c, M_EnquiryDataTwo *msg);
extern int NF_Unmarshal_EnquiryDataThree(NF_Unmarshal_Context *c, M_EnquiryDataThree *msg);
extern int NF_Unmarshal_EnquiryDataFour(NF_Unmarshal_Context *c, M_EnquiryDataFour *msg);
extern int NF_Unmarshal_EnquiryDataFive(NF_Unmarshal_Context *c, M_EnquiryDataFive *msg);
extern int NF_Unmarshal_EnquiryDataSix(NF_Unmarshal_Context *c, M_EnquiryDataSix *msg);
extern int NF_Unmarshal_ModuleAttrib(NF_Unmarshal_Context *c, M_ModuleAttrib *msg);
extern int NF_Unmarshal_UseLimit(NF_Unmarshal_Context *c, M_UseLimit *msg);
extern int NF_Unmarshal_Action(NF_Unmarshal_Context *c, M_Action *msg);
extern int NF_Unmarshal_KeyHashAttrib(NF_Unmarshal_Context *c, M_KeyHashAttrib *msg);
extern int NF_Unmarshal_ModuleCert(NF_Unmarshal_Context *c, M_ModuleCert *msg);
extern int NF_Unmarshal_Reply(NF_Unmarshal_Context *c, M_Reply *msg);
extern int NF_Unmarshal_ImageMetaDataHeader(NF_Unmarshal_Context *c, M_ImageMetaDataHeader *msg);
extern int NF_Unmarshal_ImageMetaData(NF_Unmarshal_Context *c, M_ImageMetaData *msg);
extern int NF_Unmarshal_OldProgrammingSignedData(NF_Unmarshal_Context *c, M_OldProgrammingSignedData *msg);
extern int NF_Unmarshal_ProgrammingSignedData(NF_Unmarshal_Context *c, M_ProgrammingSignedData *msg);
extern int NF_Unmarshal_FirmwareFileHeader(NF_Unmarshal_Context *c, M_FirmwareFileHeader *msg);
extern int NF_Unmarshal_FirmwareFileData(NF_Unmarshal_Context *c, M_FirmwareFileData *msg);
extern int NF_Unmarshal_SigningKeys(NF_Unmarshal_Context *c, M_SigningKeys *msg);
extern int NF_Unmarshal_CertSignMessage(NF_Unmarshal_Context *c, M_CertSignMessage *msg);
extern int NF_Unmarshal_ModCertMsg(NF_Unmarshal_Context *c, M_ModCertMsg *msg);
extern int NF_Unmarshal_StandaloneCert(NF_Unmarshal_Context *c, M_StandaloneCert *msg);
extern int NF_Unmarshal_Warrant(NF_Unmarshal_Context *c, M_Warrant *msg);
extern int NF_Unmarshal_ModuleAttribProof(NF_Unmarshal_Context *c, M_ModuleAttribProof *msg);
extern int NF_Unmarshal_BlobData(NF_Unmarshal_Context *c, M_BlobData *msg);
extern int NF_Unmarshal_ModuleChannelOpenInfo(NF_Unmarshal_Context *c, M_ModuleChannelOpenInfo *msg);
extern int NF_Unmarshal_ImpathKXMessage(NF_Unmarshal_Context *c, M_ImpathKXMessage *msg);
extern int NF_Unmarshal_ImpathMessage(NF_Unmarshal_Context *c, M_ImpathMessage *msg);
extern int NF_Unmarshal_ImpathCipherText(NF_Unmarshal_Context *c, M_ImpathCipherText *msg);
extern int NF_Unmarshal_SignedImage(NF_Unmarshal_Context *c, M_SignedImage *msg);
extern int NF_Unmarshal_SEECertData(NF_Unmarshal_Context *c, M_SEECertData *msg);
extern int NF_Unmarshal_HashedSignedImage(NF_Unmarshal_Context *c, M_HashedSignedImage *msg);
extern int NF_Unmarshal_CodeSignMessage(NF_Unmarshal_Context *c, M_CodeSignMessage *msg);
extern int NF_Unmarshal_SEEJobArgs(NF_Unmarshal_Context *c, M_SEEJobArgs *msg);
extern int NF_Unmarshal_SEEJobRes(NF_Unmarshal_Context *c, M_SEEJobRes *msg);
extern int NF_Unmarshal_TicketInfo(NF_Unmarshal_Context *c, M_TicketInfo *msg);
extern int NF_Unmarshal_Ticket(NF_Unmarshal_Context *c, M_Ticket *msg);
extern int NF_Unmarshal_SKYCertList(NF_Unmarshal_Context *c, M_SKYCertList *msg);
extern int NF_Unmarshal_KeyCert(NF_Unmarshal_Context *c, M_KeyCert *msg);

/* --- External dependencies --- */

extern int NF_Unmarshal_fixedoctetstring(NF_Unmarshal_Context *c, unsigned char *p, int sz);
extern int NF_Unmarshal_length(NF_Unmarshal_Context *c, NF_Unmarshal_Context *cc);
extern int NF_Unmarshal_padding(NF_Unmarshal_Context *c, NF_Unmarshal_Context *cc);
extern int NF_Unmarshal_Command_header_callback(NF_Unmarshal_Context *c, M_Command *msg);
extern int NF_Unmarshal_Reply_header_callback(NF_Unmarshal_Context *c, M_Reply *msg);
extern int NF_Unmarshal_BlobFormat_Indirect_BlobExData_header_callback(NF_Unmarshal_Context *c, M_BlobFormat_Indirect_BlobExData *msg);

/*----- That's all, folks -------------------------------------------------*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nfast\inc\messages-akm-dh.h ===
/* -*-c-*-
 *
 * Generated by Marshmallow at 2003-04-25T18:38:58
 */

#ifndef MESSAGES_AKM_DH_H
#define MESSAGES_AKM_DH_H

/*----- Enumeration constants ---------------------------------------------*/

/* --- KeyMgmtEntType codes --- */

#define KeyMgmtEntType_Sentinel                                          0
#define KeyMgmtEntType_Index                                             2
#define KeyMgmtEntType_OldHashKA                                         3
#define KeyMgmtEntType_ESNModule                                         4
#define KeyMgmtEntType_DateWorldInit                                     5
#define KeyMgmtEntType_ParamsLTU                                         6
#define KeyMgmtEntType_Ident                                             8
#define KeyMgmtEntType_AppName                                           9
#define KeyMgmtEntType_NonKey                                          100
#define KeyMgmtEntType_Name                                            101
#define KeyMgmtEntType_ParamsLTNSO                                     122
#define KeyMgmtEntType_BlobKNSO                                        123
#define KeyMgmtEntType_ParamsLTM                                       124
#define KeyMgmtEntType_BlobKM                                          125
#define KeyMgmtEntType_BlobKMC                                         126
#define KeyMgmtEntType_ParamsLTP                                       127
#define KeyMgmtEntType_BlobKP                                          128
#define KeyMgmtEntType_ParamsLTR                                       129
#define KeyMgmtEntType_BlobKRE                                         130
#define KeyMgmtEntType_BlobKRA                                         131
#define KeyMgmtEntType_BlobPubKNSO                                     132
#define KeyMgmtEntType_BlobPubKMC                                      133
#define KeyMgmtEntType_CertKMaKMCbKNSO                                 134
#define KeyMgmtEntType_CertKPbKNSO                                     135
#define KeyMgmtEntType_CertKREaKRAbKNSO                                136
#define KeyMgmtEntType_HashKM                                          137
#define KeyMgmtEntType_HashKNSO                                        138
#define KeyMgmtEntType_CertKMaKMCbKMC                                  139
#define KeyMgmtEntType_BlobPubKRE                                      140
#define KeyMgmtEntType_BlobPubKRA                                      141
#define KeyMgmtEntType_HashKRE                                         142
#define KeyMgmtEntType_HashKRA                                         143
#define KeyMgmtEntType_CertKMaKMCaKFIPSbKNSO                           144
#define KeyMgmtEntType_CertKMaKMCaKFIPSbKMC                            145
#define KeyMgmtEntType_BlobKFIPS                                       146
#define KeyMgmtEntType_BlobPubKFIPS                                    147
#define KeyMgmtEntType_CertKMaKMCaKFIPSbKFIPS                          148
#define KeyMgmtEntType_KeyPubKNSO                                      149
#define KeyMgmtEntType_CertDelgFIPSbNSO                                150
#define KeyMgmtEntType_MesgDelgFIPSbNSO                                151
#define KeyMgmtEntType_ParamsLTFIPS                                    152
#define KeyMgmtEntType_HashKFIPS                                       153
#define KeyMgmtEntType_HashKMC                                         154
#define KeyMgmtEntType_BlobPubKP                                       155
#define KeyMgmtEntType_HashKP                                          156
#define KeyMgmtEntType_CertGenKNSO                                     157
#define KeyMgmtEntType_MesgGenKNSO                                     158
#define KeyMgmtEntType_ParamsLTRKilled                                 159
#define KeyMgmtEntType_CertKREaKRAbKNSOKilled                          160
#define KeyMgmtEntType_HashKRAKilled                                   161
#define KeyMgmtEntType_HashKREKilled                                   162
#define KeyMgmtEntType_ParamsLTNV                                      163
#define KeyMgmtEntType_BlobKNV                                         164
#define KeyMgmtEntType_BlobPubKNV                                      165
#define KeyMgmtEntType_HashKNV                                         166
#define KeyMgmtEntType_ParamsLTRTC                                     167
#define KeyMgmtEntType_BlobKRTC                                        168
#define KeyMgmtEntType_BlobPubKRTC                                     169
#define KeyMgmtEntType_HashKRTC                                        170
#define KeyMgmtEntType_CertKNVbKNSO                                    171
#define KeyMgmtEntType_MesgDelgNVbNSO                                  172
#define KeyMgmtEntType_CertDelgNVbNSO                                  173
#define KeyMgmtEntType_MesgDelgRTCbNSO                                 174
#define KeyMgmtEntType_CertDelgRTCbNSO                                 175
#define KeyMgmtEntType_CertGenKM                                       176
#define KeyMgmtEntType_MesgGenKM                                       177
#define KeyMgmtEntType_CertGenKMC                                      178
#define KeyMgmtEntType_MesgGenKMC                                      179
#define KeyMgmtEntType_CertGenKRA                                      180
#define KeyMgmtEntType_MesgGenKRA                                      181
#define KeyMgmtEntType_CertGenKRE                                      182
#define KeyMgmtEntType_MesgGenKRE                                      183
#define KeyMgmtEntType_CertGenKP                                       184
#define KeyMgmtEntType_MesgGenKP                                       185
#define KeyMgmtEntType_ESNGen                                          186
#define KeyMgmtEntType_MesgGenKNV                                      187
#define KeyMgmtEntType_CertGenKNV                                      188
#define KeyMgmtEntType_MesgGenKRTC                                     189
#define KeyMgmtEntType_CertGenKRTC                                     190
#define KeyMgmtEntType_CertKRTCbKNSO                                   191
#define KeyMgmtEntType_CertKDSEEbKNSO                                  192
#define KeyMgmtEntType_CertDSEEALLbKNSO                                193
#define KeyMgmtEntType_ParamsLTDSEE                                    194
#define KeyMgmtEntType_BlobKDSEE                                       195
#define KeyMgmtEntType_BlobPubKDSEE                                    196
#define KeyMgmtEntType_HashKDSEE                                       197
#define KeyMgmtEntType_MesgDelgDSEEbNSO                                198
#define KeyMgmtEntType_CertDelgDSEEbNSO                                199
#define KeyMgmtEntType_BlobKA                                          200
#define KeyMgmtEntType_OldAppName                                      201
#define KeyMgmtEntType_AppInfo                                         202
#define KeyMgmtEntType_BlobRecoveryKA                                  203
#define KeyMgmtEntType_HashKA                                          204
#define KeyMgmtEntType_CertKMLaESN                                     210
#define KeyMgmtEntType_HashKML                                         211
#define KeyMgmtEntType_RecoverablePIN                                  212
#define KeyMgmtEntType_MesgSendbKMC                                    213
#define KeyMgmtEntType_CertSendbKMC                                    214
#define KeyMgmtEntType_ParamsLTFTO                                     220
#define KeyMgmtEntType_BlobKFTO                                        221
#define KeyMgmtEntType_BlobPubKFTO                                     222
#define KeyMgmtEntType_HashKFTO                                        223
#define KeyMgmtEntType_CertKFTObKNSO                                   224
#define KeyMgmtEntType_MesgDelgFTObNSO                                 225
#define KeyMgmtEntType_CertDelgFTObNSO                                 226
#define KeyMgmtEntType_MesgGenKFTO                                     227
#define KeyMgmtEntType_CertGenKFTO                                     228
#define KeyMgmtEntType_BlobPubKA                                       301
#define KeyMgmtEntType_ExtFilename                                     302
#define KeyMgmtEntType_ExtFilenameHost                                 303
#define KeyMgmtEntType_BlobPubKML                                      304
#define KeyMgmtEntType_CertGenKA                                       305
#define KeyMgmtEntType_MesgGenKA                                       306
#define KeyMgmtEntType_IdentSEEInteg                                   307
#define KeyMgmtEntType_TimeLimit                                       308
#define KeyMgmtEntType_PerAuthUseLimit                                 309
#define KeyMgmtEntType_CertModuleState                                 310
#define KeyMgmtEntType_MesgModuleState                                 311
#define KeyMgmtEntType_MesgGenKDSEE                                    400
#define KeyMgmtEntType_CertGenKDSEE                                    401

/*----- Flag constants ----------------------------------------------------*/

/*----- Data structure formats --------------------------------------------*
 *
 * KEYMGMTFILEENTRY:
 *   WORD                                     type
 *   BYTEBLOCK                                data
 *
 * KEYMGMTFILE:
 *   HASH                                     magic
 *   WORD                                     timehigh
 *   WORD                                     timelow
 *   WORD                                     n_entries
 *   n_entries * KEYMGMTFILEENTRY             entries
 *
 * The following message variants are empty.
 *
 */

/*----- That's all, folks -------------------------------------------------*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nfast\inc\messages-akm-en.h ===
/* -*-c-*-
 *
 * Generated by Marshmallow at 2003-04-25T18:38:59
 */

#ifndef MESSAGES_AKM_EN_H
#define MESSAGES_AKM_EN_H

/*----- Enumeration constants ---------------------------------------------*/

/* --- Notes on enumeration naming --- *
 *
 * Each enumeration `Foo' has a `Foo__Max' constant defined, which is the 
 * smallest integer greater than all members of the enumeration.  This is 
 * useful if you're trying to make arrays of things.
 */

/* --- KeyMgmtEntType codes --- */

typedef enum M_KeyMgmtEntType {
  KeyMgmtEntType_Sentinel =                                             0,
  KeyMgmtEntType_Index =                                                2,
  KeyMgmtEntType_OldHashKA =                                            3,
  KeyMgmtEntType_ESNModule =                                            4,
  KeyMgmtEntType_DateWorldInit =                                        5,
  KeyMgmtEntType_ParamsLTU =                                            6,
  KeyMgmtEntType_Ident =                                                8,
  KeyMgmtEntType_AppName =                                              9,
  KeyMgmtEntType_NonKey =                                             100,
  KeyMgmtEntType_Name =                                               101,
  KeyMgmtEntType_ParamsLTNSO =                                        122,
  KeyMgmtEntType_BlobKNSO =                                           123,
  KeyMgmtEntType_ParamsLTM =                                          124,
  KeyMgmtEntType_BlobKM =                                             125,
  KeyMgmtEntType_BlobKMC =                                            126,
  KeyMgmtEntType_ParamsLTP =                                          127,
  KeyMgmtEntType_BlobKP =                                             128,
  KeyMgmtEntType_ParamsLTR =                                          129,
  KeyMgmtEntType_BlobKRE =                                            130,
  KeyMgmtEntType_BlobKRA =                                            131,
  KeyMgmtEntType_BlobPubKNSO =                                        132,
  KeyMgmtEntType_BlobPubKMC =                                         133,
  KeyMgmtEntType_CertKMaKMCbKNSO =                                    134,
  KeyMgmtEntType_CertKPbKNSO =                                        135,
  KeyMgmtEntType_CertKREaKRAbKNSO =                                   136,
  KeyMgmtEntType_HashKM =                                             137,
  KeyMgmtEntType_HashKNSO =                                           138,
  KeyMgmtEntType_CertKMaKMCbKMC =                                     139,
  KeyMgmtEntType_BlobPubKRE =                                         140,
  KeyMgmtEntType_BlobPubKRA =                                         141,
  KeyMgmtEntType_HashKRE =                                            142,
  KeyMgmtEntType_HashKRA =                                            143,
  KeyMgmtEntType_CertKMaKMCaKFIPSbKNSO =                              144,
  KeyMgmtEntType_CertKMaKMCaKFIPSbKMC =                               145,
  KeyMgmtEntType_BlobKFIPS =                                          146,
  KeyMgmtEntType_BlobPubKFIPS =                                       147,
  KeyMgmtEntType_CertKMaKMCaKFIPSbKFIPS =                             148,
  KeyMgmtEntType_KeyPubKNSO =                                         149,
  KeyMgmtEntType_CertDelgFIPSbNSO =                                   150,
  KeyMgmtEntType_MesgDelgFIPSbNSO =                                   151,
  KeyMgmtEntType_ParamsLTFIPS =                                       152,
  KeyMgmtEntType_HashKFIPS =                                          153,
  KeyMgmtEntType_HashKMC =                                            154,
  KeyMgmtEntType_BlobPubKP =                                          155,
  KeyMgmtEntType_HashKP =                                             156,
  KeyMgmtEntType_CertGenKNSO =                                        157,
  KeyMgmtEntType_MesgGenKNSO =                                        158,
  KeyMgmtEntType_ParamsLTRKilled =                                    159,
  KeyMgmtEntType_CertKREaKRAbKNSOKilled =                             160,
  KeyMgmtEntType_HashKRAKilled =                                      161,
  KeyMgmtEntType_HashKREKilled =                                      162,
  KeyMgmtEntType_ParamsLTNV =                                         163,
  KeyMgmtEntType_BlobKNV =                                            164,
  KeyMgmtEntType_BlobPubKNV =                                         165,
  KeyMgmtEntType_HashKNV =                                            166,
  KeyMgmtEntType_ParamsLTRTC =                                        167,
  KeyMgmtEntType_BlobKRTC =                                           168,
  KeyMgmtEntType_BlobPubKRTC =                                        169,
  KeyMgmtEntType_HashKRTC =                                           170,
  KeyMgmtEntType_CertKNVbKNSO =                                       171,
  KeyMgmtEntType_MesgDelgNVbNSO =                                     172,
  KeyMgmtEntType_CertDelgNVbNSO =                                     173,
  KeyMgmtEntType_MesgDelgRTCbNSO =                                    174,
  KeyMgmtEntType_CertDelgRTCbNSO =                                    175,
  KeyMgmtEntType_CertGenKM =                                          176,
  KeyMgmtEntType_MesgGenKM =                                          177,
  KeyMgmtEntType_CertGenKMC =                                         178,
  KeyMgmtEntType_MesgGenKMC =                                         179,
  KeyMgmtEntType_CertGenKRA =                                         180,
  KeyMgmtEntType_MesgGenKRA =                                         181,
  KeyMgmtEntType_CertGenKRE =                                         182,
  KeyMgmtEntType_MesgGenKRE =                                         183,
  KeyMgmtEntType_CertGenKP =                                          184,
  KeyMgmtEntType_MesgGenKP =                                          185,
  KeyMgmtEntType_ESNGen =                                             186,
  KeyMgmtEntType_MesgGenKNV =                                         187,
  KeyMgmtEntType_CertGenKNV =                                         188,
  KeyMgmtEntType_MesgGenKRTC =                                        189,
  KeyMgmtEntType_CertGenKRTC =                                        190,
  KeyMgmtEntType_CertKRTCbKNSO =                                      191,
  KeyMgmtEntType_CertKDSEEbKNSO =                                     192,
  KeyMgmtEntType_CertDSEEALLbKNSO =                                   193,
  KeyMgmtEntType_ParamsLTDSEE =                                       194,
  KeyMgmtEntType_BlobKDSEE =                                          195,
  KeyMgmtEntType_BlobPubKDSEE =                                       196,
  KeyMgmtEntType_HashKDSEE =                                          197,
  KeyMgmtEntType_MesgDelgDSEEbNSO =                                   198,
  KeyMgmtEntType_CertDelgDSEEbNSO =                                   199,
  KeyMgmtEntType_BlobKA =                                             200,
  KeyMgmtEntType_OldAppName =                                         201,
  KeyMgmtEntType_AppInfo =                                            202,
  KeyMgmtEntType_BlobRecoveryKA =                                     203,
  KeyMgmtEntType_HashKA =                                             204,
  KeyMgmtEntType_CertKMLaESN =                                        210,
  KeyMgmtEntType_HashKML =                                            211,
  KeyMgmtEntType_RecoverablePIN =                                     212,
  KeyMgmtEntType_MesgSendbKMC =                                       213,
  KeyMgmtEntType_CertSendbKMC =                                       214,
  KeyMgmtEntType_ParamsLTFTO =                                        220,
  KeyMgmtEntType_BlobKFTO =                                           221,
  KeyMgmtEntType_BlobPubKFTO =                                        222,
  KeyMgmtEntType_HashKFTO =                                           223,
  KeyMgmtEntType_CertKFTObKNSO =                                      224,
  KeyMgmtEntType_MesgDelgFTObNSO =                                    225,
  KeyMgmtEntType_CertDelgFTObNSO =                                    226,
  KeyMgmtEntType_MesgGenKFTO =                                        227,
  KeyMgmtEntType_CertGenKFTO =                                        228,
  KeyMgmtEntType_BlobPubKA =                                          301,
  KeyMgmtEntType_ExtFilename =                                        302,
  KeyMgmtEntType_ExtFilenameHost =                                    303,
  KeyMgmtEntType_BlobPubKML =                                         304,
  KeyMgmtEntType_CertGenKA =                                          305,
  KeyMgmtEntType_MesgGenKA =                                          306,
  KeyMgmtEntType_IdentSEEInteg =                                      307,
  KeyMgmtEntType_TimeLimit =                                          308,
  KeyMgmtEntType_PerAuthUseLimit =                                    309,
  KeyMgmtEntType_CertModuleState =                                    310,
  KeyMgmtEntType_MesgModuleState =                                    311,
  KeyMgmtEntType_MesgGenKDSEE =                                       400,
  KeyMgmtEntType_CertGenKDSEE =                                       401,
  KeyMgmtEntType__Max =                                               402 
} M_KeyMgmtEntType;

/*----- Flag constants ----------------------------------------------------*/

/* --- Notes on flag naming --- *
 *
 * For each flagset `Foo_flags', we define some useful masks:
 *
 *   * `Foo_flags__reserved', if defined, is the mask of `harmless' flags,
 *     which may be set without upsetting existing software.
 *
 *   * `Foo_flags__allflags' is the mask of all currently-defined flags.
 *
 *   * `Foo_flags__presentflags' is the mask of flags which enable optional
 *     parts of data structures.
 */

/*----- That's all, folks -------------------------------------------------*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nfast\inc\messages-akm-enstr.h ===
/* -*-c-*-
 *
 * Generated by Marshmallow at 2003-04-25T18:38:59
 */

#ifndef MESSAGES_AKM_ENSTR_H
#define MESSAGES_AKM_ENSTR_H

/* --- Table format --- */

#ifndef NF_VALINFO
#define NF_VALINFO

typedef struct NF_ValInfo {
  M_Word code;
  const char *string;
} NF_ValInfo;

#endif

/* --- Required functions --- */

const char *NF_Lookup(M_Word val, const NF_ValInfo *vit);
int NF_LookupString(const char *string, M_Word *result, const NF_ValInfo *vit);

/* --- Enumeration and flag tables --- */

extern const NF_ValInfo NF_KeyMgmtEntType_enumtable[];


/*----- That's all, folks -------------------------------------------------*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nfast\inc\messages-akm-eh.h ===
/* -*-c-*-
 *
 * Generated by Marshmallow at 2003-04-25T18:38:58
 */

#ifndef MESSAGES_AKM_EH_H
#define MESSAGES_AKM_EH_H

struct NF_UserData;

/* --- Required functions --- */

extern void *NF_Malloc(size_t sz, struct NF_UserData *u);
extern int NF_Free(void *p, struct NF_UserData *u);
extern int NFErr_EnumRange(const char *ty, const char *mem, const char *e, M_Word val, int max, struct NF_UserData *u);
extern int NFErr_TableTooLarge(const char *ty, const char *mem, const char *tab, M_Word n, int max, struct NF_UserData *u);

/*----- That's all, folks -------------------------------------------------*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nfast\inc\messages-akm-im.h ===
/* -*-c-*-
 *
 * Generated by Marshmallow at 2003-04-25T18:38:59
 */

#ifndef MESSAGES_AKM_IM_H
#define MESSAGES_AKM_IM_H

/* --- Structure KeyMgmtFileEntry --- */

typedef struct M_KeyMgmtFileEntry M_KeyMgmtFileEntry;

/* --- Structure KeyMgmtFileEntry --- */

struct M_KeyMgmtFileEntry {
  M_Word type;
  M_ByteBlock data;
};

/* --- Structure KeyMgmtFile --- */

typedef struct M_KeyMgmtFile M_KeyMgmtFile;

/* --- Vector vec_KeyMgmtFileEntry --- */

typedef M_KeyMgmtFileEntry *M_vec_KeyMgmtFileEntry;

/* --- Structure KeyMgmtFile --- */

struct M_KeyMgmtFile {
  M_Hash magic;
  M_Word timehigh;
  M_Word timelow;
  int n_entries;
  M_vec_KeyMgmtFileEntry entries;
};

/*----- That's all, folks -------------------------------------------------*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nfast\inc\messages-akm-free.h ===
/* -*-c-*-
 *
 * Generated by Marshmallow at 2003-04-25T18:38:59
 */

#ifndef MESSAGES_AKM_FREE_H
#define MESSAGES_AKM_FREE_H

/* --- Freeing context --- */

#ifndef NF_FREE_CONTEXT
#define NF_FREE_CONTEXT

typedef struct NF_Free_Context {
  struct NF_UserData *u;
} NF_Free_Context;

#endif

/* --- Exported types --- */

extern int NF_Free_KeyMgmtFileEntry(NF_Free_Context *c, M_KeyMgmtFileEntry *msg);
extern int NF_Free_KeyMgmtEntType(NF_Free_Context *c, M_KeyMgmtEntType *msg);
extern int NF_Free_KeyMgmtFile(NF_Free_Context *c, M_KeyMgmtFile *msg);

/* --- External dependencies --- */


/*----- That's all, folks -------------------------------------------------*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nfast\inc\messages-akm-mar.h ===
/* -*-c-*-
 *
 * Generated by Marshmallow at 2003-04-25T18:38:59
 */

#ifndef MESSAGES_AKM_MAR_H
#define MESSAGES_AKM_MAR_H

/* --- Marshalling context --- */

#ifndef NF_MARSHAL_CONTEXT
#define NF_MARSHAL_CONTEXT

typedef struct NF_Marshal_Context {
  unsigned char *op;
  int remain;
  struct NF_UserData *u;
} NF_Marshal_Context;

#endif

/* --- Exported types --- */

extern int NF_Marshal_KeyMgmtFileEntry(NF_Marshal_Context *c, const M_KeyMgmtFileEntry *msg);
extern int NF_Marshal_KeyMgmtEntType(NF_Marshal_Context *c, const M_KeyMgmtEntType *msg);
extern int NF_Marshal_KeyMgmtFile(NF_Marshal_Context *c, const M_KeyMgmtFile *msg);

/* --- External dependencies --- */

extern int NF_Marshal_length(NF_Marshal_Context *c, NF_Marshal_Context *cc);
extern int NF_Marshal_padding(NF_Marshal_Context *c, NF_Marshal_Context *cc);

/*----- That's all, folks -------------------------------------------------*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nfast\inc\messages-akm-read.h ===
/* -*-c-*-
 *
 * Generated by Marshmallow at 2003-04-25T18:38:59
 */

#ifndef MESSAGES_AKM_READ_H
#define MESSAGES_AKM_READ_H

/* --- Reading context --- */

#ifndef NF_READ_CONTEXT
#define NF_READ_CONTEXT

typedef struct NF_Read_Context {
  FILE *file;
  int (*addprompt)(struct NF_Read_Context *c, const char *string);
  int (*continueindent)(struct NF_Read_Context *c, int indent);
  int (*autonewline)(struct NF_Read_Context *c);
  int comparing;
  struct NF_UserData *u;
} NF_Read_Context;

#endif

/* --- Exported types --- */

extern int NF_Read_KeyMgmtFileEntry(NF_Read_Context *c, int ind, M_KeyMgmtFileEntry *msg);
extern int NF_Read_KeyMgmtEntType(NF_Read_Context *c, int ind, M_KeyMgmtEntType *msg);
extern int NF_Read_KeyMgmtFile(NF_Read_Context *c, int ind, M_KeyMgmtFile *msg);

/* --- External dependencies --- */

extern int NF_Read_enum
	(NF_Read_Context *c, int ind, M_Word *w, M_Word max,
	 const NF_ValInfo *vit);
extern int NF_Read_length(NF_Read_Context *c, NF_Read_Context *cc);
extern int NF_Read_padding(NF_Read_Context *c, NF_Read_Context *cc);

/*----- That's all, folks -------------------------------------------------*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nfast\inc\messages-akm-print.h ===
/* -*-c-*-
 *
 * Generated by Marshmallow at 2003-04-25T18:38:59
 */

#ifndef MESSAGES_AKM_PRINT_H
#define MESSAGES_AKM_PRINT_H

#include <stdio.h>

/* --- Printing context --- */

#ifndef NF_PRINT_CONTEXT
#define NF_PRINT_CONTEXT

typedef struct NF_Print_Context {
  FILE *file;
  struct NF_UserData *u;
} NF_Print_Context;

#endif

/* --- Exported types --- */

extern int NF_Print_KeyMgmtFileEntry(NF_Print_Context *c, int ind, const M_KeyMgmtFileEntry *msg);
extern int NF_Print_KeyMgmtEntType(NF_Print_Context *c, int ind, const M_KeyMgmtEntType *msg);
extern int NF_Print_KeyMgmtFile(NF_Print_Context *c, int ind, const M_KeyMgmtFile *msg);

/* --- External dependencies --- */


/*----- That's all, folks -------------------------------------------------*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nfast\inc\messages-akm-trans.h ===
/* -*-c-*-
 *
 * Generated by Marshmallow at 2003-04-25T18:38:59
 */

#ifndef MESSAGES_AKM_TRANS_H
#define MESSAGES_AKM_TRANS_H

/* --- Translating context --- */

#ifndef NF_TRANSLATE_CONTEXT
#define NF_TRANSLATE_CONTEXT

typedef struct NF_Translate_Context {
  const unsigned char *ip;
  unsigned char *op;
  int iremain, oremain;
  struct NF_UserData *u;
} NF_Translate_Context;

#endif

/* --- Exported types --- */

extern int NF_Translate_KeyMgmtFileEntry(NF_Translate_Context *c);
extern int NF_Translate_KeyMgmtEntType(NF_Translate_Context *c, M_Word *w);
extern int NF_Translate_KeyMgmtFile(NF_Translate_Context *c);

/* --- External dependencies --- */

extern int NF_Translate_length(NF_Translate_Context *c, NF_Translate_Context *cc);
extern int NF_Translate_padding(NF_Translate_Context *c, NF_Translate_Context *cc);

/*----- That's all, folks -------------------------------------------------*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nfast\inc\messages-akm-unmar.h ===
/* -*-c-*-
 *
 * Generated by Marshmallow at 2003-04-25T18:38:59
 */

#ifndef MESSAGES_AKM_UNMAR_H
#define MESSAGES_AKM_UNMAR_H

/* --- Unmarshalling context --- */

#ifndef NF_UNMARSHAL_CONTEXT
#define NF_UNMARSHAL_CONTEXT

typedef struct NF_Unmarshal_Context {
  const unsigned char *ip;
  int remain;
  struct NF_UserData *u;
} NF_Unmarshal_Context;

#endif

/* --- Exported types --- */

extern int NF_Unmarshal_KeyMgmtFileEntry(NF_Unmarshal_Context *c, M_KeyMgmtFileEntry *msg);
extern int NF_Unmarshal_KeyMgmtEntType(NF_Unmarshal_Context *c, M_KeyMgmtEntType *msg);
extern int NF_Unmarshal_KeyMgmtFile(NF_Unmarshal_Context *c, M_KeyMgmtFile *msg);

/* --- External dependencies --- */

extern int NF_Unmarshal_length(NF_Unmarshal_Context *c, NF_Unmarshal_Context *cc);
extern int NF_Unmarshal_padding(NF_Unmarshal_Context *c, NF_Unmarshal_Context *cc);

/*----- That's all, folks -------------------------------------------------*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nfast\inc\messages-anfkm-en.h ===
/* -*-c-*-
 *
 * Generated by Marshmallow at 2003-04-25T18:39:00
 */

#ifndef MESSAGES_ANFKM_EN_H
#define MESSAGES_ANFKM_EN_H

/*----- Enumeration constants ---------------------------------------------*/

/* --- Notes on enumeration naming --- *
 *
 * Each enumeration `Foo' has a `Foo__Max' constant defined, which is the 
 * smallest integer greater than all members of the enumeration.  This is 
 * useful if you're trying to make arrays of things.
 */

/* --- SlotState codes --- */

typedef enum NFKM_SlotState {
  SlotState_UnusedTableEntry =                                          1,
  SlotState_Empty =                                                     2,
  SlotState_Blank =                                                     3,
  SlotState_Admin =                                                     4,
  SlotState_Operator =                                                  5,
  SlotState_Unidentified =                                              6,
  SlotState_Error =                                                     7,
  SlotState_Partial =                                                   8,
  SlotState__Max =                                                      9 
} NFKM_SlotState;

/* --- ModuleState codes --- */

typedef enum NFKM_ModuleState {
  ModuleState_Unknown =                                                 1,
  ModuleState_Usable =                                                  2,
  ModuleState_MaintMode =                                               3,
  ModuleState_Uninitialized =                                           4,
  ModuleState_Factory =                                                 5,
  ModuleState_Foreign =                                                 6,
  ModuleState_AccelOnly =                                               7,
  ModuleState_Failed =                                                  8,
  ModuleState_Unchecked =                                               9,
  ModuleState_InitMode =                                               10,
  ModuleState_PreInitMode =                                            11,
  ModuleState_UnusedTableEntry =                                       12,
  ModuleState__Max =                                                   13 
} NFKM_ModuleState;

/*----- Flag constants ----------------------------------------------------*/

/* --- Notes on flag naming --- *
 *
 * For each flagset `Foo_flags', we define some useful masks:
 *
 *   * `Foo_flags__reserved', if defined, is the mask of `harmless' flags,
 *     which may be set without upsetting existing software.
 *
 *   * `Foo_flags__allflags' is the mask of all currently-defined flags.
 *
 *   * `Foo_flags__presentflags' is the mask of flags which enable optional
 *     parts of data structures.
 */

/* --- CardSet_flags --- */

#define CardSet_flags_Persistent                                0x00000001
#define CardSet_flags_NotPersistent                             0x00000002
#define CardSet_flags_PINRecoveryRequired                       0x00000004
#define CardSet_flags_PINRecoveryForbidden                      0x00000008
#define CardSet_flags_RemoteEnabled                             0x00000010
#define CardSet_flags__reserved                                 0xffffffff
#define CardSet_flags__allflags                                 0x0000001f
#define CardSet_flags__presentflags                             0x00000000

/* --- CardSet versioning --- */

#define CardSet__maxversion                                              1

/* --- Card_flags --- */

#define Card_flags_RecoverablePIN                               0x00000001
#define Card_flags__reserved                                    0xffffffff
#define Card_flags__allflags                                    0x00000001
#define Card_flags__presentflags                                0x00000000

/* --- Card versioning --- */

#define Card__maxversion                                                 0

/* --- SlotInfo_flags --- */

#define SlotInfo_flags_Passphrase                               0x00010000
#define SlotInfo_flags_RemoteEnabled                            0x00020000
#define SlotInfo_flags__reserved                                0xffff0000
#define SlotInfo_flags__allflags                                0x00030000
#define SlotInfo_flags__presentflags                            0x00000000

/* --- ShareFlag --- */

#define ShareFlag_LTNSO                                         0x00000001
#define ShareFlag_LTC                                           0x00000002
#define ShareFlag_LTM                                           0x00000004
#define ShareFlag_LTR                                           0x00000008
#define ShareFlag_LTU                                           0x00000010
#define ShareFlag_LTUC                                          0x00000020
#define ShareFlag_LTFIPS                                        0x00000040
#define ShareFlag_LTP                                           0x00000080
#define ShareFlag_LTNV                                          0x00000100
#define ShareFlag_LTRTC                                         0x00000200
#define ShareFlag_LTDSEE                                        0x00000400
#define ShareFlag_LTFTO                                         0x00000800
#define ShareFlag__reserved                                     0xffffffff
#define ShareFlag__allflags                                     0x00000fff
#define ShareFlag__presentflags                                 0x00000000

/* --- SlotInfo versioning --- */

#define SlotInfo__maxversion                                             4

/* --- ModuleInfo_flags --- */

#define ModuleInfo_flags_ShareTarget                            0x00010000
#define ModuleInfo_flags__reserved                              0xffff0000
#define ModuleInfo_flags__allflags                              0x00010000
#define ModuleInfo_flags__presentflags                          0x00000000

/* --- ModuleInfo versioning --- */

#define ModuleInfo__maxversion                                           1

/* --- WorldInfo_flags --- */

#define WorldInfo_flags_Initialized                             0x00010000
#define WorldInfo_flags_Usable                                  0x00020000
#define WorldInfo_flags_Recovery                                0x00040000
#define WorldInfo_flags_ExistingClient                          0x00080000
#define WorldInfo_flags_StrictFIPS140                           0x00100000
#define WorldInfo_flags_Checked                                 0x00200000
#define WorldInfo_flags_Dead                                    0x00400000
#define WorldInfo_flags_PINRecovery                             0x00800000
#define WorldInfo_flags_RTC                                     0x01000000
#define WorldInfo_flags_NVRAM                                   0x02000000
#define WorldInfo_flags_SEEDebug                                0x04000000
#define WorldInfo_flags_SEEDebugForAll                          0x08000000
#define WorldInfo_flags_ForeignTokenOpen                        0x10000000
#define WorldInfo_flags__reserved                               0xffff0000
#define WorldInfo_flags__allflags                               0x1fff0000
#define WorldInfo_flags__presentflags                           0x00000000

/* --- WorldInfo versioning --- */

#define WorldInfo__maxversion                                            9

/* --- Key_flags --- */

#define Key_flags_RecoveryEnabled                               0x00000001
#define Key_flags_RecoveryDisabled                              0x00000002
#define Key_flags_HasCertificate                                0x00000004
#define Key_flags_PublicKey                                     0x00000008
#define Key_flags_ProtectionModule                              0x00000010
#define Key_flags_ProtectionCardSet                             0x00000020
#define Key_flags_ProtectionNoKey                               0x00000040
#define Key_flags_SEEAppKey                                     0x00000080
#define Key_flags_TimeLimit                                     0x00000100
#define Key_flags_SEEAppKeyHashAndMech                          0x00000200
#define Key_flags_PerAuthUseLimit                               0x00000400
#define Key_flags__allflags                                     0x000007ff
#define Key_flags__presentflags                                 0x00000000

/* --- Key versioning --- */

#define Key__maxversion                                                  7

/*----- That's all, folks -------------------------------------------------*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nfast\inc\messages-anfkm-eh.h ===
/* -*-c-*-
 *
 * Generated by Marshmallow at 2003-04-25T18:39:00
 */

#ifndef MESSAGES_ANFKM_EH_H
#define MESSAGES_ANFKM_EH_H

struct NF_UserData;

/* --- Required functions --- */

extern void *NF_Malloc(size_t sz, struct NF_UserData *u);
extern int NF_Free(void *p, struct NF_UserData *u);
extern int NFErr_TableTooLarge(const char *ty, const char *mem, const char *tab, M_Word n, int max, struct NF_UserData *u);
extern int NFErr_UnknownFlag(const char *ty, const char *mem, M_Word f, struct NF_UserData *u);

/*----- That's all, folks -------------------------------------------------*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nfast\inc\messages-anfkm-dh.h ===
/* -*-c-*-
 *
 * Generated by Marshmallow at 2003-04-25T18:39:00
 */

#ifndef MESSAGES_ANFKM_DH_H
#define MESSAGES_ANFKM_DH_H

/*----- Enumeration constants ---------------------------------------------*/

/* --- SlotState codes --- */

#define SlotState_UnusedTableEntry                                       1
#define SlotState_Empty                                                  2
#define SlotState_Blank                                                  3
#define SlotState_Admin                                                  4
#define SlotState_Operator                                               5
#define SlotState_Unidentified                                           6
#define SlotState_Error                                                  7
#define SlotState_Partial                                                8

/* --- ModuleState codes --- */

#define ModuleState_Unknown                                              1
#define ModuleState_Usable                                               2
#define ModuleState_MaintMode                                            3
#define ModuleState_Uninitialized                                        4
#define ModuleState_Factory                                              5
#define ModuleState_Foreign                                              6
#define ModuleState_AccelOnly                                            7
#define ModuleState_Failed                                               8
#define ModuleState_Unchecked                                            9
#define ModuleState_InitMode                                            10
#define ModuleState_PreInitMode                                         11
#define ModuleState_UnusedTableEntry                                    12

/*----- Flag constants ----------------------------------------------------*/

/* --- CardSet_flags --- */

#define CardSet_flags_Persistent                                0x00000001
#define CardSet_flags_NotPersistent                             0x00000002
#define CardSet_flags_PINRecoveryRequired                       0x00000004
#define CardSet_flags_PINRecoveryForbidden                      0x00000008
#define CardSet_flags_RemoteEnabled                             0x00000010
#define CardSet_flags__reserved                                 0xffffffff
#define CardSet_flags__allflags                                 0x0000001f
#define CardSet_flags__presentflags                             0x00000000

/* --- CardSet versioning --- */

#define CardSet_v__maxversion                                            1

/* --- Card_flags --- */

#define Card_flags_RecoverablePIN                               0x00000001
#define Card_flags__reserved                                    0xffffffff
#define Card_flags__allflags                                    0x00000001
#define Card_flags__presentflags                                0x00000000

/* --- Card versioning --- */

#define Card_v__maxversion                                               0

/* --- SlotInfo_flags --- */

#define SlotInfo_flags_Passphrase                               0x00010000
#define SlotInfo_flags_RemoteEnabled                            0x00020000
#define SlotInfo_flags__reserved                                0xffff0000
#define SlotInfo_flags__allflags                                0x00030000
#define SlotInfo_flags__presentflags                            0x00000000

/* --- ShareFlag --- */

#define ShareFlag_LTNSO                                         0x00000001
#define ShareFlag_LTC                                           0x00000002
#define ShareFlag_LTM                                           0x00000004
#define ShareFlag_LTR                                           0x00000008
#define ShareFlag_LTU                                           0x00000010
#define ShareFlag_LTUC                                          0x00000020
#define ShareFlag_LTFIPS                                        0x00000040
#define ShareFlag_LTP                                           0x00000080
#define ShareFlag_LTNV                                          0x00000100
#define ShareFlag_LTRTC                                         0x00000200
#define ShareFlag_LTDSEE                                        0x00000400
#define ShareFlag_LTFTO                                         0x00000800
#define ShareFlag__reserved                                     0xffffffff
#define ShareFlag__allflags                                     0x00000fff
#define ShareFlag__presentflags                                 0x00000000

/* --- SlotInfo versioning --- */

#define SlotInfo_v__maxversion                                           4

/* --- ModuleInfo_flags --- */

#define ModuleInfo_flags_ShareTarget                            0x00010000
#define ModuleInfo_flags__reserved                              0xffff0000
#define ModuleInfo_flags__allflags                              0x00010000
#define ModuleInfo_flags__presentflags                          0x00000000

/* --- ModuleInfo versioning --- */

#define ModuleInfo_v__maxversion                                         1

/* --- WorldInfo_flags --- */

#define WorldInfo_flags_Initialized                             0x00010000
#define WorldInfo_flags_Usable                                  0x00020000
#define WorldInfo_flags_Recovery                                0x00040000
#define WorldInfo_flags_ExistingClient                          0x00080000
#define WorldInfo_flags_StrictFIPS140                           0x00100000
#define WorldInfo_flags_Checked                                 0x00200000
#define WorldInfo_flags_Dead                                    0x00400000
#define WorldInfo_flags_PINRecovery                             0x00800000
#define WorldInfo_flags_RTC                                     0x01000000
#define WorldInfo_flags_NVRAM                                   0x02000000
#define WorldInfo_flags_SEEDebug                                0x04000000
#define WorldInfo_flags_SEEDebugForAll                          0x08000000
#define WorldInfo_flags_ForeignTokenOpen                        0x10000000
#define WorldInfo_flags__reserved                               0xffff0000
#define WorldInfo_flags__allflags                               0x1fff0000
#define WorldInfo_flags__presentflags                           0x00000000

/* --- WorldInfo versioning --- */

#define WorldInfo_v__maxversion                                          9

/* --- Key_flags --- */

#define Key_flags_RecoveryEnabled                               0x00000001
#define Key_flags_RecoveryDisabled                              0x00000002
#define Key_flags_HasCertificate                                0x00000004
#define Key_flags_PublicKey                                     0x00000008
#define Key_flags_ProtectionModule                              0x00000010
#define Key_flags_ProtectionCardSet                             0x00000020
#define Key_flags_ProtectionNoKey                               0x00000040
#define Key_flags_SEEAppKey                                     0x00000080
#define Key_flags_TimeLimit                                     0x00000100
#define Key_flags_SEEAppKeyHashAndMech                          0x00000200
#define Key_flags_PerAuthUseLimit                               0x00000400
#define Key_flags__allflags                                     0x000007ff
#define Key_flags__presentflags                                 0x00000000

/* --- Key versioning --- */

#define Key_v__maxversion                                                7

/*----- Data structure formats --------------------------------------------*
 *
 * CARDSET:
 *   WORD (version tag)                       v
 *   UTF8STRING                               name
 *   WORD                                     n
 *   WORD                                     k
 *   WORD                                     n_names
 *   n_names * UTF8STRING                     names
 *   HASH                                     hkltu
 *   WORD (flags)                             flags
 *   WORD                                     timeout
 *   CARDSETINTERNALDATAPOINTER               intern
 * (if v >= 1)
 *   TIME                                     gentime
 *
 * CARD:
 *   WORD (version tag)                       v
 *   UTF8STRING                               name
 *   CARDSETIDENT                             cardset
 *   WORD                                     index
 *   WORD (flags)                             flags
 *   CARDINTERNALDATAPOINTER                  intern
 *
 * PARTIALCARDSETS:
 *   WORD                                     n_pcs
 *   n_pcs * PARTIALCARDSET                   pcs
 *
 * PARTIALCARDSET:
 *   HASH                                     h
 *   WORD                                     tag
 *
 * SLOTINFO:
 *   WORD (version tag)                       v
 *   PHYSTOKEN                                token
 *   CHANGEINFO                               change
 *   WORD (enum `SlotType')                   phystype
 *   WORD                                     slotlistflags
 *   WORD (enum `SlotState')                  slotstate
 *   WORD (flags)                             flags
 *   WORD (flags)                             pp
 *   WORD (flags)                             shares
 *   WORD                                     shareno
 *   WORD (enum `Status')                     ecode
 *   ERRORINFO (based on `ecode')             einfo
 *   OPT_CARDSET                              cardset
 *   SLOTINTERNALDATAPOINTER                  intern
 * (if v >= 1)
 *   OPT_CARD                                 card
 * (if v >= 2)
 *   WORD                                     partialtag
 * (if v >= 3)
 *   SLOTEXDATA (based on `phystype')         exdata
 * (if v >= 4)
 *   WORD (flags)                             remoteshares
 *
 * MODULEINFO:
 *   WORD (version tag)                       v
 *   MODULEID                                 module
 *   CHANGEINFO                               change
 *   WORD (enum `ModuleState')                state
 *   WORD (flags)                             flags
 *   WORD                                     n_slots
 *   n_slots * OPT_SLOTINFO                   slots
 *   STRING                                   esn
 *   HASH                                     hkml
 *   MODULEINTERNALDATAPOINTER                intern
 * (if v >= 1)
 *   WORD                                     e4flags
 *
 * WORLDINFO:
 *   WORD (version tag)                       v
 *   CHANGEINFO                               change
 *   WORD (flags)                             flags
 *   WORD                                     n_modules
 *   n_modules * OPT_MODULEINFO               modules
 *   HASH                                     hknso
 *   HASH                                     hkm
 *   HASH                                     hkmwk
 *   HASH                                     hkra
 *   HASH                                     hkre
 *   BYTEBLOCK                                blobpubkre
 *   WORLDINTERNALDATAPOINTER                 intern
 *   CLIENTID                                 existingclient
 *   WORD                                     n_existingobjects
 *   n_existingobjects * OPT_EXISTINGOBJECTINFO existingobjects
 * (if v >= 1)
 *   HASH                                     hkfips
 * (if v >= 2)
 *   HASH                                     hkmc
 *   WORD                                     acs_n
 *   WORD                                     acs_k
 * (if v >= 3)
 *   HASH                                     hkp
 *   BYTEBLOCK                                blobpubkp
 * (if v >= 4)
 *   HASH                                     hknv
 *   BYTEBLOCK                                blobpubknv
 *   HASH                                     hkrtc
 *   BYTEBLOCK                                blobpubkrtc
 * (if v >= 5)
 *   HASH                                     hkdsee
 *   BYTEBLOCK                                blobpubkdsee
 * (if v >= 6)
 *   TIME                                     createtime
 *   WORD                                     t_m
 *   WORD                                     t_r
 *   WORD                                     t_p
 *   WORD                                     t_nv
 *   WORD                                     t_rtc
 *   WORD                                     t_dsee
 * (if v >= 7)
 *   BYTEBLOCK                                blobpubkmc
 *   HASH                                     hkfto
 *   BYTEBLOCK                                blobpubkfto
 *   WORD                                     t_fto
 * (if v >= 8)
 *   BYTEBLOCK                                blobpubkfips
 * (if v >= 9)
 *   STRING                                   esn
 *   BYTEBLOCK                                blobpubkml
 *   BYTEBLOCK                                modstatemsg
 *   BYTEBLOCK                                modstatesig
 *
 * EXISTINGOBJECTINFO:
 *   MODULEID                                 module
 *   HASH                                     hash
 *   CHANGEINFO                               change
 *   KEYID                                    id
 *
 * KEY:
 *   BYTEBLOCK                                privblob
 *   BYTEBLOCK                                pubblob
 *   BYTEBLOCK                                privblobrecov
 *   UTF8STRING                               name
 *   STRING                                   appname
 *   STRING                                   ident
 *   HASH                                     hash
 *   WORD                                     n_entries
 *   n_entries * KEYMGMTFILEENTRY             entries
 *   WORD (flags)                             flags
 *   CARDSETIDENT                             cardset
 *   WORD (version tag)                       v
 *   WORD                                     timehigh
 *   WORD                                     timelow
 * (if v >= 1)
 *   STRING                                   oldident
 * (if v >= 2)
 *   BYTEBLOCK                                kcmsg
 *   BYTEBLOCK                                kcsig
 *   STRING                                   esn
 *   BYTEBLOCK                                blobpubkml
 *   BYTEBLOCK                                modcert
 * (if v >= 3)
 *   TIME                                     gentime
 * (if v >= 4)
 *   STRING                                   identseeinteg
 * (if v >= 5)
 *   WORD                                     timelimit
 * (if v >= 6)
 *   WORD                                     pa_uselimit
 * (if v >= 7)
 *   BYTEBLOCK                                modstatemsg
 *   BYTEBLOCK                                modstatesig
 *
 * KEYIDENT:
 *   STRING                                   appname
 *   STRING                                   ident
 *
 * The following message variants are empty.
 *
 */

/*----- That's all, folks -------------------------------------------------*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nfast\inc\messages-anfkm-enstr.h ===
/* -*-c-*-
 *
 * Generated by Marshmallow at 2003-04-25T18:39:00
 */

#ifndef MESSAGES_ANFKM_ENSTR_H
#define MESSAGES_ANFKM_ENSTR_H

/* --- Table format --- */

#ifndef NF_VALINFO
#define NF_VALINFO

typedef struct NF_ValInfo {
  M_Word code;
  const char *string;
} NF_ValInfo;

#endif

/* --- Required functions --- */

const char *NF_Lookup(M_Word val, const NF_ValInfo *vit);
int NF_LookupString(const char *string, M_Word *result, const NF_ValInfo *vit);

/* --- Enumeration and flag tables --- */

extern const NF_ValInfo NF_SlotState_enumtable[];
extern const NF_ValInfo NF_ModuleState_enumtable[];

extern const NF_ValInfo NF_CardSet_flags_table[];
extern const NF_ValInfo NF_Card_flags_table[];
extern const NF_ValInfo NF_SlotInfo_flags_table[];
extern const NF_ValInfo NF_ShareFlag_table[];
extern const NF_ValInfo NF_ModuleInfo_flags_table[];
extern const NF_ValInfo NF_WorldInfo_flags_table[];
extern const NF_ValInfo NF_Key_flags_table[];

/*----- That's all, folks -------------------------------------------------*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nfast\inc\messages-anfkm-free.h ===
/* -*-c-*-
 *
 * Generated by Marshmallow at 2003-04-25T18:39:00
 */

#ifndef MESSAGES_ANFKM_FREE_H
#define MESSAGES_ANFKM_FREE_H

/* --- Freeing context --- */

#ifndef NF_FREE_CONTEXT
#define NF_FREE_CONTEXT

typedef struct NF_Free_Context {
  struct NF_UserData *u;
} NF_Free_Context;

#endif

/* --- Exported types --- */

extern int NF_Free_String(NF_Free_Context *c, NFKM_String *msg);
extern int NF_Free_UTF8String(NF_Free_Context *c, NFKM_UTF8String *msg);
extern int NF_Free_Time(NF_Free_Context *c, NFKM_Time *msg);
extern int NF_Free_CardSetInternalDataPointer(NF_Free_Context *c, NFKM_CardSetInternalDataPointer *msg);
extern int NF_Free_CardSet(NF_Free_Context *c, NFKM_CardSet *msg);
extern int NF_Free_CardInternalDataPointer(NF_Free_Context *c, NFKM_CardInternalDataPointer *msg);
extern int NF_Free_Card(NF_Free_Context *c, NFKM_Card *msg);
extern int NF_Free_PartialCardsets(NF_Free_Context *c, NFKM_PartialCardsets *msg);
extern int NF_Free_SlotState(NF_Free_Context *c, NFKM_SlotState *msg);
extern int NF_Free_ChangeInfo(NF_Free_Context *c, NFKM_ChangeInfo *msg);
extern int NF_Free_SlotInternalDataPointer(NF_Free_Context *c, NFKM_SlotInternalDataPointer *msg);
extern int NF_Free_SlotInfo(NF_Free_Context *c, NFKM_SlotInfo *msg);
extern int NF_Free_ModuleState(NF_Free_Context *c, NFKM_ModuleState *msg);
extern int NF_Free_ModuleInternalDataPointer(NF_Free_Context *c, NFKM_ModuleInternalDataPointer *msg);
extern int NF_Free_ModuleInfo(NF_Free_Context *c, NFKM_ModuleInfo *msg);
extern int NF_Free_WorldInternalDataPointer(NF_Free_Context *c, NFKM_WorldInternalDataPointer *msg);
extern int NF_Free_WorldInfo(NF_Free_Context *c, NFKM_WorldInfo *msg);
extern int NF_Free_Key(NF_Free_Context *c, NFKM_Key *msg);
extern int NF_Free_KeyIdent(NF_Free_Context *c, NFKM_KeyIdent *msg);

/* --- External dependencies --- */


/*----- That's all, folks -------------------------------------------------*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nfast\inc\messages-anfkm-im.h ===
/* -*-c-*-
 *
 * Generated by Marshmallow at 2003-04-25T18:39:00
 */

#ifndef MESSAGES_ANFKM_IM_H
#define MESSAGES_ANFKM_IM_H

/* --- Synonym UTF8String --- */

typedef NFKM_String NFKM_UTF8String;

/* --- Structure CardSet --- */

typedef struct NFKM_CardSet NFKM_CardSet;

/* --- Vector vec_UTF8String --- */

typedef NFKM_UTF8String *NFKM_vec_UTF8String;

/* --- Flags word CardSet_flags --- */

typedef M_Word NFKM_CardSet_flags;

/* --- Structure CardSet --- */

struct NFKM_CardSet {
  M_Word v;
  NFKM_UTF8String name;
  M_Word n;
  M_Word k;
  int n_names;
  NFKM_vec_UTF8String names;
  M_Hash hkltu;
  NFKM_CardSet_flags flags;
  M_Word timeout;
  NFKM_CardSetInternalDataPointer intern;

  /* --- If v >= 1 --- */

  NFKM_Time gentime;
};

/* --- Structure Card --- */

typedef struct NFKM_Card NFKM_Card;

/* --- Synonym CardSetIdent --- */

typedef M_Hash NFKM_CardSetIdent;

/* --- Flags word Card_flags --- */

typedef M_Word NFKM_Card_flags;

/* --- Structure Card --- */

struct NFKM_Card {
  M_Word v;
  NFKM_UTF8String name;
  NFKM_CardSetIdent cardset;
  M_Word index;
  NFKM_Card_flags flags;
  NFKM_CardInternalDataPointer intern;
};

/* --- Structure PartialCardsets --- */

typedef struct NFKM_PartialCardsets NFKM_PartialCardsets;

/* --- Structure PartialCardset --- */

typedef struct NFKM_PartialCardset NFKM_PartialCardset;

/* --- Vector vec_PartialCardset --- */

typedef NFKM_PartialCardset *NFKM_vec_PartialCardset;

/* --- Structure PartialCardsets --- */

struct NFKM_PartialCardsets {
  int n_pcs;
  NFKM_vec_PartialCardset pcs;
};

/* --- Structure PartialCardset --- */

struct NFKM_PartialCardset {
  M_Hash h;
  M_Word tag;
};

/* --- Structure SlotInfo --- */

typedef struct NFKM_SlotInfo NFKM_SlotInfo;

/* --- Flags word SlotInfo_flags --- */

typedef M_Word NFKM_SlotInfo_flags;

/* --- Flags word ShareFlag --- */

typedef M_Word NFKM_ShareFlag;

/* --- Optional opt_CardSet --- */

typedef NFKM_CardSet *NFKM_opt_CardSet;

/* --- Optional opt_Card --- */

typedef NFKM_Card *NFKM_opt_Card;

/* --- Structure SlotInfo --- */

struct NFKM_SlotInfo {
  M_Word v;
  M_PhysToken token;
  NFKM_ChangeInfo change;
  M_SlotType phystype;
  M_Word slotlistflags;
  NFKM_SlotState slotstate;
  NFKM_SlotInfo_flags flags;
  NFKM_ShareFlag pp;
  NFKM_ShareFlag shares;
  M_Word shareno;
  M_Status ecode;
  union M_Status__ErrorInfo einfo;
  NFKM_opt_CardSet cardset;
  NFKM_SlotInternalDataPointer intern;

  /* --- If v >= 1 --- */

  NFKM_opt_Card card;

  /* --- If v >= 2 --- */

  M_Word partialtag;

  /* --- If v >= 3 --- */

  union M_SlotType__SlotExData exdata;

  /* --- If v >= 4 --- */

  NFKM_ShareFlag remoteshares;
};

/* --- Structure ModuleInfo --- */

typedef struct NFKM_ModuleInfo NFKM_ModuleInfo;

/* --- Flags word ModuleInfo_flags --- */

typedef M_Word NFKM_ModuleInfo_flags;

/* --- Optional opt_SlotInfo --- */

typedef NFKM_SlotInfo *NFKM_opt_SlotInfo;

/* --- Vector vec_opt_SlotInfo --- */

typedef NFKM_opt_SlotInfo *NFKM_vec_opt_SlotInfo;

/* --- Structure ModuleInfo --- */

struct NFKM_ModuleInfo {
  M_Word v;
  M_ModuleID module;
  NFKM_ChangeInfo change;
  NFKM_ModuleState state;
  NFKM_ModuleInfo_flags flags;
  int n_slots;
  NFKM_vec_opt_SlotInfo slots;
  NFKM_String esn;
  M_Hash hkml;
  NFKM_ModuleInternalDataPointer intern;

  /* --- If v >= 1 --- */

  M_Word e4flags;
};

/* --- Structure WorldInfo --- */

typedef struct NFKM_WorldInfo NFKM_WorldInfo;

/* --- Flags word WorldInfo_flags --- */

typedef M_Word NFKM_WorldInfo_flags;

/* --- Optional opt_ModuleInfo --- */

typedef NFKM_ModuleInfo *NFKM_opt_ModuleInfo;

/* --- Vector vec_opt_ModuleInfo --- */

typedef NFKM_opt_ModuleInfo *NFKM_vec_opt_ModuleInfo;

/* --- Structure ExistingObjectInfo --- */

typedef struct NFKM_ExistingObjectInfo NFKM_ExistingObjectInfo;

/* --- Optional opt_ExistingObjectInfo --- */

typedef NFKM_ExistingObjectInfo *NFKM_opt_ExistingObjectInfo;

/* --- Vector vec_opt_ExistingObjectInfo --- */

typedef NFKM_opt_ExistingObjectInfo *NFKM_vec_opt_ExistingObjectInfo;

/* --- Structure WorldInfo --- */

struct NFKM_WorldInfo {
  M_Word v;
  NFKM_ChangeInfo change;
  NFKM_WorldInfo_flags flags;
  int n_modules;
  NFKM_vec_opt_ModuleInfo modules;
  M_Hash hknso;
  M_Hash hkm;
  M_Hash hkmwk;
  M_Hash hkra;
  M_Hash hkre;
  M_ByteBlock blobpubkre;
  NFKM_WorldInternalDataPointer intern;
  M_ClientID existingclient;
  int n_existingobjects;
  NFKM_vec_opt_ExistingObjectInfo existingobjects;

  /* --- If v >= 1 --- */

  M_Hash hkfips;

  /* --- If v >= 2 --- */

  M_Hash hkmc;
  M_Word acs_n;
  M_Word acs_k;

  /* --- If v >= 3 --- */

  M_Hash hkp;
  M_ByteBlock blobpubkp;

  /* --- If v >= 4 --- */

  M_Hash hknv;
  M_ByteBlock blobpubknv;
  M_Hash hkrtc;
  M_ByteBlock blobpubkrtc;

  /* --- If v >= 5 --- */

  M_Hash hkdsee;
  M_ByteBlock blobpubkdsee;

  /* --- If v >= 6 --- */

  NFKM_Time createtime;
  M_Word t_m;
  M_Word t_r;
  M_Word t_p;
  M_Word t_nv;
  M_Word t_rtc;
  M_Word t_dsee;

  /* --- If v >= 7 --- */

  M_ByteBlock blobpubkmc;
  M_Hash hkfto;
  M_ByteBlock blobpubkfto;
  M_Word t_fto;

  /* --- If v >= 8 --- */

  M_ByteBlock blobpubkfips;

  /* --- If v >= 9 --- */

  NFKM_String esn;
  M_ByteBlock blobpubkml;
  M_ByteBlock modstatemsg;
  M_ByteBlock modstatesig;
};

/* --- Structure ExistingObjectInfo --- */

struct NFKM_ExistingObjectInfo {
  M_ModuleID module;
  M_Hash hash;
  NFKM_ChangeInfo change;
  M_KeyID id;
};

/* --- Structure Key --- */

typedef struct NFKM_Key NFKM_Key;

/* --- Vector vec_KeyMgmtFileEntry --- */

typedef M_KeyMgmtFileEntry *NFKM_vec_KeyMgmtFileEntry;

/* --- Flags word Key_flags --- */

typedef M_Word NFKM_Key_flags;

/* --- Structure Key --- */

struct NFKM_Key {
  M_ByteBlock privblob;
  M_ByteBlock pubblob;
  M_ByteBlock privblobrecov;
  NFKM_UTF8String name;
  NFKM_String appname;
  NFKM_String ident;
  M_Hash hash;
  int n_entries;
  NFKM_vec_KeyMgmtFileEntry entries;
  NFKM_Key_flags flags;
  NFKM_CardSetIdent cardset;
  M_Word v;
  M_Word timehigh;
  M_Word timelow;

  /* --- If v >= 1 --- */

  NFKM_String oldident;

  /* --- If v >= 2 --- */

  M_ByteBlock kcmsg;
  M_ByteBlock kcsig;
  NFKM_String esn;
  M_ByteBlock blobpubkml;
  M_ByteBlock modcert;

  /* --- If v >= 3 --- */

  NFKM_Time gentime;

  /* --- If v >= 4 --- */

  NFKM_String identseeinteg;

  /* --- If v >= 5 --- */

  M_Word timelimit;

  /* --- If v >= 6 --- */

  M_Word pa_uselimit;

  /* --- If v >= 7 --- */

  M_ByteBlock modstatemsg;
  M_ByteBlock modstatesig;
};

/* --- Structure KeyIdent --- */

typedef struct NFKM_KeyIdent NFKM_KeyIdent;

/* --- Structure KeyIdent --- */

struct NFKM_KeyIdent {
  NFKM_String appname;
  NFKM_String ident;
};

/*----- That's all, folks -------------------------------------------------*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nfast\inc\messages-anfkm-mar.h ===
/* -*-c-*-
 *
 * Generated by Marshmallow at 2003-04-25T18:39:00
 */

#ifndef MESSAGES_ANFKM_MAR_H
#define MESSAGES_ANFKM_MAR_H

/* --- Marshalling context --- */

#ifndef NF_MARSHAL_CONTEXT
#define NF_MARSHAL_CONTEXT

typedef struct NF_Marshal_Context {
  unsigned char *op;
  int remain;
  struct NF_UserData *u;
} NF_Marshal_Context;

#endif

/* --- Exported types --- */

extern int NF_Marshal_String(NF_Marshal_Context *c, const NFKM_String *msg);
extern int NF_Marshal_UTF8String(NF_Marshal_Context *c, const NFKM_UTF8String *msg);
extern int NF_Marshal_Time(NF_Marshal_Context *c, const NFKM_Time *msg);
extern int NF_Marshal_CardSetInternalDataPointer(NF_Marshal_Context *c, const NFKM_CardSetInternalDataPointer *msg);
extern int NF_Marshal_CardSet(NF_Marshal_Context *c, const NFKM_CardSet *msg);
extern int NF_Marshal_CardInternalDataPointer(NF_Marshal_Context *c, const NFKM_CardInternalDataPointer *msg);
extern int NF_Marshal_Card(NF_Marshal_Context *c, const NFKM_Card *msg);
extern int NF_Marshal_PartialCardsets(NF_Marshal_Context *c, const NFKM_PartialCardsets *msg);
extern int NF_Marshal_SlotState(NF_Marshal_Context *c, const NFKM_SlotState *msg);
extern int NF_Marshal_ChangeInfo(NF_Marshal_Context *c, const NFKM_ChangeInfo *msg);
extern int NF_Marshal_SlotInternalDataPointer(NF_Marshal_Context *c, const NFKM_SlotInternalDataPointer *msg);
extern int NF_Marshal_SlotInfo(NF_Marshal_Context *c, const NFKM_SlotInfo *msg);
extern int NF_Marshal_ModuleState(NF_Marshal_Context *c, const NFKM_ModuleState *msg);
extern int NF_Marshal_ModuleInternalDataPointer(NF_Marshal_Context *c, const NFKM_ModuleInternalDataPointer *msg);
extern int NF_Marshal_ModuleInfo(NF_Marshal_Context *c, const NFKM_ModuleInfo *msg);
extern int NF_Marshal_WorldInternalDataPointer(NF_Marshal_Context *c, const NFKM_WorldInternalDataPointer *msg);
extern int NF_Marshal_WorldInfo(NF_Marshal_Context *c, const NFKM_WorldInfo *msg);
extern int NF_Marshal_Key(NF_Marshal_Context *c, const NFKM_Key *msg);
extern int NF_Marshal_KeyIdent(NF_Marshal_Context *c, const NFKM_KeyIdent *msg);

/* --- External dependencies --- */

extern int NF_Marshal_length(NF_Marshal_Context *c, NF_Marshal_Context *cc);
extern int NF_Marshal_padding(NF_Marshal_Context *c, NF_Marshal_Context *cc);

/*----- That's all, folks -------------------------------------------------*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nfast\inc\messages-anfkm-print.h ===
/* -*-c-*-
 *
 * Generated by Marshmallow at 2003-04-25T18:39:01
 */

#ifndef MESSAGES_ANFKM_PRINT_H
#define MESSAGES_ANFKM_PRINT_H

#include <stdio.h>

/* --- Printing context --- */

#ifndef NF_PRINT_CONTEXT
#define NF_PRINT_CONTEXT

typedef struct NF_Print_Context {
  FILE *file;
  struct NF_UserData *u;
} NF_Print_Context;

#endif

/* --- Exported types --- */

extern int NF_Print_String(NF_Print_Context *c, int ind, const NFKM_String *msg);
extern int NF_Print_UTF8String(NF_Print_Context *c, int ind, const NFKM_UTF8String *msg);
extern int NF_Print_Time(NF_Print_Context *c, int ind, const NFKM_Time *msg);
extern int NF_Print_CardSetInternalDataPointer(NF_Print_Context *c, int ind, const NFKM_CardSetInternalDataPointer *msg);
extern int NF_Print_CardSet(NF_Print_Context *c, int ind, const NFKM_CardSet *msg);
extern int NF_Print_CardInternalDataPointer(NF_Print_Context *c, int ind, const NFKM_CardInternalDataPointer *msg);
extern int NF_Print_Card(NF_Print_Context *c, int ind, const NFKM_Card *msg);
extern int NF_Print_PartialCardsets(NF_Print_Context *c, int ind, const NFKM_PartialCardsets *msg);
extern int NF_Print_SlotState(NF_Print_Context *c, int ind, const NFKM_SlotState *msg);
extern int NF_Print_ChangeInfo(NF_Print_Context *c, int ind, const NFKM_ChangeInfo *msg);
extern int NF_Print_SlotInternalDataPointer(NF_Print_Context *c, int ind, const NFKM_SlotInternalDataPointer *msg);
extern int NF_Print_SlotInfo(NF_Print_Context *c, int ind, const NFKM_SlotInfo *msg);
extern int NF_Print_ModuleState(NF_Print_Context *c, int ind, const NFKM_ModuleState *msg);
extern int NF_Print_ModuleInternalDataPointer(NF_Print_Context *c, int ind, const NFKM_ModuleInternalDataPointer *msg);
extern int NF_Print_ModuleInfo(NF_Print_Context *c, int ind, const NFKM_ModuleInfo *msg);
extern int NF_Print_WorldInternalDataPointer(NF_Print_Context *c, int ind, const NFKM_WorldInternalDataPointer *msg);
extern int NF_Print_WorldInfo(NF_Print_Context *c, int ind, const NFKM_WorldInfo *msg);
extern int NF_Print_Key(NF_Print_Context *c, int ind, const NFKM_Key *msg);
extern int NF_Print_KeyIdent(NF_Print_Context *c, int ind, const NFKM_KeyIdent *msg);

/* --- External dependencies --- */

extern int NF_Print_bitmap(NF_Print_Context *c, M_Word f, const NF_ValInfo *vit);

/*----- That's all, folks -------------------------------------------------*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nfast\inc\messages-anfkm-trans.h ===
/* -*-c-*-
 *
 * Generated by Marshmallow at 2003-04-25T18:39:01
 */

#ifndef MESSAGES_ANFKM_TRANS_H
#define MESSAGES_ANFKM_TRANS_H

/* --- Translating context --- */

#ifndef NF_TRANSLATE_CONTEXT
#define NF_TRANSLATE_CONTEXT

typedef struct NF_Translate_Context {
  const unsigned char *ip;
  unsigned char *op;
  int iremain, oremain;
  struct NF_UserData *u;
} NF_Translate_Context;

#endif

/* --- Exported types --- */

extern int NF_Translate_String(NF_Translate_Context *c);
extern int NF_Translate_UTF8String(NF_Translate_Context *c);
extern int NF_Translate_Time(NF_Translate_Context *c);
extern int NF_Translate_CardSetInternalDataPointer(NF_Translate_Context *c);
extern int NF_Translate_CardSet(NF_Translate_Context *c);
extern int NF_Translate_CardInternalDataPointer(NF_Translate_Context *c);
extern int NF_Translate_Card(NF_Translate_Context *c);
extern int NF_Translate_PartialCardsets(NF_Translate_Context *c);
extern int NF_Translate_SlotState(NF_Translate_Context *c, M_Word *w);
extern int NF_Translate_ChangeInfo(NF_Translate_Context *c);
extern int NF_Translate_SlotInternalDataPointer(NF_Translate_Context *c);
extern int NF_Translate_SlotInfo(NF_Translate_Context *c);
extern int NF_Translate_ModuleState(NF_Translate_Context *c, M_Word *w);
extern int NF_Translate_ModuleInternalDataPointer(NF_Translate_Context *c);
extern int NF_Translate_ModuleInfo(NF_Translate_Context *c);
extern int NF_Translate_WorldInternalDataPointer(NF_Translate_Context *c);
extern int NF_Translate_WorldInfo(NF_Translate_Context *c);
extern int NF_Translate_Key(NF_Translate_Context *c);
extern int NF_Translate_KeyIdent(NF_Translate_Context *c);

/* --- External dependencies --- */

extern int NF_Translate_length(NF_Translate_Context *c, NF_Translate_Context *cc);
extern int NF_Translate_padding(NF_Translate_Context *c, NF_Translate_Context *cc);

/*----- That's all, folks -------------------------------------------------*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nfast\inc\messages-anfkm-read.h ===
/* -*-c-*-
 *
 * Generated by Marshmallow at 2003-04-25T18:39:01
 */

#ifndef MESSAGES_ANFKM_READ_H
#define MESSAGES_ANFKM_READ_H

/* --- Reading context --- */

#ifndef NF_READ_CONTEXT
#define NF_READ_CONTEXT

typedef struct NF_Read_Context {
  FILE *file;
  int (*addprompt)(struct NF_Read_Context *c, const char *string);
  int (*continueindent)(struct NF_Read_Context *c, int indent);
  int (*autonewline)(struct NF_Read_Context *c);
  int comparing;
  struct NF_UserData *u;
} NF_Read_Context;

#endif

/* --- Exported types --- */

extern int NF_Read_String(NF_Read_Context *c, int ind, NFKM_String *msg);
extern int NF_Read_UTF8String(NF_Read_Context *c, int ind, NFKM_UTF8String *msg);
extern int NF_Read_Time(NF_Read_Context *c, int ind, NFKM_Time *msg);
extern int NF_Read_CardSetInternalDataPointer(NF_Read_Context *c, int ind, NFKM_CardSetInternalDataPointer *msg);
extern int NF_Read_CardSet(NF_Read_Context *c, int ind, NFKM_CardSet *msg);
extern int NF_Read_CardInternalDataPointer(NF_Read_Context *c, int ind, NFKM_CardInternalDataPointer *msg);
extern int NF_Read_Card(NF_Read_Context *c, int ind, NFKM_Card *msg);
extern int NF_Read_PartialCardsets(NF_Read_Context *c, int ind, NFKM_PartialCardsets *msg);
extern int NF_Read_SlotState(NF_Read_Context *c, int ind, NFKM_SlotState *msg);
extern int NF_Read_ChangeInfo(NF_Read_Context *c, int ind, NFKM_ChangeInfo *msg);
extern int NF_Read_SlotInternalDataPointer(NF_Read_Context *c, int ind, NFKM_SlotInternalDataPointer *msg);
extern int NF_Read_SlotInfo(NF_Read_Context *c, int ind, NFKM_SlotInfo *msg);
extern int NF_Read_ModuleState(NF_Read_Context *c, int ind, NFKM_ModuleState *msg);
extern int NF_Read_ModuleInternalDataPointer(NF_Read_Context *c, int ind, NFKM_ModuleInternalDataPointer *msg);
extern int NF_Read_ModuleInfo(NF_Read_Context *c, int ind, NFKM_ModuleInfo *msg);
extern int NF_Read_WorldInternalDataPointer(NF_Read_Context *c, int ind, NFKM_WorldInternalDataPointer *msg);
extern int NF_Read_WorldInfo(NF_Read_Context *c, int ind, NFKM_WorldInfo *msg);
extern int NF_Read_Key(NF_Read_Context *c, int ind, NFKM_Key *msg);
extern int NF_Read_KeyIdent(NF_Read_Context *c, int ind, NFKM_KeyIdent *msg);

/* --- External dependencies --- */

extern int NF_Read_bitmap
	(NF_Read_Context *c, int ind, M_Word *w, M_Word all,
	 const NF_ValInfo *vit);
extern int NF_Read_enum
	(NF_Read_Context *c, int ind, M_Word *w, M_Word max,
	 const NF_ValInfo *vit);
extern const NF_ValInfo NF_YesNo_enumtable[];
extern int NF_Read_length(NF_Read_Context *c, NF_Read_Context *cc);
extern int NF_Read_padding(NF_Read_Context *c, NF_Read_Context *cc);

/*----- That's all, folks -------------------------------------------------*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nfast\inc\messages-anfkm-unmar.h ===
/* -*-c-*-
 *
 * Generated by Marshmallow at 2003-04-25T18:39:02
 */

#ifndef MESSAGES_ANFKM_UNMAR_H
#define MESSAGES_ANFKM_UNMAR_H

/* --- Unmarshalling context --- */

#ifndef NF_UNMARSHAL_CONTEXT
#define NF_UNMARSHAL_CONTEXT

typedef struct NF_Unmarshal_Context {
  const unsigned char *ip;
  int remain;
  struct NF_UserData *u;
} NF_Unmarshal_Context;

#endif

/* --- Exported types --- */

extern int NF_Unmarshal_String(NF_Unmarshal_Context *c, NFKM_String *msg);
extern int NF_Unmarshal_UTF8String(NF_Unmarshal_Context *c, NFKM_UTF8String *msg);
extern int NF_Unmarshal_Time(NF_Unmarshal_Context *c, NFKM_Time *msg);
extern int NF_Unmarshal_CardSetInternalDataPointer(NF_Unmarshal_Context *c, NFKM_CardSetInternalDataPointer *msg);
extern int NF_Unmarshal_CardSet(NF_Unmarshal_Context *c, NFKM_CardSet *msg);
extern int NF_Unmarshal_CardInternalDataPointer(NF_Unmarshal_Context *c, NFKM_CardInternalDataPointer *msg);
extern int NF_Unmarshal_Card(NF_Unmarshal_Context *c, NFKM_Card *msg);
extern int NF_Unmarshal_PartialCardsets(NF_Unmarshal_Context *c, NFKM_PartialCardsets *msg);
extern int NF_Unmarshal_SlotState(NF_Unmarshal_Context *c, NFKM_SlotState *msg);
extern int NF_Unmarshal_ChangeInfo(NF_Unmarshal_Context *c, NFKM_ChangeInfo *msg);
extern int NF_Unmarshal_SlotInternalDataPointer(NF_Unmarshal_Context *c, NFKM_SlotInternalDataPointer *msg);
extern int NF_Unmarshal_SlotInfo(NF_Unmarshal_Context *c, NFKM_SlotInfo *msg);
extern int NF_Unmarshal_ModuleState(NF_Unmarshal_Context *c, NFKM_ModuleState *msg);
extern int NF_Unmarshal_ModuleInternalDataPointer(NF_Unmarshal_Context *c, NFKM_ModuleInternalDataPointer *msg);
extern int NF_Unmarshal_ModuleInfo(NF_Unmarshal_Context *c, NFKM_ModuleInfo *msg);
extern int NF_Unmarshal_WorldInternalDataPointer(NF_Unmarshal_Context *c, NFKM_WorldInternalDataPointer *msg);
extern int NF_Unmarshal_WorldInfo(NF_Unmarshal_Context *c, NFKM_WorldInfo *msg);
extern int NF_Unmarshal_Key(NF_Unmarshal_Context *c, NFKM_Key *msg);
extern int NF_Unmarshal_KeyIdent(NF_Unmarshal_Context *c, NFKM_KeyIdent *msg);

/* --- External dependencies --- */

extern int NF_Unmarshal_length(NF_Unmarshal_Context *c, NF_Unmarshal_Context *cc);
extern int NF_Unmarshal_padding(NF_Unmarshal_Context *c, NF_Unmarshal_Context *cc);

/*----- That's all, folks -------------------------------------------------*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nfast\inc\nf-pthread-fixup.h ===
/* Copyright (C) 2002- nCipher Corporation Ltd. All rights reserved. */

#if !defined(NF_PTHREAD_FIXUP_H)
#define NF_PTHREAD_FIXUP_H

#include <stddef.h>
#include <sys/types.h>

#ifdef NFAST_CONF_H
#include NFAST_CONF_H
#else
#include "nfast-conf-auto.h"
#endif

#ifdef HAVE_PTHREAD_H
# include <pthread.h>
#endif
/* FreeBSD3.2 has a declaration of pthread_attr_setstacksize()
   in pthread.h, but it isn't in the libs. We need the declaration
   below, but we also need this to prevent declaration clashes
*/

#ifndef HAVE_PTHREAD_ATTR_SETSTACKSIZE
#define pthread_attr_setstacksize nf_pthread_attr_setstacksize
extern int nf_pthread_attr_setstacksize(void *p, size_t size);
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nfast\inc\netaddr.h ===
/*
 * netaddr.h
 *
 * Network address conversions
 *
 * Copyright (C) 1996-2002 nCipher Corporation Ltd. All rights reserved.
 */

#ifndef NETADDR_H
#define NETADDR_H

#ifdef __cplusplus
  extern "C" {
#endif

#include "stdmarshal.h"

/*----- Data structures ---------------------------------------------------*/

struct sockaddr;

/*----- Functions provided ------------------------------------------------*/

/* --- @nf_netaddr_tostring@ --- *
 *
 * Arguments:	@const struct M_NetworkAddress *a@ = address to translate
 *		@char *p@ = pointer to buffer to write in
 *		@const char *l@ = limit of the buffer
 *
 * Returns:	A pointer to the terminating null in the buffer, or null if
 *		it failed.
 *
 * Use:		Writes a textual representation of the given network address
 *		to the string.
 */

char *nf_netaddr_tostring(const struct M_NetworkAddress *a,
			  char *p, const char *l);

/* --- @nf_netaddr_tosockaddr@ --- *
 *
 * Arguments:	@const struct M_NetworkAddress *a@ = pointer to address
 *		@void *buf@ = pointer to buffer to write in
 *		@size_t *sz@ = (in/out) size of the buffer
 *
 * Returns:	A pointer to a @struct sockaddr@ within the buffer, or null
 *		if the address family is unreocgnized.
 *
 * Use:		Translates a marshalled network address into a socket address
 *		suitable for passing to @connect@ or something similar.
 */

struct sockaddr *nf_netaddr_tosockaddr(const struct M_NetworkAddress *a,
				       void *buf, size_t *sz);

/* --- @nf_netaddr_fromsockaddr@ --- *
 *
 * Arguments:	@struct M_NetworkAddress *a@ = pointer to address structure
 *		@const struct sockaddr *sa@ = socket address
 *
 * Returns:	Zero if OK, nonzero if the address family is unrecognized.
 *
 * Use:		Fills in the network address from the socket address.
 */

int nf_netaddr_fromsockaddr(struct M_NetworkAddress *a,
			    const struct sockaddr *sa);

/* --- @nf_netaddr_eq@ --- *
 *
 * Arguments:	@const struct M_NetworkAddress *a@ = pointer to first address
 *		@const struct M_NetworkAddress *b@ = pointer to second one
 *
 * Returns:	Nonzero if the network addresses are equal, zero if they
 *		differ.
 */

int nf_netaddr_eq(const struct M_NetworkAddress *a,
		  const struct M_NetworkAddress *b);

/* --- @nf_netaddr_stricter@ --- *
 *
 * Arguments:	@const struct M_NetworkAddress *a@ = pointer to first address
 *		@const struct M_NetworkAddress *b@ = pointer to second one
 *
 * Returns:	Nonzero if address @a@ is `less than or equal to' address @b@
 *		in a strictness partial-order.
 */

int nf_netaddr_stricter(const struct M_NetworkAddress *a,
			const struct M_NetworkAddress *b);

/*----- That's all, folks -------------------------------------------------*/

#ifdef __cplusplus
  }
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nfast\inc\nfast-conf-auto.h ===
/* GENERATED AUTOMATICALLY BY MANCONFIGURE - DO NOT EDIT */
#define		HAVE_CONFIG_H	1
#undef		const
#define		inline
#undef		WORDS_BIGENDIAN
#undef		HAVE___VSNPRINTF
#undef		HAVE_GETTIMEOFDAY
#define		HAVE_STRCASECMP	1
#define		strcasecmp _stricmp
#define		HAVE_VSNPRINTF	1
#define		HAVE_VSNPRINTF_DECLARATION	1
#define 	vsnprintf _vsnprintf
#define		HAVE_SNPRINTF	1
#define		HAVE_SNPRINTF_DECLARATION	1
#define 	snprintf _snprintf
typedef void* NFAST_TRANSPORTHANDLE_TYPE;
typedef unsigned int uint32;
#define SIZEOF_SHORT 2
#define SIZEOF_UNSIGNED_SHORT 2
#define SIZEOF_INT 4
#define SIZEOF_LONG 4
#define SIZEOF_VOIDP 4
#define SIZEOF_BOOLEAN 4
#define SIZEOF_LONG_LONG 0
#define SIZEOF___INT64 8
#define ALIGNMENTOF_VOIDP 1
#undef		HAVE_ISATTY
#define		HAVE__ISATTY	1
#define		NT_EVENT_LOG	1
#define NFAST_HOME_DEFAULT "c:\\nfast"
#define NFAST_DIRSEP "\\"
#define HAVE_WINDOWS_H	1
#define HAVE_WINBASE_H	1
#define HAVE_WINSOCK2_H	1
typedef int socklen_t;
#define HAVE_STDIO_H	1
#define HAVE_STDDEF_H	1
#define HAVE_ERRNO_H	1
#define HAVE_ASSERT_H	1
#define HAVE_DIRECT_H	1
#define HAVE_FCNTL_H	1
#define HAVE_MALLOC_H	1
#define HAVE_MEMORY_H	1
#define HAVE_SIGNAL_H	1
#define HAVE_STRING_H	1
#define HAVE_IO_H	1
#define HAVE_SYS_TYPES_H 1
#define	HAVE_SYS_TIMEB_H 1
#define	HAVE_SYS_STAT_H 1
#define	HAVE_MEMCPY	1
#define HAVE_ASCTIME	1
#define HAVE_STRDUP	1
#define HAVE_STRTOD	1
#define HAVE_SPRINTF	1
#define HAVE_WSPRINTF	1
#define HAVE_SELECT	1
#define HAVE_TM_ZONE	1
#define NEED_SSIZE_T_TYPE int
#define RENAME_CANT_OVERWRITE 1
#ifndef NOMEM
#  define NOMEM Status_NoHostMemory
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nfast\inc\nfast-client.h ===
/* Copyright (C) 1996-1998 nCipher Corporation Ltd. All rights reserved. */

#ifndef NFAST_CLIENT_H
#define NFAST_CLIENT_H

#include "nfastapp.h"

/* Unless otherwise stated int functions return 0 for success
 * or -1 for error (setting errno) and pointer functions non-NULL
 * for success or NULL for error (setting errno).
 */

typedef struct NFast_ConnectionData *NFast_Connection;

NFast_Connection NFast_PrivilegedConnect(struct NFast_Call_Context *cctx);
NFast_Connection NFast_Connect(struct NFast_Call_Context *cctx);

void NFast_GetIdent(NFast_Connection, NFast_Client_Ident *cid_r);
NFast_Connection NFast_Reconnect(const NFast_Client_Ident *cid,
                                 struct NFast_Call_Context *cctx);
/* Can get you another connection (eg in another process) which has
 * access to the same keys &c.  The NFast_Client_Ident can be copied
 * using memcpy, read and written using fread/fwrite, &c - its byte
 * image is sufficient to use it.  NFast_GetIdent always succeeds.
 * When no connections are open any more using a particular ident it
 * is garbage collected and all its objects in the server and module
 * discarded.
 */

int NFast_Transact(NFast_Connection conn,
                   struct NFast_Call_Context *cctx,
                   const M_Command *command,
                   M_Reply *reply,
                   struct NFast_Transaction_Context *tctx);
/* Synchronous transaction; may be mixed with asynch transactions. */

int NFast_Submit(NFast_Connection conn,
                 struct NFast_Call_Context *cctx,
                 const M_Command *command,
                 M_Reply *reply,
                 struct NFast_Transaction_Context *tctx);
/* The M_Reply* must be unique; it is used to identify the transaction. */

int NFast_Query(NFast_Connection conn,
                struct NFast_Call_Context *cctx,
                M_Reply **replyp,
                struct NFast_Transaction_Context **tctx_r);
int NFast_Wait(NFast_Connection conn,
               struct NFast_Call_Context *cctx,
               M_Reply **replyp,
               struct NFast_Transaction_Context **tctx_r);
/* In both cases replyp _must_ be non-NULL.  If *replyp is NULL
 * NFast_Query or NFast_Wait will be satisfied with any returned
 * reply, and *replyp will be changed to point to the that reply.  If
 * *replyp is not NULL then they will only be satisfied by the reply
 * in question; other replies will be queued internally.
 *
 * ctx_r may be NULL; if it isn't then the ctx used when submitting
 * the reply will be stored in *ctx_r.
 *
 * NFast_Query checks whether the/an appropriate reply has come back
 * yet; NFast_Wait waits for the/an appropriate reply.
 *
 * NFast_Query and NFast_Wait return 0 if a reply was found and
 * returned; -1 (setting errno) for a system error; -2 (setting errno
 * to ENOENT) if there are no outstanding appropriate requests.
 * NFast_Query returns -3 (setting errno to EWOULDBLOCK) if there were
 * outstanding requests but none of the replies have come back yet.
 */

int NFast_Disconnect(NFast_Connection conn, struct NFast_Call_Context *cctx);
/* If NFastApp_Disconnect gives an error the connection _has_
 * been closed, but some error was detected.
 */

void NFast_Free_Command(struct NFast_Call_Context *cctx,
                        struct NFast_Transaction_Context *tctx,
                        M_Command *command);
void NFast_Free_Reply(struct NFast_Call_Context *cctx,
                      struct NFast_Transaction_Context *tctx,
                     M_Reply *reply);

void *NFast_MallocUpcall(size_t sz,
                         struct NFast_Call_Context *cctx,
                         struct NFast_Transaction_Context *tctx);
void *NFast_ReallocUpcall(void *ptr, size_t sz,
                          struct NFast_Call_Context *cctx,
                          struct NFast_Transaction_Context *tctx);
void NFast_FreeUpcall(void *ptr,
                      struct NFast_Call_Context *cctx,
                      struct NFast_Transaction_Context *tctx);
/* These three must be provided by the application.  The malloc/realloc
 * may fail, in which case errno should be set, and the generic stub
 * functions will return -1 or NULL with errno unchanged.  The
 * transaction context will be NULL if no specific transaction is
 * involved.
 */

int NFast_BignumReceiveUpcall(struct NFast_Call_Context *cctx,
                              struct NFast_Transaction_Context *tctx,
                              M_Bignum *bignum, int nbytes,
                              const void *source, int msbitfirst, int mswordfirst);
/* The user code is expected to allocate memory as needed and copy
 * all the data from source into the bignum.  nbytes includes
 * padding to a 4 byte boundary.
 */

int NFast_BignumSendLenUpcall(struct NFast_Call_Context *cctx,
                              struct NFast_Transaction_Context *tctx,
                              const M_Bignum *bignum, int *nbytes_r);
/* The user code is expected to say how may bytes of bignum there are;
 * this must include padding to a 4-byte boundary and must be >0.
 */

int NFast_BignumSendUpcall(struct NFast_Call_Context *cctx,
                           struct NFast_Transaction_Context *tctx,
                           const M_Bignum *bignum, int nbytes,
                           void *dest, int msbitfirst, int mswordfirst);
/* The user code is expected to copy the bytes from the bignum into
 * the destination.  nbytes is the value passed back by ...SendLenUpcall
 * and ms{bit,word}first were determined using _BignumFormatUpcall.
 */

void NFast_BignumFreeUpcall(struct NFast_Call_Context *cctx,
                            struct NFast_Transaction_Context *tctx,
                            M_Bignum *bignum);
/* The user code is expected to free the bignum if *bignum is not a NULL
 * pointer, and then to set *bignum to NULL.
 */

int NFast_BignumFormatUpcall(struct NFast_Call_Context *cctx,
                             struct NFast_Transaction_Context *tctx,
                             int *msbitfirst_io, int *mswordfirst_io);
/* This is called during the submit to find out what the bignum
 * format ought to be for this request.  msbitfirst_io is initialised to
 * the native format and mswordfirst_io to 0; the user is expected to
 * update them as appropriate and return Status_OK.
 */

/* Return values for ...Bignum...Upcall must be Status values whose ErrorInfo
 * is empty.  Status_OK (0) means all went well.
 */

NFAST_TRANSPORTHANDLE_TYPE NFast_GetTransportHandle(NFast_Connection conn);
/* Can be used in select(2) on UNIX and similar calls elsewhere.
 * Always succeeds.
 */

int NFast_Expected_Reply(struct NFast_Call_Context *cctx,
                         char *buf, int buflen,
                         M_Reply *reply, M_Cmd cmd,
                         struct NFast_Transaction_Context *tctx);
/* Checks that reply is an OK reply with reply.cmd==cmd; if not,
 * calls NFast_Free_Reply on reply, fills buf (as for NFast_StrStatus)
 * with an error message, and returns 0 or -1.  Returns >0 if reply is OK.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nfast\inc\nfast-fixup.h ===
/* Copyright (C) 1996-1998 nCipher Corporation Ltd. All rights reserved. */

/*Should change to NF_CROSSCC later (post mips-branch merge)*/

#if !defined(COMPAT_H) && !defined(NF_CROSSCC) && !defined(__arm)
#define COMPAT_H
/* __arm is only in to allow contemporary nfast versions to build.
   Remove soon! */

#include <stdarg.h>

#include <sys/types.h>

#ifdef NFAST_CONF_H
#include NFAST_CONF_H
#else
#include "nfast-conf-auto.h"
#endif

#ifdef HAVE_IO_H
# include <io.h>
#endif

#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif

#ifdef HAVE_STRINGS_H
# include <strings.h>
#endif

#ifdef HAVE_SYS_SELECT_H
# include <sys/select.h>
#endif

#ifndef HAVE_INLINE
# undef inline
# define inline
#endif

#ifdef HAVE_UNISTD_H
/* We don't try to use pread on NT */
#ifndef HAVE_PREAD_DECLARATION
#ifndef pread
# define pread nf_pread
ssize_t nf_pread( int fildes, void *buf, size_t nbyte, off_t offset );
# endif
#endif

#ifndef HAVE_PWRITE_DECLARATION
#ifndef pwrite
# define pwrite nf_pwrite
ssize_t nf_pwrite( int fildes, const void *buf, size_t nbyte, off_t offset );
# endif
#endif
#endif

#ifndef HAVE_UUVSNPRINTF
# ifdef HAVE___VSNPRINTF
#  define HAVE_UUVSNPRINTF
# endif
#endif

#ifndef HAVE_VSNPRINTF
# ifdef HAVE_UUVSNPRINTF
#  ifndef HAVE_UUVSNPRINTF_DECLARATION
int __vsnprintf(char *buf, size_t n, const char *fmt, va_list ap);
#  endif
#  define vsnprintf __vsnprintf
# else
#  define vsnprintf nf_awful_vsnprintf
#  define NEED_OWN_VSNPRINTF
int nf_awful_vsnprintf(char *buf, size_t n, const char *fmt, va_list ap);
# endif
#else
# ifndef HAVE_VSNPRINTF_DECLARATION
int vsnprintf(char *buf, size_t n, const char *fmt, va_list ap);
# endif
#endif

#ifndef HAVE_VSYSLOG
# ifdef HAVE_SYSLOG
#  define NEED_OWN_VSYSLOG
void vsyslog(int priority, const char *format, va_list ap);
# endif
#endif

#if !defined(HAVE_SNPRINTF) || !defined(HAVE_SNPRINTF_DECLARATION)
int snprintf(char *buf, size_t n, const char *fmt, ...);
#endif

#ifndef HAVE_STRSIGNAL
const char *strsignal(int sig);
#endif

#ifdef HAVE_SYS_PTIMERS_H
#include <sys/ptimers.h>
#endif

#ifdef HAVE_WINSOCK2_H
#  include "winsock2.h"
#else
#  include <sys/socket.h>
#  include <netinet/in.h>
#  include <arpa/inet.h>
#  include <netdb.h>
#endif

#ifndef HAVE_INET_ATON
int inet_aton(const char *cp, struct in_addr *inp);
#endif

#ifndef HAVE_GETTIMEOFDAY
#  define gettimeofday nf_gettimeofday
   int nf_gettimeofday(struct timeval *r, void *nullptr);
#  else
#  include <sys/time.h>
#endif

#ifdef HAVE_WAIT3
# ifndef HAVE_WAIT3_DECLARATION
   #include <sys/resource.h>
pid_t wait3(int *statusp, int options, struct rusage *rusage);
# endif
#endif

#ifdef HAVE_WAIT
# ifndef HAVE_WCOREDUMP_DECLARATION
#  ifndef WCOREDUMP
#   define WCOREDUMP(x) (((x)&0x080)?1:0)
#  endif
# endif
#endif

#ifndef HAVE_ISATTY
# ifdef HAVE__ISATTY
#  define isatty _isatty
# else
#  error NO WAY TO GET ISATTY
# endif
#endif

#ifdef RENAME_CANT_OVERWRITE
#include <stdio.h> /* Avoid clobbering the system's declaration */
#define rename nf_rename
int nf_rename( const char *oldname, const char *newname );
#endif

#ifndef HAVE_UNAME
# ifndef _WIN32
#  error NO WAY TO GET UNAME
# else
#  define SYS_NMLN 20
struct utsname {
   char sysname[SYS_NMLN];
   char nodename[SYS_NMLN];
   char release[SYS_NMLN];
   char version[SYS_NMLN];
   char machine[SYS_NMLN];
};
int nf_uname(struct utsname *nstruct);
#  define uname nf_uname
# endif
#else
# include <sys/utsname.h>
#endif

#include <sys/stat.h>
#include <fcntl.h>
#ifdef UNIXIO_HACKING
#ifdef _WIN32
#  define stat _stat
#  define open _open
#  define close _close
#  define read _read
#  define write _write
#  define fdopen _fdopen
#  define fileno _fileno
#  define fstat _fstat
#  define lseek _lseek
#  define isatty _isatty
#  define O_RDONLY _O_RDONLY
#  define O_WRONLY _O_WRONLY
#  define O_RDWR _O_RDWR
#  define O_APPEND _O_APPEND
#  define O_CREAT _O_CREAT
#  define O_TRUNC _O_TRUNC
#  define O_EXCL _O_EXCL
#  define O_BINARY _O_BINARY
#  define O_TEXT _O_TEXT
#else
#  define O_BINARY 0u
#  define O_TEXT 0u
#endif

#ifndef STDIN_FILENO
#  define STDIN_FILENO 0
#endif

#ifndef STDOUT_FILENO
#  define STDOUT_FILENO 1
#endif

#ifndef STDERR_FILENO
#  define STDERR_FILENO 2
#endif
#endif

#ifdef _WIN32
#include "process.h"
#  define exec   _exec
#  define execl  _execl
#  define execlp _execlp
#  define execle _execle
#  define execv  _execv
#  define execvp _execvp
#  define execve _execve
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nfast\inc\nfkm.h ===
/* -*-c-*-
 *
 * $Id: nfkm.h,v 1.107.2.1 2003/04/25 13:56:11 iwj Exp $
 *
 * Key management library
 *
 * (c) 2000 nCipher Corporation Ltd.
 * All rights reserved.  Company confidential.
 */

#ifndef NFKM_H
#define NFKM_H

#ifdef __cplusplus
  extern "C" {
#endif

/*----- Header files ------------------------------------------------------*/

#include <stdarg.h>
#include <time.h>
    
#include "nfastapp.h"

#include "messages-akm-en.h"
#include "messages-akm-im.h"
#include "messages-akm-eh.h"
#include "messages-akm-enstr.h"
#include "messages-akm-mar.h"
#include "messages-akm-unmar.h"
#include "messages-akm-free.h"
#include "messages-akm-read.h"
#include "messages-akm-trans.h"
#include "messages-akm-print.h"

/*----- Primitive data types ----------------------------------------------*/

/* --- Pointers to bits of internal data --- */

typedef struct NFKM_CardSetInternalData *NFKM_CardSetInternalDataPointer;
typedef struct NFKM_CardInternalData *NFKM_CardInternalDataPointer;
typedef struct NFKM_SlotInternalData *NFKM_SlotInternalDataPointer;
typedef struct NFKM_ModuleInternalData *NFKM_ModuleInternalDataPointer;
typedef struct NFKM_WorldInternalData *NFKM_WorldInternalDataPointer;

typedef char *NFKM_String;

typedef time_t NFKM_Time;

typedef struct NFKM_ChangeInfo {
  unsigned generation; /* ~0 means deleted */
  void *userdata; /* NULL means OK to just delete */
} NFKM_ChangeInfo;

/* generation will be changed to different nonzero, non-~0 value when
 * the data in the covered structure changes (but NOT when only data
 * covered by its substructures changes).  The change will be the
 * addition of a reasonably small value (see RFC1982 on Sequence
 * Space Arithmetic).  If the structure and leaves would have been
 * deleted but for a nonnull userdata, or entries beyond this one that
 * haven't been deleted, then generation will be set to ~0.
 * generation may be set to any value by the caller, except that it
 * should not be set to ~0.  For new entries the generation will be
 * non-0.
 */

/*----- Other data structures ---------------------------------------------*/

#include "messages-anfkm-en.h"
#include "messages-anfkm-im.h"

#include "messages-anfkm-eh.h"
#include "messages-anfkm-enstr.h"
#include "messages-anfkm-mar.h"
#include "messages-anfkm-unmar.h"
#include "messages-anfkm-free.h"
#include "messages-anfkm-read.h"
#include "messages-anfkm-trans.h"
#include "messages-anfkm-print.h"

/*----- Functions provided ------------------------------------------------*/

typedef struct NFKM_GetInfoParams {
  unsigned long f;			/* - */
  size_t n_partials;			/* P */
  const NFKM_PartialCardset *partials;	/* P */
} NFKM_GetInfoParams;

#define NFKM_GIF_PARTIAL 1u	/* P */	/* Partially-written cardsets */

M_Status NFKM_getinfox(NFast_AppHandle app, const NFKM_GetInfoParams *gip,
		       NFKM_WorldInfo **ww, struct NFast_Call_Context *cc);

M_Status NFKM_getinfo(NFast_AppHandle app, NFKM_WorldInfo **world_io,
		      struct NFast_Call_Context *cctx);
/* Equivalent to NFKM_getinfox with no flags set in the params structure.
 */

void NFKM_freeinfo(NFast_AppHandle app, NFKM_WorldInfo **world_io,
		   struct NFast_Call_Context *cctx);
/* Examines the connected modules and their slots, to check
 * which modes they are in and what they are capable of.
 * On first call *world_io should be NULL.  On subsequent calls
 * it can be left from the previous call, in which case it will
 * be overwritten, and ChangeInfo's will be updated.  You must use
 * NFKM_freeinfo to free it.
 * This call will open its own connection, which will be used
 * throughout the life of the WorldInfo.  app must be supplied.
 * _freeinfo sets *world_io to NULL.
 *
 * If an error occurs in getinfo the structure may be left in a
 * partially incorrect state, even to having null pointers where some
 * pointers to additional data ought to be.  The caller must free the
 * data in _all_ cases, even error cases.  It's also not guaranteed
 * that after an error a further call to getinfo will produce correct
 * information or even not crash, or that the generation information
 * is updated properly after errors.  After an error the only safe
 * thing to do is to inspect some of the userdata pointers (while
 * being careful about null pointers in the data structure when
 * traversing it), and then call freeinfo.  However, even on
 * error none of the parts of the structure with nonzero userdata
 * pointers will be removed or made inaccessible by getinfo.
 *
 * freeinfo will delete everything without regard to userdata
 * pointers.
 */

typedef struct NFKM_FIPS140AuthState {
  M_ModuleID mn;
  M_KeyID lt, key;
  M_Hash hkltfips;
  NFKM_SlotState cardkind; /* what kind of card loaded from - Operator or Admin ? */
  M_Hash hkltu; /* all-bits-0 unless Operator */
} *NFKM_FIPS140AuthHandle;

M_Status NFKM_fips140auth(NFast_AppHandle app, NFastApp_Connection conn,
			  const NFKM_SlotInfo *slot,
			  NFKM_FIPS140AuthHandle *fips140auth_r,
			  struct NFast_Call_Context *cctx);
void NFKM_freefips140auth(NFast_AppHandle app, NFastApp_Connection conn,
			  NFKM_FIPS140AuthHandle fips140auth,
			  struct NFast_Call_Context *cctx);
/* If WorldInfo_flags_StrictFIPS140 is set then you must pass a
 * _FIPS140AuthHandle to _makecardset_begin and _erasecard, and you must also
 * provide an extra certification during key generation, which is best
 * achieved using _newkey_fips140cert.  A fips140auth is obtained from this
 * function; slot must refer to a slot containing a valid operator or
 * administrator card.  No passphrase is required.  A fips140auth is specific
 * to the module on which it was obtained, and to the ClientID for the
 * connection.  Functions which take a fips140auth must be passed !0 iff the
 * world has _StrictFIPS140; passing 0 where an auth is required, or vice
 * versa, will make them fail with a relevant Status value.  If
 * _StrictFIPS140 is not set then _fips140auth just fills in
 * *fips140auth_r with 0.
 */

typedef struct NFKM_MakeCSState *NFKM_MakeCSHandle;

M_Status NFKM_makecardset_begin(NFast_AppHandle app,
				NFastApp_Connection conn,
				const NFKM_ModuleInfo *module,
                                NFKM_MakeCSHandle *state_r,
                                const char *name, int n, int k,
				M_Word flags, int timeout,
				NFKM_FIPS140AuthHandle fips140auth,
				struct NFast_Call_Context *cctx);

void NFKM_makecardset_gethash(NFKM_MakeCSHandle mch, M_Hash *hh);
/* Fetches the identifying hash for cards created by this makecardset job.
 */

M_Word NFKM_makecardset_setflags(NFKM_MakeCSHandle mch,
				 M_Word bic, M_Word xor);
/* Returns the current flags; then clears the bits in `bic' and toggles the
 * bits in `xor'.  The flags wanted are the Card_flags_* ones.
 *
 * It is best to avoid using this function; instead, pass appropriate
 * CardSet_flags_ to NFKM_makecardset_begin and it will automatically
 * set appropriate share flags.
 */


void NFKM_makecardset_setshareacl(NFKM_MakeCSHandle mch, M_ACL *acl);
/* Sets the ACL to be set on subsequent shares of this cardset.  The ACL is
 * not copied: the pointer must remain valid.  The initial state is that no
 * ACL is set for shares; to return to this state, pass a null pointer.
 *
 * It is best to avoid using this function; instead, pass appropriate
 * CardSet_flags_ to NFKM_makecardset_begin and it will construct and
 * use an appropriate ACL.
 */

#define NFKM_SAF_REMOTE 1u		/* Allow remote reading of shares */

M_Status NFKM_makecardset_makeshareacl(NFKM_MakeCSHandle mch,
				       M_Word f, M_ACL *acl);
/* Constructs a share ACL.  Dispose of the ACL using NFastApp_FreeACL when
 * you've finished.
 */

/* FIX-ME: valid passphrase checking should be done in the km library
   for consistency's sake. Change NFKM_makecardset_nextcard to take 
   a const char *pp not a const M_Hash *pp   
 */
M_Status NFKM_makecardset_nextcard(NFKM_MakeCSHandle state, const char *name,
                                   NFKM_SlotInfo *slot, const M_Hash *pp,
				   int *sharesleft_r,
				   NFKM_FIPS140AuthHandle fips140auth);
/* Return values and semantics as for _loadcardset_nextcard.  If you don't
 * want the card to have a name, pass null.  This currently has the same
 * effect as passing an empty name, but may have a different interpretation
 * in future.
 */

#define NFKM_MCF_STEAL 1u

M_Status NFKM_makecardset_getlogicaltoken(NFKM_MakeCSHandle mch,
					  M_KeyID *ltid,
					  unsigned f);
/* Fetches the logical token id for a cardset which has been written.  Only
 * call this function /after/ @_nextcard@ says there are no shares left.  If
 * you set @NFKM_MCF_STEAL@ in @f@ then you get to keep the logical token id
 * and @_done@ won't destroy it.
 */


M_Status NFKM_makecardset_done(NFKM_MakeCSHandle state,
			       NFKM_CardSetIdent *ident_r,
			       NFKM_FIPS140AuthHandle fips140auth);

void NFKM_makecardset_abort(NFKM_MakeCSHandle state);

void NFKM_slotcacheinvalidate(NFKM_SlotInfo *slot);
/* Call this if you modify the data on a physical token directly (ie
 * without going through NFKM_makecardset_*, or if you have two
 * worlds from getinfo and use a slot from one for _makecardset_
 * but want the other to be up to date.  If you forget then the
 * slot info visible from getinfo will not reflect the changes.
 * The cacheinvalidation has no visible effect until the next
 * time you call _getinfo.
 */

M_Status NFKM_operatorcard_checkpp(NFast_AppHandle app,
				   NFastApp_Connection conn,
				   const NFKM_SlotInfo *slot,
				   const M_Hash *pp,
				   struct NFast_Call_Context *cctx);
M_Status NFKM_operatorcard_changepp(NFast_AppHandle app,
				    NFastApp_Connection conn,
				    const NFKM_SlotInfo *slot,
				    const M_Hash *oldpp, const M_Hash *newpp,
				    struct NFast_Call_Context *cctx);

M_Status NFKM_checkpp(NFast_AppHandle app, NFastApp_Connection conn,
		      const NFKM_SlotInfo *slot, const M_Hash *pp,
		      struct NFast_Call_Context *cctx);
/* Verify that a passphrase is correct for a given card.  Each share on the
 * card which has a passphrase set is checked.
 */

M_Status NFKM_changepp(NFast_AppHandle app, NFastApp_Connection conn,
		       const NFKM_SlotInfo *slot, unsigned flags,
		       const M_Hash *oldpp, const M_Hash *newpp,
		       NFKM_ShareFlag remove, NFKM_ShareFlag set,
		       struct NFast_Call_Context *cctx);

#define NFKM_changepp_flags_NoPINRecovery 1u

/* Change the passphrase on a card.  The shares given in `remove' have their
 * passphrases removed, regardless of `newpp'; the shares given in `set' have
 * their passphrases set or changed.  The `remove' and `set' flags must be
 * disjoint.  A default appropriate to the type of card in the slot is used
 * if both `remove' and `set' are zero.
 */

M_Status NFKM_erasecard(NFast_AppHandle app, NFastApp_Connection conn,
			const NFKM_SlotInfo *slot,
			NFKM_FIPS140AuthHandle fips140auth,
			struct NFast_Call_Context *cctx);

M_Status NFKM_forgetcardset(NFast_AppHandle app, const NFKM_CardSetIdent *ident,
			    struct NFast_Call_Context *cctx);

typedef struct NFKM_LoadCSState *NFKM_LoadCSHandle;

M_Status NFKM_loadcardset_begin(NFast_AppHandle app,
				NFastApp_Connection conn,
				const NFKM_ModuleInfo *module,
				const NFKM_CardSet *cardset,
				NFKM_LoadCSHandle *state_r,
				struct NFast_Call_Context *cctx);
  /* Doesn't change *state_r on failure. */
M_Status NFKM_loadcardset_nextcard(NFKM_LoadCSHandle state, const NFKM_SlotInfo *slot,
				   const M_Hash *pp, int *sharesleft_r);
  /* Return value will be TokenIOError, PhysTokenNotPresent or DecryptFailed,
   * or something else if everything went horribly wrong (ie an unrecoverable
   * error).  After any error, even a recoverable one *sharesleft_r is not changed.
   */
M_Status NFKM_loadcardset_done(NFKM_LoadCSHandle state,
                               M_KeyID *logtokid_r);
void NFKM_loadcardset_abort(NFKM_LoadCSHandle state);

M_Status NFKM_findcardset(NFast_AppHandle app, const NFKM_CardSetIdent *cardhash,
			  NFKM_CardSet **cs_r,
			  struct NFast_Call_Context *cctx);
/* If cardset does not exist, *cs_r is set to 0.  *cs_r ignored on input. */
void NFKM_freecardset(NFast_AppHandle app, NFKM_CardSet *cs,
		      struct NFast_Call_Context *cctx);
/* use only after _findcardset; cs may be 0. */

M_Status NFKM_findcard(NFast_AppHandle app, const NFKM_CardSet *cs,
		       int shareno, NFKM_Card **c_r,
		       struct NFast_Call_Context *cc);
/* If there is no card info, *c_r is set to 0. */
void NFKM_freecard(NFast_AppHandle app, NFKM_Card *c,
		   struct NFast_Call_Context *cc);
/* use only after _findcard; c may be 0. */

M_Status NFKM_listcardsets(NFast_AppHandle app, int *n_r, NFKM_CardSetIdent **list_r,
			   struct NFast_Call_Context *cctx);
/* caller must free the list (with free) when no longer required */

M_Status NFKM_listkeys(NFast_AppHandle app, int *n_r, NFKM_KeyIdent **list_r,
		       const char *appname /* may be 0 for all apps */,
		       struct NFast_Call_Context *cctx);
void NFKM_freekeyidentlist(NFast_AppHandle app, int n, NFKM_KeyIdent *list,
			   struct NFast_Call_Context *cctx);

/* Entries with numbers between 65536 and 1048575 inclusive are
   reserved for use by applications, and may have different meanings from
   one application to another. The use of subranges indicates whether the
   key management system needs to deal with the blobs and in what way.
   Numbers 65536-131071 (0x1nnnn) are not blobs at all and will not be touched;
   131072-196607 (0x2nnnn) are blobs of protected data (under LTU or KM);
   196608-262144 (0x3nnnn) are blobs of protected data made for recovery (under KRE);
   262144-327679 (0x4nnnn) are blobs of public data.
   327680-1048575 (0x5nnnn-0xfnnnn) should not currently be used. If
   they are found then the key management system may be unwilling to
   manipulate the key object in certain ways. */

#define NFKM_APPENTRY_indivmask      0x00ffff
#define NFKM_APPENTRY_typemask       0x0f0000
#define NFKM_APPENTRY_typemin        0x010000
#define NFKM_APPENTRY_typemax        0x050000

#define NFKM_APPENTRY_NOT_BLOB       0x010000
#define NFKM_APPENTRY_BLOB_PROTECTED 0x020000
#define NFKM_APPENTRY_BLOB_RECOVERY  0x030000
#define NFKM_APPENTRY_BLOB_PUBLIC    0x040000

#define NFKM_NKF_allflags           0x000b
/* result for new key if world has recovery   enabled    disabled ... */
#define NFKM_NKF_RecoveryDefault    0x0000 /* enabled    disabled   */
#define NFKM_NKF_RecoveryRequired   0x0001 /* enabled    InvalidACL */
#define NFKM_NKF_RecoveryDisabled   0x0002 /* disabled   disabled   */
#define NFKM_NKF_RecoveryForbidden  0x0003 /* InvalidACL disabled   */
#define NFKM_NKF_RecoveryEnabled    0x0001 /* for _findkey: recovery is enabled */
#define NFKM_NKF_RecoveryUnknown    0x0000 /* for _findkey: don't know about recovery */
#define NFKM_NKF_RecoveryNoKey      0x0003 /* for _findkey: no priv./sec. keys */
#define NFKM_NKF_Recovery_mask      0x0003
#define NFKM_NKF_HasCertificate	    0x0004
#define NFKM_NKF_PublicKey          0x0008 /* if set _makeacl makes for pub half */
#define NFKM_NKF_Protection_mask    0x0070
#define NFKM_NKF_ProtectionUnknown  0x0000 /* no need to set these in _makeacl */
#define NFKM_NKF_ProtectionModule   0x0010 /*  or _makeblobs */
#define NFKM_NKF_ProtectionCardSet  0x0020
#define NFKM_NKF_ProtectionNoKey    0x0040 /*  ... also covers when only public key(s) */
#define NFKM_NKF_SEEAppKey	    0x0080
#define NFKM_NKF_TimeLimit	    0x0100
#define NFKM_NKF_SEEAppKeyHashAndMech  0x0200
#define NFKM_NKF_PerAuthUseLimit    0x0400

#define NFKM_DEFOPPERMS_SIGN     \
 (Act_OpPermissions_Details_perms_Sign|Act_OpPermissions_Details_perms_UseAsCertificate|Act_OpPermissions_Details_perms_SignModuleCert)
#define NFKM_DEFOPPERMS_VERIFY   \
 (Act_OpPermissions_Details_perms_Verify)
#define NFKM_DEFOPPERMS_ENCRYPT  \
 (Act_OpPermissions_Details_perms_Encrypt|Act_OpPermissions_Details_perms_UseAsBlobKey)
#define NFKM_DEFOPPERMS_DECRYPT  \
 (Act_OpPermissions_Details_perms_Decrypt|Act_OpPermissions_Details_perms_UseAsBlobKey)

typedef struct NFKM_MakeACLParams {
  M_Word f;
  M_Word op_base, op_bic;
  const NFKM_CardSet *cs;
  const M_Hash *seeinteg;		/* SEEAppKey */
  M_Word timelimit;			/* TimeLimit */
  const M_KeyHashAndMech *seeintegkham;	/* SEEAppKeyHashAndMech */
  M_Word pa_uselimit;			/* PerAuthUseLimit */
} NFKM_MakeACLParams;

M_Status NFKM_newkey_makeacl(NFast_AppHandle app,
			     NFastApp_Connection conn,
			     const NFKM_WorldInfo *world,
			     const NFKM_CardSet *cardset,
			     M_Word flags,
			     M_Word opperms_base, M_Word opperms_maskout,
			     M_ACL *acl,
			     struct NFast_Call_Context *cctx);

M_Status NFKM_newkey_makeaclx(NFast_AppHandle app, NFastApp_Connection conn,
			      const NFKM_WorldInfo *w,
			      const NFKM_MakeACLParams *map,
			      M_ACL *acl, struct NFast_Call_Context *cc);

/* world must be non-0.  cardset should be 0 for module-only
 * protection, or non-o for cardset protection.  The acl will be
 * overwritten (and should therefore not contain any pointers to
 * malloc'd memory).
 *
 * oppermissions should be things like _Sign, _Decrypt, _UseAsBlobKey,
 * _UseAsCertificate or whatever.  In most cases you should set it to
 * one of the four macros _DEFOPPERMS_{SIGN,VERIFY,ENCRYPT,DECRYPT},
 * or some combination of those for keys like RSA and symmetric keys,
 * that can do both.
 *
 * If you wish to modify the default ACL, you may do so after calling
 * this function; it will be allocated dynamically.
 *
 * The _Protection flags must either be Unknown, or they must be
 * Module or CardSet and correspond to whether cardset is non-0; in
 * any case cardset determines the protection.
 *
 * You must free the ACL at some point, either as part of a call to
 * NFastApp_Free_Command (if it was part of a command), or using
 * NFastApp_FreeACL.
 */

M_Status NFKM_newkey_makeblobs(NFast_AppHandle app, NFastApp_Connection conn,
			       const NFKM_WorldInfo *world,
			       M_KeyID privatekey, M_KeyID publickey,
			       const NFKM_CardSet *cardset, M_KeyID logtokenid,
			       M_Word flags,
			       NFKM_Key *newkeydata_io,
			       struct NFast_Call_Context *cctx);
/* world must be non-0.  privatekey and/or publickey may be 0 if only
 * one half (or possibly even neither!) is to be recorded (or if the
 * key is a symmetric key).  Either cardset and logtokenid must both
 * be 0, or both non-0, according to whether cardset was 0 in
 * _makeacl.  flags should be as in _makeacl for the private half
 * (_PublicKey must not be specified).
 *
 * This call will overwrite the previous contents of
 * newkeydata_io->privblob, ->pubblob and ->privblobrecov (so they
 * should not contain pointers to any malloc'd memory), and will also
 * fill in ->hash, ->flags and ->cardset.  It will not change the other
 * members, which must be set appropriately before the caller uses
 * _recordkey.
 */

M_Status NFKM_newkey_makeauth(NFast_AppHandle app,
			      const NFKM_WorldInfo *world,
			      M_Word *cmd_flags,
			      M_CertificateList **cmd_certs,
			      NFKM_FIPS140AuthHandle fips140auth,
			      struct NFast_Call_Context *cctx);
/* *cmd_flags and *cmd_certs will be updated to include any
 * certificate needed for the StrictFIPS140 mode.  If certs are
 * already indicated by Command_flags_certs_present in *cmd_flags and
 * a non-0 *cmd_certs then the table of certs and the certs themselves
 * will be assumed to have been obtained dynamically, and any cert
 * table or certs recorded will be allocated dynamically.  They must
 * be freed by the caller at some later point, either as part of a
 * call of NFastApp_Free_Command, or explicitly by hand.
 *
 * As usual, you may call this function with 0 for fips140auth; it will then
 * do nothing.  If the world had WorldInfo_flagsStrictFIPS140 set your
 * GenerateKey or GenerateKeyPair command will fail unless you pass a non-0
 * fips140auth.
 */

M_Status NFKM_newkey_writecert(NFast_AppHandle app, NFastApp_Connection conn,
			       const NFKM_ModuleInfo *m, M_KeyID kpriv,
			       M_ModuleCert *mc, NFKM_Key *k,
			       struct NFast_Call_Context *cctx);
/* Sets up the key generation certificate information for a new key.  The
 * argument @mc@ should be the module certificate for a symmetric or private
 * key.  To free the data stored in the Key structure, call @NFKM_freecert@.
 */

void NFKM_freecert(NFast_AppHandle app, NFKM_Key *k,
		   struct NFast_Call_Context *cctx);
/* Frees just the key generation certificate entries in a Key structure.
 */

M_Status NFKM_findkey(NFast_AppHandle app, const NFKM_KeyIdent keyident,
		      NFKM_Key **info_r,
		      struct NFast_Call_Context *cctx);
/* if the key does not exist then *info_r is set to 0. */
void NFKM_freekey(NFast_AppHandle app, NFKM_Key *info,
		  struct NFast_Call_Context *cctx);
/* use only after _findkey.  info may be 0. */


M_Status NFKM_recordkey(NFast_AppHandle app, NFKM_Key *key,
			struct NFast_Call_Context *cctx);
/* recordkey does _not_ take over any of the memory in key.
 * protection state (module, token, etc.) is implied by the privblob details:
 * the flags word is not inspected.
 *
 * The NFKM_Key block should be cleared to all-bits-zero before use.  If you
 * use any advanced features, set the version field (member `v') to the
 * correct value before calling recordkey.
 */

M_Status NFKM_recordkeys(NFast_AppHandle app, NFKM_Key **k, size_t n,
			 struct NFast_Call_Context *cc);
/* recordkeys does the same job as recordkey for multiple keys.  Either all
 * the keys are written or none are.
 */

M_Status NFKM_forgetkey(NFast_AppHandle app, const NFKM_KeyIdent keyident,
			struct NFast_Call_Context *cctx);
/* _not_ a secure deletion */

/* Hex<->binary conversion; length must already have been checked. */
M_Status NFKM_hex2bin(const char *in_hex, unsigned char *out_bin, size_t out_bytes);
/* Return Status_OK or Status_HostDataInvalid.  No errors are logged. */

void NFKM_bin2hex(const unsigned char *in_bin, char *out_hex, size_t in_bytes);
/* Always succeeds.  Does NOT nul terminate ! */

M_Status NFKM_hashpp(NFast_AppHandle app, NFastApp_Connection conn,
		     const char *string, M_Hash *hash_r,
		     struct NFast_Call_Context *cctx);

M_Status NFKM_getkmdatadir(NFast_AppHandle app, char **path_r,
			   struct NFast_Call_Context *cctx);
/* Looks at NFAST_KMDATA, NFAST_HOME, registry entries, whatever.
 * Other routines should be used if possible, to avoid relying on
 * the structure of this directory.  This call returns the
 * path _including_ the component `local'.
 * The caller should free *path_r using NFastApp_Free.
 */

M_Status NFKM_stashworld(NFast_AppHandle app, char **newname,
			 struct NFast_Call_Context *cc);
/* Renames the current world directory.  If newname is non-zero, *newname
 * is made to point to the newly-selected name.  If there is no world
 * directory to begin with, *newname is set to a null pointer and a
 * success code is returned.
 */

typedef struct NFKM_DiagnosticContextStruct *NFKM_DiagnosticContextHandle;
typedef M_Status NFKM_diagnostic_callback(NFKM_DiagnosticContextHandle ctx,
					  const char *format, va_list al);

M_Status NFKM_checkconsistency(NFast_AppHandle app, NFKM_DiagnosticContextHandle callctx,
			       NFKM_diagnostic_callback *informational,
			       NFKM_diagnostic_callback *warning,
			       NFKM_diagnostic_callback *fatal,
			       struct NFast_Call_Context *cctx);
/* Checks the general consistency of the KM universe.
 * Returns:
 *  - if there was a fatal error, the return value from fatal(),
 *    which MUST be nonzero;
 *  - otherwise, if any other diagnostic callback returned nonzero,
 *    that return value (checking was aborted at that point)
 *  - otherwise, Status_OK.
 */

#define NFAST_NFKM_TOKENSFILE_VAR "NFAST_NFKM_TOKENSFILE"

M_Status NFKM_startexistingobjects(NFast_AppHandle app,
				   const char *alt_existingobjects_file,
				   NFastApp_Connection *conn_r,
				   struct NFast_Call_Context *cctx);
/* Will set the environment variable NFAST_NFKM_TOKENSFILE, to
 * alt_existingobjects_file if non-0, or to a default value otherwise.
 * Will obtain an appropriate client ID, and make sure it's recorded
 * in the relevant file.
 *
 * Unless you wish to update in place existing object information (eg
 * because you are doing the same job as with-nfast) you do not need to
 * call this function; with-nfast or the equivalent will set it up for you.
 */

M_Status NFKM_recordexistingobject(NFast_AppHandle app, M_ModuleID module,
				   const M_Hash *objecthash, M_KeyID id,
				   struct NFast_Call_Context *cctx);
/* If id==0, removes any annotation that the object is present.
 * You MUST already have an existing objects file and be using its clientid.
 */

/*----- Short cuts for commonly-used commands -----------------------------*
 *
 * All the functions need an app handle and an existing connection.
 *
 * The `what' arguments should describe what sort of thing you're doing the
 * operation to, for the benefit of people reading log messages created when
 * things go wrong.
 */

M_Status NFKM_cmd_generaterandom(NFast_AppHandle app,
				 NFastApp_Connection conn,
				 M_Word wanted, unsigned char **block_r,
				 struct NFast_Call_Context *cctx);
/* Calls GenerateRandom.  Short cut Sets *block_r to point to newly allocated
 * memory containing the random data.
 */

M_Status NFKM_cmd_destroy(NFast_AppHandle app, NFastApp_Connection conn,
			  M_ModuleID mn, M_KeyID idka, const char *what,
			  struct NFast_Call_Context *cctx);
/* Calls Destroy.  Destroys something. */

M_Status NFKM_cmd_loadblob(NFast_AppHandle app, NFastApp_Connection conn,
			   M_ModuleID mn, const M_ByteBlock *blob,
			   M_KeyID idlt, M_KeyID *idk_r,
			   const char *whatfor,
			   struct NFast_Call_Context *cctx);
/* Calls LoadBlob.  Set `idlt' to zero if the blob is module-only.  Make
 * `whatfor' be null if you don't want a log warning if it goes wrong.
 */

M_Status NFKM_cmd_getkeyinfo(NFast_AppHandle app, NFastApp_Connection conn,
			     M_ModuleID mn, M_KeyID idka, M_Hash *hash_r,
			     const char *what,
			     struct NFast_Call_Context *cctx);
/* Calls GetKeyInfo.  Gives you the key hash. */

M_Status NFKM_cmd_getkeyplain(NFast_AppHandle app, NFastApp_Connection conn,
			      M_ModuleID mn, M_KeyID idka, M_KeyData *keyvalue_r,
			      const char *what,
			      struct NFast_Call_Context *cctx);
/* Calls Export.  Could plausibly be enhanced in the future to allow the
 * supply of a certificate list authorizing the export.  When you've finished
 * with the exported key, call NFastApp_Free_KeyData on it.
 */

/*----- Certificate building support --------------------------------------*/

/* --- @NFKM_cert_add@ --- *
 *
 * Arguments:	@NFast_AppHandle app@ = an application handle
 *		@unsigned n@ = number of certificate slots wanted
 *		@M_Certificate **cv@ = address to store certificate pointer
 *		@M_Word *f@ = pointer to command flags word
 *		@M_CertificateList **cl@ = address of certificate list ptr
 *		@struct NFast_Call_Context *cc@ = call context to use
 *
 * Returns:	A status code.
 *
 * Use:		Allocates @n@ slots in the certificates table for a command,
 *		and stores a pointer to the first new slot in @*cv@.  Note
 *		that new slots are allocated at the end of the table, not at
 *		the beginning.  The flag word pointer @f@ may be null if
 *		you're just gathering the certificate for use in multiple
 *		commands.  Making @cl@ null isn't helpful (or allowed).
 *
 *		If a flags pointer @f@ is given, it's used to decide whether
 *		the certificate list has been initialized -- if
 *		@certs_present@ is clear, the contents of @*cl@ is ignored
 *		and a new table is allocated anyway.  Otherwise, if either
 *		the flag is set or the flags word is absent, @*cl@ must
 *		either be null to indicate that a new table is desired, or
 *		point to the base of a currently allocated table (which is
 *		safe to pass to @NFastApp_Realloc@).
 *
 *		When this call returns successfully, the number of
 *		certificates @(*cl)->n_certs@ is unchanged (or initialized to
 *		zero, if the certificate list block had to be allocated).
 *		The new certificate slots are filled with zero bytes.
 */

M_Status NFKM_cert_add(NFast_AppHandle app, unsigned n, M_Certificate **cv,
		       M_Word *f, M_CertificateList **cl,
		       struct NFast_Call_Context *cc);

/* --- @NFKM_cert_setdelg@ --- *
 *
 * Arguments:	@NFast_AppHandle app@ = an application handle
 *		@const NFKM_WorldInfo *w@ = pointer to a world block
 *		@M_Certificate *c@ = pointer to certificate to fill in
 *		@M_Word ty_cert@ = entry type of the delegation certificate
 *		@struct NFast_Call_Context *cc@ = call context to use
 *
 * Returns:	A status code.
 *
 * Use:		Fills in a delegating command certificate.  Most of the
 *		details are worked out by looking at the @ty_cert@ argument,
 *		which is the kmfile entry type for the signature on the
 *		delegation certificate (e.g., @CertDelgFIPSbNSO@) stored in
 *		the world file.  The other information required is worked out
 *		from there.  This (currently) only works with KNSO delegation
 *		certificates.
 *
 *		If this call fails, there may well be debris left in the
 *		certificate block.  It's safe to free, although you shouldn't
 *		assume that it's meaningful in any other way.
 */

M_Status NFKM_cert_setdelg(NFast_AppHandle app, const NFKM_WorldInfo *w,
			   M_Certificate *c, M_Word ty_cert,
			   struct NFast_Call_Context *cc);

/* --- @NFKM_cert_remoteshare@ --- *
 *
 * Arguments:	@NFast_AppHandle app@ = an application handle
 *		@NFastApp_Connection conn@ = connection handle
 *		@const NFKM_WorldInfo *w@ = pointer to a world block
 *		@M_Certificate *c@ = pointer to certificate to fill in
 *		@NFKM_ModuleInfo *m@ = module whose cert we want
 *		@struct NFast_Call_Context *cc@ = call context to use
 *
 * Returns:	A status code.
 *
 * Use:		Fills in a module @SendShare@ certificate.
 *
 *		If this call fails, there may well be debris left in the
 *		certificate block.  It's safe to free, although you shouldn't
 *		assume that it's meaningful in any other way.
 */

M_Status NFKM_cert_remoteshare(NFast_AppHandle app, NFastApp_Connection conn, 
                               const NFKM_WorldInfo *w, M_Certificate *c, 
                               NFKM_ModuleInfo *m, struct NFast_Call_Context *cc);

/*----- Debugging dumps ---------------------------------------------------*/

M_Status NFKM_dump_world(NFast_AppHandle app, const NFKM_WorldInfo *p,
			 FILE *fp, const char *name,
			 struct NFast_Call_Context *cc);
M_Status NFKM_dump_slot(NFast_AppHandle app, const NFKM_SlotInfo *p,
			FILE *fp, const char *name,
			struct NFast_Call_Context *cc);
M_Status NFKM_dump_module(NFast_AppHandle app, const NFKM_ModuleInfo *p,
			  FILE *fp, const char *name,
			  struct NFast_Call_Context *cc);
M_Status NFKM_dump_key(NFast_AppHandle app, const NFKM_Key *p,
		       FILE *fp, const char *name,
		       struct NFast_Call_Context *cc);
M_Status NFKM_dump_cardset(NFast_AppHandle app, const NFKM_CardSet *p,
			   FILE *fp, const char *name,
			   struct NFast_Call_Context *cc);
M_Status NFKM_dump_card(NFast_AppHandle app, const NFKM_Card *p,
			FILE *fp, const char *name,
			struct NFast_Call_Context *cc);
M_Status NFKM_dump_acl(NFast_AppHandle app, const M_ACL *p,
		       FILE *fp, const char *name,
		       struct NFast_Call_Context *cc);
M_Status NFKM_dump_keygenparams(NFast_AppHandle app, const M_KeyGenParams *p,
				FILE *fp, const char *name,
				struct NFast_Call_Context *cc);
M_Status NFKM_dump_cert(NFast_AppHandle app, const M_Certificate *p,
			FILE *fp, const char *name,
			struct NFast_Call_Context *cc);
M_Status NFKM_dump_certlist(NFast_AppHandle app, const M_CertificateList *p,
			    FILE *fp, const char *name,
			    struct NFast_Call_Context *cc);
M_Status NFKM_dump_certsignmsg(NFast_AppHandle app,
			       const M_CertSignMessage *p,
			       FILE *fp, const char *name,
			       struct NFast_Call_Context *cc);
M_Status NFKM_dump_modcertmsg(NFast_AppHandle app, const M_ModCertMsg *p,
			      FILE *fp, const char *name,
			      struct NFast_Call_Context *cc);
M_Status NFKM_dump_keydata(NFast_AppHandle app, const M_KeyData *p,
			   FILE *fp, const char *name,
			   struct NFast_Call_Context *cc);
M_Status NFKM_dump_command(NFast_AppHandle app, const M_Command *p,
			   FILE *fp, const char *name,
			   struct NFast_Call_Context *cc);
M_Status NFKM_dump_reply(NFast_AppHandle app, const M_Reply *p,
			 FILE *fp, const char *name,
			 struct NFast_Call_Context *cc);
/* Produce a debugging dump of an NFKM object.
 */

/*----- ACL construction --------------------------------------------------*/

typedef struct NFKM_MkACL *NFKM_MkACLHandle;

/* --- @NFKM_mkacl_nextty@ --- *
 *
 * Arguments:	@NFKM_MkACLHandle ma@ = ACL construction handle
 *
 * Returns:	A pointer to the next free slot of the appropriate
 *		type, or a null pointer if there isn't enough memory.
 *
 * Use:		Returns the next free slot in a particular dynamic
 *		array, allocating more memory if necessary.
 */

M_PermissionGroup *NFKM_mkacl_nextpg(NFKM_MkACLHandle ma);
M_Action *NFKM_mkacl_nextact(NFKM_MkACLHandle ma);
M_UseLimit *NFKM_mkacl_nextlim(NFKM_MkACLHandle ma);
M_RemoteModule *NFKM_mkacl_nextrm(NFKM_MkACLHandle ma);
M_ModuleAttribList *NFKM_mkacl_nextmal(NFKM_MkACLHandle ma);
M_ModuleAttrib *NFKM_mkacl_nextma(NFKM_MkACLHandle ma);
M_KeyHashAttrib *NFKM_mkacl_nextkha(NFKM_MkACLHandle ma);
M_KeyHashAndMech *NFKM_mkacl_nextkham(NFKM_MkACLHandle ma);

/* --- @NFKM_mkacl_setty@ --- *
 *
 * Arguments:	@NFKM_MkACLHandle ma@ = ACL construction handle
 *		@int *n@ = address of table size
 *		@M_Ty **v@ = address of table pointer
 *
 * Returns:	A status code.
 *
 * Use:		Sets a table to refer to the currently constructed
 *		array of a particular type.
 */

M_Status NFKM_mkacl_setpg(NFKM_MkACLHandle ma, int *n,
			  M_PermissionGroup **v);
M_Status NFKM_mkacl_setact(NFKM_MkACLHandle ma, int *n, M_Action **v);
M_Status NFKM_mkacl_setlim(NFKM_MkACLHandle ma, int *n, M_UseLimit **v);
M_Status NFKM_mkacl_setrm(NFKM_MkACLHandle ma, int *n, M_RemoteModule **v);
M_Status NFKM_mkacl_setmal(NFKM_MkACLHandle ma, int *n,
			   M_ModuleAttribList **v);
M_Status NFKM_mkacl_setma(NFKM_MkACLHandle ma, int *n, M_ModuleAttrib **v);
M_Status NFKM_mkacl_setkha(NFKM_MkACLHandle ma, int *n, M_KeyHashAttrib **v);
M_Status NFKM_mkacl_setkham(NFKM_MkACLHandle ma, int *n,
			    M_KeyHashAndMech **v);

/* --- @NFKM_mkacl_create@ --- *
 *
 * Arguments:	@NFast_AppHandle app@ = application handle
 *		@NFastApp_Connection conn@ = connection handle
 *		@NFKM_MkACLHandle *mah@ = where to store the handle
 *		@struct NFast_Call_Context *cc@ = call context
 *
 * Returns:	A status code.
 *
 * Use:		Creates an ACL-construction object.  On failure, a null
 *		pointer is stored in @*mah@.
 */

M_Status NFKM_mkacl_create(NFast_AppHandle app, NFastApp_Connection conn,
			   NFKM_MkACLHandle *mah,
			   struct NFast_Call_Context *cc);

/* --- @NFKM_mkacl_destroy@ --- *
 *
 * Arguments:	@NFKM_MkACLHandle ma@ = ACL construction handle
 *
 * Returns:	---
 *
 * Use:		Frees up an ACL construction handle.  It's safe to pass a
 *		null pointer.
 */

void NFKM_mkacl_destroy(NFKM_MkACLHandle mah);

/* --- @NFKM_mkacl_reset@ --- *
 *
 * Arguments:	@NFKM_MkACLHandle ma@ = ACL construction handle
 *
 * Returns:	---
 *
 * Use:		Resets an ACL construction handle.  Any partially-created
 *		things are freed and forgotten.
 */

void NFKM_mkacl_reset(NFKM_MkACLHandle ma);

/* --- @NFKM_mkacl_check@ --- *
 *
 * Arguments:	@NFKM_MkACLHandle ma@ = ACL construction handle
 *
 * Returns:	A status code.
 *
 * Use:		Checks whether everything is OK with the context.  If it is,
 *		returns @Status_OK@.
 */

M_Status NFKM_mkacl_check(NFKM_MkACLHandle ma);

/* --- @NFKM_mkacl_setacl@ --- *
 *
 * Arguments:	@NFKM_MkACLHandle ma@ = ACL construction handle
 *		@M_ACL *acl@ = pointer to ACL to set
 *
 * Returns:	A status code.
 *
 * Use:		Writes the constructed ACL somewhere useful and resets for
 *		creating another ACL.
 */

M_Status NFKM_mkacl_setacl(NFKM_MkACLHandle ma, M_ACL *acl);

/* --- @NFKM_mkacl_ops@ --- *
 *
 * Arguments:	@NFKM_MkACLHandle ma@ = ACL construction handle
 *		@M_Word p@ = permissions flags
 *
 * Returns:	A status code.
 *
 * Use:		Adds an @OpPermissions@ action node to the ACL under
 *		construction.
 */

M_Status NFKM_mkacl_ops(NFKM_MkACLHandle ma, M_Word p);

/* --- @NFKM_mkacl_makeblob@ --- *
 *
 * Arguments:	@NFKM_MkACLHandle ma@ = ACL construction handle
 *		@M_Word f@ = flags for the action node
 *		@M_KMHash *hkm@ = pointer to KM hash, or null
 *		@M_TokenHash *hlt@ = pointer to token hash, or null
 *		@M_TokenParams *tp@ = pointer to token parameters, or null
 *
 * Returns:	A status code.
 *
 * Use:		Adds a @MakeBlob@ action node to the ACL under construction.
 */

M_Status NFKM_mkacl_makeblob(NFKM_MkACLHandle ma, M_Word f, M_KMHash *hkm,
			      M_TokenHash *hlt, M_TokenParams *tp);

/* --- @NFKM_mkacl_archiveblob@ --- *
 *
 * Arguments:	@NFKM_MkACLHandle ma@ = ACL construction handle
 *		@M_Mech m@ = mechanism to use for blobbing
 *		@M_KeyHash *hk@ = pointer to blobbing key, or null
 *
 * Returns:	A status code.
 *
 * Use:		Adds a @MakeArchiveBlob@ action node to the ACL under
 *		construction.
 */

M_Status NFKM_mkacl_archiveblob(NFKM_MkACLHandle ma,
				M_Mech m, M_KeyHash *hk);

/* --- @NFKM_mkacl_nsoperms@ --- *
 *
 * Arguments:	@NFKM_MkACLHandle ma@ = ACL construction handle
 *		@M_Word f@ = NSO operations mask
 *
 * Returns:	A status code.
 *
 * Use:		Adds an NSO-operations entry to an ACL.
 */

M_Status NFKM_mkacl_nsoperms(NFKM_MkACLHandle ma, M_Word f);

/* --- @NFKM_mkacl_globlimit@, @NFKM_mkacl_authlimit@ --- *
 *
 * Arguments:	@NFKM_MkACLHandle ma@ = ACL construction handle
 *		@unsigned max@ = number of operations allowed
 *		@M_LimitID *lid@ = pointer to limit id, or null
 *
 * Returns:	A status code.
 *
 * Use:		Adds a use limit node.  If a limit id is given it's used
 *		as-is; otherwise a new random one is generated by sending a
 *		@GenerateRandom@ request to the module.
 */

M_Status NFKM_mkacl_globlimit(NFKM_MkACLHandle ma,
			      unsigned max, M_LimitID *lid);

M_Status NFKM_mkacl_authlimit(NFKM_MkACLHandle ma,
			      unsigned max, M_LimitID *lid);

/* --- @NFKM_mkacl_timelimit@ --- *
 *
 * Arguments:	@NFKM_MkACLHandle ma@ = ACL construction handle
 *		@unsigned long sec@ = number of seconds to wait
 *
 * Returns:	A status code.
 *
 * Use:		Adds a time limit node.
 */

M_Status NFKM_mkacl_timelimit(NFKM_MkACLHandle ma, unsigned long sec);

/* --- @NFKM_mkacl_pgroup@, @NFKM_mkacl_pgroup_certmech@ --- *
 *
 * Arguments:	@NFKM_MkACLHandle ma@ = ACL construction handle
 *		@M_Word f@ = flags
 *		@M_KeyHash *hkauth@ = hash of the authorization key, or null
 *		@M_KeyHashAndMech *kham@ = pointer to appropriate stuff
 *
 * Returns:	A status code.
 *
 * Use:		Adds a permissions group to the ACL being built.  The actions
 *		and use limits constructed since the last permission group,
 *		reset or initialization are attached to the group.
 */

M_Status NFKM_mkacl_pgroup(NFKM_MkACLHandle ma, M_Word f, M_KeyHash *hkauth);
M_Status NFKM_mkacl_pgroup_certmech(NFKM_MkACLHandle ma, M_Word f,
				    M_KeyHashAndMech *kham);

/* --- @NFKM_mkacl_trump@ --- *
 *
 * Arguments:	@NFKM_MkACLHandle ma@ = ACL construction handle
 *		@M_KeyHash *hknso@ = pointer to Security Officer's key hash
 *		@M_Word p@ = extra permissions (e.g., @ExportAsPlain@)
 *
 * Returns:	A status code.
 *
 * Use:		Adds `trump operations' to an ACL.  Assumes that there aren't
 *		uncommitted nodes in the actions and limits tables.  This
 *		requires 3 actions and 1 permission group.
 */

M_Status NFKM_mkacl_trump(NFKM_MkACLHandle ma, M_KeyHash *hknso, M_Word p);

/* --- @NFKM_mkacl_pubkey@ --- *
 *
 * Arguments:	@NFKM_MkACLHandle ma@ = ACL construction handle
 *		@M_Word p@ = extra permissions
 *
 * Returns:	A status code.
 *
 * Use:		Sets up a public key ACL.  This requires 2 actions and 1
 *		permission group.
 */

M_Status NFKM_mkacl_pubkey(NFKM_MkACLHandle ma, M_Word p);

/*----- Security world administration -------------------------------------*/

/* --- @NFKM_InitWorldParams@ --- *
 *
 * This structure will grow as new features are added to the security world.
 * As long as you only set flags defined below, you'll be OK when this
 * happens.  The comments below attempt to show which flags affect which
 * fields.  I'm afraid that they interact somewhat.
 */

typedef struct NFKM_InitWorldParams {
			/* Flags */	/* Meaning */
  unsigned f;		/* - */		/* Feature flags */
  unsigned t, n;	/* - */		/* Secret sharing parameters */
  unsigned t_m;		/* T */		/* Module programming threshold */
  unsigned t_r;		/* T R */	/* Key recovery threshold */
  unsigned t_p;		/* T P */	/* PIN recovery threshold */
  unsigned t_nv;	/* T N */	/* NVRAM fiddling threshold */
  unsigned t_rtc;	/* T C */	/* RTC fiddling threshold */
  unsigned t_dsee;	/* T D */	/* SEE debugging threshold */
  unsigned dmask;	/* + */		/* Unwanted flags (after default) */
  unsigned t_fto;	/* T G */	/* ForeignTokenOpen threshold */
} NFKM_InitWorldParams;

#define NFKM_IWF_FIPS 1u	/* F */	/* Make a FIPS 140 world */
#define NFKM_IWF_RECOVERY 2u	/* R */	/* Make a world with key recovery */
#define NFKM_IWF_TOKPARAMS 4u	/* T */	/* Specify detailed sharing params */
#define NFKM_IWF_PINRECOVERY 8u /* P */	/* Make a world with PIN recovery */
#define NFKM_IWF_RTC 16u	/* C */	/* Make key for setting RTC */
#define NFKM_IWF_NVRAM 32u	/* N */	/* Make key for fiddling NVRAM */
#define NFKM_IWF_DSEE 64u	/* D */	/* Make key to debug SEEworlds */
#define NFKM_IWF_DSEEALL 128u		/* Allow anyone to debug SEEworlds */
#define NFKM_IWF_DEFAULTS 256u	/* + */	/* Select default flags */
#define NFKM_IWF_FTO 512u	/* G */	/* Make key for foreign token open */

/* --- @NFKM_InitModuleParams@ --- *
 *
 * This structure will grow in the same way.  It's used in both @initworld@
 * and @loadworld@ to set the properties for the module being initialized.
 */

typedef struct NFKM_InitModuleParams {
			/* Flags */	/* Meaning */
  unsigned f;		/* - */		/* Feature flags */
} NFKM_InitModuleParams;

#define NFKM_IMF_SHARETARGET 1u		/* Good remote share target */

/* --- Various opaque handles --- */

typedef struct NFKM_InitWorld *NFKM_InitWorldHandle;
typedef struct NFKM_LoadWorld *NFKM_LoadWorldHandle;
typedef struct NFKM_ReplaceACS *NFKM_ReplaceACSHandle;
typedef struct NFKM_ReplaceOCS *NFKM_ReplaceOCSHandle;
typedef struct NFKM_RecoverPIN *NFKM_RecoverPINHandle;

/* --- @NFKM_erasemodule@ --- *
 *
 * Arguments:	@NFast_AppHandle app@ = application handle
 *		@NFastApp_Connection conn@ = connection to the server
 *		@const NFKM_ModuleInfo *m@ = module to be erased
 *		@struct NFast_Call_Context *cc@ = call context
 *
 * Returns:	A status code.
 *
 * Use:		Erases a module.  The module must be in (pre-)init mode.  All
 *		NSO permissions are granted, and the security officer's key
 *		is reset to its default.
 */

M_Status NFKM_erasemodule(NFast_AppHandle app, NFastApp_Connection conn,
			  const NFKM_ModuleInfo *m,
			  struct NFast_Call_Context *cc);

/* --- @NFKM_initworld_begin@ --- *
 *
 * Arguments:	@NFast_AppHandle app@ = application handle
 *		@NFastApp_Connection conn@ = connection to the server
 *		@NFKM_InitWorldHandle *iwh@ = address of handle to set
 *		@const NFKM_ModuleInfo *m@ = module to be initialized
 *		@const NFKM_InitWorldParams *iwp@ = parameters for new world
 *		@struct NFast_Call_Context *cc@ = call context for the job
 *
 * Returns:	A status code.
 *
 * Use:		Does the initial part of work for a security world
 *		initialization.  If this function fails, nothing will have
 *		been allocated and no further action need be taken; if it
 *		succeeds, the handle returned must be freed by calling
 *		@NFKM_initworld_done@ or @NFKM_initworld_abort@.
 *
 *		It will help if you call @NFKM_getinfo@ again after this
 *		function -- otherwise you won't be able to refer to the
 *		module's slots since it was in PreInit mode last time you
 *		looked.
 */

M_Status NFKM_initworld_begin(NFast_AppHandle app, NFastApp_Connection conn,
			      NFKM_InitWorldHandle *iwh,
			      const NFKM_ModuleInfo *m,
			      const NFKM_InitWorldParams *iwp,
			      struct NFast_Call_Context *cc);

/* --- @NFKM_initworld_gethash@ --- *
 *
 * Arguments:	@NFKM_InitWorldHandle iwh@ = handle for security world init
 *		@M_Hash *hh@ = where to write the hash
 *
 * Returns:	---
 *
 * Use:		Fetches the identifying hash for new administrator cards
 *		created by this job.
 */

void NFKM_initworld_gethash(NFKM_InitWorldHandle iwh, M_Hash *hh);

/* --- @NFKM_initworld_nextcard@ --- *
 *
 * Arguments:	@NFKM_InitWorldHandle iwh@ = handle for security world init
 *		@NFKM_SlotInfo *s@ = slot containing the admin card
 *		@const M_Hash *pp@ = passphrase for the card
 *		@int *left@ = address to store number of cards remaining
 *
 * Returns:	A status code.
 *
 * Use:		Writes an administrator card.
 */

M_Status NFKM_initworld_nextcard(NFKM_InitWorldHandle iwh, NFKM_SlotInfo *s,
				 const M_Hash *pp, int *left);

/* --- @NFKM_initworld_setinitmoduleparams@ --- *
 *
 * Arguments:	@NFKM_InitWorldHandle iwh@ = handle for security world init
 *		@const NFKM_InitModuleParams *imp@ = module init params
 *
 * Returns:	A status code.
 *
 * Use:		Configures the parameters for module initialization at the
 *		end of the world initialization.
 */

M_Status NFKM_initworld_setinitmoduleparams(NFKM_InitWorldHandle iwh,
					   const NFKM_InitModuleParams *imp);

/* --- @NFKM_initworld_done@ --- *
 *
 * Arguments:	@NFKM_InitWorldHandle iwh@ = handle for security world init
 *
 * Returns:	A status code.
 *
 * Use:		Finishes security world initialization.  If this function
 *		succeeds, the handle will have been freed; if it fails, you
 *		must still call @NFKM_initworld_abort@.
 */

M_Status NFKM_initworld_done(NFKM_InitWorldHandle iwh);

/* --- @NFKM_initworld_abort@ --- *
 *
 * Arguments:	@NFKM_InitWorldHandle iwh@ = handle for security world init
 *
 * Returns:	---
 *
 * Use:		Destroys a security world initialization context.
 */

void NFKM_initworld_abort(NFKM_InitWorldHandle iwh);

/* --- @NFKM_loadworld_begin@ --- *
 *
 * Arguments:	@NFast_AppHandle app@ = application handle
 *		@NFastApp_Connection conn@ = connection handle
 *		@NFKM_LoadWorldHandle *lwh@ = address of handle to fill in
 *		@const NFKM_ModuleInfo *m@ = module to be initialized
 *		@struct NFast_Call_Context *cc@ = call context handle
 *
 * Returns:	A status code.
 *
 * Use:		Initializes an operation to program a module with an existing
 *		security world.  If this function fails, nothing will have
 *		been allocated and no further action need be taken; if it
 *		succeeds, the handle returned must be freed by calling
 *		@NFKM_loadworld_done@ or @NFKM_loadworld_abort@.
 *
 *		As for initializing new security worlds, it will help if you
 *		call @NFKM_getinfo@ again after this function.
 */

M_Status NFKM_loadworld_begin(NFast_AppHandle app, NFastApp_Connection conn,
			      NFKM_LoadWorldHandle *lwh,
			      const NFKM_ModuleInfo *m,
			      struct NFast_Call_Context *cc);

/* --- @NFKM_loadworld_nextcard@ --- *
 *
 * Arguments:	@NFKM_LoadWorldHandle lwh@ = handle for security world load
 *		@const NFKM_SlotInfo *s@ = slot containing the admin card
 *		@const M_Hash *pp@ = passphrase for the card
 *		@int *left@ = address to store number of cards remaining
 *
 * Returns:	A status code.
 *
 * Use:		Reads an administrator card.
 */

M_Status NFKM_loadworld_nextcard(NFKM_LoadWorldHandle lwh,
				 const NFKM_SlotInfo *s,
				 const M_Hash *pp, int *left);

/* --- @NFKM_loadworld_setinitmoduleparams@ --- *
 *
 * Arguments:	@NFKM_LoadWorldHandle lwh@ = handle for security world init
 *		@const NFKM_InitModuleParams *imp@ = module init params
 *
 * Returns:	A status code.
 *
 * Use:		Configures the parameters for module initialization at the
 *		end of the world initialization.
 */

M_Status NFKM_loadworld_setinitmoduleparams(NFKM_LoadWorldHandle lwh,
					   const NFKM_InitModuleParams *imp);

/* --- @NFKM_loadworld_done@ --- *
 *
 * Arguments:	NFKM_LoadWorldHandle lwh@ = handle for security world load
 *
 * Returns:	A status code.
 *
 * Use:		Finishes security world loading.  If this function succeeds,
 *		the handle will have been freed; if it fails, you must still
 *		call @NFKM_loadworld_abort@.
 */

M_Status NFKM_loadworld_done(NFKM_LoadWorldHandle lwh);

/* --- @NFKM_loadworld_abort@ --- *
 *
 * Arguments:	@NFKM_LoadWorldHandle lwh@ = handle for security world load
 *
 * Returns:	---
 *
 * Use:		Destroys a security world loading context.
 */

void NFKM_loadworld_abort(NFKM_LoadWorldHandle lwh);

/* --- @NFKM_replaceacs_preflightcheck@ --- *
 *
 * Arguments:	@NFast_AppHandle app@ = application handle
 *		@const NFKM_WorldInfo *w@ = world information
 *		@int *unsafe@ = cleared if safe, nonzero if not
 *		@struct NFast_Call_Context *cc@ = call context
 *
 * Returns:	A status code.
 *
 * Use:		Verifies that a replaceacs operation is safe.  If the
 *		operation is safe, @*unsafe@ is cleared; otherwise it will
 *		contain a nonzero value.  Later, this might explain in more
 *		detail what the problem is.  Currently, the only check is
 *		for world file entries which aren't understood (and therefore
 *		might be blobs of keys which would need to be replaced).
 */

int NFKM_replaceacs_preflightcheck(NFast_AppHandle app,
				   const NFKM_WorldInfo *w,
				   int *unsafe,
				   struct NFast_Call_Context *cc);

/* --- @NFKM_replaceacs_begin@ --- *
 *
 * Arguments:	@NFast_AppHandle app@ = application handle
 *		@NFastApp_Connection conn@ = connection handle
 *		@NFKM_ReplaceACSHandle *rah@ = address of job handle
 *		@const NFKM_ModuleInfo *m@ = module to use for the transfer
 *		@struct NFast_Call_Context *cc@ = call context
 *
 * Returns:	A status code.
 *
 * Use:		Starts a job to replace the admin cardset.  If this function
 *		fails, there's nothing else to do; if it succeeds, you'll
 *		have to either go all the way through @_done@ or call
 *		@NFKM_replaceacs_abort@ to throw away all of the state.
 */

M_Status NFKM_replaceacs_begin(NFast_AppHandle app, NFastApp_Connection conn,
			       NFKM_ReplaceACSHandle *rah,
			       const NFKM_ModuleInfo *m,
			       struct NFast_Call_Context *cc);

/* --- @NFKM_replaceacs_readcard@ --- *
 *
 * Arguments:	@NFKM_ReplaceACSHandle rah@ = job handle
 *		@const NFKM_SlotInfo *s@ = slot containing admin card
 *		@const M_Hash *pp@ = passphrase for the card
 *		@int *left@ = address to store number of cards remaining
 *
 * Returns:	A status code.
 *
 * Use:		Reads an administrator card, with a view to replacing it.
 */

M_Status NFKM_replaceacs_readcard(NFKM_ReplaceACSHandle rah,
				  const NFKM_SlotInfo *s, const M_Hash *pp,
				  int *left);

/* --- @NFKM_replaceacs_middle@ --- *
 *
 * Arguments:	@NFKM_ReplaceACSHandle rah@ = job handle
 *
 * Returns:	A status code.
 *
 * Use:		Does the work in the middle of an admin cardset replacement
 *		job.
 */

M_Status NFKM_replaceacs_middle(NFKM_ReplaceACSHandle rah);

/* --- @NFKM_replaceacs_gethash@ --- *
 *
 * Arguments:	@NFKM_ReplaceACSHandle rah@ = handle for security world init
 *		@M_Hash *hh@ = where to write the hash
 *
 * Returns:	---
 *
 * Use:		Fetches the identifying hash for new administrator cards
 *		created by this job.
 */

void NFKM_replaceacs_gethash(NFKM_ReplaceACSHandle rah, M_Hash *hh);

/* --- @NFKM_replaceacs_writecard@ --- *
 *
 * Arguments:	@NFKM_ReplaceACSHandle rah@ = job handle
 *		@NFKM_SlotInfo *s@ = slot containing admin card
 *		@const M_Hash *pp@ = passphrase for the card
 *		@int *left@ = address to store number of cards remaining
 *
 * Returns:	A status code.
 *
 * Use:		Writes a replacement administrator card.
 */

M_Status NFKM_replaceacs_writecard(NFKM_ReplaceACSHandle rah,
				   NFKM_SlotInfo *s, const M_Hash *pp,
				   int *left);

/* --- @NFKM_replaceacs_done@ --- *
 *
 * Arguments:	@NFKM_ReplaceACSHandle rah@ = job handle
 *
 * Returns:	A status code.
 *
 * Use:		Wraps up an admin card replacement job.
 */

M_Status NFKM_replaceacs_done(NFKM_ReplaceACSHandle rah);

/* --- @NFKM_replaceacs_abort@ --- *
 *
 * Arguments:	@NFKM_ReplaceACSHandle rah@ = job handle
 *
 * Returns:	---
 *
 * Use:		Destroys an admin card replacement context.
 */

void NFKM_replaceacs_abort(NFKM_ReplaceACSHandle rah);

/* --- @NFKM_replaceocs_begin@ --- *
 *
 * Arguments:	@NFast_AppHandle app@ = application handle
 *		@NFastApp_Connection conn@ = connection handle
 *		@NFKM_ReplaceOCSHandle *roh@ = address to store job handle
 *		@const NFKM_ModuleInfo *m@ = module to do the recovery on
 *		@struct NFast_Call_Context *cc@ = caller's call context
 *
 * Returns:	A status code.
 *
 * Use:		Initializes an operator cardset replacement context.  The
 *		next job is to load the various tokens off the admin cards
 *		(with @NFKM_replaceocs_nextcard@) and then to instruct the
 *		recovery of various keys.
 */

M_Status NFKM_replaceocs_begin(NFast_AppHandle app, NFastApp_Connection conn,
			       NFKM_ReplaceOCSHandle *roh,
			       const NFKM_ModuleInfo *m,
			       struct NFast_Call_Context *cc);

/* --- @NFKM_replaceocs_nextcard@ --- *
 *
 * Arguments:	@NFKM_ReplaceOCSHandle roh@ = job handle
 *		@const NFKM_SlotInfo *s@ = pointer to slot to read
 *		@const M_Hash *pp@ = pointer to PIN hash, if there is one
 *		@int *left@ = address to store number of cards remaining
 *
 * Returns:	A status code.
 *
 * Use:		Reads an admin card.
 */

M_Status NFKM_replaceocs_nextcard(NFKM_ReplaceOCSHandle roh,
				  const NFKM_SlotInfo *s,
				  const M_Hash *pp, int *left);

/* --- @NFKM_replaceocs_middle@ --- *
 *
 * Arguments:	@NFKM_ReplaceOCSHandle roh@ = job handle
 *
 * Returns:	A status code.
 *
 * Use:		Sets up the cardset recovery system ready for actually doing
 *		recovery.
 */

M_Status NFKM_replaceocs_middle(NFKM_ReplaceOCSHandle roh);

/* --- @NFKM_replaceocs_key@ --- *
 *
 * Arguments:	@NFKM_ReplaceOCSHandle roh@ = job handle
 *		@NFKM_Key *k@ = key structure to recover (overwritten)
 *		@M_KeyID lt@ = logical token to protect recovered key
 *		@const NFKM_CardSet *cs@ = pointer to cardset information
 *
 * Returns:	A status code.
 *
 * Use:		Recovers a key.  The protected working blobs in the given key
 *		are rewritten to contain the new blobs.  The key block isn't
 *		written to a file -- you should call @NFKM_recordkey@ (or
 *		@NFKM_recordkeys@) to do the actual work.
 *
 *		Special magic applies to PKCS#11 keys (appname `pkcs11').  If
 *		the key is a PKCS#11 one, the *ident* of the key is changed
 *		to reflect its new protection status.  Because PKCS#11 has
 *		the concept of a `public' object associated with a particular
 *		cardset, it makes sense to present this call with a
 *		module-protected key, zero @lt@ and nonzero @cs@ to move a
 *		public object to a different cardset.
 */

M_Status NFKM_replaceocs_key(NFKM_ReplaceOCSHandle roh, NFKM_Key *k,
			     M_KeyID lt, const NFKM_CardSet *cs);

/* --- @NFKM_replaceocs_cardset@ --- *
 *
 * Arguments:	@NFKM_ReplaceOCSHandle roh@ = job handle
 *		@const NFKM_CardSetIdent *hcs@ = cardset identity to use
 *		@M_KeyID lt@ = logical token to protect recovered key
 *		@const NFKM_CardSet *cs@ = pointer to cardset information
 *		@unsigned *done, *notdone@ = where to store the results
 *
 * Returns:	A status code.
 *
 * Use:		Recovers the keys protected by a particular cardset.  The
 *		keys are written back out to disk.  Either all of the key
 *		writes will succeed or none will.  The idents of PKCS#11 keys
 *		are changed as appropriate, including module-protected
 *		PKCS#11 keys.  If everything was successful, and the pointers
 *		aren't null, the @done@ and @notdone@ values are incremented.
 */

M_Status NFKM_replaceocs_cardset(NFKM_ReplaceOCSHandle roh,
				 const NFKM_CardSetIdent *hcs, M_KeyID lt,
				 const NFKM_CardSet *cs,
				 unsigned *done, unsigned *notdone);

/* --- @NFKM_replaceocs_done@ --- *
 *
 * Arguments:	@NFKM_ReplaceOCSHandle roh@ = job handle
 *
 * Returns:	---
 *
 * Use:		Finishes with an operator cardset replacement context.
 */

void NFKM_replaceocs_done(NFKM_ReplaceOCSHandle roh);

/* --- @NFKM_recoverpin_begin@ --- *
 *
 * Arguments:	@NFast_AppHandle app@ = application handle
 *		@NFastApp_Connection conn@ = connection handle
 *		@NFKM_RecoverPINHandle *rph@ = where to store the handle
 *		@const NFKM_ModuleInfo *m@ = module to do the recovery
 *		@struct NFast_Call_Context *cc@ = call context
 *
 * Returns:	A status code.
 *
 * Use:		Initializes a PIN recovery session.  If the call succeeds,
 *		you must eventually release the handle by calling
 *		@NFKM_recoverpin_done@.
 */

M_Status NFKM_recoverpin_begin(NFast_AppHandle app, NFastApp_Connection conn,
			       NFKM_RecoverPINHandle *rph,
			       const NFKM_ModuleInfo *m,
			       struct NFast_Call_Context *cc);

/* --- @NFKM_recoverpin_nextcard@ --- *
 *
 * Arguments:	@NFKM_RecoverPINHandle rph@ = job handle
 *		@const NFKM_SlotInfo *s@ = pointer to slot to read
 *		@const M_Hash *pp@ = pointer to PIN hash, or null
 *		@int *left@ = address to store number of cards remaining
 *
 * Returns:	A status code.
 *
 * Use:		Reads an admin card.
 */

M_Status NFKM_recoverpin_nextcard(NFKM_RecoverPINHandle rph,
				  const NFKM_SlotInfo *s, const M_Hash *pp,
				  int *left);

/* --- @NFKM_recoverpin_middle@ --- *
 *
 * Arguments:	@NFKM_RecoverPINHandle rph@ = job handle
 *
 * Returns:	A status code.
 *
 * Use:		Completes assembly of admin tokens and loads keys.
 */

M_Status NFKM_recoverpin_middle(NFKM_RecoverPINHandle rph);

/* --- @NFKM_recoverpin_card@ --- *
 *
 * Arguments:	@NFKM_RecoverPINHandle rph@ = job handle
 *		@const NFKM_Card *c@ = pointer to a card record
 *		@M_Hash *pp@ = where to store the recovered PIN hash
 *
 * Returns:	A status code.
 *
 * Use:		Recovers a card's PIN.  @Status_NotAvailable@ is returned if
 *		the card doesn't support recovery, or if there is no PIN to
 *		recover.
 */

M_Status NFKM_recoverpin_card(NFKM_RecoverPINHandle rph,
			      const NFKM_Card *c, M_Hash *pp);

/* --- @NFKM_recoverpin_done@ --- *
 *
 * Arguments:	@NFKM_RecoverPINHandle rph@ = job handle
 *
 * Returns:	---
 *
 * Use:		Frees a PIN recovery job.
 */

void NFKM_recoverpin_done(NFKM_RecoverPINHandle rph);

/*----- Admin key loading -------------------------------------------------*/

/* --- About key and token numbering --- *
 *
 * Key and token numbers exist in the same sort of numbering space.  The
 * number for a token will be the same as one of the keys it protects.
 */

enum {
  NFKM_KNSO,
  NFKM_KM,
  NFKM_KRA,
  NFKM_KP,
  NFKM_KNV,
  NFKM_KRTC,
  NFKM_KFIPS,
  NFKM_KMC,
  NFKM_KRE,
  NFKM_KDSEE,
  NFKM_KFTO,
  NFKM_KMAX
};

enum {
  NFKM_LTNSO = NFKM_KNSO,
  NFKM_LTM = NFKM_KM,
  NFKM_LTR = NFKM_KRA,
  NFKM_LTP = NFKM_KP,
  NFKM_LTNV = NFKM_KNV,
  NFKM_LTRTC = NFKM_KRTC,
  NFKM_LTFIPS = NFKM_KFIPS,
  NFKM_LTDSEE = NFKM_KDSEE,
  NFKM_LTFTO = NFKM_KFTO,
  NFKM_LTMAX = NFKM_KMAX
};

#define NFKM_LAKF_STEAL 1u

typedef struct NFKM_LoadAdminKeys *NFKM_LoadAdminKeysHandle;

/* --- @NFKM_loadadminkeys_begin@ --- *
 *
 * Arguments:	@NFast_AppHandle app@ = application handle
 *		@NFastApp_Connection conn@ = connection handle
 *		@NFKM_LoadAdminKeysHandle *lakh@ = address of handle
 *		@const NFKM_ModuleInfo *m@ = module to do the loading
 *		@struct NFast_Call_Context *cc@ = call context handle
 *
 * Returns:	A status code.
 *
 * Use:		Initializes an operation to load administrator keys.
 *		Initially, no tokens are are selected for loading.
 */

M_Status NFKM_loadadminkeys_begin(NFast_AppHandle app,
				  NFastApp_Connection conn,
				  NFKM_LoadAdminKeysHandle *lakh,
				  const NFKM_ModuleInfo *m,
				  struct NFast_Call_Context *cc);

/* --- @NFKM_loadadminkeys_selecttokens@ --- *
 *
 * Arguments:	@NFKM_LoadAdminKeysHandle lakh@ = context for loading
 *		@const int *k@ = array of key or token labels
 *
 * Returns:	A status code (only for programming errors).
 *
 * Use:		Selects a collection of tokens to be loaded.  The array is
 *		terminated by an entry containing the value @-1@.  Each entry
 *		may be either a key or token label.  A key label requests
 *		that the token protecting that key be loaded.
 */

M_Status NFKM_loadadminkeys_selecttokens(NFKM_LoadAdminKeysHandle lakh,
					 const int *k);

/* --- @NFKM_loadadminkeys_selecttoken@ --- *
 *
 * Arguments:	@NFKM_LoadAdminKeysHandle lakh@ = context for loading
 *		@int k@ = a key or token label
 *
 * Returns:	A status code (only for programming errors).
 *
 * Use:		Selects a token to be loaded.  See
 *		@NFKM_loadadminkeys_selecttokens@ for full details about
 *		labels.
 */

M_Status NFKM_loadadminkeys_selecttoken(NFKM_LoadAdminKeysHandle lakh,
					int k);

/* --- @NFKM_loadadminkeys_whichtokens@ --- *
 *
 * Arguments:	@NFKM_LoadAdminKeysHandle lakh@ = context for loading
 *
 * Returns:	A bitmap of logical tokens to be loaded.
 *
 * Use:		Discovers which logical tokens will be read in the next or
 *		current @loadtokens@ operation.
 */

NFKM_ShareFlag NFKM_loadadminkeys_whichtokens(NFKM_LoadAdminKeysHandle lakh);

/* --- @NFKM_loadadminkeys_loadtokens@ --- *
 *
 * Arguments:	@NFKM_LoadAdminKeysHandle lakh@ = context for loading
 *		@int *left@ = address at which to store cards remaining
 *
 * Returns:	A status code.
 *
 * Use:		Starts loading the necessary tokens.  It might be possible
 *		that they're all loaded already, in which case @*left@ is
 *		reset to zero on exit.
 */

M_Status NFKM_loadadminkeys_loadtokens(NFKM_LoadAdminKeysHandle lakh,
				       int *left);

/* --- @NFKM_loadadminkeys_nextcard@ --- *
 *
 * Arguments:	@NFKM_LoadAdminKeysHandle lakh@ = context for loading
 *		@const NFKM_SlotInfo *s@ = pointer to slot to read
 *		@const M_Hash *pp@ = pointer to PIN hash, or null
 *		@int *left@ = address to store number of cards remaining
 *
 * Returns:	A status code.
 *
 * Use:		Reads an admin card.
 */

M_Status NFKM_loadadminkeys_nextcard(NFKM_LoadAdminKeysHandle lakh,
				     const NFKM_SlotInfo *s,
				     const M_Hash *pp, int *left);

/* --- @NFKM_loadadminkeys_getobjects@ --- *
 *
 * Arguments:	@NFKM_LoadAdminKeysHandle lakh@ = context for loading
 *		@M_KeyID *v@ = pointer to output vector for keyids
 *		@const int *v_k@ = vector of key labels
 *		@const int *v_lt@ = vector of token labels
 *		@unsigned f@ = a bitmap of flags
 *
 * Returns:	A status code.
 *
 * Use:		Extracts objects from the admin keys context.  Logical tokens
 *		must have been loaded using the @selecttokens@, @loadtokens@
 *		and @nextcard@ interface; keys must have their protecting
 *		logical token loaded already.  The KeyIDs for the objects are
 *		stored in the array @v@ in the order of their labels in the
 *		@v_k@ and @v_it@ vectors, keys first.  The label vectors are
 *		terminated by an entry with the value @-1@.  Either @v_k@ or
 *		@v_lt@ (or both) may be null to indicate that no objects of
 *		that type should be loaded.
 *
 *		Usually, the context retains `ownership' of the objects
 *		extracted: the objects will remain available to other
 *		callers, and will be Destroyed when the context is freed.  If
 *		the flag @NFKM_LAKF_STEAL@ is set in @f@, the context will
 *		forget about the object; it will not be available to
 *		subsequent callers, nor be Destroyed automatically.  Also,
 *		note that `stealing' a logical token will prevent keys from
 *		being loaded from blobs until that token is reloaded.
 *		However, note that keys which have already been loaded but
 *		not stolen will remain available.
 *
 *		As an example, consider the case where LTR has been loaded.
 *		Two calls are made to @getobjects@: one which fetches KRE,
 *		and a second which steals the token LTR.  It is no longer
 *		possible to get KRA (because LTR is now unavailable), but
 *		further requests to get KRE will be honoured.
 *
 *		Finally, if an error occurs, the contents of the vector @v@
 *		are unspecified, and no objects will have been stolen.
 *		However, some of the requested keys may have been loaded.
 */

M_Status NFKM_loadadminkeys_getobjects(NFKM_LoadAdminKeysHandle lakh,
				       M_KeyID *v, const int *v_k,
				       const int *v_lt, unsigned f);

/* --- @NFKM_loadadminkeys_{get,steal}{key,token}@ --- *
 *
 * Arguments:	@NFKM_LoadAdminKeysHandle lakh@ = context for loading
 *		@int i@ = label for key or token
 *		@M_KeyID *k@ = address to store keyid
 *
 * Returns:	A status code.
 *
 * Use:		These are convenience functions which offer slightly simpler
 *		interfaces than @getobjects@.  The `steal' functions set the
 *		@NFKM_LAKF_STEAL@ flag, which the `get' functions do not; the
 *		`key' functions load keys whereas the `token' functions fetch
 *		logical tokens.  See @NFKM_loadadminkeys_getobjects@ for full
 *		details about the behaviour of these functions.
 *
 *		Remember that a key can't be loaded once its logical token
 *		has been stolen.  The upshot is that, if you want to steal a
 *		key and its token, you should steal the key /first/.
 */

M_Status NFKM_loadadminkeys_getkey(NFKM_LoadAdminKeysHandle lakh,
				   int i, M_KeyID *k);
M_Status NFKM_loadadminkeys_stealkey(NFKM_LoadAdminKeysHandle lakh,
				     int i, M_KeyID *k);
M_Status NFKM_loadadminkeys_gettoken(NFKM_LoadAdminKeysHandle lakh,
				     int i, M_KeyID *k);
M_Status NFKM_loadadminkeys_stealtoken(NFKM_LoadAdminKeysHandle lakh,
				       int i, M_KeyID *k);

/* --- @NFKM_loadadminkeys_done@ --- *
 *
 * Arguments:	@NFKM_LoadAdminKeysHandle lakh@ = context for loading
 *
 * Returns:	---
 *
 * Use:		Frees a key loading context.  Any keys and tokens remaining
 *		owned by the context are destroyed.
 */

void NFKM_loadadminkeys_done(NFKM_LoadAdminKeysHandle lakh);

/*----- That's all, folks -------------------------------------------------*/

#ifdef __cplusplus
  }
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nfast\inc\stdmarshal.h ===
/* Copyright (C) 1996-1998 nCipher Corporation Ltd. All rights reserved. */

#ifndef STDMARSHAL_H
#define STDMARSHAL_H

#include <assert.h>
#include <stddef.h>
#include "stdmarshaltypes.h"

/* Now our definitions -------------- */

#include "messages-a-eh.h"

#include "messages-a-free.h"
#include "messages-a-mar.h"
#include "messages-a-unmar.h"

#include "messages-a-enstr.h"
#include "messages-a-print.h"

#include "messages-a-read.h"
#include "messages-a-trans.h"

/* Error printing -------------------- */

extern int NFast_StrStatus(char *buf, int buflen, M_Status stat);
extern int NFast_StrError(char *buf, int buflen, M_Status stat,
                   const union M_Status__ErrorInfo *ei);
/* Print a message describing the status or the error into the user's
 * buffer.  No more than buflen bytes of buf will be written; the trailing
 * null will always be written.  The return value will be 0 for OK or
 * -1 for buffer overrun (message didn't fit and was truncated); illegal
 * status values are recorded as text in the buffer.
 */

extern int ncerrno_lasterror(void);
/* Returns the system error number for the last error
   (=errno on Unix, and GetLastError() on NT)
*/

/* 
 * Converts a system error number into an nCErrno.
 */
extern M_nCErrno ncerrno ( int e );

/* 
 * Fills in buf with an error string for the system error e. 
 * returns the length of the string. If buf is NULL then just returns
 * the length.
 */
extern unsigned int ncerrno_str ( int e, char *buf, unsigned int len );


/* Marshalled-hex format routines ----------- */

/* Note, if you use these, you must link against the nfast SHA1 implementation;
   this is automatically present if you use the Generic Stub */

extern int NCH_hexout( FILE *out, const char *type, const M_ByteBlock *pbb );

/* An NF_Userdata can be passed into NCH_hexin to force the use of an
 * applications malloc upcall. If ud is NULL the system malloc() will be
 * used instead.
 */
extern int NCH_hexin2( FILE *in, const char *type, M_ByteBlock *pbb,
                      FILE *errout, struct NF_UserData *ud);

/* The original definition of NCH_hexin, preserved for compatibility.
 * Same as NCH_hexin2(in,type,pbb,errout,NULL).
 */
extern int NCH_hexin( FILE *in, const char *type, M_ByteBlock *pbb,
                      FILE *errout);

/* Utility routines ------------------------- */

extern int NF_dupstring ( M_ASCIIString *dst, const char *src, struct NF_UserData *u );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nfast\inc\nfastapp.h ===
/*
*  nfastapp.h
*
*  nCipher Generic Stub library interface definitions
*
* Copyright (C) 1996-2002 nCipher Corporation Ltd. All rights reserved.
*/

#ifndef NFASTAPP_H
#define NFASTAPP_H

#include <stdlib.h>
#include <stdio.h>

/*----- Header files ------------------------------------------------------*/

#include "stdmarshal.h"


/*----- Data structures and types -----------------------------------------*/

typedef M_ClientID NFast_Client_Ident;
typedef struct NFastApp_ConnectionData *NFastApp_Connection;

/* Unless otherwise stated int functions return 0 for success
 * or a Status value for error (setting errno if it's Status_OSErrorErrno)
 */

struct NFast_Call_Context;
struct NFast_Transaction_Context;
/* Declared only; user gets to define it. */

typedef struct NFast_Application *NFast_AppHandle;


/* ---- memory allocation upcalls -------- */

/* These three must be provided by the application.  The
 * malloc/realloc may fail, in which the generic stub functions will
 * return NOMEM.  The transaction context will be NULL if no
 * specific transaction is involved.
 */
typedef void *(*NFast_MallocUpcall_t)
     (size_t sz,
      struct NFast_Call_Context *cctx,
      struct NFast_Transaction_Context *tctx);

typedef void *(*NFast_ReallocUpcall_t)
     (void *ptr, size_t sz,
      struct NFast_Call_Context *cctx,
      struct NFast_Transaction_Context *tctx);

typedef void (*NFast_FreeUpcall_t)
     (void *ptr,
      struct NFast_Call_Context *cctx,
      struct NFast_Transaction_Context *tctx);

/* ---- bignumber format upcalls --------- */

typedef int (*NFast_BignumReceiveUpcall_t)
     (struct NFast_Application *app,
      struct NFast_Call_Context *cctx,
      struct NFast_Transaction_Context *tctx,
      M_Bignum *bignum, int nbytes,
      const void *source, int msbitfirst, int mswordfirst);
/* The user code is expected to allocate memory as needed and copy
 * all the data from source into the bignum.  nbytes includes
 * padding to a 4 byte boundary.
 */

typedef int (*NFast_BignumSendLenUpcall_t)
     (struct NFast_Application *app,
      struct NFast_Call_Context *cctx,
      struct NFast_Transaction_Context *tctx,
      const M_Bignum *bignum, int *nbytes_r);
/* The user code is expected to say how may bytes of bignum there are;
 * this must include padding to a 4-byte boundary and must be >0.
 */

typedef int (*NFast_BignumSendUpcall_t)
     (struct NFast_Application *app,
      struct NFast_Call_Context *cctx,
      struct NFast_Transaction_Context *tctx,
      const M_Bignum *bignum, int nbytes,
      void *dest, int msbitfirst, int mswordfirst);
/* The user code is expected to copy the bytes from the bignum into
 * the destination.  nbytes is the value passed back by ...SendLenUpcall_t)
 * and ms{bit,word}first were determined using _BignumFormatUpcall_t).
 */

typedef void (*NFast_BignumFreeUpcall_t)
     (struct NFast_Application *app,
      struct NFast_Call_Context *cctx,
      struct NFast_Transaction_Context *tctx,
      M_Bignum *bignum);
/* The user code is expected to free the bignum if *bignum is not a NULL
 * pointer, and then to set *bignum to NULL.
 */

typedef int (*NFast_BignumFormatUpcall_t)
     (struct NFast_Application *app,
      struct NFast_Call_Context *cctx,
      struct NFast_Transaction_Context *tctx,
      int *msbitfirst_io, int *mswordfirst_io);
/* This is called during the submit to find out what the bignum
 * format ought to be for this request.  msbitfirst_io is initialised to
 * the native format and mswordfirst_io to 0; the user is expected to
 * update them as appropriate and return Status_OK.
 */

/* Return values for ...Bignum...Upcall must be Status values whose ErrorInfo
 * is empty.  Status_OK (0) means all went well.
 */

/* These functions return Status values whose ErrorInfo is empty;
 * they may use OSErrorErrno */

/* ---- transport upcalls ---------------- */

struct SysConnData;

typedef int (*NFast_TransportConnectUpcall_t)
     (struct NFast_Application *app, struct SysConnData **sysc_r,
      int debuglevel, int priv, struct NFast_Call_Context *cctx, FILE **debugfile_r);

typedef int (*NFast_TransportDisconnectUpcall_t)
     (struct NFast_Application *app, struct SysConnData *sysc, FILE *debugfile,
      struct NFast_Call_Context *cctx);

typedef void (*NFast_TransportBreakUpcall_t)
     (struct NFast_Application *app, struct SysConnData *sysc,
      struct NFast_Call_Context *cctx, struct NFast_Transaction_Context *tctx);

/* Just this next one returns 0 or 1. */
typedef int (*NFast_TransportBrokenUpcall_t)
     (struct NFast_Application *app, struct SysConnData *sysc,
      struct NFast_Call_Context *cctx, struct NFast_Transaction_Context *tctx);

typedef int (*NFast_TransportSendUpcall_t)
     (struct NFast_Application *app, struct SysConnData *sysc,
      unsigned char *buf, int len,
      struct NFast_Call_Context *cctx, struct NFast_Transaction_Context *tctx);

typedef int (*NFast_TransportReceiveUpcall_t)
     (struct NFast_Application *app, struct SysConnData *sysc,
      int nonblocking,
      struct NFast_Call_Context *cctx, struct NFast_Transaction_Context *tctx,
      unsigned char **buf_r, int *len_r);

/* Just this next one is not allowed to fail. */
typedef void (*NFast_TransportReceivedoneUpcall_t)
     (struct NFast_Application *app, struct SysConnData *sysc,
      struct NFast_Call_Context *cctx, struct NFast_Transaction_Context *tctx);


/* --- Thread synchronization upcalls --- */

typedef struct NFast_MutexStruct *NFast_Mutex;
typedef struct NFast_CondStruct *NFast_Cond;

typedef int (*NFast_MutexCreateUpcall)
     (struct NFast_Application *a, NFast_Mutex *m,
      struct NFast_Call_Context *cc);
typedef void (*NFast_MutexDestroyUpcall)
     (struct NFast_Application *a, NFast_Mutex m,
      struct NFast_Call_Context *cc);
typedef int (*NFast_MutexLockUpcall)
     (struct NFast_Application *a, NFast_Mutex m,
      struct NFast_Call_Context *cc);
typedef void (*NFast_MutexUnlockUpcall)
     (struct NFast_Application *a, NFast_Mutex m,
      struct NFast_Call_Context *cc);

typedef int (*NFast_CondCreateUpcall)
     (struct NFast_Application *a, NFast_Cond *c,
      struct NFast_Call_Context *cc);
typedef void (*NFast_CondDestroyUpcall)
     (struct NFast_Application *a, NFast_Cond c,
      struct NFast_Call_Context *cc);
typedef int (*NFast_CondWaitUpcall)
     (struct NFast_Application *a, NFast_Cond c, NFast_Mutex m,
      struct NFast_Call_Context *cc);
typedef int (*NFast_CondSignalUpcall)
     (struct NFast_Application *a, NFast_Cond c,
      struct NFast_Call_Context *cc);
typedef int (*NFast_CondBroadcastUpcall)
     (struct NFast_Application *a, NFast_Cond c,
      struct NFast_Call_Context *cc);


/*----- Functions ---------------------------------------------------------*/


int NFastApp_Init(NFast_AppHandle *handle_out,
                  NFast_MallocUpcall_t mallocupcall,
                  NFast_ReallocUpcall_t reallocupcall,
                  NFast_FreeUpcall_t freeupcall,
                  struct NFast_Call_Context *cctx);

void NFastApp_Finish(NFast_AppHandle handle,
                     struct NFast_Call_Context *cctx);
/* You may not call NFast_DestroyApp with any connections open. */

int NFastApp_Clone(NFast_AppHandle handle_in, NFast_AppHandle *handle_out,
		   NFast_MallocUpcall_t mallocupcall,
		   NFast_ReallocUpcall_t reallocupcall,
		   NFast_FreeUpcall_t freeupcall,
		   struct NFast_Call_Context *cctx);
/* If you pass 0 for malloc, realloc and free upcalls they are
 * inherited.  The new AppHandle has no connections open (but if
 * the original had a ClientID already then so will this one,
 * and it will be the same - so you'd better open some connections
 * before the old application closes its last one).
 */

int NFastApp_GetMallocUpcalls(NFast_AppHandle handle,
                              NFast_MallocUpcall_t *mallocupcall,
                              NFast_ReallocUpcall_t *reallocupcall,
                              NFast_FreeUpcall_t *freeupcall);

/* These functions are just like malloc, but they do not set errno. */
void *NFastApp_Malloc(NFast_AppHandle app,
                      size_t sz,
                      struct NFast_Call_Context *cctx,
                      struct NFast_Transaction_Context *tctx);

void *NFastApp_Realloc(NFast_AppHandle app,
                       void *ptr, size_t sz,
                       struct NFast_Call_Context *cctx,
                       struct NFast_Transaction_Context *tctx);

void NFastApp_Free(NFast_AppHandle app, void *ptr,
                   struct NFast_Call_Context *cctx,
                   struct NFast_Transaction_Context *tctx);

extern struct NF_UserData *NFastApp_AllocUD(
	struct NFast_Application *app,
	struct NFast_Call_Context *cctx,
	struct NFast_Transaction_Context *tctx,
	unsigned flags );
#define USERDATA_DEVICEFMT	0
#define USERDATA_LOCALFMT	1

extern void NFastApp_FreeUD( struct NF_UserData *u );

int NFastApp_SetClientIdent(NFast_AppHandle app,
                            const NFast_Client_Ident *cid,
                            struct NFast_Call_Context *cctx);
int NFastApp_GetClientIdent(NFast_AppHandle app,
                            NFast_Client_Ident *cid,
                            struct NFast_Call_Context *cctx);
/* All calls to NFast_Connect will have the same client id, and
 * access to the same keys &c.  The NFast_Client_Ident can be copied
 * using memcpy, read and written using fread/fwrite, &c - its byte
 * image is sufficient to use it.  NFast_GetIdent can fail (for
 * example, if no connections have been opened or client ID set).
 * When no connections are open any more using a particular ident it
 * is garbage collected and all its objects in the server and module
 * discarded.
 * If this isn't set then the first call to NFast_Connect sets it
 * implicitly, so later calls share the id.
 */

int NFastApp_Transact(NFastApp_Connection conn,
                      struct NFast_Call_Context *cctx,
                      const M_Command *command,
                      M_Reply *reply,
                      struct NFast_Transaction_Context *tctx);
/* Synchronous transaction; may be mixed with asynch transactions. */

int NFastApp_Submit(NFastApp_Connection conn,
                    struct NFast_Call_Context *cctx,
                    const M_Command *command,
                    M_Reply *reply,
                    struct NFast_Transaction_Context *tctx);
/* The M_Reply* must be unique; it is used to identify the transaction. */

int NFastApp_Query(NFastApp_Connection conn,
                   struct NFast_Call_Context *cctx,
                   M_Reply **replyp,
                   struct NFast_Transaction_Context **tctx_r);
int NFastApp_Wait(NFastApp_Connection conn,
                  struct NFast_Call_Context *cctx,
                  M_Reply **replyp,
                  struct NFast_Transaction_Context **tctx_r);
/* In both cases replyp _must_ be non-NULL.  If *replyp is NULL
 * NFastApp_Query or NFastApp_Wait will be satisfied with any returned
 * reply, and *replyp will be changed to point to the that reply.  If
 * *replyp is not NULL then they will only be satisfied by the reply
 * in question; other replies will be queued internally.
 *
 * ctx_r may be NULL; if it isn't then the ctx used when submitting
 * the reply will be stored in *ctx_r.
 *
 * NFastApp_Query checks whether the/an appropriate reply has come back
 * yet; NFast_Wait waits for the/an appropriate reply.
 *
 * NFastApp_Query and NFastApp_Wait can return, as well as the usual return
 * values, TransactionNotFound if there are no outstanding appropriate
 * requests.  NFastApp_Query returns TransactionNotYetComplete if there
 * were outstanding requests but none of the replies have come back
 * yet.
 */

int NFastApp_SetBignumUpcalls(NFast_AppHandle app,
                              NFast_BignumReceiveUpcall_t bignumreceiveupcall,
                              NFast_BignumSendLenUpcall_t bignumsendlenupcall,
                              NFast_BignumSendUpcall_t bignumsendupcall,
                              NFast_BignumFreeUpcall_t bignumfreeupcall,
                              NFast_BignumFormatUpcall_t bignumformatupcall,
                              struct NFast_Call_Context *cctx);

int NFastApp_GetBignumUpcalls(NFast_AppHandle app,
                              NFast_BignumReceiveUpcall_t *bignumreceiveupcall,
                              NFast_BignumSendLenUpcall_t *bignumsendlenupcall,
                              NFast_BignumSendUpcall_t *bignumsendupcall,
                              NFast_BignumFreeUpcall_t *bignumfreeupcall,
                              NFast_BignumFormatUpcall_t *bignumformatupcall,
                              struct NFast_Call_Context *cctx);

int NFastApp_SetTransportUpcalls(NFast_AppHandle app,
                                 NFast_TransportConnectUpcall_t connectupcall,
                                 NFast_TransportDisconnectUpcall_t disconnectupcall,
                                 NFast_TransportBreakUpcall_t breakupcall,
                                 NFast_TransportBrokenUpcall_t brokenupcall,
                                 NFast_TransportSendUpcall_t sendupcall,
                                 NFast_TransportReceiveUpcall_t receiveupcall,
                                 NFast_TransportReceivedoneUpcall_t receiveupdonecall,
                                 struct NFast_Call_Context *cctx);

int NFastApp_SetThreadUpcalls(NFast_AppHandle app,
			      NFast_MutexCreateUpcall mutexcreateupcall,
			      NFast_MutexDestroyUpcall mutexdestroyupcall,
			      NFast_MutexLockUpcall mutexlockupcall,
			      NFast_MutexUnlockUpcall mutexunlockupcall,
			      NFast_CondCreateUpcall condcreateupcall,
			      NFast_CondDestroyUpcall conddestroyupcall,
			      NFast_CondWaitUpcall condwaitupcall,
			      NFast_CondSignalUpcall condsignalupcall,
			      NFast_CondBroadcastUpcall condbroadcastupcall,
			      struct NFast_Call_Context *cc);

int NFastApp_Connect(NFast_AppHandle app, NFastApp_Connection *conn_r,
                     uint32 flags, struct NFast_Call_Context *cctx);

#define NFastApp_ConnectionFlags_Privileged     0x01
#define NFastApp_ConnectionFlags_NoClientID     0x02
#define NFastApp_ConnectionFlags_ForceClientID  0x04

int NFastApp_Disconnect(NFastApp_Connection conn, struct NFast_Call_Context *cctx);
/* If NFastApp_Disconnect gives an error the connection _has_
 * been closed, but some error was detected.
 */

void NFastApp_Free_Command(struct NFast_Application *app,
                           struct NFast_Call_Context *cctx,
                           struct NFast_Transaction_Context *tctx,
                           M_Command *command);
void NFastApp_Free_Reply(struct NFast_Application *app,
                         struct NFast_Call_Context *cctx,
                         struct NFast_Transaction_Context *tctx,
                         M_Reply *reply);

void NFast_Perror(const char *msg, M_Status stat);

NFAST_TRANSPORTHANDLE_TYPE NFastApp_GetTransportHandle(NFastApp_Connection conn);
/* Can be used in select(2) on UNIX and similar calls elsewhere.
 * Always succeeds.
 */

int NFastApp_Expected_Reply(struct NFast_Application *app,
                            struct NFast_Call_Context *cctx,
                            char *buf, int buflen,
                            M_Reply *reply, M_Cmd cmd,
                            struct NFast_Transaction_Context *tctx);
/* Checks that reply is an OK reply with reply.cmd==cmd; if not,
 * calls NFastApp_Free_Reply on reply, fills buf (as for NFast_StrStatus)
 * with an error message, and returns 0 or -1.  Returns >0 if reply is OK.
 */

extern int NFast_BuildCmdCert(struct NFast_Application *app,
                              struct NFast_Call_Context *cctx,
                              struct NFast_Transaction_Context *tctx,
                              const M_CertSignMessage *msg,
                              M_ByteBlock *cert_out,
                              M_Hash *certhash_out );

/* Used to create a certificate for a command, in the format required by the
   module. The details in 'msg' are marshalled into a byte block format, 
   which is allocated using the malloc upcalls and placed in 'cert_out'.
   The SHA-1 hash of this is calculated and placed in certhash_out, if 
   this pointer is not NULL.

   The 'header' and 'footer' members of 'msg' must have been set to
   MagicValue_CertMsgHeader and MagicValue_CertMsgFooter respectively */

int NFast_MarshalCertificate (struct NFast_Application *app,
			    struct NFast_Call_Context *cctx,
			    struct NFast_Transaction_Context *tctx,
			    const M_Certificate *src,
			    M_ByteBlock *mc_out);
/* once you have signed the message built by BuildCmdCert above, you
   can serialise the whole thing with this call and store it safely
   somewhere. */

int NFast_MarshalCertificateList (struct NFast_Application *app,
			    struct NFast_Call_Context *cctx,
			    struct NFast_Transaction_Context *tctx,
			    const M_CertificateList *src,
			    M_ByteBlock *mc_out);
/* As above, but for an M_CertificateList instead of an M_Certificate */

int NFast_UnmarshalCertificate (struct NFast_Application *app,
			    struct NFast_Call_Context *cctx,
			    struct NFast_Transaction_Context *tctx,
			    const unsigned char *buf, int len,
			    M_Certificate *mc);
/* Turns a serialised signed certificate built by NFast_MarshalCertificate
   into an M_Certificate again, for putting in a command */

int NFast_UnmarshalCertificateList (struct NFast_Application *app,
			    struct NFast_Call_Context *cctx,
			    struct NFast_Transaction_Context *tctx,
			    const unsigned char *buf, int len,
			    M_CertificateList *mc);
/* As above, but for an M_CertificateList instead of an M_Certificate */

extern void NFast_Hash( const unsigned char *ptr, int len,
			M_Hash *hash_out );
/* Creates a hash of the given bytes, using SHA-1 */

extern void NFastApp_Free_CertSignMessage(struct NFast_Application *app,
					  struct NFast_Call_Context *cctx,
					  struct NFast_Transaction_Context *tctx,
					  M_CertSignMessage *csm);
/* Frees the (somewhat complex) CertSignMessage structure; useful for freeing one
   you have constructed and just passed to _BuildCmdCert */



extern int NFastApp_MarshalACL(struct NFast_Application *app,
                     struct NFast_Call_Context *cctx,
                     struct NFast_Transaction_Context *tctx,
                     const M_ACL *pACL,
                     M_ByteBlock *blk_out );

/* Used to turn an M_ACL structure into a byte block, suitable for
   importing as a template key.

   Important note: Although ACLs do not at present contain any 
   M_Bignums, they may do so at some point in the future. When marshalling
   an ACL for use in a template key, the bignumber format is fixed as
   module internal format (LSB first, LS word first), because the bignumbers
   contained in such a key must have a unique interpretation. Otherwise the
   key hash would not identify a unique template key with a unique meaning.
   So this function does not call the NFast_BignumFormatUpcall before
   attempting to send bignumbers.

   Therefore, if you call this function in your program, the 
   NFast_BignumSendUpcall function you supply *MUST* either cope correctly
   with the msbitfirst and mswordfirst parameters being 0, or fail an assertion
   or return an error code. It should not silently ignore them!

   The value of blk_out on call is ignored.  In case of error it will
   be freed if any memory in it was allocated; if _MarshalACL succeeds
   the caller must free blk_out->ptr.
*/

extern void NFastApp_FreeACL( struct NFast_Application *app,
                         struct NFast_Call_Context *cctx,
                         struct NFast_Transaction_Context *tctx,
                         M_ACL *acl);
/* Frees the (somewhat complex) ACL structure; useful for freeing an
   ACL you have constructed and just passed to NFastApp_MarshalACL */


#define NFast_ExamineBlob_flags_km_required   0x001
#define NFast_ExamineBlob_flags_kt_required   0x002
#define NFast_ExamineBlob_flags_kr_required   0x004

typedef struct {
  M_BlobFormat format;
  M_Word flags;
  M_KMHash hkm;
  M_TokenHash hkt;
  M_KeyHash hkr;
} NFast_ExamineBlob_Info;

int NFast_ExamineBlob(struct NFast_Application *app,
                      struct NFast_Call_Context *cctx,
                      struct NFast_Transaction_Context *tctx,
                      const unsigned char *data, int len,
                      NFast_ExamineBlob_Info *info_r);

int NFastApp_ExamineModCert(struct NFast_Application *app,
			    struct NFast_Call_Context *cctx,
			    struct NFast_Transaction_Context *tctx,
			    const unsigned char *data, int len,
			    M_ModCertMsg *mc);

/* Some other useful freeing functions */

extern void NFastApp_Free_KeyData(struct NFast_Application *app,
				  struct NFast_Call_Context *cctx,
				  struct NFast_Transaction_Context *tctx,
				  M_KeyData *csm);
extern void NFastApp_Free_CipherText(struct NFast_Application *app,
				     struct NFast_Call_Context *cctx,
				     struct NFast_Transaction_Context *tctx,
				     M_CipherText *csm);
extern void NFastApp_Free_ModCertMsg(struct NFast_Application *app,
				     struct NFast_Call_Context *cctx,
				     struct NFast_Transaction_Context *tctx,
				     M_ModCertMsg *csm);
extern void NFastApp_Free_CertificateList(struct NFast_Application *app,
					  struct NFast_Call_Context *cctx,
					  struct NFast_Transaction_Context *tctx,
					  M_CertificateList *csm);

extern const char *const NFast_VersionString;


/* Structure to accomodate sar file info function */
typedef struct _sarfileinfo {
  M_Hash sarfilehash;   /* SHA-1 hash of the payload */
  long imagesize;       /* size (bytes) of the payload */
  int ncerts;           /* number of certificates present */
  M_SEECertData *certs; /* all certificates present, in order */
} sarfileinfo, NFast_sarfile_info;

/* Examines the sar file in `sardata' and returns basic information about it.
 * `sinfo' should be owned by the caller; call NFastApp_FreeSarFileInfo()
 * to free it. */
extern M_Status NFastApp_GetSarFileInfo(struct NFast_Application *app,
                         struct NFast_Call_Context *cctx,
                         struct NFast_Transaction_Context *tctx,
                         const M_ByteBlock * const sardata,
                         NFast_sarfile_info *sinfo);

/* When finished with a `sarfileinfo', this function frees any
 * ancillary data it may contain. This function also zeroes the
 * structure's direct contents. */
extern void NFastApp_FreeSarFileInfo(struct NFast_Application *app,
                         NFast_sarfile_info *sinfo,
                         struct NFast_Call_Context *cctx,
                         struct NFast_Transaction_Context *tctx);

/* DEPRECATED:
 * This is an older version of NFastApp_GetSarFileInfo(). */
extern int NFast_GetSarFileInfo(struct NFast_Application *app,
                         struct NFast_Call_Context *cctx,
                         struct NFast_Transaction_Context *tctx,
                         const M_ByteBlock * const sardata,
                         sarfileinfo *sinfo);

/* DEPRECATED:
 * This older version of NFastApp_FreeSarFileInfo() used the `free'
 * function to free its contents, no matter what allocated it.
 * You should probably use NFastApp_FreeSarFileInfo() instead.
 */
extern void NFast_FreeSarFileInfo(const sarfileinfo *sinfo);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nfast\inc\stdmarshaltypes.h ===
/* Copyright (C) 1996-1998 nCipher Corporation Ltd. All rights reserved. */

#ifndef STDMARSHALTYPES_H
#define STDMARSHALTYPES_H

#ifdef NFAST_CONF_H  /* Override settings */
#  include NFAST_CONF_H
#else
#  ifdef NF_CROSSCC   /* General cross-compilation config */
#    include "nfast-conf-crosscc.h"
#  else               /* Autoconf or similar */
#    include "nfast-conf-auto.h"
#  endif
#endif

#define MAX_DEVICE_WRITE 8192	/* Maximum length to be passed to device in a write */
#define MAX_DEVICE_READ  8192	/* Maximum length to be returned from device in a read */
	/* For a device this usually includes a length word at the start of each job plus a
		terminating zero word */

#define MAX_CLIENT_WRITE 8192	/* Maximum length to be submitted by client down pipe/socket */
#define MAX_CLIENT_READ  8192	/* Maximum length to be returned to client up pipe/socket */
	/* For a client this includes the length word sent at the start of each job */


/* Essential types ----------------- */

#define MARSHERR_MALLOCFAIL NOMEM
typedef uint32 M_Word;

typedef M_Word M_Tag;
typedef M_Word M_KeyID;
typedef M_Word M_ModuleID;
typedef M_Word M_SlotID;

typedef int M_MustBeZeroWord;

typedef struct NFast_Bignum *M_Bignum;

typedef struct {
  M_Word len;
  unsigned char *ptr;
} M_ByteBlock;

typedef struct {
  char *ptr;
} M_ASCIIString;


/* Definitions --------------------- */

#include "messages-a-en.h"
#include "messages-a-im.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nfast\inc\stdread.h ===
/*
*  STDREAD.H - was localread.h
*            - standard routines for reading things in (a la trial)
*
*   Copyright (C) 1996-1998 nCipher Corporation Ltd.
*   All rights reserved.  Company Confidential.
*/

#ifndef STDREAD_H
#define STDREAD_H

/* 'Read' Routines additions to standard marshalling library ----------------- */

#define MAXBIGNUMBYTES 8192

/* Internal status values
 * If Status_Malformed returned by read, then look at *emsg
 * (initialised to `syntax error').
 */
#define STATUS_MISMATCH -12
#define STATUS_ASTERISK -13


struct NF_StdReadContext {
  FILE *promptto;
  int lineno;
  const char *emsg;
  int blocksize;
};

extern struct NF_StdReadContext *NFast_GetStdReadContext ( struct NF_UserData *u );
/* This must be supplied by the user. Must not return NULL. */

void readfailure(NF_Read_Context *rc, int r, const char *where);
int initread(NF_Read_Context *rc, struct NF_UserData *u,
            int lineno, const char *toplevel, FILE *file, FILE *promptto, int compare);

int lexhexdump(NF_Read_Context *rc, int indent,
               int *nbytesp, unsigned char **data, int round);
int lexmalformed(NF_Read_Context *rc, int c, const char *emsg);
int lexaddprompt(NF_Read_Context *rc, const char *string);
int lexword(NF_Read_Context *rc, char *buf, int size);
int lexautonewline(NF_Read_Context *rc);
int lexquotedstring(NF_Read_Context *rc, char *buf, int size);
int lexjunknewline(NF_Read_Context *rc);

extern const NF_ValInfo NF_YesNo_enumtable[];

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.2.8\samples\cpp-sample\AssemblyInfo.cpp ===
#include "stdafx.h"

using namespace System::Reflection;
using namespace System::Runtime::CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitleAttribute("")];
[assembly:AssemblyDescriptionAttribute("")];
[assembly:AssemblyConfigurationAttribute("")];
[assembly:AssemblyCompanyAttribute("")];
[assembly:AssemblyProductAttribute("")];
[assembly:AssemblyCopyrightAttribute("")];
[assembly:AssemblyTrademarkAttribute("")];
[assembly:AssemblyCultureAttribute("")];		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersionAttribute("2.2.0.0")];

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//        When specifying the KeyFile, the location of the KeyFile should be
//        relative to the project directory.
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly:AssemblyDelaySignAttribute(false)];
[assembly:AssemblyKeyFileAttribute("")];
[assembly:AssemblyKeyNameAttribute("")];
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.2.8\samples\cpp-sample\cppsample.cpp ===
/************************************************************************************
'
' Copyright  2002 James W. Newkirk, Michael C. Two, Alexei A. Vorontsov
' Copyright  2000-2002 Philip A. Craig
'
' This software is provided 'as-is', without any express or implied warranty. In no 
' event will the authors be held liable for any damages arising from the use of this 
' software.
' 
' Permission is granted to anyone to use this software for any purpose, including 
' commercial applications, and to alter it and redistribute it freely, subject to the 
' following restrictions:
'
' 1. The origin of this software must not be misrepresented; you must not claim that 
' you wrote the original software. If you use this software in a product, an 
' acknowledgment (see the following) in the product documentation is required.
'
' Portions Copyright  2002 James W. Newkirk, Michael C. Two, Alexei A. Vorontsov 
' or Copyright  2000-2002 Philip A. Craig
'
' 2. Altered source versions must be plainly marked as such, and must not be 
' misrepresented as being the original software.
'
' 3. This notice may not be removed or altered from any source distribution.
'
'***********************************************************************************/

#include "stdafx.h"

#include "cppsample.h"

namespace NUnitSamples {

	void SimpleCPPSample::Init() {
		fValue1 = 2;
		fValue2 = 3;
	}

	void SimpleCPPSample::Add() {
		int result = fValue1 + fValue2;
		Assert::AreEqual(6,result);
	}

	void SimpleCPPSample::DivideByZero()
	{
		int zero= 0;
		int result= 8/zero;
	}

	void SimpleCPPSample::Equals() {
		Assert::AreEqual(12, 12, "Integer");
		Assert::AreEqual(12L, 12L, "Long");
		Assert::AreEqual('a', 'a', "Char");


		Assert::AreEqual(12, 13, "Expected Failure (Integer)");
		Assert::AreEqual(12.0, 11.99, 0.0, "Expected Failure (Double)");
	}

	void SimpleCPPSample::IgnoredTest()
	{
		throw new InvalidCastException();
	}

	void SimpleCPPSample::ExpectAnException()
	{
		throw new InvalidCastException();
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.2.8\samples\cpp-sample\Stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
// cpp-sample.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.2.8\samples\cpp-sample\cppsample.h ===
/************************************************************************************
'
' Copyright  2002 James W. Newkirk, Michael C. Two, Alexei A. Vorontsov
' Copyright  2000-2002 Philip A. Craig
'
' This software is provided 'as-is', without any express or implied warranty. In no 
' event will the authors be held liable for any damages arising from the use of this 
' software.
' 
' Permission is granted to anyone to use this software for any purpose, including 
' commercial applications, and to alter it and redistribute it freely, subject to the 
' following restrictions:
'
' 1. The origin of this software must not be misrepresented; you must not claim that 
' you wrote the original software. If you use this software in a product, an 
' acknowledgment (see the following) in the product documentation is required.
'
' Portions Copyright  2002 James W. Newkirk, Michael C. Two, Alexei A. Vorontsov 
' or Copyright  2000-2002 Philip A. Craig
'
' 2. Altered source versions must be plainly marked as such, and must not be 
' misrepresented as being the original software.
'
' 3. This notice may not be removed or altered from any source distribution.
'
'***********************************************************************************/

#pragma once

using namespace System;
using namespace NUnit::Framework;

namespace NUnitSamples
{
	[TestFixture]
	public __gc class SimpleCPPSample
	{
		int fValue1;
		int fValue2;
	public:
		[SetUp] void Init();

		[Test] void Add();
		[Test] void DivideByZero();
		[Test] void Equals();
		[Test] [Ignore("ignored test")] void IgnoredTest();
		[Test] [ExpectedException(__typeof(InvalidOperationException))] void ExpectAnException();
	};
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.2.8\samples\cpp-sample\Stdafx.h ===
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently,
// but are changed infrequently

#pragma once

#using <mscorlib.dll>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.2.8\samples\csharp\money\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("2.2.0.0")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.2.8\samples\csharp\money\MoneyBag.cs ===
#region Copyright (c) 2002, James W. Newkirk, Michael C. Two, Alexei A. Vorontsov, Philip A. Craig
/************************************************************************************
'
' Copyright  2002 James W. Newkirk, Michael C. Two, Alexei A. Vorontsov
' Copyright  2000-2002 Philip A. Craig
'
' This software is provided 'as-is', without any express or implied warranty. In no 
' event will the authors be held liable for any damages arising from the use of this 
' software.
' 
' Permission is granted to anyone to use this software for any purpose, including 
' commercial applications, and to alter it and redistribute it freely, subject to the 
' following restrictions:
'
' 1. The origin of this software must not be misrepresented; you must not claim that 
' you wrote the original software. If you use this software in a product, an 
' acknowledgment (see the following) in the product documentation is required.
'
' Portions Copyright  2002 James W. Newkirk, Michael C. Two, Alexei A. Vorontsov 
' or Copyright  2000-2002 Philip A. Craig
'
' 2. Altered source versions must be plainly marked as such, and must not be 
' misrepresented as being the original software.
'
' 3. This notice may not be removed or altered from any source distribution.
'
'***********************************************************************************/
#endregion

namespace NUnit.Samples.Money 
{

	using System;
	using System.Collections;
	using System.Text;

	/// <summary>A MoneyBag defers exchange rate conversions.</summary>
	/// <remarks>For example adding 
	/// 12 Swiss Francs to 14 US Dollars is represented as a bag 
	/// containing the two Monies 12 CHF and 14 USD. Adding another
	/// 10 Swiss francs gives a bag with 22 CHF and 14 USD. Due to 
	/// the deferred exchange rate conversion we can later value a 
	/// MoneyBag with different exchange rates.
	///
	/// A MoneyBag is represented as a list of Monies and provides 
	/// different constructors to create a MoneyBag.</remarks>
	class MoneyBag: IMoney 
	{
		private ArrayList fMonies= new ArrayList(5);

		private MoneyBag() 
		{
		}
		public MoneyBag(Money[] bag) 
		{
			for (int i= 0; i < bag.Length; i++) 
			{
				if (!bag[i].IsZero)
					AppendMoney(bag[i]);
			}
		}
		public MoneyBag(Money m1, Money m2) 
		{
			AppendMoney(m1);
			AppendMoney(m2);
		}
		public MoneyBag(Money m, MoneyBag bag) 
		{
			AppendMoney(m);
			AppendBag(bag);
		}
		public MoneyBag(MoneyBag m1, MoneyBag m2) 
		{
			AppendBag(m1);
			AppendBag(m2);
		}
		public IMoney Add(IMoney m) 
		{
			return m.AddMoneyBag(this);
		}
		public IMoney AddMoney(Money m) 
		{
			return (new MoneyBag(m, this)).Simplify();
		}
		public IMoney AddMoneyBag(MoneyBag s) 
		{
			return (new MoneyBag(s, this)).Simplify();
		}
		private void AppendBag(MoneyBag aBag) 
		{
			foreach (Money m in aBag.fMonies)
				AppendMoney(m);
		}
		private void AppendMoney(Money aMoney) 
		{
			IMoney old= FindMoney(aMoney.Currency);
			if (old == null) 
			{
				fMonies.Add(aMoney);
				return;
			}
			fMonies.Remove(old);
			IMoney sum= old.Add(aMoney);
			if (sum.IsZero) 
				return;
			fMonies.Add(sum);
		}
		private bool Contains(Money aMoney) 
		{
			Money m= FindMoney(aMoney.Currency);
			return m.Amount == aMoney.Amount;
		}
		public override bool Equals(Object anObject) 
		{
			if (IsZero)
				if (anObject is IMoney)
					return ((IMoney)anObject).IsZero;
            
			if (anObject is MoneyBag) 
			{
				MoneyBag aMoneyBag= (MoneyBag)anObject;
				if (aMoneyBag.fMonies.Count != fMonies.Count)
					return false;
                
				foreach (Money m in fMonies) 
				{
					if (!aMoneyBag.Contains(m))
						return false;
				}
				return true;
			}
			return false;
		}
		private Money FindMoney(String currency) 
		{
			foreach (Money m in fMonies) 
			{
				if (m.Currency.Equals(currency))
					return m;
			}
			return null;
		}
		public override int GetHashCode() 
		{
			int hash= 0;
			foreach (Money m in fMonies) 
			{
				hash^= m.GetHashCode();
			}
			return hash;
		}
		public bool IsZero 
		{
			get { return fMonies.Count == 0; }
		}
		public IMoney Multiply(int factor) 
		{
			MoneyBag result= new MoneyBag();
			if (factor != 0) 
			{
				foreach (Money m in fMonies) 
				{
					result.AppendMoney((Money)m.Multiply(factor));
				}
			}
			return result;
		}
		public IMoney Negate() 
		{
			MoneyBag result= new MoneyBag();
			foreach (Money m in fMonies) 
			{
				result.AppendMoney((Money)m.Negate());
			}
			return result;
		}
		private IMoney Simplify() 
		{
			if (fMonies.Count == 1)
				return (IMoney)fMonies[0];
			return this;
		}
		public IMoney Subtract(IMoney m) 
		{
			return Add(m.Negate());
		}
		public override String ToString() 
		{
			StringBuilder buffer = new StringBuilder();
			buffer.Append("{");
			foreach (Money m in fMonies)
				buffer.Append(m);
			buffer.Append("}");
			return buffer.ToString();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.2.8\samples\csharp\money\Money.cs ===
#region Copyright (c) 2002, James W. Newkirk, Michael C. Two, Alexei A. Vorontsov, Philip A. Craig
/************************************************************************************
'
' Copyright  2002 James W. Newkirk, Michael C. Two, Alexei A. Vorontsov
' Copyright  2000-2002 Philip A. Craig
'
' This software is provided 'as-is', without any express or implied warranty. In no 
' event will the authors be held liable for any damages arising from the use of this 
' software.
' 
' Permission is granted to anyone to use this software for any purpose, including 
' commercial applications, and to alter it and redistribute it freely, subject to the 
' following restrictions:
'
' 1. The origin of this software must not be misrepresented; you must not claim that 
' you wrote the original software. If you use this software in a product, an 
' acknowledgment (see the following) in the product documentation is required.
'
' Portions Copyright  2002 James W. Newkirk, Michael C. Two, Alexei A. Vorontsov 
' or Copyright  2000-2002 Philip A. Craig
'
' 2. Altered source versions must be plainly marked as such, and must not be 
' misrepresented as being the original software.
'
' 3. This notice may not be removed or altered from any source distribution.
'
'***********************************************************************************/
#endregion

namespace NUnit.Samples.Money 
{

	using System;
	using System.Text;

	/// <summary>A simple Money.</summary>
	class Money: IMoney 
	{

		private int fAmount;
		private String fCurrency;
        
		/// <summary>Constructs a money from the given amount and
		/// currency.</summary>
		public Money(int amount, String currency) 
		{
			fAmount= amount;
			fCurrency= currency;
		}

		/// <summary>Adds a money to this money. Forwards the request to
		/// the AddMoney helper.</summary>
		public IMoney Add(IMoney m) 
		{
			return m.AddMoney(this);
		}

		public IMoney AddMoney(Money m) 
		{
			if (m.Currency.Equals(Currency) )
				return new Money(Amount+m.Amount, Currency);
			return new MoneyBag(this, m);
		}

		public IMoney AddMoneyBag(MoneyBag s) 
		{
			return s.AddMoney(this);
		}

		public int Amount 
		{
			get { return fAmount; }
		}

		public String Currency 
		{
			get { return fCurrency; }
		}

		public override bool Equals(Object anObject) 
		{
			if (IsZero)
				if (anObject is IMoney)
					return ((IMoney)anObject).IsZero;
			if (anObject is Money) 
			{
				Money aMoney= (Money)anObject;
				return aMoney.Currency.Equals(Currency)
					&& Amount == aMoney.Amount;
			}
			return false;
		}

		public override int GetHashCode() 
		{
			return fCurrency.GetHashCode()+fAmount;
		}

		public bool IsZero 
		{
			get { return Amount == 0; }
		}

		public IMoney Multiply(int factor) 
		{
			return new Money(Amount*factor, Currency);
		}

		public IMoney Negate() 
		{
			return new Money(-Amount, Currency);
		}

		public IMoney Subtract(IMoney m) 
		{
			return Add(m.Negate());
		}

		public override String ToString() 
		{
			StringBuilder buffer = new StringBuilder();
			buffer.Append("["+Amount+" "+Currency+"]");
			return buffer.ToString();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.2.8\samples\csharp\money\IMoney.cs ===
#region Copyright (c) 2002, James W. Newkirk, Michael C. Two, Alexei A. Vorontsov, Philip A. Craig
/************************************************************************************
'
' Copyright  2002 James W. Newkirk, Michael C. Two, Alexei A. Vorontsov
' Copyright  2000-2002 Philip A. Craig
'
' This software is provided 'as-is', without any express or implied warranty. In no 
' event will the authors be held liable for any damages arising from the use of this 
' software.
' 
' Permission is granted to anyone to use this software for any purpose, including 
' commercial applications, and to alter it and redistribute it freely, subject to the 
' following restrictions:
'
' 1. The origin of this software must not be misrepresented; you must not claim that 
' you wrote the original software. If you use this software in a product, an 
' acknowledgment (see the following) in the product documentation is required.
'
' Portions Copyright  2002 James W. Newkirk, Michael C. Two, Alexei A. Vorontsov 
' or Copyright  2000-2002 Philip A. Craig
'
' 2. Altered source versions must be plainly marked as such, and must not be 
' misrepresented as being the original software.
'
' 3. This notice may not be removed or altered from any source distribution.
'
'***********************************************************************************/
#endregion

namespace NUnit.Samples.Money 
{

	/// <summary>The common interface for simple Monies and MoneyBags.</summary>
	interface IMoney 
	{

		/// <summary>Adds a money to this money.</summary>
		IMoney Add(IMoney m);

		/// <summary>Adds a simple Money to this money. This is a helper method for
		/// implementing double dispatch.</summary>
		IMoney AddMoney(Money m);

		/// <summary>Adds a MoneyBag to this money. This is a helper method for
		/// implementing double dispatch.</summary>
		IMoney AddMoneyBag(MoneyBag s);

		/// <value>True if this money is zero.</value>
		bool IsZero { get; }

		/// <summary>Multiplies a money by the given factor.</summary>
		IMoney Multiply(int factor);

		/// <summary>Negates this money.</summary>
		IMoney Negate();

		/// <summary>Subtracts a money from this money.</summary>
		IMoney Subtract(IMoney m);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.2.8\samples\csharp\money\MoneyTest.cs ===
#region Copyright (c) 2002, James W. Newkirk, Michael C. Two, Alexei A. Vorontsov, Philip A. Craig
/************************************************************************************
'
' Copyright  2002 James W. Newkirk, Michael C. Two, Alexei A. Vorontsov
' Copyright  2000-2002 Philip A. Craig
'
' This software is provided 'as-is', without any express or implied warranty. In no 
' event will the authors be held liable for any damages arising from the use of this 
' software.
' 
' Permission is granted to anyone to use this software for any purpose, including 
' commercial applications, and to alter it and redistribute it freely, subject to the 
' following restrictions:
'
' 1. The origin of this software must not be misrepresented; you must not claim that 
' you wrote the original software. If you use this software in a product, an 
' acknowledgment (see the following) in the product documentation is required.
'
' Portions Copyright  2002 James W. Newkirk, Michael C. Two, Alexei A. Vorontsov 
' or Copyright  2000-2002 Philip A. Craig
'
' 2. Altered source versions must be plainly marked as such, and must not be 
' misrepresented as being the original software.
'
' 3. This notice may not be removed or altered from any source distribution.
'
'***********************************************************************************/
#endregion

namespace NUnit.Samples.Money 
{
	using System;
	using NUnit.Framework;
	/// <summary>
	/// 
	/// </summary>
	/// 
	[TestFixture]
	public class MoneyTest 
	{
		private Money f12CHF;
		private Money f14CHF;
		private Money f7USD;
		private Money f21USD;
        
		private MoneyBag fMB1;
		private MoneyBag fMB2;

		/// <summary>
		/// 
		/// </summary>
		/// 
		[SetUp]
		protected void SetUp() 
		{
			f12CHF= new Money(12, "CHF");
			f14CHF= new Money(14, "CHF");
			f7USD= new Money( 7, "USD");
			f21USD= new Money(21, "USD");

			fMB1= new MoneyBag(f12CHF, f7USD);
			fMB2= new MoneyBag(f14CHF, f21USD);
		}

		/// <summary>
		/// 
		/// </summary>
		/// 
		[Test]
		public void BagMultiply() 
		{
			// {[12 CHF][7 USD]} *2 == {[24 CHF][14 USD]}
			Money[] bag = { new Money(24, "CHF"), new Money(14, "USD") };
			MoneyBag expected= new MoneyBag(bag);
			Assert.AreEqual(expected, fMB1.Multiply(2));
			Assert.AreEqual(fMB1, fMB1.Multiply(1));
			Assert.IsTrue(fMB1.Multiply(0).IsZero);
		}

		/// <summary>
		/// 
		/// </summary>
		/// 
		[Test]
		public void BagNegate() 
		{
			// {[12 CHF][7 USD]} negate == {[-12 CHF][-7 USD]}
			Money[] bag= { new Money(-12, "CHF"), new Money(-7, "USD") };
			MoneyBag expected= new MoneyBag(bag);
			Assert.AreEqual(expected, fMB1.Negate());
		}

		/// <summary>
		/// 
		/// </summary>
		/// 
		[Test]
		public void BagSimpleAdd() 
		{
			// {[12 CHF][7 USD]} + [14 CHF] == {[26 CHF][7 USD]}
			Money[] bag= { new Money(26, "CHF"), new Money(7, "USD") };
			MoneyBag expected= new MoneyBag(bag);
			Assert.AreEqual(expected, fMB1.Add(f14CHF));
		}

		/// <summary>
		/// 
		/// </summary>
		/// 
		[Test]
		public void BagSubtract() 
		{
			// {[12 CHF][7 USD]} - {[14 CHF][21 USD] == {[-2 CHF][-14 USD]}
			Money[] bag= { new Money(-2, "CHF"), new Money(-14, "USD") };
			MoneyBag expected= new MoneyBag(bag);
			Assert.AreEqual(expected, fMB1.Subtract(fMB2));
		}

		/// <summary>
		/// 
		/// </summary>
		/// 
		[Test]
		public void BagSumAdd() 
		{
			// {[12 CHF][7 USD]} + {[14 CHF][21 USD]} == {[26 CHF][28 USD]}
			Money[] bag= { new Money(26, "CHF"), new Money(28, "USD") };
			MoneyBag expected= new MoneyBag(bag);
			Assert.AreEqual(expected, fMB1.Add(fMB2));
		}

		/// <summary>
		/// 
		/// </summary>
		/// 
		[Test]
		public void IsZero() 
		{
			Assert.IsTrue(fMB1.Subtract(fMB1).IsZero);

			Money[] bag = { new Money(0, "CHF"), new Money(0, "USD") };
			Assert.IsTrue(new MoneyBag(bag).IsZero);
		}

		/// <summary>
		/// 
		/// </summary>
		/// 
		[Test]
		public void MixedSimpleAdd() 
		{
			// [12 CHF] + [7 USD] == {[12 CHF][7 USD]}
			Money[] bag= { f12CHF, f7USD };
			MoneyBag expected= new MoneyBag(bag);
			Assert.AreEqual(expected, f12CHF.Add(f7USD));
		}

		/// <summary>
		/// 
		/// </summary>
		/// 
		[Test]
		public void MoneyBagEquals() 
		{
			//NOTE: Normally we use Assert.AreEqual to test whether two
			// objects are equal. But here we are testing the MoneyBag.Equals()
			// method itself, so using AreEqual would not serve the purpose.
			Assert.IsFalse(fMB1.Equals(null)); 

			Assert.IsTrue(fMB1.Equals( fMB1 ));
			MoneyBag equal= new MoneyBag(new Money(12, "CHF"), new Money(7, "USD"));
			Assert.IsTrue(fMB1.Equals(equal));
			Assert.IsTrue(!fMB1.Equals(f12CHF));
			Assert.IsTrue(!f12CHF.Equals(fMB1));
			Assert.IsTrue(!fMB1.Equals(fMB2));
		}

		/// <summary>
		/// 
		/// </summary>
		/// 
		[Test]
		public void MoneyBagHash() 
		{
			MoneyBag equal= new MoneyBag(new Money(12, "CHF"), new Money(7, "USD"));
			Assert.AreEqual(fMB1.GetHashCode(), equal.GetHashCode());
		}

		/// <summary>
		/// 
		/// </summary>
		/// 
		[Test]
		public void MoneyEquals() 
		{
			//NOTE: Normally we use Assert.AreEqual to test whether two
			// objects are equal. But here we are testing the MoneyBag.Equals()
			// method itself, so using AreEqual would not serve the purpose.
			Assert.IsFalse(f12CHF.Equals(null)); 
			Money equalMoney= new Money(12, "CHF");
			Assert.IsTrue(f12CHF.Equals( f12CHF ));
			Assert.IsTrue(f12CHF.Equals( equalMoney ));
			Assert.IsFalse(f12CHF.Equals(f14CHF));
		}

		/// <summary>
		/// 
		/// </summary>
		/// 
		[Test]
		public void MoneyHash() 
		{
			Assert.IsFalse(f12CHF.Equals(null)); 
			Money equal= new Money(12, "CHF");
			Assert.AreEqual(f12CHF.GetHashCode(), equal.GetHashCode());
		}

		/// <summary>
		/// 
		/// </summary>
		/// 
		[Test]
		public void Normalize() 
		{
			Money[] bag= { new Money(26, "CHF"), new Money(28, "CHF"), new Money(6, "CHF") };
			MoneyBag moneyBag= new MoneyBag(bag);
			Money[] expected = { new Money(60, "CHF") };
			// note: expected is still a MoneyBag
			MoneyBag expectedBag= new MoneyBag(expected);
			Assert.AreEqual(expectedBag, moneyBag);
		}

		/// <summary>
		/// 
		/// </summary>
		/// 
		[Test]
		public void Normalize2() 
		{
			// {[12 CHF][7 USD]} - [12 CHF] == [7 USD]
			Money expected= new Money(7, "USD");
			Assert.AreEqual(expected, fMB1.Subtract(f12CHF));
		}

		/// <summary>
		/// 
		/// </summary>
		/// 
		[Test]
		public void Normalize3() 
		{
			// {[12 CHF][7 USD]} - {[12 CHF][3 USD]} == [4 USD]
			Money[] s1 = { new Money(12, "CHF"), new Money(3, "USD") };
			MoneyBag ms1= new MoneyBag(s1);
			Money expected= new Money(4, "USD");
			Assert.AreEqual(expected, fMB1.Subtract(ms1));
		}

		/// <summary>
		/// 
		/// </summary>
		/// 
		[Test]
		public void Normalize4() 
		{
			// [12 CHF] - {[12 CHF][3 USD]} == [-3 USD]
			Money[] s1 = { new Money(12, "CHF"), new Money(3, "USD") };
			MoneyBag ms1= new MoneyBag(s1);
			Money expected= new Money(-3, "USD");
			Assert.AreEqual(expected, f12CHF.Subtract(ms1));
		}

		/// <summary>
		/// 
		/// </summary>
		/// 
		[Test]
		public void Print() 
		{
			Assert.AreEqual("[12 CHF]", f12CHF.ToString());
		}

		/// <summary>
		/// 
		/// </summary>
		/// 
		[Test]
		public void SimpleAdd() 
		{
			// [12 CHF] + [14 CHF] == [26 CHF]
			Money expected= new Money(26, "CHF");
			Assert.AreEqual(expected, f12CHF.Add(f14CHF));
		}

		/// <summary>
		/// 
		/// </summary>
		/// 
		[Test]
		public void SimpleBagAdd() 
		{
			// [14 CHF] + {[12 CHF][7 USD]} == {[26 CHF][7 USD]}
			Money[] bag= { new Money(26, "CHF"), new Money(7, "USD") };
			MoneyBag expected= new MoneyBag(bag);
			Assert.AreEqual(expected, f14CHF.Add(fMB1));
		}

		/// <summary>
		/// 
		/// </summary>
		/// 
		[Test]
		public void SimpleMultiply() 
		{
			// [14 CHF] *2 == [28 CHF]
			Money expected= new Money(28, "CHF");
			Assert.AreEqual(expected, f14CHF.Multiply(2));
		}

		/// <summary>
		/// 
		/// </summary>
		/// 
		[Test]
		public void SimpleNegate() 
		{
			// [14 CHF] negate == [-14 CHF]
			Money expected= new Money(-14, "CHF");
			Assert.AreEqual(expected, f14CHF.Negate());
		}

		/// <summary>
		/// 
		/// </summary>
		/// 
		[Test]
		public void SimpleSubtract() 
		{
			// [14 CHF] - [12 CHF] == [2 CHF]
			Money expected= new Money(2, "CHF");
			Assert.AreEqual(expected, f14CHF.Subtract(f12CHF));
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.2.8\samples\csharp\money-port\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("2.2.0.0")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.2.8\samples\csharp\money-port\MoneyBag.cs ===
#region Copyright (c) 2002, James W. Newkirk, Michael C. Two, Alexei A. Vorontsov, Philip A. Craig
/************************************************************************************
'
' Copyright  2002 James W. Newkirk, Michael C. Two, Alexei A. Vorontsov
' Copyright  2000-2002 Philip A. Craig
'
' This software is provided 'as-is', without any express or implied warranty. In no 
' event will the authors be held liable for any damages arising from the use of this 
' software.
' 
' Permission is granted to anyone to use this software for any purpose, including 
' commercial applications, and to alter it and redistribute it freely, subject to the 
' following restrictions:
'
' 1. The origin of this software must not be misrepresented; you must not claim that 
' you wrote the original software. If you use this software in a product, an 
' acknowledgment (see the following) in the product documentation is required.
'
' Portions Copyright  2002 James W. Newkirk, Michael C. Two, Alexei A. Vorontsov 
' or Copyright  2000-2002 Philip A. Craig
'
' 2. Altered source versions must be plainly marked as such, and must not be 
' misrepresented as being the original software.
'
' 3. This notice may not be removed or altered from any source distribution.
'
'***********************************************************************************/
#endregion

namespace NUnit.Samples.Money 
{

  using System;
  using System.Collections;
  using System.Text;

  /// <summary>A MoneyBag defers exchange rate conversions.</summary>
  /// <remarks>For example adding 
  /// 12 Swiss Francs to 14 US Dollars is represented as a bag 
  /// containing the two Monies 12 CHF and 14 USD. Adding another
  /// 10 Swiss francs gives a bag with 22 CHF and 14 USD. Due to 
  /// the deferred exchange rate conversion we can later value a 
  /// MoneyBag with different exchange rates.
  ///
  /// A MoneyBag is represented as a list of Monies and provides 
  /// different constructors to create a MoneyBag.</remarks>
  class MoneyBag: IMoney {
    private ArrayList fMonies= new ArrayList(5);

    private MoneyBag() {
    }
    public MoneyBag(Money[] bag) {
      for (int i= 0; i < bag.Length; i++) {
        if (!bag[i].IsZero)
          AppendMoney(bag[i]);
      }
    }
    public MoneyBag(Money m1, Money m2) {
      AppendMoney(m1);
      AppendMoney(m2);
    }
    public MoneyBag(Money m, MoneyBag bag) {
      AppendMoney(m);
      AppendBag(bag);
    }
    public MoneyBag(MoneyBag m1, MoneyBag m2) {
      AppendBag(m1);
      AppendBag(m2);
    }
    public IMoney Add(IMoney m) {
      return m.AddMoneyBag(this);
    }
    public IMoney AddMoney(Money m) {
      return (new MoneyBag(m, this)).Simplify();
    }
    public IMoney AddMoneyBag(MoneyBag s) {
      return (new MoneyBag(s, this)).Simplify();
    }
    private void AppendBag(MoneyBag aBag) {
      foreach (Money m in aBag.fMonies)
        AppendMoney(m);
    }
    private void AppendMoney(Money aMoney) {
      IMoney old= FindMoney(aMoney.Currency);
      if (old == null) {
        fMonies.Add(aMoney);
        return;
      }
      fMonies.Remove(old);
      IMoney sum= old.Add(aMoney);
      if (sum.IsZero) 
        return;
      fMonies.Add(sum);
    }
    private bool Contains(Money aMoney) {
      Money m= FindMoney(aMoney.Currency);
      return m.Amount == aMoney.Amount;
    }
    public override bool Equals(Object anObject) {
      if (IsZero)
        if (anObject is IMoney)
          return ((IMoney)anObject).IsZero;
            
      if (anObject is MoneyBag) {
        MoneyBag aMoneyBag= (MoneyBag)anObject;
        if (aMoneyBag.fMonies.Count != fMonies.Count)
          return false;
                
        foreach (Money m in fMonies) {
          if (!aMoneyBag.Contains(m))
            return false;
        }
        return true;
      }
      return false;
    }
    private Money FindMoney(String currency) {
      foreach (Money m in fMonies) {
        if (m.Currency.Equals(currency))
          return m;
      }
      return null;
    }
    public override int GetHashCode() {
      int hash= 0;
      foreach (Money m in fMonies) {
        hash^= m.GetHashCode();
      }
      return hash;
    }
    public bool IsZero {
      get { return fMonies.Count == 0; }
    }
    public IMoney Multiply(int factor) {
      MoneyBag result= new MoneyBag();
      if (factor != 0) {
        foreach (Money m in fMonies) {
          result.AppendMoney((Money)m.Multiply(factor));
        }
      }
      return result;
    }
    public IMoney Negate() {
      MoneyBag result= new MoneyBag();
      foreach (Money m in fMonies) {
        result.AppendMoney((Money)m.Negate());
      }
      return result;
    }
    private IMoney Simplify() {
      if (fMonies.Count == 1)
        return (IMoney)fMonies[0];
      return this;
    }
    public IMoney Subtract(IMoney m) {
      return Add(m.Negate());
    }
    public override String ToString() {
      StringBuilder buffer = new StringBuilder();
      buffer.Append("{");
      foreach (Money m in fMonies)
        buffer.Append(m);
      buffer.Append("}");
      return buffer.ToString();
    }
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.2.8\samples\csharp\money-port\Money.cs ===
#region Copyright (c) 2002, James W. Newkirk, Michael C. Two, Alexei A. Vorontsov, Philip A. Craig
/************************************************************************************
'
' Copyright  2002 James W. Newkirk, Michael C. Two, Alexei A. Vorontsov
' Copyright  2000-2002 Philip A. Craig
'
' This software is provided 'as-is', without any express or implied warranty. In no 
' event will the authors be held liable for any damages arising from the use of this 
' software.
' 
' Permission is granted to anyone to use this software for any purpose, including 
' commercial applications, and to alter it and redistribute it freely, subject to the 
' following restrictions:
'
' 1. The origin of this software must not be misrepresented; you must not claim that 
' you wrote the original software. If you use this software in a product, an 
' acknowledgment (see the following) in the product documentation is required.
'
' Portions Copyright  2002 James W. Newkirk, Michael C. Two, Alexei A. Vorontsov 
' or Copyright  2000-2002 Philip A. Craig
'
' 2. Altered source versions must be plainly marked as such, and must not be 
' misrepresented as being the original software.
'
' 3. This notice may not be removed or altered from any source distribution.
'
'***********************************************************************************/
#endregion

namespace NUnit.Samples.Money 
{

  using System;
  using System.Text;

  /// <summary>A simple Money.</summary>
  class Money: IMoney {

    private int fAmount;
    private String fCurrency;
        
    /// <summary>Constructs a money from the given amount and
    /// currency.</summary>
    public Money(int amount, String currency) {
      fAmount= amount;
      fCurrency= currency;
    }

    /// <summary>Adds a money to this money. Forwards the request to
    /// the AddMoney helper.</summary>
    public IMoney Add(IMoney m) {
      return m.AddMoney(this);
    }

    public IMoney AddMoney(Money m) {
      if (m.Currency.Equals(Currency) )
        return new Money(Amount+m.Amount, Currency);
      return new MoneyBag(this, m);
    }

    public IMoney AddMoneyBag(MoneyBag s) {
      return s.AddMoney(this);
    }

    public int Amount {
      get { return fAmount; }
    }

    public String Currency {
      get { return fCurrency; }
    }

    public override bool Equals(Object anObject) {
      if (IsZero)
        if (anObject is IMoney)
          return ((IMoney)anObject).IsZero;
      if (anObject is Money) {
        Money aMoney= (Money)anObject;
        return aMoney.Currency.Equals(Currency)
          && Amount == aMoney.Amount;
      }
      return false;
    }

    public override int GetHashCode() {
      return fCurrency.GetHashCode()+fAmount;
    }

    public bool IsZero {
      get { return Amount == 0; }
    }

    public IMoney Multiply(int factor) {
      return new Money(Amount*factor, Currency);
    }

    public IMoney Negate() {
      return new Money(-Amount, Currency);
    }

    public IMoney Subtract(IMoney m) {
      return Add(m.Negate());
    }

    public override String ToString() {
      StringBuilder buffer = new StringBuilder();
      buffer.Append("["+Amount+" "+Currency+"]");
      return buffer.ToString();
    }
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.2.8\samples\csharp\money-port\MoneyTest.cs ===
#region Copyright (c) 2002, James W. Newkirk, Michael C. Two, Alexei A. Vorontsov, Philip A. Craig
/************************************************************************************
'
' Copyright  2002 James W. Newkirk, Michael C. Two, Alexei A. Vorontsov
' Copyright  2000-2002 Philip A. Craig
'
' This software is provided 'as-is', without any express or implied warranty. In no 
' event will the authors be held liable for any damages arising from the use of this 
' software.
' 
' Permission is granted to anyone to use this software for any purpose, including 
' commercial applications, and to alter it and redistribute it freely, subject to the 
' following restrictions:
'
' 1. The origin of this software must not be misrepresented; you must not claim that 
' you wrote the original software. If you use this software in a product, an 
' acknowledgment (see the following) in the product documentation is required.
'
' Portions Copyright  2002 James W. Newkirk, Michael C. Two, Alexei A. Vorontsov 
' or Copyright  2000-2002 Philip A. Craig
'
' 2. Altered source versions must be plainly marked as such, and must not be 
' misrepresented as being the original software.
'
' 3. This notice may not be removed or altered from any source distribution.
'
'***********************************************************************************/
#endregion

namespace NUnit.Samples.Money.Port
{
	using System;
	using NUnit.Framework;
	/// <summary>
	/// 
	/// </summary>
	public class MoneyTest: TestCase 
	{
		private Money f12CHF;
		private Money f14CHF;
		private Money f7USD;
		private Money f21USD;
        
		private MoneyBag fMB1;
		private MoneyBag fMB2;

		/// <summary>
		/// 
		/// </summary>
		protected override void SetUp() 
		{
			f12CHF= new Money(12, "CHF");
			f14CHF= new Money(14, "CHF");
			f7USD= new Money( 7, "USD");
			f21USD= new Money(21, "USD");

			fMB1= new MoneyBag(f12CHF, f7USD);
			fMB2= new MoneyBag(f14CHF, f21USD);
		}
		/// <summary>
		/// 
		/// </summary>
		public void TestBagMultiply() 
		{
			// {[12 CHF][7 USD]} *2 == {[24 CHF][14 USD]}
			Money[] bag = { new Money(24, "CHF"), new Money(14, "USD") };
			MoneyBag expected= new MoneyBag(bag);
			Assertion.AssertEquals(expected, fMB1.Multiply(2));
			Assertion.AssertEquals(fMB1, fMB1.Multiply(1));
			Assertion.Assert(fMB1.Multiply(0).IsZero);
		}
		/// <summary>
		/// 
		/// </summary>
		public void TestBagNegate() 
		{
			// {[12 CHF][7 USD]} negate == {[-12 CHF][-7 USD]}
			Money[] bag= { new Money(-12, "CHF"), new Money(-7, "USD") };
			MoneyBag expected= new MoneyBag(bag);
			Assertion.AssertEquals(expected, fMB1.Negate());
		}
		/// <summary>
		/// 
		/// </summary>
		public void TestBagSimpleAdd() 
		{
			// {[12 CHF][7 USD]} + [14 CHF] == {[26 CHF][7 USD]}
			Money[] bag= { new Money(26, "CHF"), new Money(7, "USD") };
			MoneyBag expected= new MoneyBag(bag);
			Assertion.AssertEquals(expected, fMB1.Add(f14CHF));
		}
		/// <summary>
		/// 
		/// </summary>
		public void TestBagSubtract() 
		{
			// {[12 CHF][7 USD]} - {[14 CHF][21 USD] == {[-2 CHF][-14 USD]}
			Money[] bag= { new Money(-2, "CHF"), new Money(-14, "USD") };
			MoneyBag expected= new MoneyBag(bag);
			Assertion.AssertEquals(expected, fMB1.Subtract(fMB2));
		}
		/// <summary>
		/// 
		/// </summary>
		public void TestBagSumAdd() 
		{
			// {[12 CHF][7 USD]} + {[14 CHF][21 USD]} == {[26 CHF][28 USD]}
			Money[] bag= { new Money(26, "CHF"), new Money(28, "USD") };
			MoneyBag expected= new MoneyBag(bag);
			Assertion.AssertEquals(expected, fMB1.Add(fMB2));
		}
		/// <summary>
		/// 
		/// </summary>
		public void TestIsZero() 
		{
			Assertion.Assert(fMB1.Subtract(fMB1).IsZero);

			Money[] bag = { new Money(0, "CHF"), new Money(0, "USD") };
			Assertion.Assert(new MoneyBag(bag).IsZero);
		}
		/// <summary>
		/// 
		/// </summary>
		public void TestMixedSimpleAdd() 
		{
			// [12 CHF] + [7 USD] == {[12 CHF][7 USD]}
			Money[] bag= { f12CHF, f7USD };
			MoneyBag expected= new MoneyBag(bag);
			Assertion.AssertEquals(expected, f12CHF.Add(f7USD));
		}
		/// <summary>
		/// 
		/// </summary>
		public void TestMoneyBagEquals() 
		{
			Assertion.Assert(!fMB1.Equals(null)); 

			Assertion.AssertEquals(fMB1, fMB1);
			MoneyBag equal= new MoneyBag(new Money(12, "CHF"), new Money(7, "USD"));
			Assertion.Assert(fMB1.Equals(equal));
			Assertion.Assert(!fMB1.Equals(f12CHF));
			Assertion.Assert(!f12CHF.Equals(fMB1));
			Assertion.Assert(!fMB1.Equals(fMB2));
		}
		/// <summary>
		/// 
		/// </summary>
		public void TestMoneyBagHash() 
		{
			MoneyBag equal= new MoneyBag(new Money(12, "CHF"), new Money(7, "USD"));
			Assertion.AssertEquals(fMB1.GetHashCode(), equal.GetHashCode());
		}
		/// <summary>
		/// 
		/// </summary>
		public void TestMoneyEquals() 
		{
			Assertion.Assert(!f12CHF.Equals(null)); 
			Money equalMoney= new Money(12, "CHF");
			Assertion.AssertEquals(f12CHF, f12CHF);
			Assertion.AssertEquals(f12CHF, equalMoney);
			Assertion.AssertEquals(f12CHF.GetHashCode(), equalMoney.GetHashCode());
			Assertion.Assert(!f12CHF.Equals(f14CHF));
		}
		/// <summary>
		/// 
		/// </summary>
		public void TestMoneyHash() 
		{
			Assertion.Assert(!f12CHF.Equals(null)); 
			Money equal= new Money(12, "CHF");
			Assertion.AssertEquals(f12CHF.GetHashCode(), equal.GetHashCode());
		}
		/// <summary>
		/// 
		/// </summary>
		public void TestNormalize() 
		{
			Money[] bag= { new Money(26, "CHF"), new Money(28, "CHF"), new Money(6, "CHF") };
			MoneyBag moneyBag= new MoneyBag(bag);
			Money[] expected = { new Money(60, "CHF") };
			// note: expected is still a MoneyBag
			MoneyBag expectedBag= new MoneyBag(expected);
			Assertion.AssertEquals(expectedBag, moneyBag);
		}
		/// <summary>
		/// 
		/// </summary>
		public void TestNormalize2() 
		{
			// {[12 CHF][7 USD]} - [12 CHF] == [7 USD]
			Money expected= new Money(7, "USD");
			Assertion.AssertEquals(expected, fMB1.Subtract(f12CHF));
		}
		/// <summary>
		/// 
		/// </summary>
		public void TestNormalize3() 
		{
			// {[12 CHF][7 USD]} - {[12 CHF][3 USD]} == [4 USD]
			Money[] s1 = { new Money(12, "CHF"), new Money(3, "USD") };
			MoneyBag ms1= new MoneyBag(s1);
			Money expected= new Money(4, "USD");
			Assertion.AssertEquals(expected, fMB1.Subtract(ms1));
		}
		/// <summary>
		/// 
		/// </summary>
		public void TestNormalize4() 
		{
			// [12 CHF] - {[12 CHF][3 USD]} == [-3 USD]
			Money[] s1 = { new Money(12, "CHF"), new Money(3, "USD") };
			MoneyBag ms1= new MoneyBag(s1);
			Money expected= new Money(-3, "USD");
			Assertion.AssertEquals(expected, f12CHF.Subtract(ms1));
		}
		/// <summary>
		/// 
		/// </summary>
		public void TestPrint() 
		{
			Assertion.AssertEquals("[12 CHF]", f12CHF.ToString());
		}
		/// <summary>
		/// 
		/// </summary>
		public void TestSimpleAdd() 
		{
			// [12 CHF] + [14 CHF] == [26 CHF]
			Money expected= new Money(26, "CHF");
			Assertion.AssertEquals(expected, f12CHF.Add(f14CHF));
		}
		/// <summary>
		/// 
		/// </summary>
		public void TestSimpleBagAdd() 
		{
			// [14 CHF] + {[12 CHF][7 USD]} == {[26 CHF][7 USD]}
			Money[] bag= { new Money(26, "CHF"), new Money(7, "USD") };
			MoneyBag expected= new MoneyBag(bag);
			Assertion.AssertEquals(expected, f14CHF.Add(fMB1));
		}
		/// <summary>
		/// 
		/// </summary>
		public void TestSimpleMultiply() 
		{
			// [14 CHF] *2 == [28 CHF]
			Money expected= new Money(28, "CHF");
			Assertion.AssertEquals(expected, f14CHF.Multiply(2));
		}
		/// <summary>
		/// 
		/// </summary>
		public void TestSimpleNegate() 
		{
			// [14 CHF] negate == [-14 CHF]
			Money expected= new Money(-14, "CHF");
			Assertion.AssertEquals(expected, f14CHF.Negate());
		}
		/// <summary>
		/// 
		/// </summary>
		public void TestSimpleSubtract() 
		{
			// [14 CHF] - [12 CHF] == [2 CHF]
			Money expected= new Money(2, "CHF");
			Assertion.AssertEquals(expected, f14CHF.Subtract(f12CHF));
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.2.8\samples\csharp\simple\CSharpTest.cs ===
#region Copyright (c) 2002, James W. Newkirk, Michael C. Two, Alexei A. Vorontsov, Philip A. Craig
/************************************************************************************
'
' Copyright  2002 James W. Newkirk, Michael C. Two, Alexei A. Vorontsov
' Copyright  2000-2002 Philip A. Craig
'
' This software is provided 'as-is', without any express or implied warranty. In no 
' event will the authors be held liable for any damages arising from the use of this 
' software.
' 
' Permission is granted to anyone to use this software for any purpose, including 
' commercial applications, and to alter it and redistribute it freely, subject to the 
' following restrictions:
'
' 1. The origin of this software must not be misrepresented; you must not claim that 
' you wrote the original software. If you use this software in a product, an 
' acknowledgment (see the following) in the product documentation is required.
'
' Portions Copyright  2002 James W. Newkirk, Michael C. Two, Alexei A. Vorontsov 
' or Copyright  2000-2002 Philip A. Craig
'
' 2. Altered source versions must be plainly marked as such, and must not be 
' misrepresented as being the original software.
'
' 3. This notice may not be removed or altered from any source distribution.
'
'***********************************************************************************/
#endregion

namespace NUnit.Samples 
{
	using System;
	using NUnit.Framework;

	/// <summary>Some simple Tests.</summary>
	/// 
	[TestFixture] 
	public class SimpleCSharpTest
	{
		/// <summary>
		/// 
		/// </summary>
		protected int fValue1;
		/// <summary>
		/// 
		/// </summary>
		protected int fValue2;
		
		/// <summary>
		/// 
		/// </summary>
		[SetUp] public void Init() 
		{
			fValue1= 2;
			fValue2= 3;
		}

		/// <summary>
		/// 
		/// </summary>
		///
		[Test] public void Add() 
		{
			double result= fValue1 + fValue2;
			// forced failure result == 5
			Assert.AreEqual(6, result, "Expected Failure.");
		}

		/// <summary>
		/// 
		/// </summary>
		/// 
		[Test] public void DivideByZero() 
		{
			int zero= 0;
			int result= 8/zero;
		}

		/// <summary>
		/// 
		/// </summary>
		/// 
		[Test] public void Equals() 
		{
			Assert.AreEqual(12, 12, "Integer");
			Assert.AreEqual(12L, 12L, "Long");
			Assert.AreEqual('a', 'a', "Char");
			Assert.AreEqual((object)12, (object)12, "Integer Object Cast");
            
			Assert.AreEqual(12, 13, "Expected Failure (Integer)");
			Assert.AreEqual(12.0, 11.99, 0.0, "Expected Failure (Double).");
		}

		[Test]
		[ExpectedException(typeof(InvalidOperationException))]
		public void ExpectAnException()
		{
			throw new InvalidCastException();
		}

		[Test]
		[Ignore("ignored test")]
		public void IgnoredTest()
		{
			throw new Exception();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.2.8\samples\csharp\money-port\IMoney.cs ===
#region Copyright (c) 2002, James W. Newkirk, Michael C. Two, Alexei A. Vorontsov, Philip A. Craig
/************************************************************************************
'
' Copyright  2002 James W. Newkirk, Michael C. Two, Alexei A. Vorontsov
' Copyright  2000-2002 Philip A. Craig
'
' This software is provided 'as-is', without any express or implied warranty. In no 
' event will the authors be held liable for any damages arising from the use of this 
' software.
' 
' Permission is granted to anyone to use this software for any purpose, including 
' commercial applications, and to alter it and redistribute it freely, subject to the 
' following restrictions:
'
' 1. The origin of this software must not be misrepresented; you must not claim that 
' you wrote the original software. If you use this software in a product, an 
' acknowledgment (see the following) in the product documentation is required.
'
' Portions Copyright  2002 James W. Newkirk, Michael C. Two, Alexei A. Vorontsov 
' or Copyright  2000-2002 Philip A. Craig
'
' 2. Altered source versions must be plainly marked as such, and must not be 
' misrepresented as being the original software.
'
' 3. This notice may not be removed or altered from any source distribution.
'
'***********************************************************************************/
#endregion

namespace NUnit.Samples.Money 
{

  /// <summary>The common interface for simple Monies and MoneyBags.</summary>
  interface IMoney {

    /// <summary>Adds a money to this money.</summary>
    IMoney Add(IMoney m);

    /// <summary>Adds a simple Money to this money. This is a helper method for
    /// implementing double dispatch.</summary>
    IMoney AddMoney(Money m);

    /// <summary>Adds a MoneyBag to this money. This is a helper method for
    /// implementing double dispatch.</summary>
    IMoney AddMoneyBag(MoneyBag s);

    /// <value>True if this money is zero.</value>
    bool IsZero { get; }

    /// <summary>Multiplies a money by the given factor.</summary>
    IMoney Multiply(int factor);

    /// <summary>Negates this money.</summary>
    IMoney Negate();

    /// <summary>Subtracts a money from this money.</summary>
    IMoney Subtract(IMoney m);
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.2.8\samples\csharp\simple\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("csharp.sample.dll")]
[assembly: AssemblyDescription("C# Sample Unit Tests")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("NUnit")]
[assembly: AssemblyProduct("NUnit")]
[assembly: AssemblyCopyright("Copyright (C) 2002-2003 James W. Newkirk, Michael C. Two, Alexei A. Vorontsov. \nCopyright (C) 2000-2003 Philip Craig.\nAll Rights Reserved.")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("2.2.0.0")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.4.1\samples\cpp\cpp-cli\failures\cppsample.cpp ===
// ****************************************************************
// This is free software licensed under the NUnit license. You
// may obtain a copy of the license as well as information regarding
// copyright ownership at http://nunit.org/?p=license&r=2.4.
// ****************************************************************

#include "cppsample.h"

namespace NUnitSamples {

	void SimpleCPPSample::Init() {
		fValue1 = 2;
		fValue2 = 3;
	}

	void SimpleCPPSample::Add() {
		int result = fValue1 + fValue2;
		Assert::AreEqual(6,result);
	}

	void SimpleCPPSample::DivideByZero()
	{
		int zero= 0;
		int result= 8/zero;
	}

	void SimpleCPPSample::Equals() {
		Assert::AreEqual(12, 12, "Integer");
		Assert::AreEqual(12L, 12L, "Long");
		Assert::AreEqual('a', 'a', "Char");


		Assert::AreEqual(12, 13, "Expected Failure (Integer)");
		Assert::AreEqual(12.0, 11.99, 0.0, "Expected Failure (Double)");
	}

	void SimpleCPPSample::IgnoredTest()
	{
		throw gcnew InvalidCastException();
	}

	void SimpleCPPSample::ExpectAnException()
	{
		throw gcnew InvalidCastException();
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.4.1\samples\cpp\cpp-cli\failures\cppsample.h ===
// ****************************************************************
// This is free software licensed under the NUnit license. You
// may obtain a copy of the license as well as information regarding
// copyright ownership at http://nunit.org/?p=license&r=2.4.
// ****************************************************************

#pragma once

using namespace System;
using namespace NUnit::Framework;

namespace NUnitSamples
{
	[TestFixture]
	public ref class SimpleCPPSample
	{
		int fValue1;
		int fValue2;
	public:
		[SetUp] void Init();

		[Test] void Add();
		[Test] void DivideByZero();
		[Test] void Equals();
		[Test] [Ignore("ignored test")] void IgnoredTest();
		[Test] [ExpectedException(InvalidOperationException::typeid)] void ExpectAnException();
	};
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.4.1\samples\cpp\cpp-cli\syntax\AssemblyInfo.cpp ===
#include "stdafx.h"

using namespace System;
using namespace System::Reflection;
using namespace System::Runtime::CompilerServices;
using namespace System::Runtime::InteropServices;
using namespace System::Security::Permissions;

//
// General Information about an assembly is controlled through the following
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitleAttribute("cppclisyntax")];
[assembly:AssemblyDescriptionAttribute("")];
[assembly:AssemblyConfigurationAttribute("")];
[assembly:AssemblyCompanyAttribute("")];
[assembly:AssemblyProductAttribute("cppclisyntax")];
[assembly:AssemblyCopyrightAttribute("Copyright (c)  2007")];
[assembly:AssemblyTrademarkAttribute("")];
[assembly:AssemblyCultureAttribute("")];

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version
//      Build Number
//      Revision
//
// You can specify all the value or you can default the Revision and Build Numbers
// by using the '*' as shown below:

[assembly:AssemblyVersionAttribute("1.0.*")];

[assembly:ComVisible(false)];

[assembly:CLSCompliantAttribute(true)];

[assembly:SecurityPermission(SecurityAction::RequestMinimum, UnmanagedCode = true)];
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.4.1\samples\cpp\cpp-cli\failures\AssemblyInfo.cpp ===
using namespace System::Reflection;
using namespace System::Runtime::CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitleAttribute("")];
[assembly:AssemblyDescriptionAttribute("")];
[assembly:AssemblyConfigurationAttribute("")];
[assembly:AssemblyCompanyAttribute("")];
[assembly:AssemblyProductAttribute("")];
[assembly:AssemblyCopyrightAttribute("")];
[assembly:AssemblyTrademarkAttribute("")];
[assembly:AssemblyCultureAttribute("")];		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersionAttribute("2.2.0.0")];

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//        When specifying the KeyFile, the location of the KeyFile should be
//        relative to the project directory.
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly:AssemblyDelaySignAttribute(false)];
[assembly:AssemblyKeyFileAttribute("")];
[assembly:AssemblyKeyNameAttribute("")];
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.4.1\samples\csharp\failures\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("csharp.sample.dll")]
[assembly: AssemblyDescription("C# Sample Unit Tests")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("NUnit")]
[assembly: AssemblyProduct("NUnit")]
[assembly: AssemblyCopyright("Copyright (C) 2002-2003 James W. Newkirk, Michael C. Two, Alexei A. Vorontsov. \nCopyright (C) 2000-2003 Philip Craig.\nAll Rights Reserved.")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("2.2.0.0")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.4.1\samples\cpp\cpp-cli\syntax\cpp-cli-syntax.cpp ===
// ****************************************************************
// This is free software licensed under the NUnit license. You
// may obtain a copy of the license as well as information regarding
// copyright ownership at http://nunit.org/?p=license&r=2.4.
// ****************************************************************

using namespace NUnit::Framework;
using NUnit::Framework::SyntaxHelpers::Text;
using NUnit::Framework::SyntaxHelpers::List;
using NUnit::Framework::SyntaxHelpers::Has;
using System::String;

namespace NUnitSamples
{
	[TestFixture]
	public ref class AssertSyntaxTests : AssertionHelper
	{
	public:
		[Test]
		void IsNull()
		{
			// Classic syntax
			Assert::IsNull(nullptr);

			// Helper syntax
			Assert::That(nullptr, Is::Null);

			// Inherited syntax
			Expect(nullptr, Null);
		}

		[Test]
		void IsNotNull()
		{
			// Classic syntax
			Assert::IsNotNull(42);

			// Helper syntax
			Assert::That(42, Is::Not->Null);

			// Inherited syntax
			Expect( 42, Not->Null );
		}

		[Test]
		void IsTrue()
		{
			// Classic syntax
			Assert::IsTrue(2+2==4);

			// Helper syntax
			Assert::That(2+2==4, Is::True);
			Assert::That(2+2==4);

			// Inherited syntax
			Expect(2+2==4, True);
			Expect(2+2==4);
		}

		[Test]
		void IsFalse()
		{
			// Classic syntax
			Assert::IsFalse(2+2==5);

			// Helper syntax
			Assert::That(2+2==5, Is::False);
			
			// Inherited syntax
			Expect(2+2==5, False);
		}

		[Test]
		void IsNaN()
		{
			double d = double::NaN;
			float f = float::NaN;

			// Classic syntax
			Assert::IsNaN(d);
			Assert::IsNaN(f);

			// Helper syntax
			Assert::That(d, Is::NaN);
			Assert::That(f, Is::NaN);
			
			// Inherited syntax
			Expect(d, NaN);
			Expect(f, NaN);
		}

		[Test]
		void EmptyStringTests()
		{
			// Classic syntax
			Assert::IsEmpty("");
			Assert::IsNotEmpty("Hello!");

			// Helper syntax
			Assert::That("", Is::Empty);
			Assert::That("Hello!", Is::Not->Empty);

			// Inherited syntax
			Expect("", Empty);
			Expect("Hello!", Not->Empty);
		}

		[Test]
		void EmptyCollectionTests()
		{
			// Classic syntax
			Assert::IsEmpty(gcnew array<bool>(0));
			Assert::IsNotEmpty(gcnew array<int>(3));

			// Helper syntax
			Assert::That(gcnew array<bool>(0), Is::Empty);
			Assert::That(gcnew array<int>(3), Is::Not->Empty);

			// Inherited syntax
			Expect(gcnew array<bool>(0), Empty);
			Expect(gcnew array<int>(3), Not->Empty);
		}

		[Test]
		void ExactTypeTests()
		{
			// Classic syntax workarounds)
			String^ greeting = "Hello";
			Assert::AreEqual(String::typeid, greeting->GetType());
			Assert::AreEqual("System.String", greeting->GetType()->FullName);
			Assert::AreNotEqual(int::typeid, greeting->GetType());
			Assert::AreNotEqual("System.Int32", greeting->GetType()->FullName);

			// Helper syntax
			Assert::That(greeting, Is::TypeOf(String::typeid));
			Assert::That(greeting, Is::Not->TypeOf(int::typeid));
			
			// Inherited syntax
			Expect( "Hello", TypeOf(String::typeid));
			Expect( "Hello", Not->TypeOf(int::typeid));
		}

		[Test]
		void InstanceOfTypeTests()
		{
			// Classic syntax
			Assert::IsInstanceOfType(String::typeid, "Hello");
			Assert::IsNotInstanceOfType(String::typeid, 5);

			// Helper syntax
			Assert::That("Hello", Is::InstanceOfType(String::typeid));
			Assert::That(5, Is::Not->InstanceOfType(String::typeid));

			// Inherited syntax
			Expect("Hello", InstanceOfType(String::typeid));
			Expect(5, Not->InstanceOfType(String::typeid));
		}

		[Test]
		void AssignableFromTypeTests()
		{
			// Classic syntax
			Assert::IsAssignableFrom(String::typeid, "Hello");
			Assert::IsNotAssignableFrom(String::typeid, 5);

			// Helper syntax
			Assert::That( "Hello", Is::AssignableFrom(String::typeid));
			Assert::That( 5, Is::Not->AssignableFrom(String::typeid));
			
			// Inherited syntax
			Expect( "Hello", AssignableFrom(String::typeid));
			Expect( 5, Not->AssignableFrom(String::typeid));
		}

		[Test]
		void SubstringTests()
		{
			String^ phrase = "Hello World!";
			array<String^>^ strings = {"abc", "bad", "dba" };
			
			// Classic Syntax
			StringAssert::Contains("World", phrase);
			
			// Helper syntax
			Assert::That(phrase, Contains("World"));
			// Only available using new syntax
			Assert::That(phrase, Text::DoesNotContain("goodbye"));
			Assert::That(phrase, Text::Contains("WORLD")->IgnoreCase);
			Assert::That(phrase, Text::DoesNotContain("BYE")->IgnoreCase);
			Assert::That(strings, Text::All->Contains( "b" ) );

			// Inherited syntax
			Expect(phrase, Contains("World"));
			// Only available using new syntax
			Expect(phrase, Not->Contains("goodbye"));
			Expect(phrase, Contains("WORLD")->IgnoreCase);
			Expect(phrase, Not->Contains("BYE")->IgnoreCase);
			Expect(strings, All->Contains("b"));
		}

		[Test]
		void StartsWithTests()
		{
			String^ phrase = "Hello World!";
			array<String^>^ greetings = { "Hello!", "Hi!", "Hola!" };

			// Classic syntax
			StringAssert::StartsWith("Hello", phrase);

			// Helper syntax
			Assert::That(phrase, Text::StartsWith("Hello"));
			// Only available using new syntax
			Assert::That(phrase, Text::DoesNotStartWith("Hi!"));
			Assert::That(phrase, Text::StartsWith("HeLLo")->IgnoreCase);
			Assert::That(phrase, Text::DoesNotStartWith("HI")->IgnoreCase);
			Assert::That(greetings, Text::All->StartsWith("h")->IgnoreCase);

			// Inherited syntax
			Expect(phrase, StartsWith("Hello"));
			// Only available using new syntax
			Expect(phrase, Not->StartsWith("Hi!"));
			Expect(phrase, StartsWith("HeLLo")->IgnoreCase);
			Expect(phrase, Not->StartsWith("HI")->IgnoreCase);
			Expect(greetings, All->StartsWith("h")->IgnoreCase);
		}

		[Test]
		void EndsWithTests()
		{
			String^ phrase = "Hello World!";
			array<String^>^ greetings = { "Hello!", "Hi!", "Hola!" };

			// Classic Syntax
			StringAssert::EndsWith("!", phrase);

			// Helper syntax
			Assert::That(phrase, Text::EndsWith("!"));
			// Only available using new syntax
			Assert::That(phrase, Text::DoesNotEndWith("?"));
			Assert::That(phrase, Text::EndsWith("WORLD!")->IgnoreCase);
			Assert::That(greetings, Text::All->EndsWith("!"));
		
			// Inherited syntax
			Expect(phrase, EndsWith("!"));
			// Only available using new syntax
			Expect(phrase, Not->EndsWith("?"));
			Expect(phrase, EndsWith("WORLD!")->IgnoreCase);
			Expect(greetings, All->EndsWith("!") );
		}

		[Test]
		void EqualIgnoringCaseTests()
		{
			String^ phrase = "Hello World!";

			// Classic syntax
			StringAssert::AreEqualIgnoringCase("hello world!",phrase);
            
			// Helper syntax
			Assert::That(phrase, Is::EqualTo("hello world!")->IgnoreCase);
			//Only available using new syntax
			Assert::That(phrase, Is::Not->EqualTo("goodbye world!")->IgnoreCase);
			Assert::That(gcnew array<String^> { "Hello", "World" }, 
				Is::EqualTo(gcnew array<Object^> { "HELLO", "WORLD" })->IgnoreCase);
			Assert::That(gcnew array<String^> {"HELLO", "Hello", "hello" },
				Is::All->EqualTo( "hello" )->IgnoreCase);
		            
			// Inherited syntax
			Expect(phrase, EqualTo("hello world!")->IgnoreCase);
			//Only available using new syntax
			Expect(phrase, Not->EqualTo("goodbye world!")->IgnoreCase);
			Expect(gcnew array<String^> { "Hello", "World" }, 
				EqualTo(gcnew array<Object^> { "HELLO", "WORLD" })->IgnoreCase);
			Expect(gcnew array<String^> {"HELLO", "Hello", "hello" },
				All->EqualTo( "hello" )->IgnoreCase);
		}

		[Test]
		void RegularExpressionTests()
		{
			String^ phrase = "Now is the time for all good men to come to the aid of their country.";
			array<String^>^ quotes = { "Never say never", "It's never too late", "Nevermore!" };

			// Classic syntax
			StringAssert::IsMatch( "all good men", phrase );
			StringAssert::IsMatch( "Now.*come", phrase );

			// Helper syntax
			Assert::That( phrase, Text::Matches( "all good men" ) );
			Assert::That( phrase, Text::Matches( "Now.*come" ) );
			// Only available using new syntax
			Assert::That(phrase, Text::DoesNotMatch("all.*men.*good"));
			Assert::That(phrase, Text::Matches("ALL")->IgnoreCase);
			Assert::That(quotes, Text::All->Matches("never")->IgnoreCase);
		
			// Inherited syntax
			Expect( phrase, Matches( "all good men" ) );
			Expect( phrase, Matches( "Now.*come" ) );
			// Only available using new syntax
			Expect(phrase, Not->Matches("all.*men.*good"));
			Expect(phrase, Matches("ALL")->IgnoreCase);
			Expect(quotes, All->Matches("never")->IgnoreCase);
		}

		[Test]
		void EqualityTests()
		{
			array<int>^ i3 = { 1, 2, 3 };
			array<double>^ d3 = { 1.0, 2.0, 3.0 };
			array<int>^ iunequal = { 1, 3, 2 };

			// Classic Syntax
			Assert::AreEqual(4, 2 + 2);
			Assert::AreEqual(i3, d3);
			Assert::AreNotEqual(5, 2 + 2);
			Assert::AreNotEqual(i3, iunequal);

			// Helper syntax
			Assert::That(2 + 2, Is::EqualTo(4));
			Assert::That(2 + 2 == 4);
			Assert::That(i3, Is::EqualTo(d3));
			Assert::That(2 + 2, Is::Not->EqualTo(5));
			Assert::That(i3, Is::Not->EqualTo(iunequal));
		
			// Inherited syntax
			Expect(2 + 2, EqualTo(4));
			Expect(2 + 2 == 4);
			Expect(i3, EqualTo(d3));
			Expect(2 + 2, Not->EqualTo(5));
			Expect(i3, Not->EqualTo(iunequal));
		}

		[Test]
		void EqualityTestsWithTolerance()
		{
			// CLassic syntax
			Assert::AreEqual(5.0, 4.99, 0.05);
			Assert::AreEqual(5.0F, 4.99F, 0.05F);

			// Helper syntax
			Assert::That(4.99L, Is::EqualTo(5.0L)->Within(0.05L));
			Assert::That(4.99f, Is::EqualTo(5.0f)->Within(0.05f));
		
			// Inherited syntax
			Expect(4.99L, EqualTo(5.0L)->Within(0.05L));
			Expect(4.99f, EqualTo(5.0f)->Within(0.05f));
		}

		[Test]
		void ComparisonTests()
		{
			// Classic Syntax
			Assert::Greater(7, 3);
			Assert::GreaterOrEqual(7, 3);
			Assert::GreaterOrEqual(7, 7);

			// Helper syntax
			Assert::That(7, Is::GreaterThan(3));
			Assert::That(7, Is::GreaterThanOrEqualTo(3));
			Assert::That(7, Is::AtLeast(3));
			Assert::That(7, Is::GreaterThanOrEqualTo(7));
			Assert::That(7, Is::AtLeast(7));

			// Inherited syntax
			Expect(7, GreaterThan(3));
			Expect(7, GreaterThanOrEqualTo(3));
			Expect(7, AtLeast(3));
			Expect(7, GreaterThanOrEqualTo(7));
			Expect(7, AtLeast(7));

			// Classic syntax
			Assert::Less(3, 7);
			Assert::LessOrEqual(3, 7);
			Assert::LessOrEqual(3, 3);

			// Helper syntax
			Assert::That(3, Is::LessThan(7));
			Assert::That(3, Is::LessThanOrEqualTo(7));
			Assert::That(3, Is::AtMost(7));
			Assert::That(3, Is::LessThanOrEqualTo(3));
			Assert::That(3, Is::AtMost(3));
		
			// Inherited syntax
			Expect(3, LessThan(7));
			Expect(3, LessThanOrEqualTo(7));
			Expect(3, AtMost(7));
			Expect(3, LessThanOrEqualTo(3));
			Expect(3, AtMost(3));
		}

		[Test]
		void AllItemsTests()
		{
			array<Object^>^ ints = { 1, 2, 3, 4 };
			array<Object^>^ strings = { "abc", "bad", "cab", "bad", "dad" };

			// Classic syntax
			CollectionAssert::AllItemsAreNotNull(ints);
			CollectionAssert::AllItemsAreInstancesOfType(ints, int::typeid);
			CollectionAssert::AllItemsAreInstancesOfType(strings, String::typeid);
			CollectionAssert::AllItemsAreUnique(ints);

			// Helper syntax
			Assert::That(ints, Is::All->Not->Null);
			Assert::That(ints, Is::All->InstanceOfType(int::typeid));
			Assert::That(strings, Is::All->InstanceOfType(String::typeid));
			Assert::That(ints, Is::Unique);
			// Only available using new syntax
			Assert::That(strings, Is::Not->Unique);
			Assert::That(ints, Is::All->GreaterThan(0));
			Assert::That(strings, Text::All->Contains( "a" ) );
			Assert::That(strings, List::Some->StartsWith( "ba" ) );
		
			// Inherited syntax
			Expect(ints, All->Not->Null);
			Expect(ints, All->InstanceOfType(int::typeid));
			Expect(strings, All->InstanceOfType(String::typeid));
			Expect(ints, Unique);
			// Only available using new syntax
			Expect(strings, Not->Unique);
			Expect(ints, All->GreaterThan(0));
			Expect(strings, All->Contains( "a" ) );
			Expect(strings, Some->StartsWith( "ba" ) );
		}

		[Test]
		void SomeItemsTests()
		{
			array<Object^>^ mixed = { 1, 2, "3", nullptr, "four", 100 };
			array<Object^>^ strings = { "abc", "bad", "cab", "bad", "dad" };

			// Not available using the classic syntax

			// Helper syntax
			Assert::That(mixed, Has::Some->Null);
			Assert::That(mixed, Has::Some->InstanceOfType(int::typeid));
			Assert::That(mixed, Has::Some->InstanceOfType(String::typeid));
			Assert::That(mixed, Has::Some->GreaterThan(99));
			Assert::That(strings, Has::Some->StartsWith( "ba" ) );
			Assert::That(strings, Has::Some->Not->StartsWith( "ba" ) );
		
			// Inherited syntax
			Expect(mixed, Some->Null);
			Expect(mixed, Some->InstanceOfType(int::typeid));
			Expect(mixed, Some->InstanceOfType(String::typeid));
			Expect(mixed, Some->GreaterThan(99));
			Expect(strings, Some->StartsWith( "ba" ) );
			Expect(strings, Some->Not->StartsWith( "ba" ) );
		}

		[Test]
		void NoItemsTests()
		{
			array<Object^>^ ints = { 1, 2, 3, 4, 5 };
			array<Object^>^ strings = { "abc", "bad", "cab", "bad", "dad" };

			// Not available using the classic syntax

			// Helper syntax
			Assert::That(ints, Has::None->Null);
			Assert::That(ints, Has::None->InstanceOfType(String::typeid));
			Assert::That(ints, Has::None->GreaterThan(99));
			Assert::That(strings, Has::None->StartsWith( "qu" ) );
		
			// Inherited syntax
			Expect(ints, None->Null);
			Expect(ints, None->InstanceOfType(String::typeid));
			Expect(ints, None->GreaterThan(99));
			Expect(strings, None->StartsWith( "qu" ) );
		}

		[Test]
		void CollectionContainsTests()
		{
			array<int>^ iarray = { 1, 2, 3 };
			array<String^>^ sarray = { "a", "b", "c" };

			// Classic syntax
			Assert::Contains(3, iarray);
			Assert::Contains("b", sarray);
			CollectionAssert::Contains(iarray, 3);
			CollectionAssert::Contains(sarray, "b");
			CollectionAssert::DoesNotContain(sarray, "x");

			// Helper syntax
			Assert::That(iarray, List::Contains(3));
			Assert::That(sarray, List::Contains("b"));
			Assert::That(sarray, List::Not->Contains("x"));
		
			// Inherited syntax
			Expect(iarray, Contains(3));
			Expect(sarray, Contains("b"));
			Expect(sarray, Not->Contains("x"));
		}

		[Test]
		void CollectionEquivalenceTests()
		{
			array<int>^ ints1to5 = { 1, 2, 3, 4, 5 };

			// Classic syntax
			CollectionAssert::AreEquivalent(gcnew array<int> { 2, 1, 4, 3, 5 }, ints1to5);
			CollectionAssert::AreNotEquivalent(gcnew array<int> { 2, 2, 4, 3, 5 }, ints1to5);
			CollectionAssert::AreNotEquivalent(gcnew array<int> { 2, 4, 3, 5 }, ints1to5);
			CollectionAssert::AreEquivalent(gcnew array<int> { 2, 2, 1, 1, 4, 3, 5 }, ints1to5);
		
			// Helper syntax
			Assert::That(gcnew array<int> { 2, 1, 4, 3, 5 }, Is::EquivalentTo(ints1to5));
			Assert::That(gcnew array<int> { 2, 2, 4, 3, 5 }, Is::Not->EquivalentTo(ints1to5));
			Assert::That(gcnew array<int> { 2, 4, 3, 5 }, Is::Not->EquivalentTo(ints1to5));
			Assert::That(gcnew array<int> { 2, 2, 1, 1, 4, 3, 5 }, Is::EquivalentTo(ints1to5));

			// Inherited syntax
			Expect(gcnew array<int> { 2, 1, 4, 3, 5 }, EquivalentTo(ints1to5));
			Expect(gcnew array<int> { 2, 2, 4, 3, 5 }, Not->EquivalentTo(ints1to5));
			Expect(gcnew array<int> { 2, 4, 3, 5 }, Not->EquivalentTo(ints1to5));
			Expect(gcnew array<int> { 2, 2, 1, 1, 4, 3, 5 }, EquivalentTo(ints1to5));
		}

		[Test]
		void SubsetTests()
		{
			array<int>^ ints1to5 = { 1, 2, 3, 4, 5 };

			// Classic syntax
			CollectionAssert::IsSubsetOf(gcnew array<int> { 1, 3, 5 }, ints1to5);
			CollectionAssert::IsSubsetOf(gcnew array<int> { 1, 2, 3, 4, 5 }, ints1to5);
			CollectionAssert::IsNotSubsetOf(gcnew array<int> { 2, 4, 6 }, ints1to5);

			// Helper syntax
			Assert::That(gcnew array<int> { 1, 3, 5 }, Is::SubsetOf(ints1to5));
			Assert::That(gcnew array<int> { 1, 2, 3, 4, 5 }, Is::SubsetOf(ints1to5));
			Assert::That(gcnew array<int> { 2, 4, 6 }, Is::Not->SubsetOf(ints1to5));
		
			// Inherited syntax
			Expect(gcnew array<int> { 1, 3, 5 }, SubsetOf(ints1to5));
			Expect(gcnew array<int> { 1, 2, 3, 4, 5 }, SubsetOf(ints1to5));
			Expect(gcnew array<int> { 2, 4, 6 }, Not->SubsetOf(ints1to5));
		}

		[Test]
		void PropertyTests()
		{
			array<String^>^ strings = { "abc", "bca", "xyz" };

			// Helper syntax
			Assert::That( "Hello", Has::Property("Length", 5) );
			Assert::That( "Hello", Has::Length( 5 ) );
			Assert::That( strings , Has::All->Property( "Length", 3 ) );
			Assert::That( strings, Has::All->Length( 3 ) );

			// Inherited syntax
			Expect( "Hello", Property("Length", 5) );
			Expect( "Hello", Length( 5 ) );
			Expect( strings, All->Property("Length", 3 ) );
			Expect( strings, All->Length( 3 ) );
		}

		[Test]
		void NotTests()
		{
			// Not available using the classic syntax

			// Helper syntax
			Assert::That(42, Is::Not->Null);
			Assert::That(42, Is::Not->True);
			Assert::That(42, Is::Not->False);
			Assert::That(2.5, Is::Not->NaN);
			Assert::That(2 + 2, Is::Not->EqualTo(3));
			Assert::That(2 + 2, Is::Not->Not->EqualTo(4));
			Assert::That(2 + 2, Is::Not->Not->Not->EqualTo(5));

			// Inherited syntax
			Expect(42, Not->Null);
			Expect(42, Not->True);
			Expect(42, Not->False);
			Expect(2.5, Not->NaN);
			Expect(2 + 2, Not->EqualTo(3));
			Expect(2 + 2, Not->Not->EqualTo(4));
			Expect(2 + 2, Not->Not->Not->EqualTo(5));
		}

		[Test]
		void NotOperator()
		{
			// The ! operator is only available in the new syntax
			Assert::That(42, !Is::Null);
			// Inherited syntax
			Expect( 42, !Null );
		}

		[Test]
		void AndOperator()
		{
			// The & operator is only available in the new syntax
			Assert::That(7, Is::GreaterThan(5) & Is::LessThan(10));
			// Inherited syntax
			Expect( 7, GreaterThan(5) & LessThan(10));
		}

		[Test]
		void OrOperator()
		{
			// The | operator is only available in the new syntax
			Assert::That(3, Is::LessThan(5) | Is::GreaterThan(10));
			Expect( 3, LessThan(5) | GreaterThan(10));
		}

		[Test]
		void ComplexTests()
		{
			Assert::That(7, Is::Not->Null & Is::Not->LessThan(5) & Is::Not->GreaterThan(10));
			Expect(7, Not->Null & Not->LessThan(5) & Not->GreaterThan(10));

			Assert::That(7, !Is::Null & !Is::LessThan(5) & !Is::GreaterThan(10));
			Expect(7, !Null & !LessThan(5) & !GreaterThan(10));
		}

		// This method contains assertions that should not compile
		// You can check by uncommenting it.
		//void WillNotCompile()
		//{
		//    Assert::That(42, Is::Not);
		//    Assert::That(42, Is::All);
		//    Assert::That(42, Is::Null->Not);
		//    Assert::That(42, Is::Not->Null->GreaterThan(10));
		//    Assert::That(42, Is::GreaterThan(10)->LessThan(99));

		//    object[] c = new object[0];
		//    Assert::That(c, Is::Null->All);
		//    Assert::That(c, Is::Not->All);
		//    Assert::That(c, Is::All->Not);
		//}
	};
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.4.1\samples\cpp\managed\failures\cppsample.h ===
// ****************************************************************
// This is free software licensed under the NUnit license. You
// may obtain a copy of the license as well as information regarding
// copyright ownership at http://nunit.org/?p=license&r=2.4.
// ****************************************************************

#pragma once

using namespace System;
using namespace NUnit::Framework;

namespace NUnitSamples
{
	[TestFixture]
	public __gc class SimpleCPPSample
	{
		int fValue1;
		int fValue2;
	public:
		[SetUp] void Init();

		[Test] void Add();
		[Test] void DivideByZero();
		[Test] void Equals();
		[Test] [Ignore("ignored test")] void IgnoredTest();
		[Test] [ExpectedException(__typeof(InvalidOperationException))] void ExpectAnException();
	};
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.4.1\samples\cpp\managed\failures\cppsample.cpp ===
// ****************************************************************
// This is free software licensed under the NUnit license. You
// may obtain a copy of the license as well as information regarding
// copyright ownership at http://nunit.org/?p=license&r=2.4.
// ****************************************************************

#include "cppsample.h"

namespace NUnitSamples {

	void SimpleCPPSample::Init() {
		fValue1 = 2;
		fValue2 = 3;
	}

	void SimpleCPPSample::Add() {
		int result = fValue1 + fValue2;
		Assert::AreEqual(6,result);
	}

	void SimpleCPPSample::DivideByZero()
	{
		int zero= 0;
		int result= 8/zero;
	}

	void SimpleCPPSample::Equals() {
		Assert::AreEqual(12, 12, "Integer");
		Assert::AreEqual(12L, 12L, "Long");
		Assert::AreEqual('a', 'a', "Char");


		Assert::AreEqual(12, 13, "Expected Failure (Integer)");
		Assert::AreEqual(12.0, 11.99, 0.0, "Expected Failure (Double)");
	}

	void SimpleCPPSample::IgnoredTest()
	{
		throw new InvalidCastException();
	}

	void SimpleCPPSample::ExpectAnException()
	{
		throw new InvalidCastException();
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.4.1\samples\csharp\money\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("2.2.0.0")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.4.1\samples\cpp\managed\failures\AssemblyInfo.cpp ===
using namespace System::Reflection;
using namespace System::Runtime::CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitleAttribute("")];
[assembly:AssemblyDescriptionAttribute("")];
[assembly:AssemblyConfigurationAttribute("")];
[assembly:AssemblyCompanyAttribute("")];
[assembly:AssemblyProductAttribute("")];
[assembly:AssemblyCopyrightAttribute("")];
[assembly:AssemblyTrademarkAttribute("")];
[assembly:AssemblyCultureAttribute("")];		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the value or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly:AssemblyVersionAttribute("2.2.0.0")];

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//        When specifying the KeyFile, the location of the KeyFile should be
//        relative to the project directory.
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly:AssemblyDelaySignAttribute(false)];
[assembly:AssemblyKeyFileAttribute("")];
[assembly:AssemblyKeyNameAttribute("")];
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.4.1\samples\csharp\failures\CSharpTest.cs ===
// ****************************************************************
// This is free software licensed under the NUnit license. You
// may obtain a copy of the license as well as information regarding
// copyright ownership at http://nunit.org/?p=license&r=2.4.
// ****************************************************************

namespace NUnit.Samples 
{
	using System;
	using NUnit.Framework;

	/// <summary>Some simple Tests.</summary>
	/// 
	[TestFixture] 
	public class SimpleCSharpTest
	{
		/// <summary>
		/// 
		/// </summary>
		protected int fValue1;
		/// <summary>
		/// 
		/// </summary>
		protected int fValue2;
		
		/// <summary>
		/// 
		/// </summary>
		[SetUp] public void Init() 
		{
			fValue1= 2;
			fValue2= 3;
		}

		/// <summary>
		/// 
		/// </summary>
		///
		[Test] public void Add() 
		{
			double result= fValue1 + fValue2;
			// forced failure result == 5
			Assert.AreEqual(6, result, "Expected Failure.");
		}

		/// <summary>
		/// 
		/// </summary>
		/// 
		[Test] public void DivideByZero() 
		{
			int zero= 0;
			int result= 8/zero;
		}

		/// <summary>
		/// 
		/// </summary>
		/// 
		[Test] public void Equals() 
		{
			Assert.AreEqual(12, 12, "Integer");
			Assert.AreEqual(12L, 12L, "Long");
			Assert.AreEqual('a', 'a', "Char");
			Assert.AreEqual((object)12, (object)12, "Integer Object Cast");
            
			Assert.AreEqual(12, 13, "Expected Failure (Integer)");
			Assert.AreEqual(12.0, 11.99, 0.0, "Expected Failure (Double).");
		}

		[Test]
		[ExpectedException(typeof(InvalidOperationException))]
		public void ExpectAnException()
		{
			throw new InvalidCastException();
		}

		[Test]
		[Ignore("ignored test")]
		public void IgnoredTest()
		{
			throw new Exception();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.4.1\samples\csharp\money-port\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("2.2.0.0")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.4.1\samples\csharp\money\MoneyBag.cs ===
// ****************************************************************
// This is free software licensed under the NUnit license. You
// may obtain a copy of the license as well as information regarding
// copyright ownership at http://nunit.org/?p=license&r=2.4.
// ****************************************************************

namespace NUnit.Samples.Money 
{

	using System;
	using System.Collections;
	using System.Text;

	/// <summary>A MoneyBag defers exchange rate conversions.</summary>
	/// <remarks>For example adding 
	/// 12 Swiss Francs to 14 US Dollars is represented as a bag 
	/// containing the two Monies 12 CHF and 14 USD. Adding another
	/// 10 Swiss francs gives a bag with 22 CHF and 14 USD. Due to 
	/// the deferred exchange rate conversion we can later value a 
	/// MoneyBag with different exchange rates.
	///
	/// A MoneyBag is represented as a list of Monies and provides 
	/// different constructors to create a MoneyBag.</remarks>
	class MoneyBag: IMoney 
	{
		private ArrayList fMonies= new ArrayList(5);

		private MoneyBag() 
		{
		}
		public MoneyBag(Money[] bag) 
		{
			for (int i= 0; i < bag.Length; i++) 
			{
				if (!bag[i].IsZero)
					AppendMoney(bag[i]);
			}
		}
		public MoneyBag(Money m1, Money m2) 
		{
			AppendMoney(m1);
			AppendMoney(m2);
		}
		public MoneyBag(Money m, MoneyBag bag) 
		{
			AppendMoney(m);
			AppendBag(bag);
		}
		public MoneyBag(MoneyBag m1, MoneyBag m2) 
		{
			AppendBag(m1);
			AppendBag(m2);
		}
		public IMoney Add(IMoney m) 
		{
			return m.AddMoneyBag(this);
		}
		public IMoney AddMoney(Money m) 
		{
			return (new MoneyBag(m, this)).Simplify();
		}
		public IMoney AddMoneyBag(MoneyBag s) 
		{
			return (new MoneyBag(s, this)).Simplify();
		}
		private void AppendBag(MoneyBag aBag) 
		{
			foreach (Money m in aBag.fMonies)
				AppendMoney(m);
		}
		private void AppendMoney(Money aMoney) 
		{
			IMoney old= FindMoney(aMoney.Currency);
			if (old == null) 
			{
				fMonies.Add(aMoney);
				return;
			}
			fMonies.Remove(old);
			IMoney sum= old.Add(aMoney);
			if (sum.IsZero) 
				return;
			fMonies.Add(sum);
		}
		private bool Contains(Money aMoney) 
		{
			Money m= FindMoney(aMoney.Currency);
			return m.Amount == aMoney.Amount;
		}
		public override bool Equals(Object anObject) 
		{
			if (IsZero)
				if (anObject is IMoney)
					return ((IMoney)anObject).IsZero;
            
			if (anObject is MoneyBag) 
			{
				MoneyBag aMoneyBag= (MoneyBag)anObject;
				if (aMoneyBag.fMonies.Count != fMonies.Count)
					return false;
                
				foreach (Money m in fMonies) 
				{
					if (!aMoneyBag.Contains(m))
						return false;
				}
				return true;
			}
			return false;
		}
		private Money FindMoney(String currency) 
		{
			foreach (Money m in fMonies) 
			{
				if (m.Currency.Equals(currency))
					return m;
			}
			return null;
		}
		public override int GetHashCode() 
		{
			int hash= 0;
			foreach (Money m in fMonies) 
			{
				hash^= m.GetHashCode();
			}
			return hash;
		}
		public bool IsZero 
		{
			get { return fMonies.Count == 0; }
		}
		public IMoney Multiply(int factor) 
		{
			MoneyBag result= new MoneyBag();
			if (factor != 0) 
			{
				foreach (Money m in fMonies) 
				{
					result.AppendMoney((Money)m.Multiply(factor));
				}
			}
			return result;
		}
		public IMoney Negate() 
		{
			MoneyBag result= new MoneyBag();
			foreach (Money m in fMonies) 
			{
				result.AppendMoney((Money)m.Negate());
			}
			return result;
		}
		private IMoney Simplify() 
		{
			if (fMonies.Count == 1)
				return (IMoney)fMonies[0];
			return this;
		}
		public IMoney Subtract(IMoney m) 
		{
			return Add(m.Negate());
		}
		public override String ToString() 
		{
			StringBuilder buffer = new StringBuilder();
			buffer.Append("{");
			foreach (Money m in fMonies)
				buffer.Append(m);
			buffer.Append("}");
			return buffer.ToString();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.4.1\samples\csharp\money\IMoney.cs ===
// ****************************************************************
// This is free software licensed under the NUnit license. You
// may obtain a copy of the license as well as information regarding
// copyright ownership at http://nunit.org/?p=license&r=2.4.
// ****************************************************************

namespace NUnit.Samples.Money 
{

	/// <summary>The common interface for simple Monies and MoneyBags.</summary>
	interface IMoney 
	{

		/// <summary>Adds a money to this money.</summary>
		IMoney Add(IMoney m);

		/// <summary>Adds a simple Money to this money. This is a helper method for
		/// implementing double dispatch.</summary>
		IMoney AddMoney(Money m);

		/// <summary>Adds a MoneyBag to this money. This is a helper method for
		/// implementing double dispatch.</summary>
		IMoney AddMoneyBag(MoneyBag s);

		/// <value>True if this money is zero.</value>
		bool IsZero { get; }

		/// <summary>Multiplies a money by the given factor.</summary>
		IMoney Multiply(int factor);

		/// <summary>Negates this money.</summary>
		IMoney Negate();

		/// <summary>Subtracts a money from this money.</summary>
		IMoney Subtract(IMoney m);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.4.1\samples\csharp\syntax\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.4.1\samples\csharp\money\Money.cs ===
// ****************************************************************
// This is free software licensed under the NUnit license. You
// may obtain a copy of the license as well as information regarding
// copyright ownership at http://nunit.org/?p=license&r=2.4.
// ****************************************************************

namespace NUnit.Samples.Money 
{

	using System;
	using System.Text;

	/// <summary>A simple Money.</summary>
	class Money: IMoney 
	{

		private int fAmount;
		private String fCurrency;
        
		/// <summary>Constructs a money from the given amount and
		/// currency.</summary>
		public Money(int amount, String currency) 
		{
			fAmount= amount;
			fCurrency= currency;
		}

		/// <summary>Adds a money to this money. Forwards the request to
		/// the AddMoney helper.</summary>
		public IMoney Add(IMoney m) 
		{
			return m.AddMoney(this);
		}

		public IMoney AddMoney(Money m) 
		{
			if (m.Currency.Equals(Currency) )
				return new Money(Amount+m.Amount, Currency);
			return new MoneyBag(this, m);
		}

		public IMoney AddMoneyBag(MoneyBag s) 
		{
			return s.AddMoney(this);
		}

		public int Amount 
		{
			get { return fAmount; }
		}

		public String Currency 
		{
			get { return fCurrency; }
		}

		public override bool Equals(Object anObject) 
		{
			if (IsZero)
				if (anObject is IMoney)
					return ((IMoney)anObject).IsZero;
			if (anObject is Money) 
			{
				Money aMoney= (Money)anObject;
				return aMoney.Currency.Equals(Currency)
					&& Amount == aMoney.Amount;
			}
			return false;
		}

		public override int GetHashCode() 
		{
			return fCurrency.GetHashCode()+fAmount;
		}

		public bool IsZero 
		{
			get { return Amount == 0; }
		}

		public IMoney Multiply(int factor) 
		{
			return new Money(Amount*factor, Currency);
		}

		public IMoney Negate() 
		{
			return new Money(-Amount, Currency);
		}

		public IMoney Subtract(IMoney m) 
		{
			return Add(m.Negate());
		}

		public override String ToString() 
		{
			StringBuilder buffer = new StringBuilder();
			buffer.Append("["+Amount+" "+Currency+"]");
			return buffer.ToString();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.4.1\samples\csharp\money-port\IMoney.cs ===
// ****************************************************************
// This is free software licensed under the NUnit license. You
// may obtain a copy of the license as well as information regarding
// copyright ownership at http://nunit.org/?p=license&r=2.4.
// ****************************************************************

namespace NUnit.Samples.Money 
{

  /// <summary>The common interface for simple Monies and MoneyBags.</summary>
  interface IMoney {

    /// <summary>Adds a money to this money.</summary>
    IMoney Add(IMoney m);

    /// <summary>Adds a simple Money to this money. This is a helper method for
    /// implementing double dispatch.</summary>
    IMoney AddMoney(Money m);

    /// <summary>Adds a MoneyBag to this money. This is a helper method for
    /// implementing double dispatch.</summary>
    IMoney AddMoneyBag(MoneyBag s);

    /// <value>True if this money is zero.</value>
    bool IsZero { get; }

    /// <summary>Multiplies a money by the given factor.</summary>
    IMoney Multiply(int factor);

    /// <summary>Negates this money.</summary>
    IMoney Negate();

    /// <summary>Subtracts a money from this money.</summary>
    IMoney Subtract(IMoney m);
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.4.1\samples\Extensibility\Core\MaxTimeDecorator\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.4.1\samples\csharp\money-port\Money.cs ===
// ****************************************************************
// This is free software licensed under the NUnit license. You
// may obtain a copy of the license as well as information regarding
// copyright ownership at http://nunit.org/?p=license&r=2.4.
// ****************************************************************

namespace NUnit.Samples.Money 
{

  using System;
  using System.Text;

  /// <summary>A simple Money.</summary>
  class Money: IMoney {

    private int fAmount;
    private String fCurrency;
        
    /// <summary>Constructs a money from the given amount and
    /// currency.</summary>
    public Money(int amount, String currency) {
      fAmount= amount;
      fCurrency= currency;
    }

    /// <summary>Adds a money to this money. Forwards the request to
    /// the AddMoney helper.</summary>
    public IMoney Add(IMoney m) {
      return m.AddMoney(this);
    }

    public IMoney AddMoney(Money m) {
      if (m.Currency.Equals(Currency) )
        return new Money(Amount+m.Amount, Currency);
      return new MoneyBag(this, m);
    }

    public IMoney AddMoneyBag(MoneyBag s) {
      return s.AddMoney(this);
    }

    public int Amount {
      get { return fAmount; }
    }

    public String Currency {
      get { return fCurrency; }
    }

    public override bool Equals(Object anObject) {
      if (IsZero)
        if (anObject is IMoney)
          return ((IMoney)anObject).IsZero;
      if (anObject is Money) {
        Money aMoney= (Money)anObject;
        return aMoney.Currency.Equals(Currency)
          && Amount == aMoney.Amount;
      }
      return false;
    }

    public override int GetHashCode() {
      return fCurrency.GetHashCode()+fAmount;
    }

    public bool IsZero {
      get { return Amount == 0; }
    }

    public IMoney Multiply(int factor) {
      return new Money(Amount*factor, Currency);
    }

    public IMoney Negate() {
      return new Money(-Amount, Currency);
    }

    public IMoney Subtract(IMoney m) {
      return Add(m.Negate());
    }

    public override String ToString() {
      StringBuilder buffer = new StringBuilder();
      buffer.Append("["+Amount+" "+Currency+"]");
      return buffer.ToString();
    }
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.4.1\samples\csharp\money\MoneyTest.cs ===
// ****************************************************************
// This is free software licensed under the NUnit license. You
// may obtain a copy of the license as well as information regarding
// copyright ownership at http://nunit.org/?p=license&r=2.4.
// ****************************************************************

namespace NUnit.Samples.Money 
{
	using System;
	using NUnit.Framework;
	/// <summary>
	/// 
	/// </summary>
	/// 
	[TestFixture]
	public class MoneyTest 
	{
		private Money f12CHF;
		private Money f14CHF;
		private Money f7USD;
		private Money f21USD;
        
		private MoneyBag fMB1;
		private MoneyBag fMB2;

		/// <summary>
		/// 
		/// </summary>
		/// 
		[SetUp]
		protected void SetUp() 
		{
			f12CHF= new Money(12, "CHF");
			f14CHF= new Money(14, "CHF");
			f7USD= new Money( 7, "USD");
			f21USD= new Money(21, "USD");

			fMB1= new MoneyBag(f12CHF, f7USD);
			fMB2= new MoneyBag(f14CHF, f21USD);
		}

		/// <summary>
		/// 
		/// </summary>
		/// 
		[Test]
		public void BagMultiply() 
		{
			// {[12 CHF][7 USD]} *2 == {[24 CHF][14 USD]}
			Money[] bag = { new Money(24, "CHF"), new Money(14, "USD") };
			MoneyBag expected= new MoneyBag(bag);
			Assert.AreEqual(expected, fMB1.Multiply(2));
			Assert.AreEqual(fMB1, fMB1.Multiply(1));
			Assert.IsTrue(fMB1.Multiply(0).IsZero);
		}

		/// <summary>
		/// 
		/// </summary>
		/// 
		[Test]
		public void BagNegate() 
		{
			// {[12 CHF][7 USD]} negate == {[-12 CHF][-7 USD]}
			Money[] bag= { new Money(-12, "CHF"), new Money(-7, "USD") };
			MoneyBag expected= new MoneyBag(bag);
			Assert.AreEqual(expected, fMB1.Negate());
		}

		/// <summary>
		/// 
		/// </summary>
		/// 
		[Test]
		public void BagSimpleAdd() 
		{
			// {[12 CHF][7 USD]} + [14 CHF] == {[26 CHF][7 USD]}
			Money[] bag= { new Money(26, "CHF"), new Money(7, "USD") };
			MoneyBag expected= new MoneyBag(bag);
			Assert.AreEqual(expected, fMB1.Add(f14CHF));
		}

		/// <summary>
		/// 
		/// </summary>
		/// 
		[Test]
		public void BagSubtract() 
		{
			// {[12 CHF][7 USD]} - {[14 CHF][21 USD] == {[-2 CHF][-14 USD]}
			Money[] bag= { new Money(-2, "CHF"), new Money(-14, "USD") };
			MoneyBag expected= new MoneyBag(bag);
			Assert.AreEqual(expected, fMB1.Subtract(fMB2));
		}

		/// <summary>
		/// 
		/// </summary>
		/// 
		[Test]
		public void BagSumAdd() 
		{
			// {[12 CHF][7 USD]} + {[14 CHF][21 USD]} == {[26 CHF][28 USD]}
			Money[] bag= { new Money(26, "CHF"), new Money(28, "USD") };
			MoneyBag expected= new MoneyBag(bag);
			Assert.AreEqual(expected, fMB1.Add(fMB2));
		}

		/// <summary>
		/// 
		/// </summary>
		/// 
		[Test]
		public void IsZero() 
		{
			Assert.IsTrue(fMB1.Subtract(fMB1).IsZero);

			Money[] bag = { new Money(0, "CHF"), new Money(0, "USD") };
			Assert.IsTrue(new MoneyBag(bag).IsZero);
		}

		/// <summary>
		/// 
		/// </summary>
		/// 
		[Test]
		public void MixedSimpleAdd() 
		{
			// [12 CHF] + [7 USD] == {[12 CHF][7 USD]}
			Money[] bag= { f12CHF, f7USD };
			MoneyBag expected= new MoneyBag(bag);
			Assert.AreEqual(expected, f12CHF.Add(f7USD));
		}

		/// <summary>
		/// 
		/// </summary>
		/// 
		[Test]
		public void MoneyBagEquals() 
		{
			//NOTE: Normally we use Assert.AreEqual to test whether two
			// objects are equal. But here we are testing the MoneyBag.Equals()
			// method itself, so using AreEqual would not serve the purpose.
			Assert.IsFalse(fMB1.Equals(null)); 

			Assert.IsTrue(fMB1.Equals( fMB1 ));
			MoneyBag equal= new MoneyBag(new Money(12, "CHF"), new Money(7, "USD"));
			Assert.IsTrue(fMB1.Equals(equal));
			Assert.IsTrue(!fMB1.Equals(f12CHF));
			Assert.IsTrue(!f12CHF.Equals(fMB1));
			Assert.IsTrue(!fMB1.Equals(fMB2));
		}

		/// <summary>
		/// 
		/// </summary>
		/// 
		[Test]
		public void MoneyBagHash() 
		{
			MoneyBag equal= new MoneyBag(new Money(12, "CHF"), new Money(7, "USD"));
			Assert.AreEqual(fMB1.GetHashCode(), equal.GetHashCode());
		}

		/// <summary>
		/// 
		/// </summary>
		/// 
		[Test]
		public void MoneyEquals() 
		{
			//NOTE: Normally we use Assert.AreEqual to test whether two
			// objects are equal. But here we are testing the MoneyBag.Equals()
			// method itself, so using AreEqual would not serve the purpose.
			Assert.IsFalse(f12CHF.Equals(null)); 
			Money equalMoney= new Money(12, "CHF");
			Assert.IsTrue(f12CHF.Equals( f12CHF ));
			Assert.IsTrue(f12CHF.Equals( equalMoney ));
			Assert.IsFalse(f12CHF.Equals(f14CHF));
		}

		/// <summary>
		/// 
		/// </summary>
		/// 
		[Test]
		public void MoneyHash() 
		{
			Assert.IsFalse(f12CHF.Equals(null)); 
			Money equal= new Money(12, "CHF");
			Assert.AreEqual(f12CHF.GetHashCode(), equal.GetHashCode());
		}

		/// <summary>
		/// 
		/// </summary>
		/// 
		[Test]
		public void Normalize() 
		{
			Money[] bag= { new Money(26, "CHF"), new Money(28, "CHF"), new Money(6, "CHF") };
			MoneyBag moneyBag= new MoneyBag(bag);
			Money[] expected = { new Money(60, "CHF") };
			// note: expected is still a MoneyBag
			MoneyBag expectedBag= new MoneyBag(expected);
			Assert.AreEqual(expectedBag, moneyBag);
		}

		/// <summary>
		/// 
		/// </summary>
		/// 
		[Test]
		public void Normalize2() 
		{
			// {[12 CHF][7 USD]} - [12 CHF] == [7 USD]
			Money expected= new Money(7, "USD");
			Assert.AreEqual(expected, fMB1.Subtract(f12CHF));
		}

		/// <summary>
		/// 
		/// </summary>
		/// 
		[Test]
		public void Normalize3() 
		{
			// {[12 CHF][7 USD]} - {[12 CHF][3 USD]} == [4 USD]
			Money[] s1 = { new Money(12, "CHF"), new Money(3, "USD") };
			MoneyBag ms1= new MoneyBag(s1);
			Money expected= new Money(4, "USD");
			Assert.AreEqual(expected, fMB1.Subtract(ms1));
		}

		/// <summary>
		/// 
		/// </summary>
		/// 
		[Test]
		public void Normalize4() 
		{
			// [12 CHF] - {[12 CHF][3 USD]} == [-3 USD]
			Money[] s1 = { new Money(12, "CHF"), new Money(3, "USD") };
			MoneyBag ms1= new MoneyBag(s1);
			Money expected= new Money(-3, "USD");
			Assert.AreEqual(expected, f12CHF.Subtract(ms1));
		}

		/// <summary>
		/// 
		/// </summary>
		/// 
		[Test]
		public void Print() 
		{
			Assert.AreEqual("[12 CHF]", f12CHF.ToString());
		}

		/// <summary>
		/// 
		/// </summary>
		/// 
		[Test]
		public void SimpleAdd() 
		{
			// [12 CHF] + [14 CHF] == [26 CHF]
			Money expected= new Money(26, "CHF");
			Assert.AreEqual(expected, f12CHF.Add(f14CHF));
		}

		/// <summary>
		/// 
		/// </summary>
		/// 
		[Test]
		public void SimpleBagAdd() 
		{
			// [14 CHF] + {[12 CHF][7 USD]} == {[26 CHF][7 USD]}
			Money[] bag= { new Money(26, "CHF"), new Money(7, "USD") };
			MoneyBag expected= new MoneyBag(bag);
			Assert.AreEqual(expected, f14CHF.Add(fMB1));
		}

		/// <summary>
		/// 
		/// </summary>
		/// 
		[Test]
		public void SimpleMultiply() 
		{
			// [14 CHF] *2 == [28 CHF]
			Money expected= new Money(28, "CHF");
			Assert.AreEqual(expected, f14CHF.Multiply(2));
		}

		/// <summary>
		/// 
		/// </summary>
		/// 
		[Test]
		public void SimpleNegate() 
		{
			// [14 CHF] negate == [-14 CHF]
			Money expected= new Money(-14, "CHF");
			Assert.AreEqual(expected, f14CHF.Negate());
		}

		/// <summary>
		/// 
		/// </summary>
		/// 
		[Test]
		public void SimpleSubtract() 
		{
			// [14 CHF] - [12 CHF] == [2 CHF]
			Money expected= new Money(2, "CHF");
			Assert.AreEqual(expected, f14CHF.Subtract(f12CHF));
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.4.1\samples\csharp\money-port\MoneyBag.cs ===
// ****************************************************************
// This is free software licensed under the NUnit license. You
// may obtain a copy of the license as well as information regarding
// copyright ownership at http://nunit.org/?p=license&r=2.4.
// ****************************************************************

namespace NUnit.Samples.Money 
{

  using System;
  using System.Collections;
  using System.Text;

  /// <summary>A MoneyBag defers exchange rate conversions.</summary>
  /// <remarks>For example adding 
  /// 12 Swiss Francs to 14 US Dollars is represented as a bag 
  /// containing the two Monies 12 CHF and 14 USD. Adding another
  /// 10 Swiss francs gives a bag with 22 CHF and 14 USD. Due to 
  /// the deferred exchange rate conversion we can later value a 
  /// MoneyBag with different exchange rates.
  ///
  /// A MoneyBag is represented as a list of Monies and provides 
  /// different constructors to create a MoneyBag.</remarks>
  class MoneyBag: IMoney {
    private ArrayList fMonies= new ArrayList(5);

    private MoneyBag() {
    }
    public MoneyBag(Money[] bag) {
      for (int i= 0; i < bag.Length; i++) {
        if (!bag[i].IsZero)
          AppendMoney(bag[i]);
      }
    }
    public MoneyBag(Money m1, Money m2) {
      AppendMoney(m1);
      AppendMoney(m2);
    }
    public MoneyBag(Money m, MoneyBag bag) {
      AppendMoney(m);
      AppendBag(bag);
    }
    public MoneyBag(MoneyBag m1, MoneyBag m2) {
      AppendBag(m1);
      AppendBag(m2);
    }
    public IMoney Add(IMoney m) {
      return m.AddMoneyBag(this);
    }
    public IMoney AddMoney(Money m) {
      return (new MoneyBag(m, this)).Simplify();
    }
    public IMoney AddMoneyBag(MoneyBag s) {
      return (new MoneyBag(s, this)).Simplify();
    }
    private void AppendBag(MoneyBag aBag) {
      foreach (Money m in aBag.fMonies)
        AppendMoney(m);
    }
    private void AppendMoney(Money aMoney) {
      IMoney old= FindMoney(aMoney.Currency);
      if (old == null) {
        fMonies.Add(aMoney);
        return;
      }
      fMonies.Remove(old);
      IMoney sum= old.Add(aMoney);
      if (sum.IsZero) 
        return;
      fMonies.Add(sum);
    }
    private bool Contains(Money aMoney) {
      Money m= FindMoney(aMoney.Currency);
      return m.Amount == aMoney.Amount;
    }
    public override bool Equals(Object anObject) {
      if (IsZero)
        if (anObject is IMoney)
          return ((IMoney)anObject).IsZero;
            
      if (anObject is MoneyBag) {
        MoneyBag aMoneyBag= (MoneyBag)anObject;
        if (aMoneyBag.fMonies.Count != fMonies.Count)
          return false;
                
        foreach (Money m in fMonies) {
          if (!aMoneyBag.Contains(m))
            return false;
        }
        return true;
      }
      return false;
    }
    private Money FindMoney(String currency) {
      foreach (Money m in fMonies) {
        if (m.Currency.Equals(currency))
          return m;
      }
      return null;
    }
    public override int GetHashCode() {
      int hash= 0;
      foreach (Money m in fMonies) {
        hash^= m.GetHashCode();
      }
      return hash;
    }
    public bool IsZero {
      get { return fMonies.Count == 0; }
    }
    public IMoney Multiply(int factor) {
      MoneyBag result= new MoneyBag();
      if (factor != 0) {
        foreach (Money m in fMonies) {
          result.AppendMoney((Money)m.Multiply(factor));
        }
      }
      return result;
    }
    public IMoney Negate() {
      MoneyBag result= new MoneyBag();
      foreach (Money m in fMonies) {
        result.AppendMoney((Money)m.Negate());
      }
      return result;
    }
    private IMoney Simplify() {
      if (fMonies.Count == 1)
        return (IMoney)fMonies[0];
      return this;
    }
    public IMoney Subtract(IMoney m) {
      return Add(m.Negate());
    }
    public override String ToString() {
      StringBuilder buffer = new StringBuilder();
      buffer.Append("{");
      foreach (Money m in fMonies)
        buffer.Append(m);
      buffer.Append("}");
      return buffer.ToString();
    }
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.4.1\samples\csharp\syntax\AssertSyntaxTests.cs ===
// ****************************************************************
// Copyright 2007, Charlie Poole
// This is free software licensed under the NUnit license. You may
// obtain a copy of the license at http://nunit.org/?p=license&r=2.4
// ****************************************************************

using System;
using NUnit.Framework.Constraints;
using NUnit.Framework.SyntaxHelpers;

namespace NUnit.Framework.Tests
{
	/// <summary>
	/// This test fixture attempts to exercise all the syntactic
	/// variations of Assert without getting into failures, errors 
	/// or corner cases. Thus, some of the tests may be duplicated 
	/// in other fixtures.
	/// 
	/// Each test performs the same operations using the classic
	/// syntax (if available) and the new syntax in both the
	/// helper-based and inherited forms.
	/// 
	/// This Fixture will eventually be duplicated in other
	/// supported languages. 
	/// </summary>
	[TestFixture]
	public class AssertSyntaxTests : AssertionHelper
	{
		[Test]
		public void IsNull()
		{
			// Classic syntax
			Assert.IsNull(null);

			// Helper syntax
			Assert.That(null, Is.Null);

			// Inherited syntax
			Expect(null, Null);
		}

		[Test]
		public void IsNotNull()
		{
			// Classic syntax
			Assert.IsNotNull(42);

			// Helper syntax
			Assert.That(42, Is.Not.Null);

			// Inherited syntax
			Expect( 42, Not.Null );
		}

		[Test]
		public void IsTrue()
		{
			// Classic syntax
			Assert.IsTrue(2+2==4);

			// Helper syntax
			Assert.That(2+2==4, Is.True);
			Assert.That(2+2==4);

			// Inherited syntax
			Expect(2+2==4, True);
			Expect(2+2==4);
		}

		[Test]
		public void IsFalse()
		{
			// Classic syntax
			Assert.IsFalse(2+2==5);

			// Helper syntax
			Assert.That(2+2== 5, Is.False);
			
			// Inherited syntax
			Expect(2+2==5, False);
		}

		[Test]
		public void IsNaN()
		{
			double d = double.NaN;
			float f = float.NaN;

			// Classic syntax
			Assert.IsNaN(d);
			Assert.IsNaN(f);

			// Helper syntax
			Assert.That(d, Is.NaN);
			Assert.That(f, Is.NaN);
			
			// Inherited syntax
			Expect(d, NaN);
			Expect(f, NaN);
		}

		[Test]
		public void EmptyStringTests()
		{
			// Classic syntax
			Assert.IsEmpty("");
			Assert.IsNotEmpty("Hello!");

			// Helper syntax
			Assert.That("", Is.Empty);
			Assert.That("Hello!", Is.Not.Empty);

			// Inherited syntax
			Expect("", Empty);
			Expect("Hello!", Not.Empty);
		}

		[Test]
		public void EmptyCollectionTests()
		{
			// Classic syntax
			Assert.IsEmpty(new bool[0]);
			Assert.IsNotEmpty(new int[] { 1, 2, 3 });

			// Helper syntax
			Assert.That(new bool[0], Is.Empty);
			Assert.That(new int[] { 1, 2, 3 }, Is.Not.Empty);

			// Inherited syntax
			Expect(new bool[0], Empty);
			Expect(new int[] { 1, 2, 3 }, Not.Empty);
		}

		[Test]
		public void ExactTypeTests()
		{
			// Classic syntax workarounds
			Assert.AreEqual(typeof(string), "Hello".GetType());
			Assert.AreEqual("System.String", "Hello".GetType().FullName);
			Assert.AreNotEqual(typeof(int), "Hello".GetType());
			Assert.AreNotEqual("System.Int32", "Hello".GetType().FullName);

			// Helper syntax
			Assert.That("Hello", Is.TypeOf(typeof(string)));
			Assert.That("Hello", Is.Not.TypeOf(typeof(int)));
			
			// Inherited syntax
			Expect( "Hello", TypeOf(typeof(string)));
			Expect( "Hello", Not.TypeOf(typeof(int)));
		}

		[Test]
		public void InstanceOfTypeTests()
		{
			// Classic syntax
			Assert.IsInstanceOfType(typeof(string), "Hello");
			Assert.IsNotInstanceOfType(typeof(string), 5);

			// Helper syntax
			Assert.That("Hello", Is.InstanceOfType(typeof(string)));
			Assert.That(5, Is.Not.InstanceOfType(typeof(string)));

			// Inherited syntax
			Expect("Hello", InstanceOfType(typeof(string)));
			Expect(5, Not.InstanceOfType(typeof(string)));
		}

		[Test]
		public void AssignableFromTypeTests()
		{
			// Classic syntax
			Assert.IsAssignableFrom(typeof(string), "Hello");
			Assert.IsNotAssignableFrom(typeof(string), 5);

			// Helper syntax
			Assert.That( "Hello", Is.AssignableFrom(typeof(string)));
			Assert.That( 5, Is.Not.AssignableFrom(typeof(string)));
			
			// Inherited syntax
			Expect( "Hello", AssignableFrom(typeof(string)));
			Expect( 5, Not.AssignableFrom(typeof(string)));
		}

		[Test]
		public void SubstringTests()
		{
			string phrase = "Hello World!";
			string[] array = new string[] { "abc", "bad", "dba" };
			
			// Classic Syntax
			StringAssert.Contains("World", phrase);
			
			// Helper syntax
			Assert.That(phrase, Text.Contains("World"));
			// Only available using new syntax
			Assert.That(phrase, Text.DoesNotContain("goodbye"));
			Assert.That(phrase, Text.Contains("WORLD").IgnoreCase);
			Assert.That(phrase, Text.DoesNotContain("BYE").IgnoreCase);
			Assert.That(array, Text.All.Contains( "b" ) );

			// Inherited syntax
			Expect(phrase, Contains("World"));
			// Only available using new syntax
			Expect(phrase, Not.Contains("goodbye"));
			Expect(phrase, Contains("WORLD").IgnoreCase);
			Expect(phrase, Not.Contains("BYE").IgnoreCase);
			Expect(array, All.Contains("b"));
		}

		[Test]
		public void StartsWithTests()
		{
			string phrase = "Hello World!";
			string[] greetings = new string[] { "Hello!", "Hi!", "Hola!" };

			// Classic syntax
			StringAssert.StartsWith("Hello", phrase);

			// Helper syntax
			Assert.That(phrase, Text.StartsWith("Hello"));
			// Only available using new syntax
			Assert.That(phrase, Text.DoesNotStartWith("Hi!"));
			Assert.That(phrase, Text.StartsWith("HeLLo").IgnoreCase);
			Assert.That(phrase, Text.DoesNotStartWith("HI").IgnoreCase);
			Assert.That(greetings, Text.All.StartsWith("h").IgnoreCase);

			// Inherited syntax
			Expect(phrase, StartsWith("Hello"));
			// Only available using new syntax
			Expect(phrase, Not.StartsWith("Hi!"));
			Expect(phrase, StartsWith("HeLLo").IgnoreCase);
			Expect(phrase, Not.StartsWith("HI").IgnoreCase);
			Expect(greetings, All.StartsWith("h").IgnoreCase);
		}

		[Test]
		public void EndsWithTests()
		{
			string phrase = "Hello World!";
			string[] greetings = new string[] { "Hello!", "Hi!", "Hola!" };

			// Classic Syntax
			StringAssert.EndsWith("!", phrase);

			// Helper syntax
			Assert.That(phrase, Text.EndsWith("!"));
			// Only available using new syntax
			Assert.That(phrase, Text.DoesNotEndWith("?"));
			Assert.That(phrase, Text.EndsWith("WORLD!").IgnoreCase);
			Assert.That(greetings, Text.All.EndsWith("!"));
		
			// Inherited syntax
			Expect(phrase, EndsWith("!"));
			// Only available using new syntax
			Expect(phrase, Not.EndsWith("?"));
			Expect(phrase, EndsWith("WORLD!").IgnoreCase);
			Expect(greetings, All.EndsWith("!") );
		}

		[Test]
		public void EqualIgnoringCaseTests()
		{
			string phrase = "Hello World!";

			// Classic syntax
			StringAssert.AreEqualIgnoringCase("hello world!",phrase);
            
			// Helper syntax
			Assert.That(phrase, Is.EqualTo("hello world!").IgnoreCase);
			//Only available using new syntax
			Assert.That(phrase, Is.Not.EqualTo("goodbye world!").IgnoreCase);
			Assert.That(new string[] { "Hello", "World" }, 
				Is.EqualTo(new object[] { "HELLO", "WORLD" }).IgnoreCase);
			Assert.That(new string[] {"HELLO", "Hello", "hello" },
				Is.All.EqualTo( "hello" ).IgnoreCase);
		            
			// Inherited syntax
			Expect(phrase, EqualTo("hello world!").IgnoreCase);
			//Only available using new syntax
			Expect(phrase, Not.EqualTo("goodbye world!").IgnoreCase);
			Expect(new string[] { "Hello", "World" }, 
				EqualTo(new object[] { "HELLO", "WORLD" }).IgnoreCase);
			Expect(new string[] {"HELLO", "Hello", "hello" },
				All.EqualTo( "hello" ).IgnoreCase);
		}

		[Test]
		public void RegularExpressionTests()
		{
			string phrase = "Now is the time for all good men to come to the aid of their country.";
			string[] quotes = new string[] { "Never say never", "It's never too late", "Nevermore!" };

			// Classic syntax
			StringAssert.IsMatch( "all good men", phrase );
			StringAssert.IsMatch( "Now.*come", phrase );

			// Helper syntax
			Assert.That( phrase, Text.Matches( "all good men" ) );
			Assert.That( phrase, Text.Matches( "Now.*come" ) );
			// Only available using new syntax
			Assert.That(phrase, Text.DoesNotMatch("all.*men.*good"));
			Assert.That(phrase, Text.Matches("ALL").IgnoreCase);
			Assert.That(quotes, Text.All.Matches("never").IgnoreCase);
		
			// Inherited syntax
			Expect( phrase, Matches( "all good men" ) );
			Expect( phrase, Matches( "Now.*come" ) );
			// Only available using new syntax
			Expect(phrase, Not.Matches("all.*men.*good"));
			Expect(phrase, Matches("ALL").IgnoreCase);
			Expect(quotes, All.Matches("never").IgnoreCase);
		}

		[Test]
		public void EqualityTests()
		{
			int[] i3 = new int[] { 1, 2, 3 };
			double[] d3 = new double[] { 1.0, 2.0, 3.0 };
			int[] iunequal = new int[] { 1, 3, 2 };

			// Classic Syntax
			Assert.AreEqual(4, 2 + 2);
			Assert.AreEqual(i3, d3);
			Assert.AreNotEqual(5, 2 + 2);
			Assert.AreNotEqual(i3, iunequal);

			// Helper syntax
			Assert.That(2 + 2, Is.EqualTo(4));
			Assert.That(2 + 2 == 4);
			Assert.That(i3, Is.EqualTo(d3));
			Assert.That(2 + 2, Is.Not.EqualTo(5));
			Assert.That(i3, Is.Not.EqualTo(iunequal));
		
			// Inherited syntax
			Expect(2 + 2, EqualTo(4));
			Expect(2 + 2 == 4);
			Expect(i3, EqualTo(d3));
			Expect(2 + 2, Not.EqualTo(5));
			Expect(i3, Not.EqualTo(iunequal));
		}

		[Test]
		public void EqualityTestsWithTolerance()
		{
			// CLassic syntax
			Assert.AreEqual(5.0d, 4.99d, 0.05d);
			Assert.AreEqual(5.0f, 4.99f, 0.05f);

			// Helper syntax
			Assert.That(4.99d, Is.EqualTo(5.0d).Within(0.05d));
			Assert.That(4.99f, Is.EqualTo(5.0f).Within(0.05f));
		
			// Inherited syntax
			Expect(4.99d, EqualTo(5.0d).Within(0.05d));
			Expect(4.99f, EqualTo(5.0f).Within(0.05f));
		}

		[Test]
		public void ComparisonTests()
		{
			// Classic Syntax
			Assert.Greater(7, 3);
			Assert.GreaterOrEqual(7, 3);
			Assert.GreaterOrEqual(7, 7);

			// Helper syntax
			Assert.That(7, Is.GreaterThan(3));
			Assert.That(7, Is.GreaterThanOrEqualTo(3));
			Assert.That(7, Is.AtLeast(3));
			Assert.That(7, Is.GreaterThanOrEqualTo(7));
			Assert.That(7, Is.AtLeast(7));

			// Inherited syntax
			Expect(7, GreaterThan(3));
			Expect(7, GreaterThanOrEqualTo(3));
			Expect(7, AtLeast(3));
			Expect(7, GreaterThanOrEqualTo(7));
			Expect(7, AtLeast(7));

			// Classic syntax
			Assert.Less(3, 7);
			Assert.LessOrEqual(3, 7);
			Assert.LessOrEqual(3, 3);

			// Helper syntax
			Assert.That(3, Is.LessThan(7));
			Assert.That(3, Is.LessThanOrEqualTo(7));
			Assert.That(3, Is.AtMost(7));
			Assert.That(3, Is.LessThanOrEqualTo(3));
			Assert.That(3, Is.AtMost(3));
		
			// Inherited syntax
			Expect(3, LessThan(7));
			Expect(3, LessThanOrEqualTo(7));
			Expect(3, AtMost(7));
			Expect(3, LessThanOrEqualTo(3));
			Expect(3, AtMost(3));
		}

		[Test]
		public void AllItemsTests()
		{
			object[] ints = new object[] { 1, 2, 3, 4 };
			object[] strings = new object[] { "abc", "bad", "cab", "bad", "dad" };

			// Classic syntax
			CollectionAssert.AllItemsAreNotNull(ints);
			CollectionAssert.AllItemsAreInstancesOfType(ints, typeof(int));
			CollectionAssert.AllItemsAreInstancesOfType(strings, typeof(string));
			CollectionAssert.AllItemsAreUnique(ints);

			// Helper syntax
			Assert.That(ints, Is.All.Not.Null);
			Assert.That(ints, Is.All.InstanceOfType(typeof(int)));
			Assert.That(strings, Is.All.InstanceOfType(typeof(string)));
			Assert.That(ints, Is.Unique);
			// Only available using new syntax
			Assert.That(strings, Is.Not.Unique);
			Assert.That(ints, Is.All.GreaterThan(0));
			Assert.That(strings, Text.All.Contains( "a" ) );
			Assert.That(strings, List.Some.StartsWith( "ba" ) );
		
			// Inherited syntax
			Expect(ints, All.Not.Null);
			Expect(ints, All.InstanceOfType(typeof(int)));
			Expect(strings, All.InstanceOfType(typeof(string)));
			Expect(ints, Unique);
			// Only available using new syntax
			Expect(strings, Not.Unique);
			Expect(ints, All.GreaterThan(0));
			Expect(strings, All.Contains( "a" ) );
			Expect(strings, Some.StartsWith( "ba" ) );
		}

		[Test]
		public void SomeItemsTests()
		{
			object[] mixed = new object[] { 1, 2, "3", null, "four", 100 };
			object[] strings = new object[] { "abc", "bad", "cab", "bad", "dad" };

			// Not available using the classic syntax

			// Helper syntax
			Assert.That(mixed, Has.Some.Null);
			Assert.That(mixed, Has.Some.InstanceOfType(typeof(int)));
			Assert.That(mixed, Has.Some.InstanceOfType(typeof(string)));
			Assert.That(mixed, Has.Some.GreaterThan(99));
			Assert.That(strings, Has.Some.StartsWith( "ba" ) );
			Assert.That(strings, Has.Some.Not.StartsWith( "ba" ) );
		
			// Inherited syntax
			Expect(mixed, Some.Null);
			Expect(mixed, Some.InstanceOfType(typeof(int)));
			Expect(mixed, Some.InstanceOfType(typeof(string)));
			Expect(mixed, Some.GreaterThan(99));
			Expect(strings, Some.StartsWith( "ba" ) );
			Expect(strings, Some.Not.StartsWith( "ba" ) );
		}

		[Test]
		public void NoItemsTests()
		{
			object[] ints = new object[] { 1, 2, 3, 4, 5 };
			object[] strings = new object[] { "abc", "bad", "cab", "bad", "dad" };

			// Not available using the classic syntax

			// Helper syntax
			Assert.That(ints, Has.None.Null);
			Assert.That(ints, Has.None.InstanceOfType(typeof(string)));
			Assert.That(ints, Has.None.GreaterThan(99));
			Assert.That(strings, Has.None.StartsWith( "qu" ) );
		
			// Inherited syntax
			Expect(ints, None.Null);
			Expect(ints, None.InstanceOfType(typeof(string)));
			Expect(ints, None.GreaterThan(99));
			Expect(strings, None.StartsWith( "qu" ) );
		}

		[Test]
		public void CollectionContainsTests()
		{
			int[] iarray = new int[] { 1, 2, 3 };
			string[] sarray = new string[] { "a", "b", "c" };

			// Classic syntax
			Assert.Contains(3, iarray);
			Assert.Contains("b", sarray);
			CollectionAssert.Contains(iarray, 3);
			CollectionAssert.Contains(sarray, "b");
			CollectionAssert.DoesNotContain(sarray, "x");

			// Helper syntax
			Assert.That(iarray, List.Contains(3));
			Assert.That(sarray, List.Contains("b"));
			Assert.That(sarray, List.Not.Contains("x"));
		
			// Inherited syntax
			Expect(iarray, Contains(3));
			Expect(sarray, Contains("b"));
			Expect(sarray, Not.Contains("x"));
		}

		[Test]
		public void CollectionEquivalenceTests()
		{
			int[] ints1to5 = new int[] { 1, 2, 3, 4, 5 };

			// Classic syntax
			CollectionAssert.AreEquivalent(new int[] { 2, 1, 4, 3, 5 }, ints1to5);
			CollectionAssert.AreNotEquivalent(new int[] { 2, 2, 4, 3, 5 }, ints1to5);
			CollectionAssert.AreNotEquivalent(new int[] { 2, 4, 3, 5 }, ints1to5);
			CollectionAssert.AreEquivalent(new int[] { 2, 2, 1, 1, 4, 3, 5 }, ints1to5);
		
			// Helper syntax
			Assert.That(new int[] { 2, 1, 4, 3, 5 }, Is.EquivalentTo(ints1to5));
			Assert.That(new int[] { 2, 2, 4, 3, 5 }, Is.Not.EquivalentTo(ints1to5));
			Assert.That(new int[] { 2, 4, 3, 5 }, Is.Not.EquivalentTo(ints1to5));
			Assert.That(new int[] { 2, 2, 1, 1, 4, 3, 5 }, Is.EquivalentTo(ints1to5));

			// Inherited syntax
			Expect(new int[] { 2, 1, 4, 3, 5 }, EquivalentTo(ints1to5));
			Expect(new int[] { 2, 2, 4, 3, 5 }, Not.EquivalentTo(ints1to5));
			Expect(new int[] { 2, 4, 3, 5 }, Not.EquivalentTo(ints1to5));
			Expect(new int[] { 2, 2, 1, 1, 4, 3, 5 }, EquivalentTo(ints1to5));
		}

		[Test]
		public void SubsetTests()
		{
			int[] ints1to5 = new int[] { 1, 2, 3, 4, 5 };

			// Classic syntax
			CollectionAssert.IsSubsetOf(new int[] { 1, 3, 5 }, ints1to5);
			CollectionAssert.IsSubsetOf(new int[] { 1, 2, 3, 4, 5 }, ints1to5);
			CollectionAssert.IsNotSubsetOf(new int[] { 2, 4, 6 }, ints1to5);

			// Helper syntax
			Assert.That(new int[] { 1, 3, 5 }, Is.SubsetOf(ints1to5));
			Assert.That(new int[] { 1, 2, 3, 4, 5 }, Is.SubsetOf(ints1to5));
			Assert.That(new int[] { 2, 4, 6 }, Is.Not.SubsetOf(ints1to5));
		
			// Inherited syntax
			Expect(new int[] { 1, 3, 5 }, SubsetOf(ints1to5));
			Expect(new int[] { 1, 2, 3, 4, 5 }, SubsetOf(ints1to5));
			Expect(new int[] { 2, 4, 6 }, Not.SubsetOf(ints1to5));
		}

		[Test]
		public void PropertyTests()
		{
			string[] array = new string[] { "abc", "bca", "xyz" };

			// Helper syntax
			Assert.That( "Hello", Has.Property("Length", 5) );
			Assert.That( "Hello", Has.Length( 5 ) );
			Assert.That( array , Has.All.Property( "Length", 3 ) );
			Assert.That( array, Has.All.Length( 3 ) );

			// Inherited syntax
			Expect( "Hello", Property("Length", 5) );
			Expect( "Hello", Length( 5 ) );
			Expect( array, All.Property("Length", 3 ) );
			Expect( array, All.Length( 3 ) );
		}

		[Test]
		public void NotTests()
		{
			// Not available using the classic syntax

			// Helper syntax
			Assert.That(42, Is.Not.Null);
			Assert.That(42, Is.Not.True);
			Assert.That(42, Is.Not.False);
			Assert.That(2.5, Is.Not.NaN);
			Assert.That(2 + 2, Is.Not.EqualTo(3));
			Assert.That(2 + 2, Is.Not.Not.EqualTo(4));
			Assert.That(2 + 2, Is.Not.Not.Not.EqualTo(5));

			// Inherited syntax
			Expect(42, Not.Null);
			Expect(42, Not.True);
			Expect(42, Not.False);
			Expect(2.5, Not.NaN);
			Expect(2 + 2, Not.EqualTo(3));
			Expect(2 + 2, Not.Not.EqualTo(4));
			Expect(2 + 2, Not.Not.Not.EqualTo(5));
		}

		[Test]
		public void NotOperator()
		{
			// The ! operator is only available in the new syntax
			Assert.That(42, !Is.Null);
			// Inherited syntax
			Expect( 42, !Null );
		}

		[Test]
		public void AndOperator()
		{
			// The & operator is only available in the new syntax
			Assert.That(7, Is.GreaterThan(5) & Is.LessThan(10));
			// Inherited syntax
			Expect( 7, GreaterThan(5) & LessThan(10));
		}

		[Test]
		public void OrOperator()
		{
			// The | operator is only available in the new syntax
			Assert.That(3, Is.LessThan(5) | Is.GreaterThan(10));
			Expect( 3, LessThan(5) | GreaterThan(10));
		}

		[Test]
		public void ComplexTests()
		{
			Assert.That(7, Is.Not.Null & Is.Not.LessThan(5) & Is.Not.GreaterThan(10));
			Expect(7, Not.Null & Not.LessThan(5) & Not.GreaterThan(10));

			Assert.That(7, !Is.Null & !Is.LessThan(5) & !Is.GreaterThan(10));
			Expect(7, !Null & !LessThan(5) & !GreaterThan(10));

			// TODO: Remove #if when mono compiler can handle null
#if MONO
            Constraint x = null;
            Assert.That(7, !x & !Is.LessThan(5) & !Is.GreaterThan(10));
			Expect(7, !x & !LessThan(5) & !GreaterThan(10));
#else
			Assert.That(7, !(Constraint)null & !Is.LessThan(5) & !Is.GreaterThan(10));
			Expect(7, !(Constraint)null & !LessThan(5) & !GreaterThan(10));
#endif
		}

		// This method contains assertions that should not compile
		// You can check by uncommenting it.
		//public void WillNotCompile()
		//{
		//    Assert.That(42, Is.Not);
		//    Assert.That(42, Is.All);
		//    Assert.That(42, Is.Null.Not);
		//    Assert.That(42, Is.Not.Null.GreaterThan(10));
		//    Assert.That(42, Is.GreaterThan(10).LessThan(99));

		//    object[] c = new object[0];
		//    Assert.That(c, Is.Null.All);
		//    Assert.That(c, Is.Not.All);
		//    Assert.That(c, Is.All.Not);
		//}
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.4.1\samples\Extensibility\Core\MaxTimeDecorator\Tests\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.4.1\samples\csharp\money-port\MoneyTest.cs ===
// ****************************************************************
// This is free software licensed under the NUnit license. You
// may obtain a copy of the license as well as information regarding
// copyright ownership at http://nunit.org/?p=license&r=2.4.
// ****************************************************************

namespace NUnit.Samples.Money.Port
{
	using System;
	using NUnit.Framework;
	/// <summary>
	/// 
	/// </summary>
	public class MoneyTest: TestCase 
	{
		private Money f12CHF;
		private Money f14CHF;
		private Money f7USD;
		private Money f21USD;
        
		private MoneyBag fMB1;
		private MoneyBag fMB2;

		/// <summary>
		/// 
		/// </summary>
		protected override void SetUp() 
		{
			f12CHF= new Money(12, "CHF");
			f14CHF= new Money(14, "CHF");
			f7USD= new Money( 7, "USD");
			f21USD= new Money(21, "USD");

			fMB1= new MoneyBag(f12CHF, f7USD);
			fMB2= new MoneyBag(f14CHF, f21USD);
		}
		/// <summary>
		/// 
		/// </summary>
		public void TestBagMultiply() 
		{
			// {[12 CHF][7 USD]} *2 == {[24 CHF][14 USD]}
			Money[] bag = { new Money(24, "CHF"), new Money(14, "USD") };
			MoneyBag expected= new MoneyBag(bag);
			Assertion.AssertEquals(expected, fMB1.Multiply(2));
			Assertion.AssertEquals(fMB1, fMB1.Multiply(1));
			Assertion.Assert(fMB1.Multiply(0).IsZero);
		}
		/// <summary>
		/// 
		/// </summary>
		public void TestBagNegate() 
		{
			// {[12 CHF][7 USD]} negate == {[-12 CHF][-7 USD]}
			Money[] bag= { new Money(-12, "CHF"), new Money(-7, "USD") };
			MoneyBag expected= new MoneyBag(bag);
			Assertion.AssertEquals(expected, fMB1.Negate());
		}
		/// <summary>
		/// 
		/// </summary>
		public void TestBagSimpleAdd() 
		{
			// {[12 CHF][7 USD]} + [14 CHF] == {[26 CHF][7 USD]}
			Money[] bag= { new Money(26, "CHF"), new Money(7, "USD") };
			MoneyBag expected= new MoneyBag(bag);
			Assertion.AssertEquals(expected, fMB1.Add(f14CHF));
		}
		/// <summary>
		/// 
		/// </summary>
		public void TestBagSubtract() 
		{
			// {[12 CHF][7 USD]} - {[14 CHF][21 USD] == {[-2 CHF][-14 USD]}
			Money[] bag= { new Money(-2, "CHF"), new Money(-14, "USD") };
			MoneyBag expected= new MoneyBag(bag);
			Assertion.AssertEquals(expected, fMB1.Subtract(fMB2));
		}
		/// <summary>
		/// 
		/// </summary>
		public void TestBagSumAdd() 
		{
			// {[12 CHF][7 USD]} + {[14 CHF][21 USD]} == {[26 CHF][28 USD]}
			Money[] bag= { new Money(26, "CHF"), new Money(28, "USD") };
			MoneyBag expected= new MoneyBag(bag);
			Assertion.AssertEquals(expected, fMB1.Add(fMB2));
		}
		/// <summary>
		/// 
		/// </summary>
		public void TestIsZero() 
		{
			Assertion.Assert(fMB1.Subtract(fMB1).IsZero);

			Money[] bag = { new Money(0, "CHF"), new Money(0, "USD") };
			Assertion.Assert(new MoneyBag(bag).IsZero);
		}
		/// <summary>
		/// 
		/// </summary>
		public void TestMixedSimpleAdd() 
		{
			// [12 CHF] + [7 USD] == {[12 CHF][7 USD]}
			Money[] bag= { f12CHF, f7USD };
			MoneyBag expected= new MoneyBag(bag);
			Assertion.AssertEquals(expected, f12CHF.Add(f7USD));
		}
		/// <summary>
		/// 
		/// </summary>
		public void TestMoneyBagEquals() 
		{
			Assertion.Assert(!fMB1.Equals(null)); 

			Assertion.AssertEquals(fMB1, fMB1);
			MoneyBag equal= new MoneyBag(new Money(12, "CHF"), new Money(7, "USD"));
			Assertion.Assert(fMB1.Equals(equal));
			Assertion.Assert(!fMB1.Equals(f12CHF));
			Assertion.Assert(!f12CHF.Equals(fMB1));
			Assertion.Assert(!fMB1.Equals(fMB2));
		}
		/// <summary>
		/// 
		/// </summary>
		public void TestMoneyBagHash() 
		{
			MoneyBag equal= new MoneyBag(new Money(12, "CHF"), new Money(7, "USD"));
			Assertion.AssertEquals(fMB1.GetHashCode(), equal.GetHashCode());
		}
		/// <summary>
		/// 
		/// </summary>
		public void TestMoneyEquals() 
		{
			Assertion.Assert(!f12CHF.Equals(null)); 
			Money equalMoney= new Money(12, "CHF");
			Assertion.AssertEquals(f12CHF, f12CHF);
			Assertion.AssertEquals(f12CHF, equalMoney);
			Assertion.AssertEquals(f12CHF.GetHashCode(), equalMoney.GetHashCode());
			Assertion.Assert(!f12CHF.Equals(f14CHF));
		}
		/// <summary>
		/// 
		/// </summary>
		public void TestMoneyHash() 
		{
			Assertion.Assert(!f12CHF.Equals(null)); 
			Money equal= new Money(12, "CHF");
			Assertion.AssertEquals(f12CHF.GetHashCode(), equal.GetHashCode());
		}
		/// <summary>
		/// 
		/// </summary>
		public void TestNormalize() 
		{
			Money[] bag= { new Money(26, "CHF"), new Money(28, "CHF"), new Money(6, "CHF") };
			MoneyBag moneyBag= new MoneyBag(bag);
			Money[] expected = { new Money(60, "CHF") };
			// note: expected is still a MoneyBag
			MoneyBag expectedBag= new MoneyBag(expected);
			Assertion.AssertEquals(expectedBag, moneyBag);
		}
		/// <summary>
		/// 
		/// </summary>
		public void TestNormalize2() 
		{
			// {[12 CHF][7 USD]} - [12 CHF] == [7 USD]
			Money expected= new Money(7, "USD");
			Assertion.AssertEquals(expected, fMB1.Subtract(f12CHF));
		}
		/// <summary>
		/// 
		/// </summary>
		public void TestNormalize3() 
		{
			// {[12 CHF][7 USD]} - {[12 CHF][3 USD]} == [4 USD]
			Money[] s1 = { new Money(12, "CHF"), new Money(3, "USD") };
			MoneyBag ms1= new MoneyBag(s1);
			Money expected= new Money(4, "USD");
			Assertion.AssertEquals(expected, fMB1.Subtract(ms1));
		}
		/// <summary>
		/// 
		/// </summary>
		public void TestNormalize4() 
		{
			// [12 CHF] - {[12 CHF][3 USD]} == [-3 USD]
			Money[] s1 = { new Money(12, "CHF"), new Money(3, "USD") };
			MoneyBag ms1= new MoneyBag(s1);
			Money expected= new Money(-3, "USD");
			Assertion.AssertEquals(expected, f12CHF.Subtract(ms1));
		}
		/// <summary>
		/// 
		/// </summary>
		public void TestPrint() 
		{
			Assertion.AssertEquals("[12 CHF]", f12CHF.ToString());
		}
		/// <summary>
		/// 
		/// </summary>
		public void TestSimpleAdd() 
		{
			// [12 CHF] + [14 CHF] == [26 CHF]
			Money expected= new Money(26, "CHF");
			Assertion.AssertEquals(expected, f12CHF.Add(f14CHF));
		}
		/// <summary>
		/// 
		/// </summary>
		public void TestSimpleBagAdd() 
		{
			// [14 CHF] + {[12 CHF][7 USD]} == {[26 CHF][7 USD]}
			Money[] bag= { new Money(26, "CHF"), new Money(7, "USD") };
			MoneyBag expected= new MoneyBag(bag);
			Assertion.AssertEquals(expected, f14CHF.Add(fMB1));
		}
		/// <summary>
		/// 
		/// </summary>
		public void TestSimpleMultiply() 
		{
			// [14 CHF] *2 == [28 CHF]
			Money expected= new Money(28, "CHF");
			Assertion.AssertEquals(expected, f14CHF.Multiply(2));
		}
		/// <summary>
		/// 
		/// </summary>
		public void TestSimpleNegate() 
		{
			// [14 CHF] negate == [-14 CHF]
			Money expected= new Money(-14, "CHF");
			Assertion.AssertEquals(expected, f14CHF.Negate());
		}
		/// <summary>
		/// 
		/// </summary>
		public void TestSimpleSubtract() 
		{
			// [14 CHF] - [12 CHF] == [2 CHF]
			Money expected= new Money(2, "CHF");
			Assertion.AssertEquals(expected, f14CHF.Subtract(f12CHF));
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.4.1\samples\Extensibility\Core\MaxTimeDecorator\ExpectFailureAttribute.cs ===
// ****************************************************************
// Copyright 2007, Charlie Poole
// This is free software licensed under the NUnit license. You may
// obtain a copy of the license at http://nunit.org/?p=license&r=2.4
// ****************************************************************

using System;

namespace NUnit.Framework.Extensions
{
	/// <summary>
	/// Summary description for ExpectFailureAttribute.
	/// </summary>
	[AttributeUsage( AttributeTargets.Method, AllowMultiple=false, Inherited=false )]
	public sealed class ExpectFailureAttribute : Attribute
	{
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.4.1\samples\Extensibility\Core\MaxTimeDecorator\MaxTimeDecorator.cs ===
// ****************************************************************
// Copyright 2007, Charlie Poole
// This is free software licensed under the NUnit license. You may
// obtain a copy of the license at http://nunit.org/?p=license&r=2.4
// ****************************************************************

using System;
using System.Reflection;
using NUnit.Core.Extensibility;

namespace NUnit.Core.Extensions
{
	/// <summary>
	/// Summary description for MaxTimeDecorator.
	/// </summary>
	[NUnitAddin(Description="Fails a test if its elapsed time is longer than a given maximum")]
	public class MaxTimeDecorator : IAddin, ITestDecorator
	{
		#region IAddin Members

		public bool Install(IExtensionHost host)
		{
			System.Diagnostics.Trace.WriteLine( "MaxTimeDecorator: Install called" );
			IExtensionPoint decorators = host.GetExtensionPoint( "TestDecorators" );
			if ( decorators == null ) return false;

			decorators.Install( this );
			return true;
		}

		#endregion

		#region ITestDecorator Members

		public Test Decorate(Test test, System.Reflection.MemberInfo member)
		{
			if ( test is TestCase )
			{
				Attribute attr = Reflect.GetAttribute( 
					member, "NUnit.Framework.Extensions.MaxTimeAttribute", false );
				if ( attr != null )
				{
					int maxTime = (int)Reflect.GetPropertyValue( attr, "MaxTime", BindingFlags.Public | BindingFlags.Instance );
					test = new MaxTimeTestCase( (TestCase)test, maxTime );
				}
			}

			return test;
		}

		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.4.1\samples\Extensibility\Core\MaxTimeDecorator\MaxTimeTestCase.cs ===
// ****************************************************************
// Copyright 2007, Charlie Poole
// This is free software licensed under the NUnit license. You may
// obtain a copy of the license at http://nunit.org/?p=license&r=2.4
// ****************************************************************

using System;
using System.Reflection;

namespace NUnit.Core.Extensions
{
	/// <summary>
	/// Summary description for MaxTimeTestCase.D:\Dev\NUnit\nunit-2.4\samples\Extensibility\Core\SampleFixtureExtension\Tests\SampleFixtureExtensionTests.cs
	/// </summary>
	public class MaxTimeTestCase : TestCase
	{
		private TestCase testCase;
		private int maxTime = 0;

		public MaxTimeTestCase( TestCase testCase, int maxTime )
			: base( (TestName)testCase.TestName.Clone() )
		{
			// We give it a different test id to avoid confusion
			// when debugging - even though it's not strictly
			// necessary in this case.
			this.TestName.TestID = new TestID();
			this.testCase = testCase;
			this.maxTime = maxTime;
		}

		public override void Run(TestCaseResult result)
		{
			testCase.Run( result );
			if ( result.IsSuccess )
			{
				int elapsedTime = (int)(result.Time * 1000);
				if ( elapsedTime > maxTime )
					result.Failure( string.Format( "Elapsed time of {0}ms exceeds maximum of {1}ms", elapsedTime, maxTime ), null );
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.4.1\samples\Extensibility\Core\SampleFixtureExtension\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.4.1\samples\Extensibility\Core\MaxTimeDecorator\MaxTimeAttribute.cs ===
// ****************************************************************
// Copyright 2007, Charlie Poole
// This is free software licensed under the NUnit license. You may
// obtain a copy of the license at http://nunit.org/?p=license&r=2.4
// ****************************************************************

using System;

namespace NUnit.Framework.Extensions
{
	/// <summary>
	/// Summary description for MaxTimeAttribute.
	/// </summary>
	[AttributeUsage( AttributeTargets.Method, AllowMultiple=false, Inherited=false )]
	public sealed class MaxTimeAttribute : Attribute
	{
		private int maxTime;

		public MaxTimeAttribute( int maxTime )
		{
			this.maxTime = maxTime;
		}

		public int MaxTime
		{
			get { return maxTime; }
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.4.1\samples\Extensibility\Core\SampleFixtureExtension\Tests\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.4.1\samples\Extensibility\Core\Minimal\Minimal.cs ===
// ****************************************************************
// Copyright 2007, Charlie Poole
// This is free software licensed under the NUnit license. You may
// obtain a copy of the license at http://nunit.org/?p=license&r=2.4
// ****************************************************************

using System;
using NUnit.Core.Extensibility;

namespace NUnit.Samples.Extensibility
{
	/// <summary>
	/// This is the smallest possible Addin, which does nothing 
	/// but is recognized by NUnit and listed in the Addins dialog.
	/// 
	/// The Addin class is marked by the NUnitAddin attribute and
	/// implements IAddin, as required. Optional property syntax
	/// is used here to override the default name of the addin and
	/// to provide a description. Both are displayed by NUnit in the
	/// Addin Dialog.
	/// 
	/// The addin doesn't actually install anything, but simply
	/// returns false in its Install method.
	/// </summary>
	[NUnitAddin(Name="Minimal Addin", Description="This Addin doesn't do anything")]
	public class Minimal : IAddin
	{
		#region IAddin Members
		public bool Install(IExtensionHost host)
		{
			// TODO:  Add Minimal.Install implementation
			return true;
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.4.1\samples\Extensibility\Core\MaxTimeDecorator\Tests\MaxTimeDecoratorTests.cs ===
// ****************************************************************
// Copyright 2007, Charlie Poole
// This is free software licensed under the NUnit license. You may
// obtain a copy of the license at http://nunit.org/?p=license&r=2.4
// ****************************************************************

using System;
using NUnit.Framework;
using NUnit.Framework.Extensions;

namespace Tests
{
	/// <summary>
	/// Tests for MaxTime decoration. Some of these tests are
	/// actually expected to fail, so the results must be
	/// examined visually. It would be possible to test these
	/// automatically by running a second copy of NUnit, but
	/// this is better handled through an acceptance test
	/// suite such as FIT.
	/// </summary>
	[TestFixture]
	public class MaxTimeDecoratorTests
	{
		[Test,MaxTime(1000)]
		public void MaxTimeNotExceeded()
		{
		}

		[Test,MaxTime(1000), ExpectedException(typeof(AssertionException),ExpectedMessage="Intentional failure")]
		public void MaxTimeNotExceededButFailed()
		{
			Assert.Fail("Intentional failure");
		}

		[Test,MaxTime(1),ExpectFailure,Description("This should fail due to time exceeded")]
		public void MaxTimeWasExceeded()
		{
			System.Threading.Thread.Sleep(100);
		}

		[Test,MaxTime(1),ExpectedException(typeof(AssertionException),ExpectedMessage="Intentional failure")]
		public void MaxTimeWasExceededButFailed()
		{
			System.Threading.Thread.Sleep(100);
			Assert.Fail("Intentional failure");
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.4.1\samples\Extensibility\Core\SampleFixtureExtension\SampleFixtureExtension.cs ===
// ****************************************************************
// Copyright 2007, Charlie Poole
// This is free software licensed under the NUnit license. You may
// obtain a copy of the license at http://nunit.org/?p=license&r=2.4
// ****************************************************************

using System;

namespace NUnit.Core.Extensions
{
	/// <summary>
	/// SampleFixtureExtension extends NUnitTestFixture and adds a custom setup
	/// before running TestFixtureSetUp and after running TestFixtureTearDown.
	/// Because it inherits from NUnitTestFixture, a lot of work is done for it.
	/// </summary>
	class SampleFixtureExtension : NUnitTestFixture
	{
		public SampleFixtureExtension( Type fixtureType ) 
			: base( fixtureType )
		{
			// NOTE: Since we are inheriting from NUnitTestFixture we don't 
			// have to do anything if we don't want to. All the attributes
			// that are normally used with an NUnitTestFixture will be
			// recognized.
			//
			// Just to have something to do, we override DoOneTimeSetUp and 
			// DoOneTimeTearDown below to do some special processing before 
			// and after the normal TestFixtureSetUp and TestFixtureTearDown.
			// In this example, we simply display a message.
		}

		protected override void DoOneTimeSetUp(TestResult suiteResult)
		{
			Console.WriteLine( "Extended Fixture SetUp called" );
			base.DoOneTimeSetUp (suiteResult);
		}

		protected override void DoOneTimeTearDown(TestResult suiteResult)
		{
			base.DoOneTimeTearDown (suiteResult);
			Console.WriteLine( "Extended Fixture TearDown called" );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.4.1\samples\Extensibility\Core\SampleFixtureExtension\SampleFixtureExtensionAttribute.cs ===
// ****************************************************************
// Copyright 2007, Charlie Poole
// This is free software licensed under the NUnit license. You may
// obtain a copy of the license at http://nunit.org/?p=license&r=2.4
// ****************************************************************

using System;

namespace NUnit.Core.Extensions
{
	/// <summary>
	/// SampleFixtureExtensionAttribute is used to identify a SampleFixtureExtension class
	/// </summary>
	[AttributeUsage(AttributeTargets.Class, AllowMultiple=false)]
	public sealed class SampleFixtureExtensionAttribute : Attribute
	{
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.4.1\samples\Extensibility\Core\SampleSuiteExtension\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.4.1\samples\Extensibility\Core\SampleSuiteExtension\Tests\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.4.1\samples\Extensibility\Core\SampleFixtureExtension\SampleFixtureExtensionBuilder.cs ===
// ****************************************************************
// Copyright 2007, Charlie Poole
// This is free software licensed under the NUnit license. You may
// obtain a copy of the license at http://nunit.org/?p=license&r=2.4
// ****************************************************************

using System;
using NUnit.Core.Builders;
using NUnit.Core.Extensibility;

namespace NUnit.Core.Extensions
{
	/// <summary>
	/// MockFixtureExtensionBuilder knows how to build
	/// a MockFixtureExtension.
	/// </summary>
	[NUnitAddin(Description="Wraps an NUnitTestFixture with an additional level of SetUp and TearDown")]
	public class SampleFixtureExtensionBuilder : NUnitTestFixtureBuilder, IAddin
	{	
		#region NUnitTestFixtureBuilder Overrides
		/// <summary>
		/// Makes a SampleFixtureExtension instance
		/// </summary>
		/// <param name="type">The type to be used</param>
		/// <returns>A SampleFixtureExtension as a TestSuite</returns>
		protected override TestSuite MakeSuite(Type type)
		{
			return new SampleFixtureExtension( type );
		}

		// The builder recognizes the types that it can use by the presense
		// of SampleFixtureExtensionAttribute. Note that an attribute does not
		// have to be used. You can use any arbitrary set of rules that can be 
		// implemented using reflection on the type.
		public override bool CanBuildFrom(Type type)
		{
			return Reflect.HasAttribute( type, "NUnit.Core.Extensions.SampleFixtureExtensionAttribute", false );
		}
		#endregion

		#region IAddin Members
		public bool Install(IExtensionHost host)
		{
			IExtensionPoint suiteBuilders = host.GetExtensionPoint( "SuiteBuilders" );
			if ( suiteBuilders == null )
				return false;

			suiteBuilders.Install( this );
			return true;
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.4.1\samples\Extensibility\Core\SampleSuiteExtension\Addin.cs ===
// ****************************************************************
// Copyright 2007, Charlie Poole
// This is free software licensed under the NUnit license. You may
// obtain a copy of the license at http://nunit.org/?p=license&r=2.4
// ****************************************************************

using System;
using NUnit.Core.Extensibility;

namespace NUnit.Core.Extensions
{
	/// <summary>
	/// Summary description for Addin.
	/// </summary>
	[NUnitAddin(Name="SampleSuiteExtension", Description = "Recognizes Tests starting with SampleTest...")]
	public class Addin : IAddin
	{
		#region IAddin Members
		public bool Install(IExtensionHost host)
		{
			IExtensionPoint builders = host.GetExtensionPoint( "SuiteBuilders" );
			if ( builders == null )
				return false;

			builders.Install( new SampleSuiteExtensionBuilder() );
			return true;
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.4.1\samples\Extensibility\Core\SampleFixtureExtension\Tests\SampleFixtureExtensionTests.cs ===
// ****************************************************************
// Copyright 2007, Charlie Poole
// This is free software licensed under the NUnit license. You may
// obtain a copy of the license at http://nunit.org/?p=license&r=2.4
// ****************************************************************

using System;
using NUnit.Framework;
using NUnit.Core.Extensions;

namespace NUnit.Extensions.Tests
{
	/// <summary>
	/// Test class that demonstrates SampleFixtureExtension
	/// </summary>
	[SampleFixtureExtension]
	public class SampleFixtureExtensionTests
	{
		[TestFixtureSetUp]
		public void SetUpTests()
		{
			Console.WriteLine( "TestFixtureSetUp called" );
		}

		[TestFixtureTearDown]
		public void FixtureTearDown()
		{
			Console.WriteLine( "TestFixtureTearDown called" );
		}

		[Test]
		public void SomeTest()
		{
			Console.WriteLine( "Hello from some test" );
		}

		[Test]
		public void AnotherTest()
		{
			Console.WriteLine( "Hello from another test" );
		}

		public void NotATest()
		{
			Console.WriteLine( "I shouldn't be called!" );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.4.1\samples\Extensibility\Core\SampleSuiteExtension\Tests\SampleSuiteExtensionTests.cs ===
// ****************************************************************
// Copyright 2007, Charlie Poole
// This is free software licensed under the NUnit license. You may
// obtain a copy of the license at http://nunit.org/?p=license&r=2.4
// ****************************************************************

using System;
using System.Reflection;

namespace NUnit.Core.Extensions.Tests
{
	/// <summary>
	/// Test class that demonstrates SampleSuiteExtension
	/// </summary>
	[SampleSuiteExtension]
	public class SampleSuiteExtensionTests
	{
		public void SampleTest1()
		{
			Console.WriteLine( "Hello from sample test 1" );
		}

		public void SampleTest2()
		{
			Console.WriteLine( "Hello from sample test 2" );
		}

		public void NotATest()
		{
			Console.WriteLine( "I shouldn't be called!" );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.4.1\samples\Extensibility\Core\SampleSuiteExtension\SampleSuiteExtensionAttribute.cs ===
// ****************************************************************
// Copyright 2007, Charlie Poole
// This is free software licensed under the NUnit license. You may
// obtain a copy of the license at http://nunit.org/?p=license&r=2.4
// ****************************************************************

using System;

namespace NUnit.Core.Extensions
{
	/// <summary>
	/// SampleSuiteExtensionAttribute is used to identify a SampleSuiteExtension fixture
	/// </summary>
	[AttributeUsage(AttributeTargets.Class, AllowMultiple=false)]
	public sealed class SampleSuiteExtensionAttribute : Attribute
	{
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.4.1\samples\Extensibility\Core\SampleSuiteExtension\SampleSuiteExtension.cs ===
// ****************************************************************
// Copyright 2007, Charlie Poole
// This is free software licensed under the NUnit license. You may
// obtain a copy of the license at http://nunit.org/?p=license&r=2.4
// ****************************************************************

using System;
using System.Reflection;

namespace NUnit.Core.Extensions
{
	/// <summary>
	/// SampleSuiteExtension is a minimal example of a suite extension. It 
	/// extends test suite and creates a fixture that runs every test starting 
	/// with "SampleTest..." Because it inherits from TestSuite, rather than
	/// TestFixture, it has to construct its own fixture object and find its 
	/// own tests. Everything is done in the constructor for simplicity.
	/// </summary>
	class SampleSuiteExtension : TestSuite
	{
		public SampleSuiteExtension( Type fixtureType ) 
			: base( fixtureType )
		{
			// Create the fixture object. We could wait to do this when
			// it is needed, but we do it here for simplicity.
			this.Fixture = Reflect.Construct( fixtureType );

			// Locate our test methods and add them to the suite using
			// the Add method of TestSuite. Note that we don't do a simple
			// Tests.Add, because that wouldn't set the parent of the tests.
			foreach( MethodInfo method in fixtureType.GetMethods( 
				BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly ) )
			{
				if ( method.Name.StartsWith( "SampleTest" ) )
					this.Add( new NUnitTestMethod( method ) );
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\nunit\2.4.1\samples\Extensibility\Core\SampleSuiteExtension\SampleSuiteExtensionBuilder.cs ===
// ****************************************************************
// Copyright 2007, Charlie Poole
// This is free software licensed under the NUnit license. You may
// obtain a copy of the license at http://nunit.org/?p=license&r=2.4
// ****************************************************************

using System;
using NUnit.Core.Extensibility;

namespace NUnit.Core.Extensions
{
	/// <summary>
	/// SampleSuiteExtensionBuilder knows how to build a SampleSuiteExtension
	/// </summary>
	public class SampleSuiteExtensionBuilder : ISuiteBuilder
	{	
		#region ISuiteBuilder Members

		// This builder delegates all the work to the constructor of the  
		// extension suite. Many builders will need to do more work, 
		// looking for other attributes, setting properties on the 
		// suite and locating methods for tests, setup and teardown.
		public Test BuildFrom(Type type)
		{
			if ( CanBuildFrom( type ) )
				return new SampleSuiteExtension( type );
			return null;
		}
		
		// The builder recognizes the types that it can use by the presense
		// of SampleSuiteExtensionAttribute. Note that an attribute does not
		// have to be used. You can use any arbitrary set of rules that can be 
		// implemented using reflection on the type.
		public bool CanBuildFrom(Type type)
		{
			return Reflect.HasAttribute( type, "NUnit.Core.Extensions.SampleSuiteExtensionAttribute", false );
		}

		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\NUnitAddIns\DataSourceTestAddIn\DataProvider.XML\DataProvider.cs ===
//-----------------------------------------------------------------------
// <copyright file="DataProvider.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   implement a data provider for xml files
// </summary>
//-----------------------------------------------------------------------
using System;
using System.IO;
using System.Reflection;
using System.Text;
using System.Xml;

using NUnit.Core;

namespace DataProvider.XML
{
    public class DataProvider : IDataProvider
    {
        public DataProvider()
        {
        }

        public void CreateTestMethods(MethodInfo methodInfo, TestSuite testSuite, string connectionString, string query)
        {
            // get the full path to the xml file
            string methodModulePath = Path.GetDirectoryName(methodInfo.Module.Assembly.Location);
            string fileName = Path.Combine(methodModulePath, connectionString);

            try
            {
                // load the xml document specified by the fileName
                XmlDocument xmlDocument = new XmlDocument();

                using (FileStream fileStream = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read))
                {
                    using (StreamReader streamReader = new StreamReader(fileStream, Encoding.UTF8, true))
                    {
                        xmlDocument.Load(streamReader);
                    }
                }

                // get the list of nodes
                XmlNodeList xmlNodeList = xmlDocument.DocumentElement.ChildNodes;

                if (false == String.IsNullOrEmpty(query))
                {
                    // get the list of nodes specified by the query
                    xmlNodeList = xmlDocument.DocumentElement.SelectNodes(query);
                }

                // iterate each node and create a test method for each element
                foreach (XmlNode xmlNode in xmlNodeList)
                {
                    if (false == (xmlNode is XmlElement))
                    {
                        continue;
                    }

                    testSuite.Add(new XmlTestMethod(methodInfo, xmlNode as XmlElement));
                }
            }
            catch (ArgumentException e)
            {
                this.CreateNotRunnableTestMethod(methodInfo, testSuite, fileName, e.Message);
            }
            catch (IOException e)
            {
                this.CreateNotRunnableTestMethod(methodInfo, testSuite, fileName, e.Message);
            }
            catch (XmlException e)
            {
                this.CreateNotRunnableTestMethod(methodInfo, testSuite, fileName, e.Message);
            }
        }

        /// <summary>
        /// Creates a not runnable test method with the specified reasons
        /// </summary>
        /// <param name="methodInfo">The method attributes and metadata that was decorated with the DataSourceTestAttribute</param>
        /// <param name="testSuite">The test suite to populate with the not runnable test method</param>
        /// <param name="fileName">The xml file name</param>
        /// <param name="reason">The reason the test method is not runnable</param>
        private void CreateNotRunnableTestMethod(MethodInfo methodInfo, TestSuite testSuite, string fileName, string reason)
        {
            NUnitTestMethod testMethod = new NUnitTestMethod(methodInfo);
            testMethod.RunState = RunState.NotRunnable;
            testMethod.IgnoreReason = String.Format("Cannot load XML file '{0}' : {1}", fileName, reason);
            testSuite.Add(testMethod);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\NUnitAddIns\DataSourceTestAddIn\DataProvider.XML\TestMethod.cs ===
//-----------------------------------------------------------------------
// <copyright file="TestMethod.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   implement a data provider for xml files
// </summary>
//-----------------------------------------------------------------------
using System.Collections.Specialized;
using System.Reflection;
using System.Xml;

using NUnit.Core;

namespace DataProvider.XML
{
    class XmlTestMethod : NUnitTestMethod
    {
        private StringDictionary stringDictionary = new StringDictionary();

        public XmlTestMethod(MethodInfo methodInfo, XmlElement xmlElement) : base(methodInfo)
        {
            // create a key value pair for each attribute
            foreach (XmlAttribute xmlAttribute in xmlElement.Attributes)
            {
                this.stringDictionary[xmlAttribute.Name] = xmlAttribute.Value;
            }

            // check for test name
            if (true == this.stringDictionary.ContainsKey("name"))
            {
                this.TestName.Name = this.stringDictionary["name"];
            }

            // check for test description
            if (true == this.stringDictionary.ContainsKey("description"))
            {
                this.Description = this.stringDictionary["description"];
            }
        }

        public override void RunTestMethod(TestCaseResult testResult)
        {
            object[] arguments = new object[] { this.stringDictionary };
            Reflect.InvokeMethod(this.Method, this.Fixture, arguments);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\NUnitAddIns\DataSourceTestAddIn\DataSourceTestAttribute\DataSourceTestAttribute.cs ===
//-----------------------------------------------------------------------
// <copyright file="DataSourceTestAttribute.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   extends the nUnit framework to support a DataSource attribute that
//   provides data source-specific information for data-driven testing
// </summary>
//-----------------------------------------------------------------------
using System;

namespace DataSourceTest
{
    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    public class DataSourceTestAttribute : Attribute
    {
        private string dataProvider;
        private string connectionString;
        private string query;

        public DataSourceTestAttribute(string dataProvider, string connectionString)
        {
            this.dataProvider = dataProvider;
            this.connectionString = connectionString;
        }

        public DataSourceTestAttribute(string dataProvider, string connectionString, string query)
        {
            this.dataProvider = dataProvider;
            this.connectionString = connectionString;
            this.query = query;
        }

        public string DataProvider
        {
            get { return this.dataProvider; }
        }

        public string ConnectionString
        {
            get { return this.connectionString; }
        }

        public string Query
        {
            get { return this.query; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\NUnitAddIns\DataSourceTestAddIn\DataSourceTestAddIn\DataSourceTestAddIn.cs ===
//-----------------------------------------------------------------------
// <copyright file="DataSourceTestAddIn.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   extends the nUnit framework to support a DataSource attribute that
//   provides data source-specific information for data-driven testing
// </summary>
//-----------------------------------------------------------------------
using System;
using System.IO;
using System.Reflection;

using NUnit.Core;
using NUnit.Core.Extensibility;

using DataProvider;

namespace DataSourceTest
{
    [NUnitAddin(Description = "Provides data source-specific information for data-driven testing")]
    public class DataSourceTestAddIn : IAddin, ITestCaseBuilder
    {
        public const string DataSourceTestAttributeName = "DataSourceTest.DataSourceTestAttribute";

        public bool Install(IExtensionHost iExtensionHost)
        {
            if (null == iExtensionHost)
            {
                throw new ArgumentNullException("iExtensionHost");
            }

            IExtensionPoint iExtensionPoint = iExtensionHost.GetExtensionPoint("TestCaseBuilders");

            if (null != iExtensionPoint)
            {
                iExtensionPoint.Install(this);
            }

            return (null != iExtensionPoint);
        }

        public bool CanBuildFrom(MethodInfo methodInfo)
        {
            if (null == methodInfo)
            {
                throw new ArgumentNullException("methodInfo");
            }

            DataSourceTestAttribute dataSourceTestAttribute = null;

            if (true == Reflect.HasAttribute(methodInfo, DataSourceTestAttributeName, false))
            {
                dataSourceTestAttribute = Reflect.GetAttribute(methodInfo, DataSourceTestAttributeName, false) as DataSourceTestAttribute;
            }

            return (null != dataSourceTestAttribute);
        }

        public Test BuildFrom(MethodInfo methodInfo)
        {
            if (null == methodInfo)
            {
                throw new ArgumentNullException("methodInfo");
            }

            TestSuite testSuite = new TestSuite(methodInfo.DeclaringType.ToString(), methodInfo.Name);
            DataSourceTestAttribute dataSourceTestAttribute = Reflect.GetAttribute(methodInfo, DataSourceTestAttributeName, false) as DataSourceTestAttribute;

            IDataProvider dataProvider = null;

            string methodModulePath = Path.GetDirectoryName(methodInfo.Module.Assembly.Location);
            string thisModulePath = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);

            // try to load the data provider from the same path as the method module
            dataProvider = this.LoadDataProvider(methodModulePath, dataSourceTestAttribute.DataProvider);

            if (null == dataProvider)
            {
                // try to load the data provider from the same path as this module
                dataProvider = this.LoadDataProvider(thisModulePath, dataSourceTestAttribute.DataProvider);
            }

            if (null == dataProvider)
            {
                // cannot load the data provider so create a not runnable test method
                this.CreateNotRunnableTestMethod(methodInfo, testSuite, dataSourceTestAttribute.DataProvider);
            }
            else
            {
                // call the data provider to create the test methods
                dataProvider.CreateTestMethods(methodInfo, testSuite, dataSourceTestAttribute.ConnectionString, dataSourceTestAttribute.Query);
            }

            return testSuite;
        }

        /// <summary>
        /// Load the specified data provider from the path and module
        /// </summary>
        /// <param name="path">The path to load the module from</param>
        /// <param name="dataProvider">The module to load</param>
        /// <returns>The IDataProvider interface from the loaded module</returns>
        private IDataProvider LoadDataProvider(string path, string dataProvider)
        {
            try
            {
                Assembly assembly = Assembly.LoadFrom(Path.Combine(path, dataProvider) + ".dll");

                object o = assembly.CreateInstance(dataProvider + ".DataProvider");

                if (false == (o is IDataProvider))
                {
                    throw new InvalidOperationException("Data provider does not implement the IDataProvider interface");
                }

                return (o as IDataProvider);
            }
            catch (ArgumentException)
            {
            }
            catch (BadImageFormatException)
            {
            }
            catch (InvalidOperationException)
            {
            }
            catch (IOException)
            {
            }

            return null;
        }

        /// <summary>
        /// Creates a not runnable test method
        /// </summary>
        /// <param name="methodInfo">The method attributes and metadata that was decorated with the DataSourceTestAttribute</param>
        /// <param name="testSuite">The test suite to populate with the not runnable test method</param>
        /// <param name="dataProvider">The data provider name</param>
        private void CreateNotRunnableTestMethod(MethodInfo methodInfo, TestSuite testSuite, string dataProvider)
        {
            NUnitTestMethod testMethod = new NUnitTestMethod(methodInfo);
            testMethod.RunState = RunState.NotRunnable;
            testMethod.IgnoreReason = String.Format("Cannot Load Data Provider '{0}'", dataProvider);
            testSuite.Add(testMethod);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\NUnitAddIns\DataSourceTestAddIn\DataSourceTestAttribute\Properties\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("DataProvider.XML")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("DataProvider.XML")]
[assembly: AssemblyCopyright("Copyright   2008")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("6fd720f0-f725-49de-9e6f-4742385b674e")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\NUnitAddIns\DataSourceTestAddIn\DataProvider.XML\Properties\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("DataProvider.XML")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("DataProvider.XML")]
[assembly: AssemblyCopyright("Copyright   2008")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("6fd720f0-f725-49de-9e6f-4742385b674e")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\NUnitAddIns\DataSourceTestAddIn\DataSourceTestAddIn\Properties\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("DataProvider.XML")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("DataProvider.XML")]
[assembly: AssemblyCopyright("Copyright   2008")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("6fd720f0-f725-49de-9e6f-4742385b674e")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\NUnitAddIns\DataSourceTestAddIn\IDataProvider\IDataProvider.cs ===
//-----------------------------------------------------------------------
// <copyright file="IDataProvider.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   defines the IDataProvider interface that is used by the DataSourceTestAddIn
// </summary>
//-----------------------------------------------------------------------
using System.Reflection;

using NUnit.Core;

namespace DataProvider
{
    public interface IDataProvider
    {
        void CreateTestMethods(MethodInfo methodInfo, TestSuite testSuite, string connectionString, string query);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\NUnitAddIns\DataSourceTestAddIn\IDataProvider\Properties\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("IDataProvider")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("IDataProvider")]
[assembly: AssemblyCopyright("Copyright   2008")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("9409e531-94c5-4492-a433-c78e0e28bdd7")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\OACR\3.0.40203.0\amd64\etc\esp\SqlEye.Native.Annotations.h ===
#if !defined(__midl) && defined(_PREFAST_)

// Data Sink (a parameter scontaining a sql command or connection string to be executed by the API)
//
#define __sql_command  __declspec("SAL_SqlCommand")

#define __sql_connection_string __declspec("SAL_SqlConnectionString")

#define __sql_command_fragment  __declspec("SAL_SqlCommand")

#define __sql_connection_string_fragment __declspec("SAL_SqlConnectionString")

// Data Source (parameter or return value that may contain untrusted data upon return of the API)
//
// Example 1: __sql_untrusted CHAR* GetRegistryValue(CHAR* key)
// Example 2: void GetRegistryValue(CHAR* key, __sqluntrusted __out_ecount_z(cchValue) CHAR* value, size_t cchValue)
//
#define __sql_untrusted  __declspec("SAL_SqlUnTrusted")

// Escaped annotations

// Escaped '
//
#define __sql_escaped_single_quote __declspec("SAL_SqlEscaped")

// Escaped "
//
#define __sql_escaped_double_quote __declspec("SAL_SqlEscaped")

// Escaped ]
//
#define __sql_escaped_right_bracket __declspec("SAL_SqlEscaped")

// Currently escaped-and-delimited annotations expand to the same as __sql_command,
// since the requirement we currently check is that all inputs to such variable
// be escaped and delimited.
//

// Escaped and delimited '
//
#define __sql_escaped_and_delimited_single_quote __declspec("SAL_SqlCommand")

// Escaped and delimited "
//
#define __sql_escaped_and_delimited_double_quote __declspec("SAL_SqlCommand")

// Escaped and delimited ]
//
#define __sql_escaped_and_delimited_right_bracket __declspec("SAL_SqlCommand")

// Trusted: A parameter for which we know safe values are passed at all call sites. 
// One should always avoid using this one, as this annotation results in no checking at the call site.
// Instead use __sql_command, __sql_escaped_* or __sql_escaped_and_delimited_* annotations,
// This is only provided in case of an unmanageable amount of noise occuring due to a large number
// of known-safe callsites.
//
#define __sql_trusted  __declspec("SAL_SqlTrusted")

#else

#define __sql_command 
#define __sql_connection_string  
#define __sql_command_fragment
#define __sql_connection_string_fragment  

#define __sql_untrusted

#define __sql_escaped_single_quote
#define __sql_escaped_double_quote
#define __sql_escaped_right_bracket

#define __sql_escaped_and_delimited_single_quote
#define __sql_escaped_and_delimited_double_quote
#define __sql_escaped_and_delimited_right_bracket

#define __sql_trusted

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\OACR\3.0.40203.0\amd64\inc\oacrdll.h ===
#pragma once
/*****************************************************************************

   Module  : OACRDll
   Owner   : MarcK

   Copyright (c) Microsoft Corporation. All rights reserved.

******************************************************************************

  APIs exported by oacr.dll.
  
  oacr.dll is part of the Microsoft Auto Code Review (OACR) system. 
  It provides the same functionality as oacr.exe. It is intended for build
  integration from build environments using their own executable.

*****************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif

// Typedefs for dynamic loading via LoadLibrary and GetProcAddress
typedef int (__stdcall* OACRCMDWPROC)( const wchar_t* );
typedef int (__stdcall* OACRCMDAPROC)( const char* );


// Run an OACR command. Same command line syntax as the oacr.exe command line tool.
int __stdcall OACRCmdW( const wchar_t* wzCmd );
int __stdcall OACRCmdA( const char* szCmd );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\OACR\3.0.40203.0\amd64\inc\oacr.h ===
#pragma once
/*****************************************************************************

   Module  : OACR
   Owner   : HannesR

******************************************************************************

   Definitions and #defines for OACR support

*****************************************************************************/

// SAL annotations are #defined in this file
#include <sal.h>
#include <specstrings.h>
//#include "oacrsal.h"
#include "pftwarnings.h"

#if( _PREFAST_ )
#if( _MSC_VER < 1400 )
#define _PREFAST2_ 1
#else
#define _PREFAST8_ 1
#endif
#endif

// Allow deprecated Pre Orcas style annotations by default
#ifndef OACR_DEPRECATED
#define OACR_DEPRECATED 1
#endif

#ifndef ARM
#define __oacr_noop __noop
#else
#define __oacr_noop
#endif

#if defined(__cplusplus)
#define __extern_c     extern "C"
#define __extern_cplus extern "C++"
#else
#define __extern_c
#define __extern_cplus
#endif

#define __noreturn __declspec( noreturn )

// size_t is used in some OACR macros
#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif

// OACR keywords:
// annotations undertstood by PREfast plugins

#ifndef _Sealed_method_
// use _Sealed_method_ to specify C# style 'sealed' behavior for methods
#define _Sealed_method_ __oacr_sealed_method
#endif // _Sealed_method_


#ifndef _Sealed_class_
// use _Sealed_class_ to specify C# style 'sealed' behavior for classes
#define _Sealed_class_ __oacr_sealed_class
#endif // _Sealed_class_


#ifndef _SA_deprecated_
// use _SA_deprecated_ to mark functions that should not be called any more
// pass the replacement function as argument to the macro
#define _SA_deprecated_(NewFunctionName) __oacr_sa_deprecated(NewFunctionName)
#endif // _SA_deprecated_


#ifndef _Intl_deprecated_
// annotation used by warning UNMARKED_INTL_DEPRECATED_FUNCTION (25114)
// to mark deprecated functions using LCID parameters
// The annotation is used by Office to cleanup the use of LCIDs
#define _Intl_deprecated_ __oacr_intl_deprecated
#endif // _Intl_deprecated_


#ifndef _Oleo_deprecated_
// Office specifix annotation used by the OLEO effort
#define _Oleo_deprecated_( NewFunctionName ) __oacr_oleo_deprecated(NewFunctionName)
#endif // _Oleo_deprecated_


#ifndef _Rpc_
// use _Rpc_ for functions that used as remote procedure calls, the keyword will silence
// various OACR checks on formal parameters of the marked functions
#define _Rpc_ __oacr_rpc
#endif // _Rpc_


#ifndef _RequireNoThrow_
// use _RequireNoThrow_ inside a compound statement to indicate that the rest of the block
// should not emit exceptions.
#define _RequireNoThrow_ __oacr_requireNoThrow
#endif // _RequireNoThrow_


#ifndef _Canthrow_
// use _Canthrow_ for method declarations of template classes that have throwing and non-throwing
// specializations to suppress warning FUNC_COULD_BE_NOTHROW (25307).
#define _Canthrow_ __oacr_canthrow
#endif // __requireNoThrow


#ifndef _Genericfunctype_
// use _Genericfunctype_ for function typedefs used for arrays of functions of different function types.
// if the typedef is marked as _Genericfunctype_, OACR will not generate DIFFERENT_CALLING_CONVENTION (25018) warnings
// e.g. typedef _Genericfunctype_ void (*FUNCPTR)();
#if( OACR )
#define _Genericfunctype_ __oacr_genericfunctype
#else
#define _Genericfunctype_
#endif
#endif // _Genericfunctype_


#ifndef _Nothrowfunctype_
// use _Nothrowfunctype_ for function typedefs of non exception throwing function pointers
// e.g. typedef _Nothrowfunctype_ void (*FUNCPTR)();
// only assign non throwing functions to typedefs so marked
#define _Nothrowfunctype_ __oacr_nothrowfunctype
#endif // _Nothrowfunctype_


#ifndef _BindReturn_
// stronger than __checkReturn, typically used by functions that return
// a pointer to an allocated object
// e.g _BindReturn_ void* malloc( size_t size );
// void Bar()
// {
//    void* pv;
//    if( ( pv == malloc( 20 ) ) == NULL )      <<<< typo !!
//    ...
// }
#define _BindReturn_ __oacr_bindReturn
#endif // _BindReturn_


#ifndef _Memberinitializer_
// use _Memberinitializer_ for init functions that initialize all members of a class
// e.g.:
// class X
// {
//    int m_i:
//    int m_j:
//    _Memberinitializer_ void Init(){ m_i = m_j = 0; }
// public:
//    X(){ Init(); }
// };
#define _Memberinitializer_ __oacr_memberinitializer
#endif // _Memberinitializer_


#ifndef _Noheap_
// use _Noheap_ classes that should not be instantiated on the heap
// e.g.:
// _Noheap_ class CriticalSection
// {
// public:
//    CriticalSection();
//    ~CriticalSection();
// };
#define _Noheap_ __oacr_noheap
#endif // _Noheap_


#ifndef _Unsafe_string_api_
// use _Unsafe_string_api_ to phase out functions that pass unbound writable buffers
// e.g.
// _Unsafe_string_api_ void MyStrCpy( char* szTo, const char* szFrom );
#define _Unsafe_string_api_ __oacr_unsafe_string_api
#endif // _Unsafe_string_api_


#ifndef _Needsreview_
// use _Needsreview_ to mark functions whose calls need to be reviewed for a
// special reason.
// e.g. a wrapper function to another function that needs to be reviewed
//_Needsreview_ __inline BOOL MsoGetStringTypeExW(LCID Locale, DWORD dwInfoType, LPCWSTR lpSrcStr, int cchSrc, LPWORD lpCharType)
//{
//   return OACR_REVIEWED_CALL("hannesr", GetStringTypeExW(Locale, dwInfoType, lpSrcStr, cchSrc, lpCharType));
//}
// use the OACR_REVIEWED_CALL macro to silent the warning after making sure that the function is used properly
#define _Needsreview_ __oacr_needsreview
#endif // _Needsreview_


#ifndef _Notrunccast_
// use _Notrunccast_ to find unsafe truncating cast on allocating functions taking
// a 16 bit size parameter
// e.g.
// void* MyMalloc( _Notrunccast_ ushort size );
#define _Notrunccast_ __oacr_notrunccast
#endif // _Notrunccast_


#ifndef _Noinference_
// keyword to disable (wrong) Hungarian inference of __count annotations
// inference is disabled for the all formals of the function
// e.g. _Noinference_ void FreePv( void* pv, size_t cb );
#define _Noinference_     __oacr_noinference
#endif // _Noinference_


// Pre Orcas style annotations are deprecated
#if( OACR_DEPRECATED )

#ifndef __sealed_method
#define __sealed_method                      _Sealed_method_
#endif
#ifndef __sealed_class
#define __sealed_class                       _Sealed_class_
#endif
#ifndef __sa_deprecated
#define __sa_deprecated(NewFunctionName)     _SA_deprecated_(NewFunctionName)
#endif
#ifndef __intl_deprecated
#define __intl_deprecated                    _Intl_deprecated_
#endif
#ifndef __oleo_deprecated
#define __oleo_deprecated( NewFunctionName ) _Oleo_deprecated_(NewFunctionName)
#endif
#ifndef __rpc
#define __rpc                                _Rpc_
#endif
#ifndef __requireNoThrow
#define __requireNoThrow                     _RequireNoThrow_
#endif
#ifndef __canthrow
#define __canthrow                           _Canthrow_
#endif
#ifndef __genericfunctype
#define __genericfunctype                    _Genericfunctype_
#endif
#ifndef __nothrowfunctype
#define __nothrowfunctype                    _Nothrowfunctype_
#endif
#ifndef __bindReturn
#define __bindReturn                         _BindReturn_
#endif
#ifndef __memberinitializer
#define __memberinitializer                  _Memberinitializer_
#endif
#ifndef __noheap
#define __noheap                             _Noheap_
#endif
#ifndef __nostack
#define __nostack                            // not supported
#endif
#ifndef __unsafe_string_api
#define __unsafe_string_api                  _Unsafe_string_api_
#endif
#ifndef __needsreview
#define __needsreview                        _Needsreview_
#endif
#ifndef __notrunccast
#define __notrunccast                        _Notrunccast_
#endif
#ifndef __noinference
#define __noinference                        _Noinference_
#endif
#ifndef __min_function
#define __min_function                       // deprecated, use range annotations
#endif
#ifndef __max_function
#define __max_function                       // deprecated, use range annotations
#endif
#ifndef __printf_format_string
#define __printf_format_string               _Printf_format_string_
#endif

#undef __callback
#define __callback                           _Callback_

#ifndef __sa_sealed // use __sealed_method and __sealed_class instead
#if( OACR )
#define __sa_sealed __declspec("_Sealed_")
#else
#define __sa_sealed
#endif
#endif // __sa_sealed

#endif // OACR_DEPRECATED

//-----------------

// OACR helper macros to suppress particular warnings

#ifndef OACR_USE_PTR
// use to suppress constness and related warnings:
// NONCONST_LOCAL (25003), NONCONST_PARAM( 25004), NONCONST_FUNCTION (25005), 
// NONCONST_LOCAL_BUFFERPTR (25032), NONCONST_BUFFER_PARAM (25033)
#if( OACR )
__extern_c void OACRUsePtr( void* p );
#define OACR_USE_PTR( p ) OACRUsePtr( p )
#else
#define OACR_USE_PTR( p ) __oacr_noop
#endif
#endif // OACR_USE_PTR

#ifndef OACR_MEMBER_IS_INITIALIZED_IN_CTOR
// Use to suppress warning UNINITIALIZED_DATAMEMBER (25070) (as issued from a _Memberinitializer_)
// for data members which are correctly initialized in the ctor.
// (Warning 25070 cannot automatically handle member initialization that
// is spread across both ctor initializer list and a _Memberinitializer_ method).
// NOTES: This is functionally to OACR_USE_PTR(&m).
//        Contrast with OACR_MEMBER_IS_INITIALIZED_IN_MEMBERINITIALIZER.
#define OACR_MEMBER_IS_INITIALIZED_IN_CTOR( m ) OACR_USE_PTR( &m )
#endif // OACR_MEMBER_IS_INITIALIZED_IN_CTOR

#ifndef OACR_MEMBER_IS_INITIALIZED_IN_MEMBERINITIALIZER
// Use to suppress warning UNINITIALIZED_DATAMEMBER (25070) (as issued from a ctor)
// for data members which are correctly initialized in the _Memberinitializer_ method.
// (Warning 25070 cannot automatically handle member initialization that
// is spread across both ctor initializer list and a _Memberinitializer_ method).
// NOTES: This is functionally equivalent to OACR_USE_PTR(&m).
//        Contrast with OACR_MEMBER_IS_INITIALIZED_IN_CTOR.
#define OACR_MEMBER_IS_INITIALIZED_IN_MEMBERINITIALIZER( m ) OACR_USE_PTR( &m )
#endif // OACR_MEMBER_IS_INITIALIZED_IN_MEMBERINITIALIZER

#ifndef OACR_POSSIBLE_THROW
// use to suppress __nothrow related warnings NOTHROW_FUNC_THROWS (25306) and FUNC_COULD_BE_NOTHROW (25307)
#if( OACR )
__extern_cplus void OACRPossibleThrow();
#define OACR_POSSIBLE_THROW OACRPossibleThrow()
#else
#define OACR_POSSIBLE_THROW __oacr_noop
#endif
#endif // OACR_POSSIBLE_THROW

#ifndef OACR_ASSUME_NOTHROW_BEGIN
// use with OACR_ASSUME_NOTHROW_END to suppress NOTHROW_FUNC_THROWS warnings around functions that don't throw in this context
// macro pair needs to be on the same scope
#if( OACR )
#define OACR_ASSUME_NOTHROW_BEGIN try{
#define OACR_ASSUME_NOTHROW_END }catch(...){}
#else
#define OACR_ASSUME_NOTHROW_BEGIN
#define OACR_ASSUME_NOTHROW_END
#endif
#endif // OACR_POSSIBLE_THROW

#ifndef UNREFERENCED_OACR
// use to function staticness and related warnings: STATIC_FUNCTION (25007)
#if( OACR )
#define UNREFERENCED_OACR( p ) __assume( p == p )
#else
#define UNREFERENCED_OACR( p )
#endif
#endif // UNREFERENCED_OACR


#ifndef OACR_OWN_PTR
// can be used for objects that attach themselves to an owner
// in their constructors
#if( OACR )
__extern_c void OACROwnPtr( const void* p );
#define OACR_OWN_PTR( p ) OACROwnPtr( p )
#else
#define OACR_OWN_PTR( p ) __oacr_noop
#endif
#endif // OACR_OWN_PTR


#ifndef OACR_PTR_NOT_NULL
// tells OACR that a pointer is not null at this point
#if( OACR )
#define OACR_PTR_NOT_NULL( p ) OACR_ASSUME( 0 != p )
#else
#define OACR_PTR_NOT_NULL( p ) __oacr_noop
#endif
#endif // OACR_PTR_NOT_NULL


#ifndef OACR_NOT_IMPLEMENTED_MEMBER
#if( OACR )
#define OACR_NOT_IMPLEMENTED_MEMBER OACR_USE_PTR( (void*)this )
#else
#define OACR_NOT_IMPLEMENTED_MEMBER
#endif
#endif // OACR_NOT_IMPLEMENTED_MEMBER


#ifndef OACR_DECLARE_FILLER
#if( OACR )
#define OACR_DECLARE_FILLER( type, inst ) type __filler##inst;
#else
#define OACR_DECLARE_FILLER( type, inst )
#endif
#endif // OACR_DECLARE_FILLER


// use this macro once you have inspected warnings FUNCTION_NEEDS_REVIEW (25028)
#ifndef OACR_REVIEWED_CALL
#if( OACR )
__extern_c void __OACRReviewedCall();
#define OACR_REVIEWED_CALL( reviewer, functionCall ) ( __OACRReviewedCall(), functionCall )
#else
#define OACR_REVIEWED_CALL( reviewer, functionCall ) functionCall
#endif
#endif // OACR_REVIEWED_CALL


// use this macro once you have inspected warnings URL_NEEDS_TO_BE_REVIEWED (25085)
#ifndef OACR_REVIEWED_URL
#if( OACR )
__extern_c void __OACRReviewedUrl();
#define OACR_REVIEWED_URL( reviewer, reviewedUrl ) ( __OACRReviewedUrl(), reviewedUrl )
#else
#define OACR_REVIEWED_URL( reviewer, reviewedUrl ) reviewedUrl
#endif
#endif // OACR_REVIEWED_URL

#if( OACR && defined(_WINDEF_) && 0 )

// redefine FALSE & TRUE for better HRESULT<->BOOL conversion detection
#ifdef FALSE
#undef FALSE
#define FALSE ((BOOL)0)
#endif

#ifdef TRUE
#undef TRUE
#define TRUE ((BOOL)1)
#endif

#endif

// Use the following macros to suppress and disable OACR warnings in the code
// Using the macros allows us to have the same source code being compiled with
// PREfast 2.x and Whidbey PREfast

// macro to tell OACR to not issue a specific warning for the following line of code
// use to suppress false positives from OACR
// e.g.
// if( fPointerNotNull )
//    OACR_WARNING_SUPRESS( DEREF_NULL_PTR, "pointer access is guarded by 'fPointerNotNull'" )
//    p->Foo();

#ifndef OACR_WARNING_PUSH
#if( OACR && !defined(OACR_NO_WARNING_MACROS) )
#if( 1400 <=_MSC_VER )
#define OACR_WARNING_PUSH __pragma ( warning( push ) )
#else
#define OACR_WARNING_PUSH __pragma ( prefast( push ) )
#endif
#else
#define OACR_WARNING_PUSH
#endif
#endif

#ifndef OACR_WARNING_POP
#if( OACR && !defined(OACR_NO_WARNING_MACROS) )
#if( 1400 <=_MSC_VER )
#define OACR_WARNING_POP __pragma ( warning( pop ) )
#else
#define OACR_WARNING_POP __pragma ( prefast( pop ) )
#endif
#else
#define OACR_WARNING_POP
#endif
#endif

#ifndef OACR_WARNING_ENABLE
#if( OACR && !defined(OACR_NO_WARNING_MACROS) )
#if( 1400 <=_MSC_VER )
#define OACR_WARNING_ENABLE( cWarning, comment ) __pragma ( warning( enable: __WARNING_##cWarning ) )
#else
#define OACR_WARNING_ENABLE( cWarning, comment )
#endif
#else
#define OACR_WARNING_ENABLE( cWarning, comment )
#endif
#endif

#ifndef OACR_WARNING_DISABLE
#if( OACR && !defined(OACR_NO_WARNING_MACROS) )
#if( 1400 <=_MSC_VER )
#define OACR_WARNING_DISABLE( cWarning, comment ) __pragma ( warning( disable: __WARNING_##cWarning ) )
#else
#define OACR_WARNING_DISABLE( cWarning, comment ) __pragma ( prefast( disable: __WARNING_##cWarning, comment ) )
#endif
#else
#define OACR_WARNING_DISABLE( cWarning, comment )
#endif
#endif

#ifndef OACR_WARNING_SUPPRESS
#if( OACR && !defined(OACR_NO_WARNING_MACROS) )
#if( 1400 <=_MSC_VER )
#define OACR_WARNING_SUPPRESS( cWarning, comment ) __pragma ( warning( suppress: __WARNING_##cWarning ) )
#else
#define OACR_WARNING_SUPPRESS( cWarning, comment ) __pragma ( prefast( suppress: __WARNING_##cWarning, comment) )
#endif
#else
#define OACR_WARNING_SUPPRESS( cWarning, comment )
#endif
#endif

// macro to tell OACR about conditions that are true.
// Use OACR_ASSUME instead of #pragma prefast(suppress,...) if possible
// e.g.:
// if( g_pRoot == NULL ) // global variable g_pRoot
// {
//    InitRoot();
//    OACR_ASSUME( NULL != g_pRoot ); 
// }
// g_pRoot->Traverse();    // without OACR_ASSUME this would cause warning 11
#if( OACR )
#define OACR_ASSUME( fCondition ) __assume( fCondition )

#elif defined(Assert)
#define OACR_ASSUME( fCondition ) Assert( fCondition )

#else
#define OACR_ASSUME( fCondition ) __oacr_noop

#endif

// macro to tell OACR that a string is null terminated at this point of execution
#if( OACR && defined( _Post_z_ ) )
__extern_c void __OACRAssumeNullterminated( _Post_z_ const char* sz );
#define OACR_ASSUME_NULLTERMINATED( string ) __OACRAssumeNullterminated( (const char*)string )

#else
#define OACR_ASSUME_NULLTERMINATED( string ) __oacr_noop

#endif

// macro to tell OACR that a pointer is null valid at this point of execution
#if( OACR && defined( _Post_valid_ ) )
__extern_c void __OACRAssumeValid( _Post_valid_ const void* pv );
#define OACR_ASSUME_VALID( ptr ) __OACRAssumeValid( ptr )

#else
#define OACR_ASSUME_VALID( ptr ) __oacr_noop

#endif


// macro to tell OACR that a buffer has a certain readable extent at this point of execution
// it can be used to silent noisy espX INCORRECT_ANNOTATION warnings
#if( OACR && defined( _Post_bytecount_ ) )
__extern_c void __OACRAssumeByteCount( _Post_bytecount_(cb) const void* pv, size_t cb );
#define OACR_ASSUME_BYTECOUNT( pv, cb ) __OACRAssumeByteCount( pv, cb )

#else
#define OACR_ASSUME_BYTECOUNT( pv, cb ) __oacr_noop

#endif


// new intrinsinc functions in Whidbey compiler
#if( _PREFAST2_ )
__extern_c void* _AddressOfReturnAddress();
#endif

// OACR custom plugin specific extensions

//=======================================================================

#define _Callback_                         __oacr_callback

#undef __override
#define __override                         __oacr_override

//======================================================================
// OACR custom attributes

// OACR custom plugin specific extensions

#if( _USE_ATTRIBUTES_FOR_SAL )

#pragma push_macro( "SA" )
#pragma push_macro( "REPEATABLE" )

#ifdef __cplusplus
#define SA( id ) id
#define REPEATABLE [repeatable]
#else  // !__cplusplus
#define SA( id ) SA_##id
#define REPEATABLE
#endif  // !__cplusplus

enum OACRFunctionFlag
{
   eOACRCallback          = 0x0001,
   eOACRRpc               = 0x0002,
   eOACROverride          = 0x0004,
   eOACRSealed            = 0x0008,
   eOACRMemberInitializer = 0x0010,
   eOACRUnsafeStringApi   = 0x0020,
   eOACRNeedsReview       = 0x0040,
   eOACRIntlDeprecated    = 0x0080,
   eOACRNoInferrence      = 0x0100,
   //eOACRMinFunction     = 0x0200,
   //eOACRMaxFunction     = 0x0400,
   //eOACRCompilerGen     = 0x0800,
   eOACRCanThrow          = 0x1000,
   eOACRBindReturn        = 0x2000,
};

REPEATABLE
[source_annotation_attribute( SA( Method ) )]
struct OACRFunctionFlagsAttribute
{
#ifdef __cplusplus
	OACRFunctionFlagsAttribute();
#endif
	int Flags;
};

enum OACRFunctionProp
{
   eOACRDeprecated     = 0,
   eOACROleoDeprecated = 1,
};

typedef enum OACRFunctionProp OACRFunctionProp;

#pragma warning( push )
#pragma warning( disable:4820 )
REPEATABLE
[source_annotation_attribute( SA( Method ) )]
struct OACRFunctionPropAttribute
{
#ifdef __cplusplus
	OACRFunctionPropAttribute();
#endif
	OACRFunctionProp Type;
   const char*      SzVal;
};
#pragma warning( pop )

#pragma pop_macro( "REPEATABLE" )
#pragma pop_macro( "SA" )

typedef struct OACRFunctionFlagsAttribute SA_OACRFunctionFlags;
typedef struct OACRFunctionPropAttribute  SA_OACRFunctionProp;

//--------------------------------------------------

#ifdef _PREFAST_
// use __declspecs until Whidbey-PREfast bug VS:479840 is fixed
#define __oacr_callback          __declspec("_Callback_")
#define __oacr_override          __declspec("_Override_")
#else  // _PREFAST_
#define __oacr_callback
#define __oacr_override
#endif  // _PREFAST_
//#define __oacr_callback          [method:SA_OACRFunctionFlags(Flags=eOACRCallback         )]
//#define __oacr_override          [method:SA_OACRFunctionFlags(Flags=eOACROverride         )]
#define __oacr_rpc               [method:SA_OACRFunctionFlags(Flags=eOACRRpc)]
#define __oacr_sealed_method     [method:SA_OACRFunctionFlags(Flags=eOACRSealed)]
#define __oacr_memberinitializer [method:SA_OACRFunctionFlags(Flags=eOACRMemberInitializer)]
#define __oacr_unsafe_string_api [method:SA_OACRFunctionFlags(Flags=eOACRUnsafeStringApi)]
#define __oacr_needsreview       [method:SA_OACRFunctionFlags(Flags=eOACRNeedsReview)]
#define __oacr_intl_deprecated   [method:SA_OACRFunctionFlags(Flags=eOACRIntlDeprecated)]
#define __oacr_noinference       [method:SA_OACRFunctionFlags(Flags=eOACRNoInferrence)]
#define __oacr_canthrow          [method:SA_OACRFunctionFlags(Flags=eOACRCanThrow)]
#define __oacr_bindReturn        [method:SA_OACRFunctionFlags(Flags=eOACRBindReturn)]

#define __oacr_sa_deprecated( NewFunctionName )   [method:SA_OACRFunctionProp(Type=eOACRDeprecated,    SzVal=#NewFunctionName)]
#define __oacr_oleo_deprecated( NewFunctionName ) [method:SA_OACRFunctionProp(Type=eOACROleoDeprecated,SzVal=#NewFunctionName)]

#ifdef _PREFAST_
#define __oacr_genericfunctype  __declspec("_Genericfunctype_")
#define __oacr_nothrowfunctype  __declspec("_Nothrowfunctype_")
#define __oacr_noheap           __declspec("_Noheap_" )
#define __oacr_notrunccast      __declspec("_Notrunccast_" )
#define __oacr_sealed_class     __declspec("_Sealed_")
__extern_c int __RequireNoThrow();
#define __oacr_requireNoThrow __RequireNoThrow();
#else  // _PREFAST_
#define __oacr_genericfunctype
#define __oacr_nothrowfunctype
#define __oacr_noheap
#define __oacr_notrunccast
#define __oacr_sealed_class
#define __oacr_requireNoThrow
#endif  // _PREFAST_

#elif( _USE_DECLSPECS_FOR_SAL )

#define __oacr_callback                         __declspec("_Callback_")
#define __oacr_override                         __declspec("_Override_")
#define __oacr_rpc                              __declspec("_Rpc_")
#define __oacr_sealed_method                    __declspec("_Sealed_")
#define __oacr_memberinitializer                __declspec("_Memberinitializer_")
#define __oacr_unsafe_string_api                __declspec("_Unsafe_string_api_")
#define __oacr_needsreview                      __declspec("_Needsreview_")
#define __oacr_intl_deprecated                  __declspec("_Intl_deprecated_")
#define __oacr_noinference                      __declspec("_Noinference_")
#define __oacr_canthrow                         __declspec("_Canthrow_")
#define __oacr_bindReturn                       __declspec("_BindReturn_")
#define __oacr_sa_deprecated(NewFunctionName)   __declspec("_SA_deprecated_("SPECSTRINGIZE(NewFunctionName)")")
#define __oacr_oleo_deprecated(NewFunctionName) __declspec("_Oleo_deprecated_("SPECSTRINGIZE(NewFunctionName)")")
#define __oacr_genericfunctype                  __declspec("_Genericfunctype_")
#define __oacr_nothrowfunctype                  __declspec("__nothrowfunctype") // TODO: change to _Nothrowfunctype_
#define __oacr_noheap                           __declspec("_Noheap_")
#define __oacr_notrunccast                      __declspec("_Notrunccast_")
#define __oacr_sealed_class                     __declspec("_Sealed_")
__extern_c int __RequireNoThrow();
#define __oacr_requireNoThrow __RequireNoThrow();

#else // neither [attributes] not __declspecs

#define __oacr_callback
#define __oacr_override
#define __oacr_rpc
#define __oacr_sealed_method
#define __oacr_memberinitializer
#define __oacr_unsafe_string_api
#define __oacr_needsreview
#define __oacr_intl_deprecated
#define __oacr_noinference
#define __oacr_canthrow
#define __oacr_bindReturn
#define __oacr_sa_deprecated(NewFunctionName)
#define __oacr_oleo_deprecated(NewFunctionName)
#define __oacr_genericfunctype
#define __oacr_nothrowfunctype
#define __oacr_noheap
#define __oacr_notrunccast
#define __oacr_sealed_class
#define __oacr_requireNoThrow

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\OACR\3.0.40203.0\amd64\inc\oacrhook.h ===
#pragma once
/*****************************************************************************

   Module  : OACRHook
   Owner   : MarcK

   Copyright (c) Microsoft Corporation. All rights reserved.

******************************************************************************

  Part of the Microsoft Auto Code Review (OACR) system.
  
  OACR supports hooking into the calls to build tools (cl.exe, link.exe, etc.),
  in order to perform custom operations as part of the build. The user can 
  provide a DLL, which is then loaded and called by OACR at the appropriate
  time. This header file declares the callback function that needs to be
  implemented by the DLL.

*****************************************************************************/

#ifdef __cplusplus

// Callback to process build tool output (stdout,stderr) line by line.
// 'pClientData' is the client data passed to FReadStdOutFile() or FReadStdErrFile().
// Must return true to get next line, or false to abort reading.
typedef bool ( __stdcall *PFNFPROCESSLINE )( const WCHAR* wzLine, void* pClientData );


// The interface passed with each notification.
interface IBuildToolRunInfo
{
   // NOTE: All APIs returning a string, return the number of characters
   //       copied to the output string (not including the NULL termination). 
   //       If the string to be returned is too long, it is truncated, and
   //       the buffer size is returned.
   //       If 0 is passed for the buffer size, the minimum required buffer
   //       size (including the NULL termination) is returned.
   //       In the error case, 0 is returned.

   // Build tools that can be hooked into
   enum Tool
   {
      NONE = 0,

      CL,   // C/C++ compiler (cl.exe)
      CSC,  // C# compiler (csc.exe)
      LINK, // Linker (link.exe)
      LIB,  // Library manager (lib.exe)
      MIDL, // MIDL compiler (midl.exe)
   };

   // Notifications sent
   enum Notification
   {
      BEFORE_RUN,   // Sent before the build tool is called
      AFTER_RUN,    // Sent after the build tools has been run
      AFTER_RETRY,  // Sent after a retry of a build tool run
   };

   //-------------------------------------------------------------------------
   // Client data
   //
   // Can be used to maintain state between notifications for the same build
   // tool run.
   //-------------------------------------------------------------------------

   virtual void  SetClientData( void* pData ) = 0;
   virtual void* GetClientData() const = 0;

   //-------------------------------------------------------------------------
   // Retrieve information - Any notification
   //-------------------------------------------------------------------------

   // Return the current notification.
   virtual Notification GetNotification() const = 0;

   // Return the build tool that triggered the notification.
   virtual Tool GetTool() const = 0;

   // Return the name of the OACR project under which the build tool has been called.
   virtual DWORD GetOACRProjectName( WCHAR* wzProjectName, DWORD cchProjectName ) const = 0;

   // Return the command line, as passed to the build tool.
   virtual DWORD GetCommandLine( WCHAR* wzCommandLine, DWORD cchCommandLine ) const = 0;

   // Return the fully expanded command line. Reponse files (e.g. '@c:\temp\foo.tmp'),
   // and environment variables (e.g. %CL%) are folded into the command line.
   virtual DWORD GetExpandedCommandLine( WCHAR* wzCommandLine, DWORD cchCommandLine ) const = 0;

   // Return the full path name of the build tool executable.
   virtual DWORD GetToolFileName( WCHAR* wzFileName, DWORD cchFileName ) const = 0;

   // Return the full path name of the primary output file generated by the build tool run.
   //    CL  : .obj file
   //    CSC : .exe or .dll (specified in the first /out switch)
   //    LINK: .exe or .dll
   //    LIB : .lib
   //    MIDL: .h file
   // The call fails for CL with multiple source files (batch runs). Use the batch run
   // APIs to get information about batch runs.
   virtual DWORD GetOutputFileName( WCHAR* wzFileName, DWORD cchFileName ) const = 0;

   //
   // Batch run info (CL only)
   //

   // Return true for a batch CL run (i.e. multiple source files)
   virtual bool FBatchRun() const = 0;

   // Return the number of source files in the batch run. Returns 0, for non batch runs.
   virtual DWORD CBatchItems() const = 0;

   // Return the full path name of the output file (.obj) for the source file with the
   // specified index. Returns 0 for non batch runs.
   virtual DWORD GetBatchItemOutputFileName( DWORD whichItem, WCHAR* wzFileName, DWORD cchFileName ) const = 0;

   //-------------------------------------------------------------------------
   // Retrieve information - Notifications 'AFTER_RUN' or 'AFTER_RETRY'
   //-------------------------------------------------------------------------

   // Return the result code for the build tool run.
   virtual int GetResult() const = 0;

   // Return the full path name of the file to which stdout output of the build tool run
   // has been redirected. Returns 0, if stdout redirection is turned off.
   virtual DWORD GetStdOutFileName( WCHAR* wzFileName, DWORD cchFileName ) const = 0;

   // Return the full path name of the file to which stderr output of the build tool run
   // has been redirected. Returns 0, if stderr redirection is turned off.
   virtual DWORD GetStdErrFileName( WCHAR* wzFileName, DWORD cchFileName ) const = 0;

   // Read the redirected stdout output of the build tool run, and send it to the specified
   // callback line by line. Noop, if stdout redirection is turned off.
   virtual bool FReadStdOutFile( PFNFPROCESSLINE pfnFProcessLine, void* pClientData = NULL ) const = 0;

   // Read the redirected stderr output of the build tool run, and send it to the specified
   // callback line by line. Noop, if stderr redirection is turned off.
   virtual bool FReadStdErrFile( PFNFPROCESSLINE pfnFProcessLine, void* pClientData = NULL ) const = 0;

   //
   // Batch run info (CL only)
   //

   // Return true, if the source file with the specified index was compiled successfully.
   // Returns fals for non batch runs.
   virtual bool FBatchItemSuccess( DWORD whichItem ) const = 0;

   //-------------------------------------------------------------------------
   // Generate stdout & stderr output - Any notification
   //-------------------------------------------------------------------------

   // Write to stdout.
   virtual void WriteStdOut( const WCHAR* wzMessage ) const = 0;

   // Write to stderr.
   virtual void WriteStdErr( const WCHAR* wzMessage ) const = 0;

   // Write the content of the specified text file to stdout.
   virtual bool FWriteStdOutFromFile( const WCHAR* wzFileName ) const = 0;

   // Write the content of the specified text file to stderr.
   virtual bool FWriteStdErrFromFile( const WCHAR* wzFileName ) const = 0;

   //-------------------------------------------------------------------------
   // Modify tool run - Any notification
   //-------------------------------------------------------------------------

   // Enable or disable further notifications for this build tool run. 
   // Notifications are enabled by default.
   virtual void SetNotify( bool fNotify ) = 0;

   // Override the result code for the build tool run.
   virtual void SetResult( int result ) = 0;

   // Set the command line to be passed to the build tool.
   virtual void SetCommandLine( const WCHAR* wzCommandLine ) = 0;

   // Set the file name of the build tool executable to be called.
   virtual void SetToolFileName( const WCHAR* wzFileName ) = 0;

   // Enable or disable redirection of stdout output of the build tool run.
   // Redirection is disabled by default.
   virtual void SetCaptureStdOut( bool fCapture ) = 0;

   // Enable or disable redirection of stderr output of the build tool run.
   // Redirection is disabled by default.
   virtual void SetCaptureStdErr( bool fCapture ) = 0;

   //-------------------------------------------------------------------------
   // Modify tool run - Notification 'BEFORE_RUN'
   //-------------------------------------------------------------------------

   // Cancel the build tool run. Use the SetResult() API to set the result code.
   // This is a noop, if called during the AFTER_RUN or AFTER_RETRY notification.
   virtual void CancelRun() = 0;

   //-------------------------------------------------------------------------
   // Modify tool run - Notifications 'AFTER_RUN' or 'AFTER_RETRY'
   //-------------------------------------------------------------------------

   // Force a retry of the build tool run.
   // This is a noop, if called during the BEFORE_RUN notification.
   virtual void RetryRun() = 0;

}; // IBuildToolRunInfo


// The callback that is called by OACR.
// This method needs to be implemented in the user provided DLL, so that OACR 
// can call it through LoadLibrary()/GetProcAddress()
extern "C" _Callback_ void __stdcall OnBuildToolRun( _In_ IBuildToolRunInfo& toolRunInfo );

#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\OACR\3.0.40203.0\amd64\inc\pftwarnings.h ===
#pragma once
/*****************************************************************************

DO NOT EDIT - Generated file

PREfast Warning Ids

PREfast(x86)      : 9.0.21022.30
Defect modules
   mspft          : 9.0.21022.30
   cntincs        : 9.0.21022.31202
   EspCxxDrv      : 9.0.21022.30908
   espx           : 9.0.21022.30208
   GoldPft        : 9.0.21022.40216
   IntegerOverflow: 9.0.21022.21217
   oacrcplus      : 9.0.21022.40217
   oacrexc        : 9.0.21022.40217
   oacrmodel      : 9.0.21022.40213
   SALCheck       : 9.0.21022.30208

PREfast(amd64)    : 9.0.21022.30
Defect modules
   mspft          : 9.0.21022.30
   cntincs        : 9.0.21022.31202
   EspCxxDrv      : 9.0.21022.30908
   espx           : 9.0.21022.30208
   GoldPft        : 9.0.21022.40216
   IntegerOverflow: 9.0.21022.21217
   oacrcplus      : 9.0.21022.40217
   oacrexc        : 9.0.21022.40217
   oacrmodel      : 9.0.21022.40213
   SALCheck       : 9.0.21022.30208

Esp               : 1.2.30415.30908
Defect modules
   CfgPersist     : 1.2.30415.30908
   EspBldChk      : 1.2.30415.30908
   EspOpal        : 1.2.30415.30908
   NullPtr        : 1.2.30415.30908
   SqlEye.TSQL    : 1.2.30415.30516
   In             : <no version>
   SqlEye.Managed.EscapingAndDelimiting: <no version>
   SqlEye.Native.EscapingAndDelimiting: <no version>
   SqlEye.Native.MissingCommandSal: <no version>
   SqlEye.Native.MissingConnectionStringSal: <no version>
   SqlEye.Native.Truncation: <no version>
   SqlEye.TSql.EscapingAndDelimiting: <no version>

Generated on 02/20/09 at 13:42:15

*****************************************************************************/


#ifdef _PREFAST_

/* MSPFT */

#define __WARNING_6001 6001
#define __WARNING_USING_UNINIT_VAR 6001
#define __WARNING_6011 6011
#define __WARNING_DEREF_NULL_PTR 6011
#define __WARNING_6029 6029
#define __WARNING_USING_TAINTED_DATA 6029
#define __WARNING_6031 6031
#define __WARNING_RETVAL_IGNORED_FUNC_COULD_FAIL 6031
#define __WARNING_6053 6053
#define __WARNING_MISSING_ZERO_TERMINATION1 6053
#define __WARNING_6054 6054
#define __WARNING_MISSING_ZERO_TERMINATION2 6054
#define __WARNING_6057 6057
#define __WARNING_CHAR_BYTE_SIZE_MISMATCH 6057
#define __WARNING_6059 6059
#define __WARNING_BAD_CONCATENATION 6059
#define __WARNING_6063 6063
#define __WARNING_MISSING_STRING_ARGUMENT_TO_FORMAT_FUNCTION 6063
#define __WARNING_6064 6064
#define __WARNING_MISSING_INTEGER_ARGUMENT_TO_FORMAT_FUNCTION 6064
#define __WARNING_6066 6066
#define __WARNING_NON_POINTER_ARGUMENT_TO_FORMAT_FUNCTION 6066
#define __WARNING_6067 6067
#define __WARNING_NON_STRING_ARGUMENT_TO_FORMAT_FUNCTION 6067
#define __WARNING_6200 6200
#define __WARNING_INDEX_EXCEEDS_MAX_NONSTACK 6200
#define __WARNING_6201 6201
#define __WARNING_INDEX_EXCEEDS_MAX 6201
#define __WARNING_6202 6202
#define __WARNING_BUFFER_OVERRUN 6202
#define __WARNING_6203 6203
#define __WARNING_BUFFER_OVERRUN_NONSTACK 6203
#define __WARNING_6204 6204
#define __WARNING_UNVALIDATED_PARAM 6204
#define __WARNING_6209 6209
#define __WARNING_SIZEOF_CHAR_BYTE_SIZE_MISMATCH 6209
#define __WARNING_6211 6211
#define __WARNING_MEMORY_LEAK_EXCEPTION 6211
#define __WARNING_6214 6214
#define __WARNING_CAST_HRESULT_TO_BOOL 6214
#define __WARNING_6215 6215
#define __WARNING_CAST_BOOL_TO_HRESULT 6215
#define __WARNING_6216 6216
#define __WARNING_COMPILER_INSERTED_CAST_BOOL_TO_HRESULT 6216
#define __WARNING_6217 6217
#define __WARNING_TESTING_HRESULT_WITH_NOT 6217
#define __WARNING_6219 6219
#define __WARNING_COMPARING_HRESULT_TO_ONE 6219
#define __WARNING_6220 6220
#define __WARNING_COMPARING_HRESULT_TO_MINUS_ONE 6220
#define __WARNING_6221 6221
#define __WARNING_COMPARING_HRESULT_TO_INT 6221
#define __WARNING_6225 6225
#define __WARNING_ASSIGNING_ONE_TO_HRESULT 6225
#define __WARNING_6226 6226
#define __WARNING_ASSIGNING_MINUS_ONE_TO_HRESULT 6226
#define __WARNING_6230 6230
#define __WARNING_USING_HRESULT_IN_BOOLEAN_CONTEXT 6230
#define __WARNING_6235 6235
#define __WARNING_NONZEROLOGICALOR 6235
#define __WARNING_6236 6236
#define __WARNING_LOGICALORNONZERO 6236
#define __WARNING_6237 6237
#define __WARNING_ZEROLOGICALANDLOSINGSIDEEFFECTS 6237
#define __WARNING_6239 6239
#define __WARNING_NONZEROLOGICALAND 6239
#define __WARNING_6240 6240
#define __WARNING_LOGICALANDNONZERO 6240
#define __WARNING_6242 6242
#define __WARNING_LOCALUNWINDFORCED 6242
#define __WARNING_6244 6244
#define __WARNING_LOCALDECLHIDESGLOBAL 6244
#define __WARNING_6246 6246
#define __WARNING_LOCALDECLHIDESLOCAL 6246
#define __WARNING_6248 6248
#define __WARNING_CREATINGNULLDACL 6248
#define __WARNING_6250 6250
#define __WARNING_WIN32UNRELEASEDVADS 6250
#define __WARNING_6255 6255
#define __WARNING_UNPROTECTEDUSEOFALLOCA 6255
#define __WARNING_6258 6258
#define __WARNING_USINGTERMINATETHREAD 6258
#define __WARNING_6259 6259
#define __WARNING_DEADCODEINBITORLIMITEDSWITCH 6259
#define __WARNING_6260 6260
#define __WARNING_USEOFBYTEAREA 6260
#define __WARNING_6262 6262
#define __WARNING_EXCESSIVESTACKUSAGE 6262
#define __WARNING_6263 6263
#define __WARNING_USINGALLOCAINLOOP 6263
#define __WARNING_6268 6268
#define __WARNING_MISPARENTHESIZED_CASTS 6268
#define __WARNING_6269 6269
#define __WARNING_POINTER_DEREF_DISCARDED 6269
#define __WARNING_6270 6270
#define __WARNING_MISSING_FLOAT_ARGUMENT_TO_FORMAT_FUNCTION 6270
#define __WARNING_6271 6271
#define __WARNING_EXTRA_ARGUMENT_TO_FORMAT_FUNCTION 6271
#define __WARNING_6272 6272
#define __WARNING_NON_FLOAT_ARGUMENT_TO_FORMAT_FUNCTION 6272
#define __WARNING_6273 6273
#define __WARNING_NON_INTEGER_ARGUMENT_TO_FORMAT_FUNCTION 6273
#define __WARNING_6274 6274
#define __WARNING_NON_CHAR_ARGUMENT_TO_FORMAT_FUNCTION 6274
#define __WARNING_6276 6276
#define __WARNING_CHAR_TO_WCHAR_CAST 6276
#define __WARNING_6277 6277
#define __WARNING_CREATEPROCESS_ESCAPE 6277
#define __WARNING_6278 6278
#define __WARNING_ARRAY_NEW_DELETE_MISMATCH 6278
#define __WARNING_6279 6279
#define __WARNING_NEW_ARRAY_DELETE_MISMATCH 6279
#define __WARNING_6280 6280
#define __WARNING_MEMORY_ALLOCATION_MISMATCH 6280
#define __WARNING_6281 6281
#define __WARNING_BITWISERELATIONPRECEDENCEERROR 6281
#define __WARNING_6282 6282
#define __WARNING_ASSIGNMENTREPLACESTEST 6282
#define __WARNING_6283 6283
#define __WARNING_PRIMITIVE_ARRAY_NEW_DELETE_MISMATCH 6283
#define __WARNING_6284 6284
#define __WARNING_OBJECT_AS_STRING_ARGUMENT_TO_FORMAT_FUNCTION 6284
#define __WARNING_6285 6285
#define __WARNING_LOGICALOROFCONSTANTS 6285
#define __WARNING_6286 6286
#define __WARNING_NONZEROLOGICALORLOSINGSIDEEFFECTS 6286
#define __WARNING_6287 6287
#define __WARNING_REDUNDANTTEST 6287
#define __WARNING_6288 6288
#define __WARNING_MUTUALINCLUSIONOVERANDISFALSE 6288
#define __WARNING_6289 6289
#define __WARNING_MUTUALEXCLUSIONOVERORISTRUE 6289
#define __WARNING_6290 6290
#define __WARNING_LOGICALNOTBITWISEAND 6290
#define __WARNING_6291 6291
#define __WARNING_LOGICALNOTBITWISEOR 6291
#define __WARNING_6292 6292
#define __WARNING_LOOP_COUNTS_UP_FROM_MAX 6292
#define __WARNING_6293 6293
#define __WARNING_LOOP_INDEX_GOES_NEGATIVE 6293
#define __WARNING_6294 6294
#define __WARNING_LOOP_BODY_NEVER_EXECUTED 6294
#define __WARNING_6295 6295
#define __WARNING_INFINITE_LOOP 6295
#define __WARNING_6296 6296
#define __WARNING_LOOP_ONLY_EXECUTED_ONCE 6296
#define __WARNING_6297 6297
#define __WARNING_RESULTOFSHIFTCASTTOLARGERSIZE 6297
#define __WARNING_6298 6298
#define __WARNING_CONST_STRING_TO_WRITABLE_STRING 6298
#define __WARNING_6299 6299
#define __WARNING_BITFIELD_TO_BOOL_COMPARISON 6299
#define __WARNING_6302 6302
#define __WARNING_CHAR_WCHAR_ARGUMENT_TO_FORMAT_FUNCTION 6302
#define __WARNING_6303 6303
#define __WARNING_WCHAR_CHAR_ARGUMENT_TO_FORMAT_FUNCTION 6303
#define __WARNING_6305 6305
#define __WARNING_SIZEOF_COUNTOF_MISMATCH 6305
#define __WARNING_6306 6306
#define __WARNING_INCORRECT_VARARG_FUNCTIONCALL 6306
#define __WARNING_6308 6308
#define __WARNING_REALLOCLEAK 6308
#define __WARNING_6309 6309
#define __WARNING_PASSING_FUNCTION_UNEXPECTED_NULL 6309
#define __WARNING_6310 6310
#define __WARNING_ILLEGALEXCEPTEXPRCONST 6310
#define __WARNING_6312 6312
#define __WARNING_EXCEPTIONCONTINUEEXECUTION 6312
#define __WARNING_6313 6313
#define __WARNING_BITANDVSZEROVALUEDFLAG 6313
#define __WARNING_6314 6314
#define __WARNING_BITORVSQUESTION 6314
#define __WARNING_6315 6315
#define __WARNING_BITORVSBITAND 6315
#define __WARNING_6316 6316
#define __WARNING_INAPPROPRIATEUSEOFBITOR 6316
#define __WARNING_6317 6317
#define __WARNING_NOTNOTCOMPLEMENT 6317
#define __WARNING_6318 6318
#define __WARNING_EXCEPTIONCONTINUESEARCH 6318
#define __WARNING_6319 6319
#define __WARNING_IGNOREDBYCOMMA 6319
#define __WARNING_6320 6320
#define __WARNING_EXCEPTIONEXECUTEHANDLER 6320
#define __WARNING_6322 6322
#define __WARNING_EXCEPT_BLOCK_EMPTY 6322
#define __WARNING_6323 6323
#define __WARNING_ARITH_OP_ON_BOOL 6323
#define __WARNING_6324 6324
#define __WARNING_STRCPY_INSTEAD_OF_STRCMP 6324
#define __WARNING_6326 6326
#define __WARNING_CONST_CONST_COMP 6326
#define __WARNING_6327 6327
#define __WARNING_DEST_BUFFER_INSUFFICIENT 6327
#define __WARNING_6328 6328
#define __WARNING_POTENTIAL_ARGUMENT_TYPE_MISMATCH 6328
#define __WARNING_6329 6329
#define __WARNING_POTENTIAL_INCORRECT_RETVAL_CHECK 6329
#define __WARNING_6331 6331
#define __WARNING_VIRTUALFREEINVALIDPARAM1 6331
#define __WARNING_6332 6332
#define __WARNING_VIRTUALFREEINVALIDPARAM2 6332
#define __WARNING_6333 6333
#define __WARNING_VIRTUALFREEINVALIDPARAM3 6333
#define __WARNING_6334 6334
#define __WARNING_SIZEOFEXPR 6334
#define __WARNING_6335 6335
#define __WARNING_LEAKING_PROCESS_HANDLE 6335
#define __WARNING_6336 6336
#define __WARNING_QUESTIONPRECEDENCE 6336
#define __WARNING_6381 6381
#define __WARNING_SHUTDOWN_API 6381
#define __WARNING_6383 6383
#define __WARNING_ELEMENTS_TO_BYTES 6383
#define __WARNING_6384 6384
#define __WARNING_DIVIDING_SIZEOF_POINTER 6384
#define __WARNING_6385 6385
#define __WARNING_READ_OVERRUN 6385
#define __WARNING_6386 6386
#define __WARNING_WRITE_OVERRUN 6386
#define __WARNING_6387 6387
#define __WARNING_INVALID_PARAM_VALUE_1 6387
#define __WARNING_6388 6388
#define __WARNING_INVALID_PARAM_VALUE_2 6388
#define __WARNING_6400 6400
#define __WARNING_LOCALE_DEPENDENT_CONSTANT_STRING_COMPARISON 6400
#define __WARNING_6401 6401
#define __WARNING_DEFAULT_LOCALE_CONSTANT_STRING_COMPARISON 6401
#define __WARNING_6500 6500
#define __WARNING_INVALID_ATTRIBUTE_PROPERTY 6500
#define __WARNING_6501 6501
#define __WARNING_CONFLICTING_ATTRIBUTE_PROPERTY_VALUES 6501
#define __WARNING_6503 6503
#define __WARNING_REFERENCES_CANT_BE_NULL 6503
#define __WARNING_6504 6504
#define __WARNING_NULL_ON_NON_POINTER 6504
#define __WARNING_6505 6505
#define __WARNING_MUSTCHECK_ON_VOID 6505
#define __WARNING_6506 6506
#define __WARNING_BUFFER_SIZE_ON_NON_POINTER_OR_ARRAY 6506
#define __WARNING_6507 6507
#define __WARNING_NULL_MISMATCH_AT_DEREF_0 6507
#define __WARNING_6508 6508
#define __WARNING_WRITE_ACCESS_ON_CONST 6508
#define __WARNING_6509 6509
#define __WARNING_RETURN_USED_ON_PRECONDITION 6509
#define __WARNING_6510 6510
#define __WARNING_NULLTERMINATED_ON_NON_POINTER 6510
#define __WARNING_6511 6511
#define __WARNING_MUSTCHECK_MAYBE 6511
#define __WARNING_6512 6512
#define __WARNING_NULL_CONFLICTS_WITH_NOT_VALID 6512
#define __WARNING_6513 6513
#define __WARNING_ELEMENT_SIZE_WITHOUT_BUFFER_SIZE 6513
#define __WARNING_6514 6514
#define __WARNING_BUFFER_SIZE_EXCEEDS_ARRAY_SIZE 6514
#define __WARNING_6515 6515
#define __WARNING_BUFFER_SIZE_ON_NON_POINTER 6515
#define __WARNING_6516 6516
#define __WARNING_NO_PROPERTIES_ON_ATTRIBUTE 6516
#define __WARNING_6517 6517
#define __WARNING_VALID_SIZE_ON_NON_READABLE_BUFFER 6517
#define __WARNING_6518 6518
#define __WARNING_WRITABLE_SIZE_ON_NON_WRITABLE_BUFFER 6518
#define __WARNING_6521 6521
#define __WARNING_INVALID_SIZE_STRING_DEREF 6521
#define __WARNING_6522 6522
#define __WARNING_INVALID_SIZE_STRING_TYPE 6522
#define __WARNING_6523 6523
#define __WARNING_INVALID_SIZE_STRING_PARAM 6523
#define __WARNING_6525 6525
#define __WARNING_INVALID_SIZE_STRING_UNREACHABLE_LOCATION 6525
#define __WARNING_6526 6526
#define __WARNING_INVALID_SIZE_STRING_BUFFER_TYPE 6526
#define __WARNING_6530 6530
#define __WARNING_UNRECOGNIZED_FORMAT_STRING_STYLE 6530
#define __WARNING_6535 6535
#define __WARNING_BUFFERSIZE_INFEASIBLE 6535
#define __WARNING_6540 6540
#define __WARNING_OVERRIDING_OLD_MODEL 6540
#define __WARNING_6990 6990
#define __WARNING_MANAGEDCODENOTSUPPORTED 6990
#define __WARNING_6991 6991
#define __WARNING_ATTRIBUTESNOTSUPPORTED 6991
#define __WARNING_6992 6992
#define __WARNING_NATIVEEVENTSYNTAXNOTSUPPORTED 6992
#define __WARNING_6993 6993
#define __WARNING_OMPNOTSUPPORTED 6993
#define __WARNING_6994 6994
#define __WARNING_PCHNOTFOUND 6994
#define __WARNING_6995 6995
#define __WARNING_SAVETOXMLFAILED 6995

/* IntegerOverflow */

#define __WARNING_22010 22010
#define __WARNING_DUMMY_IO_WARNING1 22010
#define __WARNING_22011 22011
#define __WARNING_ALLOC_SIZE_OVERFLOW 22011
#define __WARNING_22012 22012
#define __WARNING_ALLOC_SIZE_WRONG_OVERFLOW_CHECK 22012
#define __WARNING_22013 22013
#define __WARNING_INDEX_WRONG_OVERFLOW_CHECK 22013
#define __WARNING_22014 22014
#define __WARNING_ALLOC_SIZE_NEGATIVE 22014
#define __WARNING_22015 22015
#define __WARNING_INDEX_NEGATIVE 22015
#define __WARNING_22016 22016
#define __WARNING_LOOP_INDEX_WRONG_OVERFLOW_CHECK 22016
#define __WARNING_22017 22017
#define __WARNING_ALLOC_SIZE_UNDERFLOW 22017
#define __WARNING_22018 22018
#define __WARNING_INDEX_UNDERFLOW 22018
#define __WARNING_22019 22019
#define __WARNING_LOOP_INDEX_UNDERFLOW 22019
#define __WARNING_22020 22020
#define __WARNING_SIGNED_UNSIGNED_COMPARISON 22020
#define __WARNING_22021 22021
#define __WARNING_DIFF_SIZE_SIGNED_UNSIGNED_COMPARISON 22021
#define __WARNING_22022 22022
#define __WARNING_ALLOC_SIZE_OVERFLOW_WITH_ACCESS 22022
#define __WARNING_22023 22023
#define __WARNING_ALLOC_SIZE_OVERFLOW_IN_ALLOC_WRAPPER 22023
#define __WARNING_22024 22024
#define __WARNING_ALLOC_SIZE_UNDERFLOW_IN_ALLOC_WRAPPER 22024
#define __WARNING_22025 22025
#define __WARNING_RETVAL_IS_USED_IN_ALLOC_SIZE_COMPUTATION 22025
#define __WARNING_22026 22026
#define __WARNING_REFARG_IS_USED_IN_ALLOC_SIZE_COMPUTATION 22026
#define __WARNING_22027 22027
#define __WARNING_OVERFLOW_OR_UNDERFLOW_IN_ALLOCATOR_SIZE_FUNC_RETVAL 22027
#define __WARNING_22028 22028
#define __WARNING_OVERFLOW_OR_UNDERFLOW_IN_ALLOCATOR_SIZE_FUNC_REFARG 22028
#define __WARNING_22029 22029
#define __WARNING_OVERFLOW_OR_UNDERFLOW_IN_ALLOC_SIZE 22029
#define __WARNING_22030 22030
#define __WARNING_OVERFLOW_OR_UNDERFLOW_IN_ALLOC_WRAPPER 22030
#define __WARNING_22051 22051
#define __WARNING_UNTRUSTED_ALLOC_SIZE_OVERFLOW 22051
#define __WARNING_22052 22052
#define __WARNING_UNTRUSTED_ALLOC_SIZE_WRONG_OVERFLOW_CHECK 22052
#define __WARNING_22053 22053
#define __WARNING_UNTRUSTED_INDEX_WRONG_OVERFLOW_CHECK 22053
#define __WARNING_22054 22054
#define __WARNING_UNTRUSTED_ALLOC_SIZE_NEGATIVE 22054
#define __WARNING_22055 22055
#define __WARNING_UNTRUSTED_INDEX_NEGATIVE 22055
#define __WARNING_22056 22056
#define __WARNING_UNTRUSTED_LOOP_INDEX_WRONG_OVERFLOW_CHECK 22056
#define __WARNING_22057 22057
#define __WARNING_UNTRUSTED_ALLOC_SIZE_UNDERFLOW 22057
#define __WARNING_22058 22058
#define __WARNING_UNTRUSTED_INDEX_UNDERFLOW 22058
#define __WARNING_22059 22059
#define __WARNING_UNTRUSTED_LOOP_INDEX_UNDERFLOW 22059
#define __WARNING_22060 22060
#define __WARNING_UNTRUSTED_SIGNED_UNSIGNED_COMPARISON 22060
#define __WARNING_22061 22061
#define __WARNING_UNTRUSTED_DIFF_SIZE_SIGNED_UNSIGNED_COMPARISON 22061
#define __WARNING_22062 22062
#define __WARNING_UNTRUSTED_ALLOC_SIZE_OVERFLOW_WITH_ACCESS 22062
#define __WARNING_22063 22063
#define __WARNING_UNTRUSTED_ALLOC_SIZE_OVERFLOW_IN_ALLOC_WRAPPER 22063
#define __WARNING_22064 22064
#define __WARNING_UNTRUSTED_ALLOC_SIZE_UNDERFLOW_IN_ALLOC_WRAPPER 22064
#define __WARNING_22067 22067
#define __WARNING_UNTRUSTED_OVERFLOW_OR_UNDERFLOW_IN_ALLOCATOR_SIZE_FUNC_RETVAL 22067
#define __WARNING_22068 22068
#define __WARNING_UNTRUSTED_OVERFLOW_OR_UNDERFLOW_IN_ALLOCATOR_SIZE_FUNC_REFARG 22068
#define __WARNING_22069 22069
#define __WARNING_UNTRUSTED_OVERFLOW_OR_UNDERFLOW_IN_ALLOC_SIZE 22069
#define __WARNING_22070 22070
#define __WARNING_UNTRUSTED_OVERFLOW_OR_UNDERFLOW_IN_ALLOC_WRAPPER 22070
#define __WARNING_22081 22081
#define __WARNING_UNTRUSTED_ALLOC_SIZE 22081
#define __WARNING_22082 22082
#define __WARNING_UNTRUSTED_INDEX 22082
#define __WARNING_22083 22083
#define __WARNING_UNTRUSTED_LOOP_INDEX 22083
#define __WARNING_22084 22084
#define __WARNING_UNTRUSTED_OVERFLOWN_EXPR 22084
#define __WARNING_22085 22085
#define __WARNING_UNTRUSTED_UNDERFLOWN_EXPR 22085

/* OACRCPLUS */

#define __WARNING_25000 25000
#define __WARNING_BIG_FORMAL_PARAM 25000
#define __WARNING_25001 25001
#define __WARNING_IMPLICIT_CTOR 25001
#define __WARNING_25002 25002
#define __WARNING_UPCAST_CTOR 25002
#define __WARNING_25003 25003
#define __WARNING_NONCONST_LOCAL 25003
#define __WARNING_25004 25004
#define __WARNING_NONCONST_PARAM 25004
#define __WARNING_25005 25005
#define __WARNING_NONCONST_FUNCTION 25005
#define __WARNING_25006 25006
#define __WARNING_UNUSED_PARAM 25006
#define __WARNING_25007 25007
#define __WARNING_STATIC_FUNCTION 25007
#define __WARNING_25008 25008
#define __WARNING_FREE_CONSTRUCTOR_CALL 25008
#define __WARNING_25009 25009
#define __WARNING_IDENTITY_ASSIGNMENT 25009
#define __WARNING_25010 25010
#define __WARNING_VIRTUAL_CALL_IN_CTOR 25010
#define __WARNING_25011 25011
#define __WARNING_CASE_FALLTHRU 25011
#define __WARNING_25012 25012
#define __WARNING_SMARTPOINTER_DELETE 25012
#define __WARNING_25013 25013
#define __WARNING_RETURN_FROM_GOTO_CONTEXT 25013
#define __WARNING_25014 25014
#define __WARNING_MISSING_OVERRIDE 25014
#define __WARNING_25015 25015
#define __WARNING_DOESNT_OVERRIDE 25015
#define __WARNING_25016 25016
#define __WARNING_OVERRIDE_CONST_MISMATCH 25016
#define __WARNING_25017 25017
#define __WARNING_OVERRIDING_NONVIRTUAL 25017
#define __WARNING_25018 25018
#define __WARNING_DIFFERENT_CALLING_CONVENTION 25018
#define __WARNING_25019 25019
#define __WARNING_VERYBIG_FORMAL_PARAM 25019
#define __WARNING_25020 25020
#define __WARNING_SAMENAME_DATAMEMBER 25020
#define __WARNING_25021 25021
#define __WARNING_POOR_DATAALIGNMENT 25021
#define __WARNING_25022 25022
#define __WARNING_REMOVERETURNCONST_FUNCTIONCAST 25022
#define __WARNING_25023 25023
#define __WARNING_BOGUS_BSTRCONST 25023
#define __WARNING_25024 25024
#define __WARNING_DANGEROUS_POINTERCAST 25024
#define __WARNING_25025 25025
#define __WARNING_UNSAFE_STRING_FUNCTION 25025
#define __WARNING_25026 25026
#define __WARNING_OBSOLETE_INI_ACCESSOR 25026
#define __WARNING_25027 25027
#define __WARNING_BANNED_FUNCTION 25027
#define __WARNING_25028 25028
#define __WARNING_FUNCTION_NEEDS_REVIEW 25028
#define __WARNING_25029 25029
#define __WARNING_OBSOLETE_ACL_FUNCTION 25029
#define __WARNING_25030 25030
#define __WARNING_BOGUS_EXPRESSION_LIST 25030
#define __WARNING_25031 25031
#define __WARNING_HRESULT_NOT_CHECKED 25031
#define __WARNING_25032 25032
#define __WARNING_NONCONST_LOCAL_BUFFERPTR 25032
#define __WARNING_25033 25033
#define __WARNING_NONCONST_BUFFER_PARAM 25033
#define __WARNING_25035 25035
#define __WARNING_SIZEOF_POINTER_IN_DIVISION 25035
#define __WARNING_25036 25036
#define __WARNING_STATIC_MASKING_VIRTUAL 25036
#define __WARNING_25037 25037
#define __WARNING_TRUE_CONSTANT_EXPR_IN_AND 25037
#define __WARNING_25038 25038
#define __WARNING_FALSE_CONSTANT_EXPR_IN_AND 25038
#define __WARNING_25039 25039
#define __WARNING_TRUE_CONSTANT_EXPR_IN_OR 25039
#define __WARNING_25040 25040
#define __WARNING_FALSE_CONSTANT_EXPR_IN_OR 25040
#define __WARNING_25041 25041
#define __WARNING_IF_CONDITION_IS_ALWAYS_TRUE 25041
#define __WARNING_25042 25042
#define __WARNING_IF_CONDITION_IS_ALWAYS_FALSE 25042
#define __WARNING_25043 25043
#define __WARNING_LOCAL_BSTR_SHOULD_BE_CONST_WCHAR_PTR 25043
#define __WARNING_25044 25044
#define __WARNING_BSTR_PARAM_SHOULD_BE_CONST_WCHAR_PTR 25044
#define __WARNING_25045 25045
#define __WARNING_ISBADPTR_FUNCTION 25045
#define __WARNING_25046 25046
#define __WARNING_SPECIFY_SELECTANY 25046
#define __WARNING_25047 25047
#define __WARNING_INCORRECT_SELECTANY 25047
#define __WARNING_25048 25048
#define __WARNING_STRINGCONST_ASSIGNED_TO_NONCONST 25048
#define __WARNING_25049 25049
#define __WARNING_FREESTANDING_CONSTANT 25049
#define __WARNING_25050 25050
#define __WARNING_LOCAL_FUNCDECL 25050
#define __WARNING_25051 25051
#define __WARNING_DIFFERENT_RETURN_TYPE_SIZE 25051
#define __WARNING_25052 25052
#define __WARNING_DIFFERENT_RETURN_TYPE_KIND 25052
#define __WARNING_25053 25053
#define __WARNING_DIFFERENT_PARAM_COUNT 25053
#define __WARNING_25054 25054
#define __WARNING_DIFFERENT_PARAM_TYPE_SIZE 25054
#define __WARNING_25055 25055
#define __WARNING_DIFFERENT_PARAM_TYPE_KIND 25055
#define __WARNING_25056 25056
#define __WARNING_REMOVEPARAMCONST_FUNCTIONCAST 25056
#define __WARNING_25057 25057
#define __WARNING_COUNT_REQUIRED_FOR_WRITABLE_BUFFER 25057
#define __WARNING_25058 25058
#define __WARNING_CAST_CAN_BE_CONST 25058
#define __WARNING_25059 25059
#define __WARNING_SUPERFLUOUS_CAST 25059
#define __WARNING_25060 25060
#define __WARNING_SUPERFLUOUS_NOTNOT 25060
#define __WARNING_25061 25061
#define __WARNING_BACKWARD_JUMP 25061
#define __WARNING_25062 25062
#define __WARNING_BACKWARD_JUMP_IN_MACRO 25062
#define __WARNING_25063 25063
#define __WARNING_FILEMAPPING_WITH_GLOBAL_NAME 25063
#define __WARNING_25064 25064
#define __WARNING_FUNCTION_CALLED_TWICE_IN_MACRO 25064
#define __WARNING_25065 25065
#define __WARNING_UNSIGNED_SHORT_NEGATIVE_INT_COMPARISON 25065
#define __WARNING_25066 25066
#define __WARNING_OUTOFRANGE_SHORT_LONG_COMPARISON 25066
#define __WARNING_25067 25067
#define __WARNING_UNREACHABLE_CASE_LABEL 25067
#define __WARNING_25068 25068
#define __WARNING_USE_WIDE_API 25068
#define __WARNING_25069 25069
#define __WARNING_GOTO 25069
#define __WARNING_25070 25070
#define __WARNING_UNINITIALIZED_DATAMEMBER 25070
#define __WARNING_25071 25071
#define __WARNING_NO_MEMBERINIT 25071
#define __WARNING_25073 25073
#define __WARNING_WRONG_MEMBERINIT_ORDER 25073
#define __WARNING_25075 25075
#define __WARNING_NOHEAP_MEMBER 25075
#define __WARNING_25076 25076
#define __WARNING_NOHEAP_BASECLASS 25076
#define __WARNING_25077 25077
#define __WARNING_NEW_ON_NOHEAP 25077
#define __WARNING_25078 25078
#define __WARNING_CONDITIONAL_WITH_FALSE_TRUE 25078
#define __WARNING_25079 25079
#define __WARNING_CONDITIONAL_WITH_TRUE_FALSE 25079
#define __WARNING_25080 25080
#define __WARNING_CONDITIONAL_WITH_SAME_ALTERNATIVES 25080
#define __WARNING_25084 25084
#define __WARNING_DANGEROUS_ALL_ACCESS_ACL 25084
#define __WARNING_25085 25085
#define __WARNING_URL_NEEDS_TO_BE_REVIEWED 25085
#define __WARNING_25086 25086
#define __WARNING_SD_REQUIRED_FOR_NAMED_OBJECT 25086
#define __WARNING_25087 25087
#define __WARNING_UNSPECIFIED_ACCESSRIGHTS 25087
#define __WARNING_25089 25089
#define __WARNING_DEPRECATED_WIN16_FUNCTION 25089
#define __WARNING_25090 25090
#define __WARNING_USE_CPLUSPLUS_BOOL_CONST 25090
#define __WARNING_25091 25091
#define __WARNING_RETURNTYPE_CAN_BE_BOOL 25091
#define __WARNING_25092 25092
#define __WARNING_LOCAL_CAN_BE_BOOL 25092
#define __WARNING_25093 25093
#define __WARNING_FORMAL_CAN_BE_BOOL 25093
#define __WARNING_25094 25094
#define __WARNING_BASECLASS_SHOULDHAVE_PROTECTED_OR_VIRTUAL_DTOR 25094
#define __WARNING_25096 25096
#define __WARNING_ENUM_TYPEDEF 25096
#define __WARNING_25098 25098
#define __WARNING_INTEGRAL_CAST_TO_OBJECT_WITH_VTABLE 25098
#define __WARNING_25099 25099
#define __WARNING_USE_PREFIX_OPERATOR 25099
#define __WARNING_25100 25100
#define __WARNING_LHS_TEMP_OBJECT 25100
#define __WARNING_25101 25101
#define __WARNING_RHS_TEMP_OBJECT 25101
#define __WARNING_25102 25102
#define __WARNING_EXC_NOT_CAUGHT_BY_REFERENCE 25102
#define __WARNING_25103 25103
#define __WARNING_EXC_NOT_THROWN_BY_VALUE 25103
#define __WARNING_25104 25104
#define __WARNING_INCONSISTENT_DECLSPECS 25104
#define __WARNING_25105 25105
#define __WARNING_SEALED_BASE_CLASS 25105
#define __WARNING_25106 25106
#define __WARNING_SEALED_BASE_METHOD 25106
#define __WARNING_25107 25107
#define __WARNING_NOTRUNCCAST_PARAM 25107
#define __WARNING_25108 25108
#define __WARNING_UNBOUND_RETURN 25108
#define __WARNING_25109 25109
#define __WARNING_MISSING_BINDRETURN 25109
#define __WARNING_25110 25110
#define __WARNING_CLARYFY_PRECEDENCE_FOR_QUESTIONOPERATOR 25110
#define __WARNING_25112 25112
#define __WARNING_DEPRECATED_FUNCTION 25112
#define __WARNING_25113 25113
#define __WARNING_DEPRECATED_LANGUAGE_TYPE_USED 25113
#define __WARNING_25114 25114
#define __WARNING_UNMARKED_INTL_DEPRECATED_FUNCTION 25114
#define __WARNING_25115 25115
#define __WARNING_DEPRECATED_INTL_FUNCTION_CALL 25115
#define __WARNING_25119 25119
#define __WARNING_OLEO_DEPRECATED_FUNCTION 25119
#define __WARNING_25120 25120
#define __WARNING_COUNT_REQUIRED_FOR_VOIDPTR_BUFFER 25120
#define __WARNING_25124 25124
#define __WARNING_RETURNING_TEMP_OBJECT 25124
#define __WARNING_25125 25125
#define __WARNING_STRCPY_LOOP 25125
#define __WARNING_25126 25126
#define __WARNING_POSSIBLE_STRCPY_LOOP 25126
#define __WARNING_25127 25127
#define __WARNING_BOOLEAN_BITWISE_OPERATOR_MIX 25127
#define __WARNING_25128 25128
#define __WARNING_DIFFERENT_COMPARE_ON_64BIT 25128
#define __WARNING_25129 25129
#define __WARNING_POSSIBLE_64BIT_TRUNCATION 25129
#define __WARNING_25130 25130
#define __WARNING_NONCONST_CLSID 25130
#define __WARNING_25131 25131
#define __WARNING_EMPTY_DTOR 25131
#define __WARNING_25132 25132
#define __WARNING_BY_VALUE_FORMAL_WITH_DTOR 25132
#define __WARNING_25133 25133
#define __WARNING_BY_VALUE_TEMPLATEFORMAL_WITH_DTOR 25133
#define __WARNING_25134 25134
#define __WARNING_IMPLICIT_TEMPLATECTOR 25134
#define __WARNING_25135 25135
#define __WARNING_LOCAL_ARRAY_SHOULD_BE_STATIC 25135
#define __WARNING_25136 25136
#define __WARNING_NONCONST_LOCAL_ARRAY 25136
#define __WARNING_25137 25137
#define __WARNING_LOCAL_ARRAY_SHOULD_BE_PTR 25137
#define __WARNING_25138 25138
#define __WARNING_STATIC_ARRAY_SHOULD_BE_LOCAL_PTR 25138
#define __WARNING_25139 25139
#define __WARNING_EMPTY_NONPUBLIC_DTOR 25139
#define __WARNING_25140 25140
#define __WARNING_DANGEROUS_INTTOPTR_CAST 25140
#define __WARNING_25141 25141
#define __WARNING_PRINTF_FORMAT_STRING_PARAM_NEEDS_REVIEW 25141
#define __WARNING_25142 25142
#define __WARNING_OBSOLETE_OACR_REVIEWED_CALL_MACRO 25142
#define __WARNING_25143 25143
#define __WARNING_WRITABLE_GLOBAL_FUNCTION_POINTER 25143

/* OACRExc */

#define __WARNING_25301 25301
#define __WARNING_DTOR_SHOULD_BE_NOTHROW 25301
#define __WARNING_25302 25302
#define __WARNING_OPERATOR_DELETE_SHOULD_BE_NOTHROW 25302
#define __WARNING_25303 25303
#define __WARNING_SWAP_FUNC_SHOULD_BE_NOTHROW 25303
#define __WARNING_25304 25304
#define __WARNING_CALLBACK_FUNC_SHOULD_BE_NOTHROW 25304
#define __WARNING_25305 25305
#define __WARNING_CLEANUP_FUNC_SHOULD_BE_NOTHROW 25305
#define __WARNING_25306 25306
#define __WARNING_NOTHROW_FUNC_THROWS 25306
#define __WARNING_25307 25307
#define __WARNING_FUNC_COULD_BE_NOTHROW 25307
#define __WARNING_25308 25308
#define __WARNING_UNNECESSARY_TRY_CATCH 25308
#define __WARNING_25309 25309
#define __WARNING_NOTHROW_BLOCK_THROWS 25309
#define __WARNING_25310 25310
#define __WARNING_COM_METHOD_THROWS 25310
#define __WARNING_25311 25311
#define __WARNING_GENERATED_FUNC_THROWS 25311

/* OACRMODEL */

#define __WARNING_25351 25351
#define __WARNING_HUNGARIAN_INFERRED 25351
#define __WARNING_25352 25352
#define __WARNING_MISSING_ANNOTATION 25352
#define __WARNING_25353 25353
#define __WARNING_OVERRIDE_AT_NON_VIRTUAL 25353
#define __WARNING_25354 25354
#define __WARNING_OVERRIDE_AT_STATIC 25354
#define __WARNING_25355 25355
#define __WARNING_OVERRIDE_AT_BASECLASS 25355
#define __WARNING_25356 25356
#define __WARNING_UNSUPPORTED_DEREF_VALUE 25356
#define __WARNING_25357 25357
#define __WARNING_PRE_ANNOTATION_AT_RETURNVALUE 25357
#define __WARNING_25358 25358
#define __WARNING_MISSING_NOTHROW_AT_DECL 25358
#define __WARNING_25359 25359
#define __WARNING_DEPRECATED_OVERRIDE 25359
#define __WARNING_25360 25360
#define __WARNING_OBSOLETE_OVERRIDE 25360
#define __WARNING_25361 25361
#define __WARNING_ILLEGAL_BOUND_AT_PARAM 25361
#define __WARNING_25362 25362
#define __WARNING_ILLEGAL_BOUND_AT_RETURN 25362
#define __WARNING_25363 25363
#define __WARNING_ILLEGAL_DEREF_BOUND_AT_PARAM 25363
#define __WARNING_25364 25364
#define __WARNING_ILLEGAL_DEREF_BOUND_AT_RETURN 25364
#define __WARNING_25365 25365
#define __WARNING_ILLEGAL_RANGE_AT_PARAM 25365
#define __WARNING_25366 25366
#define __WARNING_ILLEGAL_RANGE_AT_RETURN 25366
#define __WARNING_25367 25367
#define __WARNING_ILLEGAL_DEREF_RANGE_AT_PARAM 25367
#define __WARNING_25368 25368
#define __WARNING_ILLEGAL_DEREF_RANGE_AT_RETURN 25368
#define __WARNING_25369 25369
#define __WARNING_PARAM_UPPERBOUND_LT_LOWERBOUND 25369
#define __WARNING_25370 25370
#define __WARNING_RETURN_UPPERBOUND_LT_LOWERBOUND 25370
#define __WARNING_25371 25371
#define __WARNING_NO_ANNOTATIONS_AT_DECLARATION 25371
#define __WARNING_25372 25372
#define __WARNING_DECLSPEC_SAL_ANNOTATION 25372

/* espX */

#define __WARNING_26000 26000
#define __WARNING_BUFFER_OVERFLOW 26000
#define __WARNING_26001 26001
#define __WARNING_BUFFER_UNDERFLOW 26001
#define __WARNING_26002 26002
#define __WARNING_READ_UNTRACKED_BUFFER 26002
#define __WARNING_26003 26003
#define __WARNING_UNTRACKED_BUFFER 26003
#define __WARNING_26004 26004
#define __WARNING_UNINITIALIZED_POINTER 26004
#define __WARNING_26005 26005
#define __WARNING_ZEROLENGTHARRAY 26005
#define __WARNING_26006 26006
#define __WARNING_INCORRECT_ANNOTATION_STRING 26006
#define __WARNING_26007 26007
#define __WARNING_INCORRECT_ANNOTATION 26007
#define __WARNING_26009 26009
#define __WARNING_BUFFERACCESS 26009
#define __WARNING_26010 26010
#define __WARNING_POTENTIAL_BUFFER_OVERFLOW 26010
#define __WARNING_26011 26011
#define __WARNING_POTENTIAL_BUFFER_UNDERFLOW 26011
#define __WARNING_26012 26012
#define __WARNING_UNTRACKED_BUFFER_BUT_UNANNOTATABLE 26012
#define __WARNING_26013 26013
#define __WARNING_COMPLEX_EXPR 26013
#define __WARNING_26014 26014
#define __WARNING_INCORRECT_VALIDATION 26014
#define __WARNING_26015 26015
#define __WARNING_POTENTIAL_BUFFER_OVERFLOW_HIGH_PRIORITY 26015
#define __WARNING_26016 26016
#define __WARNING_BUFFER_OVERFLOW_NULL_TERMINATED 26016
#define __WARNING_26017 26017
#define __WARNING_POTENTIAL_BUFFER_OVERFLOW_MISC 26017
#define __WARNING_26018 26018
#define __WARNING_POTENTIAL_BUFFER_OVERFLOW_NULLTERMINATED 26018
#define __WARNING_26019 26019
#define __WARNING_INCORRECT_VALIDATION2 26019

/* SALCheck */

#define __WARNING_26020 26020
#define __WARNING_INSANE_ANNOTATION 26020
#define __WARNING_26021 26021
#define __WARNING_ANNOTATION_MISMATCH_MISSING_FIRST 26021
#define __WARNING_26022 26022
#define __WARNING_ANNOTATION_MISMATCH_MISSING_SECOND 26022
#define __WARNING_26023 26023
#define __WARNING_ANNOTATION_MISMATCH 26023

/* espX */

#define __WARNING_26030 26030
#define __WARNING_POSTCONDITION_BUFFER_OVERFLOW 26030
#define __WARNING_26031 26031
#define __WARNING_POSTCONDITION_BUFFER_UNDERFLOW 26031
#define __WARNING_26035 26035
#define __WARNING_PRECONDITION_NULLTERMINATION_VIOLATION 26035
#define __WARNING_26036 26036
#define __WARNING_POSTCONDITION_NULLTERMINATION_VIOLATION 26036
#define __WARNING_26037 26037
#define __WARNING_POTENTIAL_NULLTERMINATION_VIOLATION 26037
#define __WARNING_26040 26040
#define __WARNING_POTENTIAL_POSTCONDITION_BUFFER_OVERFLOW 26040
#define __WARNING_26041 26041
#define __WARNING_POTENTIAL_POSTCONDITION_BUFFER_UNDERFLOW 26041
#define __WARNING_26044 26044
#define __WARNING_INCORRECT_VALIDATION_POSTCONDITION 26044
#define __WARNING_26045 26045
#define __WARNING_HIGH_PRIORITY_OVERFLOW_POSTCONDITION 26045
#define __WARNING_26050 26050
#define __WARNING_CHECKER_ASSERTION_FAILURE 26050
#define __WARNING_26051 26051
#define __WARNING_IRREDUCIBLE_CFG 26051
#define __WARNING_26052 26052
#define __WARNING_POTENTIALLY_UNCONSTRAINED_CALL 26052
#define __WARNING_26053 26053
#define __WARNING_POTENTIAL_BUFFER_OVERFLOW_LOOP_DEPENDENT 26053
#define __WARNING_26060 26060
#define __WARNING_RANGE_PRECONDITION_VIOLATION 26060
#define __WARNING_26061 26061
#define __WARNING_RANGE_POSTCONDITION_VIOLATION 26061
#define __WARNING_26070 26070
#define __WARNING_POTENTIAL_RANGE_PRECONDITION_VIOLATION 26070
#define __WARNING_26071 26071
#define __WARNING_POTENTIAL_RANGE_POSTCONDITION_VIOLATION 26071
#define __WARNING_26080 26080
#define __WARNING_VALIDATED_ACCESS 26080
#define __WARNING_26081 26081
#define __WARNING_USING_STRUCT_ANNOTATION 26081
#define __WARNING_26090 26090
#define __WARNING_SUSPICIOUS_FUNCTION_POINTER_CAST 26090

/* NullPtr */

#define __WARNING_26500 26500
#define __WARNING_NULL_DEREFERENCE 26500
#define __WARNING_26501 26501
#define __WARNING_NULL_DEREFERENCE_THIS 26501
#define __WARNING_26505 26505
#define __WARNING_NULL_DEREFERENCE_API 26505
#define __WARNING_26506 26506
#define __WARNING_NULL_DEREFERENCE_THIS_API 26506
#define __WARNING_26510 26510
#define __WARNING_INTERFACE_PRE_NULL 26510
#define __WARNING_26511 26511
#define __WARNING_INTERFACE_PRE_NOTNULL 26511
#define __WARNING_26512 26512
#define __WARNING_INTERFACE_PRE_NOTNULL_VAL 26512
#define __WARNING_26515 26515
#define __WARNING_INTERFACE_POST_NULL 26515
#define __WARNING_26516 26516
#define __WARNING_INTERFACE_POST_NULL_CTOR 26516
#define __WARNING_26517 26517
#define __WARNING_INTERFACE_POST_NOTNULL 26517
#define __WARNING_26518 26518
#define __WARNING_INTERFACE_POST_NOTNULL_CTOR 26518
#define __WARNING_26520 26520
#define __WARNING_TRUNCATED_PTR 26520

/* In */

#define __WARNING_26550 26550
#define __WARNING_ASSIGNMENT_TO_IN_PARAMETER 26550

/* EspOpal */

#define __WARNING_26599 26599
#define __WARNING_GENERIC_OPAL_DEFECT 26599

/* SqlEye.Native.EscapingAndDelimiting */

#define __WARNING_26600 26600
#define __WARNING_SQLINJECTION_CXX_ESCAPING_COMMAND 26600
#define __WARNING_26601 26601
#define __WARNING_SQLINJECTION_CXX_DELIMITING_COMMAND 26601
#define __WARNING_26602 26602
#define __WARNING_SQLINJECTION_CXX_ESCAPING_AND_DELIMITING_COMMAND 26602
#define __WARNING_26604 26604
#define __WARNING_SQLINJECTION_CXX_ESCAPING_COMMAND_PRECONDITION 26604
#define __WARNING_26610 26610
#define __WARNING_SQLINJECTION_CXX_ESCAPING_CONNECTION_STRING 26610
#define __WARNING_26611 26611
#define __WARNING_SQLINJECTION_CXX_DELIMITING_CONNECTION_STRING 26611
#define __WARNING_26612 26612
#define __WARNING_SQLINJECTION_CXX_ESCAPING_AND_DELIMITING_CONNECTION_STRING 26612

/* SqlEye.Native.MissingCommandSal */

#define __WARNING_26620 26620
#define __WARNING_SQLINJECTION_CXX_MISSING_COMMAND_SAL 26620

/* SqlEye.Native.MissingConnectionStringSal */

#define __WARNING_26625 26625
#define __WARNING_SQLINJECTION_CXX_MISSING_CONNECTION_STRING_SAL 26625

/* SqlEye.Native.Truncation */

#define __WARNING_26630 26630
#define __WARNING_SQLINJECTION_CXX_TRUNCATION_COMMAND 26630
#define __WARNING_26635 26635
#define __WARNING_SQLINJECTION_CXX_TRUNCATION_CONNECTION_STRING 26635

/* SqlEye.Native.EscapingAndDelimiting */

#define __WARNING_26660 26660
#define __WARNING_SQLINJECTION_CXX_ESCAPING_COMMAND_LOWER_CONFIDENCE 26660
#define __WARNING_26661 26661
#define __WARNING_SQLINJECTION_CXX_DELIMITING_COMMAND_LOWER_CONFIDENCE 26661
#define __WARNING_26662 26662
#define __WARNING_SQLINJECTION_CXX_ESCAPING_AND_DELIMITING_COMMAND_LOWER_CONFIDENCE 26662
#define __WARNING_26670 26670
#define __WARNING_SQLINJECTION_CXX_ESCAPING_CONNECTION_STRING_LOWER_CONFIDENCE 26670
#define __WARNING_26671 26671
#define __WARNING_SQLINJECTION_CXX_DELIMITING_CONNECTION_STRING_LOWER_CONFIDENCE 26671
#define __WARNING_26672 26672
#define __WARNING_SQLINJECTION_CXX_ESCAPING_AND_DELIMITING_CONNECTION_STRING_LOWER_CONFIDENCE 26672

/* Goldpft */

#define __WARNING_38001 38001
#define __WARNING_LOCALE_SENSITIVE_STRCMP 38001
#define __WARNING_38002 38002
#define __WARNING_LOCALE_SENSITIVE_COMPARESTRING 38002
#define __WARNING_38003 38003
#define __WARNING_SYSTEM_LOCALE_MISUSE 38003
#define __WARNING_38004 38004
#define __WARNING_DEPRECATED_LIBRARY 38004
#define __WARNING_38010 38010
#define __WARNING_CALLING_SETTHREADLOCALE 38010
#define __WARNING_38011 38011
#define __WARNING_OVERRIDING_LOCALE_SETTINGS_WITH_SETLOCALEINFO 38011
#define __WARNING_38020 38020
#define __WARNING_ANSI_APICALL 38020
#define __WARNING_38021 38021
#define __WARNING_W2A_BEST_FIT 38021
#define __WARNING_38022 38022
#define __WARNING_CLIPBOARD_ANSI 38022
#define __WARNING_38023 38023
#define __WARNING_ANSI_DATAFILE 38023
#define __WARNING_38030 38030
#define __WARNING_HARD_CODED_STRING_TO_UI_FN 38030
#define __WARNING_38031 38031
#define __WARNING_HARDCODED_FONT_INFO 38031
#define __WARNING_38032 38032
#define __WARNING_CONSOLE_OUTPUT_ISSUE 38032
#define __WARNING_38033 38033
#define __WARNING_FORMAT_MESSAGE_LANG 38033
#define __WARNING_38034 38034
#define __WARNING_CONCATENATED_RESOURCE_STRING 38034
#define __WARNING_38035 38035
#define __WARNING_LOCALIZABLE_STRING_FORMAT_ISSUE 38035
#define __WARNING_38036 38036
#define __WARNING_MESSAGEBOX_RTL 38036
#define __WARNING_38037 38037
#define __WARNING_BITMAP_OR_ANSI_FONT 38037
#define __WARNING_38038 38038
#define __WARNING_COMMANDLINK_SETNOTE 38038
#define __WARNING_38039 38039
#define __WARNING_SCREEN_COORDINATES_CONVERSION 38039
#define __WARNING_38041 38041
#define __WARNING_GETDATEFORMAT_WRAPPER 38041
#define __WARNING_38042 38042
#define __WARNING_GETDATEFORMAT_AUTOLAYOUT 38042
#define __WARNING_38043 38043
#define __WARNING_LAYOUT_BITMAPORIENTATIONPRESERVED 38043
#define __WARNING_38044 38044
#define __WARNING_LOC_METADATA_GENERATED_GOLDPFT 38044
#define __WARNING_38045 38045
#define __WARNING_NON_LOCFRIENDLY_STRING_FORMATTING 38045

/* SqlEye.TSql.EscapingAndDelimiting */

#define __WARNING_80100 80100
#define __WARNING_SQLINJECTION_TSQL_ESCAPING_COMMAND 80100
#define __WARNING_80101 80101
#define __WARNING_SQLINJECTION_TSQL_DELIMITING_COMMAND 80101
#define __WARNING_80102 80102
#define __WARNING_SQLINJECTION_TSQL_ESCAPING_AND_DELIMITING_COMMAND 80102
#define __WARNING_80103 80103
#define __WARNING_SQLINJECTION_TSQL_ESCAPING_COMMAND_SECOND_ORDER 80103
#define __WARNING_80104 80104
#define __WARNING_SQLINJECTION_TSQL_ESCAPING_COMMAND_PRECONDITION 80104
#define __WARNING_80105 80105
#define __WARNING_SQLINJECTION_TSQL_ESCAPING_COMMAND_SECOND_ORDER_PRECONDITION 80105

/* SqlEye.TSQL */

#define __WARNING_80130 80130
#define __WARNING_SQLINJECTION_TSQL_TRUNCATION_COMMAND 80130
#define __WARNING_80131 80131
#define __WARNING_SQLINJECTION_TSQL_STR_TRUNCATED_ON_COMMAND_EXECUTION 80131
#define __WARNING_80140 80140
#define __WARNING_SQLINJECTION_TSQL_TRUNCATED_STR_PASSED_TO_SP 80140
#define __WARNING_80141 80141
#define __WARNING_SQLINJECTION_TSQL_STR_TRUNCATED_ON_CALL_TO_SP 80141
#define __WARNING_80142 80142
#define __WARNING_SQLINJECTION_TSQL_TRUNCATED_STR_ASSIGNED_TO_OUTPUT 80142
#define __WARNING_80143 80143
#define __WARNING_SQLINJECTION_TSQL_STR_TRUNCATED_ON_OUTPUT_ASSIGNMENT 80143

/* SqlEye.Managed.EscapingAndDelimiting */

#define __WARNING_80200 80200
#define __WARNING_SQLINJECTION_MSIL_ESCAPING_COMMAND 80200
#define __WARNING_80201 80201
#define __WARNING_SQLINJECTION_MSIL_DELIMITING_COMMAND 80201
#define __WARNING_80202 80202
#define __WARNING_SQLINJECTION_MSIL_ESCAPING_AND_DELIMITING_COMMAND 80202

#endif // _PREfast_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\OACR\3.0.40203.0\x86\etc\esp\SqlEye.Native.Annotations.h ===
#if !defined(__midl) && defined(_PREFAST_)

// Data Sink (a parameter scontaining a sql command or connection string to be executed by the API)
//
#define __sql_command  __declspec("SAL_SqlCommand")

#define __sql_connection_string __declspec("SAL_SqlConnectionString")

#define __sql_command_fragment  __declspec("SAL_SqlCommand")

#define __sql_connection_string_fragment __declspec("SAL_SqlConnectionString")

// Data Source (parameter or return value that may contain untrusted data upon return of the API)
//
// Example 1: __sql_untrusted CHAR* GetRegistryValue(CHAR* key)
// Example 2: void GetRegistryValue(CHAR* key, __sqluntrusted __out_ecount_z(cchValue) CHAR* value, size_t cchValue)
//
#define __sql_untrusted  __declspec("SAL_SqlUnTrusted")

// Escaped annotations

// Escaped '
//
#define __sql_escaped_single_quote __declspec("SAL_SqlEscaped")

// Escaped "
//
#define __sql_escaped_double_quote __declspec("SAL_SqlEscaped")

// Escaped ]
//
#define __sql_escaped_right_bracket __declspec("SAL_SqlEscaped")

// Currently escaped-and-delimited annotations expand to the same as __sql_command,
// since the requirement we currently check is that all inputs to such variable
// be escaped and delimited.
//

// Escaped and delimited '
//
#define __sql_escaped_and_delimited_single_quote __declspec("SAL_SqlCommand")

// Escaped and delimited "
//
#define __sql_escaped_and_delimited_double_quote __declspec("SAL_SqlCommand")

// Escaped and delimited ]
//
#define __sql_escaped_and_delimited_right_bracket __declspec("SAL_SqlCommand")

// Trusted: A parameter for which we know safe values are passed at all call sites. 
// One should always avoid using this one, as this annotation results in no checking at the call site.
// Instead use __sql_command, __sql_escaped_* or __sql_escaped_and_delimited_* annotations,
// This is only provided in case of an unmanageable amount of noise occuring due to a large number
// of known-safe callsites.
//
#define __sql_trusted  __declspec("SAL_SqlTrusted")

#else

#define __sql_command 
#define __sql_connection_string  
#define __sql_command_fragment
#define __sql_connection_string_fragment  

#define __sql_untrusted

#define __sql_escaped_single_quote
#define __sql_escaped_double_quote
#define __sql_escaped_right_bracket

#define __sql_escaped_and_delimited_single_quote
#define __sql_escaped_and_delimited_double_quote
#define __sql_escaped_and_delimited_right_bracket

#define __sql_trusted

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\OACR\3.0.40203.0\x86\inc\oacrdll.h ===
#pragma once
/*****************************************************************************

   Module  : OACRDll
   Owner   : MarcK

   Copyright (c) Microsoft Corporation. All rights reserved.

******************************************************************************

  APIs exported by oacr.dll.
  
  oacr.dll is part of the Microsoft Auto Code Review (OACR) system. 
  It provides the same functionality as oacr.exe. It is intended for build
  integration from build environments using their own executable.

*****************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif

// Typedefs for dynamic loading via LoadLibrary and GetProcAddress
typedef int (__stdcall* OACRCMDWPROC)( const wchar_t* );
typedef int (__stdcall* OACRCMDAPROC)( const char* );


// Run an OACR command. Same command line syntax as the oacr.exe command line tool.
int __stdcall OACRCmdW( const wchar_t* wzCmd );
int __stdcall OACRCmdA( const char* szCmd );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\OACR\3.0.40203.0\x86\inc\pftwarnings.h ===
#pragma once
/*****************************************************************************

DO NOT EDIT - Generated file

PREfast Warning Ids

PREfast(x86)      : 9.0.21022.30
Defect modules
   mspft          : 9.0.21022.30
   cntincs        : 9.0.21022.31202
   EspCxxDrv      : 9.0.21022.30908
   espx           : 9.0.21022.30208
   GoldPft        : 9.0.21022.40216
   IntegerOverflow: 9.0.21022.21217
   oacrcplus      : 9.0.21022.40217
   oacrexc        : 9.0.21022.40217
   oacrmodel      : 9.0.21022.40213
   SALCheck       : 9.0.21022.30208

PREfast(amd64)    : 9.0.21022.30
Defect modules
   mspft          : 9.0.21022.30
   cntincs        : 9.0.21022.31202
   EspCxxDrv      : 9.0.21022.30908
   espx           : 9.0.21022.30208
   GoldPft        : 9.0.21022.40216
   IntegerOverflow: 9.0.21022.21217
   oacrcplus      : 9.0.21022.40217
   oacrexc        : 9.0.21022.40217
   oacrmodel      : 9.0.21022.40213
   SALCheck       : 9.0.21022.30208

Esp               : 1.2.30415.30908
Defect modules
   CfgPersist     : 1.2.30415.30908
   EspBldChk      : 1.2.30415.30908
   EspOpal        : 1.2.30415.30908
   GoldMan        : 1.1.30415.40216
   GoldManRes     : 1.1.30415.40216
   NullPtr        : 1.2.30415.30908
   SqlEye.TSQL    : 1.2.30415.30516
   In             : <no version>
   SqlEye.Managed.EscapingAndDelimiting: <no version>
   SqlEye.Native.EscapingAndDelimiting: <no version>
   SqlEye.Native.MissingCommandSal: <no version>
   SqlEye.Native.MissingConnectionStringSal: <no version>
   SqlEye.Native.Truncation: <no version>
   SqlEye.TSql.EscapingAndDelimiting: <no version>

Generated on 02/20/09 at 13:42:59

*****************************************************************************/


#ifdef _PREFAST_

/* MSPFT */

#define __WARNING_6001 6001
#define __WARNING_USING_UNINIT_VAR 6001
#define __WARNING_6011 6011
#define __WARNING_DEREF_NULL_PTR 6011
#define __WARNING_6029 6029
#define __WARNING_USING_TAINTED_DATA 6029
#define __WARNING_6031 6031
#define __WARNING_RETVAL_IGNORED_FUNC_COULD_FAIL 6031
#define __WARNING_6053 6053
#define __WARNING_MISSING_ZERO_TERMINATION1 6053
#define __WARNING_6054 6054
#define __WARNING_MISSING_ZERO_TERMINATION2 6054
#define __WARNING_6057 6057
#define __WARNING_CHAR_BYTE_SIZE_MISMATCH 6057
#define __WARNING_6059 6059
#define __WARNING_BAD_CONCATENATION 6059
#define __WARNING_6063 6063
#define __WARNING_MISSING_STRING_ARGUMENT_TO_FORMAT_FUNCTION 6063
#define __WARNING_6064 6064
#define __WARNING_MISSING_INTEGER_ARGUMENT_TO_FORMAT_FUNCTION 6064
#define __WARNING_6066 6066
#define __WARNING_NON_POINTER_ARGUMENT_TO_FORMAT_FUNCTION 6066
#define __WARNING_6067 6067
#define __WARNING_NON_STRING_ARGUMENT_TO_FORMAT_FUNCTION 6067
#define __WARNING_6200 6200
#define __WARNING_INDEX_EXCEEDS_MAX_NONSTACK 6200
#define __WARNING_6201 6201
#define __WARNING_INDEX_EXCEEDS_MAX 6201
#define __WARNING_6202 6202
#define __WARNING_BUFFER_OVERRUN 6202
#define __WARNING_6203 6203
#define __WARNING_BUFFER_OVERRUN_NONSTACK 6203
#define __WARNING_6204 6204
#define __WARNING_UNVALIDATED_PARAM 6204
#define __WARNING_6209 6209
#define __WARNING_SIZEOF_CHAR_BYTE_SIZE_MISMATCH 6209
#define __WARNING_6211 6211
#define __WARNING_MEMORY_LEAK_EXCEPTION 6211
#define __WARNING_6214 6214
#define __WARNING_CAST_HRESULT_TO_BOOL 6214
#define __WARNING_6215 6215
#define __WARNING_CAST_BOOL_TO_HRESULT 6215
#define __WARNING_6216 6216
#define __WARNING_COMPILER_INSERTED_CAST_BOOL_TO_HRESULT 6216
#define __WARNING_6217 6217
#define __WARNING_TESTING_HRESULT_WITH_NOT 6217
#define __WARNING_6219 6219
#define __WARNING_COMPARING_HRESULT_TO_ONE 6219
#define __WARNING_6220 6220
#define __WARNING_COMPARING_HRESULT_TO_MINUS_ONE 6220
#define __WARNING_6221 6221
#define __WARNING_COMPARING_HRESULT_TO_INT 6221
#define __WARNING_6225 6225
#define __WARNING_ASSIGNING_ONE_TO_HRESULT 6225
#define __WARNING_6226 6226
#define __WARNING_ASSIGNING_MINUS_ONE_TO_HRESULT 6226
#define __WARNING_6230 6230
#define __WARNING_USING_HRESULT_IN_BOOLEAN_CONTEXT 6230
#define __WARNING_6235 6235
#define __WARNING_NONZEROLOGICALOR 6235
#define __WARNING_6236 6236
#define __WARNING_LOGICALORNONZERO 6236
#define __WARNING_6237 6237
#define __WARNING_ZEROLOGICALANDLOSINGSIDEEFFECTS 6237
#define __WARNING_6239 6239
#define __WARNING_NONZEROLOGICALAND 6239
#define __WARNING_6240 6240
#define __WARNING_LOGICALANDNONZERO 6240
#define __WARNING_6242 6242
#define __WARNING_LOCALUNWINDFORCED 6242
#define __WARNING_6244 6244
#define __WARNING_LOCALDECLHIDESGLOBAL 6244
#define __WARNING_6246 6246
#define __WARNING_LOCALDECLHIDESLOCAL 6246
#define __WARNING_6248 6248
#define __WARNING_CREATINGNULLDACL 6248
#define __WARNING_6250 6250
#define __WARNING_WIN32UNRELEASEDVADS 6250
#define __WARNING_6255 6255
#define __WARNING_UNPROTECTEDUSEOFALLOCA 6255
#define __WARNING_6258 6258
#define __WARNING_USINGTERMINATETHREAD 6258
#define __WARNING_6259 6259
#define __WARNING_DEADCODEINBITORLIMITEDSWITCH 6259
#define __WARNING_6260 6260
#define __WARNING_USEOFBYTEAREA 6260
#define __WARNING_6262 6262
#define __WARNING_EXCESSIVESTACKUSAGE 6262
#define __WARNING_6263 6263
#define __WARNING_USINGALLOCAINLOOP 6263
#define __WARNING_6268 6268
#define __WARNING_MISPARENTHESIZED_CASTS 6268
#define __WARNING_6269 6269
#define __WARNING_POINTER_DEREF_DISCARDED 6269
#define __WARNING_6270 6270
#define __WARNING_MISSING_FLOAT_ARGUMENT_TO_FORMAT_FUNCTION 6270
#define __WARNING_6271 6271
#define __WARNING_EXTRA_ARGUMENT_TO_FORMAT_FUNCTION 6271
#define __WARNING_6272 6272
#define __WARNING_NON_FLOAT_ARGUMENT_TO_FORMAT_FUNCTION 6272
#define __WARNING_6273 6273
#define __WARNING_NON_INTEGER_ARGUMENT_TO_FORMAT_FUNCTION 6273
#define __WARNING_6274 6274
#define __WARNING_NON_CHAR_ARGUMENT_TO_FORMAT_FUNCTION 6274
#define __WARNING_6276 6276
#define __WARNING_CHAR_TO_WCHAR_CAST 6276
#define __WARNING_6277 6277
#define __WARNING_CREATEPROCESS_ESCAPE 6277
#define __WARNING_6278 6278
#define __WARNING_ARRAY_NEW_DELETE_MISMATCH 6278
#define __WARNING_6279 6279
#define __WARNING_NEW_ARRAY_DELETE_MISMATCH 6279
#define __WARNING_6280 6280
#define __WARNING_MEMORY_ALLOCATION_MISMATCH 6280
#define __WARNING_6281 6281
#define __WARNING_BITWISERELATIONPRECEDENCEERROR 6281
#define __WARNING_6282 6282
#define __WARNING_ASSIGNMENTREPLACESTEST 6282
#define __WARNING_6283 6283
#define __WARNING_PRIMITIVE_ARRAY_NEW_DELETE_MISMATCH 6283
#define __WARNING_6284 6284
#define __WARNING_OBJECT_AS_STRING_ARGUMENT_TO_FORMAT_FUNCTION 6284
#define __WARNING_6285 6285
#define __WARNING_LOGICALOROFCONSTANTS 6285
#define __WARNING_6286 6286
#define __WARNING_NONZEROLOGICALORLOSINGSIDEEFFECTS 6286
#define __WARNING_6287 6287
#define __WARNING_REDUNDANTTEST 6287
#define __WARNING_6288 6288
#define __WARNING_MUTUALINCLUSIONOVERANDISFALSE 6288
#define __WARNING_6289 6289
#define __WARNING_MUTUALEXCLUSIONOVERORISTRUE 6289
#define __WARNING_6290 6290
#define __WARNING_LOGICALNOTBITWISEAND 6290
#define __WARNING_6291 6291
#define __WARNING_LOGICALNOTBITWISEOR 6291
#define __WARNING_6292 6292
#define __WARNING_LOOP_COUNTS_UP_FROM_MAX 6292
#define __WARNING_6293 6293
#define __WARNING_LOOP_INDEX_GOES_NEGATIVE 6293
#define __WARNING_6294 6294
#define __WARNING_LOOP_BODY_NEVER_EXECUTED 6294
#define __WARNING_6295 6295
#define __WARNING_INFINITE_LOOP 6295
#define __WARNING_6296 6296
#define __WARNING_LOOP_ONLY_EXECUTED_ONCE 6296
#define __WARNING_6297 6297
#define __WARNING_RESULTOFSHIFTCASTTOLARGERSIZE 6297
#define __WARNING_6298 6298
#define __WARNING_CONST_STRING_TO_WRITABLE_STRING 6298
#define __WARNING_6299 6299
#define __WARNING_BITFIELD_TO_BOOL_COMPARISON 6299
#define __WARNING_6302 6302
#define __WARNING_CHAR_WCHAR_ARGUMENT_TO_FORMAT_FUNCTION 6302
#define __WARNING_6303 6303
#define __WARNING_WCHAR_CHAR_ARGUMENT_TO_FORMAT_FUNCTION 6303
#define __WARNING_6305 6305
#define __WARNING_SIZEOF_COUNTOF_MISMATCH 6305
#define __WARNING_6306 6306
#define __WARNING_INCORRECT_VARARG_FUNCTIONCALL 6306
#define __WARNING_6308 6308
#define __WARNING_REALLOCLEAK 6308
#define __WARNING_6309 6309
#define __WARNING_PASSING_FUNCTION_UNEXPECTED_NULL 6309
#define __WARNING_6310 6310
#define __WARNING_ILLEGALEXCEPTEXPRCONST 6310
#define __WARNING_6312 6312
#define __WARNING_EXCEPTIONCONTINUEEXECUTION 6312
#define __WARNING_6313 6313
#define __WARNING_BITANDVSZEROVALUEDFLAG 6313
#define __WARNING_6314 6314
#define __WARNING_BITORVSQUESTION 6314
#define __WARNING_6315 6315
#define __WARNING_BITORVSBITAND 6315
#define __WARNING_6316 6316
#define __WARNING_INAPPROPRIATEUSEOFBITOR 6316
#define __WARNING_6317 6317
#define __WARNING_NOTNOTCOMPLEMENT 6317
#define __WARNING_6318 6318
#define __WARNING_EXCEPTIONCONTINUESEARCH 6318
#define __WARNING_6319 6319
#define __WARNING_IGNOREDBYCOMMA 6319
#define __WARNING_6320 6320
#define __WARNING_EXCEPTIONEXECUTEHANDLER 6320
#define __WARNING_6322 6322
#define __WARNING_EXCEPT_BLOCK_EMPTY 6322
#define __WARNING_6323 6323
#define __WARNING_ARITH_OP_ON_BOOL 6323
#define __WARNING_6324 6324
#define __WARNING_STRCPY_INSTEAD_OF_STRCMP 6324
#define __WARNING_6326 6326
#define __WARNING_CONST_CONST_COMP 6326
#define __WARNING_6327 6327
#define __WARNING_DEST_BUFFER_INSUFFICIENT 6327
#define __WARNING_6328 6328
#define __WARNING_POTENTIAL_ARGUMENT_TYPE_MISMATCH 6328
#define __WARNING_6329 6329
#define __WARNING_POTENTIAL_INCORRECT_RETVAL_CHECK 6329
#define __WARNING_6331 6331
#define __WARNING_VIRTUALFREEINVALIDPARAM1 6331
#define __WARNING_6332 6332
#define __WARNING_VIRTUALFREEINVALIDPARAM2 6332
#define __WARNING_6333 6333
#define __WARNING_VIRTUALFREEINVALIDPARAM3 6333
#define __WARNING_6334 6334
#define __WARNING_SIZEOFEXPR 6334
#define __WARNING_6335 6335
#define __WARNING_LEAKING_PROCESS_HANDLE 6335
#define __WARNING_6336 6336
#define __WARNING_QUESTIONPRECEDENCE 6336
#define __WARNING_6381 6381
#define __WARNING_SHUTDOWN_API 6381
#define __WARNING_6383 6383
#define __WARNING_ELEMENTS_TO_BYTES 6383
#define __WARNING_6384 6384
#define __WARNING_DIVIDING_SIZEOF_POINTER 6384
#define __WARNING_6385 6385
#define __WARNING_READ_OVERRUN 6385
#define __WARNING_6386 6386
#define __WARNING_WRITE_OVERRUN 6386
#define __WARNING_6387 6387
#define __WARNING_INVALID_PARAM_VALUE_1 6387
#define __WARNING_6388 6388
#define __WARNING_INVALID_PARAM_VALUE_2 6388
#define __WARNING_6400 6400
#define __WARNING_LOCALE_DEPENDENT_CONSTANT_STRING_COMPARISON 6400
#define __WARNING_6401 6401
#define __WARNING_DEFAULT_LOCALE_CONSTANT_STRING_COMPARISON 6401
#define __WARNING_6500 6500
#define __WARNING_INVALID_ATTRIBUTE_PROPERTY 6500
#define __WARNING_6501 6501
#define __WARNING_CONFLICTING_ATTRIBUTE_PROPERTY_VALUES 6501
#define __WARNING_6503 6503
#define __WARNING_REFERENCES_CANT_BE_NULL 6503
#define __WARNING_6504 6504
#define __WARNING_NULL_ON_NON_POINTER 6504
#define __WARNING_6505 6505
#define __WARNING_MUSTCHECK_ON_VOID 6505
#define __WARNING_6506 6506
#define __WARNING_BUFFER_SIZE_ON_NON_POINTER_OR_ARRAY 6506
#define __WARNING_6507 6507
#define __WARNING_NULL_MISMATCH_AT_DEREF_0 6507
#define __WARNING_6508 6508
#define __WARNING_WRITE_ACCESS_ON_CONST 6508
#define __WARNING_6509 6509
#define __WARNING_RETURN_USED_ON_PRECONDITION 6509
#define __WARNING_6510 6510
#define __WARNING_NULLTERMINATED_ON_NON_POINTER 6510
#define __WARNING_6511 6511
#define __WARNING_MUSTCHECK_MAYBE 6511
#define __WARNING_6512 6512
#define __WARNING_NULL_CONFLICTS_WITH_NOT_VALID 6512
#define __WARNING_6513 6513
#define __WARNING_ELEMENT_SIZE_WITHOUT_BUFFER_SIZE 6513
#define __WARNING_6514 6514
#define __WARNING_BUFFER_SIZE_EXCEEDS_ARRAY_SIZE 6514
#define __WARNING_6515 6515
#define __WARNING_BUFFER_SIZE_ON_NON_POINTER 6515
#define __WARNING_6516 6516
#define __WARNING_NO_PROPERTIES_ON_ATTRIBUTE 6516
#define __WARNING_6517 6517
#define __WARNING_VALID_SIZE_ON_NON_READABLE_BUFFER 6517
#define __WARNING_6518 6518
#define __WARNING_WRITABLE_SIZE_ON_NON_WRITABLE_BUFFER 6518
#define __WARNING_6521 6521
#define __WARNING_INVALID_SIZE_STRING_DEREF 6521
#define __WARNING_6522 6522
#define __WARNING_INVALID_SIZE_STRING_TYPE 6522
#define __WARNING_6523 6523
#define __WARNING_INVALID_SIZE_STRING_PARAM 6523
#define __WARNING_6525 6525
#define __WARNING_INVALID_SIZE_STRING_UNREACHABLE_LOCATION 6525
#define __WARNING_6526 6526
#define __WARNING_INVALID_SIZE_STRING_BUFFER_TYPE 6526
#define __WARNING_6530 6530
#define __WARNING_UNRECOGNIZED_FORMAT_STRING_STYLE 6530
#define __WARNING_6535 6535
#define __WARNING_BUFFERSIZE_INFEASIBLE 6535
#define __WARNING_6540 6540
#define __WARNING_OVERRIDING_OLD_MODEL 6540
#define __WARNING_6990 6990
#define __WARNING_MANAGEDCODENOTSUPPORTED 6990
#define __WARNING_6991 6991
#define __WARNING_ATTRIBUTESNOTSUPPORTED 6991
#define __WARNING_6992 6992
#define __WARNING_NATIVEEVENTSYNTAXNOTSUPPORTED 6992
#define __WARNING_6993 6993
#define __WARNING_OMPNOTSUPPORTED 6993
#define __WARNING_6994 6994
#define __WARNING_PCHNOTFOUND 6994
#define __WARNING_6995 6995
#define __WARNING_SAVETOXMLFAILED 6995

/* GoldMan */

#define __WARNING_17900 17900
#define __WARNING_HARDCODED_STR_IN_USER_FACING_API 17900
#define __WARNING_17901 17901
#define __WARNING_HARDCODED_STR_FOR_LOCALIZED_ATTRIBUTE 17901
#define __WARNING_17902 17902
#define __WARNING_HARDCODED_STR_IN_TURKISH_I 17902
#define __WARNING_17903 17903
#define __WARNING_CULTURE_INFO_FROM_LCID 17903
#define __WARNING_17904 17904
#define __WARNING_CULTURE_INFO_MISUSE 17904
#define __WARNING_17905 17905
#define __WARNING_HARDCODED_FONT_FAMILY_AND_SIZE 17905
#define __WARNING_17906 17906
#define __WARNING_RESOURCE_STRING_CONCAT 17906
#define __WARNING_17907 17907
#define __WARNING_CONCAT_STR_IN_USER_FACING_API 17907
#define __WARNING_17908 17908
#define __WARNING_CONCAT_STR_FOR_LOCALIZED_ATTRIBUTE 17908
#define __WARNING_17909 17909
#define __WARNING_LOC_METADATA_GENERATED_GOLDMAN 17909

/* IntegerOverflow */

#define __WARNING_22010 22010
#define __WARNING_DUMMY_IO_WARNING1 22010
#define __WARNING_22011 22011
#define __WARNING_ALLOC_SIZE_OVERFLOW 22011
#define __WARNING_22012 22012
#define __WARNING_ALLOC_SIZE_WRONG_OVERFLOW_CHECK 22012
#define __WARNING_22013 22013
#define __WARNING_INDEX_WRONG_OVERFLOW_CHECK 22013
#define __WARNING_22014 22014
#define __WARNING_ALLOC_SIZE_NEGATIVE 22014
#define __WARNING_22015 22015
#define __WARNING_INDEX_NEGATIVE 22015
#define __WARNING_22016 22016
#define __WARNING_LOOP_INDEX_WRONG_OVERFLOW_CHECK 22016
#define __WARNING_22017 22017
#define __WARNING_ALLOC_SIZE_UNDERFLOW 22017
#define __WARNING_22018 22018
#define __WARNING_INDEX_UNDERFLOW 22018
#define __WARNING_22019 22019
#define __WARNING_LOOP_INDEX_UNDERFLOW 22019
#define __WARNING_22020 22020
#define __WARNING_SIGNED_UNSIGNED_COMPARISON 22020
#define __WARNING_22021 22021
#define __WARNING_DIFF_SIZE_SIGNED_UNSIGNED_COMPARISON 22021
#define __WARNING_22022 22022
#define __WARNING_ALLOC_SIZE_OVERFLOW_WITH_ACCESS 22022
#define __WARNING_22023 22023
#define __WARNING_ALLOC_SIZE_OVERFLOW_IN_ALLOC_WRAPPER 22023
#define __WARNING_22024 22024
#define __WARNING_ALLOC_SIZE_UNDERFLOW_IN_ALLOC_WRAPPER 22024
#define __WARNING_22025 22025
#define __WARNING_RETVAL_IS_USED_IN_ALLOC_SIZE_COMPUTATION 22025
#define __WARNING_22026 22026
#define __WARNING_REFARG_IS_USED_IN_ALLOC_SIZE_COMPUTATION 22026
#define __WARNING_22027 22027
#define __WARNING_OVERFLOW_OR_UNDERFLOW_IN_ALLOCATOR_SIZE_FUNC_RETVAL 22027
#define __WARNING_22028 22028
#define __WARNING_OVERFLOW_OR_UNDERFLOW_IN_ALLOCATOR_SIZE_FUNC_REFARG 22028
#define __WARNING_22029 22029
#define __WARNING_OVERFLOW_OR_UNDERFLOW_IN_ALLOC_SIZE 22029
#define __WARNING_22030 22030
#define __WARNING_OVERFLOW_OR_UNDERFLOW_IN_ALLOC_WRAPPER 22030
#define __WARNING_22051 22051
#define __WARNING_UNTRUSTED_ALLOC_SIZE_OVERFLOW 22051
#define __WARNING_22052 22052
#define __WARNING_UNTRUSTED_ALLOC_SIZE_WRONG_OVERFLOW_CHECK 22052
#define __WARNING_22053 22053
#define __WARNING_UNTRUSTED_INDEX_WRONG_OVERFLOW_CHECK 22053
#define __WARNING_22054 22054
#define __WARNING_UNTRUSTED_ALLOC_SIZE_NEGATIVE 22054
#define __WARNING_22055 22055
#define __WARNING_UNTRUSTED_INDEX_NEGATIVE 22055
#define __WARNING_22056 22056
#define __WARNING_UNTRUSTED_LOOP_INDEX_WRONG_OVERFLOW_CHECK 22056
#define __WARNING_22057 22057
#define __WARNING_UNTRUSTED_ALLOC_SIZE_UNDERFLOW 22057
#define __WARNING_22058 22058
#define __WARNING_UNTRUSTED_INDEX_UNDERFLOW 22058
#define __WARNING_22059 22059
#define __WARNING_UNTRUSTED_LOOP_INDEX_UNDERFLOW 22059
#define __WARNING_22060 22060
#define __WARNING_UNTRUSTED_SIGNED_UNSIGNED_COMPARISON 22060
#define __WARNING_22061 22061
#define __WARNING_UNTRUSTED_DIFF_SIZE_SIGNED_UNSIGNED_COMPARISON 22061
#define __WARNING_22062 22062
#define __WARNING_UNTRUSTED_ALLOC_SIZE_OVERFLOW_WITH_ACCESS 22062
#define __WARNING_22063 22063
#define __WARNING_UNTRUSTED_ALLOC_SIZE_OVERFLOW_IN_ALLOC_WRAPPER 22063
#define __WARNING_22064 22064
#define __WARNING_UNTRUSTED_ALLOC_SIZE_UNDERFLOW_IN_ALLOC_WRAPPER 22064
#define __WARNING_22067 22067
#define __WARNING_UNTRUSTED_OVERFLOW_OR_UNDERFLOW_IN_ALLOCATOR_SIZE_FUNC_RETVAL 22067
#define __WARNING_22068 22068
#define __WARNING_UNTRUSTED_OVERFLOW_OR_UNDERFLOW_IN_ALLOCATOR_SIZE_FUNC_REFARG 22068
#define __WARNING_22069 22069
#define __WARNING_UNTRUSTED_OVERFLOW_OR_UNDERFLOW_IN_ALLOC_SIZE 22069
#define __WARNING_22070 22070
#define __WARNING_UNTRUSTED_OVERFLOW_OR_UNDERFLOW_IN_ALLOC_WRAPPER 22070
#define __WARNING_22081 22081
#define __WARNING_UNTRUSTED_ALLOC_SIZE 22081
#define __WARNING_22082 22082
#define __WARNING_UNTRUSTED_INDEX 22082
#define __WARNING_22083 22083
#define __WARNING_UNTRUSTED_LOOP_INDEX 22083
#define __WARNING_22084 22084
#define __WARNING_UNTRUSTED_OVERFLOWN_EXPR 22084
#define __WARNING_22085 22085
#define __WARNING_UNTRUSTED_UNDERFLOWN_EXPR 22085

/* OACRCPLUS */

#define __WARNING_25000 25000
#define __WARNING_BIG_FORMAL_PARAM 25000
#define __WARNING_25001 25001
#define __WARNING_IMPLICIT_CTOR 25001
#define __WARNING_25002 25002
#define __WARNING_UPCAST_CTOR 25002
#define __WARNING_25003 25003
#define __WARNING_NONCONST_LOCAL 25003
#define __WARNING_25004 25004
#define __WARNING_NONCONST_PARAM 25004
#define __WARNING_25005 25005
#define __WARNING_NONCONST_FUNCTION 25005
#define __WARNING_25006 25006
#define __WARNING_UNUSED_PARAM 25006
#define __WARNING_25007 25007
#define __WARNING_STATIC_FUNCTION 25007
#define __WARNING_25008 25008
#define __WARNING_FREE_CONSTRUCTOR_CALL 25008
#define __WARNING_25009 25009
#define __WARNING_IDENTITY_ASSIGNMENT 25009
#define __WARNING_25010 25010
#define __WARNING_VIRTUAL_CALL_IN_CTOR 25010
#define __WARNING_25011 25011
#define __WARNING_CASE_FALLTHRU 25011
#define __WARNING_25012 25012
#define __WARNING_SMARTPOINTER_DELETE 25012
#define __WARNING_25013 25013
#define __WARNING_RETURN_FROM_GOTO_CONTEXT 25013
#define __WARNING_25014 25014
#define __WARNING_MISSING_OVERRIDE 25014
#define __WARNING_25015 25015
#define __WARNING_DOESNT_OVERRIDE 25015
#define __WARNING_25016 25016
#define __WARNING_OVERRIDE_CONST_MISMATCH 25016
#define __WARNING_25017 25017
#define __WARNING_OVERRIDING_NONVIRTUAL 25017
#define __WARNING_25018 25018
#define __WARNING_DIFFERENT_CALLING_CONVENTION 25018
#define __WARNING_25019 25019
#define __WARNING_VERYBIG_FORMAL_PARAM 25019
#define __WARNING_25020 25020
#define __WARNING_SAMENAME_DATAMEMBER 25020
#define __WARNING_25021 25021
#define __WARNING_POOR_DATAALIGNMENT 25021
#define __WARNING_25022 25022
#define __WARNING_REMOVERETURNCONST_FUNCTIONCAST 25022
#define __WARNING_25023 25023
#define __WARNING_BOGUS_BSTRCONST 25023
#define __WARNING_25024 25024
#define __WARNING_DANGEROUS_POINTERCAST 25024
#define __WARNING_25025 25025
#define __WARNING_UNSAFE_STRING_FUNCTION 25025
#define __WARNING_25026 25026
#define __WARNING_OBSOLETE_INI_ACCESSOR 25026
#define __WARNING_25027 25027
#define __WARNING_BANNED_FUNCTION 25027
#define __WARNING_25028 25028
#define __WARNING_FUNCTION_NEEDS_REVIEW 25028
#define __WARNING_25029 25029
#define __WARNING_OBSOLETE_ACL_FUNCTION 25029
#define __WARNING_25030 25030
#define __WARNING_BOGUS_EXPRESSION_LIST 25030
#define __WARNING_25031 25031
#define __WARNING_HRESULT_NOT_CHECKED 25031
#define __WARNING_25032 25032
#define __WARNING_NONCONST_LOCAL_BUFFERPTR 25032
#define __WARNING_25033 25033
#define __WARNING_NONCONST_BUFFER_PARAM 25033
#define __WARNING_25035 25035
#define __WARNING_SIZEOF_POINTER_IN_DIVISION 25035
#define __WARNING_25036 25036
#define __WARNING_STATIC_MASKING_VIRTUAL 25036
#define __WARNING_25037 25037
#define __WARNING_TRUE_CONSTANT_EXPR_IN_AND 25037
#define __WARNING_25038 25038
#define __WARNING_FALSE_CONSTANT_EXPR_IN_AND 25038
#define __WARNING_25039 25039
#define __WARNING_TRUE_CONSTANT_EXPR_IN_OR 25039
#define __WARNING_25040 25040
#define __WARNING_FALSE_CONSTANT_EXPR_IN_OR 25040
#define __WARNING_25041 25041
#define __WARNING_IF_CONDITION_IS_ALWAYS_TRUE 25041
#define __WARNING_25042 25042
#define __WARNING_IF_CONDITION_IS_ALWAYS_FALSE 25042
#define __WARNING_25043 25043
#define __WARNING_LOCAL_BSTR_SHOULD_BE_CONST_WCHAR_PTR 25043
#define __WARNING_25044 25044
#define __WARNING_BSTR_PARAM_SHOULD_BE_CONST_WCHAR_PTR 25044
#define __WARNING_25045 25045
#define __WARNING_ISBADPTR_FUNCTION 25045
#define __WARNING_25046 25046
#define __WARNING_SPECIFY_SELECTANY 25046
#define __WARNING_25047 25047
#define __WARNING_INCORRECT_SELECTANY 25047
#define __WARNING_25048 25048
#define __WARNING_STRINGCONST_ASSIGNED_TO_NONCONST 25048
#define __WARNING_25049 25049
#define __WARNING_FREESTANDING_CONSTANT 25049
#define __WARNING_25050 25050
#define __WARNING_LOCAL_FUNCDECL 25050
#define __WARNING_25051 25051
#define __WARNING_DIFFERENT_RETURN_TYPE_SIZE 25051
#define __WARNING_25052 25052
#define __WARNING_DIFFERENT_RETURN_TYPE_KIND 25052
#define __WARNING_25053 25053
#define __WARNING_DIFFERENT_PARAM_COUNT 25053
#define __WARNING_25054 25054
#define __WARNING_DIFFERENT_PARAM_TYPE_SIZE 25054
#define __WARNING_25055 25055
#define __WARNING_DIFFERENT_PARAM_TYPE_KIND 25055
#define __WARNING_25056 25056
#define __WARNING_REMOVEPARAMCONST_FUNCTIONCAST 25056
#define __WARNING_25057 25057
#define __WARNING_COUNT_REQUIRED_FOR_WRITABLE_BUFFER 25057
#define __WARNING_25058 25058
#define __WARNING_CAST_CAN_BE_CONST 25058
#define __WARNING_25059 25059
#define __WARNING_SUPERFLUOUS_CAST 25059
#define __WARNING_25060 25060
#define __WARNING_SUPERFLUOUS_NOTNOT 25060
#define __WARNING_25061 25061
#define __WARNING_BACKWARD_JUMP 25061
#define __WARNING_25062 25062
#define __WARNING_BACKWARD_JUMP_IN_MACRO 25062
#define __WARNING_25063 25063
#define __WARNING_FILEMAPPING_WITH_GLOBAL_NAME 25063
#define __WARNING_25064 25064
#define __WARNING_FUNCTION_CALLED_TWICE_IN_MACRO 25064
#define __WARNING_25065 25065
#define __WARNING_UNSIGNED_SHORT_NEGATIVE_INT_COMPARISON 25065
#define __WARNING_25066 25066
#define __WARNING_OUTOFRANGE_SHORT_LONG_COMPARISON 25066
#define __WARNING_25067 25067
#define __WARNING_UNREACHABLE_CASE_LABEL 25067
#define __WARNING_25068 25068
#define __WARNING_USE_WIDE_API 25068
#define __WARNING_25069 25069
#define __WARNING_GOTO 25069
#define __WARNING_25070 25070
#define __WARNING_UNINITIALIZED_DATAMEMBER 25070
#define __WARNING_25071 25071
#define __WARNING_NO_MEMBERINIT 25071
#define __WARNING_25073 25073
#define __WARNING_WRONG_MEMBERINIT_ORDER 25073
#define __WARNING_25075 25075
#define __WARNING_NOHEAP_MEMBER 25075
#define __WARNING_25076 25076
#define __WARNING_NOHEAP_BASECLASS 25076
#define __WARNING_25077 25077
#define __WARNING_NEW_ON_NOHEAP 25077
#define __WARNING_25078 25078
#define __WARNING_CONDITIONAL_WITH_FALSE_TRUE 25078
#define __WARNING_25079 25079
#define __WARNING_CONDITIONAL_WITH_TRUE_FALSE 25079
#define __WARNING_25080 25080
#define __WARNING_CONDITIONAL_WITH_SAME_ALTERNATIVES 25080
#define __WARNING_25084 25084
#define __WARNING_DANGEROUS_ALL_ACCESS_ACL 25084
#define __WARNING_25085 25085
#define __WARNING_URL_NEEDS_TO_BE_REVIEWED 25085
#define __WARNING_25086 25086
#define __WARNING_SD_REQUIRED_FOR_NAMED_OBJECT 25086
#define __WARNING_25087 25087
#define __WARNING_UNSPECIFIED_ACCESSRIGHTS 25087
#define __WARNING_25089 25089
#define __WARNING_DEPRECATED_WIN16_FUNCTION 25089
#define __WARNING_25090 25090
#define __WARNING_USE_CPLUSPLUS_BOOL_CONST 25090
#define __WARNING_25091 25091
#define __WARNING_RETURNTYPE_CAN_BE_BOOL 25091
#define __WARNING_25092 25092
#define __WARNING_LOCAL_CAN_BE_BOOL 25092
#define __WARNING_25093 25093
#define __WARNING_FORMAL_CAN_BE_BOOL 25093
#define __WARNING_25094 25094
#define __WARNING_BASECLASS_SHOULDHAVE_PROTECTED_OR_VIRTUAL_DTOR 25094
#define __WARNING_25096 25096
#define __WARNING_ENUM_TYPEDEF 25096
#define __WARNING_25098 25098
#define __WARNING_INTEGRAL_CAST_TO_OBJECT_WITH_VTABLE 25098
#define __WARNING_25099 25099
#define __WARNING_USE_PREFIX_OPERATOR 25099
#define __WARNING_25100 25100
#define __WARNING_LHS_TEMP_OBJECT 25100
#define __WARNING_25101 25101
#define __WARNING_RHS_TEMP_OBJECT 25101
#define __WARNING_25102 25102
#define __WARNING_EXC_NOT_CAUGHT_BY_REFERENCE 25102
#define __WARNING_25103 25103
#define __WARNING_EXC_NOT_THROWN_BY_VALUE 25103
#define __WARNING_25104 25104
#define __WARNING_INCONSISTENT_DECLSPECS 25104
#define __WARNING_25105 25105
#define __WARNING_SEALED_BASE_CLASS 25105
#define __WARNING_25106 25106
#define __WARNING_SEALED_BASE_METHOD 25106
#define __WARNING_25107 25107
#define __WARNING_NOTRUNCCAST_PARAM 25107
#define __WARNING_25108 25108
#define __WARNING_UNBOUND_RETURN 25108
#define __WARNING_25109 25109
#define __WARNING_MISSING_BINDRETURN 25109
#define __WARNING_25110 25110
#define __WARNING_CLARYFY_PRECEDENCE_FOR_QUESTIONOPERATOR 25110
#define __WARNING_25112 25112
#define __WARNING_DEPRECATED_FUNCTION 25112
#define __WARNING_25113 25113
#define __WARNING_DEPRECATED_LANGUAGE_TYPE_USED 25113
#define __WARNING_25114 25114
#define __WARNING_UNMARKED_INTL_DEPRECATED_FUNCTION 25114
#define __WARNING_25115 25115
#define __WARNING_DEPRECATED_INTL_FUNCTION_CALL 25115
#define __WARNING_25119 25119
#define __WARNING_OLEO_DEPRECATED_FUNCTION 25119
#define __WARNING_25120 25120
#define __WARNING_COUNT_REQUIRED_FOR_VOIDPTR_BUFFER 25120
#define __WARNING_25124 25124
#define __WARNING_RETURNING_TEMP_OBJECT 25124
#define __WARNING_25125 25125
#define __WARNING_STRCPY_LOOP 25125
#define __WARNING_25126 25126
#define __WARNING_POSSIBLE_STRCPY_LOOP 25126
#define __WARNING_25127 25127
#define __WARNING_BOOLEAN_BITWISE_OPERATOR_MIX 25127
#define __WARNING_25128 25128
#define __WARNING_DIFFERENT_COMPARE_ON_64BIT 25128
#define __WARNING_25129 25129
#define __WARNING_POSSIBLE_64BIT_TRUNCATION 25129
#define __WARNING_25130 25130
#define __WARNING_NONCONST_CLSID 25130
#define __WARNING_25131 25131
#define __WARNING_EMPTY_DTOR 25131
#define __WARNING_25132 25132
#define __WARNING_BY_VALUE_FORMAL_WITH_DTOR 25132
#define __WARNING_25133 25133
#define __WARNING_BY_VALUE_TEMPLATEFORMAL_WITH_DTOR 25133
#define __WARNING_25134 25134
#define __WARNING_IMPLICIT_TEMPLATECTOR 25134
#define __WARNING_25135 25135
#define __WARNING_LOCAL_ARRAY_SHOULD_BE_STATIC 25135
#define __WARNING_25136 25136
#define __WARNING_NONCONST_LOCAL_ARRAY 25136
#define __WARNING_25137 25137
#define __WARNING_LOCAL_ARRAY_SHOULD_BE_PTR 25137
#define __WARNING_25138 25138
#define __WARNING_STATIC_ARRAY_SHOULD_BE_LOCAL_PTR 25138
#define __WARNING_25139 25139
#define __WARNING_EMPTY_NONPUBLIC_DTOR 25139
#define __WARNING_25140 25140
#define __WARNING_DANGEROUS_INTTOPTR_CAST 25140
#define __WARNING_25141 25141
#define __WARNING_PRINTF_FORMAT_STRING_PARAM_NEEDS_REVIEW 25141
#define __WARNING_25142 25142
#define __WARNING_OBSOLETE_OACR_REVIEWED_CALL_MACRO 25142
#define __WARNING_25143 25143
#define __WARNING_WRITABLE_GLOBAL_FUNCTION_POINTER 25143

/* OACRExc */

#define __WARNING_25301 25301
#define __WARNING_DTOR_SHOULD_BE_NOTHROW 25301
#define __WARNING_25302 25302
#define __WARNING_OPERATOR_DELETE_SHOULD_BE_NOTHROW 25302
#define __WARNING_25303 25303
#define __WARNING_SWAP_FUNC_SHOULD_BE_NOTHROW 25303
#define __WARNING_25304 25304
#define __WARNING_CALLBACK_FUNC_SHOULD_BE_NOTHROW 25304
#define __WARNING_25305 25305
#define __WARNING_CLEANUP_FUNC_SHOULD_BE_NOTHROW 25305
#define __WARNING_25306 25306
#define __WARNING_NOTHROW_FUNC_THROWS 25306
#define __WARNING_25307 25307
#define __WARNING_FUNC_COULD_BE_NOTHROW 25307
#define __WARNING_25308 25308
#define __WARNING_UNNECESSARY_TRY_CATCH 25308
#define __WARNING_25309 25309
#define __WARNING_NOTHROW_BLOCK_THROWS 25309
#define __WARNING_25310 25310
#define __WARNING_COM_METHOD_THROWS 25310
#define __WARNING_25311 25311
#define __WARNING_GENERATED_FUNC_THROWS 25311

/* OACRMODEL */

#define __WARNING_25351 25351
#define __WARNING_HUNGARIAN_INFERRED 25351
#define __WARNING_25352 25352
#define __WARNING_MISSING_ANNOTATION 25352
#define __WARNING_25353 25353
#define __WARNING_OVERRIDE_AT_NON_VIRTUAL 25353
#define __WARNING_25354 25354
#define __WARNING_OVERRIDE_AT_STATIC 25354
#define __WARNING_25355 25355
#define __WARNING_OVERRIDE_AT_BASECLASS 25355
#define __WARNING_25356 25356
#define __WARNING_UNSUPPORTED_DEREF_VALUE 25356
#define __WARNING_25357 25357
#define __WARNING_PRE_ANNOTATION_AT_RETURNVALUE 25357
#define __WARNING_25358 25358
#define __WARNING_MISSING_NOTHROW_AT_DECL 25358
#define __WARNING_25359 25359
#define __WARNING_DEPRECATED_OVERRIDE 25359
#define __WARNING_25360 25360
#define __WARNING_OBSOLETE_OVERRIDE 25360
#define __WARNING_25361 25361
#define __WARNING_ILLEGAL_BOUND_AT_PARAM 25361
#define __WARNING_25362 25362
#define __WARNING_ILLEGAL_BOUND_AT_RETURN 25362
#define __WARNING_25363 25363
#define __WARNING_ILLEGAL_DEREF_BOUND_AT_PARAM 25363
#define __WARNING_25364 25364
#define __WARNING_ILLEGAL_DEREF_BOUND_AT_RETURN 25364
#define __WARNING_25365 25365
#define __WARNING_ILLEGAL_RANGE_AT_PARAM 25365
#define __WARNING_25366 25366
#define __WARNING_ILLEGAL_RANGE_AT_RETURN 25366
#define __WARNING_25367 25367
#define __WARNING_ILLEGAL_DEREF_RANGE_AT_PARAM 25367
#define __WARNING_25368 25368
#define __WARNING_ILLEGAL_DEREF_RANGE_AT_RETURN 25368
#define __WARNING_25369 25369
#define __WARNING_PARAM_UPPERBOUND_LT_LOWERBOUND 25369
#define __WARNING_25370 25370
#define __WARNING_RETURN_UPPERBOUND_LT_LOWERBOUND 25370
#define __WARNING_25371 25371
#define __WARNING_NO_ANNOTATIONS_AT_DECLARATION 25371
#define __WARNING_25372 25372
#define __WARNING_DECLSPEC_SAL_ANNOTATION 25372

/* espX */

#define __WARNING_26000 26000
#define __WARNING_BUFFER_OVERFLOW 26000
#define __WARNING_26001 26001
#define __WARNING_BUFFER_UNDERFLOW 26001
#define __WARNING_26002 26002
#define __WARNING_READ_UNTRACKED_BUFFER 26002
#define __WARNING_26003 26003
#define __WARNING_UNTRACKED_BUFFER 26003
#define __WARNING_26004 26004
#define __WARNING_UNINITIALIZED_POINTER 26004
#define __WARNING_26005 26005
#define __WARNING_ZEROLENGTHARRAY 26005
#define __WARNING_26006 26006
#define __WARNING_INCORRECT_ANNOTATION_STRING 26006
#define __WARNING_26007 26007
#define __WARNING_INCORRECT_ANNOTATION 26007
#define __WARNING_26009 26009
#define __WARNING_BUFFERACCESS 26009
#define __WARNING_26010 26010
#define __WARNING_POTENTIAL_BUFFER_OVERFLOW 26010
#define __WARNING_26011 26011
#define __WARNING_POTENTIAL_BUFFER_UNDERFLOW 26011
#define __WARNING_26012 26012
#define __WARNING_UNTRACKED_BUFFER_BUT_UNANNOTATABLE 26012
#define __WARNING_26013 26013
#define __WARNING_COMPLEX_EXPR 26013
#define __WARNING_26014 26014
#define __WARNING_INCORRECT_VALIDATION 26014
#define __WARNING_26015 26015
#define __WARNING_POTENTIAL_BUFFER_OVERFLOW_HIGH_PRIORITY 26015
#define __WARNING_26016 26016
#define __WARNING_BUFFER_OVERFLOW_NULL_TERMINATED 26016
#define __WARNING_26017 26017
#define __WARNING_POTENTIAL_BUFFER_OVERFLOW_MISC 26017
#define __WARNING_26018 26018
#define __WARNING_POTENTIAL_BUFFER_OVERFLOW_NULLTERMINATED 26018
#define __WARNING_26019 26019
#define __WARNING_INCORRECT_VALIDATION2 26019

/* SALCheck */

#define __WARNING_26020 26020
#define __WARNING_INSANE_ANNOTATION 26020
#define __WARNING_26021 26021
#define __WARNING_ANNOTATION_MISMATCH_MISSING_FIRST 26021
#define __WARNING_26022 26022
#define __WARNING_ANNOTATION_MISMATCH_MISSING_SECOND 26022
#define __WARNING_26023 26023
#define __WARNING_ANNOTATION_MISMATCH 26023

/* espX */

#define __WARNING_26030 26030
#define __WARNING_POSTCONDITION_BUFFER_OVERFLOW 26030
#define __WARNING_26031 26031
#define __WARNING_POSTCONDITION_BUFFER_UNDERFLOW 26031
#define __WARNING_26035 26035
#define __WARNING_PRECONDITION_NULLTERMINATION_VIOLATION 26035
#define __WARNING_26036 26036
#define __WARNING_POSTCONDITION_NULLTERMINATION_VIOLATION 26036
#define __WARNING_26037 26037
#define __WARNING_POTENTIAL_NULLTERMINATION_VIOLATION 26037
#define __WARNING_26040 26040
#define __WARNING_POTENTIAL_POSTCONDITION_BUFFER_OVERFLOW 26040
#define __WARNING_26041 26041
#define __WARNING_POTENTIAL_POSTCONDITION_BUFFER_UNDERFLOW 26041
#define __WARNING_26044 26044
#define __WARNING_INCORRECT_VALIDATION_POSTCONDITION 26044
#define __WARNING_26045 26045
#define __WARNING_HIGH_PRIORITY_OVERFLOW_POSTCONDITION 26045
#define __WARNING_26050 26050
#define __WARNING_CHECKER_ASSERTION_FAILURE 26050
#define __WARNING_26051 26051
#define __WARNING_IRREDUCIBLE_CFG 26051
#define __WARNING_26052 26052
#define __WARNING_POTENTIALLY_UNCONSTRAINED_CALL 26052
#define __WARNING_26053 26053
#define __WARNING_POTENTIAL_BUFFER_OVERFLOW_LOOP_DEPENDENT 26053
#define __WARNING_26060 26060
#define __WARNING_RANGE_PRECONDITION_VIOLATION 26060
#define __WARNING_26061 26061
#define __WARNING_RANGE_POSTCONDITION_VIOLATION 26061
#define __WARNING_26070 26070
#define __WARNING_POTENTIAL_RANGE_PRECONDITION_VIOLATION 26070
#define __WARNING_26071 26071
#define __WARNING_POTENTIAL_RANGE_POSTCONDITION_VIOLATION 26071
#define __WARNING_26080 26080
#define __WARNING_VALIDATED_ACCESS 26080
#define __WARNING_26081 26081
#define __WARNING_USING_STRUCT_ANNOTATION 26081
#define __WARNING_26090 26090
#define __WARNING_SUSPICIOUS_FUNCTION_POINTER_CAST 26090

/* NullPtr */

#define __WARNING_26500 26500
#define __WARNING_NULL_DEREFERENCE 26500
#define __WARNING_26501 26501
#define __WARNING_NULL_DEREFERENCE_THIS 26501
#define __WARNING_26505 26505
#define __WARNING_NULL_DEREFERENCE_API 26505
#define __WARNING_26506 26506
#define __WARNING_NULL_DEREFERENCE_THIS_API 26506
#define __WARNING_26510 26510
#define __WARNING_INTERFACE_PRE_NULL 26510
#define __WARNING_26511 26511
#define __WARNING_INTERFACE_PRE_NOTNULL 26511
#define __WARNING_26512 26512
#define __WARNING_INTERFACE_PRE_NOTNULL_VAL 26512
#define __WARNING_26515 26515
#define __WARNING_INTERFACE_POST_NULL 26515
#define __WARNING_26516 26516
#define __WARNING_INTERFACE_POST_NULL_CTOR 26516
#define __WARNING_26517 26517
#define __WARNING_INTERFACE_POST_NOTNULL 26517
#define __WARNING_26518 26518
#define __WARNING_INTERFACE_POST_NOTNULL_CTOR 26518
#define __WARNING_26520 26520
#define __WARNING_TRUNCATED_PTR 26520

/* In */

#define __WARNING_26550 26550
#define __WARNING_ASSIGNMENT_TO_IN_PARAMETER 26550

/* EspOpal */

#define __WARNING_26599 26599
#define __WARNING_GENERIC_OPAL_DEFECT 26599

/* SqlEye.Native.EscapingAndDelimiting */

#define __WARNING_26600 26600
#define __WARNING_SQLINJECTION_CXX_ESCAPING_COMMAND 26600
#define __WARNING_26601 26601
#define __WARNING_SQLINJECTION_CXX_DELIMITING_COMMAND 26601
#define __WARNING_26602 26602
#define __WARNING_SQLINJECTION_CXX_ESCAPING_AND_DELIMITING_COMMAND 26602
#define __WARNING_26604 26604
#define __WARNING_SQLINJECTION_CXX_ESCAPING_COMMAND_PRECONDITION 26604
#define __WARNING_26610 26610
#define __WARNING_SQLINJECTION_CXX_ESCAPING_CONNECTION_STRING 26610
#define __WARNING_26611 26611
#define __WARNING_SQLINJECTION_CXX_DELIMITING_CONNECTION_STRING 26611
#define __WARNING_26612 26612
#define __WARNING_SQLINJECTION_CXX_ESCAPING_AND_DELIMITING_CONNECTION_STRING 26612

/* SqlEye.Native.MissingCommandSal */

#define __WARNING_26620 26620
#define __WARNING_SQLINJECTION_CXX_MISSING_COMMAND_SAL 26620

/* SqlEye.Native.MissingConnectionStringSal */

#define __WARNING_26625 26625
#define __WARNING_SQLINJECTION_CXX_MISSING_CONNECTION_STRING_SAL 26625

/* SqlEye.Native.Truncation */

#define __WARNING_26630 26630
#define __WARNING_SQLINJECTION_CXX_TRUNCATION_COMMAND 26630
#define __WARNING_26635 26635
#define __WARNING_SQLINJECTION_CXX_TRUNCATION_CONNECTION_STRING 26635

/* SqlEye.Native.EscapingAndDelimiting */

#define __WARNING_26660 26660
#define __WARNING_SQLINJECTION_CXX_ESCAPING_COMMAND_LOWER_CONFIDENCE 26660
#define __WARNING_26661 26661
#define __WARNING_SQLINJECTION_CXX_DELIMITING_COMMAND_LOWER_CONFIDENCE 26661
#define __WARNING_26662 26662
#define __WARNING_SQLINJECTION_CXX_ESCAPING_AND_DELIMITING_COMMAND_LOWER_CONFIDENCE 26662
#define __WARNING_26670 26670
#define __WARNING_SQLINJECTION_CXX_ESCAPING_CONNECTION_STRING_LOWER_CONFIDENCE 26670
#define __WARNING_26671 26671
#define __WARNING_SQLINJECTION_CXX_DELIMITING_CONNECTION_STRING_LOWER_CONFIDENCE 26671
#define __WARNING_26672 26672
#define __WARNING_SQLINJECTION_CXX_ESCAPING_AND_DELIMITING_CONNECTION_STRING_LOWER_CONFIDENCE 26672

/* Goldpft */

#define __WARNING_38001 38001
#define __WARNING_LOCALE_SENSITIVE_STRCMP 38001
#define __WARNING_38002 38002
#define __WARNING_LOCALE_SENSITIVE_COMPARESTRING 38002
#define __WARNING_38003 38003
#define __WARNING_SYSTEM_LOCALE_MISUSE 38003
#define __WARNING_38004 38004
#define __WARNING_DEPRECATED_LIBRARY 38004
#define __WARNING_38010 38010
#define __WARNING_CALLING_SETTHREADLOCALE 38010
#define __WARNING_38011 38011
#define __WARNING_OVERRIDING_LOCALE_SETTINGS_WITH_SETLOCALEINFO 38011
#define __WARNING_38020 38020
#define __WARNING_ANSI_APICALL 38020
#define __WARNING_38021 38021
#define __WARNING_W2A_BEST_FIT 38021
#define __WARNING_38022 38022
#define __WARNING_CLIPBOARD_ANSI 38022
#define __WARNING_38023 38023
#define __WARNING_ANSI_DATAFILE 38023
#define __WARNING_38030 38030
#define __WARNING_HARD_CODED_STRING_TO_UI_FN 38030
#define __WARNING_38031 38031
#define __WARNING_HARDCODED_FONT_INFO 38031
#define __WARNING_38032 38032
#define __WARNING_CONSOLE_OUTPUT_ISSUE 38032
#define __WARNING_38033 38033
#define __WARNING_FORMAT_MESSAGE_LANG 38033
#define __WARNING_38034 38034
#define __WARNING_CONCATENATED_RESOURCE_STRING 38034
#define __WARNING_38035 38035
#define __WARNING_LOCALIZABLE_STRING_FORMAT_ISSUE 38035
#define __WARNING_38036 38036
#define __WARNING_MESSAGEBOX_RTL 38036
#define __WARNING_38037 38037
#define __WARNING_BITMAP_OR_ANSI_FONT 38037
#define __WARNING_38038 38038
#define __WARNING_COMMANDLINK_SETNOTE 38038
#define __WARNING_38039 38039
#define __WARNING_SCREEN_COORDINATES_CONVERSION 38039
#define __WARNING_38041 38041
#define __WARNING_GETDATEFORMAT_WRAPPER 38041
#define __WARNING_38042 38042
#define __WARNING_GETDATEFORMAT_AUTOLAYOUT 38042
#define __WARNING_38043 38043
#define __WARNING_LAYOUT_BITMAPORIENTATIONPRESERVED 38043
#define __WARNING_38044 38044
#define __WARNING_LOC_METADATA_GENERATED_GOLDPFT 38044
#define __WARNING_38045 38045
#define __WARNING_NON_LOCFRIENDLY_STRING_FORMATTING 38045

/* SqlEye.TSql.EscapingAndDelimiting */

#define __WARNING_80100 80100
#define __WARNING_SQLINJECTION_TSQL_ESCAPING_COMMAND 80100
#define __WARNING_80101 80101
#define __WARNING_SQLINJECTION_TSQL_DELIMITING_COMMAND 80101
#define __WARNING_80102 80102
#define __WARNING_SQLINJECTION_TSQL_ESCAPING_AND_DELIMITING_COMMAND 80102
#define __WARNING_80103 80103
#define __WARNING_SQLINJECTION_TSQL_ESCAPING_COMMAND_SECOND_ORDER 80103
#define __WARNING_80104 80104
#define __WARNING_SQLINJECTION_TSQL_ESCAPING_COMMAND_PRECONDITION 80104
#define __WARNING_80105 80105
#define __WARNING_SQLINJECTION_TSQL_ESCAPING_COMMAND_SECOND_ORDER_PRECONDITION 80105

/* SqlEye.TSQL */

#define __WARNING_80130 80130
#define __WARNING_SQLINJECTION_TSQL_TRUNCATION_COMMAND 80130
#define __WARNING_80131 80131
#define __WARNING_SQLINJECTION_TSQL_STR_TRUNCATED_ON_COMMAND_EXECUTION 80131
#define __WARNING_80140 80140
#define __WARNING_SQLINJECTION_TSQL_TRUNCATED_STR_PASSED_TO_SP 80140
#define __WARNING_80141 80141
#define __WARNING_SQLINJECTION_TSQL_STR_TRUNCATED_ON_CALL_TO_SP 80141
#define __WARNING_80142 80142
#define __WARNING_SQLINJECTION_TSQL_TRUNCATED_STR_ASSIGNED_TO_OUTPUT 80142
#define __WARNING_80143 80143
#define __WARNING_SQLINJECTION_TSQL_STR_TRUNCATED_ON_OUTPUT_ASSIGNMENT 80143

/* SqlEye.Managed.EscapingAndDelimiting */

#define __WARNING_80200 80200
#define __WARNING_SQLINJECTION_MSIL_ESCAPING_COMMAND 80200
#define __WARNING_80201 80201
#define __WARNING_SQLINJECTION_MSIL_DELIMITING_COMMAND 80201
#define __WARNING_80202 80202
#define __WARNING_SQLINJECTION_MSIL_ESCAPING_AND_DELIMITING_COMMAND 80202

#endif // _PREfast_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\OACR\3.0.40203.0\x86\inc\oacrhook.h ===
#pragma once
/*****************************************************************************

   Module  : OACRHook
   Owner   : MarcK

   Copyright (c) Microsoft Corporation. All rights reserved.

******************************************************************************

  Part of the Microsoft Auto Code Review (OACR) system.
  
  OACR supports hooking into the calls to build tools (cl.exe, link.exe, etc.),
  in order to perform custom operations as part of the build. The user can 
  provide a DLL, which is then loaded and called by OACR at the appropriate
  time. This header file declares the callback function that needs to be
  implemented by the DLL.

*****************************************************************************/

#ifdef __cplusplus

// Callback to process build tool output (stdout,stderr) line by line.
// 'pClientData' is the client data passed to FReadStdOutFile() or FReadStdErrFile().
// Must return true to get next line, or false to abort reading.
typedef bool ( __stdcall *PFNFPROCESSLINE )( const WCHAR* wzLine, void* pClientData );


// The interface passed with each notification.
interface IBuildToolRunInfo
{
   // NOTE: All APIs returning a string, return the number of characters
   //       copied to the output string (not including the NULL termination). 
   //       If the string to be returned is too long, it is truncated, and
   //       the buffer size is returned.
   //       If 0 is passed for the buffer size, the minimum required buffer
   //       size (including the NULL termination) is returned.
   //       In the error case, 0 is returned.

   // Build tools that can be hooked into
   enum Tool
   {
      NONE = 0,

      CL,   // C/C++ compiler (cl.exe)
      CSC,  // C# compiler (csc.exe)
      LINK, // Linker (link.exe)
      LIB,  // Library manager (lib.exe)
      MIDL, // MIDL compiler (midl.exe)
   };

   // Notifications sent
   enum Notification
   {
      BEFORE_RUN,   // Sent before the build tool is called
      AFTER_RUN,    // Sent after the build tools has been run
      AFTER_RETRY,  // Sent after a retry of a build tool run
   };

   //-------------------------------------------------------------------------
   // Client data
   //
   // Can be used to maintain state between notifications for the same build
   // tool run.
   //-------------------------------------------------------------------------

   virtual void  SetClientData( void* pData ) = 0;
   virtual void* GetClientData() const = 0;

   //-------------------------------------------------------------------------
   // Retrieve information - Any notification
   //-------------------------------------------------------------------------

   // Return the current notification.
   virtual Notification GetNotification() const = 0;

   // Return the build tool that triggered the notification.
   virtual Tool GetTool() const = 0;

   // Return the name of the OACR project under which the build tool has been called.
   virtual DWORD GetOACRProjectName( WCHAR* wzProjectName, DWORD cchProjectName ) const = 0;

   // Return the command line, as passed to the build tool.
   virtual DWORD GetCommandLine( WCHAR* wzCommandLine, DWORD cchCommandLine ) const = 0;

   // Return the fully expanded command line. Reponse files (e.g. '@c:\temp\foo.tmp'),
   // and environment variables (e.g. %CL%) are folded into the command line.
   virtual DWORD GetExpandedCommandLine( WCHAR* wzCommandLine, DWORD cchCommandLine ) const = 0;

   // Return the full path name of the build tool executable.
   virtual DWORD GetToolFileName( WCHAR* wzFileName, DWORD cchFileName ) const = 0;

   // Return the full path name of the primary output file generated by the build tool run.
   //    CL  : .obj file
   //    CSC : .exe or .dll (specified in the first /out switch)
   //    LINK: .exe or .dll
   //    LIB : .lib
   //    MIDL: .h file
   // The call fails for CL with multiple source files (batch runs). Use the batch run
   // APIs to get information about batch runs.
   virtual DWORD GetOutputFileName( WCHAR* wzFileName, DWORD cchFileName ) const = 0;

   //
   // Batch run info (CL only)
   //

   // Return true for a batch CL run (i.e. multiple source files)
   virtual bool FBatchRun() const = 0;

   // Return the number of source files in the batch run. Returns 0, for non batch runs.
   virtual DWORD CBatchItems() const = 0;

   // Return the full path name of the output file (.obj) for the source file with the
   // specified index. Returns 0 for non batch runs.
   virtual DWORD GetBatchItemOutputFileName( DWORD whichItem, WCHAR* wzFileName, DWORD cchFileName ) const = 0;

   //-------------------------------------------------------------------------
   // Retrieve information - Notifications 'AFTER_RUN' or 'AFTER_RETRY'
   //-------------------------------------------------------------------------

   // Return the result code for the build tool run.
   virtual int GetResult() const = 0;

   // Return the full path name of the file to which stdout output of the build tool run
   // has been redirected. Returns 0, if stdout redirection is turned off.
   virtual DWORD GetStdOutFileName( WCHAR* wzFileName, DWORD cchFileName ) const = 0;

   // Return the full path name of the file to which stderr output of the build tool run
   // has been redirected. Returns 0, if stderr redirection is turned off.
   virtual DWORD GetStdErrFileName( WCHAR* wzFileName, DWORD cchFileName ) const = 0;

   // Read the redirected stdout output of the build tool run, and send it to the specified
   // callback line by line. Noop, if stdout redirection is turned off.
   virtual bool FReadStdOutFile( PFNFPROCESSLINE pfnFProcessLine, void* pClientData = NULL ) const = 0;

   // Read the redirected stderr output of the build tool run, and send it to the specified
   // callback line by line. Noop, if stderr redirection is turned off.
   virtual bool FReadStdErrFile( PFNFPROCESSLINE pfnFProcessLine, void* pClientData = NULL ) const = 0;

   //
   // Batch run info (CL only)
   //

   // Return true, if the source file with the specified index was compiled successfully.
   // Returns fals for non batch runs.
   virtual bool FBatchItemSuccess( DWORD whichItem ) const = 0;

   //-------------------------------------------------------------------------
   // Generate stdout & stderr output - Any notification
   //-------------------------------------------------------------------------

   // Write to stdout.
   virtual void WriteStdOut( const WCHAR* wzMessage ) const = 0;

   // Write to stderr.
   virtual void WriteStdErr( const WCHAR* wzMessage ) const = 0;

   // Write the content of the specified text file to stdout.
   virtual bool FWriteStdOutFromFile( const WCHAR* wzFileName ) const = 0;

   // Write the content of the specified text file to stderr.
   virtual bool FWriteStdErrFromFile( const WCHAR* wzFileName ) const = 0;

   //-------------------------------------------------------------------------
   // Modify tool run - Any notification
   //-------------------------------------------------------------------------

   // Enable or disable further notifications for this build tool run. 
   // Notifications are enabled by default.
   virtual void SetNotify( bool fNotify ) = 0;

   // Override the result code for the build tool run.
   virtual void SetResult( int result ) = 0;

   // Set the command line to be passed to the build tool.
   virtual void SetCommandLine( const WCHAR* wzCommandLine ) = 0;

   // Set the file name of the build tool executable to be called.
   virtual void SetToolFileName( const WCHAR* wzFileName ) = 0;

   // Enable or disable redirection of stdout output of the build tool run.
   // Redirection is disabled by default.
   virtual void SetCaptureStdOut( bool fCapture ) = 0;

   // Enable or disable redirection of stderr output of the build tool run.
   // Redirection is disabled by default.
   virtual void SetCaptureStdErr( bool fCapture ) = 0;

   //-------------------------------------------------------------------------
   // Modify tool run - Notification 'BEFORE_RUN'
   //-------------------------------------------------------------------------

   // Cancel the build tool run. Use the SetResult() API to set the result code.
   // This is a noop, if called during the AFTER_RUN or AFTER_RETRY notification.
   virtual void CancelRun() = 0;

   //-------------------------------------------------------------------------
   // Modify tool run - Notifications 'AFTER_RUN' or 'AFTER_RETRY'
   //-------------------------------------------------------------------------

   // Force a retry of the build tool run.
   // This is a noop, if called during the BEFORE_RUN notification.
   virtual void RetryRun() = 0;

}; // IBuildToolRunInfo


// The callback that is called by OACR.
// This method needs to be implemented in the user provided DLL, so that OACR 
// can call it through LoadLibrary()/GetProcAddress()
extern "C" _Callback_ void __stdcall OnBuildToolRun( _In_ IBuildToolRunInfo& toolRunInfo );

#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\OACR\3.0.40203.0\x86\inc\oacr.h ===
#pragma once
/*****************************************************************************

   Module  : OACR
   Owner   : HannesR

******************************************************************************

   Definitions and #defines for OACR support

*****************************************************************************/

// SAL annotations are #defined in this file
#include <sal.h>
#include <specstrings.h>
//#include "oacrsal.h"
#include "pftwarnings.h"

#if( _PREFAST_ )
#if( _MSC_VER < 1400 )
#define _PREFAST2_ 1
#else
#define _PREFAST8_ 1
#endif
#endif

// Allow deprecated Pre Orcas style annotations by default
#ifndef OACR_DEPRECATED
#define OACR_DEPRECATED 1
#endif

#ifndef ARM
#define __oacr_noop __noop
#else
#define __oacr_noop
#endif

#if defined(__cplusplus)
#define __extern_c     extern "C"
#define __extern_cplus extern "C++"
#else
#define __extern_c
#define __extern_cplus
#endif

#define __noreturn __declspec( noreturn )

// size_t is used in some OACR macros
#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif

// OACR keywords:
// annotations undertstood by PREfast plugins

#ifndef _Sealed_method_
// use _Sealed_method_ to specify C# style 'sealed' behavior for methods
#define _Sealed_method_ __oacr_sealed_method
#endif // _Sealed_method_


#ifndef _Sealed_class_
// use _Sealed_class_ to specify C# style 'sealed' behavior for classes
#define _Sealed_class_ __oacr_sealed_class
#endif // _Sealed_class_


#ifndef _SA_deprecated_
// use _SA_deprecated_ to mark functions that should not be called any more
// pass the replacement function as argument to the macro
#define _SA_deprecated_(NewFunctionName) __oacr_sa_deprecated(NewFunctionName)
#endif // _SA_deprecated_


#ifndef _Intl_deprecated_
// annotation used by warning UNMARKED_INTL_DEPRECATED_FUNCTION (25114)
// to mark deprecated functions using LCID parameters
// The annotation is used by Office to cleanup the use of LCIDs
#define _Intl_deprecated_ __oacr_intl_deprecated
#endif // _Intl_deprecated_


#ifndef _Oleo_deprecated_
// Office specifix annotation used by the OLEO effort
#define _Oleo_deprecated_( NewFunctionName ) __oacr_oleo_deprecated(NewFunctionName)
#endif // _Oleo_deprecated_


#ifndef _Rpc_
// use _Rpc_ for functions that used as remote procedure calls, the keyword will silence
// various OACR checks on formal parameters of the marked functions
#define _Rpc_ __oacr_rpc
#endif // _Rpc_


#ifndef _RequireNoThrow_
// use _RequireNoThrow_ inside a compound statement to indicate that the rest of the block
// should not emit exceptions.
#define _RequireNoThrow_ __oacr_requireNoThrow
#endif // _RequireNoThrow_


#ifndef _Canthrow_
// use _Canthrow_ for method declarations of template classes that have throwing and non-throwing
// specializations to suppress warning FUNC_COULD_BE_NOTHROW (25307).
#define _Canthrow_ __oacr_canthrow
#endif // __requireNoThrow


#ifndef _Genericfunctype_
// use _Genericfunctype_ for function typedefs used for arrays of functions of different function types.
// if the typedef is marked as _Genericfunctype_, OACR will not generate DIFFERENT_CALLING_CONVENTION (25018) warnings
// e.g. typedef _Genericfunctype_ void (*FUNCPTR)();
#if( OACR )
#define _Genericfunctype_ __oacr_genericfunctype
#else
#define _Genericfunctype_
#endif
#endif // _Genericfunctype_


#ifndef _Nothrowfunctype_
// use _Nothrowfunctype_ for function typedefs of non exception throwing function pointers
// e.g. typedef _Nothrowfunctype_ void (*FUNCPTR)();
// only assign non throwing functions to typedefs so marked
#define _Nothrowfunctype_ __oacr_nothrowfunctype
#endif // _Nothrowfunctype_


#ifndef _BindReturn_
// stronger than __checkReturn, typically used by functions that return
// a pointer to an allocated object
// e.g _BindReturn_ void* malloc( size_t size );
// void Bar()
// {
//    void* pv;
//    if( ( pv == malloc( 20 ) ) == NULL )      <<<< typo !!
//    ...
// }
#define _BindReturn_ __oacr_bindReturn
#endif // _BindReturn_


#ifndef _Memberinitializer_
// use _Memberinitializer_ for init functions that initialize all members of a class
// e.g.:
// class X
// {
//    int m_i:
//    int m_j:
//    _Memberinitializer_ void Init(){ m_i = m_j = 0; }
// public:
//    X(){ Init(); }
// };
#define _Memberinitializer_ __oacr_memberinitializer
#endif // _Memberinitializer_


#ifndef _Noheap_
// use _Noheap_ classes that should not be instantiated on the heap
// e.g.:
// _Noheap_ class CriticalSection
// {
// public:
//    CriticalSection();
//    ~CriticalSection();
// };
#define _Noheap_ __oacr_noheap
#endif // _Noheap_


#ifndef _Unsafe_string_api_
// use _Unsafe_string_api_ to phase out functions that pass unbound writable buffers
// e.g.
// _Unsafe_string_api_ void MyStrCpy( char* szTo, const char* szFrom );
#define _Unsafe_string_api_ __oacr_unsafe_string_api
#endif // _Unsafe_string_api_


#ifndef _Needsreview_
// use _Needsreview_ to mark functions whose calls need to be reviewed for a
// special reason.
// e.g. a wrapper function to another function that needs to be reviewed
//_Needsreview_ __inline BOOL MsoGetStringTypeExW(LCID Locale, DWORD dwInfoType, LPCWSTR lpSrcStr, int cchSrc, LPWORD lpCharType)
//{
//   return OACR_REVIEWED_CALL("hannesr", GetStringTypeExW(Locale, dwInfoType, lpSrcStr, cchSrc, lpCharType));
//}
// use the OACR_REVIEWED_CALL macro to silent the warning after making sure that the function is used properly
#define _Needsreview_ __oacr_needsreview
#endif // _Needsreview_


#ifndef _Notrunccast_
// use _Notrunccast_ to find unsafe truncating cast on allocating functions taking
// a 16 bit size parameter
// e.g.
// void* MyMalloc( _Notrunccast_ ushort size );
#define _Notrunccast_ __oacr_notrunccast
#endif // _Notrunccast_


#ifndef _Noinference_
// keyword to disable (wrong) Hungarian inference of __count annotations
// inference is disabled for the all formals of the function
// e.g. _Noinference_ void FreePv( void* pv, size_t cb );
#define _Noinference_     __oacr_noinference
#endif // _Noinference_


// Pre Orcas style annotations are deprecated
#if( OACR_DEPRECATED )

#ifndef __sealed_method
#define __sealed_method                      _Sealed_method_
#endif
#ifndef __sealed_class
#define __sealed_class                       _Sealed_class_
#endif
#ifndef __sa_deprecated
#define __sa_deprecated(NewFunctionName)     _SA_deprecated_(NewFunctionName)
#endif
#ifndef __intl_deprecated
#define __intl_deprecated                    _Intl_deprecated_
#endif
#ifndef __oleo_deprecated
#define __oleo_deprecated( NewFunctionName ) _Oleo_deprecated_(NewFunctionName)
#endif
#ifndef __rpc
#define __rpc                                _Rpc_
#endif
#ifndef __requireNoThrow
#define __requireNoThrow                     _RequireNoThrow_
#endif
#ifndef __canthrow
#define __canthrow                           _Canthrow_
#endif
#ifndef __genericfunctype
#define __genericfunctype                    _Genericfunctype_
#endif
#ifndef __nothrowfunctype
#define __nothrowfunctype                    _Nothrowfunctype_
#endif
#ifndef __bindReturn
#define __bindReturn                         _BindReturn_
#endif
#ifndef __memberinitializer
#define __memberinitializer                  _Memberinitializer_
#endif
#ifndef __noheap
#define __noheap                             _Noheap_
#endif
#ifndef __nostack
#define __nostack                            // not supported
#endif
#ifndef __unsafe_string_api
#define __unsafe_string_api                  _Unsafe_string_api_
#endif
#ifndef __needsreview
#define __needsreview                        _Needsreview_
#endif
#ifndef __notrunccast
#define __notrunccast                        _Notrunccast_
#endif
#ifndef __noinference
#define __noinference                        _Noinference_
#endif
#ifndef __min_function
#define __min_function                       // deprecated, use range annotations
#endif
#ifndef __max_function
#define __max_function                       // deprecated, use range annotations
#endif
#ifndef __printf_format_string
#define __printf_format_string               _Printf_format_string_
#endif

#undef __callback
#define __callback                           _Callback_

#ifndef __sa_sealed // use __sealed_method and __sealed_class instead
#if( OACR )
#define __sa_sealed __declspec("_Sealed_")
#else
#define __sa_sealed
#endif
#endif // __sa_sealed

#endif // OACR_DEPRECATED

//-----------------

// OACR helper macros to suppress particular warnings

#ifndef OACR_USE_PTR
// use to suppress constness and related warnings:
// NONCONST_LOCAL (25003), NONCONST_PARAM( 25004), NONCONST_FUNCTION (25005), 
// NONCONST_LOCAL_BUFFERPTR (25032), NONCONST_BUFFER_PARAM (25033)
#if( OACR )
__extern_c void OACRUsePtr( void* p );
#define OACR_USE_PTR( p ) OACRUsePtr( p )
#else
#define OACR_USE_PTR( p ) __oacr_noop
#endif
#endif // OACR_USE_PTR

#ifndef OACR_MEMBER_IS_INITIALIZED_IN_CTOR
// Use to suppress warning UNINITIALIZED_DATAMEMBER (25070) (as issued from a _Memberinitializer_)
// for data members which are correctly initialized in the ctor.
// (Warning 25070 cannot automatically handle member initialization that
// is spread across both ctor initializer list and a _Memberinitializer_ method).
// NOTES: This is functionally to OACR_USE_PTR(&m).
//        Contrast with OACR_MEMBER_IS_INITIALIZED_IN_MEMBERINITIALIZER.
#define OACR_MEMBER_IS_INITIALIZED_IN_CTOR( m ) OACR_USE_PTR( &m )
#endif // OACR_MEMBER_IS_INITIALIZED_IN_CTOR

#ifndef OACR_MEMBER_IS_INITIALIZED_IN_MEMBERINITIALIZER
// Use to suppress warning UNINITIALIZED_DATAMEMBER (25070) (as issued from a ctor)
// for data members which are correctly initialized in the _Memberinitializer_ method.
// (Warning 25070 cannot automatically handle member initialization that
// is spread across both ctor initializer list and a _Memberinitializer_ method).
// NOTES: This is functionally equivalent to OACR_USE_PTR(&m).
//        Contrast with OACR_MEMBER_IS_INITIALIZED_IN_CTOR.
#define OACR_MEMBER_IS_INITIALIZED_IN_MEMBERINITIALIZER( m ) OACR_USE_PTR( &m )
#endif // OACR_MEMBER_IS_INITIALIZED_IN_MEMBERINITIALIZER

#ifndef OACR_POSSIBLE_THROW
// use to suppress __nothrow related warnings NOTHROW_FUNC_THROWS (25306) and FUNC_COULD_BE_NOTHROW (25307)
#if( OACR )
__extern_cplus void OACRPossibleThrow();
#define OACR_POSSIBLE_THROW OACRPossibleThrow()
#else
#define OACR_POSSIBLE_THROW __oacr_noop
#endif
#endif // OACR_POSSIBLE_THROW

#ifndef OACR_ASSUME_NOTHROW_BEGIN
// use with OACR_ASSUME_NOTHROW_END to suppress NOTHROW_FUNC_THROWS warnings around functions that don't throw in this context
// macro pair needs to be on the same scope
#if( OACR )
#define OACR_ASSUME_NOTHROW_BEGIN try{
#define OACR_ASSUME_NOTHROW_END }catch(...){}
#else
#define OACR_ASSUME_NOTHROW_BEGIN
#define OACR_ASSUME_NOTHROW_END
#endif
#endif // OACR_POSSIBLE_THROW

#ifndef UNREFERENCED_OACR
// use to function staticness and related warnings: STATIC_FUNCTION (25007)
#if( OACR )
#define UNREFERENCED_OACR( p ) __assume( p == p )
#else
#define UNREFERENCED_OACR( p )
#endif
#endif // UNREFERENCED_OACR


#ifndef OACR_OWN_PTR
// can be used for objects that attach themselves to an owner
// in their constructors
#if( OACR )
__extern_c void OACROwnPtr( const void* p );
#define OACR_OWN_PTR( p ) OACROwnPtr( p )
#else
#define OACR_OWN_PTR( p ) __oacr_noop
#endif
#endif // OACR_OWN_PTR


#ifndef OACR_PTR_NOT_NULL
// tells OACR that a pointer is not null at this point
#if( OACR )
#define OACR_PTR_NOT_NULL( p ) OACR_ASSUME( 0 != p )
#else
#define OACR_PTR_NOT_NULL( p ) __oacr_noop
#endif
#endif // OACR_PTR_NOT_NULL


#ifndef OACR_NOT_IMPLEMENTED_MEMBER
#if( OACR )
#define OACR_NOT_IMPLEMENTED_MEMBER OACR_USE_PTR( (void*)this )
#else
#define OACR_NOT_IMPLEMENTED_MEMBER
#endif
#endif // OACR_NOT_IMPLEMENTED_MEMBER


#ifndef OACR_DECLARE_FILLER
#if( OACR )
#define OACR_DECLARE_FILLER( type, inst ) type __filler##inst;
#else
#define OACR_DECLARE_FILLER( type, inst )
#endif
#endif // OACR_DECLARE_FILLER


// use this macro once you have inspected warnings FUNCTION_NEEDS_REVIEW (25028)
#ifndef OACR_REVIEWED_CALL
#if( OACR )
__extern_c void __OACRReviewedCall();
#define OACR_REVIEWED_CALL( reviewer, functionCall ) ( __OACRReviewedCall(), functionCall )
#else
#define OACR_REVIEWED_CALL( reviewer, functionCall ) functionCall
#endif
#endif // OACR_REVIEWED_CALL


// use this macro once you have inspected warnings URL_NEEDS_TO_BE_REVIEWED (25085)
#ifndef OACR_REVIEWED_URL
#if( OACR )
__extern_c void __OACRReviewedUrl();
#define OACR_REVIEWED_URL( reviewer, reviewedUrl ) ( __OACRReviewedUrl(), reviewedUrl )
#else
#define OACR_REVIEWED_URL( reviewer, reviewedUrl ) reviewedUrl
#endif
#endif // OACR_REVIEWED_URL

#if( OACR && defined(_WINDEF_) && 0 )

// redefine FALSE & TRUE for better HRESULT<->BOOL conversion detection
#ifdef FALSE
#undef FALSE
#define FALSE ((BOOL)0)
#endif

#ifdef TRUE
#undef TRUE
#define TRUE ((BOOL)1)
#endif

#endif

// Use the following macros to suppress and disable OACR warnings in the code
// Using the macros allows us to have the same source code being compiled with
// PREfast 2.x and Whidbey PREfast

// macro to tell OACR to not issue a specific warning for the following line of code
// use to suppress false positives from OACR
// e.g.
// if( fPointerNotNull )
//    OACR_WARNING_SUPRESS( DEREF_NULL_PTR, "pointer access is guarded by 'fPointerNotNull'" )
//    p->Foo();

#ifndef OACR_WARNING_PUSH
#if( OACR && !defined(OACR_NO_WARNING_MACROS) )
#if( 1400 <=_MSC_VER )
#define OACR_WARNING_PUSH __pragma ( warning( push ) )
#else
#define OACR_WARNING_PUSH __pragma ( prefast( push ) )
#endif
#else
#define OACR_WARNING_PUSH
#endif
#endif

#ifndef OACR_WARNING_POP
#if( OACR && !defined(OACR_NO_WARNING_MACROS) )
#if( 1400 <=_MSC_VER )
#define OACR_WARNING_POP __pragma ( warning( pop ) )
#else
#define OACR_WARNING_POP __pragma ( prefast( pop ) )
#endif
#else
#define OACR_WARNING_POP
#endif
#endif

#ifndef OACR_WARNING_ENABLE
#if( OACR && !defined(OACR_NO_WARNING_MACROS) )
#if( 1400 <=_MSC_VER )
#define OACR_WARNING_ENABLE( cWarning, comment ) __pragma ( warning( enable: __WARNING_##cWarning ) )
#else
#define OACR_WARNING_ENABLE( cWarning, comment )
#endif
#else
#define OACR_WARNING_ENABLE( cWarning, comment )
#endif
#endif

#ifndef OACR_WARNING_DISABLE
#if( OACR && !defined(OACR_NO_WARNING_MACROS) )
#if( 1400 <=_MSC_VER )
#define OACR_WARNING_DISABLE( cWarning, comment ) __pragma ( warning( disable: __WARNING_##cWarning ) )
#else
#define OACR_WARNING_DISABLE( cWarning, comment ) __pragma ( prefast( disable: __WARNING_##cWarning, comment ) )
#endif
#else
#define OACR_WARNING_DISABLE( cWarning, comment )
#endif
#endif

#ifndef OACR_WARNING_SUPPRESS
#if( OACR && !defined(OACR_NO_WARNING_MACROS) )
#if( 1400 <=_MSC_VER )
#define OACR_WARNING_SUPPRESS( cWarning, comment ) __pragma ( warning( suppress: __WARNING_##cWarning ) )
#else
#define OACR_WARNING_SUPPRESS( cWarning, comment ) __pragma ( prefast( suppress: __WARNING_##cWarning, comment) )
#endif
#else
#define OACR_WARNING_SUPPRESS( cWarning, comment )
#endif
#endif

// macro to tell OACR about conditions that are true.
// Use OACR_ASSUME instead of #pragma prefast(suppress,...) if possible
// e.g.:
// if( g_pRoot == NULL ) // global variable g_pRoot
// {
//    InitRoot();
//    OACR_ASSUME( NULL != g_pRoot ); 
// }
// g_pRoot->Traverse();    // without OACR_ASSUME this would cause warning 11
#if( OACR )
#define OACR_ASSUME( fCondition ) __assume( fCondition )

#elif defined(Assert)
#define OACR_ASSUME( fCondition ) Assert( fCondition )

#else
#define OACR_ASSUME( fCondition ) __oacr_noop

#endif

// macro to tell OACR that a string is null terminated at this point of execution
#if( OACR && defined( _Post_z_ ) )
__extern_c void __OACRAssumeNullterminated( _Post_z_ const char* sz );
#define OACR_ASSUME_NULLTERMINATED( string ) __OACRAssumeNullterminated( (const char*)string )

#else
#define OACR_ASSUME_NULLTERMINATED( string ) __oacr_noop

#endif

// macro to tell OACR that a pointer is null valid at this point of execution
#if( OACR && defined( _Post_valid_ ) )
__extern_c void __OACRAssumeValid( _Post_valid_ const void* pv );
#define OACR_ASSUME_VALID( ptr ) __OACRAssumeValid( ptr )

#else
#define OACR_ASSUME_VALID( ptr ) __oacr_noop

#endif


// macro to tell OACR that a buffer has a certain readable extent at this point of execution
// it can be used to silent noisy espX INCORRECT_ANNOTATION warnings
#if( OACR && defined( _Post_bytecount_ ) )
__extern_c void __OACRAssumeByteCount( _Post_bytecount_(cb) const void* pv, size_t cb );
#define OACR_ASSUME_BYTECOUNT( pv, cb ) __OACRAssumeByteCount( pv, cb )

#else
#define OACR_ASSUME_BYTECOUNT( pv, cb ) __oacr_noop

#endif


// new intrinsinc functions in Whidbey compiler
#if( _PREFAST2_ )
__extern_c void* _AddressOfReturnAddress();
#endif

// OACR custom plugin specific extensions

//=======================================================================

#define _Callback_                         __oacr_callback

#undef __override
#define __override                         __oacr_override

//======================================================================
// OACR custom attributes

// OACR custom plugin specific extensions

#if( _USE_ATTRIBUTES_FOR_SAL )

#pragma push_macro( "SA" )
#pragma push_macro( "REPEATABLE" )

#ifdef __cplusplus
#define SA( id ) id
#define REPEATABLE [repeatable]
#else  // !__cplusplus
#define SA( id ) SA_##id
#define REPEATABLE
#endif  // !__cplusplus

enum OACRFunctionFlag
{
   eOACRCallback          = 0x0001,
   eOACRRpc               = 0x0002,
   eOACROverride          = 0x0004,
   eOACRSealed            = 0x0008,
   eOACRMemberInitializer = 0x0010,
   eOACRUnsafeStringApi   = 0x0020,
   eOACRNeedsReview       = 0x0040,
   eOACRIntlDeprecated    = 0x0080,
   eOACRNoInferrence      = 0x0100,
   //eOACRMinFunction     = 0x0200,
   //eOACRMaxFunction     = 0x0400,
   //eOACRCompilerGen     = 0x0800,
   eOACRCanThrow          = 0x1000,
   eOACRBindReturn        = 0x2000,
};

REPEATABLE
[source_annotation_attribute( SA( Method ) )]
struct OACRFunctionFlagsAttribute
{
#ifdef __cplusplus
	OACRFunctionFlagsAttribute();
#endif
	int Flags;
};

enum OACRFunctionProp
{
   eOACRDeprecated     = 0,
   eOACROleoDeprecated = 1,
};

typedef enum OACRFunctionProp OACRFunctionProp;

#pragma warning( push )
#pragma warning( disable:4820 )
REPEATABLE
[source_annotation_attribute( SA( Method ) )]
struct OACRFunctionPropAttribute
{
#ifdef __cplusplus
	OACRFunctionPropAttribute();
#endif
	OACRFunctionProp Type;
   const char*      SzVal;
};
#pragma warning( pop )

#pragma pop_macro( "REPEATABLE" )
#pragma pop_macro( "SA" )

typedef struct OACRFunctionFlagsAttribute SA_OACRFunctionFlags;
typedef struct OACRFunctionPropAttribute  SA_OACRFunctionProp;

//--------------------------------------------------

#ifdef _PREFAST_
// use __declspecs until Whidbey-PREfast bug VS:479840 is fixed
#define __oacr_callback          __declspec("_Callback_")
#define __oacr_override          __declspec("_Override_")
#else  // _PREFAST_
#define __oacr_callback
#define __oacr_override
#endif  // _PREFAST_
//#define __oacr_callback          [method:SA_OACRFunctionFlags(Flags=eOACRCallback         )]
//#define __oacr_override          [method:SA_OACRFunctionFlags(Flags=eOACROverride         )]
#define __oacr_rpc               [method:SA_OACRFunctionFlags(Flags=eOACRRpc)]
#define __oacr_sealed_method     [method:SA_OACRFunctionFlags(Flags=eOACRSealed)]
#define __oacr_memberinitializer [method:SA_OACRFunctionFlags(Flags=eOACRMemberInitializer)]
#define __oacr_unsafe_string_api [method:SA_OACRFunctionFlags(Flags=eOACRUnsafeStringApi)]
#define __oacr_needsreview       [method:SA_OACRFunctionFlags(Flags=eOACRNeedsReview)]
#define __oacr_intl_deprecated   [method:SA_OACRFunctionFlags(Flags=eOACRIntlDeprecated)]
#define __oacr_noinference       [method:SA_OACRFunctionFlags(Flags=eOACRNoInferrence)]
#define __oacr_canthrow          [method:SA_OACRFunctionFlags(Flags=eOACRCanThrow)]
#define __oacr_bindReturn        [method:SA_OACRFunctionFlags(Flags=eOACRBindReturn)]

#define __oacr_sa_deprecated( NewFunctionName )   [method:SA_OACRFunctionProp(Type=eOACRDeprecated,    SzVal=#NewFunctionName)]
#define __oacr_oleo_deprecated( NewFunctionName ) [method:SA_OACRFunctionProp(Type=eOACROleoDeprecated,SzVal=#NewFunctionName)]

#ifdef _PREFAST_
#define __oacr_genericfunctype  __declspec("_Genericfunctype_")
#define __oacr_nothrowfunctype  __declspec("_Nothrowfunctype_")
#define __oacr_noheap           __declspec("_Noheap_" )
#define __oacr_notrunccast      __declspec("_Notrunccast_" )
#define __oacr_sealed_class     __declspec("_Sealed_")
__extern_c int __RequireNoThrow();
#define __oacr_requireNoThrow __RequireNoThrow();
#else  // _PREFAST_
#define __oacr_genericfunctype
#define __oacr_nothrowfunctype
#define __oacr_noheap
#define __oacr_notrunccast
#define __oacr_sealed_class
#define __oacr_requireNoThrow
#endif  // _PREFAST_

#elif( _USE_DECLSPECS_FOR_SAL )

#define __oacr_callback                         __declspec("_Callback_")
#define __oacr_override                         __declspec("_Override_")
#define __oacr_rpc                              __declspec("_Rpc_")
#define __oacr_sealed_method                    __declspec("_Sealed_")
#define __oacr_memberinitializer                __declspec("_Memberinitializer_")
#define __oacr_unsafe_string_api                __declspec("_Unsafe_string_api_")
#define __oacr_needsreview                      __declspec("_Needsreview_")
#define __oacr_intl_deprecated                  __declspec("_Intl_deprecated_")
#define __oacr_noinference                      __declspec("_Noinference_")
#define __oacr_canthrow                         __declspec("_Canthrow_")
#define __oacr_bindReturn                       __declspec("_BindReturn_")
#define __oacr_sa_deprecated(NewFunctionName)   __declspec("_SA_deprecated_("SPECSTRINGIZE(NewFunctionName)")")
#define __oacr_oleo_deprecated(NewFunctionName) __declspec("_Oleo_deprecated_("SPECSTRINGIZE(NewFunctionName)")")
#define __oacr_genericfunctype                  __declspec("_Genericfunctype_")
#define __oacr_nothrowfunctype                  __declspec("__nothrowfunctype") // TODO: change to _Nothrowfunctype_
#define __oacr_noheap                           __declspec("_Noheap_")
#define __oacr_notrunccast                      __declspec("_Notrunccast_")
#define __oacr_sealed_class                     __declspec("_Sealed_")
__extern_c int __RequireNoThrow();
#define __oacr_requireNoThrow __RequireNoThrow();

#else // neither [attributes] not __declspecs

#define __oacr_callback
#define __oacr_override
#define __oacr_rpc
#define __oacr_sealed_method
#define __oacr_memberinitializer
#define __oacr_unsafe_string_api
#define __oacr_needsreview
#define __oacr_intl_deprecated
#define __oacr_noinference
#define __oacr_canthrow
#define __oacr_bindReturn
#define __oacr_sa_deprecated(NewFunctionName)
#define __oacr_oleo_deprecated(NewFunctionName)
#define __oacr_genericfunctype
#define __oacr_nothrowfunctype
#define __oacr_noheap
#define __oacr_notrunccast
#define __oacr_sealed_class
#define __oacr_requireNoThrow

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\OACR\3.5.30319\amd64\etc\esp\SqlEye.Native.Annotations.h ===
#if !defined(__midl) && defined(_PREFAST_)

// Data Sink (a parameter scontaining a sql command or connection string to be executed by the API)
//
#define __sql_command  __declspec("SAL_SqlCommand")

#define __sql_connection_string __declspec("SAL_SqlConnectionString")

#define __sql_command_fragment  __declspec("SAL_SqlCommand")

#define __sql_connection_string_fragment __declspec("SAL_SqlConnectionString")

// Data Source (parameter or return value that may contain untrusted data upon return of the API)
//
// Example 1: __sql_untrusted CHAR* GetRegistryValue(CHAR* key)
// Example 2: void GetRegistryValue(CHAR* key, __sqluntrusted __out_ecount_z(cchValue) CHAR* value, size_t cchValue)
//
#define __sql_untrusted  __declspec("SAL_SqlUnTrusted")

// Escaped annotations

// Escaped '
//
#define __sql_escaped_single_quote __declspec("SAL_SqlEscaped")

// Escaped "
//
#define __sql_escaped_double_quote __declspec("SAL_SqlEscaped")

// Escaped ]
//
#define __sql_escaped_right_bracket __declspec("SAL_SqlEscaped")

// Currently escaped-and-delimited annotations expand to the same as __sql_command,
// since the requirement we currently check is that all inputs to such variable
// be escaped and delimited.
//

// Escaped and delimited '
//
#define __sql_escaped_and_delimited_single_quote __declspec("SAL_SqlCommand")

// Escaped and delimited "
//
#define __sql_escaped_and_delimited_double_quote __declspec("SAL_SqlCommand")

// Escaped and delimited ]
//
#define __sql_escaped_and_delimited_right_bracket __declspec("SAL_SqlCommand")

// Trusted: A parameter for which we know safe values are passed at all call sites. 
// One should always avoid using this one, as this annotation results in no checking at the call site.
// Instead use __sql_command, __sql_escaped_* or __sql_escaped_and_delimited_* annotations,
// This is only provided in case of an unmanageable amount of noise occuring due to a large number
// of known-safe callsites.
//
#define __sql_trusted  __declspec("SAL_SqlTrusted")

#else

#define __sql_command 
#define __sql_connection_string  
#define __sql_command_fragment
#define __sql_connection_string_fragment  

#define __sql_untrusted

#define __sql_escaped_single_quote
#define __sql_escaped_double_quote
#define __sql_escaped_right_bracket

#define __sql_escaped_and_delimited_single_quote
#define __sql_escaped_and_delimited_double_quote
#define __sql_escaped_and_delimited_right_bracket

#define __sql_trusted

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\OACR\3.5.30319\amd64\inc\oacrdll.h ===
#pragma once
/*****************************************************************************

   Module  : OACRDll
   Owner   : MarcK

   Copyright (c) Microsoft Corporation. All rights reserved.

******************************************************************************

  APIs exported by oacr.dll.
  
  oacr.dll is part of the Microsoft Auto Code Review (OACR) system. 
  It provides the same functionality as oacr.exe. It is intended for build
  integration from build environments using their own executable.

*****************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif

// Typedefs for dynamic loading via LoadLibrary and GetProcAddress
typedef int (__stdcall* OACRCMDWPROC)( const wchar_t* );
typedef int (__stdcall* OACRCMDAPROC)( const char* );


// Run an OACR command. Same command line syntax as the oacr.exe command line tool.
int __stdcall OACRCmdW( const wchar_t* wzCmd );
int __stdcall OACRCmdA( const char* szCmd );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\OACR\3.5.30319\amd64\inc\oacrhook.h ===
#pragma once
/*****************************************************************************

   Module  : OACRHook
   Owner   : MarcK

   Copyright (c) Microsoft Corporation. All rights reserved.

******************************************************************************

  Part of the Microsoft Auto Code Review (OACR) system.
  
  OACR supports hooking into the calls to build tools (cl.exe, link.exe, etc.),
  in order to perform custom operations as part of the build. The user can 
  provide a DLL, which is then loaded and called by OACR at the appropriate
  time. This header file declares the callback function that needs to be
  implemented by the DLL.

*****************************************************************************/

#ifdef __cplusplus

// Callback to process build tool output (stdout,stderr) line by line.
// 'pClientData' is the client data passed to FReadStdOutFile() or FReadStdErrFile().
// Must return true to get next line, or false to abort reading.
typedef bool ( __stdcall *PFNFPROCESSLINE )( const WCHAR* wzLine, void* pClientData );


// The interface passed with each notification.
interface IBuildToolRunInfo
{
   // NOTE: All APIs returning a string, return the number of characters
   //       copied to the output string (not including the NULL termination). 
   //       If the string to be returned is too long, it is truncated, and
   //       the buffer size is returned.
   //       If 0 is passed for the buffer size, the minimum required buffer
   //       size (including the NULL termination) is returned.
   //       In the error case, 0 is returned.

   // Build tools that can be hooked into
   enum Tool
   {
      NONE = 0,

      CL,   // C/C++ compiler (cl.exe)
      CSC,  // C# compiler (csc.exe)
      LINK, // Linker (link.exe)
      LIB,  // Library manager (lib.exe)
      MIDL, // MIDL compiler (midl.exe)
   };

   // Notifications sent
   enum Notification
   {
      BEFORE_RUN,   // Sent before the build tool is called
      AFTER_RUN,    // Sent after the build tools has been run
      AFTER_RETRY,  // Sent after a retry of a build tool run
   };

   //-------------------------------------------------------------------------
   // Client data
   //
   // Can be used to maintain state between notifications for the same build
   // tool run.
   //-------------------------------------------------------------------------

   virtual void  SetClientData( void* pData ) = 0;
   virtual void* GetClientData() const = 0;

   //-------------------------------------------------------------------------
   // Retrieve information - Any notification
   //-------------------------------------------------------------------------

   // Return the current notification.
   virtual Notification GetNotification() const = 0;

   // Return the build tool that triggered the notification.
   virtual Tool GetTool() const = 0;

   // Return the name of the OACR project under which the build tool has been called.
   virtual DWORD GetOACRProjectName( WCHAR* wzProjectName, DWORD cchProjectName ) const = 0;

   // Return the command line, as passed to the build tool.
   virtual DWORD GetCommandLine( WCHAR* wzCommandLine, DWORD cchCommandLine ) const = 0;

   // Return the fully expanded command line. Reponse files (e.g. '@c:\temp\foo.tmp'),
   // and environment variables (e.g. %CL%) are folded into the command line.
   virtual DWORD GetExpandedCommandLine( WCHAR* wzCommandLine, DWORD cchCommandLine ) const = 0;

   // Return the full path name of the build tool executable.
   virtual DWORD GetToolFileName( WCHAR* wzFileName, DWORD cchFileName ) const = 0;

   // Return the full path name of the primary output file generated by the build tool run.
   //    CL  : .obj file
   //    CSC : .exe or .dll (specified in the first /out switch)
   //    LINK: .exe or .dll
   //    LIB : .lib
   //    MIDL: .h file
   // The call fails for CL with multiple source files (batch runs). Use the batch run
   // APIs to get information about batch runs.
   virtual DWORD GetOutputFileName( WCHAR* wzFileName, DWORD cchFileName ) const = 0;

   //
   // Batch run info (CL only)
   //

   // Return true for a batch CL run (i.e. multiple source files)
   virtual bool FBatchRun() const = 0;

   // Return the number of source files in the batch run. Returns 0, for non batch runs.
   virtual DWORD CBatchItems() const = 0;

   // Return the full path name of the output file (.obj) for the source file with the
   // specified index. Returns 0 for non batch runs.
   virtual DWORD GetBatchItemOutputFileName( DWORD whichItem, WCHAR* wzFileName, DWORD cchFileName ) const = 0;

   //-------------------------------------------------------------------------
   // Retrieve information - Notifications 'AFTER_RUN' or 'AFTER_RETRY'
   //-------------------------------------------------------------------------

   // Return the result code for the build tool run.
   virtual int GetResult() const = 0;

   // Return the full path name of the file to which stdout output of the build tool run
   // has been redirected. Returns 0, if stdout redirection is turned off.
   virtual DWORD GetStdOutFileName( WCHAR* wzFileName, DWORD cchFileName ) const = 0;

   // Return the full path name of the file to which stderr output of the build tool run
   // has been redirected. Returns 0, if stderr redirection is turned off.
   virtual DWORD GetStdErrFileName( WCHAR* wzFileName, DWORD cchFileName ) const = 0;

   // Read the redirected stdout output of the build tool run, and send it to the specified
   // callback line by line. Noop, if stdout redirection is turned off.
   virtual bool FReadStdOutFile( PFNFPROCESSLINE pfnFProcessLine, void* pClientData = NULL ) const = 0;

   // Read the redirected stderr output of the build tool run, and send it to the specified
   // callback line by line. Noop, if stderr redirection is turned off.
   virtual bool FReadStdErrFile( PFNFPROCESSLINE pfnFProcessLine, void* pClientData = NULL ) const = 0;

   //
   // Batch run info (CL only)
   //

   // Return true, if the source file with the specified index was compiled successfully.
   // Returns fals for non batch runs.
   virtual bool FBatchItemSuccess( DWORD whichItem ) const = 0;

   //-------------------------------------------------------------------------
   // Generate stdout & stderr output - Any notification
   //-------------------------------------------------------------------------

   // Write to stdout.
   virtual void WriteStdOut( const WCHAR* wzMessage ) const = 0;

   // Write to stderr.
   virtual void WriteStdErr( const WCHAR* wzMessage ) const = 0;

   // Write the content of the specified text file to stdout.
   virtual bool FWriteStdOutFromFile( const WCHAR* wzFileName ) const = 0;

   // Write the content of the specified text file to stderr.
   virtual bool FWriteStdErrFromFile( const WCHAR* wzFileName ) const = 0;

   //-------------------------------------------------------------------------
   // Modify tool run - Any notification
   //-------------------------------------------------------------------------

   // Enable or disable further notifications for this build tool run. 
   // Notifications are enabled by default.
   virtual void SetNotify( bool fNotify ) = 0;

   // Override the result code for the build tool run.
   virtual void SetResult( int result ) = 0;

   // Set the command line to be passed to the build tool.
   virtual void SetCommandLine( const WCHAR* wzCommandLine ) = 0;

   // Set the file name of the build tool executable to be called.
   virtual void SetToolFileName( const WCHAR* wzFileName ) = 0;

   // Enable or disable redirection of stdout output of the build tool run.
   // Redirection is disabled by default.
   virtual void SetCaptureStdOut( bool fCapture ) = 0;

   // Enable or disable redirection of stderr output of the build tool run.
   // Redirection is disabled by default.
   virtual void SetCaptureStdErr( bool fCapture ) = 0;

   //-------------------------------------------------------------------------
   // Modify tool run - Notification 'BEFORE_RUN'
   //-------------------------------------------------------------------------

   // Cancel the build tool run. Use the SetResult() API to set the result code.
   // This is a noop, if called during the AFTER_RUN or AFTER_RETRY notification.
   virtual void CancelRun() = 0;

   //-------------------------------------------------------------------------
   // Modify tool run - Notifications 'AFTER_RUN' or 'AFTER_RETRY'
   //-------------------------------------------------------------------------

   // Force a retry of the build tool run.
   // This is a noop, if called during the BEFORE_RUN notification.
   virtual void RetryRun() = 0;

}; // IBuildToolRunInfo


// The callback that is called by OACR.
// This method needs to be implemented in the user provided DLL, so that OACR 
// can call it through LoadLibrary()/GetProcAddress()
extern "C" _Callback_ void __stdcall OnBuildToolRun( _In_ IBuildToolRunInfo& toolRunInfo );

#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\OACR\3.5.30319\amd64\inc\oacr.h ===
#pragma once
/*****************************************************************************

   Module  : OACR
   Owner   : HannesR

******************************************************************************

   Definitions and #defines for OACR support

*****************************************************************************/

// SAL annotations are #defined in this file
#include <sal.h>
#include <specstrings.h>
//#include "oacrsal.h"
#include "pftwarnings.h"

// TODO: remove the _PREFAST2_ and _PREFAST8_ defines
#if( defined(_PREFAST_)&& _PREFAST_ )
#if( _MSC_VER < 1400 )
#define _PREFAST2_ 1
#else
#define _PREFAST8_ 1
#endif
#endif

// Support attribute annotations for regular foreground build to catch misplaced annotations
#undef OACR_FOREGROUND_ATTRIBUTES
#if !_USE_ATTRIBUTES_FOR_SAL && !_USE_DECLSPECS_FOR_SAL && defined(_MSC_EXTENSIONS) && !defined( MIDL_PASS ) && !defined(__midl) && !defined(RC_INVOKED) && defined(_PFT_VER) && _MSC_VER >= 1400 
#define OACR_FOREGROUND_ATTRIBUTES 1
#else
#define OACR_FOREGROUND_ATTRIBUTES 0
#endif

// Allow deprecated Pre Orcas style annotations by default
#if !defined(OACR_DEPRECATED)
#define OACR_DEPRECATED 1
#endif

#if !defined(ARM)
#define __oacr_noop __noop
#else
#define __oacr_noop
#endif

#if defined(__cplusplus)
#define __extern_c     extern "C"
#define __extern_cplus extern "C++"
#else
#define __extern_c
#define __extern_cplus
#endif

#define __noreturn __declspec( noreturn )

// size_t is used in some OACR macros
#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

#if !defined(_SIZE_T_DEFINED)
#if defined(_WIN64)
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif

// OACR keywords:
// annotations undertstood by PREfast plugins

#if !defined(_Sealed_method_)
// use _Sealed_method_ to specify C# style 'sealed' behavior for methods
#define _Sealed_method_ __oacr_sealed_method
#endif // _Sealed_method_


#if !defined(_Sealed_class_)
// use _Sealed_class_ to specify C# style 'sealed' behavior for classes
#define _Sealed_class_ __oacr_sealed_class
#endif // _Sealed_class_


#if !defined(_SA_deprecated_)
// use _SA_deprecated_ to mark functions that should not be called any more
// pass the replacement function as argument to the macro
#define _SA_deprecated_(NewFunctionName) __oacr_sa_deprecated(NewFunctionName)
#endif // _SA_deprecated_


#if !defined(_Intl_deprecated_)
// annotation used by warning UNMARKED_INTL_DEPRECATED_FUNCTION (25114)
// to mark deprecated functions using LCID parameters
// The annotation is used by Office to cleanup the use of LCIDs
#define _Intl_deprecated_ __oacr_intl_deprecated
#endif // _Intl_deprecated_


#if !defined(_Oleo_deprecated_)
// Office specifix annotation used by the OLEO effort
#define _Oleo_deprecated_( NewFunctionName ) __oacr_oleo_deprecated(NewFunctionName)
#endif // _Oleo_deprecated_


#if !defined(_Rpc_)
// use _Rpc_ for functions that used as remote procedure calls, the keyword will silence
// various OACR checks on formal parameters of the marked functions
#define _Rpc_ __oacr_rpc
#endif // _Rpc_


#if !defined(_RequireNoThrow_)
// use _RequireNoThrow_ inside a compound statement to indicate that the rest of the block
// should not emit exceptions.
#define _RequireNoThrow_ __oacr_requireNoThrow
#endif // _RequireNoThrow_


#if !defined(_Canthrow_)
// use _Canthrow_ for method declarations of template classes that have throwing and non-throwing
// specializations to suppress warning FUNC_COULD_BE_NOTHROW (25307).
#define _Canthrow_ __oacr_canthrow
#endif // __requireNoThrow


#if !defined(_Genericfunctype_)
// use _Genericfunctype_ for function typedefs used for arrays of functions of different function types.
// if the typedef is marked as _Genericfunctype_, OACR will not generate DIFFERENT_CALLING_CONVENTION (25018) warnings
// e.g. typedef _Genericfunctype_ void (*FUNCPTR)();
#if( defined(OACR) && OACR )
#define _Genericfunctype_ __oacr_genericfunctype
#else
#define _Genericfunctype_
#endif
#endif // _Genericfunctype_


#if !defined(_Nothrowfunctype_)
// use _Nothrowfunctype_ for function typedefs of non exception throwing function pointers
// e.g. typedef _Nothrowfunctype_ void (*FUNCPTR)();
// only assign non throwing functions to typedefs so marked
#define _Nothrowfunctype_ __oacr_nothrowfunctype
#endif // _Nothrowfunctype_


#if !defined(_BindReturn_)
// stronger than __checkReturn, typically used by functions that return
// a pointer to an allocated object
// e.g _BindReturn_ void* malloc( size_t size );
// void Bar()
// {
//    void* pv;
//    if( ( pv == malloc( 20 ) ) == NULL )      <<<< typo !!
//    ...
// }
#define _BindReturn_ __oacr_bindReturn
#endif // _BindReturn_


#if !defined(_Memberinitializer_)
// use _Memberinitializer_ for init functions that initialize all members of a class
// e.g.:
// class X
// {
//    int m_i:
//    int m_j:
//    _Memberinitializer_ void Init(){ m_i = m_j = 0; }
// public:
//    X(){ Init(); }
// };
#define _Memberinitializer_ __oacr_memberinitializer
#endif // _Memberinitializer_


#if !defined(_Noheap_)
// use _Noheap_ classes that should not be instantiated on the heap
// e.g.:
// _Noheap_ class CriticalSection
// {
// public:
//    CriticalSection();
//    ~CriticalSection();
// };
#define _Noheap_ __oacr_noheap
#endif // _Noheap_


#if !defined(_Unsafe_string_api_)
// use _Unsafe_string_api_ to phase out functions that pass unbound writable buffers
// e.g.
// _Unsafe_string_api_ void MyStrCpy( char* szTo, const char* szFrom );
#define _Unsafe_string_api_ __oacr_unsafe_string_api
#endif // _Unsafe_string_api_


#if !defined(_Needsreview_)
// use _Needsreview_ to mark functions whose calls need to be reviewed for a
// special reason.
// e.g. a wrapper function to another function that needs to be reviewed
//_Needsreview_ __inline BOOL MsoGetStringTypeExW(LCID Locale, DWORD dwInfoType, LPCWSTR lpSrcStr, int cchSrc, LPWORD lpCharType)
//{
//   return OACR_REVIEWED_CALL("hannesr", GetStringTypeExW(Locale, dwInfoType, lpSrcStr, cchSrc, lpCharType));
//}
// use the OACR_REVIEWED_CALL macro to silent the warning after making sure that the function is used properly
#define _Needsreview_ __oacr_needsreview
#endif // _Needsreview_


#if !defined(_Notrunccast_)
// use _Notrunccast_ to find unsafe truncating cast on allocating functions taking
// a 16 bit size parameter
// e.g.
// void* MyMalloc( _Notrunccast_ ushort size );
#define _Notrunccast_ __oacr_notrunccast
#endif // _Notrunccast_


#if !defined(_Noinference_)
// keyword to disable (wrong) Hungarian inference of __count annotations
// inference is disabled for the all formals of the function
// e.g. _Noinference_ void FreePv( void* pv, size_t cb );
#define _Noinference_     __oacr_noinference
#endif // _Noinference_


// Pre Orcas style annotations are deprecated
#if( OACR_DEPRECATED )

#if !defined(__sealed_method)
#define __sealed_method                      _Sealed_method_
#endif
#if !defined(__sealed_class)
#define __sealed_class                       _Sealed_class_
#endif
#if !defined(__sa_deprecated)
#define __sa_deprecated(NewFunctionName)     _SA_deprecated_(NewFunctionName)
#endif
#if !defined(__intl_deprecated)
#define __intl_deprecated                    _Intl_deprecated_
#endif
#if !defined(__oleo_deprecated)
#define __oleo_deprecated( NewFunctionName ) _Oleo_deprecated_(NewFunctionName)
#endif
#if !defined(__rpc)
#define __rpc                                _Rpc_
#endif
#if !defined(__requireNoThrow)
#define __requireNoThrow                     _RequireNoThrow_
#endif
#if !defined(__canthrow)
#define __canthrow                           _Canthrow_
#endif
#if !defined(__genericfunctype)
#define __genericfunctype                    _Genericfunctype_
#endif
#if !defined(__nothrowfunctype)
#define __nothrowfunctype                    _Nothrowfunctype_
#endif
#if !defined(__bindReturn)
#define __bindReturn                         _BindReturn_
#endif
#if !defined(__memberinitializer)
#define __memberinitializer                  _Memberinitializer_
#endif
#if !defined(__noheap)
#define __noheap                             _Noheap_
#endif
#if !defined(__nostack)
#define __nostack                            // not supported
#endif
#if !defined(__unsafe_string_api)
#define __unsafe_string_api                  _Unsafe_string_api_
#endif
#if !defined(__needsreview)
#define __needsreview                        _Needsreview_
#endif
#if !defined(__notrunccast)
#define __notrunccast                        _Notrunccast_
#endif
#if !defined(__noinference)
#define __noinference                        _Noinference_
#endif
#if !defined(__min_function)
#define __min_function                       // deprecated, use range annotations
#endif
#if !defined(__max_function)
#define __max_function                       // deprecated, use range annotations
#endif
#if !defined(__printf_format_string)
#define __printf_format_string               _Printf_format_string_
#endif

#undef __callback
#define __callback                           _Callback_

#if !defined(__sa_sealed) // use __sealed_method and __sealed_class instead
#if( defined(OACR) && OACR )
#define __sa_sealed __declspec("_Sealed_")
#else
#define __sa_sealed
#endif
#endif // __sa_sealed

#endif // OACR_DEPRECATED

//-----------------

// OACR helper macros to suppress particular warnings

#if !defined(OACR_USE_PTR)
// use to suppress constness and related warnings:
// NONCONST_LOCAL (25003), NONCONST_PARAM( 25004), NONCONST_FUNCTION (25005), 
// NONCONST_LOCAL_BUFFERPTR (25032), NONCONST_BUFFER_PARAM (25033)
#if( defined(OACR) && OACR )
__extern_c void OACRUsePtr( void* p );
#define OACR_USE_PTR( p ) OACRUsePtr( p )
#else
#define OACR_USE_PTR( p ) __oacr_noop
#endif
#endif // OACR_USE_PTR

#if !defined(OACR_MEMBER_IS_INITIALIZED_IN_CTOR)
// Use to suppress warning UNINITIALIZED_DATAMEMBER (25070) (as issued from a _Memberinitializer_)
// for data members which are correctly initialized in the ctor.
// (Warning 25070 cannot automatically handle member initialization that
// is spread across both ctor initializer list and a _Memberinitializer_ method).
// NOTES: This is functionally to OACR_USE_PTR(&m).
//        Contrast with OACR_MEMBER_IS_INITIALIZED_IN_MEMBERINITIALIZER.
#define OACR_MEMBER_IS_INITIALIZED_IN_CTOR( m ) OACR_USE_PTR( &m )
#endif // OACR_MEMBER_IS_INITIALIZED_IN_CTOR

#if !defined(OACR_MEMBER_IS_INITIALIZED_IN_MEMBERINITIALIZER)
// Use to suppress warning UNINITIALIZED_DATAMEMBER (25070) (as issued from a ctor)
// for data members which are correctly initialized in the _Memberinitializer_ method.
// (Warning 25070 cannot automatically handle member initialization that
// is spread across both ctor initializer list and a _Memberinitializer_ method).
// NOTES: This is functionally equivalent to OACR_USE_PTR(&m).
//        Contrast with OACR_MEMBER_IS_INITIALIZED_IN_CTOR.
#define OACR_MEMBER_IS_INITIALIZED_IN_MEMBERINITIALIZER( m ) OACR_USE_PTR( &m )
#endif // OACR_MEMBER_IS_INITIALIZED_IN_MEMBERINITIALIZER

#if !defined(OACR_POSSIBLE_THROW)
// use to suppress __nothrow related warnings NOTHROW_FUNC_THROWS (25306) and FUNC_COULD_BE_NOTHROW (25307)
#if( defined(OACR) && OACR )
__extern_cplus void OACRPossibleThrow();
#define OACR_POSSIBLE_THROW OACRPossibleThrow()
#else
#define OACR_POSSIBLE_THROW __oacr_noop
#endif
#endif // OACR_POSSIBLE_THROW

#if !defined(OACR_ASSUME_NOTHROW_BEGIN)
// use with OACR_ASSUME_NOTHROW_END to suppress NOTHROW_FUNC_THROWS warnings around functions that don't throw in this context
// macro pair needs to be on the same scope
#if( defined(OACR) && OACR )
#define OACR_ASSUME_NOTHROW_BEGIN try{
#define OACR_ASSUME_NOTHROW_END }catch(...){}
#else
#define OACR_ASSUME_NOTHROW_BEGIN
#define OACR_ASSUME_NOTHROW_END
#endif
#endif // OACR_POSSIBLE_THROW

#if !defined(UNREFERENCED_OACR)
// use to function staticness and related warnings: STATIC_FUNCTION (25007)
#if( defined(OACR) && OACR )
#define UNREFERENCED_OACR( p ) __assume( p == p )
#else
#define UNREFERENCED_OACR( p )
#endif
#endif // UNREFERENCED_OACR


#if !defined(OACR_OWN_PTR)
// can be used for objects that attach themselves to an owner
// in their constructors
#if( defined(OACR) && OACR )
__extern_c void OACROwnPtr( const void* p );
#define OACR_OWN_PTR( p ) OACROwnPtr( p )
#else
#define OACR_OWN_PTR( p ) __oacr_noop
#endif
#endif // OACR_OWN_PTR


#if !defined(OACR_PTR_NOT_NULL)
// tells OACR that a pointer is not null at this point
#if( defined(OACR) && OACR )
#define OACR_PTR_NOT_NULL( p ) OACR_ASSUME( 0 != p )
#else
#define OACR_PTR_NOT_NULL( p ) __oacr_noop
#endif
#endif // OACR_PTR_NOT_NULL


#if !defined(OACR_NOT_IMPLEMENTED_MEMBER)
#if( defined(OACR) && OACR )
#define OACR_NOT_IMPLEMENTED_MEMBER OACR_USE_PTR( (void*)this )
#else
#define OACR_NOT_IMPLEMENTED_MEMBER
#endif
#endif // OACR_NOT_IMPLEMENTED_MEMBER


#if !defined(OACR_DECLARE_FILLER)
#if( defined(OACR) && OACR )
#define OACR_DECLARE_FILLER( type, inst ) type __filler##inst;
#else
#define OACR_DECLARE_FILLER( type, inst )
#endif
#endif // OACR_DECLARE_FILLER


// use this macro once you have inspected warnings FUNCTION_NEEDS_REVIEW (25028)
#if !defined(OACR_REVIEWED_CALL)
#if( defined(OACR) && OACR )
__extern_c void __OACRReviewedCall();
#define OACR_REVIEWED_CALL( reviewer, functionCall ) ( __OACRReviewedCall(), functionCall )
#else
#define OACR_REVIEWED_CALL( reviewer, functionCall ) functionCall
#endif
#endif // OACR_REVIEWED_CALL


// use this macro once you have inspected warnings URL_NEEDS_TO_BE_REVIEWED (25085)
#if !defined(OACR_REVIEWED_URL)
#if( defined(OACR) && OACR )
__extern_c void __OACRReviewedUrl();
#define OACR_REVIEWED_URL( reviewer, reviewedUrl ) ( __OACRReviewedUrl(), reviewedUrl )
#else
#define OACR_REVIEWED_URL( reviewer, reviewedUrl ) reviewedUrl
#endif
#endif // OACR_REVIEWED_URL

#if !defined(OACR_DONT_SWAP)
// use to suppress warnings MISSING_MEMBER_SWAP (25146) for nonswappable data members like refcounts, critical sections, etc.
#if( defined(OACR) && OACR )
__extern_c void OACRDontSwap( void* p );
#define OACR_DONT_SWAP( m ) OACRDontSwap( &( m ) )
#else
#define OACR_DONT_SWAP( m ) __oacr_noop
#endif
#endif // OACR_DONT_SWAP

#if( defined(OACR) && OACR && defined(_WINDEF_) && 0 )

// redefine FALSE & TRUE for better HRESULT<->BOOL conversion detection
#if defined(FALSE)
#undef FALSE
#define FALSE ((BOOL)0)
#endif

#if defined(TRUE)
#undef TRUE
#define TRUE ((BOOL)1)
#endif

#endif

// Use the following macros to suppress and disable OACR warnings in the code
// Using the macros allows us to have the same source code being compiled with
// PREfast 2.x and Whidbey PREfast

// macro to tell OACR to not issue a specific warning for the following line of code
// use to suppress false positives from OACR
// e.g.
// if( fPointerNotNull )
//    OACR_WARNING_SUPRESS( DEREF_NULL_PTR, "pointer access is guarded by 'fPointerNotNull'" )
//    p->Foo();

#if !defined(OACR_WARNING_PUSH)
#if( defined(OACR) && OACR && !defined(OACR_NO_WARNING_MACROS) )
#if( 1400 <=_MSC_VER )
#define OACR_WARNING_PUSH __pragma ( warning( push ) )
#else
#define OACR_WARNING_PUSH __pragma ( prefast( push ) )
#endif
#else
#define OACR_WARNING_PUSH
#endif
#endif

#if !defined(OACR_WARNING_POP)
#if( defined(OACR) && OACR && !defined(OACR_NO_WARNING_MACROS) )
#if( 1400 <=_MSC_VER )
#define OACR_WARNING_POP __pragma ( warning( pop ) )
#else
#define OACR_WARNING_POP __pragma ( prefast( pop ) )
#endif
#else
#define OACR_WARNING_POP
#endif
#endif

#if !defined(OACR_WARNING_ENABLE)
#if( defined(OACR) && OACR && !defined(OACR_NO_WARNING_MACROS) )
#if( 1400 <=_MSC_VER )
#define OACR_WARNING_ENABLE( cWarning, comment ) __pragma ( warning( enable: __WARNING_##cWarning ) )
#else
#define OACR_WARNING_ENABLE( cWarning, comment )
#endif
#else
#define OACR_WARNING_ENABLE( cWarning, comment )
#endif
#endif

#if !defined(OACR_WARNING_DISABLE)
#if( defined(OACR) && OACR && !defined(OACR_NO_WARNING_MACROS) )
#if( 1400 <=_MSC_VER )
#define OACR_WARNING_DISABLE( cWarning, comment ) __pragma ( warning( disable: __WARNING_##cWarning ) )
#else
#define OACR_WARNING_DISABLE( cWarning, comment ) __pragma ( prefast( disable: __WARNING_##cWarning, comment ) )
#endif
#else
#define OACR_WARNING_DISABLE( cWarning, comment )
#endif
#endif

#if !defined(OACR_WARNING_SUPPRESS)
#if( defined(OACR) && OACR && !defined(OACR_NO_WARNING_MACROS) )
#if( 1400 <=_MSC_VER )
#define OACR_WARNING_SUPPRESS( cWarning, comment ) __pragma ( warning( suppress: __WARNING_##cWarning ) )
#else
#define OACR_WARNING_SUPPRESS( cWarning, comment ) __pragma ( prefast( suppress: __WARNING_##cWarning, comment) )
#endif
#else
#define OACR_WARNING_SUPPRESS( cWarning, comment )
#endif
#endif

// macro to tell OACR about conditions that are true.
// Use OACR_ASSUME instead of #pragma prefast(suppress,...) if possible
// e.g.:
// if( g_pRoot == NULL ) // global variable g_pRoot
// {
//    InitRoot();
//    OACR_ASSUME( NULL != g_pRoot ); 
// }
// g_pRoot->Traverse();    // without OACR_ASSUME this would cause warning 11
#if( defined(OACR) && OACR )
#define OACR_ASSUME( fCondition ) __assume( fCondition )

#elif defined(Assert)
#define OACR_ASSUME( fCondition ) Assert( fCondition )

#else
#define OACR_ASSUME( fCondition ) __oacr_noop

#endif

// macro to tell OACR that a string is null terminated at this point of execution
#if( defined(OACR) && OACR && defined(_Post_z_) )
__extern_c void __OACRAssumeNullterminated( _Post_z_ const char* sz );
#define OACR_ASSUME_NULLTERMINATED( string ) __OACRAssumeNullterminated( (const char*)string )

#else
#define OACR_ASSUME_NULLTERMINATED( string ) __oacr_noop

#endif

// macro to tell OACR that a pointer is null valid at this point of execution
#if( defined(OACR) && OACR && defined(_Post_valid_) )
__extern_c void __OACRAssumeValid( _Post_valid_ const void* pv );
#define OACR_ASSUME_VALID( ptr ) __OACRAssumeValid( ptr )

#else
#define OACR_ASSUME_VALID( ptr ) __oacr_noop

#endif


// macro