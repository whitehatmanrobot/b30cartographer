ar  szModulePath[ _MAX_PATH ];
};

struct FASTINDDATA
{
   DWORDLONG pidfhdr;
   DWORDLONG rgiblh;
   DWORDLONG negaddrbase;
   DWORDLONG pfnInd;
};

struct FASTINITINDIRECT
{
    DWORDLONG    pirtp; //const IRTP  *
    DWORDLONG    rgCounts; //DWORD *
    DWORDLONG    rgTobBytes; //BYTE *
    DWORDLONG    pfrtp;     //FASTRTPARAM *
    DWORDLONG    rgSeqNums; //DWORD *
    DWORDLONG    pFastInd;  //FASTINDDATA *
};


struct REGAXP
{
   DWORDLONG v0;                  // 0x00                                   $0
   DWORDLONG t0;                  // 0x08                                   $1
   DWORDLONG t1;                  // 0x10                                   $2
   DWORDLONG t2;                  // 0x18                                   $3
   DWORDLONG t3;                  // 0x20                                   $4
   DWORDLONG t4;                  // 0x28                                   $5
   DWORDLONG t5;                  // 0x30                                   $6
   DWORDLONG t6;                  // 0x38                                   $7
   DWORDLONG t7;                  // 0x40                                   $8
   DWORDLONG s0;                  // 0x48        Currently not used         $9
   DWORDLONG s1;                  // 0x50        Currently not used         $10
   DWORDLONG s2;                  // 0x58                                   $11
   DWORDLONG s3;                  // 0x60                                   $12
   DWORDLONG s4;                  // 0x68                                   $13
   DWORDLONG s5;                  // 0x70                                   $14
   DWORDLONG fp;                  // 0x78        Currently not used         $15
   DWORDLONG a0;                  // 0x80                                   $16
   DWORDLONG a1;                  // 0x88                                   $17
   DWORDLONG a2;                  // 0x90                                   $18
   DWORDLONG a3;                  // 0x98                                   $19
   DWORDLONG a4;                  // 0xA0                                   $20
   DWORDLONG a5;                  // 0xA8                                   $21
   DWORDLONG t8;                  // 0xB0                                   $22
   DWORDLONG t9;                  // 0xB8                                   $23
   DWORDLONG t10;                 // 0xC0                                   $24
   DWORDLONG t11;                 // 0xC8                                   $25
   DWORDLONG ra;                  // 0xD0                                   $26
   DWORDLONG t12;                 // 0xD8                                   $27
   DWORDLONG at;                  // 0xE0                                   $28

   DWORDLONG reserved;            // 0xE8
   DWORDLONG lr1;                 // 0xF0
   DWORDLONG arg;                 // 0xF8

   DWORDLONG f0;                  // 0x100
   DWORDLONG f1;                  // 0x108
   DWORDLONG f10;                 // 0x110
   DWORDLONG f11;                 // 0x118
   DWORDLONG f12;                 // 0x120
   DWORDLONG f13;                 // 0x128
   DWORDLONG f14;                 // 0x130
   DWORDLONG f15;                 // 0x138
   DWORDLONG f16;                 // 0x140
   DWORDLONG f17;                 // 0x148
   DWORDLONG f18;                 // 0x150
   DWORDLONG f19;                 // 0x158
   DWORDLONG f20;                 // 0x160
   DWORDLONG f21;                 // 0x168
   DWORDLONG f22;                 // 0x170
   DWORDLONG f23;                 // 0x178
   DWORDLONG f24;                 // 0x180
   DWORDLONG f25;                 // 0x188
   DWORDLONG f26;                 // 0x190
   DWORDLONG f27;                 // 0x198
   DWORDLONG f28;                 // 0x1a0
   DWORDLONG f29;                 // 0x1a8
   DWORDLONG f30;                 // 0x1b0

   DWORDLONG gp;                  //             Currently not saved        $29
   DWORDLONG sp;                  //             Currently not saved        $30
   DWORDLONG zr;                  //             Currently not saved        $31
};


struct REGMIPS
{
   DWORD reserved[4];         // 0x00, 16 byte preallocated argument build area

   DWORDLONG at;                  // 0x10,                                  $1
   DWORDLONG v0;                  // 0x18,                                  $2
   DWORDLONG v1;                  // 0x20,                                  $3
   DWORDLONG a0;                  // 0x28,                                  $4
   DWORDLONG a1;                  // 0x30,                                  $5
   DWORDLONG a2;                  // 0x38,                                  $6
   DWORDLONG a3;                  // 0x40,                                  $7
   DWORDLONG t0;                  // 0x48,                                  $8
   DWORDLONG t1;                  // 0x50,                                  $9
   DWORDLONG t2;                  // 0x58,                                  $10
   DWORDLONG t3;                  // 0x60,                                  $11
   DWORDLONG t4;                  // 0x68,                                  $12
   DWORDLONG t5;                  // 0x70,                                  $13
   DWORDLONG t6;                  // 0x78,                                  $14
   DWORDLONG t7;                  // 0x80,                                  $15
   DWORDLONG s0;                  // 0x88,                                  $16
   DWORDLONG s1;                  // 0x90,                                  $17
   DWORDLONG s2;                  // 0x98,                                  $18
   DWORDLONG s3;                  // 0xA0,                                  $19
   DWORDLONG s4;                  // 0xA8,                                  $20
   DWORDLONG s5;                  // 0xB0,                                  $21
   DWORDLONG t8;                  // 0xB8,                                  $24
   DWORDLONG t9;                  // 0xC0,                                  $25
   DWORDLONG ra;                  // 0xC8,                                  $31

   DWORDLONG rs1;                 // 0xD0     reserved1
   DWORDLONG rs2;                 // 0xD8     reserved2

                              //          k0 Not needed to save         $26
                              //          k1 Not needed to save         $27
                              //          gp Not needed to save         $29
                              //          sp Not needed to save         $30

};


struct REGMPPC
{
   DWORD reserved1[9];        // 0x00, Filler
   DWORD ibPatch;             // 0x24,          ib to instr code to be patched
   DWORD reserved2[22];       // 0x28, Filler

   DWORD ctr;                 // 0x80,          Offset to original CTR
   DWORD cr;                  // 0x84,          Offset to CR
   DWORD lr;                  // 0x88,          Offset to instrumentation site
   DWORD lr1;                 // 0x8C,          Offset to instr thunk site
   DWORD r0;                  // 0x90,
   DWORD r2;                  // 0x94,
   DWORD r3;                  // 0x98,
   DWORD r4;                  // 0x9C,
   DWORD r5;                  // 0xA0,
   DWORD r6;                  // 0xA4,
   DWORD r7;                  // 0xA8,
   DWORD r8;                  // 0xAC,
   DWORD r9;                  // 0xB0,
   DWORD r10;                 // 0xB4,
   DWORD r11;                 // 0xB8,
   DWORD r12;                 // 0xBC,

   DWORD arg;                 // 0xC0,
   DWORD pidfhdr;             // 0xC4,

   DWORD reserved3[14];       // 0xC8,
   DWORD r0Alias;             // 0x100,
};


struct REGPPC
{
   DWORD reserved[32];        // 0x00, Filler

   DWORD ctr;                 // 0x80,          Offset to original CTR
   DWORD cr;                  // 0x84,          Offset to CR
   DWORD lr;                  // 0x88,          Offset to instrumentation site
   DWORD lr1;                 // 0x8C,          Offset to instr thunk site
   DWORD r0;                  // 0x90,
   DWORD r2;                  // 0x94,
   DWORD r3;                  // 0x98,
   DWORD r4;                  // 0x9C,
   DWORD r5;                  // 0xA0,
   DWORD r6;                  // 0xA4,
   DWORD r7;                  // 0xA8,
   DWORD r8;                  // 0xAC,
   DWORD r9;                  // 0xB0,
   DWORD r10;                 // 0xB4,
   DWORD r11;                 // 0xB8,
   DWORD r12;                 // 0xBC,

   DWORD arg;                 // 0xC0,
   DWORD pidfhdr;             // 0xC4,
   DWORD pthd;                // 0xC8,
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xprof\idf.h ===
/***********************************************************************
* Microsoft BBT
*
* Microsoft Confidential.  Copyright (c) Microsoft Corporation.  All rights reserved.
*
* File Comments:
*
*
***********************************************************************/

#pragma once

#pragma pack(push, 4)

struct IDFHDR                          // Instrumentation Data File Header
{
   DWORD    dwSignature;               // ( 0) File signature
   DWORD    dwVersion;                 // ( 4)
   DWORD    dwId;                      // ( 8) Id of original image (.exe, .dll, .sys, ...)
   DWORD    ibszIdfKeyPath;            // ( C) Name of .IDFKEY file
   DWORD    dwGeneration;              // (10) Database generation
   DWORDLONG    qwStartTime;               // (14) Creation time of this data

   DWORD    tov;                       // (1C) Variety of time order instrumentation

   DWORD    cb;                        // (20) Size of valid data
   DWORD    cqwCount;                  // (24) Count of static edge counts
   DWORD    ibrgqwCount;               // (28) Offset to array of static edge count
   DWORD    ciblh;                     // (2C) Count of IBLHs
   DWORD    ibrgiblh;                  // (30) Offset to array of IBLHs
   DWORD    cible;                     // (34) Number of IBLE structs allocated
   DWORD    ctlhCode;                  // (38) Count of TLHs for code
   DWORD    ibrgtlhCode;               // (3C) Offset to array of TLHs for code
   DWORD    ctlhResource;              // (40) Count of TLHs for resources
   DWORD    ibrgtlhResource;           // (44) Offset to array of TLHs for resources
   DWORD    cthd;                      // (48) Count of THDs
   DWORD    ibthdHead;                 // (4C) Offset to first THD
   DWORD    cmsStartTime;              // (50) Tick count at initialization

   DWORD    ifunEndBoot;               // (54) Index of EndBoot function (from IRTP)
   DWORD    iSequenceEndBoot;          // (58) Seq number of the last boot time code or resource
   DWORD    iIntervalEndBoot;          // (5C) Last internal of boot sequence

   // The following data is used at runtime and appears here
   // so that it can be shared among multiple processes.

   DWORD    dwLock;                    // (60) Used to lock shared structures

   DWORD    cbAllocated;               // (64) Size of allocated (committed) memory
   DWORD    cbMax;                     // (68) Maximum size of memory region

   DWORD    cpsActive;                 // (6C) Count of processes using this data

   DWORD    fSweepPending;             // (70)
   DWORD    cthdActive;                // (74) Number of threads within runtime

   DWORD    cmsTimer;                  // (78) Timer interval in milliseconds
   DWORD    pidTimer;                  // (7C) Process ID of timer process or 0?
   DWORD    iIntervalCur;              // (80) Current time interval
   DWORD    cmsNextAttempt;            // (84)

   DWORD    iSequence;                 // (88) Sequence number of initial references
   DWORD    iIntervalStart;            // (8C) First valid time interval
   DWORD    iSequenceStart;            // (90) First valid sequence number

                                       // Runtime-only state for storage allocators

   DWORD    cbPermanentFree;           // (94) Base of permanent free page
   DWORD    cbPermanentLimit;          // (98) End of permanent free page
   DWORD    cbReclaimableFree;         // (9C) Base of reclaimable free page
   DWORD    cbReclaimableLimit;        // (A0) End of reclaimable free page
   DWORD    cbReclaimablePageHead;     // (A4) Head of linked list of reclaimable pages
   DWORD    cbReclaimablePageTail;     // (A8) Tail of linked list of reclaimable pages

                                       // Bitfields are implemented from LSB to MSB.
                                       // Since the position of LSB is different for little endian
                                       // and big endian processors, bit fields cannot be used for
                                       // IDF purposes. Instead, a series of chars are used instead.
   char     fBigEndian;                // (AC) Non-zero if collected data is big-endian
   char     fSweepable;                //      Non-zero if IDF is sweepable.
   char     fWinNTPerf;
   char     fFastRT;                   // Are we using the faster runtime?
   

   DWORDLONG hIdfFile;                 // (B0) HANDLE of open .IDF file

   DWORD    dwDynProbeCount;           // (B8) Number of TOB Probes to execute to increment time.
   DWORDLONG   pWinNTBufInterval;      // (BC) pinter to NT buffer timer interval.
   DWORD    ibineHead;                 
                                       
};

#pragma pack(pop)

#define szIrtMutexPrefix   "BBT30.Mtx."
#define szIrtFMutexPrefix  "BBT30.Ftx."
#define szIrtMemoryPrefix  "BBT30.Mem."
#define szIrtTimerApp      "bbtimr30"

#define wszIrtMutexPrefix  L"BBT30.Mtx."
#define wszIrtMemoryPrefix L"BBT30.Mem."
#define wszIrtTimerApp     L"bbtimr30"

#define szIdfIdTemplate    "%BBT_Idf_Id%"
#define szIdfKeyIdTemplate "%BBT_Key_Id%"
#define szIdfSuffix        ".idf"
#define szIdfKeySuffix     ".key"

#define dwIdfKeySignature       0xa97df1eb
#define dwIdfSignature          0x09040600
#define dwDIdfSignature         0x09040601
#define dwIdfVerCurrent         0x00001010  // This also much be changed in bbtirt.h

// Flag to indicate IDF originated with pogo runtime

#define dwIdfVerPogo            0x90000000


struct IBLH                            // Indirect Branch List Header
{
   DWORD    ibibleFirst;               // Offset to first IBLE
};


struct IBLE                            // Indirect Branch List Element
{
   DWORD    ibibleNext;                // Offset to next IBLE or 0
   DWORD    blkidSrc;
   DWORDLONG    qwCount;
};


#define cdwTob          4              // Keep 4 DWORDs for each TOB
#define cbitDw          32             // There are 32 bits in a DWORD

struct TOB                             // Time Order Bits
{
   DWORD    iInterval;                 // Time interval represented
   DWORD    rgdwBit[cdwTob];           // One bit for each time interval
};


struct TLH                             // Time List Header
{
   DWORD    ibtleFirst;                // Offset to first TLE
   DWORD    iSequenceInit;             // Initial sequence number
   DWORDLONG    qwTOBFanin;                // Directly measured fanin for this block
};


struct TLE                             // Time List Element
{
   DWORD    ibtleNext;                 // Offset to next TLE or 0
   TOB      tob;
};


struct THD
{

   DWORD    iBrc;                      // Last recorded branch
   DWORD    blkidSrc;                  // Last recorded indirect branch source
   DWORD    iDst;                      // Last recorded indirect branch target
   DWORD    ibthdNext;                 // Offset of next THD or 0
};


struct RPH
{
   DWORD    cbNext;
};


#ifndef TOV_DEFINED
#define TOV_DEFINED

enum TOV                               // Time Order Variety
{
   tovNone,
   tovFunction,
   tovBlock,
   tovEveryBlock,
   
   tov4Mask,
   tov4Fun,
   tov4Block,
   tov4EveryBlock,

   tovFunctionAndPostCall,
   tovThreadEveryBlock,

   tovCTO,                            // IRT to sweep counts for tobs
};

struct INE                             // Interval name entry
{
   DWORD ibineNext;
   DWORD iInterval;
   char  szName[16];
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xprof\xbbt.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    xbbt.h

Abstract:

    BBT support header file

--*/

#pragma once

#define IRTSYS
typedef ULONG DWORD;
typedef UCHAR BYTE;

#include <stdlib.h>
#include "bbtirt.h"
#include "idf.h"

//
// We allocate 32MB of memory for collecting BBT runtime data
//
#define IRT_BUFFER_SIZE (32*1024*1024)

//
// Background sweep timer frequency (in milliseconds)
//
#define IRT_SWEEP_INTERVAL 42

//
// Saved information about client-init parameters
//
typedef struct IRTCLIENTINFO {
    const IRTP* pirtp;
    DWORD*      rgCounts;
    BYTE*       rgTobCounts;
    DWORD*      rgSeqNums;
    IDFHDR*     pidfhdr;
    DWORD       currentTime;
    DWORD       tobSweepTime;
    DWORD       copyCountsTime;
    DWORD       intervalCount;
} IRTCLIENTINFO;

//
// Round up to a power of 2
//
#define CbRound(cb, cbAlign) (((cb) + ((cbAlign)-1)) & ~((cbAlign)-1))
#define CbRoundToPage(cb)    CbRound(cb, PAGE_SIZE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xprof\xbbt.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    xbbt.cpp

Abstract:

    BBT instrumented binary runtime support functions

--*/

#ifdef _XBOX_ENABLE_PROFILING

#include "ntos.h"
#include "xprofp.h"
#include "xbbt.h"

#ifdef _XBOX_ENABLE_BBT

IRTCLIENTINFO* IrtClientInfo;   // Client-init information
LONG IrtSweepingFlag;           // Whether we're currently sweep data to disk
KTIMER IrtTimer;                // Background timer
KDPC IrtTimerDpc;               //  and associated DPC

#define IsIrtClientInited() (IrtClientInfo != NULL)
#define IrtAssert(cond) do { if (!(cond)) KeBugCheckEx(0, __LINE__, 'IRTS', 0, 0); } while(0)


//
// Allocate space for an additional TLE structure
//
TLE* PtleCreate(IDFHDR* pidfhdr, TLH* ptlh, DWORD iInterval)
{
    DWORD ibtleNew = InterlockedExchangeAdd( (PLONG)&pidfhdr->cb, sizeof(TLE) );
   
    IrtAssert(ibtleNew + sizeof(TLE) <= pidfhdr->cbMax);

    // Fill in the TLE
    TLE* ptle = (TLE*) ((BYTE*) pidfhdr + ibtleNew);
    ptle->ibtleNext = ptlh->ibtleFirst;
    ptle->tob.iInterval = (iInterval & 0xFFFFFF80);

    // Link it into the list
    ptlh->ibtleFirst = ibtleNew;

    return ptle;
}


//
// Sweep TOB data
//
#define PtlhFromIfun(pidfhdr, ifun) \
        ((TLH*) ((BYTE*) pidfhdr + pidfhdr->ibrgtlhCode) + ifun)

#define COPYTOBBITS() { \
        ptlh = PtlhFromIfun(pidfhdr, i); \
        ptlh->qwTOBFanin++; \
        ibtle = ptlh->ibtleFirst; \
        if (ibtle != 0) { \
            ptle = (TLE*) ((BYTE*) pidfhdr + ibtle); \
            dwTimeSlot = iIntervalCur - ptle->tob.iInterval; \
            if (dwTimeSlot < cdwTob * cbitDw) { \
                ptle->tob.rgdwBit[dwTimeSlot>>5] |= 1 << (dwTimeSlot & 0x1F); \
                continue; \
            } \
        } \
        ptle = PtleCreate(pidfhdr, ptlh, iIntervalCur); \
        dwTimeSlot = iIntervalCur - ptle->tob.iInterval; \
        ptle->tob.rgdwBit[dwTimeSlot>>5] |= 1 << (dwTimeSlot & 0x1F); \
        }

VOID
IrtCopyCurrentTOBBits(IRTCLIENTINFO* pci)
{
    // Figure out the current interval index
    IDFHDR* pidfhdr = pci->pidfhdr;
    const IRTP* pirtp = pci->pirtp;
    DWORD iIntervalCur = pci->tobSweepTime / pirtp->cmsTimer;
    pci->tobSweepTime %= pirtp->cmsTimer;

    pci->intervalCount += iIntervalCur;
    pidfhdr->iIntervalCur = iIntervalCur = pci->intervalCount - 1;

    BYTE* rgTobBytes = pci->rgTobCounts;
    DWORD* rgCounts = pci->rgCounts;
    DWORDLONG* pqwDest = (DWORDLONG*) ((BYTE*) pidfhdr + pidfhdr->ibrgqwCount);
    DWORD i, n, ibtle, dwTimeSlot;
    TLH* ptlh;
    TLE* ptle;
    
    n = pidfhdr->ctlhCode;
    if (pidfhdr->tov == tovCTO) {
        // Make tobs from the counts

        // for each TOB
        for (i=0; i < n; i++) {
            // tob bytes are intialized to 1 and set to 0 when hit.
            if (rgCounts[i]) {
                // this byte was hit in the last interval - reset it for the next interval
                // Save counts too!
                pqwDest[i] += rgCounts[i];
                rgCounts[i] = 0;

                COPYTOBBITS();
            }
        }
    } else {
        IrtAssert((pidfhdr->tov & tov4Mask) == 0);

        // for each TOB
        for (i=0; i < n; i++) {
            // tob bytes are intialized to 1 and set to 0 when hit.
            if (rgTobBytes[i] == 0) {
                //this byte was hit in the last interval - reset it for the next interval
                rgTobBytes[i] = 1;

                COPYTOBBITS();
            }
        }
    }
}


//
// Sweep static edge counts
//
VOID IrtCopyCounts(IRTCLIENTINFO* pci)
{
    DWORD* srcCounts = pci->rgCounts;
    IDFHDR* pidfhdr = pci->pidfhdr;
    DWORDLONG* dstCounts = (DWORDLONG*) ((BYTE*) pidfhdr + pidfhdr->ibrgqwCount);
    DWORD i, n;

    n = pidfhdr->cqwCount;
    for (i=0; i < n; i++) {
        *dstCounts++ += *srcCounts;
        *srcCounts++ = 0;
    }

    if (pci->rgSeqNums) {
        n = pidfhdr->ctlhCode;
        for (i=0; i < n; i++) {
            TLH* ptlh = PtlhFromIfun(pidfhdr, i);
            ptlh->iSequenceInit = pci->rgSeqNums[i+1];
        }

        pidfhdr->iSequence = pci->rgSeqNums[0];
    }

    pci->copyCountsTime = 0;
}


VOID
IrtTimerProc(
    PKDPC dpc,
    VOID* context,
    VOID* param1,
    VOID* param2
    )

/*++

Routine Description:

    IRT runtime background sweeping timer procedure

Arguments:

    See DDK documentation

Return Value:

    NONE

Notes:

    This function runs at dispatch level.

--*/

{
    IRTCLIENTINFO* pci = IrtClientInfo;
    IrtAssert(IsIrtClientInited());

    // Check if we need to do a sweep yet. Note that if we're currently
    // in the process of writing IDF data to disk, then skip this round.
    pci->currentTime += IRT_SWEEP_INTERVAL;
    pci->tobSweepTime += IRT_SWEEP_INTERVAL;
    pci->copyCountsTime += IRT_SWEEP_INTERVAL;

    if (IrtSweepingFlag) return;

    if (pci->tobSweepTime >= pci->pirtp->cmsTimer) {
        IrtCopyCurrentTOBBits(pci);
    }

    // Call IrtCopyCounts once every 4 seconds
    if (pci->copyCountsTime >= 4000) {
        IrtCopyCounts(pci);
    }
}


//
// Initialize IDF header information
//
VOID IrtInitializeIdfHeader(IRTCLIENTINFO* pci)
{
    DWORD cb = CbRoundToPage(sizeof(*pci));
    IDFHDR* pidfhdr = (IDFHDR*) ((BYTE*) pci + cb);
    pci->pidfhdr = pidfhdr;

    DWORD cbMax = IRT_BUFFER_SIZE - cb;
    memset(pidfhdr, 0, cbMax);

    const IRTP* pirtp = pci->pirtp;
    pidfhdr->dwSignature = dwIdfSignature;
    pidfhdr->dwVersion = dwIdfVerCurrent;
    pidfhdr->dwId = pirtp->dwId;
    pidfhdr->dwGeneration = pirtp->dwGeneration;
    pidfhdr->tov = pirtp->tov;
    pidfhdr->fSweepable = pirtp->fSweepable ? 1 : 0;

    // Calculate the minimum size for the shared memory region

    cb = CbRound(sizeof(IDFHDR), sizeof(DWORDLONG));
    if (pirtp->szIdfKeyPath) {
        pidfhdr->ibszIdfKeyPath = cb;
        cb += strlen(pirtp->szIdfKeyPath) + 1;
    }
    cb = CbRound(cb, sizeof(DWORDLONG));

    pidfhdr->cqwCount = pirtp->cbrc;
    pidfhdr->ibrgqwCount = cb;
    cb += pidfhdr->cqwCount * sizeof(DWORDLONG);

    // Save space for indirect branches
    pidfhdr->ciblh = pirtp->cibd ? pirtp->cibd : pirtp->cibs;

    pidfhdr->ibrgiblh = cb;
    cb += pidfhdr->ciblh * sizeof(IBLH);
    cb = CbRound(cb, sizeof(DWORDLONG));

    IrtAssert(pirtp->cmsTimer != 0);

    if (pirtp->cfun != 0) {
        pidfhdr->ctlhCode = pirtp->cfun;
        pidfhdr->ibrgtlhCode = cb;
        cb += pidfhdr->ctlhCode * sizeof(TLH);
        cb = CbRound(cb, sizeof(DWORDLONG));
    }

    if (pirtp->crsc != 0) {
        pidfhdr->ctlhResource = pirtp->crsc;
        pidfhdr->ibrgtlhResource = cb;
        cb += pidfhdr->ctlhResource * sizeof(TLH);
        cb = CbRound(cb, sizeof(DWORDLONG));
    }

    pidfhdr->cb = cb;

    // Calculate the minimum size for the shared memory region

    DWORD cbMin = cb + sizeof(THD);
    cbMin += pidfhdr->ciblh * sizeof(IBLE);

    if (pirtp->cfun != 0)
        cbMin += pidfhdr->ctlhCode * sizeof(TLE);

    if (pirtp->crsc != 0)
        cbMin += pidfhdr->ctlhResource * sizeof(TLE);

    IrtAssert(cbMin <= cbMax);

    pidfhdr->cbMax = cbMax;
    pidfhdr->cbAllocated = cbMax;
    pidfhdr->cmsTimer = pirtp->cmsTimer;
    pidfhdr->cpsActive = 1;
    pidfhdr->ifunEndBoot = pirtp->ifunEndBoot;
    pidfhdr->iSequenceEndBoot = (DWORD) -1;
    pidfhdr->iIntervalEndBoot = (DWORD) -1;
    pidfhdr->fFastRT = (pci->rgCounts != NULL);
    pidfhdr->iIntervalStart = pci->intervalCount;
    pidfhdr->cmsStartTime = pci->currentTime;
    KeQuerySystemTime((LARGE_INTEGER*) &pidfhdr->qwStartTime);

    if (pirtp->szIdfKeyPath) {
        strcpy((char*) pidfhdr + pidfhdr->ibszIdfKeyPath, pirtp->szIdfKeyPath);
    }
}


DWORD IrtClientNewIndFast(const IRTP* pirtp, DWORD rvaDest, long iIndSrc)
{
   if (IrtSweepingFlag) return 0;

   IRTCLIENTINFO* pci = IrtClientInfo;
   IDFHDR* pidfhdr = pci->pidfhdr;
   IBLH* rgiblh = (IBLH*) ((BYTE*) pidfhdr + pidfhdr->ibrgiblh);
   IBLH* piblh = rgiblh + iIndSrc;
   DWORD* pibible = &piblh->ibibleFirst;

   // Allocate a new ible
   DWORD ibible = InterlockedExchangeAdd((PLONG)&pidfhdr->cb, sizeof(IBLE));
   IrtAssert(ibible + sizeof(IBLE) <= pidfhdr->cbMax);

   IBLE *pible = (IBLE *) ((BYTE *) pidfhdr + ibible);

   // Fill in the IBLE

   pible->blkidSrc = rvaDest;
   pible->qwCount = 0;

   // Atomically add to the front of the list
   DWORD ibibleFirst;
   do
   {
      ibibleFirst = piblh->ibibleFirst;
      pible->ibibleNext = ibibleFirst;
   }
   while (ibibleFirst != InterlockedCompareExchange((PLONG)&piblh->ibibleFirst, ibible, ibibleFirst ));
   
   InterlockedIncrement((PLONG)&pidfhdr->cible);

   return ibible;
}


//
// This function is called when a BBT instrumented binary is run.
// We assume this function is only called once.
//
extern "C" VOID
IrtClientInitFast(
    const IRTP* pirtp,
    DWORD* rgCounts,
    BYTE* rgTobCounts,
    FASTRTPARAM* pfrtp,
    DWORD* rgSeqNums,
    FASTINDDATA* pfid,
    VOID* unused
    )
{
    if (IsIrtClientInited()) return;

    // Allocate the necessary memory buffers
    IrtSweepingFlag = 0;

    IrtClientInfo = (IRTCLIENTINFO*) MmAllocateSystemMemory(IRT_BUFFER_SIZE, PAGE_READWRITE);
    IrtAssert(IrtClientInfo != NULL);

    // Remember the client init parameters
    memset(IrtClientInfo, 0, sizeof(IRTCLIENTINFO));
    IrtClientInfo->pirtp = pirtp;
    IrtClientInfo->rgCounts = rgCounts;
    IrtClientInfo->rgTobCounts = rgTobCounts;
    IrtClientInfo->rgSeqNums = rgSeqNums;

    // Initialize IDF header information
    IrtInitializeIdfHeader(IrtClientInfo);

    if (pfid) {
       IBLH* rgiblh = (IBLH*) ((BYTE*) IrtClientInfo->pidfhdr + IrtClientInfo->pidfhdr->ibrgiblh);
       pfid->rgiblh = (DWORD_PTR) rgiblh;
       pfid->negaddrbase = -(LONGLONG) pirtp->pvImageBase;
       pfid->pidfhdr = (DWORD_PTR) IrtClientInfo->pidfhdr;
       pfid->pfnInd = (DWORD_PTR) IrtClientNewIndFast;
    }

    // Start the background timer
    LARGE_INTEGER dueTime;
    dueTime.QuadPart = -10000*IRT_SWEEP_INTERVAL;

    KeInitializeDpc(&IrtTimerDpc, IrtTimerProc, NULL);
    KeInitializeTimer(&IrtTimer);
    KeSetTimerEx(&IrtTimer, dueTime, IRT_SWEEP_INTERVAL, &IrtTimerDpc);
}


//
// Sweep the BBT data into a disk file
//
NTSTATUS IrtSweep(HANDLE file)
{
    NTSTATUS status = STATUS_INVALID_PARAMETER;

    //
    // Make sure the client has been initialized
    // and we're not sweeping at the moment
    //
    if (!IsIrtClientInited() ||
        InterlockedCompareExchange(&IrtSweepingFlag, 1, 0) != 0) {
        status = STATUS_INVALID_PARAMETER;
    } else {
        // Sweep static edge counts
        IrtCopyCounts(IrtClientInfo);

        // Write the in-memory IDF data out to the disk

        IO_STATUS_BLOCK iostatusBlock;
        FILE_END_OF_FILE_INFORMATION endOfFile;
        FILE_ALLOCATION_INFORMATION allocation;
        IDFHDR* pidfhdr = IrtClientInfo->pidfhdr;
        DWORD count = pidfhdr->cb;

        status = NtWriteFile(
                   file,
                   NULL,
                   NULL,
                   NULL,
                   &iostatusBlock,
                   pidfhdr,
                   (count + 511) & ~511,
                   NULL);

        // Set file size

        if (NT_SUCCESS(status)) {
            endOfFile.EndOfFile.QuadPart = count;
            status = NtSetInformationFile(
                        file,
                        &iostatusBlock,
                        &endOfFile,
                        sizeof(endOfFile),
                        FileEndOfFileInformation);
        }

        if (NT_SUCCESS(status)) {
            allocation.AllocationSize.QuadPart = count;
            status = NtSetInformationFile(
                        file,
                        &iostatusBlock,
                        &allocation,
                        sizeof(allocation),
                        FileAllocationInformation);
        }

        // Clean up the in-memory data
        IrtInitializeIdfHeader(IrtClientInfo);

        IrtSweepingFlag = 0;
    }

    return status;
}

#else // !_XBOX_ENABLE_BBT

//
// When BBTBUILD is not enabled, just stub out these two functions
//
extern "C" VOID
IrtClientInitFast(
    const IRTP* pirtp,
    DWORD* rgCounts,
    BYTE* rgTobCounts,
    FASTRTPARAM* pfrtp,
    DWORD* rgSeqNums,
    VOID* unused
    ) {}

NTSTATUS IrtSweep(HANDLE file) { return STATUS_NOT_IMPLEMENTED; }

#endif // !_XBOX_ENABLE_BBT

#endif // _XBOX_ENABLE_PROFILING
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\baseio.cpp ===
/*++

Copyright (c) Microsoft Corporation

Author:
    Keith Lau (keithlau)

Description:
    Module implementing file and socket I/O primitives

Module Name:

    baseio.c

--*/

#include "xonp.h"
#include "xonver.h"

//
// Do work function for file I/O
//
HRESULT CXo::ReadWriteFileContinue(
            XONLINETASK_HANDLE  hTask
            )
{
    PXONLINETASK_FILEIO pfileio = (PXONLINETASK_FILEIO)hTask;

    Assert(hTask != NULL);

    // Check to see if our overlapped file I/O has completed
    if (!GetOverlappedResult(pfileio->hFile, 
                &(pfileio->overlapped), &(pfileio->cbDone), FALSE))
    {
        DWORD dwError = GetLastError();
        if ((dwError != ERROR_IO_PENDING) &&
            (dwError != ERROR_IO_INCOMPLETE))
        {
            // Hard error, abort the file I/O
            pfileio->hr = HRESULT_FROM_WIN32(dwError);
        }
        else
            pfileio->hr = XONLINETASK_S_RUNNING;
        
        goto Cleanup;
    }
    else
    {
        // Return completion and success
        pfileio->hr = XONLINETASK_S_SUCCESS;
    }

Cleanup:
    return(pfileio->hr);
}

//
// Function to close a file IO
//
VOID CXo::ReadWriteFileClose(
            XONLINETASK_HANDLE  hTask
            )
{
    SysFree(hTask);
}

//
// Function to actually kick off the read or write
//
HRESULT CXo::ReadWriteFileBegin(
            PXONLINETASK_FILEIO pfileio,
            BOOL                fRead
            )
{
    HRESULT     hr = S_OK;
    BOOL        fResult;

    // Kick off the asynchronous op
    if (fRead)
        fResult = ReadFile(pfileio->hFile, pfileio->pbBuffer, 
                    pfileio->cbBuffer, NULL, &(pfileio->overlapped));
    else
        fResult = WriteFile(pfileio->hFile, pfileio->pbBuffer, 
                    pfileio->cbBuffer, NULL, &(pfileio->overlapped));
        
    // We need to set the work event here because overlapped file I/O will call ResetEvent,
    // and that might have just reset the signal from a different subtask.  By setting it
    // now, we might be over-setting but at least we guarantee we are not under-setting,
    // which could cause a stall.

    if (pfileio->xontask.hEventWorkAvailable)
        SetEvent(pfileio->xontask.hEventWorkAvailable);
    
    if (!fResult)
    {
        DWORD dwError = GetLastError();
        
        if (dwError != ERROR_IO_PENDING)
            hr = HRESULT_FROM_WIN32(dwError);
    }

    return(hr);
}

//
// Function to initialize a context for file read or write
//
VOID CXo::ReadWriteFileInitializeContext(
            HANDLE              hFile,
            LPBYTE              pbBuffer,
            DWORD               cbBytes,
            ULARGE_INTEGER      uliStartingOffset,
            HANDLE              hWorkEvent,
            PXONLINETASK_FILEIO pfileio
            )
{
    Assert(pfileio != NULL);
    Assert(hFile != INVALID_HANDLE_VALUE);
    Assert(pbBuffer != NULL);
    Assert(((DWORD)pbBuffer & 0x3) == 0);
    Assert((cbBytes & (XBOX_HD_SECTOR_SIZE - 1)) == 0);
    Assert((uliStartingOffset.u.LowPart & (XBOX_HD_SECTOR_SIZE - 1)) == 0);

    // Fill in the blanks
    ZeroMemory(pfileio, sizeof(XONLINETASK_FILEIO));
    pfileio->hr = S_OK;
    pfileio->hFile = hFile;
    pfileio->pbBuffer = pbBuffer;
    pfileio->cbBuffer = cbBytes;
    pfileio->overlapped.Offset = uliStartingOffset.u.LowPart;
    pfileio->overlapped.OffsetHigh = uliStartingOffset.u.HighPart;
    pfileio->overlapped.hEvent = hWorkEvent;

    TaskInitializeContext(&pfileio->xontask);
    pfileio->xontask.pfnContinue = ReadWriteFileContinue;
    pfileio->xontask.pfnClose = ReadWriteFileClose;
    pfileio->xontask.hEventWorkAvailable = hWorkEvent;
}

//
// Function to kick off a generic overlapped file read or write
//
HRESULT CXo::ReadWriteFile(
            HANDLE              hFile,
            LPBYTE              pbBuffer,
            DWORD               cbBytes,
            ULARGE_INTEGER      uliStartingOffset,
            HANDLE              hWorkEvent,
            XONLINETASK_HANDLE  *phTask,
            BOOL                fRead
            )
{
    HRESULT             hr = S_OK;
    PXONLINETASK_FILEIO pfileio = NULL;
    DWORD               dwError;
    BOOL                fResult;

    Assert(phTask != NULL);
    Assert(hFile != INVALID_HANDLE_VALUE);
    Assert(pbBuffer != NULL);
    Assert(((DWORD)pbBuffer & 0x3) == 0);
    Assert((cbBytes & (XBOX_HD_SECTOR_SIZE - 1)) == 0);
    Assert((uliStartingOffset.u.LowPart & (XBOX_HD_SECTOR_SIZE - 1)) == 0);

    // Allocate the task context
    pfileio = (PXONLINETASK_FILEIO)SysAlloc(sizeof(XONLINETASK_FILEIO), PTAG_XONLINETASK_FILEIO);
    if (!pfileio)
        return(E_OUTOFMEMORY);

    // Initialize the context
    ReadWriteFileInitializeContext(hFile, pbBuffer, cbBytes, 
                uliStartingOffset, hWorkEvent, pfileio);

    // Kick off the asynchronous op
    hr = ReadWriteFileBegin(pfileio, fRead);
    if (FAILED(hr))
        goto Error;

    // Return the opaque handle
    *phTask = (XONLINETASK_HANDLE)pfileio;
    
Cleanup:
    return(hr);

Error:
    if (pfileio)
    {
        SysFree(pfileio);
    }
    goto Cleanup;
}

//
// Function to retrieve the results of a file I/O
//
HRESULT CXo::GetReadWriteFileResults(
            XONLINETASK_HANDLE  hTask,
            DWORD               *pdwBytesTransferred,
            LPBYTE              *ppbBuffer
            )
{
    PXONLINETASK_FILEIO pfileio = (PXONLINETASK_FILEIO)hTask;

    Assert(hTask != NULL);

    if (pdwBytesTransferred)
        *pdwBytesTransferred = pfileio->cbDone;
    if (ppbBuffer)
        *ppbBuffer = pfileio->pbBuffer;
    return(pfileio->hr);
}

//
// Do work function for socket stream connect
//
HRESULT CXo::StreamConnectContinue(
            XONLINETASK_HANDLE  hTask
            )
{
    int                 iResult, iError;
    fd_set              fdsetWrite, fdsetExcept;
    struct timeval      tvTimeout = { 0, 0 };
    PXONLINETASK_SOCKIO psockio = (PXONLINETASK_SOCKIO)hTask;

    Assert(hTask != NULL);

    // Make sure the event is set for polling
    if (psockio->xontask.hEventWorkAvailable)
        SetEvent(psockio->xontask.hEventWorkAvailable);

    // Check to see if our async stream connect had completed
    fdsetWrite.fd_count = 1;
    fdsetWrite.fd_array[0] = psockio->socket;
    fdsetExcept.fd_count = 1;
    fdsetExcept.fd_array[0] = psockio->socket;

    psockio->hr = XONLINETASK_S_RUNNING;
    iResult = select(1, NULL, &fdsetWrite, &fdsetExcept, &tvTimeout);
    if (iResult == SOCKET_ERROR)
    {
        psockio->hr = HRESULT_FROM_WIN32(WSAGetLastError());
        goto Cleanup;
    }
    else if (!iResult)
    {
        // The results are not available yet, continue
        goto Cleanup;
    }
    else
    {
        psockio->hr = XONLINETASK_S_SUCCESS;
    
        // Something happened to the socket, figure out what happened
        if (fdsetExcept.fd_count != 0)
        {
            Assert(fdsetExcept.fd_array[0] == psockio->socket);

            // We failed, return E_FAIL. In original winsock, we should
            // be able to retrieve the failure code using getsockopt on
            // SO_ERROR. But Xbox does not support this option. 
            psockio->hr = HRESULT_FROM_WIN32(WSAEADDRNOTAVAIL);
        }
        else if (fdsetWrite.fd_count != 0)
        {
            Assert(fdsetWrite.fd_count == 1);
            Assert(fdsetWrite.fd_array[0] == psockio->socket);
        }
        else
        {
            AssertSz(FALSE, "StreamConnectContinue: bad select results");
        }

        // Either case, we are done!
    }

Cleanup:
    return(psockio->hr);
}

//
// Close function for socket stream connect
//
VOID CXo::StreamConnectClose(
            XONLINETASK_HANDLE  hTask
            )
{
    SysFree(hTask);
}

//
// Function to actually kick off the stream connect
//
HRESULT CXo::StreamConnectBegin(SOCKADDR_IN * psockaddr, PXONLINETASK_SOCKIO psockio)
{
    HRESULT hr = S_OK;
    ULONG   lnbio = 1;
    int     iResult;

    // Make sure the socket is set to nonblocking mode
    iResult = ioctlsocket(psockio->socket, FIONBIO, &lnbio);
    if (iResult == SOCKET_ERROR)
        return(HRESULT_FROM_WIN32(WSAGetLastError()));

    // Kick off the asynchronous connect
    iResult = connect(psockio->socket, (PSOCKADDR)psockaddr, sizeof(SOCKADDR_IN));
    if (iResult == SOCKET_ERROR)
    {
        DWORD dwError = WSAGetLastError();

        // Treat WSAEWOULDBLOCK as an error (too many IO's)
        if (dwError != WSAEWOULDBLOCK)
            hr = HRESULT_FROM_WIN32(dwError);

        // WSAEWOULDBLOCK is the expected result ...
    }
    // connect returning success immedaitely is also a success
    // scenario, although not expected. This means that the connection
    // was established synchronously. Since this should be so rare,
    // we treat it as if it was asynchronous, and the first Continue
    // call will return success.

    // This is actually a polling operation, set the event
    if (psockio->xontask.hEventWorkAvailable)
        SetEvent(psockio->xontask.hEventWorkAvailable);

    return(hr);
}

//
// Function to initialize the context for async stream connect
//
VOID CXo::StreamConnectInitializeContext(
            SOCKET              socketIn,
            HANDLE              hWorkEvent,
            PXONLINETASK_SOCKIO psockio
            )
{
    Assert(psockio != NULL);
    Assert(socketIn != INVALID_SOCKET);

    // Fill in the blanks
    ZeroMemory(psockio, sizeof(XONLINETASK_SOCKIO));
    psockio->hr = S_OK;
    psockio->socket = socketIn;
    psockio->wsaoverlapped.hEvent = hWorkEvent;

    TaskInitializeContext(&psockio->xontask);
    psockio->xontask.pfnContinue = StreamConnectContinue;
    psockio->xontask.pfnClose = StreamConnectClose;
    psockio->xontask.hEventWorkAvailable = hWorkEvent;
}

//
// Function to kick off an asynchronous stream connect
//
HRESULT CXo::StreamConnect(
            SOCKET              socketIn,
            SOCKADDR_IN         *psockaddr,
            HANDLE              hWorkEvent,
            XONLINETASK_HANDLE  *phTask
            )
{
    HRESULT             hr = S_OK;
    PXONLINETASK_SOCKIO psockio = NULL;
    DWORD               dwError;
    int                 iResult;

    Assert(phTask != NULL);
    Assert(socketIn != INVALID_SOCKET);

    // Allocate the task context
    psockio = (PXONLINETASK_SOCKIO)SysAlloc(sizeof(XONLINETASK_SOCKIO), PTAG_XONLINETASK_SOCKIO);
    if (!psockio)
        return(E_OUTOFMEMORY);

    // Initialize the context
    StreamConnectInitializeContext(socketIn, hWorkEvent, psockio);

    // Kick off the asynchronous op
    hr = StreamConnectBegin(psockaddr, psockio);
    if (FAILED(hr))
        goto Error;

    // Return the opaque handle
    *phTask = (XONLINETASK_HANDLE)psockio;

Cleanup:
    return(hr);

Error:
    if (psockio)
    {
        SysFree(psockio);
    }
    goto Cleanup;
}

//
// Function to retrieve the results of a stream connect
//
HRESULT CXo::GetStreamConnectResults(XONLINETASK_HANDLE hTask)
{
    return(((PXONLINETASK_SOCKIO)hTask)->hr);
}

//
// Do work function for socket I/O
//
HRESULT CXo::SendRecvContinue(XONLINETASK_HANDLE hTask)
{
    PXONLINETASK_SOCKIO psockio = (PXONLINETASK_SOCKIO)hTask;

    Assert(hTask != NULL);

    // Check to see if our overlapped file I/O has completed
    if (!WSAGetOverlappedResult(psockio->socket, 
                &(psockio->wsaoverlapped), &(psockio->cbDone), FALSE,
                &(psockio->dwFlags)))
    {
        DWORD dwError = WSAGetLastError();
        if ((dwError != ERROR_IO_PENDING) &&
            (dwError != ERROR_IO_INCOMPLETE))
        {
            psockio->hr = HRESULT_FROM_WIN32(dwError);
        }
        else
            psockio->hr = XONLINETASK_S_RUNNING;
        goto Cleanup;
    }
    else
    {
        // Return signalled state and success
        psockio->hr = XONLINETASK_S_SUCCESS;
    }

Cleanup:
    return(psockio->hr);
}

//
// Close function for socket stream I/O
//
VOID CXo::SendRecvClose(XONLINETASK_HANDLE hTask)
{
    SysFree(hTask);
}

//
// Function to actually kick off the socket operation
//
HRESULT CXo::SendRecvBegin(PXONLINETASK_SOCKIO psockio, BOOL fSend)
{
    HRESULT hr = S_OK;
    int     iResult;

    // Kick off the asynchronous op
    if (fSend)
        iResult = WSASend(psockio->socket, psockio->pBuffers, 
                    psockio->dwBuffers, &psockio->cbDone, 
                    psockio->dwFlags, &psockio->wsaoverlapped, NULL);
    else                
        iResult = WSARecv(psockio->socket, psockio->pBuffers, 
                    psockio->dwBuffers, &psockio->cbDone, 
                    &psockio->dwFlags, &psockio->wsaoverlapped, NULL);

    if (iResult == SOCKET_ERROR)
    {
        DWORD dwError = WSAGetLastError();

        // Treat WSAEWOULDBLOCK as an error (too many IO's)
        if (dwError != ERROR_IO_PENDING)
            hr = HRESULT_FROM_WIN32(dwError);

        // ERROR_IO_PENDING is the expected result ...
    }
    // WSASend returning success is not generally expected, but 
    // it's OK because this is functionally equivalent to an 
    // async completion.

    return(hr);
}

//
// Function to initialize the context for socket send or receive
//
VOID CXo::SendRecvInitializeContext(
            SOCKET              socket,
            LPWSABUF            pBuffers,
            DWORD               dwBufferCount,
            DWORD               dwFlags,
            HANDLE              hWorkEvent,
            PXONLINETASK_SOCKIO psockio
            )
{
    Assert(psockio != NULL);
    Assert(socket != INVALID_SOCKET);
    Assert(pBuffers != NULL);

    // Fill in the blanks
    ZeroMemory(psockio, sizeof(XONLINETASK_SOCKIO));
    psockio->hr = S_OK;
    psockio->socket = socket;
    psockio->pBuffers = pBuffers;
    psockio->dwBuffers = dwBufferCount;
    psockio->dwFlags = dwFlags;
    psockio->wsaoverlapped.hEvent = hWorkEvent;

    TaskInitializeContext(&psockio->xontask);
    psockio->xontask.pfnContinue = SendRecvContinue;
    psockio->xontask.pfnClose = SendRecvClose;
    psockio->xontask.hEventWorkAvailable = hWorkEvent;
}

//
// Function to kick off a generic overlapped socket send or receive
//
HRESULT CXo::SendRecv(
            SOCKET              socket,
            LPWSABUF            pBuffers,
            DWORD               dwBufferCount,
            DWORD               dwFlags,
            HANDLE              hWorkEvent,
            XONLINETASK_HANDLE  *phTask,
            BOOL                fSend
            )
{
    HRESULT             hr = S_OK;
    PXONLINETASK_SOCKIO psockio = NULL;
    DWORD               dwError;
    int                 iResult;

    Assert(phTask != NULL);
    Assert(socket != INVALID_SOCKET);
    Assert(pBuffers != NULL);

    // Allocate the task context
    psockio = (PXONLINETASK_SOCKIO)SysAlloc(sizeof(XONLINETASK_SOCKIO), PTAG_XONLINETASK_SOCKIO);
    if (!psockio)
        return(E_OUTOFMEMORY);

    // Initialize the context
    SendRecvInitializeContext(socket, pBuffers, dwBufferCount,
                dwFlags, hWorkEvent, psockio);

    // Kick off the asynchronous op
    hr = SendRecvBegin(psockio, fSend);
    if (FAILED(hr))
        goto Error;

    // Return the opaque handle
    *phTask = (XONLINETASK_HANDLE)psockio;

Cleanup:
    return(hr);

Error:
    if (psockio)
    {
        SysFree(psockio);
    }
    goto Cleanup;
}

//
// Function to retrieve the results of a socket I/O
//
HRESULT CXo::GetSendRecvResults(
            XONLINETASK_HANDLE  hTask,
            DWORD               *pdwBytesTransferred,
            DWORD               *pdwFlags,
            LPWSABUF            *ppBuffers
            )
{
    PXONLINETASK_SOCKIO psockio = (PXONLINETASK_SOCKIO)hTask;

    Assert(hTask != NULL);

    if (pdwBytesTransferred)
        *pdwBytesTransferred = psockio->cbDone;
    if (pdwFlags)
        *pdwFlags = psockio->dwFlags;
    if (ppBuffers)
        *ppBuffers = psockio->pBuffers;
    return(psockio->hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\autoupd.cpp ===
/*++

Copyright (c) Microsoft Corporation

Author:
    Keith Lau (keithlau)

Description:
	Module implementing Autoupdate

Module Name:

    autoupd.c

--*/

#include "xonp.h"
#include "xonver.h"

#ifdef XONLINE_FEATURE_XBOX

#include <xboxp.h>
#include <xlaunch.h>
#include <shahmac.h>

//
// Define the version of the offline dash
//
#define AUTOUPD_OFFLINE_DASH_VERSION	((DWORD)0x00000001)

//
// Define some hard paths for Autoupdate
//
#define AUTOUPD_DVD_DASH_SOURCE_PATH	"d:\\$u\\%08x\\$\\"
#define AUTOUPD_DVD_DASH_SOURCE_ROOT	"d:\\$u\\%08x\\"
#define AUTOUPD_DVD_TITLE_SOURCE_PATH	"d:\\$u\\%08x\\"
#define AUTOUPD_DVD_TITLE_ROOT_PATH		"t:\\"
#define AUTOUPD_DVD_DASH_ROOT_PATH		"y:\\"
#define AUTOUPD_UPDATE_XBE_NAME			"default.xbe"
#define AUTOUPD_DASH_CONFIG_NAME		"boot.ini"

#ifdef DEVKIT
#define AUTOUPD_DASH_UPDATE_XBE_NAME	"xshell.xbe"
#else
#define AUTOUPD_DASH_UPDATE_XBE_NAME	"xboxdash.xbe"
#endif

#define AUTOUPD_DASH_SWITCHER_XBE_NAME	"switcher.xbe"

#define AUTOUPD_DASH_UPDATE_VERSION_NAME "version.xbx"

//
// Define the path to the dash partition
//
const OCHAR DashPartition[]  = OTEXT("\\Device\\Harddisk0\\Partition2\\");
const OBJECT_STRING YDrive = CONSTANT_OBJECT_STRING( OTEXT("\\??\\Y:") );


//
// Define the full reboot paths
//
const OCHAR TitleRebootPath[] = 
		OTEXT("\\Device\\Harddisk0\\Partition1\\TDATA\\%08x\\$u");
const OCHAR DashRebootPath[] = 
		OTEXT("\\Device\\Harddisk0\\Partition2\\$%c");

//
// Strings for mounting devices
//
COBJECT_STRING DDrive      = CONSTANT_OBJECT_STRING( OTEXT("\\??\\D:") );
COBJECT_STRING CdDevice    = CONSTANT_OBJECT_STRING( OTEXT("\\Device\\CdRom0") );
COBJECT_STRING FDrive      = CONSTANT_OBJECT_STRING( OTEXT("\\??\\F:") );
COBJECT_STRING TitleData   = CONSTANT_OBJECT_STRING( OTEXT("\\Device\\Harddisk0\\partition1\\TDATA") );

//
// DVD Autoupdate (Dash and Titles) states
//
typedef enum
{
	dvdupdCountFiles = 0,
	dvdupdWipeDestination,
	dvdupdCreateTarget,
	dvdupdCopyFiles,
	dvdupdWriteConfig,
	dvdupdCleanup,
	dvdupdDone,

} AUTOUPD_DVD_STATES;

//
// DVD Autoupdate (Dash and Titles) task context
//
struct XONLINETASK_AUTOUPD_DVD
{
	XONLINETASK_CONTEXT			xontask;	// Master task handle
	HRESULT						hr;			// HRESULT
	AUTOUPD_DVD_STATES			dwState;	// Current State
	DWORD						dwTitleID;	// Title being updated
	WORD						wVersionHi;	// Current major version before update
	WORD						wVersionLo;	// Current minor version before update
	DWORD						dwFlags;	// Flags

	XONLINETASK_DIROPS			dirops;		// Directory operations context
	XONLINETASK_DIRCOPY			dircopy;	// Directory crawl context

	AUTOUPD_PROGRESS_CONTEXT	progress;	// Progress struct

	// String buffers
	CHAR						szPath[MAX_PATH];
	CHAR						szTarget[MAX_PATH];
	CHAR						szDir[MAX_PATH];
	CHAR						szTemp[MAX_PATH];

};

//
// Define the set of flags
//
#define XONLINEAUTOUPD_FLAG_DASH_UPDATE		(0x80000000)
#define XONLINEAUTOUPD_FLAG_DASH_0			(0x00000001)

#define IS_UPDATING_DASH(pautoupd) \
		(((pautoupd)->dwFlags & XONLINEAUTOUPD_FLAG_DASH_UPDATE)?TRUE:FALSE)
#define GET_UPDATE_DASH_ID(pautoupd) \
		(((pautoupd)->dwFlags & XONLINEAUTOUPD_FLAG_DASH_0)?0:1)
#define GET_DIRTYPE(pautoupd) \
		(IS_UPDATING_DASH(pautoupd)? \
				((GET_UPDATE_DASH_ID(pautoupd)==1)?dirtypeDashUpdate1:dirtypeDashUpdate0): \
				dirtypeTitleUpdate)

//
// Helper function to get the unmunged title key for the given title ID
//
HRESULT XoUpdateGetRawTitleKey(
			DWORD	dwTitleId,
			PBYTE	pbTitleKey,
			DWORD	*pcbTitleKey
			)
{
	PXBEIMAGE_CERTIFICATE	Certificate;
	DWORD					i;

    Assert(*pcbTitleKey == XBOX_KEY_LENGTH);

	// Get the header cert of the cerrent title
    Certificate = XeImageHeader()->Certificate;

    // First check to see if the current title is already it
    if (dwTitleId == Certificate->TitleID)
    {
    	memcpy(pbTitleKey, Certificate->SignatureKey, XBOX_KEY_LENGTH);
    	return(S_OK);
    }
    else
    {
    	// Now see if it's one of our alternate titles
	    for (i = 0; i < XBEIMAGE_ALTERNATE_TITLE_ID_COUNT; i++) 
	    {
	    	if (Certificate->AlternateTitleIDs[i] == dwTitleId)
	    	{
	    		memcpy(pbTitleKey, 
    					Certificate->AlternateSignatureKeys[i], XBOX_KEY_LENGTH);
	    		return(S_OK);
	    	}
	    }
    }

    return(HRESULT_FROM_WIN32(ERROR_NOT_FOUND));
}

//
// This function mounts the dash partition as Y: drive. 
//
HRESULT XoUpdateMountDashPartition()
{
	HRESULT			hr = S_OK;
    NTSTATUS		Status;
	OBJECT_STRING	VolString;
	OBJECT_STRING	DriveString;

	// Initialize the volume string
	RtlInitObjectString(&VolString, DashPartition);

	// The DriveString should not end in a backslash, so init from the same
	// string, but subtract a character on the Length member.
	RtlInitObjectString(&DriveString, DashPartition);
	DriveString.Length -= sizeof(OCHAR);

	// Just validate the partition for good measure
	Status = XapiValidateDiskPartition(&VolString);
	if (NT_SUCCESS(Status))
	{
	    // Assign it to drive y:
	    Status = IoCreateSymbolicLink((POBJECT_STRING) &YDrive, &DriveString);
	}

	if (!NT_SUCCESS(Status))
		hr = HRESULT_FROM_WIN32(RtlNtStatusToDosError(Status));

	return(hr);
}

//
// Function to mount a title's TDATA to the specified drive
//
// Call this with caution and make sure the drive to mount does 
// not conflict with pre-defined drive-letters
//
// Note: This is a simplified RIP from pathmisc.c and xapiinit.c
// because we don't want a dependency on xapilibp
//
HRESULT XoMountTitleTDataToDriveLetter(
			PCOBJECT_STRING pcDriveString,
			PCOBJECT_STRING pcPathString,
			DWORD			dwTitleId
			)
{
	HRESULT	hr = S_OK;
    NTSTATUS Status;
    OCHAR szPathTemp[MAX_PATH];
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_STRING PerTitlePathString;
    HANDLE DirHandle;
    OCHAR szTitleId[CCHMAX_HEX_DWORD];

    Assert(pcDriveString && pcPathString);

    DwordToStringO(dwTitleId, szTitleId);

    InitializeObjectAttributes(
        &Obja,
        (POBJECT_STRING)&TitleData,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Assert(ocslen(szTitleId) < CCHMAX_HEX_DWORD);
    Assert(pcPathString->Length < (sizeof(szPathTemp) - (CCHMAX_HEX_DWORD * sizeof(OCHAR))));
    ocscpy(szPathTemp, pcPathString->Buffer);
    //
    //  Usually, pcDriveString usually does not have a '\\' on the end, the exception
    //  is on mounting MU's.  So here we check for '\\' and only append if necessary.
    //
    if(szPathTemp[(pcPathString->Length / sizeof(OCHAR))-1] != OTEXT('\\'))
    {
        szPathTemp[pcPathString->Length / sizeof(OCHAR)] = OTEXT('\\');
    } else
    {
        pcPathString->Length--;
    }
    ocscpy(&(szPathTemp[(pcPathString->Length + sizeof(OCHAR)) / sizeof(OCHAR)]), szTitleId);

    RtlInitObjectString(&PerTitlePathString, szPathTemp);

    InitializeObjectAttributes(
        &Obja,
        &PerTitlePathString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtCreateFile(
                &DirHandle,
                FILE_LIST_DIRECTORY | SYNCHRONIZE | FILE_GENERIC_WRITE,
                &Obja,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_OPEN,
                FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                );
    if (NT_SUCCESS(Status))
    {
        Status = IoCreateSymbolicLink((POBJECT_STRING) pcDriveString, &PerTitlePathString);
    }
    
    if (!NT_SUCCESS(Status))
    	goto Error;

Exit:
    return(hr);

Error:    
	hr = HRESULT_FROM_WIN32(RtlNtStatusToDosError(Status));
	goto Exit;
}

//
// Drive specific to hide details
//
HRESULT XoUpdateMountTitleTDataToPrivateDrive(
			DWORD			dwTitleId
			)
{
	return(XoMountTitleTDataToDriveLetter(&FDrive, &TitleData, dwTitleId));
}

//
// Function to unmount a drive previously mounted with
// XoMountTitleTdataToDriveLetter. Since this does not do any
// routine cleanup, don't call this function to unmpa any drives
// that is not mapped with XoMountTitleTdataToDriveLetter.
// 
HRESULT XoUpdateUnmountTitleTData(
			OCHAR chDrive
			)
{
    NTSTATUS Status;
    OCHAR szDosDevice[MAX_PATH];
    OBJECT_STRING DosDevice;

    // Removing the 0x20 bit will make lower case characters uppercase
    chDrive &= (~0x20);

    soprintf(szDosDevice, OTEXT("\\??\\%c:"), chDrive);

    RtlInitObjectString(&DosDevice, szDosDevice);

	// Need to unmount the FS here as well
    Status = IoDeleteSymbolicLink(&DosDevice);

    return(RtlNtStatusToDosError(Status));
}

//
// Drive-inspecific function to hide the details
//
HRESULT XoUpdateUnmountPrivateDrive()
{
	return(XoUpdateUnmountTitleTData('F'));
}

//
// This function formats the dash partition.
//
HRESULT XoUpdateFormatDashPartition()
{
	HRESULT			hr = S_OK;
    NTSTATUS		Status;
	BOOL			fRet;
	OBJECT_STRING	VolString;
	OBJECT_STRING	DriveString;

	// Initialize the volume string
	RtlInitObjectString(&VolString, DashPartition);

	// The DriveString should not end in a backslash, so init from the same
	// string, but subtract a character on the Length member.
	RtlInitObjectString(&DriveString, DashPartition);
	DriveString.Length -= sizeof(OCHAR);

	// Just simple as that!
	fRet = XapiFormatFATVolume(&DriveString);
	if (fRet)
	{
		// Validate the partition for good measure
		Status = XapiValidateDiskPartition(&VolString);
		if (!NT_SUCCESS(Status))
			hr = HRESULT_FROM_WIN32(RtlNtStatusToDosError(Status));
	}
	else
		hr = HRESULT_FROM_WIN32(GetLastError());

	return(hr);
}

//
// Function to read the current dash boot directory 
// from the config file
//
HRESULT XoUpdateReadDashConfig(
			PAUTOUPD_DASH_CONFIG	pConfig,
			BOOL					fFailIfNotFound
			)
{
	HRESULT	hr = S_OK;
	HANDLE	hFile = INVALID_HANDLE_VALUE;
	CHAR	szConfig[MAX_PATH];
	DWORD	cbConfig;
	DWORD	dwError;

	// Figure out where to find the config file
	cbConfig = MAX_PATH;
	hr = BuildTargetPath(0, 0, 0,
				AUTOUPD_DASH_CONFIG_NAME,
				dirtypeDashRoot,
				&cbConfig, szConfig);
	Assert(SUCCEEDED(hr));
	
	hFile = CreateFile(szConfig,
				GENERIC_READ, 
				0, 	// No sharing to prevent mishaps
				NULL, 
				OPEN_EXISTING, 
				FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, 
				NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		dwError = GetLastError();
		if ((dwError == ERROR_FILE_NOT_FOUND) ||
			(dwError == ERROR_PATH_NOT_FOUND))
		{
			if (fFailIfNotFound)
			{
				hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
				goto Error;
			}
			goto Default;
		}
		
		hr = HRESULT_FROM_WIN32(dwError);
		goto Error;
	}
	if (!ReadFile(hFile, (PBYTE)pConfig, 
				sizeof(AUTOUPD_DASH_CONFIG), &cbConfig, NULL))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Error;
	}

	// If the struct doesn't look right, then fall back to default
	if (cbConfig != sizeof(AUTOUPD_DASH_CONFIG))
		goto Default;

Error:	
Exit:
	CloseHandle(hFile);
	return(hr);

Default:
	// Default active to 0
	pConfig->dwActiveDirectory = 0;
	goto Exit;
}

//
// Function to write the current dash boot directory 
// to the config file
//
HRESULT XoUpdateWriteDashConfig(
			PAUTOUPD_DASH_CONFIG	pConfig
			)
{
	HRESULT	hr = S_OK;
	HANDLE	hFile = INVALID_HANDLE_VALUE;
	CHAR	szConfig[MAX_PATH];
	DWORD	cbConfig;
	
	// Figure out where to find the config file
	cbConfig = MAX_PATH;
	hr = BuildTargetPath(0, 0, 0,
				AUTOUPD_DASH_CONFIG_NAME,
				dirtypeDashRoot,
				&cbConfig, szConfig);
	Assert(SUCCEEDED(hr));
	
	hFile = CreateFile(szConfig,
				GENERIC_WRITE, 
				0, 	// No sharing to prevent mishaps
				NULL, 
				OPEN_ALWAYS, 
				FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, 
				NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Error;
	}
	if (!WriteFile(hFile, (PBYTE)pConfig, 
				sizeof(AUTOUPD_DASH_CONFIG), &cbConfig, NULL))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Error;
	}
	SetEndOfFile(hFile);

Error:	
	CloseHandle(hFile);
	return(hr);
}

//
// Function to read the current dash update version
// from the config file
//
HRESULT XoUpdateReadDashUpdateVersion(
			PDWORD	pdwVersion
			)
{
	HRESULT	hr = S_OK;
	HANDLE	hFile = INVALID_HANDLE_VALUE;
	CHAR	szConfig[MAX_PATH];
	DWORD	cbConfig;

	// Figure out where to find the config file
	sprintf(szConfig, AUTOUPD_DVD_DASH_SOURCE_ROOT, AUTOUPD_DASH_TITLE_ID);
	strcat(szConfig, AUTOUPD_DASH_UPDATE_VERSION_NAME);

	hFile = CreateFile(szConfig,
				GENERIC_READ, 
				0, 	// No sharing to prevent mishaps
				NULL, 
				OPEN_EXISTING, 
				FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, 
				NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Error;
	}
	if (!ReadFile(hFile, (PBYTE)pdwVersion, sizeof(DWORD), &cbConfig, NULL))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Error;
	}

Error:	
	if (hFile != INVALID_HANDLE_VALUE)
		CloseHandle(hFile);
	return(hr);
}

//
// Function to replace the original dash XBE with the switcher
//
HRESULT XoUpdateInstallSwitcher(
			XONLINEDIR_TYPE	dirtype
			)
{
	HRESULT	hr = S_OK;
	CHAR	szSource[MAX_PATH];
	CHAR	szTarget[MAX_PATH];
	DWORD	cbPath;

	cbPath = MAX_PATH;
	hr = BuildTargetPath(0, 0, 0,
				AUTOUPD_DASH_SWITCHER_XBE_NAME,
				dirtype,
				&cbPath, szSource);
	if (FAILED(hr))
		return(hr);

	// Copy the switcher over, overwrite if exists
	strcpy(szTarget, AUTOUPD_DVD_DASH_ROOT_PATH);
	strcat(szTarget, AUTOUPD_DASH_UPDATE_XBE_NAME);
	if (!CopyFile(szSource, szTarget, FALSE))
		return(HRESULT_FROM_WIN32(GetLastError()));
	return(S_OK);
}

//
// Per-file task handler to count the number of files and total size
//
HRESULT CXo::UpdateDVDCountFilesContinue(
			XONLINETASK_HANDLE	hTask
			)
{
	ULARGE_INTEGER				uliAlignedSize;
	PXONLINETASK_DIRCOPY		pdircopy;
	PXONLINETASK_AUTOUPD_DVD	pautoupd;
	PAUTOUPD_PROGRESS_CONTEXT	papc;
	WIN32_FIND_DATA				*pwfd;

	Assert(hTask != NULL);

	// Locate the containing object
	pdircopy = CONTAINING_RECORD(hTask, XONLINETASK_DIRCOPY, xontaskOnFile);
	pautoupd = CONTAINING_RECORD(pdircopy, XONLINETASK_AUTOUPD_DVD, dircopy);
	papc = &pautoupd->progress;
	pwfd = &(pdircopy->dircrawl.wfd);

	// Get the context (which is a progress context) and add the values
	(papc->dwFilesTotal)++;
	uliAlignedSize.u.LowPart = pwfd->nFileSizeLow;
	uliAlignedSize.u.HighPart = pwfd->nFileSizeHigh;
	papc->uliBytesTotal.QuadPart += uliAlignedSize.QuadPart;
	
	uliAlignedSize.QuadPart += (XBOX_CLUSTER_SIZE - 1);
	uliAlignedSize.QuadPart /= XBOX_CLUSTER_SIZE;
	uliAlignedSize.QuadPart *= XBOX_CLUSTER_SIZE;
	papc->uliActualBytesRequired.QuadPart += uliAlignedSize.QuadPart;

	return(XONLINETASK_S_SUCCESS);
}

//
// Callback function used to provide progress for update process
//
HRESULT FileCopyProgressHandler(
			PVOID			pvContext,
			WIN32_FIND_DATA	*pwfd
			)
{
	HRESULT						hr = S_OK;
	PAUTOUPD_PROGRESS_CONTEXT	papc = (PAUTOUPD_PROGRESS_CONTEXT)pvContext;

	Assert(pvContext != NULL);
	Assert(pwfd != NULL);

	// Get the context (which is a progress context) and add the values
	(papc->dwFilesDone)++;
	papc->uliBytesProcessed.u.LowPart = pwfd->nFileSizeLow;
	papc->uliBytesProcessed.u.HighPart = pwfd->nFileSizeHigh;

	return(S_OK);
}

//
// State handler function for dvdupdCountFiles
//
HRESULT CXo::dvdupdCountFilesHandler(
			PXONLINETASK_AUTOUPD_DVD	pautoupd
			)
{
	HRESULT			hr = S_OK;

	// Keep pumping until the task is done
	hr = XOnlineTaskContinue((XONLINETASK_HANDLE)&(pautoupd->dircopy));
	if (XONLINETASK_STATUS_AVAILABLE(hr))
	{
		// See if it succeeded
		if (FAILED(hr))
			goto Error;

		// Just to be safe, we will wipe the destination clean
		// Remove directory alters the directory string, so we will
		// pass in a copy instead
		strcpy(pautoupd->szTemp, pautoupd->szTarget);
		hr = RemoveDirectoryInitializeContext(
					pautoupd->szTemp,
					strlen(pautoupd->szTemp),
					MAX_PATH, pautoupd->szDir, 0,
					pautoupd->xontask.hEventWorkAvailable,
					&(pautoupd->dirops));
		if (FAILED(hr))
			goto Error;

		// OK, now we know how many files/bytes we need to copy, we can 
		// now clean up the target
		pautoupd->dwState = dvdupdWipeDestination;
	}

Exit:
	return(S_OK);

Error:
	// Something failed, we will go to cleanup
	pautoupd->dwState = dvdupdCleanup;
	pautoupd->hr = hr;
	goto Exit;
}

//
// State handler function for dvdupdWipeDestination
//
HRESULT CXo::dvdupdWipeDestinationHandler(
			PXONLINETASK_AUTOUPD_DVD	pautoupd
			)
{
	HRESULT			hr = S_OK;
	PSTR			szDriveString = AUTOUPD_DVD_TITLE_ROOT_PATH;
	ULARGE_INTEGER	uliAvailable;
	ULARGE_INTEGER	uliTotal;
	DWORD			cbTemp;

	// We'll just do a format if we're updating the dash
	if (IS_UPDATING_DASH(pautoupd))
	{
		// We will format the dash partition. This does not unmount
		// the y: drive
		hr = XoUpdateFormatDashPartition();
		if (FAILED(hr))
			goto Error;

		// Create the appropriate root directory
		strcpy(pautoupd->szTemp, pautoupd->szTarget);
		cbTemp = strlen(pautoupd->szTemp);
		pautoupd->szTemp[--cbTemp] = '\0';
		if (!CreateDirectory(pautoupd->szTemp, NULL))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			goto Error;
		}

		// Now we will check to make sure we have enough disk space
		szDriveString = AUTOUPD_DVD_DASH_ROOT_PATH;
		goto CheckSpace;
	}

	// We will pump until the target directory is removed
	hr = XOnlineTaskContinue((XONLINETASK_HANDLE)&(pautoupd->dirops));
	if (XONLINETASK_STATUS_AVAILABLE(hr))
	{
		// See if it succeeded
		if (FAILED(hr))
			goto Error;

		// OK, now the destination is clean, we can then make sure the 
		// target directory is created. Create directory also does not like
		// trailing backslashes.
		strcpy(pautoupd->szTemp, pautoupd->szTarget);
		cbTemp = strlen(pautoupd->szTemp);
		pautoupd->szTemp[--cbTemp] = '\0';
		hr = CreateDirectoryInitializeContext(
					pautoupd->szTemp,
					cbTemp, 0,
					pautoupd->xontask.hEventWorkAvailable,
					&(pautoupd->dirops));
		if (FAILED(hr))
			goto Error;

CheckSpace:

		// Determine if we have sufficient space for the update. 
		if (!GetDiskFreeSpaceEx(szDriveString,
					&uliAvailable, &uliTotal, NULL))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			goto Error;
		}

		if (uliAvailable.QuadPart < pautoupd->progress.uliActualBytesRequired.QuadPart)
		{
			// Oooops, not enough disk space
			hr = HRESULT_FROM_WIN32(ERROR_DISK_FULL);
			goto Error;
		}
		
		// Next state is to create the destination
		pautoupd->dwState = dvdupdCreateTarget;
	}

Exit:
	return(S_OK);

Error:
	// Something failed, we will go to cleanup
	pautoupd->dwState = dvdupdCleanup;
	pautoupd->hr = hr;
	goto Exit;
}

//
// State handler function for dvdupdCreateTarget
//
HRESULT CXo::dvdupdCreateTargetHandler(
			PXONLINETASK_AUTOUPD_DVD	pautoupd
			)
{
	HRESULT	hr = S_OK;

	// If it's the dash we can start copying immediately
	if (IS_UPDATING_DASH(pautoupd))
		goto StartCopy;

	// Keep pumping until the task is done
	hr = XOnlineTaskContinue((XONLINETASK_HANDLE)&(pautoupd->dirops));
	if (XONLINETASK_STATUS_AVAILABLE(hr))
	{
		// See if it succeeded
		if (FAILED(hr))
			goto Error;

StartCopy:

		// OK, everything is set up, now start the update copying 
		// process
		hr = CopyDirectoryInitializeContext(
					pautoupd->szPath, 
					pautoupd->szTarget, MAX_PATH, 0,
					pautoupd->xontask.hEventWorkAvailable,
					&(pautoupd->dircopy));
		if (FAILED(hr))
			goto Error;

		// Next state is to create the destination
		pautoupd->dwState = dvdupdCopyFiles;
	}

Exit:
	return(S_OK);

Error:
	// Something failed, we will go to cleanup
	pautoupd->dwState = dvdupdCleanup;
	pautoupd->hr = hr;
	goto Exit;
}

//
// State handler function for dvdupdCopyFiles
//
HRESULT CXo::dvdupdCopyFilesHandler(
			PXONLINETASK_AUTOUPD_DVD	pautoupd
			)
{
	HRESULT	hr = S_OK;

	// Keep pumping until the task is done
	hr = XOnlineTaskContinue((XONLINETASK_HANDLE)&(pautoupd->dircopy));
	if (XONLINETASK_STATUS_AVAILABLE(hr))
	{
		// See if it succeeded
		if (FAILED(hr))
			goto Error;

		// Next state is to write the configuration
		hr = S_OK;
		pautoupd->dwState = dvdupdWriteConfig;
	}

Exit:
	return(S_OK);

Error:
	// Something failed, we will go to cleanup
	pautoupd->dwState = dvdupdCleanup;
	pautoupd->hr = hr;
	goto Exit;
}

//
// State handler function for dvdupdWriteConfig
//
HRESULT CXo::dvdupdWriteConfigHandler(
			PXONLINETASK_AUTOUPD_DVD	pautoupd
			)
{
	HRESULT			hr = S_OK;
	DGSTFILE_HEADER	dfh;
	LARGE_INTEGER	liSize;
	HANDLE			hSig = INVALID_HANDLE_VALUE;
	HANDLE			hFile = INVALID_HANDLE_VALUE;
	BYTE			rgbTitleKey[XBOX_KEY_LENGTH];
	BYTE			rgbSignature[XCALCSIG_SIGNATURE_SIZE];
	BYTE			rgbVerify[XBOX_HD_SECTOR_SIZE * 2];
	PBYTE			pbBuffer;
	PSTR			szTarget;
	DWORD			cbTarget;
	DWORD			dwDashId;
	DWORD			cbSize;
	DWORD			cbRead;
	
	XSHAHMAC_CONTEXT 			ShaHmac;
	
	XONLINETASK_CONTENT_VERIFY	verify;
	DGSTFILE_IDENTIFIER			dfi;

	// First load up the digest
	szTarget = pautoupd->szTemp;
	strcpy(szTarget, pautoupd->szTarget);
	cbTarget = strlen(szTarget);
    Assert(cbTarget + strlen(XONLINECONTENT_MANIFEST_FILE_NAME) < MAX_PATH);
	strcpy(szTarget + cbTarget, XONLINECONTENT_MANIFEST_FILE_NAME);
	hFile = CreateFile(szTarget,
				GENERIC_READ | GENERIC_WRITE, 
				0, 	// No sharing to prevent mishaps
				NULL, 
				OPEN_EXISTING, 
				FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN |
				FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING, 
				NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Error;
	}

	if (!GetFileSizeEx(hFile, &liSize))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Error;
	}
	Assert(liSize.u.HighPart == 0);

	// Get the title key that is used to sign the digest
	cbSize = XBOX_KEY_LENGTH;
	hr = XoUpdateGetRawTitleKey(pautoupd->dwTitleID, rgbTitleKey, &cbSize);
	if (FAILED(hr))
		goto Error;
	Assert(cbSize == XBOX_KEY_LENGTH);

	// Set up our dgstfile struct
	dfi.dwTitleId = pautoupd->dwTitleID;
	dfi.OfferingId = 0;
	dfi.wTitleVersionHi = pautoupd->wVersionHi;
	dfi.wTitleVersionLo = pautoupd->wVersionLo;

	// Use our tried-and-true API to verify and re-sign the update
	hr = ContentVerifyInitializeContext(hFile, 
				liSize.u.LowPart,
				rgbVerify, sizeof(rgbVerify),
				rgbTitleKey,
				XONLINECONTENT_VERIFY_FLAG_SIGN |
				XONLINECONTENT_VERIFY_FLAG_ALLOW_SAME_VERSION,
				&dfi,
				GET_DIRTYPE(pautoupd),
				NULL,
				&verify);
	if (FAILED(hr))
		goto Error;

	// Kick it off!
	hr = ContentVerifyBegin(&verify);
	if (FAILED(hr))
		goto Error;

	// Just keep it synchronous for now
	do
	{
		hr = XOnlineTaskContinue((XONLINETASK_HANDLE)&verify);
	
	} while (!XONLINETASK_STATUS_AVAILABLE(hr));

	if (FAILED(hr))
		goto Error;
	hr = S_OK;

	CloseHandle(hFile);
	hFile = INVALID_HANDLE_VALUE;

	// If this is a title update we're done!
	if (IS_UPDATING_DASH(pautoupd))
	{
		AUTOUPD_DASH_CONFIG	adc;
		
		// Finally, we clobber the original default.xbe with our switcher
		hr = XoUpdateInstallSwitcher((GET_UPDATE_DASH_ID(pautoupd)==1)?
					dirtypeDashUpdate1:dirtypeDashUpdate0);
		if (FAILED(hr))
			goto Error;

		// Then we write the configuration file to indicate the target
		// Dash directory to boot from
		adc.dwActiveDirectory = GET_UPDATE_DASH_ID(pautoupd);
		hr = XoUpdateWriteDashConfig(&adc);
		if (FAILED(hr))
			goto Error;
	}

	// Next state is to cleanup
	pautoupd->dwState = dvdupdCleanup;

Exit:
	if (hFile != INVALID_HANDLE_VALUE)
		CloseHandle(hFile);

	if (hSig != INVALID_HANDLE_VALUE)
		XCalculateSignatureEnd(hSig, (PXCALCSIG_SIGNATURE)rgbSignature);

	return(S_OK);

Error:
	// Something failed, we will go to cleanup
	pautoupd->dwState = dvdupdCleanup;
	pautoupd->hr = hr;
	goto Exit;
}

//
// State handler function for dvdupdCleanup
//
HRESULT CXo::dvdupdCleanupHandler(
			PXONLINETASK_AUTOUPD_DVD	pautoupd
			)
{
	// Just clean up the dirops and dircopy contexts
	DiropsCleanup(&pautoupd->dirops);	
	DircrawlCleanup(&pautoupd->dircopy.dircrawl);

	// We're done!
	pautoupd->dwState = dvdupdDone;

	return(S_OK);
}

//
// Array of state handler functions for DVD update
//
typedef HRESULT (CXo::*PFNAUTOUPD_DVD_HANDLER)(PXONLINETASK_AUTOUPD_DVD	pautoupd);

const PFNAUTOUPD_DVD_HANDLER CXo::s_rgpfndvdupdHandlers[] =
{
    CXo::dvdupdCountFilesHandler,
    CXo::dvdupdWipeDestinationHandler,
    CXo::dvdupdCreateTargetHandler,
    CXo::dvdupdCopyFilesHandler,
    CXo::dvdupdWriteConfigHandler,
    CXo::dvdupdCleanupHandler
};

//
// Main do work function for DVD update
//
HRESULT CXo::UpdateFromDVDContinue(
			XONLINETASK_HANDLE	hTask
			)
{
	HRESULT						hr = S_OK;
	PXONLINETASK_AUTOUPD_DVD	pautoupd = (PXONLINETASK_AUTOUPD_DVD)hTask;

	Assert(hTask != NULL);

	// Always signal the event. If we actually do any async work, we 
	// will reset the event. This makes sure we don't stall
	if (pautoupd->xontask.hEventWorkAvailable)
		SetEvent(pautoupd->xontask.hEventWorkAvailable);

	// Call the function to take care of this
	if (pautoupd->dwState < dvdupdDone)
	{
		// Call our handler to do more work
		hr = (this->*s_rgpfndvdupdHandlers[pautoupd->dwState])(pautoupd);
	}
	else if (pautoupd->dwState != dvdupdDone)
	{
		AssertSz(FALSE, "UpdateFromDVDContinue: Bad state");
		pautoupd->dwState = dvdupdDone;
		hr = E_NOTIMPL;
	}
		
	// When the next state is done, we set the flag so we don't continue.
	if (pautoupd->dwState == dvdupdDone)
	{
		// Indicate that we are done and return the final code
		hr = pautoupd->hr;
		XONLINETASK_SET_COMPLETION_STATUS(hr);
	}

	return(hr);
}

//
// Function to close the task handle
//
VOID CXo::UpdateFromDVDClose(
			XONLINETASK_HANDLE	hTask
			)
{
	PXONLINETASK_AUTOUPD_DVD	pautoupd = (PXONLINETASK_AUTOUPD_DVD)hTask;
	
	dvdupdCleanupHandler(pautoupd);
	SysFree(pautoupd);
}

//
// Function to kick off an asynchronous DVD update (Dash or title)
//
HRESULT CXo::UpdateFromDVD(
			DWORD				dwTitleID,
			WORD				wVersionHi,
			WORD				wVersionLo,
			DWORD				dwFlags,
			HANDLE				hWorkEvent,
			XONLINETASK_HANDLE	*phTask
			)
{
	HRESULT						hr = S_OK;
	PXONLINETASK_AUTOUPD_DVD	pautoupd = NULL;
	DWORD						dwTemp;

	Assert(phTask != NULL);

	// Allocate the task context
	pautoupd = (PXONLINETASK_AUTOUPD_DVD)SysAlloc(sizeof(XONLINETASK_AUTOUPD_DVD), PTAG_XONLINETASK_AUTOUPD_DVD);
	if (!pautoupd)
		return(E_OUTOFMEMORY);

	// Initialization
	ZeroMemory(pautoupd, sizeof(XONLINETASK_AUTOUPD_DVD));
	TaskInitializeContext(&pautoupd->xontask);
	pautoupd->xontask.pfnContinue = UpdateFromDVDContinue;
	pautoupd->xontask.pfnClose = UpdateFromDVDClose;
	pautoupd->xontask.hEventWorkAvailable = hWorkEvent;
	pautoupd->hr = S_OK;
	pautoupd->dwState = dvdupdCountFiles;
	pautoupd->dwTitleID = dwTitleID;
	pautoupd->dwFlags = dwFlags;
	pautoupd->wVersionHi = wVersionHi;
	pautoupd->wVersionLo = wVersionLo;

	// Set up the subtask to count files
	TaskInitializeContext(&pautoupd->dircopy.xontaskOnFile);
	pautoupd->dircopy.xontaskOnFile.pfnContinue = UpdateDVDCountFilesContinue;
	pautoupd->dircopy.xontaskOnFile.hEventWorkAvailable = hWorkEvent;

	// Compute the source and destination paths
	if (IS_UPDATING_DASH(pautoupd))
	{
		dwTemp = sprintf(pautoupd->szPath, 
					AUTOUPD_DVD_DASH_SOURCE_PATH, AUTOUPD_DASH_TITLE_ID);
		dwTemp = sprintf(pautoupd->szTarget, 
					AUTOUPD_DASH_TARGET_PATH,
					GET_UPDATE_DASH_ID(pautoupd) + '0');
	}
	else
	{
        dwTemp = sprintf(pautoupd->szPath, AUTOUPD_DVD_TITLE_SOURCE_PATH, m_dwTitleId);
		strcpy(pautoupd->szTarget, AUTOUPD_TITLE_TARGET_PATH);
	}

	// Set up the dircrawl context to count the number of files to install
	hr = DircrawlInitializeContext(
				pautoupd->szPath, NULL, MAX_PATH, 0, NULL, 
				(XONLINETASK_HANDLE)&(pautoupd->dircopy.xontaskOnFile),
				hWorkEvent,
				&(pautoupd->dircopy.dircrawl));
	if (FAILED(hr))
		goto Error;

	// Return the task handle
	*phTask = (XONLINETASK_HANDLE)pautoupd;

Exit:
	return(hr);

Error:
	if (pautoupd)
		SysFree(pautoupd);
	goto Exit;
}

//
// Function to update dash from DVD
//
HRESULT CXo::UpdateDashFromDVD(
			WORD				wVersionHi,
			WORD				wVersionLo,
			DWORD				dwDashId,
			HANDLE				hWorkEvent,
			XONLINETASK_HANDLE	*phTask
			)
{
    Assert((dwDashId == 0) || (dwDashId == 1));
	//Assert(dwVersion > 0);
	Assert(phTask != NULL);

	// Make sure the dash partition is mounted
	XoUpdateMountDashPartition();

	// Also indicate that this is a dash update
	dwDashId |= XONLINEAUTOUPD_FLAG_DASH_UPDATE;
	return(UpdateFromDVD(AUTOUPD_DASH_TITLE_ID, 
				wVersionHi, wVersionLo, dwDashId, hWorkEvent, phTask));
}

//
// Function to update title from DVD
//
HRESULT CXo::UpdateTitleFromDVD(
			DWORD				dwTitleID,
			WORD				wVersionHi,
			WORD				wVersionLo,
			HANDLE				hWorkEvent,
			XONLINETASK_HANDLE	*phTask
			)
{
	//Assert(dwVersion > 0);
	Assert(phTask != NULL);
	
	return(UpdateFromDVD(dwTitleID, 
				wVersionHi, wVersionLo, 0, hWorkEvent, phTask));
}

//
// Function to return progress for DVD auotupdate
//
HRESULT CXo::UpdateFromDVDGetProgress(
			XONLINETASK_HANDLE	hTask,
			DWORD				*pdwPercentDone,
			ULARGE_INTEGER		*puliNumerator,
			ULARGE_INTEGER		*puliDenominator
			)
{
	PXONLINETASK_AUTOUPD_DVD	pautoupd = (PXONLINETASK_AUTOUPD_DVD)hTask;
	PAUTOUPD_PROGRESS_CONTEXT	pprogress = &(pautoupd->progress);
	
	Assert(hTask != NULL);

	// We need to grab the processed count from pdircopy
	pprogress->uliBytesProcessed.QuadPart = pautoupd->dircopy.uliBytesCopied.QuadPart;
	
	if (puliNumerator)
		puliNumerator->QuadPart = pprogress->uliBytesProcessed.QuadPart;
	if (puliDenominator)
		puliDenominator->QuadPart = pprogress->uliBytesTotal.QuadPart;
	if (pdwPercentDone)
	{
		if (pprogress->uliBytesTotal.QuadPart != 0)
		{
			*pdwPercentDone = 
				(DWORD)((pprogress->uliBytesProcessed.QuadPart * 100)/
					pprogress->uliBytesTotal.QuadPart);
			if (*pdwPercentDone > 100)
				*pdwPercentDone = 100;
		}
		else
			*pdwPercentDone = 0;
	}
	return(S_OK);
}

//
// Function to reboot into the update for the specified dirtype
//
VOID XoUpdateReboot(
			DWORD			dwTitleId,
			XONLINEDIR_TYPE	dirtype
			)
{
	DWORD	dwError;
	DWORD	dwType;
	CHAR	szPath[MAX_PATH];
	CHAR	chDir;

	LAUNCH_DATA	ld;
	PLAUNCH_DATA pld = &ld;

	dwError = XGetLaunchInfo(&dwType, &ld);
	if (dwError != ERROR_SUCCESS)
	{
		dwType = LDT_NONE;
		pld = NULL;
	}

	switch (dirtype)
	{
	case dirtypeTitleUpdate:

        Assert(dwTitleId != AUTOUPD_DASH_TITLE_ID);
		sprintf(szPath, TitleRebootPath, dwTitleId);

		XWriteTitleInfoAndReboot(
				AUTOUPD_UPDATE_XBE_NAME, szPath, dwType, dwTitleId, pld);
		break;

	case dirtypeDashUpdate0:
	case dirtypeDashUpdate1:
	
		chDir = (dirtype == dirtypeDashUpdate1)?'1':'0';
        Assert(dwTitleId == AUTOUPD_DASH_TITLE_ID);
		sprintf(szPath, DashRebootPath, chDir);

		XWriteTitleInfoAndReboot(
				AUTOUPD_DASH_UPDATE_XBE_NAME, szPath, dwType, dwTitleId, pld);
		break;

	default:
		Assert(FALSE);
		goto Exit;
	}
				

Exit:				
	return;
}

//
// Function to load the Header and Cert information from an XBE
//
HRESULT XoUpdateLoadXBEInfo(
			PSTR					szXBEPath,
			PXBEIMAGE_HEADER		pxbeh,
			PXBEIMAGE_CERTIFICATE	pxbec
			)
{
	HRESULT	hr = S_OK;
	HANDLE	hFile = INVALID_HANDLE_VALUE;
	DWORD	cbSize;

	hFile = CreateFile(szXBEPath,
				GENERIC_READ, 
				0, 	// No sharing to prevent mishaps
				NULL, 
				OPEN_EXISTING, 
				FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, 
				NULL);
	if (hFile == INVALID_HANDLE_VALUE)
		goto Error;

	// Read the image header
	if (!ReadFile(hFile, (PBYTE)pxbeh, sizeof(XBEIMAGE_HEADER), &cbSize, NULL))
		goto Error;
	if (cbSize != sizeof(XBEIMAGE_HEADER))
		goto InvalidData;

	// Read the image cert
	if (pxbeh->Certificate < pxbeh->BaseAddress)
		goto InvalidData;
	cbSize = (PBYTE)(pxbeh->Certificate) - (PBYTE)(pxbeh->BaseAddress);
	if (!SetFilePointer(hFile, cbSize, NULL, FILE_BEGIN))
		goto Error;
	if (!ReadFile(hFile, (PBYTE)pxbec, sizeof(XBEIMAGE_CERTIFICATE), &cbSize, NULL))
		goto Error;
	if (cbSize != sizeof(XBEIMAGE_CERTIFICATE))
		goto InvalidData;

Exit:
	if (hFile != INVALID_HANDLE_VALUE)
		CloseHandle(hFile);

	return(hr);

InvalidData:
	SetLastError(ERROR_INVALID_DATA);

Error:
	hr = HRESULT_FROM_WIN32(GetLastError());
	goto Exit;
}

//
// Function to see if an update is present, if so, validates the digest
// and XBE cert. 
//
HRESULT XoUpdateDetectAndVerify(
			DWORD			dwTitleId,
			WORD			wVersionHi,
			WORD			wVersionLo,
			XONLINEDIR_TYPE	dirtype,
			DWORD			dwFlags
			)
{
	HRESULT	hr = S_OK;
	DWORD	dwVersion;
	DWORD	cbSize;
	CHAR	szPath[MAX_PATH];

	DGSTFILE_IDENTIFIER			dfi;
	XBEIMAGE_HEADER				xbeh;
	XBEIMAGE_CERTIFICATE		xbec;

	// Build the digest path
	cbSize = MAX_PATH;
	hr = BuildTargetPath(dwTitleId, 0, 0,
				XONLINECONTENT_MANIFEST_FILE_NAME,
				dirtype, &cbSize, szPath);
	if (FAILED(hr))
		goto NoUpdate;

	// First, validate the digest
	dfi.dwTitleId = dwTitleId;
	dfi.OfferingId = 0;
	dfi.wTitleVersionHi = wVersionHi; 
	dfi.wTitleVersionLo = wVersionLo;
	dwVersion = MAKE_DWORD_VERSION(wVersionHi, wVersionLo);

	// Verify the digest
	hr = DigestVerifySynchronous(szPath, dirtype, &dfi, dwFlags, NULL);
	if (FAILED(hr))
		goto NoUpdate;

	// The digest checks out, now let's be paranoid and make sure the info
	// in the XBE cert also checks out.
	cbSize = MAX_PATH;
	hr = BuildTargetPath(dwTitleId, 0, 0,
				(dirtype==dirtypeTitleUpdate)?
						AUTOUPD_UPDATE_XBE_NAME:AUTOUPD_DASH_UPDATE_XBE_NAME,
				dirtype, &cbSize, szPath);
	if (FAILED(hr))
		goto NoUpdate;
	
	// Load the XBE header info
	hr = XoUpdateLoadXBEInfo(szPath, &xbeh, &xbec);
	if (FAILED(hr))
		goto NoUpdate;

	// Make sure the data checks out
	if (xbec.TitleID != dwTitleId)
		goto NoUpdate;
	if (xbec.Version < dwVersion)
		goto NoUpdate;

	// Everything checks out. This update is valid
	return(S_OK);
	
NoUpdate:
	return(HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
}

//
// Function to perform the Dash switcher logic
//
VOID XoUpdateDashSwitcherLogic()
{
	XONLINEDIR_TYPE		dirtype;
	AUTOUPD_DASH_CONFIG	adc;
	DWORD				dwTitleId;
	DWORD				cRetry;
	WORD				wVersionHi;
	WORD				wVersionLo;

	dwTitleId = XeImageHeader()->Certificate->TitleID;
    Assert(dwTitleId == AUTOUPD_DASH_TITLE_ID);

	// This is the dash, we need to mount the dash partition
	XoUpdateMountDashPartition();

	// Now query the config file to see which directory to boot from
	adc.dwActiveDirectory = 0;
	XoUpdateReadDashConfig(&adc, FALSE);

	wVersionHi = (WORD)(XeImageHeader()->Certificate->Version >> 16);
	wVersionLo = (WORD)(XeImageHeader()->Certificate->Version & 0xffff);

	// We will retry both partitions as a best-effort
	for (cRetry = 0; cRetry < 2; cRetry++)
	{
		// Set the dirtype
		dirtype = (adc.dwActiveDirectory==1)?
						dirtypeDashUpdate1:dirtypeDashUpdate0;

		// Reboot into that update if its valid and at least as new as the
		// switcher version
		if (SUCCEEDED(XoUpdateDetectAndVerify(
						dwTitleId, wVersionHi, wVersionLo, dirtype, 
						XONLINECONTENT_VERIFY_FLAG_ALLOW_SAME_VERSION)))
		{
			XoUpdateReboot(dwTitleId, dirtype);
		}

		// If we come here, the first dash is somehow corrupt or invalid
		// We will mark the other partition as active and retry that. If
		// the other one fails as well, then we will have to show the UFM.
		adc.dwActiveDirectory++;
		adc.dwActiveDirectory &= 1;

		XoUpdateWriteDashConfig(&adc);
	}

	// This is bad, we will need to show the UFM here ...
	// BUGBUG: Need to display UFM

	return;
}

// ==============================================================
//
// The following specia section of code should only be enabled for 
// early online titles that have the dash update bundled in their 
// title DVD. We should disable this code when we stop bundling the
// dash update inside titles.
//

#ifdef DASH_UPDATE_IN_TITLE

#define AUTOUPD_DVD_DASH_RETRY_LIMIT		5
#define AUTOUPD_DVD_DASH_COUNTER_FILE_MASK	"t:\\$u????????.?"
#define AUTOUPD_DVD_DASH_COUNTER_FILE_PATH	"%s$u%08x.%c"

//
// Function to check whether the specified number of DVD dash update
// retries (and failures) have occurred. Returns S_OK if the number
// of retries is less than the hard limit, otherwise it returns a failure
// HRESULT
//
HRESULT CXo::UpdateCheckAndBumpRetryCount(
			DWORD	dwUpdateVersion
			)
{
	HRESULT			hr = S_OK;
	HANDLE			hFind = INVALID_HANDLE_VALUE;
	WIN32_FIND_DATA	wfd;
	DWORD			dwCounterVersion;
	CHAR			szPath[MAX_PATH];
	CHAR			szPathNew[MAX_PATH];
	CHAR			chCount = '1';
	CHAR			*pch;

	hFind = FindFirstFile(AUTOUPD_DVD_DASH_COUNTER_FILE_MASK, &wfd);
	if (hFind != INVALID_HANDLE_VALUE)
	{
		FindClose(hFind);

		// Build the full path to the counter file
		strcpy(szPath, AUTOUPD_DVD_TITLE_ROOT_PATH);
		strcat(szPath, wfd.cFileName);
		
		// First, make sure the update version supplied matches the
		// one in the counter file name. If not, this is a different 
		// update and we refresh the coutner file.
		pch = strchr(wfd.cFileName, '.');
		if (!pch)
			goto Refresh;
		*pch = '\0';
		strcpy(szPathNew, wfd.cFileName + 2);
		*pch = '.';
		
		if (FAILED(ConvertToTitleId(szPathNew, &dwCounterVersion)))
			goto Refresh;
		if (dwCounterVersion != dwUpdateVersion)
			goto Refresh;
		
		// See what the counter says
		chCount = wfd.cFileName[strlen(wfd.cFileName) - 1] - '0';
		if (chCount >= AUTOUPD_DVD_DASH_RETRY_LIMIT)
			return(E_FAIL);

		// OK, we still have quota left, bump it up ...
		chCount += '1';
		sprintf(szPathNew, AUTOUPD_DVD_DASH_COUNTER_FILE_PATH, 
					AUTOUPD_DVD_TITLE_ROOT_PATH, dwUpdateVersion, chCount);
		MoveFile(szPath, szPathNew);

		goto Exit;
	}

Create:

	// Create a new counter file, starting at 1
	sprintf(szPath, AUTOUPD_DVD_DASH_COUNTER_FILE_PATH, 
				AUTOUPD_DVD_TITLE_ROOT_PATH, dwUpdateVersion, chCount);
	hFind = CreateFile(szPath,
				GENERIC_WRITE, 
				0, 	// No sharing to prevent mishaps
				NULL, 
				CREATE_ALWAYS, 
				FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, 
				NULL);
	if (hFind != INVALID_HANDLE_VALUE)
		CloseHandle(hFind);

Exit:
	return(S_OK);

Refresh:

	DeleteFile(szPath);
	goto Create;
}

//
// Function to delete the counter file
//
VOID CXo::UpdateResetRetryCount()
{
	HANDLE			hFind = INVALID_HANDLE_VALUE;
	WIN32_FIND_DATA	wfd;
	CHAR			szPath[MAX_PATH];

	hFind = FindFirstFile(AUTOUPD_DVD_DASH_COUNTER_FILE_MASK, &wfd);
	if (hFind != INVALID_HANDLE_VALUE)
	{
		FindClose(hFind);

		// Build the full path to the counter file
		strcpy(szPath, AUTOUPD_DVD_TITLE_ROOT_PATH);
		strcat(szPath, wfd.cFileName);
		DeleteFile(szPath);
	}
}

const CHAR             g_szTitleUpdater[] = "d:\\update.xbe";

//
// Function to detect whether a dash update is needed on the current box.
// This function will only be called from titles that ship with the new
// dash packed in to the title disk
//
VOID CXo::UpdateDashIfNecessary()
{
	HRESULT					hr = S_OK;
	CHAR					szPath[MAX_PATH];
	DWORD					dwError;
	DWORD					cbSize;
	DWORD					dwCurrentVersion;
	DWORD					dwUpdateVersion;
	WORD					wVersionHi;
	WORD					wVersionLo;
	XONLINEDIR_TYPE			dirtype;
	XBEIMAGE_HEADER			xbeh;
	XBEIMAGE_CERTIFICATE	xbec;
	AUTOUPD_DASH_CONFIG		adc;
	XONLINETASK_HANDLE		hTask = NULL;
	LAUNCH_UPDATE_INFO		lui;
	
	// First, we need to make sure the dash is mounted properly
	XoUpdateMountDashPartition();

	// Now figure out what version of the dash we have on the DVD update
	hr = XoUpdateReadDashUpdateVersion(&dwUpdateVersion);
	if (FAILED(hr))
		goto Exit;

	MAKE_COMPOSITE_VERSION(dwUpdateVersion, &wVersionHi, &wVersionLo);

	// Now figure out the current dash version on the hard disk
	cbSize = MAX_PATH;
	hr = BuildTargetPath(AUTOUPD_DASH_TITLE_ID, 0, 0,
				AUTOUPD_DASH_UPDATE_XBE_NAME,
				dirtypeDashRoot,
				&cbSize, szPath);
	if (FAILED(hr))
		goto Exit;

	// Load the XBE header info for the current dash XBE
	hr = XoUpdateLoadXBEInfo(szPath, &xbeh, &xbec);
	if (FAILED(hr))
	{
		// This is the offline dash or the update was not complete
		// either case, just reinstall
		dwCurrentVersion = 0;
	}
	else
	{
		if (xbec.TitleID != AUTOUPD_DASH_TITLE_ID)
			goto Exit;
		dwCurrentVersion = xbec.Version;
	}

	// If the current version is zero, then this is the original 
	// dash and we will update regardless.
	if (dwCurrentVersion > AUTOUPD_OFFLINE_DASH_VERSION)
	{
		// OK, we know dwCurrent is the version of the switcher XBE,
		// now we go in and find out the version of the actual dash XBE
		// Note the if we fail to read the config, we will assume the dash
		// is broken and we will force an update.
		hr = XoUpdateReadDashConfig(&adc, FALSE);
		if (FAILED(hr))
			goto ForceUpdate;

		dirtype = (adc.dwActiveDirectory == 1)?
					dirtypeDashUpdate1:dirtypeDashUpdate0;

		// OK, now we run a check on the integrity of the current 
		// dash installation. If the dash installation is valid and the
		// installed version is GREATER THAN OR EQUAL TO the DVD update
		// version, then we will NOT proceed with the update.
		hr = XoUpdateDetectAndVerify(AUTOUPD_DASH_TITLE_ID, 
					wVersionHi, wVersionLo, dirtype, 
					XONLINECONTENT_VERIFY_FLAG_ALLOW_SAME_VERSION);
		if (SUCCEEDED(hr))
			goto Exit;

		// Ooops, the update is not current, we will update the dash ...
	}

ForceUpdate:

	// Now we know the update verion on the DVD, and we know that we will 
	// have to update the dash. We will then see if we have retried and 
	// failed too many times. If so, then we will skip further attempts 
	// to update (they will have to use another disk and try again)
	//
	// Note: if we enable this code, the title will need to detect
	// successful update and call UpdateResetRetryCount() or subsequent
	// updates will be affected
	//
	//if (FAILED(UpdateCheckAndBumpRetryCount(dwUpdateVersion)))
	//	goto Exit;

	TraceSz(Warning, "Beginning DVD Dash Update\n");

	// Set up the launch info (don't touch the dash params!
	lui.dwTitleId = AUTOUPD_DASH_TITLE_ID;
	lui.dwBaseVersion = dwCurrentVersion;
	lui.dwUpdateFlags = LAUNCH_UPDATE_FLAG_USE_DEFAULT_KEYS;

	sprintf(lui.szUpdatePath, "d:\\$u\\%08x\\update.xcp", AUTOUPD_DASH_TITLE_ID);

	// Reboot; this shouldn't come back
	// Always use the updater in the DVD because it is newer
	dwError = RebootToUpdaterWhilePreservingDDrive(g_szTitleUpdater, &lui);
	hr = HRESULT_FROM_WIN32(dwError);

Exit:
	return;
}

#endif

//
// Function to detect the presence of a newer version of the current
// title. If so, this will reboot to that version.
//
// Note: if the versions are the same, this will NOT reboot.
//

int XoUpdateRebootIfNecessary()
{
	NTSTATUS	Status;
	DWORD		dwTitleId;
	WORD		wVersionHi;
	WORD		wVersionLo;

	// The dash is special and we don't handle the reboot here
    dwTitleId = XeImageHeader()->Certificate->TitleID;
	if (dwTitleId == AUTOUPD_DASH_TITLE_ID)
		return(0);

	// Call the catch-all function to see if we need to reboot
	wVersionHi = (WORD)(XeImageHeader()->Certificate->Version >> 16);
	wVersionLo = (WORD)(XeImageHeader()->Certificate->Version & 0xffff);
	if (SUCCEEDED(XoUpdateDetectAndVerify(dwTitleId, wVersionHi, wVersionLo, dirtypeTitleUpdate, 0)))
	{
		XoUpdateReboot(dwTitleId, dirtypeTitleUpdate);
	}

	// If we come back here, this means either we do not have an update
	// or the update is somehow invalid. We'll assume that this is the
	// latest XBE.

#ifndef DEVKIT
	// The D: drive might have been mapped to t:\$u directory, which may
	// spook off titles. We map this back to the DVD/CD device.
	Status = IoDeleteSymbolicLink((POBJECT_STRING)&DDrive);
	Status = IoCreateSymbolicLink((POBJECT_STRING)&DDrive,
							(POBJECT_STRING) &CdDevice);
#endif

	return(0);
}

#pragma data_seg(".CRT$RIB")
static int (*_update)(void) = XoUpdateRebootIfNecessary;
#pragma data_seg()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xprof\xprofile.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    xprofile.c

Abstract:

    Kernel profiler functions

--*/

#ifdef _XBOX_ENABLE_PROFILING

#include "ntos.h"
#include "xprofp.h"

//
// Global data structures maintained by the profiler
//
XProfpGlobals XProfpData;

XProfpGlobals* XProfpGetData() {
    return &XProfpData;
}


VOID __declspec(naked) __stdcall
_CAP_Start_Profiling(
    VOID* caller,
    VOID* callee
    )

/*++

Routine Description:

    Just before a function is about to be called

Arguments:

    caller - Specifies the caller function
    callee - Specifies the called function

Return Value:

    NONE

--*/

{
    /*
        ULONG* buf;

    loop:
        buf = XProfpData.bufnext
        if buf >= XProfpData.bufend, return
        atomic incremnt of XProfpData.bufnext by 4 ULONGs
        if failed, goto loop

        buf[0] = timestamp-high
        buf[1] = timestamp-low
        buf[2] = caller
        buf[3] = callee

     */

    __asm {
        push    eax
        push    ecx
        push    edx
        lea     ecx, XProfpData
        mov     eax, [ecx]          ; eax = XProfpData.bufnext
    loop1:
        cmp     eax, [ecx+4]        ; XProfpData.bufnext >= XProfpData.bufend?
        jae     ret1
        lea     edx, [eax+16]       ; XProfpData.bufnext += 4
        cmpxchg [ecx], edx
        jnz     loop1

        mov     ecx, eax
        rdtsc
        mov     [ecx], edx          ; timestamp-high
        mov     [ecx+4], eax        ; timestamp-low
        mov     eax, [esp+16]       ; caller - 3 pushes + return address
        mov     [ecx+8], eax
        mov     eax, [esp+20]       ; callee
        mov     [ecx+12], eax

    ret1:
        pop     edx
        pop     ecx
        pop     eax
        ret     8
    }
}


VOID __declspec(naked) __stdcall
_CAP_End_Profiling(
    VOID* caller
    )
/*++

Routine Description:

    Just after a function call is made

Arguments:

    caller - Specifies the caller function

Return Value:

    NONE

--*/

{
    // Same logic as above, except the record is smaller by 1 ULONG

    __asm {
        push    eax
        push    ecx
        push    edx
        lea     ecx, XProfpData
        mov     eax, [ecx]          ; eax = XProfpData.bufnext
    loop1:
        cmp     eax, [ecx+4]        ; XProfpData.bufnext >= XProfpData.bufend?
        jae     ret1
        lea     edx, [eax+12]       ; XProfpData.bufnext += 3
        cmpxchg [ecx], edx
        jnz     loop1

        mov     ecx, eax
        rdtsc
        bts     edx, 29             ; timestamp-high | XPROFREC_CALL_END
        mov     [ecx], edx
        mov     [ecx+4], eax        ; timestamp-low
        mov     eax, [esp+16]       ; caller
        mov     [ecx+8], eax

    ret1:
        pop     edx
        pop     ecx
        pop     eax
        ret     4
    }
}


VOID __declspec(naked) __stdcall
XProfpEmitControlRecord(
    ULONG type,
    ULONG param
    )

/*++

Routine Description:

    Emit a CAP control record

Arguments:

    type - Specifies the control record type
    param - Type-specific parameter

Return Value:

    NONE

--*/

{
    // Identical to _CAP_Start_Profiling except
    // the record is marked as XPROFREC_CONTROL.

    __asm {
        push    eax
        push    ecx
        push    edx
        lea     ecx, XProfpData
        mov     eax, [ecx]          ; eax = XProfpData.bufnext
    loop1:
        cmp     eax, [ecx+4]        ; XProfpData.bufnext >= XProfpData.bufend?
        jae     ret1
        lea     edx, [eax+16]       ; XProfpData.bufnext += 4
        cmpxchg [ecx], edx
        jnz     loop1

        mov     ecx, eax
        rdtsc
        or      edx, XPROFREC_CONTROL
        mov     [ecx], edx          ; timestamp-high
        mov     [ecx+4], eax        ; timestamp-low
        mov     eax, [esp+16]       ; caller - 3 pushes + return address
        mov     [ecx+8], eax
        mov     eax, [esp+20]       ; callee
        mov     [ecx+12], eax

    ret1:
        pop     edx
        pop     ecx
        pop     eax
        ret     8
    }
}


//
// Default profiling data buffer size is 32MB
//
#define XPROF_DEFAULT_BUFSIZE 32
#define XProfpCalcBufferSize(param) \
        ((((param) & 0xffff) ? ((param) & 0xffff) : XPROF_DEFAULT_BUFSIZE) * 1024*1024)

//
// Acquire and release global access lock
//
#define XProfpLock() InterlockedCompareExchange(&XProfpData.lock, 1, 0)
#define XProfpUnlock() (XProfpData.lock = 0)

//
// Disable / enable interrupts
//
#define XProfpDisableInterrupts() KfRaiseIrql(HIGH_LEVEL)
#define XProfpRestoreInterrupts(irql) KfLowerIrql(irql)

//
// Thread context switch notification routine
//
extern PSWAP_CONTEXT_NOTIFY_ROUTINE KiDbgCtxSwapNotify;
PSWAP_CONTEXT_NOTIFY_ROUTINE XProfpSavedCtxSwapNotify;

VOID FASTCALL
XProfpThreadSwitchNotifyCallback(
    HANDLE OldThreadId,
    HANDLE NewThreadId
    )
{
    XProfpEmitControlRecord(XPROF_THREAD_SWITCH, (ULONG) NewThreadId);

    // Call the original notification function
    if (XProfpSavedCtxSwapNotify) {
        (*XProfpSavedCtxSwapNotify)(OldThreadId, NewThreadId);
    }
}

//
// DPC dispatch notification routine
//
extern PVOID KiDpcDispatchNotify;

VOID FASTCALL
XProfpDpcDispatchNotifyCallback(
    VOID* dpcproc,
    ULONG param
    )
{
    XProfpEmitControlRecord(XPROF_DPC_BEGIN+param, (ULONG) dpcproc);
}

NTSTATUS
XProfpControl(
    ULONG Action,
    ULONG Param
    )

/*++

Routine Description:

    Profiler control function

Arguments:

    Action - Specify the control action
    Param - Action-specific parameter

Return Value:

    Status code

--*/

{
    KIRQL irql;
    ULONG tid;
    NTSTATUS status = STATUS_SUCCESS;

    switch (Action) {
    case XPROF_START:
    case XPROF_STOP:
        if (XProfpLock() != 0) {
            // Simple-minded locking mechanism: prevent multiple threads
            // from calling  start/stop/resume at the same time
            status = STATUS_DEVICE_BUSY;
            break;
        }

        tid = (ULONG) PsGetCurrentThread()->UniqueThread;

        if (Action == XPROF_START) {
            // Start a new profiling session

            //
            // Clear the existing profiling data buffer first
            //
            ULONG oldsize = XProfpCalcBufferSize(XProfpData.start_param);
            ULONG newsize = XProfpCalcBufferSize(Param);
            ULONG* buf = XProfpData.bufstart;
                
            if (buf) {
                if (!XProfpData.bufnext_stopped) {
                    // There is already an active profiling session.
                    XProfpUnlock();
                    return STATUS_INVALID_PARAMETER;
                }

                irql = XProfpDisableInterrupts();

                XProfpData.bufstart = 
                XProfpData.bufend = 
                XProfpData.bufnext = 
                XProfpData.bufnext_stopped = NULL;
                XProfpData.start_type = 
                XProfpData.start_param = 0;

                KiDbgCtxSwapNotify = XProfpSavedCtxSwapNotify = NULL;
                KiDpcDispatchNotify = NULL;
                XProfpRestoreInterrupts(irql);

                // If the old size and the new size are the same,
                // then we'll reuse the same buffer. Otherwise,
                // we'll free the old buffer first.
                if (oldsize != newsize) {
                    MmDbgFreeMemory(buf, oldsize);
                    buf = NULL;
                }
            }

            //
            // Allocate memory for the new profiling data buffer
            //
            if (!buf) buf = (ULONG*) MmDbgAllocateMemory(newsize, PAGE_READWRITE|PAGE_WRITECOMBINE);
            if (buf == NULL) {
                status = STATUS_NO_MEMORY;
            } else {
                irql = XProfpDisableInterrupts();

                XProfpData.bufstart = (ULONG*) buf;
                XProfpData.bufnext = XProfpData.bufstart;
                XProfpData.bufend = (ULONG*) ((UCHAR*) buf + newsize - XPROFREC_MAXSIZE);
                XProfpData.start_param = Param;
                XProfpData.start_type = Action;

                XProfpEmitControlRecord(XPROF_START, tid);
                XProfpSavedCtxSwapNotify = KiDbgCtxSwapNotify;
                KiDbgCtxSwapNotify = XProfpThreadSwitchNotifyCallback;
                if (Param & XPROF_DPC_ENABLED)
                    KiDpcDispatchNotify = XProfpDpcDispatchNotifyCallback;
                XProfpRestoreInterrupts(irql);
            }
        } else {
            // Stop the current profiling session
            
            if (!XProfpData.bufstart) {
                // No profiling session
                status = STATUS_INVALID_PARAMETER;
            } else if (XProfpData.bufnext_stopped) {
                // Profiling session already stopped
                //  do nothing
            } else {
                irql = XProfpDisableInterrupts();
                KiDbgCtxSwapNotify = XProfpSavedCtxSwapNotify;
                XProfpSavedCtxSwapNotify = NULL;
                KiDpcDispatchNotify = NULL;

                XProfpEmitControlRecord(XPROF_STOP, tid);

                XProfpData.bufnext_stopped = XProfpData.bufnext;
                XProfpData.bufnext = XProfpData.bufend;

                XProfpRestoreInterrupts(irql);
            }
        }

        XProfpUnlock();
        break;

    case XPROF_COMMENT:
        XProfpEmitControlRecord(Action, Param);
        break;

    default:
        status = STATUS_NOT_IMPLEMENTED;
        break;
    }

    return status;
}

#endif // _XBOX_ENABLE_PROFILING
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\accounts.cpp ===
/*
 *  accounts.cpp
 *
 *  XBOX Online Service.  Copyright (c) Microsoft Corporation.
 *  
 *  Author: Steve Lamb (slamb), Ben Zotto (benzotto)
 *  Created: 12/20/01
 *
 */     

#include "xonp.h"
#include "xonlinep.h"
#include "xonver.h"

#define XOACCTS_TIMEOUT 60000
#define XOACCTS_WORKBUFFER_SIZE 512

struct ACCT_XRL
{
    DWORD dwService;                  // Service ID number
    CHAR * szUrl;                     // relative URL of ISAPI front door
    CHAR * szContentType;             // Service content type
    DWORD cbContentType;              // Size of the service content type
};

const ACCT_XRL g_AccountXrls[] =
{
    { XONLINE_USER_ACCOUNT_SERVICE, "/xuacs/verifynickname.ashx",   "Content-Type: xon/5\r\n", 21 },
    { XONLINE_USER_ACCOUNT_SERVICE, "/xuacs/tempcreateacct.ashx",   "Content-Type: xon/5\r\n", 21 },
    { XONLINE_USER_ACCOUNT_SERVICE, "/xuacs/getlockoutinfo.ashx",   "Content-Type: xon/5\r\n", 21 },
    { XONLINE_USER_ACCOUNT_SERVICE, "/xuacs/gettags.ashx",          "Content-Type: xon/5\r\n", 21 },
    { XONLINE_USER_ACCOUNT_SERVICE, "/xuacs/reservename.ashx",      "Content-Type: xon/5\r\n", 21 },
    { XONLINE_USER_ACCOUNT_SERVICE, "/xuacs/createacct.ashx",       "Content-Type: xon/5\r\n", 21 }
};

enum XRLS
{
    verifyNickname,
    tempCreate,
    getLockoutInfo,
    getTags,
    reserveName,
    createAccount
};


HRESULT
CXo::XOnlineVerifyNickname( LPCWSTR lpNickname, 
                            HANDLE hWorkEvent,
                            XONLINETASK_HANDLE *phTask )
{
    return XONLINETASK_S_SUCCESS;
}




// ********************************************************
//
// _XOnlineAccountTempCreate
//
// ********************************************************


enum CREATE_TEMP_ACCT_STATE
{
    xoacctCreateUploadPump,
    xoacctSaveAcct,
    xoacctCreateDone
};


struct XO_CREATE_ACCT_TASK
{
    XONLINETASK_CONTEXT             Context;            // this task context
    XRL_ASYNC_EXTENDED              XrlContext;         // upload context
    
    CREATE_TEMP_ACCT_STATE          State;              // current task state

    XONLINEP_USER                   Request;	        // user to create
	XONLINEP_USER                   User;               // created user on success
    BYTE                            rgbBuffer[XOACCTS_WORKBUFFER_SIZE];

    HRESULT                         hrFinal;            // final hresult
};





//---------------------------------------------------------
// _XOnlineAccountTempCreate
//
//   temporary method to create xonline accounts.  
//   Only the users name/kingdom is used.   if the async
//   task ends successfully, call _XOnlineAccountTempGetResults
//   to retrive the new user struct. 
//
HRESULT
CXo::_XOnlineAccountTempCreate(PXONLINE_USER pUser, HANDLE hWorkEvent, XONLINETASK_HANDLE *phTask)
{
    XO_CREATE_ACCT_TASK* pTaskExt = NULL;

    
    XoEnter("_XOnlineAccountTempCreate");
    XoCheck(pUser != NULL);
    XoCheck(phTask != NULL);

    HRESULT hr = XONLINETASK_S_RUNNING;
  
    if (strlen(pUser->name) > XONLINE_MAX_NAME_LENGTH || strlen(pUser->kingdom) > XONLINE_MAX_KINGDOM_LENGTH)
    {
        hr = XONLINE_E_ACCOUNTS_INVALID_USER;
        goto Cleanup;
    }

    pTaskExt = (XO_CREATE_ACCT_TASK*)SysAllocZ(sizeof(XO_CREATE_ACCT_TASK), PTAG_XO_CREATE_ACCT_TASK);
    if (pTaskExt == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    TaskInitializeContext(&(pTaskExt->Context));
    pTaskExt->Context.pfnContinue           = DoAcctTempCreateContinue;
    pTaskExt->Context.pfnClose              = DoAcctTempCreateClose;
    pTaskExt->Context.hEventWorkAvailable   = hWorkEvent;
    pTaskExt->State                         = xoacctCreateUploadPump;

    memcpy((PBYTE)&(pTaskExt->Request), pUser, sizeof(XONLINE_USER));
    
    hr = UploadFromMemoryInternal(
                g_AccountXrls[tempCreate].dwService,
                g_AccountXrls[tempCreate].szUrl,
                (PBYTE)&(pTaskExt->User),
                sizeof(XONLINE_USER) + XOACCTS_WORKBUFFER_SIZE,
                (PBYTE)(g_AccountXrls[tempCreate].szContentType),
                g_AccountXrls[tempCreate].cbContentType,
                (PBYTE)&(pTaskExt->Request),
                sizeof(XONLINE_USER),
                XOACCTS_TIMEOUT,
                hWorkEvent,
                &(pTaskExt->XrlContext));

    *phTask = (XONLINETASK_HANDLE)pTaskExt;
    
Cleanup:
    if (FAILED(hr) && pTaskExt != NULL)
    {
        SysFree(pTaskExt);
        *phTask = NULL;
    }
    
    return hr;
}

HRESULT
CXo::_XOnlineAccountTempCreateGetResults(XONLINETASK_HANDLE hTask, XONLINE_USER* pUser)
{
    XoEnter("_XOnlineAccountTempGetResults");
    XoCheck(hTask != NULL);

    XO_CREATE_ACCT_TASK*   pTaskExt   = (XO_CREATE_ACCT_TASK*)hTask;

    if (FAILED(pTaskExt->hrFinal))
    {
        goto Cleanup;
    }
    
    if (pUser != NULL)
    {
        memcpy(pUser, (PBYTE)&(pTaskExt->User), sizeof(XONLINE_USER));
        TimeStampOnlineUserStruct( (XC_ONLINE_USER_ACCOUNT_STRUCT*) pUser ); 
    }
    
Cleanup:
    return pTaskExt->hrFinal;
}


//---------------------------------------------------------
// DoAcctCreateTempContinue
//
//   _XOnlineAccountCreateTemp task pump
//
HRESULT CXo::DoAcctTempCreateContinue( XONLINETASK_HANDLE      hTask )
{
    HRESULT                hr         = XONLINETASK_S_RUNNING;
    XO_CREATE_ACCT_TASK*   pTaskExt   = (XO_CREATE_ACCT_TASK*)hTask;

    Assert(hTask != NULL);

    switch (pTaskExt->State)
    {
    case xoacctCreateUploadPump:
        hr = XOnlineTaskContinue((XONLINETASK_HANDLE)(&(pTaskExt->XrlContext)));
        if (hr != XONLINETASK_S_RUNNING)
        {
            /*
            now done on the server
            
            if (SUCCEEDED(hr))
            {
                // convert password to key.   
                // TODO: move this to the server
                if (!KerbPasswordToKey(pTaskExt->User.realm, (PBYTE)(pTaskExt->User.key)))
                {
                    hr = E_FAIL;
                    pTaskExt->State = xoacctCreateDone;
                    goto Cleanup;
                }

                ZeroMemory(pTaskExt->User.realm, XONLINE_REALM_NAME_SIZE);
                strcpy(pTaskExt->User.realm, "passport.net");
            }
            */

            pTaskExt->hrFinal = hr;
            pTaskExt->State = xoacctCreateDone;
        }

        break;
    
    case xoacctCreateDone:
        break;

    default:
        Assert(FALSE);
    }
    
    return hr;
}



//---------------------------------------------------------
// DoAcctTempCreateClose
//
//   _XOnlineAccountCreateTemp task close handler
//
VOID CXo::DoAcctTempCreateClose(XONLINETASK_HANDLE hTask)
{
    XO_CREATE_ACCT_TASK*   pTaskExt   = (XO_CREATE_ACCT_TASK*)hTask;
    
    XRL_CleanupHandler(&(pTaskExt->XrlContext.xrlasync));
    SysFree(pTaskExt);
}
                                    

// ********************************************************
//
// _XOnlineGetTags
//
// ********************************************************


#pragma pack(push, 1)
struct GET_TAGS_REQUEST
{
    WORD        wHeadSize;
    WORD        wCountryId;
    WORD        wMaxTags;
    WORD        cbName;
    char        szName[1];       // alloc'd to be the actual name size
};
#pragma pack(pop)

#pragma pack(push, 1)
struct GET_TAGS_RESPONSE
{
    WORD        wTagCount;
    BYTE        byTags[1];   // alloc'd to be the max name size
};
#pragma pack(pop)


enum GET_TAGS_STATE
{
    xoacctGetTagsUploadPump,
    xoacctGetTagsDone
};

struct GET_TAGS_TASK
{
	XONLINETASK_CONTEXT         Context;            // this task context
    XRL_ASYNC_EXTENDED          XrlContext;         // upload context
    
    GET_TAGS_STATE              State;              // current task state
    HRESULT                     hrFinal;            // final hresult

    GET_TAGS_REQUEST*           pRequest;	        // request buffer
    GET_TAGS_RESPONSE*          pResponse;          // response buffer

    LPWSTR                      pszTags;            // list of utf8-decoded tags.
};

//---------------------------------------------------------
// _XOnlineGetTags
//
//  Checks to see if the given name is good (non-offensive)
//  and returns any tags it's available in. 
// 
//  if pwsName is null, a list of all public tags is returned.
//  
//
HRESULT
CXo::_XOnlineGetTags(WORD wCountryId, WORD wMaxTags, LPCWSTR pwsName, HANDLE hWorkEvent, XONLINETASK_HANDLE *phTask)
{
    GET_TAGS_TASK* pTaskExt = NULL;
    DWORD cbName;
    DWORD cbRequest;
    DWORD cbResponse;

    XoEnter("_XOnlineGetTags");
    XoCheck(phTask != NULL);

    HRESULT hr = S_OK;
  
    pTaskExt = (GET_TAGS_TASK*)SysAllocZ(sizeof(GET_TAGS_TASK), PTAG_GET_TAGS_TASK);
    if (pTaskExt == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    //
    // init task stuff
    //
    TaskInitializeContext(&(pTaskExt->Context));
    pTaskExt->Context.pfnContinue           = DoGetTagsContinue;
    pTaskExt->Context.pfnClose              = DoGetTagsClose;
    pTaskExt->Context.hEventWorkAvailable   = hWorkEvent;
    pTaskExt->State                         = xoacctGetTagsUploadPump;

    //
    // init request
    //
    if (pwsName == NULL)
    {
        cbName = 0;
    }
    else
    {
        cbName = WideCharToMultiByte( CP_UTF8, 0, pwsName, lstrlenW(pwsName), NULL, 0, NULL, NULL );
    }
    cbRequest = sizeof(GET_TAGS_REQUEST) + cbName;
    pTaskExt->pRequest = (GET_TAGS_REQUEST*)SysAlloc(cbRequest, PTAG_GET_TAGS_REQUEST);
    if (pTaskExt->pRequest == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    
    pTaskExt->pRequest->wHeadSize   = sizeof(GET_TAGS_REQUEST) - sizeof(char);
    pTaskExt->pRequest->wCountryId  = wCountryId;
    pTaskExt->pRequest->wMaxTags    = wMaxTags;
    pTaskExt->pRequest->cbName      = (WORD)cbName;
    pTaskExt->pRequest->szName[0]   = NULL;
    
    if (pwsName != NULL)
    {
        WideCharToMultiByte(CP_UTF8, 0, pwsName, lstrlenW(pwsName), pTaskExt->pRequest->szName, cbName, NULL, NULL);
        Assert(pTaskExt->pRequest->szName[0] != NULL);
    }

    // 
    // init return buff
    // 
    cbResponse = sizeof(GET_TAGS_RESPONSE) - sizeof(BYTE) + (wMaxTags * XONLINE_KINGDOM_SIZE) + XOACCTS_WORKBUFFER_SIZE;
    pTaskExt->pResponse = (GET_TAGS_RESPONSE*)SysAllocZ(cbResponse, PTAG_GET_TAGS_RESPONSE);
    if (pTaskExt->pResponse == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    
	
	
	// 
    // launch the upload
    //
    hr = UploadFromMemoryInternal(
                g_AccountXrls[getTags].dwService,
                g_AccountXrls[getTags].szUrl,
                (PBYTE)(pTaskExt->pResponse),
                cbResponse,
                (PBYTE)(g_AccountXrls[getTags].szContentType),
                g_AccountXrls[getTags].cbContentType,
                (PBYTE)(pTaskExt->pRequest),
                cbRequest,
                XOACCTS_TIMEOUT,
                hWorkEvent,
                &(pTaskExt->XrlContext));

    *phTask = (XONLINETASK_HANDLE)pTaskExt;
    
Cleanup:
    if (FAILED(hr) && pTaskExt != NULL)
    {
        if (pTaskExt->pRequest != NULL)
        {
            SysFree(pTaskExt->pRequest);
        }

        if (pTaskExt->pResponse != NULL)
        {
            SysFree(pTaskExt->pResponse);
        }

        SysFree(pTaskExt);
        *phTask = NULL;
    }
    
    XoLeave(hr);
    return hr;
    
}

HRESULT 
CXo::DoGetTagsContinue( XONLINETASK_HANDLE hTask )
{
    HRESULT                hr         = XONLINETASK_S_RUNNING;
    GET_TAGS_TASK*   pTaskExt   = (GET_TAGS_TASK*)hTask;

    Assert(hTask != NULL);

    switch (pTaskExt->State)
    {
    case xoacctGetTagsUploadPump:
        hr = XOnlineTaskContinue((XONLINETASK_HANDLE)(&(pTaskExt->XrlContext)));
        if (hr != XONLINETASK_S_RUNNING)
        {
            pTaskExt->hrFinal = hr;
            pTaskExt->State = xoacctGetTagsDone;
            
            goto Cleanup;
        }

        break;

    case xoacctGetTagsDone:
        break;

    default:
        Assert(FALSE);
    }
Cleanup:
    pTaskExt->hrFinal = hr;
    return hr;
}


//---------------------------------------------------------
// _XOnlineGetTagsResults
//
//   returns the list of tags retrieved by _XOnlineGetTags.
//
HRESULT
CXo::_XOnlineGetTagsResults(XONLINETASK_HANDLE hTask, LPWSTR* pszTags, WORD* pwTagCount)
{
    GET_TAGS_TASK* pTaskExt = (GET_TAGS_TASK*)hTask;
    LPWSTR psz = pTaskExt->pszTags;
    PBYTE pby = pTaskExt->pResponse->byTags;
    WORD cb;
    HRESULT hr = S_OK;
    int res;

    *pwTagCount = 0;

    if (psz == NULL)
    {
        psz = (PWCHAR)SysAllocZ(sizeof(WCHAR) * XONLINE_KINGDOM_SIZE * pTaskExt->pResponse->wTagCount, PTAG_GET_TAGS_RESULTS);
        if (psz == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        pTaskExt->pszTags = psz;

        for (WORD i = 0; i < pTaskExt->pResponse->wTagCount; i++)
        {
            cb = (WORD)*pby;
            if (cb == 0 || cb > XONLINE_KINGDOM_SIZE * sizeof(WCHAR))
            {
                hr = XONLINE_E_INTERNAL_ERROR;
                goto Cleanup;
            }

            pby += sizeof(WORD);

            res = MultiByteToWideChar( CP_UTF8, 0, (LPCSTR)pby, cb, psz, XONLINE_KINGDOM_SIZE );
            if (res == 0)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto Cleanup;
            }

            pby += cb;
            psz += XONLINE_KINGDOM_SIZE;
        }
    }

    *pszTags  = pTaskExt->pszTags;
    *pwTagCount = pTaskExt->pResponse->wTagCount;
    
Cleanup:
    if (FAILED(hr))
    {
        *pszTags = NULL;
    }
    return hr;
}



//---------------------------------------------------------
// DoGetTagsClose
//
//   _XOnlineGetTags task close handler
//
VOID CXo::DoGetTagsClose(XONLINETASK_HANDLE hTask)
{
    GET_TAGS_TASK*   pTaskExt   = (GET_TAGS_TASK*)hTask;
    
    if (pTaskExt != NULL)
    {
        
        XRL_CleanupHandler(&(pTaskExt->XrlContext.xrlasync));

        if (pTaskExt->pRequest != NULL)
        {
            SysFree(pTaskExt->pRequest);
        }

        if (pTaskExt->pResponse != NULL)
        {
            SysFree(pTaskExt->pResponse);
        }
        
        if (pTaskExt->pszTags != NULL)
        {
            SysFree(pTaskExt->pszTags);
        }
        
        SysFree(pTaskExt);
    }
}








// ********************************************************
//
// _XOnlineReserveName
//
// ********************************************************


#pragma pack(push, 1)
struct RESERVE_NAME_REQUEST
{
    ULONGLONG   qwMachineId;
    WORD        wCountryId;
    WORD        wMaxNames;

    BYTE        rgbData[1];       
};
#pragma pack(pop)

#pragma pack(push, 1)
struct RESERVE_NAME_RESPONSE
{
    WORD        wNameCount;
    BYTE        rgbData[1];   // alloc'd to be the max name size
};
#pragma pack(pop)


enum RESERVE_NAME_STATE
{
    xoacctReserveNameUploadPump,
    xoacctReserveNameDone
};

struct RESERVE_NAME_TASK
{
	XONLINETASK_CONTEXT         Context;            // this task context
    XRL_ASYNC_EXTENDED          XrlContext;         // upload context
    
    RESERVE_NAME_STATE         State;              // current task state
    HRESULT                     hrFinal;            // final hresult

    DWORD                      cbRequest;
    RESERVE_NAME_REQUEST*      pRequest;	        // request buffer

    DWORD                      cbResponse;
    RESERVE_NAME_RESPONSE*     pResponse;          // response buffer

    PUSER_XNAME                      pNames;           // list of utf8-decoded names.
};

//---------------------------------------------------------
// _XOnlineReserveName
//
//  Checks to see if the given name is good (non-offensive)
//  and returns any tags it's available in. 
// 
//  if pwsName is null, a list of all public tags is returned.
//  
//
HRESULT
CXo::_XOnlineReserveName(LPCWSTR pwsGamerName, LPCWSTR pwsRealm, WORD wMaxNames, WORD wCountryId, HANDLE hWorkEvent, XONLINETASK_HANDLE *phTask)
{
    RESERVE_NAME_TASK* pTaskExt = NULL;
    DWORD cbName;
    PBYTE pb;

    XoEnter("_XOnlineReserveName");
    XoCheck(pwsGamerName != NULL);
    XoCheck(phTask != NULL);

    HRESULT hr = S_OK;
  
    pTaskExt = (RESERVE_NAME_TASK*)SysAllocZ(sizeof(RESERVE_NAME_TASK), PTAG_RESERVE_NAME_TASK);
    if (pTaskExt == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    //
    // init task stuff
    //
    TaskInitializeContext(&(pTaskExt->Context));
    pTaskExt->Context.pfnContinue           = DoReserveNameContinue;
    pTaskExt->Context.pfnClose              = DoReserveNameClose;
    pTaskExt->Context.hEventWorkAvailable   = hWorkEvent;
    pTaskExt->State                         = xoacctReserveNameUploadPump;

    //
    // init request
    //
    pTaskExt->cbRequest = sizeof(RESERVE_NAME_REQUEST) + XONLINE_NAME_SIZE + XONLINE_KINGDOM_SIZE + (2*sizeof(WORD));
    pTaskExt->pRequest = (RESERVE_NAME_REQUEST*)SysAlloc(pTaskExt->cbRequest, PTAG_RESERVE_NAME_REQUEST);
    if (pTaskExt->pRequest == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = _XOnlineGetMachineID(&(pTaskExt->pRequest->qwMachineId));
    if (FAILED(hr))
    {
        AssertSz1(FALSE, "_XOnlineGetMachineID Failed! 0x%08x", hr);
        goto Cleanup;
    }
        

    pTaskExt->pRequest->wCountryId  = wCountryId;
    pTaskExt->pRequest->wMaxNames   = wMaxNames;
    
    pb = pTaskExt->pRequest->rgbData;
    pb = WToUtf8((PWORD)pb, pb + sizeof(WORD), pwsGamerName);
    pb = WToUtf8((PWORD)pb, pb + sizeof(WORD), pwsRealm);

    Assert((pb - pTaskExt->pRequest->rgbData) < (int)(pTaskExt->cbRequest));
    
    //
    // init return buff
    // 
    //cbResponse = struct + wMaxNames * xname len/chars + workbuffer
    pTaskExt->cbResponse = sizeof(RESERVE_NAME_RESPONSE) - sizeof(BYTE) + 
                (wMaxNames * (XONLINE_NAME_SIZE + XONLINE_KINGDOM_SIZE + (2 * sizeof(WORD)))) + 
                XOACCTS_WORKBUFFER_SIZE;

    pTaskExt->pResponse = (RESERVE_NAME_RESPONSE*)SysAllocZ(pTaskExt->cbResponse, PTAG_RESERVE_NAME_RESPONSE);
    if (pTaskExt->pResponse == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

	
	// 
    // launch the upload
    //
    hr = UploadFromMemoryInternal(
                g_AccountXrls[reserveName].dwService,
                g_AccountXrls[reserveName].szUrl,
                (PBYTE)(pTaskExt->pResponse),
                pTaskExt->cbResponse,
                (PBYTE)(g_AccountXrls[reserveName].szContentType),
                g_AccountXrls[reserveName].cbContentType,
                (PBYTE)(pTaskExt->pRequest),
                pTaskExt->cbRequest,
                XOACCTS_TIMEOUT,
                hWorkEvent,
                &(pTaskExt->XrlContext));

    *phTask = (XONLINETASK_HANDLE)pTaskExt;
    
Cleanup:
    if (FAILED(hr) && pTaskExt != NULL)
    {
        if (pTaskExt->pRequest != NULL)
        {
            SysFree(pTaskExt->pRequest);
        }

        if (pTaskExt->pResponse != NULL)
        {
            SysFree(pTaskExt->pResponse);
        }

        SysFree(pTaskExt);
        *phTask = NULL;
    }
    
    XoLeave(hr);
    return hr;
    
}

HRESULT 
CXo::DoReserveNameContinue( XONLINETASK_HANDLE hTask )
{
    HRESULT                hr         = XONLINETASK_S_RUNNING;
    RESERVE_NAME_TASK*   pTaskExt   = (RESERVE_NAME_TASK*)hTask;

    Assert(hTask != NULL);

    switch (pTaskExt->State)
    {
    case xoacctReserveNameUploadPump:
        hr = XOnlineTaskContinue((XONLINETASK_HANDLE)(&(pTaskExt->XrlContext)));
        if (hr != XONLINETASK_S_RUNNING)
        {
            pTaskExt->hrFinal = hr;
            pTaskExt->State = xoacctReserveNameDone;
            
            goto Cleanup;
        }

        break;

    case xoacctReserveNameDone:
        break;

    default:
        Assert(FALSE);
    }
Cleanup:
    pTaskExt->hrFinal = hr;
    return hr;
}


//---------------------------------------------------------
// _XOnlineReserveNameResults
//
//   returns the list of tags retrieved by _XOnlineReserveName.
//
HRESULT
CXo::_XOnlineGetReserveNameResults(XONLINETASK_HANDLE hTask, PUSER_XNAME *ppNames, DWORD* pdwNameCount)
{
    XoEnter("_XOnlineGetReserveNameResults");
    XoCheck(pdwNameCount != NULL);
    XoCheck(ppNames != NULL);
    
    RESERVE_NAME_TASK* pTaskExt = (RESERVE_NAME_TASK*)hTask;
    PBYTE pby = pTaskExt->pResponse->rgbData;
    WORD cb;
    HRESULT hr = S_OK;
    int res;
    DWORD cbTotal;

    *pdwNameCount = pTaskExt->pResponse->wNameCount;
    *ppNames = pTaskExt->pNames;


    if (*ppNames == NULL && *pdwNameCount > 0)
    {
        cbTotal = sizeof(USER_XNAME) * (*pdwNameCount);
        *ppNames = (PUSER_XNAME)SysAllocZ(cbTotal, PTAG_RESERVE_NAME_RESULTS);
        if (*ppNames == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        for (WORD i = 0; i < pTaskExt->pResponse->wNameCount; i++)
        {
            cb = (WORD)*pby;
            if (cb == 0 || cb > XONLINE_NAME_SIZE)
            {
                hr = XONLINE_E_INTERNAL_ERROR;
                goto Cleanup;
            }
            pby += sizeof(WORD);
            Assert((DWORD)(pby - pTaskExt->pResponse->rgbData) < pTaskExt->cbResponse);

            res = MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)pby, cb, (*ppNames)[i].wszNickname, XONLINE_NAME_SIZE);
            if (res == 0)
            {
                AssertSz(FALSE, "MultiByteToWideChar(nickname) failed!");
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
            
            pby += cb;
            Assert((DWORD)(pby - pTaskExt->pResponse->rgbData) < pTaskExt->cbResponse);

            cb = (WORD)*pby;
            if (cb == 0 || cb > XONLINE_KINGDOM_SIZE)
            {
                hr = XONLINE_E_INTERNAL_ERROR;
                goto Cleanup;
            }
            pby += sizeof(WORD);
            Assert((DWORD)(pby - pTaskExt->pResponse->rgbData) < pTaskExt->cbResponse);

            res = MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)pby, cb, (*ppNames)[i].wszRealm, XONLINE_KINGDOM_SIZE);
            if (res == 0)
            {
                AssertSz(FALSE, "MultiByteToWideChar(nickname) failed!");
                hr = HRESULT_FROM_WIN32(GetLastError());
            }

            pby += cb;
            Assert((DWORD)(pby - pTaskExt->pResponse->rgbData) < pTaskExt->cbResponse);
        }
    }

    *pdwNameCount = pTaskExt->pResponse->wNameCount;
    pTaskExt->pNames = *ppNames;

Cleanup:
    if (FAILED(hr))
    {
        if (*ppNames != NULL)
        {
            SysFree(*ppNames);
        }

        *ppNames = NULL;
        *pdwNameCount = 0;
    }
    
    XoLeave(hr);
    return hr;
}



//---------------------------------------------------------
// DoReserveNameClose
//
//   _XOnlineGetTags task close handler
//
VOID CXo::DoReserveNameClose(XONLINETASK_HANDLE hTask)
{
    RESERVE_NAME_TASK*   pTaskExt   = (RESERVE_NAME_TASK*)hTask;
    
    if (pTaskExt != NULL)
    {
        
        XRL_CleanupHandler(&(pTaskExt->XrlContext.xrlasync));

        if (pTaskExt->pRequest != NULL)
        {
            SysFree(pTaskExt->pRequest);
        }

        if (pTaskExt->pResponse != NULL)
        {
            SysFree(pTaskExt->pResponse);
        }
        
        if (pTaskExt->pNames != NULL)
        {
            SysFree(pTaskExt->pNames);
        }
        
        SysFree(pTaskExt);
    }
}



// ********************************************************
//
// _XOnlineCreateAccount
//
// ********************************************************


#pragma pack(push, 1)
struct CREATE_ACCT_REQUEST
{
    BYTE        bCountryId;
    BYTE        bCardTypeId;
    FILETIME    ftCardExpiration;

    // string data, alloc'd to be the actual size
    BYTE byData[1]; 
};
#pragma pack(pop)

#pragma pack(push, 1)

struct CREATE_ACCT_RESPONSE
{
    ULONGLONG   qwUserID;
    BYTE        rgbKey[XONLINE_KEY_LENGTH];
    CHAR        szDomain[XONLINE_USERDOMAIN_SIZE];
    CHAR        szRealm[XONLINE_REALM_NAME_SIZE];
};
#pragma pack(pop)


enum CREATE_ACCT_STATE
{
    xoacctCreateAcctUploadPump,
    xoacctCreateAcctDone
};

struct CREATE_ACCT_TASK
{
	XONLINETASK_CONTEXT         Context;            // this task context
    XRL_ASYNC_EXTENDED          XrlContext;         // upload context
    
    CREATE_ACCT_STATE           State;              // current task state
    HRESULT                     hrFinal;            // final hresult

    CREATE_ACCT_REQUEST*        pRequest;	        // request buffer
    CREATE_ACCT_RESPONSE        Response;           // response buffer
    BYTE                        rgbBuf[XOACCTS_WORKBUFFER_SIZE]; // extra work buffer 

    XONLINEP_USER               User;
};



//---------------------------------------------------------
// _XOnlineCreateAccount
//
//  Checks to see if the given name is good (non-offensive)
//  and returns any tags it's available in. 
// 
//  if pwsName is null, a list of all public tags is returned.
//  
//
HRESULT
CXo::_XOnlineCreateAccount(USER_ACCOUNT_INFO* pAccountInfo, HANDLE hWorkEvent, XONLINETASK_HANDLE *phTask)
{
    CREATE_ACCT_TASK* pTaskExt = NULL;
    DWORD cbRequest;
    DWORD cbResponse;
    DWORD cbUsed;
    CREATE_ACCT_REQUEST* pRequest;
    PBYTE pby;
    WORD n = 0;

    XoEnter("_XOnlineCreateAccount");
    XoCheck(phTask != NULL);

    HRESULT hr = S_OK;
  
    pTaskExt = (CREATE_ACCT_TASK*)SysAllocZ(sizeof(CREATE_ACCT_TASK), PTAG_CREATE_ACCT_TASK);
    if (pTaskExt == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    //
    // init task stuff
    //
    TaskInitializeContext(&(pTaskExt->Context));
    pTaskExt->Context.pfnContinue           = DoCreateAccountContinue;
    pTaskExt->Context.pfnClose              = DoCreateAccountClose;
    pTaskExt->Context.hEventWorkAvailable   = hWorkEvent;
    pTaskExt->State                         = xoacctCreateAcctUploadPump;

    //
    // init request
    //
    cbRequest = sizeof(USER_ACCOUNT_INFO) * 3;
    pRequest = (CREATE_ACCT_REQUEST*)SysAlloc(cbRequest, PTAG_CREATE_ACCT_REQUEST);
    if (pRequest == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    
    pRequest->bCountryId = pAccountInfo->bCountryId;
	pRequest->bCardTypeId = pAccountInfo->bCardTypeId;
    pRequest->ftCardExpiration = pAccountInfo->ftCardExpiration;

    
    pby = pRequest->byData;
    pby = WToUtf8((PWORD)pby, pby + sizeof(WORD), pAccountInfo->wszNickname);
    pby = WToUtf8((PWORD)pby, pby + sizeof(WORD), pAccountInfo->wszKingdom);
    
    // count pin bytes
    for (n = 0; n < XONLINE_PIN_LENGTH && pAccountInfo->rgbPin[n] != 0; n++);
    *(PWORD)(pby) = n;
	pby += sizeof(WORD);

    // copy pin
	if (n > 0)
	{
		memcpy(pby + sizeof(WORD), pAccountInfo->rgbPin, n);
		pby += n;
	}

    pby = WToUtf8((PWORD)pby, pby + sizeof(WORD), pAccountInfo->wszFirstName);

    pby = WToUtf8((PWORD)pby, pby + sizeof(WORD), pAccountInfo->wszFirstName);
    pby = WToUtf8((PWORD)pby, pby + sizeof(WORD), pAccountInfo->wszLastName);
    pby = WToUtf8((PWORD)pby, pby + sizeof(WORD), pAccountInfo->wszStreet1);
    pby = WToUtf8((PWORD)pby, pby + sizeof(WORD), pAccountInfo->wszStreet2);
    pby = WToUtf8((PWORD)pby, pby + sizeof(WORD), pAccountInfo->wszStreet3);
    pby = WToUtf8((PWORD)pby, pby + sizeof(WORD), pAccountInfo->wszCity);
    pby = WToUtf8((PWORD)pby, pby + sizeof(WORD), pAccountInfo->wszState);
    pby = WToUtf8((PWORD)pby, pby + sizeof(WORD), pAccountInfo->wszPostalCode);
    pby = WToUtf8((PWORD)pby, pby + sizeof(WORD), pAccountInfo->wszPhonePrefix);
    pby = WToUtf8((PWORD)pby, pby + sizeof(WORD), pAccountInfo->wszPhoneNumber);
    pby = WToUtf8((PWORD)pby, pby + sizeof(WORD), pAccountInfo->wszPhoneExtension);
    
    pby = WToUtf8((PWORD)pby, pby + sizeof(WORD), pAccountInfo->wszCardHolder);
    pby = WToUtf8((PWORD)pby, pby + sizeof(WORD), pAccountInfo->wszCardNumber);
    
    pby = WToUtf8((PWORD)pby, pby + sizeof(WORD), pAccountInfo->wszEmail);
    pby = WToUtf8((PWORD)pby, pby + sizeof(WORD), pAccountInfo->wszBankCode);
    pby = WToUtf8((PWORD)pby, pby + sizeof(WORD), pAccountInfo->wszBranchCode);
    pby = WToUtf8((PWORD)pby, pby + sizeof(WORD), pAccountInfo->wszCheckDigits);

	cbUsed = pby - pRequest->byData;     
    pTaskExt->pRequest = pRequest;
    cbResponse = sizeof(CREATE_ACCT_RESPONSE) + XOACCTS_WORKBUFFER_SIZE;

    // 
    // copy known data to user struct
    //
    WToUtf8(NULL, (LPBYTE)pTaskExt->User.name, pAccountInfo->wszNickname);
    WToUtf8(NULL, (LPBYTE)pTaskExt->User.kingdom, pAccountInfo->wszKingdom);
    strcpy(pTaskExt->User.realm, "passport.net");
    memcpy(pTaskExt->User.pin, pAccountInfo->rgbPin, XONLINE_PIN_LENGTH);
    

	// 
    // launch the upload
    //
    hr = UploadFromMemoryInternal(
                g_AccountXrls[createAccount].dwService,
                g_AccountXrls[createAccount].szUrl,
                (PBYTE)&(pTaskExt->Response),
                cbResponse,
                (PBYTE)(g_AccountXrls[createAccount].szContentType),
                g_AccountXrls[createAccount].cbContentType,
                (PBYTE)(pTaskExt->pRequest),
                cbRequest,
                XOACCTS_TIMEOUT,
                hWorkEvent,
                &(pTaskExt->XrlContext));

    
    
    *phTask = (XONLINETASK_HANDLE)pTaskExt;
    
Cleanup:
    if (FAILED(hr) && pTaskExt != NULL)                     
    {
        if (pTaskExt->pRequest != NULL)
        {
            SysFree(pTaskExt->pRequest);
        }

        SysFree(pTaskExt);
        *phTask = NULL;
    }
    
    XoLeave(hr);
    return hr;
    
}

// 
// WToUtf8
//  Converts the given wide str to a UTF8 encoded str, writing 
//  the length to the (optional) pwLen param, and the 
//  encoded string to the pbData param, returning a pointer
//  to the byte following the encoded string.
//
//  NOTE: pbData is assuemed to have enough buffer space to 
//        to fit the encoded string.
//
LPBYTE
CXo::WToUtf8(PWORD pwLen, LPBYTE pbData, LPCWSTR pwszStr)
{
    Assert(pbData != NULL);
    Assert(pwszStr != NULL);
    WORD wLen;
    
    int cchStr = lstrlenW(pwszStr);
    int ret;


    if (*pwszStr == NULL)
    {
        wLen = 0;
        goto Cleanup;
    }
    
    ret = WideCharToMultiByte( CP_UTF8, 0, pwszStr, cchStr, (LPSTR)pbData, max(cchStr * 3, 0xffff), NULL, NULL );
    if (ret == 0)
    {
        AssertSz1(FALSE, "WideCharToMultiByte failed! (0x%08x)", GetLastError());
        
        wLen = 0;
        goto Cleanup;
    }
    
    if (ret > 0xffff)
    {
        AssertSz1(FALSE, "WideCharToMultiByte returned value out of range! <%d>", ret);
        
        wLen = 0;
        goto Cleanup;
    }

	wLen = (WORD)ret;

Cleanup:
    if (pwLen != NULL)
    {
        *pwLen = wLen;
    }

    return pbData + wLen;
}


HRESULT 
CXo::DoCreateAccountContinue( XONLINETASK_HANDLE hTask )
{
    HRESULT             hr         = XONLINETASK_S_RUNNING;
    CREATE_ACCT_TASK*   pTaskExt   = (CREATE_ACCT_TASK*)hTask;

    Assert(hTask != NULL);

    switch (pTaskExt->State)
    {
    case xoacctCreateAcctUploadPump:
        hr = XOnlineTaskContinue((XONLINETASK_HANDLE)(&(pTaskExt->XrlContext)));
        if (hr != XONLINETASK_S_RUNNING)
        {
            if (SUCCEEDED(hr))
            {
                pTaskExt->User.xuid.qwUserID = pTaskExt->Response.qwUserID;
                memcpy(pTaskExt->User.domain, pTaskExt->Response.szDomain, XONLINE_USERDOMAIN_SIZE);
                memcpy(pTaskExt->User.key, pTaskExt->Response.rgbKey, XONLINE_KEY_LENGTH);

                TimeStampOnlineUserStruct( (XC_ONLINE_USER_ACCOUNT_STRUCT*) &(pTaskExt->User) ); 

                hr = _XOnlineAddUserToHD((PXONLINE_USER)&(pTaskExt->User));
				hr = (FAILED(hr) ? hr : XONLINETASK_S_SUCCESS);
				
                // REVIEW: what if a failure happens here??  Do we try to roll back?
            }

            pTaskExt->hrFinal = hr;
            pTaskExt->State = xoacctCreateAcctDone;

            goto Cleanup;
        }

        break;

    case xoacctCreateAcctDone:


        break;

    default:
        Assert(FALSE);
    }
    Cleanup:
    pTaskExt->hrFinal = hr;
    return hr;
}


//---------------------------------------------------------
// _XOnlineCreateAccountResults
//
//   returns the list of tags retrieved by _XOnlineCreateAccount.
//
HRESULT
CXo::_XOnlineGetCreateAccountResults(XONLINETASK_HANDLE hTask, XONLINE_USER* pUser)
{
    XoEnter("_XOnlineGetCreateAccountResults");
    XoCheck(hTask != NULL);

    CREATE_ACCT_TASK*   pTaskExt   = (CREATE_ACCT_TASK*)hTask;

    if (FAILED(pTaskExt->hrFinal))
    {
        goto Cleanup;
    }
    
    if (pUser != NULL)
    {
        memcpy(pUser, (PBYTE)&(pTaskExt->User), sizeof(XONLINE_USER));
    }
    
Cleanup:
    XoLeave(pTaskExt->hrFinal);
    return pTaskExt->hrFinal;
    
}



//---------------------------------------------------------
// DoCreateAccountClose
//
//   _XOnlineCreateAccount task close handler
//
VOID CXo::DoCreateAccountClose(XONLINETASK_HANDLE hTask)
{
    CREATE_ACCT_TASK*   pTaskExt   = (CREATE_ACCT_TASK*)hTask;
    
    if (pTaskExt != NULL)
    {
        XRL_CleanupHandler(&(pTaskExt->XrlContext.xrlasync));

        if (pTaskExt->pRequest != NULL)
        {
            SysFree(pTaskExt->pRequest);
        }

        SysFree(pTaskExt);
    }
}













#if 0
/* THE LOCKOUT FUNCTIONALITY HAS BEEN CUT FROM THE CURRENT IMPLEMENTATION.
   TO BE RESURRECTED AT AN APPROPRIATE TIME                                 
   
   THIS IS UNTESTED CODE!                                                       */



// LockoutInfo structures

enum ACCT_LOCKOUT_STATE
{
    xoacctLockoutUploadPump,
    xoacctLockoutDone
};

#pragma pack(push, 1)
typedef struct 
{
     DWORD      cbSize;
     ULONGLONG  qwUserId;
} 
XO_LOCKOUT_INFO_REQUEST, *PXO_LOCKOUT_INFO_REQUEST;

typedef struct
{
    DWORD      cbSize;
    WORD       wTotalDays;
    WORD       wDaysRemaining;
    BYTE       bHoursRemaining;
} 
XO_LOCKOUT_INFO, *PXO_LOCKOUT_INFO;
#pragma pack(pop)

typedef struct
{
    XONLINETASK_CONTEXT         Context;            // this task context
    XRL_ASYNC_EXTENDED          XrlContext;         // upload context
    BYTE                        rgbWorkBuffer[XOACCTS_WORKBUFFER_SIZE];     // work buffer
    DWORD                       State;              // current task state

    XO_LOCKOUT_INFO_REQUEST     Request;	        // user to get info on
    HRESULT                     hrFinal;            // final hresult
}
XO_LOCKOUT_INFO_TASK, *PXO_LOCKOUT_INFO_TASK;

// SHOULD BE MOVED TO PUBLIC AREA OF XONLINE.X
typedef struct
{
    DWORD       dwTotalDays;
    DWORD       dwDaysRemaining;
    DWORD       dwHoursRemaining;
} XONLINE_LOCKOUT_INFORMATION;



//---------------------------------------------------------
// XOnlineGetLockoutInfo
//
//   Goes to the server to determine the remaining length of time
//   a user has to spend in lockout mode.  Call the GetResults
//   function to get the results.
//
HRESULT
CXo::XOnlineGetLockoutInfo(DWORD dwUserIndex, HANDLE hWorkEvent, XONLINETASK_HANDLE *phTask)
{
    XoEnter("XOnlineGetLockoutInfo");
    XoCheck(dwUserIndex < 4);

    HRESULT                     hr         = XONLINETASK_S_RUNNING;
    ULONGLONG                   qwUserPUID = 0;
    PXO_LOCKOUT_INFO_TASK       pTaskExt   = NULL;
    PXONLINE_USER               rgUsers    = NULL;
    XUID                        xUser;
    CHAR                        szContentType[25];
    DWORD                       cbContentType;
  
    pTaskExt = (PXO_LOCKOUT_INFO_TASK)SysAllocZ(sizeof(XO_LOCKOUT_INFO_TASK), PTAG_XO_LOCKOUT_INFO_TASK);
    if (pTaskExt == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    TaskInitializeContext(&(pTaskExt->Context));
    pTaskExt->Context.pfnContinue           = DoLockoutInfoContinue;
    pTaskExt->Context.pfnClose              = DoLockoutInfoClose;
    pTaskExt->Context.hEventWorkAvailable   = hWorkEvent;
    pTaskExt->State                         = xoacctLockoutUploadPump;

   
    // Get UserPUID from controller id
    rgUsers = XOnlineGetLogonUsers();
    if(rgUsers == NULL) {
        hr = XONLINE_E_NO_SESSION;
        goto Cleanup;
    }
    xUser = rgUsers[dwUserIndex].xuid;
    qwUserPUID = xUser.qwUserID;
    if(qwUserPUID == 0) {
        hr = XONLINE_E_USER_NOT_LOGGED_ON;
        goto Cleanup;
    }
    
    // fill in request    
    pTaskExt->Request.cbSize    = sizeof(XO_LOCKOUT_INFO_REQUEST);
    pTaskExt->Request.qwUserId  = qwUserPUID;
    
    hr = UploadFromMemoryInternal(
                g_AccountXrls[acctGetLockoutInfo].dwService,
                g_AccountXrls[acctGetLockoutInfo].szUrl,
                pTaskExt->rgbWorkBuffer,
                XOACCTS_WORKBUFFER_SIZE,
                (PBYTE)(g_AccountXrls[acctGetLockoutInfo].szContentType),
                g_AccountXrls[acctGetLockoutInfo].cbContentType,
                (PBYTE)&(pTaskExt->Request),
                sizeof(XO_LOCKOUT_INFO_REQUEST),
                XOACCTS_TIMEOUT,
                hWorkEvent,
                &(pTaskExt->XrlContext));

    *phTask = (XONLINETASK_HANDLE)pTaskExt;
    
Cleanup:
    if (FAILED(hr) && pTaskExt != NULL)
    {
        SysFree(pTaskExt);
        *phTask = NULL;
    }
    
    return (XOLeave(hr));
}


//---------------------------------------------------------
// XOnlineGetLockoutInfoGetResults
//
//   ...gets the results!
//
HRESULT
CXo::XOnlineGetLockoutInfoGetResults(XONLINETASK_HANDLE hTask, XONLINE_LOCKOUT_INFORMATION * pLockoutInfo)
{
    XoEnter("XOnlineGetLockoutInfoGetResults");
    XoCheck(hTask != NULL);

    PXO_LOCKOUT_INFO_TASK           pTaskExt        = (PXO_LOCKOUT_INFO_TASK)hTask;
    PXO_LOCKOUT_INFO                pResponse       = (PXO_LOCKOUT_INFO)&(pTaskExt->rgbWorkBuffer);
    XONLINE_LOCKOUT_INFORMATION     LockoutTemp;
    
    if (FAILED(pTaskExt->hrFinal))
    {
        goto Cleanup;
    }
    
    if (pLockoutInfo != NULL)
    {
        Assert(pResponse != NULL);

        pLockoutInfo->dwTotalDays         = pResponse->wTotalDays;
        pLockoutInfo->dwDaysRemaining     = pResponse->wDaysRemaining;
        pLockoutInfo->dwHoursRemaining    = pResponse->bHoursRemaining;
    }
    
Cleanup:
    return pTaskExt->hrFinal;
}



//---------------------------------------------------------
// DoLockoutContinue
//
//   XOnlineGetLockoutInfo task pump
//
HRESULT CXo::DoLockoutContinue( XONLINETASK_HANDLE      hTask )
{
    HRESULT                hr         = XONLINETASK_S_RUNNING;
    PXO_LOCKOUT_INFO_TASK  pTaskExt   = (PXO_LOCKOUT_INFO_TASK)hTask;

    Assert(hTask != NULL);

    switch (pTaskExt->State)
    {
        case xoacctLockoutUploadPump:
            hr = XOnlineTaskContinue((XONLINETASK_HANDLE)(&(pTaskExt->XrlContext)));
            if (hr != XONLINETASK_S_RUNNING)
            {
                pTaskExt->State = xoacctLockoutDone;
			    pTaskExt->hrFinal = hr;							
                goto Cleanup;
            }
            else 
            {
                Assert(pTaskExt->XrlContext.xrlasync.dwCurrent == ((PXO_LOCKOUT_INFO)(pTaskExt->rgbWorkBuffer))->cbSize);
            }
            break;

        case xoacctLockoutDone:
            hr = pTaskExt->hrFinal;
            break;

        default:
            Assert(FALSE);
    }
    
Cleanup:
    return hr;
}


//---------------------------------------------------------
// DoLockoutClose
//
//   XOnlineGetLockoutInfo task close handler
//
VOID CXo::DoLockoutClose(XONLINETASK_HANDLE hTask)
{
    PXO_LOCKOUT_INFO_TASK   pTaskExt   = (PXO_LOCKOUT_INFO_TASK)hTask;
    
    XRL_CleanupHandler(&(pTaskExt->XrlContext.xrlasync), 0);
    SysFree(pTaskExt);
}

#endif /* lockout section */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\cfcache.cpp ===
/*++

Copyright (c) Microsoft Corporation

Author:
	Keith Lau (keithlau)

Description:
	Implementation of the CFFILE cache

Module Name:

    cfcache.c

--*/

#include "xonp.h"
#include "xonver.h"

//
// Initialization routine
//
HRESULT CXo::CffileCacheInitialize(
			HANDLE						hFile,
			DWORD						dwCffileOffset,
			WORD						wCffiles,
			PBYTE						pbKey, 
			DWORD						cbKey,
			DWORD						cbLength,
			PBYTE						pbBuffer,
			DWORD						cbBuffer,
			PRC4_SHA_HEADER				pHeader,
			HANDLE						hEventWorkAvailable,
			PXONLINECONTENT_CFFILECACHE	pcffilecache
			)
{
	Assert(pcffilecache != NULL);
	Assert(hFile != INVALID_HANDLE_VALUE);
	Assert(hFile != NULL);
	Assert(wCffiles > 0);
	Assert(pbKey != NULL);
	Assert(cbKey > sizeof(DWORD));
	Assert(cbLength > 0);
	Assert(pHeader != NULL);

	pcffilecache->hFile = hFile;
	pcffilecache->uliReadOffset.QuadPart = dwCffileOffset;
	pcffilecache->wCffiles = wCffiles;
	pcffilecache->bFlags = CFFILECACHE_FLAG_DISCARD_PREDATA;
	pcffilecache->bPadding = 0;
	pcffilecache->wCurrentIndex = 0;
	pcffilecache->wCursor = 0;
	pcffilecache->wDataSize = 0;
	pcffilecache->hEventWork = hEventWorkAvailable;

	if (pbBuffer)
	{
		pcffilecache->pbBuffer = pbBuffer;
		pcffilecache->cbBuffer = cbBuffer;
	}
	else
	{
		pcffilecache->pbBuffer = pcffilecache->rgbBuffer;
		pcffilecache->cbBuffer = CFFILECACHE_SIZE;
	}

	// Initialize our RC4 decoder
	return(SymmdecInitialize(pbKey, cbKey, cbLength,
				pHeader, &pcffilecache->symmdec));
}

//
// Function to get the first/next CFFILE entry
//
HRESULT CXo::CffileCacheGetNextEntry(
			PXONLINECONTENT_CFFILECACHE	pcffilecache,
			DWORD						*pdwIndex,
			CFFILE						**ppcffile,
			PSTR						*ppszName,
			DWORD						*pcbName
			)
{
	HRESULT	hr = S_OK;
	
	Assert(pdwIndex != NULL);
	Assert(ppcffile != NULL);
	Assert(ppszName != NULL);
	Assert(pcbName != NULL);

	// Make sure there is more data to read
	if (pcffilecache->wCurrentIndex >= pcffilecache->wCffiles)
		return(S_CFFILECACHE_NO_MORE_ITEMS);

	// First, see if we are actually in a pending state waiting
	// more data.
	if (pcffilecache->bFlags & CFFILECACHE_FLAG_READ_PENDING)
	{
		DWORD				dwBytesRead;
		DWORD				dwRemaining;
		PBYTE				pbBuffer = NULL;
		XONLINETASK_HANDLE	hfileio = (XONLINETASK_HANDLE)&pcffilecache->fileio;
		
		// Continue until the receive completes asynchronously
		hr = XOnlineTaskContinue(hfileio);
		if (XONLINETASK_STATUS_AVAILABLE(hr))
		{
			// Mark as non-pending state
			pcffilecache->bFlags &= (~CFFILECACHE_FLAG_READ_PENDING);

			// Receive had returned results, see if it succeeded
			if (FAILED(hr))
				return(hr);

			// Succeeded, now get the results and analyze the data
			hr = GetReadWriteFileResults(hfileio, &dwBytesRead, &pbBuffer);
			if (FAILED(hr))
				return(hr);

			// If we read zero bytes, there is something wrong with the
			// data. Return failure
			if (dwBytesRead == 0)
				return(HRESULT_FROM_WIN32(ERROR_INVALID_DATA));

			// Now decrypt our data
			Assert(pbBuffer != NULL);

			// Adjust our pointers
			pcffilecache->uliReadOffset.QuadPart += dwBytesRead;

			// Now, we make sure if we are asked to discard the bytes
			// up to the data marker, we will do so, and not factor that
			// into valid data.
			if (pcffilecache->bFlags & CFFILECACHE_FLAG_DISCARD_PREDATA)
			{
				dwBytesRead -= pcffilecache->wDataSize;
				pcffilecache->bFlags &= (~CFFILECACHE_FLAG_DISCARD_PREDATA);
			}
			
			// Because of sector alignment, we could have read too
			// much. The decoder does not like that, so we make sure
			// we give it the exact size so the checksum matches up.
			hr = SymmdecGetRemainingCount(
						&pcffilecache->symmdec, &dwRemaining);
			if (FAILED(hr))
				return(hr);

			if (dwBytesRead > dwRemaining)
				dwBytesRead = dwRemaining;

#ifndef NO_ENCRYPT

			// Make sure we only decrypt what is new, and that we don't
			// overrun
			hr = SymmdecDecrypt(&pcffilecache->symmdec, 
						pcffilecache->pbBuffer + pcffilecache->wDataSize, 
						dwBytesRead);
			if (FAILED(hr))
				return(hr);
				
#endif				

			// Now reflect the real data size
			pcffilecache->wDataSize += (WORD)dwBytesRead;
		}
		else
		{
			// Return pending error
			return(S_CFFILECACHE_IO_PENDING);
		}
	}

	// See if there is any more data to process
	if (pcffilecache->wCursor < pcffilecache->wDataSize)
	{
		CFFILE	*pcffile = (CFFILE *)(pcffilecache->pbBuffer + pcffilecache->wCursor);
		WORD	wDataLeft = pcffilecache->wDataSize - pcffilecache->wCursor;
		
		// Make sure the data is at least the size of a CFFILE
		if (wDataLeft > sizeof(CFFILE))
		{
			PSTR	pszName = (PSTR)(pcffile + 1);
			
			// OK, we'll try to parse the remaining data for a
			// complete CFFILE record.
			wDataLeft -= sizeof(CFFILE);
			while (wDataLeft--)
				if (*pszName++ == '\0')
				{
					// We found a complete CFFILE record
					*pdwIndex = pcffilecache->wCurrentIndex++;
					*ppcffile = pcffile;
					*ppszName = (PSTR)(pcffile + 1);
					*pcbName = pszName - (*ppszName);

					// Advance the cursor
					pcffilecache->wCursor = pszName - (PSTR)pcffilecache->pbBuffer;

					return(S_OK);
				}
		}
	}

	// OK, since we're here, we are not pending for more data,
	// and the remaining data is incomplete. Let's read more 
	// data from the disk.
	{
		DWORD	dwDataSize;
		DWORD	dwReadSize;

		// Figure out how mauch data is left
		dwDataSize = pcffilecache->wDataSize - pcffilecache->wCursor;

		// Figure out how much padding we need for DWORD alignment
		pcffilecache->bPadding = (BYTE)(sizeof(DWORD) - (dwDataSize & (sizeof(DWORD) - 1)));
		pcffilecache->bPadding &= (sizeof(DWORD) - 1);

        Assert(((dwDataSize + pcffilecache->bPadding) & (sizeof(DWORD) - 1)) == 0);
		
		// First, move all unprocessed data to the front of the buffer
		if (dwDataSize)
		{
			MoveMemory(pcffilecache->pbBuffer + pcffilecache->bPadding, 
						pcffilecache->pbBuffer + pcffilecache->wCursor, dwDataSize);
		}
	
		// Reads need to be sector-aligned.
		dwDataSize += pcffilecache->bPadding;
		dwReadSize = pcffilecache->cbBuffer - dwDataSize;
		dwReadSize &= ~(XBOX_HD_SECTOR_SIZE - 1);

		// Move our pointers to the right places for new data
		pcffilecache->wCursor = pcffilecache->bPadding;
		pcffilecache->wDataSize = (WORD)dwDataSize;

		Assert((dwDataSize >> 16) == 0);

		if (dwReadSize == 0)
		{
			// The next CFFILE entry is so large that it does not leave
			// enough space for us to read the next sector. This means
			// that it is more than 1.5k. This is certainly invalid, and
			// since there is no way we can process this entry, so we fail.
			return(HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
		}

#if DBG
		if (dwReadSize < 2048)
		{
			TraceSz1(Verbose, "Buffer underutilized by %u bytes", 2048-dwReadSize);
		}
#endif

		// Final caveat, the initial file offset may not be aligned
		if (pcffilecache->bFlags & CFFILECACHE_FLAG_DISCARD_PREDATA)
		{
			DWORD	dwTemp;
			
			dwTemp = SECTOR_ALIGNMENT_ROUND_DOWN(
						pcffilecache->uliReadOffset.u.LowPart);
			pcffilecache->wCursor = (WORD)(pcffilecache->uliReadOffset.u.LowPart - dwTemp);
			pcffilecache->wDataSize = pcffilecache->wCursor;
			pcffilecache->uliReadOffset.u.LowPart = dwTemp;
			dwDataSize = 0;
		}

		// Set up the read file context
		ReadWriteFileInitializeContext(pcffilecache->hFile,
					pcffilecache->pbBuffer + dwDataSize,
					dwReadSize,
					pcffilecache->uliReadOffset,
					pcffilecache->hEventWork,
					&pcffilecache->fileio);

		hr = ReadFileInternal(&pcffilecache->fileio);
		if (FAILED(hr))
			return(hr);

		// Mark as pending state
		pcffilecache->bFlags |= CFFILECACHE_FLAG_READ_PENDING;
	}

	// Return IO pending
	return(S_CFFILECACHE_IO_PENDING);
}

//
// After reading all CFFILE entries, this must be called to
// verify the checksum
//
HRESULT CXo::CffileCacheVerifyChecksum(
			PXONLINECONTENT_CFFILECACHE	pcffilecache
			)
{
	// Make sure we have processed all CFFILE entries ...
	if (pcffilecache->wCurrentIndex < pcffilecache->wCffiles)
		return(HRESULT_FROM_WIN32(ERROR_MORE_DATA));

	// Just directly call the symmdec to verify the checksum
	return(SymmdecVerify(&pcffilecache->symmdec));
}

VOID CXo::CffileCacheDeinitialize(
			PXONLINECONTENT_CFFILECACHE	pcffilecache
			)
{
	if ((pcffilecache->hFile != INVALID_HANDLE_VALUE) && 
		(pcffilecache->hFile != NULL))
	{
		if (!CloseHandle(pcffilecache->hFile))
		{
			AssertSz(FALSE, "CffileCacheDeinitialize: cannot close handle!");
		}
		// Reset the handle
		pcffilecache->hFile = INVALID_HANDLE_VALUE;
	}
}

//
// Function to veriy the CFFILE entries before use
//
HRESULT CXo::CffileCacheVerify(
			PXONLINECONTENT_CFFILECACHE	pcffilecache
			)
{
	HRESULT	hr = S_OK;
	
	Assert(pcffilecache != NULL);

	// First, see if we are actually in a pending state waiting
	// more data.
	if (pcffilecache->bFlags & CFFILECACHE_FLAG_READ_PENDING)
	{
		DWORD				dwBytesRead;
		DWORD				dwRemaining;
		PBYTE				pbBuffer = NULL;
		XONLINETASK_HANDLE	hfileio = (XONLINETASK_HANDLE)&pcffilecache->fileio;
		
		// Continue until the receive completes asynchronously
		hr = XOnlineTaskContinue(hfileio);
		if (XONLINETASK_STATUS_AVAILABLE(hr))
		{
			// Mark as non-pending state
			pcffilecache->bFlags &= (~CFFILECACHE_FLAG_READ_PENDING);

			// Receive had returned results, see if it succeeded
			if (FAILED(hr))
				return(hr);

			// Succeeded, now get the results and analyze the data
			hr = GetReadWriteFileResults(hfileio, &dwBytesRead, &pbBuffer);
			if (FAILED(hr))
				return(hr);

			// If we read zero bytes, there is something wrong with the
			// data. Return failure
			if (dwBytesRead == 0)
				return(HRESULT_FROM_WIN32(ERROR_INVALID_DATA));

			// Now decrypt our data
			Assert(pbBuffer != NULL);

			// Adjust our pointers
			pcffilecache->uliReadOffset.QuadPart += dwBytesRead;

			// Now, we make sure if we are asked to discard the bytes
			// up to the data marker, we will do so, and not factor that
			// into valid data.
			if (pcffilecache->bFlags & CFFILECACHE_FLAG_DISCARD_PREDATA)
			{
				dwBytesRead -= pcffilecache->wDataSize;
				pcffilecache->bFlags &= (~CFFILECACHE_FLAG_DISCARD_PREDATA);
			}
			
			// Because of sector alignment, we could have read too
			// much. The decoder does not like that, so we make sure
			// we give it the exact size so the checksum matches up.
			hr = SymmdecGetRemainingCount(
						&pcffilecache->symmdec, &dwRemaining);
			if (FAILED(hr))
				return(hr);

			if (dwBytesRead > dwRemaining)
				dwBytesRead = dwRemaining;

#ifndef NO_ENCRYPT

			// Make sure we only decrypt what is new, and that we don't
			// overrun
			hr = SymmdecDecrypt(&pcffilecache->symmdec, 
						pcffilecache->pbBuffer + pcffilecache->wDataSize, 
						dwBytesRead);
			if (FAILED(hr))
				return(hr);
				
#endif				

			// Now reflect the real data size
			pcffilecache->wDataSize += (WORD)dwBytesRead;

			// See if we are done
			dwRemaining -= dwBytesRead;
			if (!dwRemaining)
			{
				// Verify the Hmac and leave
				return(SymmdecVerify(&pcffilecache->symmdec));
			}

			// We fall thru below ...
		}
		else
		{
			// Return pending error
			return(S_CFFILECACHE_IO_PENDING);
		}
	}

	// OK, since we're here, we are not pending for more data,
	// and the remaining data is incomplete. Let's read more 
	// data from the disk.
	pcffilecache->wCursor = 0;
	pcffilecache->wDataSize = 0;

	// Final caveat, the initial file offset may not be aligned
	if (pcffilecache->bFlags & CFFILECACHE_FLAG_DISCARD_PREDATA)
	{
		DWORD	dwTemp;
		
		dwTemp = SECTOR_ALIGNMENT_ROUND_DOWN(
					pcffilecache->uliReadOffset.u.LowPart);
		pcffilecache->wCursor = (WORD)(pcffilecache->uliReadOffset.u.LowPart - dwTemp);
		pcffilecache->wDataSize = pcffilecache->wCursor;
		pcffilecache->uliReadOffset.u.LowPart = dwTemp;
	}

	// Set up the read file context
	ReadWriteFileInitializeContext(pcffilecache->hFile,
				pcffilecache->pbBuffer,
				SECTOR_ALIGNMENT_ROUND_DOWN(pcffilecache->cbBuffer),
				pcffilecache->uliReadOffset,
				pcffilecache->hEventWork,
				&pcffilecache->fileio);

	hr = ReadFileInternal(&pcffilecache->fileio);
	if (FAILED(hr))
		return(hr);

	// Mark as pending state
	pcffilecache->bFlags |= CFFILECACHE_FLAG_READ_PENDING;

	// Return IO pending
	return(S_CFFILECACHE_IO_PENDING);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\contdl.cpp ===
/*++

Copyright (c) Microsoft Corporation

Author:
    Keith Lau (keithlau)

Description:
	Module implementing content download

Module Name:

    contdl.c

--*/

#include "xonp.h"
#include "xonver.h"

//#define NO_SIGNATURE

//#define CHK_CORRUPT
#ifdef CHK_CORRUPT

#define CHK_CORRUPT_SIZE		65536

VOID CXo::CheckCorruption(
			PXONLINECONTENT_INSTALL	pinstall
			)
{
	PDWORD	pdwGate = (PDWORD)(pinstall + 1);
	DWORD	dw;
	for (dw = 0; dw < (CHK_CORRUPT_SIZE >> 2); dw++, pdwGate++)
		if (*pdwGate)
		{
			AssertSz(FALSE, "CORRUPT");
		}
}

#endif

#if DBG

const char * const CXo::s_rgszPhases[dlphaseDone] =
{
	// Pre-Connect phases
	"dlphaseCatref",
	"dlphaseCheckCache",
	"dlphaseReadCache",
	"dlphaseWipeTarget",
	"dlphaseCreateCache",
	"dlphaseSetupCahce",
	"dlphaseVerifyInstall",
	"dlphasePreCustom",

	// Process data phases
	"dlphaseRecvHeader",
	"dlphaseInstallFiles",
	"dlphaseCreateTarget",
	"dlphaseWriteTarget",
	"dlphaseCheckpoint",
	"dlphaseCreateDirectory",
	"dlphaseVerifyCffiles",

	// Post-Download phases
	"dlphaseSignDrm",
	"dlphaseDeleteCache",
	"dlphasePostCustom",
};

#endif

//
// Define the name of the cache file
//
#define XONLINECONTENT_CACHE_FILE_NAME		"cache.xcd"

//
// Helper functions
//

//
// Function to begin a task to verify and/or sign the manifest
//
HRESULT CXo::VerifyOrSignManifestBegin(
			PXONLINECONTENT_INSTALL	pinstall,
			PBYTE					pbPackageKey
			)
{
	HRESULT				hr = S_OK;
	HANDLE				hFile = INVALID_HANDLE_VALUE;
	LARGE_INTEGER		liSize;
	DWORD				cbPath;
	CHAR				*szPath;
	DGSTFILE_IDENTIFIER	dfi;
	
	Assert(pinstall);

	// Open the manifest file
	szPath = (CHAR *)pinstall->rgbDecompress;
	cbPath = XONLINECONTENT_MAX_PATH;
	hr = BuildTargetPath(
				pinstall->dwTitleId, 
				pinstall->OfferingId,
				pinstall->dwBitFlags,
				XONLINECONTENT_MANIFEST_FILE_NAME,
				pinstall->dirtypeTarget,
				&cbPath,
				szPath);
	if (FAILED(hr))
		goto Error;

	hFile = CreateFile(
				szPath, 
				GENERIC_READ | GENERIC_WRITE, 
				FILE_SHARE_READ, 
				NULL, 
				OPEN_ALWAYS, 
				FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN |
				FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING, 
				NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		// We've extracted everything and now we cannot open
		// the manifest file.
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Error;
	}

	if (!GetFileSizeEx(hFile, &liSize))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Error;
	}

	// File should be reasonably small
	Assert(liSize.u.HighPart == 0);

	// Reset the counters
	pinstall->dwExpected = liSize.u.LowPart;
	pinstall->dwWritten = 0;

	// Initialize the verification context
	dfi.dwTitleId = pinstall->dwTitleId;
	dfi.OfferingId = pinstall->OfferingId;
	dfi.wTitleVersionHi = 0;
	dfi.wTitleVersionLo = 0;
	hr = ContentVerifyInitializeContext(
				hFile, liSize.u.LowPart,
				pinstall->rgbDecompress, 
				XONLINECONTENT_LZX_OUTPUT_SIZE,
				pbPackageKey,
				pbPackageKey?XONLINECONTENT_VERIFY_FLAG_SIGN:0,
				&dfi,
				pinstall->dirtypeTarget,
				pinstall->xontask.hEventWorkAvailable,
				&pinstall->verify);
	if (FAILED(hr))
		goto Error;

	// Kick it off!
	hr = ContentVerifyBegin(&pinstall->verify);
	if (FAILED(hr))
		goto Error;

Exit:
	return(hr);

Error:
	if (hFile != INVALID_HANDLE_VALUE)
		CloseHandle(hFile);
	goto Exit;
}

//
// Function to sanity check the received CAB header
//
HRESULT CXo::VerifyCabHeader(
			PXONLINECONTENT_HEADER	pheader
			)
{
	CFHEADER	*pcfheader = &pheader->cfheader;
	
	// Make sure the signature on the decrypted header checks up
	if (pcfheader->sig != sigCFHEADER)
	{
		AssertSz(FALSE, "VerifyCabHeader: Invalid CAB signature");
		goto Error;
	}

	// Check version
	if (pcfheader->version != verCF)
	{
		AssertSz(FALSE, "VerifyCabHeader: Invalid CAB version");
		goto Error;
	}

	// Assert some important assumptions
	// 1: flags only contain RESERVE_PRESENT
	if ((pcfheader->flags & cfhdrFLAGS_ALL) != cfhdrRESERVE_PRESENT)
	{
        AssertSz(FALSE, "VerifyCabHeader: Invalid flags");
		goto Error;
	}

	// 2: Cabinet set only contains 1 cabinet
	if (pcfheader->iCabinet != 0)
	{
		AssertSz(FALSE, "VerifyCabHeader: iCabinet != 0");
		goto Error;
	}

	// 3: The reserved sizes are as expected
	if (pheader->cfreserve.cbCFHeader != XONLINECONTENT_HEADER_RESERVE_SIZE)
	{
        AssertSz(FALSE, "VerifyCabHeader: Invalid header reserve size");
		goto Error;
	}

	if (pheader->cfreserve.cbCFFolder != XONLINECONTENT_PERFOLDER_RESERVE_SIZE)
	{				 
        AssertSz(FALSE, "VerifyCabHeader: Invalid per-folder reserve size");
		goto Error;
	}

	return(S_OK);		
	
Error:	
	return(HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
}

//
// Function to verify the PK signature of the header
//
HRESULT CXo::VerifyHeaderSignature(
			PXONLINECONTENT_INSTALL	pinstall,
			PXONLINECONTENT_HEADER	pheader,
			PBYTE					pbSignature
			)
{
    PBYTE		pbPublicKey = pinstall->rgbPublicKey;
    BYTE		rgbDigest[XC_DIGEST_LEN];
    BYTE        SHAHashContext[XC_SERVICE_SHA_CONTEXT_SIZE];
    
	// Run an SHA1 hash over the header to get the digest
    XcSHAInit(SHAHashContext);
    XcSHAUpdate(SHAHashContext, (PBYTE)pheader, XONLINECONTENT_FIXED_HEADER_SIZE_WITH_HMAC);
    XcSHAFinal(SHAHashContext, rgbDigest);

	// We will avoid using allocations here. We will use the LZX
	// history window as the workspace to verify the digest. This
	// window is at least 32k bytes so we should never overrun this
	if ((XcPKGetKeyLen(pbPublicKey) << 1) > XONLINECONTENT_LZX_WINDOW_SIZE)
	{
		AssertSz(FALSE, "VerifyHeaderSignature: public key length > 16k!");
		goto Error;
	}

	// Verify the digest against the encrypted signature, using the
	// LZX buffer as the workspace
	if (XcVerifyPKCS1Signature(pbSignature, pbPublicKey, rgbDigest) == FALSE)
		goto Error;

	return(S_OK);
	
Error:
	return(HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
}			

//
// Function to process fixed header data
//
HRESULT CXo::ProcessFixedHeader(
			PXONLINETASK_CONTENT_DOWNLOAD	pcontdl,
			PBYTE							pbheader
			)
{
	HRESULT						hr = S_OK;
	PXONLINECONTENT_INSTALL		pinstall = NULL;
	PXONLINECONTENT_HEADER		pheader = NULL;
	PRC4_SHA_HEADER				phmac = NULL;

	Assert(pcontdl != NULL);

	pinstall = &pcontdl->install;

#ifndef NO_SIGNATURE

	// Verify the signed portion 
	hr = VerifyHeaderSignature(pinstall, (PXONLINECONTENT_HEADER)pbheader, 
				pbheader + 
				XONLINECONTENT_FIXED_HEADER_SIZE_WITH_HMAC_AND_CHECKPOINT);
	if (FAILED(hr))
		goto Error;

#endif

	// Copy the data into the final destination
	memcpy(&pinstall->header, pbheader, 
				XONLINECONTENT_FIXED_HEADER_SIZE);

	// Point to the destination
	pheader = &pinstall->header;
	phmac = (PRC4_SHA_HEADER)(pbheader + XONLINECONTENT_FIXED_HEADER_SIZE);

#ifndef NO_ENCRYPT
	
	// OK, we have enough to start, initialize RC4 decryption
	hr = SymmdecInitialize(
				pinstall->rgbSymmetricKey, 
				XONLINE_KEY_LENGTH,
				XONLINECONTENT_FIXED_HEADER_SIZE,
				phmac,
				&pinstall->symmdecData);
	if (FAILED(hr))
		goto Error;

	// Decrypt the fixed header portion
	hr = SymmdecDecrypt(&pinstall->symmdecData,
				(PBYTE)pheader, XONLINECONTENT_FIXED_HEADER_SIZE);
	if (FAILED(hr))
		goto Error;

	// Make sure the Hmac checks out correct
	hr = SymmdecVerify(&pinstall->symmdecData);
	if (FAILED(hr))
		goto Error;

#endif

	// Verify the header
	hr = VerifyCabHeader(pheader);
	if (FAILED(hr))
		goto Error;

	return(S_OK);

Error:
	return(hr);
}

//
// Function to process CFFOLDER entries
//
HRESULT CXo::ProcessCffolderEntries(
			PXONLINETASK_CONTENT_DOWNLOAD	pcontdl,
			PBYTE							pbDataBegin
			)
{
	HRESULT						hr = S_OK;
	PXONLINECONTENT_INSTALL		pinstall = NULL;
	PXONLINECONTENT_HEADER		pheader = NULL;
	DWORD						cbSize;

	Assert(pcontdl != NULL);

	pinstall = &pcontdl->install;
	pheader = &pinstall->header;

	// Make sure the correct size is reserved per-folder
    Assert(pheader->cfreserve.cbCFFolder == sizeof(RC4_SHA_HEADER));
	cbSize = pheader->cfheader.cFolders;
	cbSize *= sizeof(CFFOLDER_HMAC);

	// Make sure the folder count makes sense
	if (pheader->cfheader.cFolders > XONLINECONTENT_MAX_CFFOLDER)
	{
		AssertSz(FALSE, "ProcessCffolderEntries: invalid folder count");
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		goto Error;
	}

	// Copy this data into its final destination
	memcpy(pinstall->rgcffolderhmac, pbDataBegin, cbSize);

#ifndef NO_ENCRYPT

	// Initialize RC4 decryption to decrypt CFFOLDER entries
	hr = SymmdecInitialize(
				pinstall->rgbSymmetricKey, 
				XONLINE_KEY_LENGTH,
				cbSize,
				&pheader->digestFolders,
				&pinstall->symmdecData);
	if (FAILED(hr))
		goto Error;

	// Decrypt the CFFOLDER entries
	hr = SymmdecDecrypt(&pinstall->symmdecData,
				(PBYTE)pinstall->rgcffolderhmac, cbSize);
	if (FAILED(hr))
		goto Error;

	// Make sure the Hmac checks out correct
	hr = SymmdecVerify(&pinstall->symmdecData);
	if (FAILED(hr))
		goto Error;

#endif

	// Now calculate the expected number of bytes of the whole
	// cached portion, including CFFILE entries. This is actually
	// just coffCabStart from the first CFFOLDER entry
	pinstall->dwExpected = pinstall->rgcffolderhmac[0].cffolder.coffCabStart;

	// Make sure the expected length is also more than the offset
	// to the first CFFILE entry
	if (pinstall->dwExpected < pinstall->header.cfheader.coffFiles)
	{
		AssertSz(FALSE, "ProcessCffolderEntries: invalid CFFILE offset");
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		goto Error;
	}

	return(S_OK);

Error:
	return(hr);
}

//
// Function to set up the state to install files in the specified folder
//
HRESULT CXo::SetupInstallFolder(
			PXONLINECONTENT_INSTALL	pinstall,
			DWORD					dwFolderIndex
			)
{
	HRESULT			hr;
	PCFFOLDER_HMAC	pcffolder = pinstall->rgcffolderhmac + dwFolderIndex;
	DWORD			cbFolderLength;

	// Validate folder index
	if (dwFolderIndex >= pinstall->header.cfheader.cFolders)
		return(HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
	
	// Reset the CFFILE and CFDATA data
	ZeroMemory(&pinstall->cfdata, sizeof(CFDATA));
	pinstall->cbUncompData = 0;
	pinstall->dwTemp = 0;

	// Figure out the exact length of the folder data, including all
	// intermittent CFDATA headers
	if (dwFolderIndex == (DWORD)(pinstall->header.cfheader.cFolders - 1))
	{
		// Last one, use the CAB length as reference
		cbFolderLength = pinstall->header.cfheader.cbCabinet;
	}
	else
	{
		// Point to the beginning of the next folder
		cbFolderLength = pcffolder[1].cffolder.coffCabStart;
	}
    Assert(cbFolderLength >= pcffolder->cffolder.coffCabStart);
	cbFolderLength -= pcffolder->cffolder.coffCabStart;

	// Initialize the decryption context for the specified folder
	hr = SymmdecInitialize(
				pinstall->rgbSymmetricKey, 
				XONLINE_KEY_LENGTH,
				cbFolderLength,
				&pcffolder->hmac,
				&pinstall->symmdecData);
	if (FAILED(hr))
		return(hr);
	
	// Reset the decompressor 
	LzxResetDecoder(&pinstall->lzx);
	
	// Set up for processing the specified folder
	pinstall->dwCurrentFolder = dwFolderIndex;
	pinstall->dwFolderOffset = 0;

	return(S_OK);	
}

//
// Function to reset the state after a failed resume attempt
//
VOID CXo::ResetAfterUnsuccessfulResume(
			PXONLINECONTENT_INSTALL	pinstall
			)
{
	// We set the expected size back to zero
	pinstall->dwExpected = 0;
	pinstall->dwWritten = 0;

	// Reset the CFFILE pointer so we reload the cache
	pinstall->pcffile = NULL;

	// We will not waste the cycles to open the cache
	// file again, we will yank it back out form our
	// CFFILE cache
	if ((pinstall->cffilecache.hFile != NULL) && 
		(pinstall->cffilecache.hFile != INVALID_HANDLE_VALUE))
	{
		pinstall->fileioData.hFile = pinstall->cffilecache.hFile;
		pinstall->cffilecache.hFile = INVALID_HANDLE_VALUE;
	}

	// Turn off the resume flag
	pinstall->dwFlags &= (~XONLINECONTENT_FLAG_RESUME);

	// Then the next state is to create a cache and download from scratch
	pinstall->dlphase = dlphaseCheckCache;
}

//
// Define the extension functions for ContentInstall
//

//
// Master cleanup function
//
VOID CXo::contdlCleanup(
			PXONLINETASK_CONTENT_DOWNLOAD	pcontdl
			)
{
	PXONLINECONTENT_INSTALL	pinstall = &pcontdl->install;

	// Cleanup absolutely everything in XONLINECONTENT_INSTALL
	if (pinstall->fileioData.hFile != INVALID_HANDLE_VALUE)
	{
		CloseHandle(pinstall->fileioData.hFile);
		pinstall->fileioData.hFile = INVALID_HANDLE_VALUE;
	}

	if (pinstall->verify.fileio.hFile != INVALID_HANDLE_VALUE)
	{
		CloseHandle(pinstall->verify.fileio.hFile);
		pinstall->verify.fileio.hFile = INVALID_HANDLE_VALUE;
	}

	CffileCacheDeinitialize(&pinstall->cffilecache);

	// Cleanup any XRL resources
	XRL_CleanupHandler(&(pcontdl->xrlasyncCatref.xrlasync));

	// If we mounted the private drive, we will need to unmount it
	XoUpdateUnmountPrivateDrive();

	// Wipe out all the data, especially the cryptographic keys
	ZeroMemory(pinstall, sizeof(XONLINECONTENT_INSTALL));
}			

//
// This function is called after all headers are received
//
HRESULT CXo::contdlDoneHeaders(
			PVOID	pvxrlasync
			)
{
	HRESULT							hr = S_OK;
	PXRL_ASYNC						pxrlasync = (PXRL_ASYNC)pvxrlasync;
	PXONLINETASK_CONTENT_DOWNLOAD	pcontdl;
	PXONLINECONTENT_INSTALL			pinstall;
	LARGE_INTEGER					liTemp;

	Assert(pxrlasync != NULL);
	
	// Extract the containg structure
	pcontdl = CONTAINING_RECORD(pxrlasync, 
					XONLINETASK_CONTENT_DOWNLOAD, xrlasync);
	pinstall = &pcontdl->install;					
	
	// Analyze the response code
	switch (pxrlasync->dwExtendedStatus)
	{
	case 200:
		// A 200 is coming back, which means the entire 
		// resource is returned by the server. 
		pinstall->dlphase = dlphaseRecvHeader;

		// Now we were expecting to resume, we have to make sure
		// everything is reverted back to its clean state
		if (pinstall->dwFlags & XONLINECONTENT_FLAG_RESUME)
		{
			// Reset the state
			ResetAfterUnsuccessfulResume(pinstall);
		}
		break;
		
	case 206:
		// This code is returned if a resume is attempted, and
		// that the server resource was not modified since the
		// date we supplied. This means that the server will 
		// return only the bytes that we don't already have.
		//
		// Just make sure we were expecting to resume
        Assert(pinstall->dwFlags & XONLINECONTENT_FLAG_RESUME);
		break;

	case 416:
		// This code means that the specified range is not 
		// satisfiable. This usually means that we already got 
		// the entire file to start with.
		//
		// We can move on to check the digest file and sign the
		// per-machine DRM
		pinstall->dwFlags |= XONLINECONTENT_FLAG_DONE_FILES;
		pinstall->dlphase = dlphaseSignDrm;
		break;
		
	default:
		hr = HRESULT_FROM_WIN32(ERROR_BAD_NET_RESP);
		TraceSz1(Verbose, "HTTP status: %u", pxrlasync->dwExtendedStatus);
	}

    return(hr);
}

//
// This function returnes whether the received data should be processed
// by the process data extension
//
BOOL CXo::contdlProcessData(
			PVOID	pvxrlasync
			)
{
	PXRL_ASYNC	pxrlasync = (PXRL_ASYNC)pvxrlasync;
	
	if (!IS_HEADER_MODE(pxrlasync))
		return(TRUE);
	return(FALSE);
}

HRESULT CXo::contdlCompleted(
			PVOID	pvxrlasync
			)
{
	HRESULT							hr = S_OK;
	PXRL_ASYNC						pxrlasync = (PXRL_ASYNC)pvxrlasync;
	PXONLINETASK_CONTENT_DOWNLOAD	pcontdl;
	LARGE_INTEGER					liTemp;

	Assert(pxrlasync != NULL);
	
	// Extract the containg structure
	pcontdl = CONTAINING_RECORD(pxrlasync, 
					XONLINETASK_CONTENT_DOWNLOAD, xrlasync);
	
	if (pcontdl->install.dwFlags & XONLINECONTENT_FLAG_DONE_FILES)
		return(S_OK);
	
	return(S_FALSE);
}

//
// Clenaup function for Download
//
VOID CXo::contdlCleanupHandler(
			PVOID	pvxrlasync
			)
{
	PXRL_ASYNC						pxrlasync = (PXRL_ASYNC)pvxrlasync;
	PXONLINETASK_CONTENT_DOWNLOAD	pcontdl;

	Assert(pxrlasync != NULL);
	
	// Extract the containg structure
	pcontdl = CONTAINING_RECORD(pxrlasync, 
					XONLINETASK_CONTENT_DOWNLOAD, xrlasync);
	contdlCleanup(pcontdl);	
}			

//
// Function to process header data
//
HRESULT CXo::contdlRecvHeader(
			PXONLINETASK_CONTENT_DOWNLOAD	pcontdl
			)
{
	HRESULT							hr = S_OK;
	PXRL_ASYNC						pxrlasync = NULL;
	PXONLINECONTENT_INSTALL			pinstall = NULL;
	PXONLINETASK_FILEIO				pfileio = NULL;
	DWORD							dwSize;

	Assert(pcontdl != NULL);

	pinstall = &pcontdl->install;
	pxrlasync = &pcontdl->xrlasync;

	// First figure out if this is the first time we are called.
	// This function may be called multiple times if the header
	// is large enough. We need to do some special initialization
	// the first time through
	if (pinstall->dwExpected == 0)
	{
		// We don't really want to waste time here. We want to at least
		// have the header and all the CFFOLDER entries in our buffer
		// before we even start to process the data
		dwSize = XONLINECONTENT_RESUME_MAX_READ_SIZE;
		if (pxrlasync->uliContentLength.QuadPart < dwSize)
			dwSize = pxrlasync->uliContentLength.u.LowPart;
		if (pxrlasync->dwCurrent < dwSize)
			goto Done;

		// By now, we would have received the entire header, plus all
		// CFFOLDER entries.

		// Call function to process fixed header
		hr = ProcessFixedHeader(pcontdl, pxrlasync->pBuffer);
		if (FAILED(hr))
			goto Error;

		// Make sure cabinet size equals reported content length
		if ((DWORD)pxrlasync->uliContentLength.u.LowPart != (DWORD)pinstall->header.cfheader.cbCabinet) 
		{
			AssertSz(FALSE, "Content length does not match package size");
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
			goto Error;
		}

		// Call another function to process the CFFOLDER entries
		// this also fills in pinstall->dwExpected
		hr = ProcessCffolderEntries(pcontdl,
					pxrlasync->pBuffer + XONLINECONTENT_COMPLETE_HEADER_SIZE);
		if (FAILED(hr))
			goto Error;

		// Make sure the size makes sense
		if (pinstall->dwExpected > pxrlasync->uliContentLength.QuadPart)
		{
			AssertSz(FALSE, "ProcessCffolderEntries: invalid data offset");
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
			goto Error;
		}

		// We nput some initiali random junk for the checkpoint in our 
		// original package to confound the prying eyes. Make sure our 
		// checkpoint is set to zero
		*(LPDWORD)(pxrlasync->pBuffer + XONLINECONTENT_CHECKPOINT) = 0;

		// We know exactly how much data to cache (pinstall->dwExpected).
		// grow the file to that size to not less than the epxected size
		hr = SetEndOfFileNt(
					pinstall->fileioData.hFile, 
					SECTOR_ALIGNMENT_ROUND_UP(pinstall->dwExpected));
		if (FAILED(hr))
			goto Error;

		// Fall thru ...
	}

	// See if we have a pending write
	if ((pinstall->dwFlags & XONLINECONTENT_FLAG_WRITE_PENDING) != 0)
	{
		XONLINETASK_HANDLE	hfileio = (XONLINETASK_HANDLE)&(pinstall->fileioData);
		DWORD				dwWritten;
		
		// We have a write pending, pump the subtask until
		// the write completes
		hr = XOnlineTaskContinue(hfileio);
		if (XONLINETASK_STATUS_AVAILABLE(hr))
		{
			// Turn off the pending flag
			pinstall->dwFlags &= (~XONLINECONTENT_FLAG_WRITE_PENDING);
		
			// Write had returned results, see if it succeeded
			if (FAILED(hr))
				goto Error;

			// Succeeded, now get the results and analyze the data
			hr = GetReadWriteFileResults(hfileio, &dwWritten, NULL);
			if (FAILED(hr))
				goto Error;

			// Written bytes should be a multiple of the sector size
			Assert(IS_HD_SECTOR_ALIGNED(dwWritten));

			// We consume the bytes that were successfully written.
			// Update the buffer state to reflect this
			pxrlasync->dwCurrent -= pinstall->dwTemp;
			MoveMemory(pxrlasync->pBuffer, 
						pxrlasync->pBuffer + pinstall->dwTemp,
						pxrlasync->dwCurrent);

			// Update written bytes
			dwWritten += pinstall->dwWritten;
			pinstall->dwWritten += pinstall->dwTemp;

			// OK, see if we have written all we need ...
			if (dwWritten >= pinstall->dwExpected)
			{
				// Make sure the actual bytes written match up
                Assert(pinstall->dwExpected == pinstall->dwWritten);

				// Set up for processing first folder
				hr = SetupInstallFolder(pinstall, 0);
				if (FAILED(hr))
					goto Error;

				// Now we have all the header data checked and verified, 
				// the cache file written and closed, we can set
				// up our CFFILE cache. It will inherit the file handle
				// from pinstall->fileioData.hFile.
				// We will first verify the CFFILE entries before we
				// use them to prevent using invalid data. We will use
				// the decompress buffer for this because it is much
				// larger and still available at this point.

				// Figure out the size of CFFILE entries
				dwWritten = pinstall->dwExpected - 
								pinstall->header.cfheader.coffFiles;
				hr = CffileCacheInitialize(
							pinstall->fileioData.hFile,
							pinstall->header.cfheader.coffFiles,
							pinstall->header.cfheader.cFiles,
							pinstall->rgbSymmetricKey, 
							XONLINE_KEY_LENGTH,
							dwWritten,
							pinstall->rgbDecompress,
							XONLINECONTENT_LZX_OUTPUT_SIZE,
							&(pinstall->header.digestFiles),
							pinstall->xontask.hEventWorkAvailable, 
							&(pinstall->cffilecache));
				if (FAILED(hr))
					goto Error;

				// The CFFILE cache had taken over the file handle, 
				// mark this one as invalid.
				pinstall->fileioData.hFile = INVALID_HANDLE_VALUE;

				// We will move on to verify the CFFILE entries
				pinstall->dlphase = dlphaseVerifyCffiles;

				// Now we may have more data already in our buffer,
				// if we do, we will continue processing until we have
				// processing all data in the buffer
				if (pxrlasync->dwCurrent)
					goto Exit;
			}

			// Set the don't continue flag to get more data
			goto Done;
		}
	}

	if ((pinstall->dwFlags & XONLINECONTENT_FLAG_WRITE_PENDING) == 0)
	{
		PXONLINETASK_FILEIO	pfileio2 = &pinstall->fileioData;
		ULARGE_INTEGER		uliOffset;
	
		// We came in with no pending write, write out as much as we can
		// do all the math to do the sector alignment and stuff
		if ((pinstall->dwWritten + pxrlasync->dwCurrent) >= pinstall->dwExpected)
		{
			pinstall->dwTemp = pinstall->dwExpected - pinstall->dwWritten;
			dwSize = SECTOR_ALIGNMENT_ROUND_UP(pinstall->dwTemp);
		}
		else
		{
			dwSize = SECTOR_ALIGNMENT_ROUND_DOWN(pxrlasync->dwCurrent);
			pinstall->dwTemp = dwSize;
		}

		Assert(dwSize > 0);

		// Kick off async write
		uliOffset.QuadPart = pinstall->dwWritten;
		ReadWriteFileInitializeContext(pfileio2->hFile,
					pxrlasync->pBuffer, dwSize, uliOffset, 
					pinstall->xontask.hEventWorkAvailable, 
					pfileio2);

		hr = WriteFileInternal(pfileio2);
		if (FAILED(hr))
			goto Error;

		// Set the flag to indicate that we are pending write complete
		pinstall->dwFlags |= XONLINECONTENT_FLAG_WRITE_PENDING;		
	}
	
Exit:
	return(S_OK);

Error:
	return(hr);

Done:
	return(XONLINETASK_S_SUCCESS);
}

//
// Function to process raw CAB data and install files
//
HRESULT CXo::contdlInstallFiles(
			PXONLINETASK_CONTENT_DOWNLOAD	pcontdl
			)
{
	HRESULT							hr = S_OK;
	PXRL_ASYNC						pxrlasync;
	PXONLINECONTENT_INSTALL			pinstall;
	PBYTE							pbBuffer;
	DWORD							cbAvailable;
	DWORD							dwIndex;
	WORD							wCompType;

	Assert(pcontdl != NULL);

	pinstall = &pcontdl->install;
	pxrlasync = &pcontdl->xrlasync;

	// Figure out if we are starting a new target file.
	if (!pinstall->pcffile)
	{
		// Yup, we have no current CFFILE, which means we are either
		// called for the first time, or we have just completely processed 
		// the previous target file. 

		// We try to get the next CFFILE entry from the cache.
		hr = CffileCacheGetNextEntry(
					&pinstall->cffilecache,
					&dwIndex,
					&pinstall->pcffile,
					&pinstall->szFileName,
					&pinstall->cbFileName);
		if (FAILED(hr))
			goto Error;

		// Now see if we got it right away ...
		if (hr == S_CFFILECACHE_IO_PENDING)
		{
			// Nope, the next entry happens to be on disk and we have
			// to load it up. There's nothing we can do now, so might
			// as well return to the dispatcher. 
			hr = S_OK;
			goto Exit;
		}

		if (hr == S_CFFILECACHE_NO_MORE_ITEMS)
		{
#ifndef NO_ENCRYPT
		
			// There are no more items, we are done with the CAB. Make
			// sure the data in the last folder is authentic.
			hr = SymmdecVerify(&pinstall->symmdecData);
			if (FAILED(hr))
				goto Error;

			// Also make sure the file cache is good
			hr = CffileCacheVerifyChecksum(
						&pinstall->cffilecache);
			if (FAILED(hr))
				goto Error;
						
#endif

			// We are done with installation phase
			pinstall->dwFlags |= XONLINECONTENT_FLAG_DONE_FILES;

			// Close the file
			if (pinstall->fileioData.hFile != INVALID_HANDLE_VALUE)
			{
				CloseHandle(pinstall->fileioData.hFile);
				pinstall->fileioData.hFile = INVALID_HANDLE_VALUE;
			}
			
			// Move on to the next phase ...
			pinstall->dlphase = dlphaseSignDrm;
			hr = XONLINETASK_S_SUCCESS;
			goto Exit;
		}
		
		// Got new CFFILE entry, now check to see if we need to create
		// the file.
		if (pinstall->pcffile->time & XONLINECONTENT_A_CONTINUED_FROM_PREV)
		{
			// This folder is actually a continuation of the same file from
			// a previous folder (note: this is an Xbox extension of the CAB
			// format and is not supported in the standard CAB format).
			// Instead of creating a new file, we will continue with the
			// same file handle.
			pinstall->dwExpected += pinstall->pcffile->cbFile;
			TraceSz3(Verbose, "[%u] Continuing %s, %u bytes", dwIndex, 
                     pinstall->szFileName, pinstall->dwExpected);

			// Must be first file in folder
            Assert(pinstall->pcffile->uoffFolderStart == 0);

			// Mark the fact that the file is to be continued
			pinstall->dwFlags |= XONLINECONTENT_FLAG_CONTINUE_FILE;
		}
		else
		{
			// This is a fresh file, go and create it.
			pinstall->dwExpected = pinstall->pcffile->cbFile;
			pinstall->dwWritten = 0;
//			TraceSz3(Verbose, "[%u] Installing %s, %u bytes", 
//					dwIndex, pinstall->szFileName, pinstall->dwExpected);

			// Create the new file
			pinstall->dlphase = dlphaseCreateTarget;
		}

		// OK, we got the next CFFILE entry. Figure out if we're in the same
		// folder
		dwIndex = pinstall->pcffile->iFolder;
		if (dwIndex != pinstall->dwCurrentFolder)
		{
#ifndef NO_ENCRYPT
		
			// Different folder. This means we should move on to the next
			// one. But this also means that we have extracted all files
			// from this folder. We will run the Hmac checksum to make sure
			// all data is authentic.
			hr = SymmdecVerify(&pinstall->symmdecData);
			if (FAILED(hr))
				goto Error;

#endif

            Assert(dwIndex == (pinstall->dwCurrentFolder + 1));

			// Set up for next folder
			hr = SetupInstallFolder(pinstall, dwIndex);
			if (FAILED(hr))
				goto Error;

			// Write out thie checkpoint
			pinstall->dlphase = dlphaseCheckpoint;
			goto Exit;
		}

		// Make sure the folder offsets match up
        Assert(pinstall->pcffile->uoffFolderStart == pinstall->dwFolderOffset);

		// Break out if we are going to another phase
		if (pinstall->dlphase != dlphaseInstallFiles)
			goto Exit;
	}
	
	// If we get here, we can safely assume that we have a CFFILE
	// entry to process, and that the folder is set to the correct
	// index.

	pbBuffer = pxrlasync->pBuffer;
	cbAvailable = pxrlasync->dwCurrent;

	// Now see if we need a new CFDATA block
	if (pinstall->cfdata.cbUncomp == 0)
	{
		// Yup, we need to get the next CFDATA entry
		// If we don't even have the minimum required amount of data, just
		// return and ask for more data
		if (cbAvailable < sizeof(CFDATA))
		{
			hr = XONLINETASK_S_SUCCESS;
			goto Exit;
		}

#ifndef NO_ENCRYPT

		// Decrypt the CFDATA header
		hr = SymmdecDecrypt(&pinstall->symmdecData,
					pbBuffer, sizeof(CFDATA));
		if (FAILED(hr))
			goto Error;

#endif

		// Copy into pinstall->cfdata
		memcpy(&pinstall->cfdata, pbBuffer, sizeof(CFDATA));

		// Adjust the values
		pbBuffer += sizeof(CFDATA);
		cbAvailable -= sizeof(CFDATA);

		// Mark the fact that the data is not decrypted/decompressed
		// yet.
		pinstall->cbUncompData = 0;
	}

	// See if we need to decrypt/decompress that data
	if (pinstall->cbUncompData == 0)
	{
		// Decompression needs to work on full blocks. The block size varies
		// from block to block. To overcome this, we will wait until we have
		// the full block, and then we will decrypt and decompress at the same
		// time.
		if (cbAvailable >= pinstall->cfdata.cbData)
		{
#ifndef NO_ENCRYPT
		
			// Yes, we have the full block. We can decrypt and decompress
			hr = SymmdecDecrypt(&pinstall->symmdecData,
						pbBuffer, pinstall->cfdata.cbData);
			if (FAILED(hr))
				goto Error;

#endif

//			TraceSz1(Verbose, "typeCompress = %04x", 
//					pinstall->rgcffolderhmac[pinstall->dwCurrentFolder].cffolder.typeCompress);

			// Decompress this data if necessary
			wCompType = pinstall->rgcffolderhmac[pinstall->dwCurrentFolder].
								cffolder.typeCompress;
			switch (CompressionTypeFromTCOMP(wCompType))
			{
			case tcompTYPE_NONE:
				// Just copy into our decompressed buffer
				memcpy(pinstall->rgbDecompress, pbBuffer, pinstall->cfdata.cbData);
				break;
				
			case tcompTYPE_LZX:
				// Make sure the our window is big enough to handle the specified
				// window bits ...
				dwIndex = 1 << LZXCompressionWindowFromTCOMP(wCompType);
				if (dwIndex > XONLINECONTENT_LZX_WINDOW_SIZE)
				{
					// Our window is not big enough to decode this data, we must
					// fail
					hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
					goto Error;
				}

				// Decompress the data
				if (!LzxDecode(
							&pinstall->lzx, 
							pinstall->cfdata.cbUncomp,
							pbBuffer, 
							pinstall->cfdata.cbData, 
							pinstall->rgbDecompress + pinstall->dwTemp, 
							&pinstall->cbUncompData) ||
					(pinstall->cfdata.cbUncomp != pinstall->cbUncompData))
				{
					hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
					goto Error;
				}
				break;

			default:
				// Don't support anything else for now
				AssertSz(FALSE, "Unsupported compression type!");
				hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
				goto Error;
			}

			// Adjust the amount of uncompressed data to include any residue
			// carried over from a previous CFDATA
			pinstall->cbUncompData += pinstall->dwTemp;
			pinstall->cfdata.cbUncomp = (WORD)pinstall->cbUncompData;
			pinstall->dwTemp = 0;

			// Skip over all data that we processed
			pbBuffer += pinstall->cfdata.cbData;
			cbAvailable -= pinstall->cfdata.cbData;
			
			// Write out this data
			pinstall->dlphase = dlphaseWriteTarget;
		}
		else
		{
			// Well, we might have more data but not enough to fill
			// the whole block. We will have to receive more data to
			// continue ...
			hr = XONLINETASK_S_SUCCESS;
		}
	}
	else
	{
		// Well, we got some more data, write it out!
		pinstall->dlphase = dlphaseWriteTarget;
	}

	// Move unprocessed data up to the front
	pxrlasync->dwCurrent = cbAvailable;
	MoveMemory(pxrlasync->pBuffer, pbBuffer, cbAvailable);
	
Exit:
	return(hr);

Error:
	goto Exit;
}

//
// Function to create the target file and grow it to a certain size
//
HRESULT CXo::contdlCreateTarget(
			PXONLINETASK_CONTENT_DOWNLOAD	pcontdl
			)
{
	HRESULT					hr = S_OK;
	PXONLINECONTENT_INSTALL	pinstall = NULL;
	PXONLINETASK_FILEIO		pfileio = NULL;
	XONLINEDIR_TYPE			dirtype;
	LARGE_INTEGER			liFileSize;
	DWORD					dwAlignedSize;
	DWORD					cbPath;

	Assert(pcontdl != NULL);

	pinstall = &pcontdl->install;
	pfileio = &pinstall->fileioData;

	// Close the previous file if opened
	if (pfileio->hFile != INVALID_HANDLE_VALUE)
	{
		CloseHandle(pfileio->hFile);
		pfileio->hFile = INVALID_HANDLE_VALUE;
	}

	// Figure out the target directory based on the type of content
	// currently installing
	dirtype = pinstall->dirtypeTarget;
	
	// CFFILE.time contains the flag that tells us whether this 
	// file should be in the title or user partition
	if ((pinstall->pcffile->time & XONLINECONTENT_A_USER_DATA) != 0)
		dirtype = dirtypeUserContent;
	
	// Build the target path
	cbPath = XONLINECONTENT_MAX_PATH;
	hr = BuildTargetPath(pinstall->dwTitleId, 
				pinstall->OfferingId,
				pinstall->dwBitFlags,
				pinstall->szFileName, 
				dirtype,
				&cbPath, pinstall->szPath);
	if (FAILED(hr))
		return(hr);

	// We will open this file if it exists, or create if not.
	pfileio->hFile = CreateFile(
				pinstall->szPath, 
				GENERIC_READ | GENERIC_WRITE, 
				FILE_SHARE_READ, 
				NULL, 
				OPEN_ALWAYS, 
				FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN |
				FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING, 
				NULL);
	if (pfileio->hFile == INVALID_HANDLE_VALUE)
	{
		DWORD	dwError = GetLastError();
		if (dwError == ERROR_PATH_NOT_FOUND)
		{
			// Directory does not exists, go ahead and create it
			hr = CreateDirectoryInitializeContext(
						pinstall->szPath, 
						cbPath,
						XONLINETASK_CDFLAG_FILE_PATH,
						pinstall->xontask.hEventWorkAvailable,
						&pinstall->dirops);
			if (FAILED(hr))
				return(hr);
				
			pinstall->dlphase = dlphaseCreateDirectory;
			goto Exit;
		}

		return(HRESULT_FROM_WIN32(dwError));
	}

	// Now figure out the current file size
	if (!GetFileSizeEx(pfileio->hFile, &liFileSize))
		return(HRESULT_FROM_WIN32(GetLastError()));

	// Figure out what the sector aligned round up size is
	dwAlignedSize = SECTOR_ALIGNMENT_ROUND_UP(pinstall->dwExpected);
	
	// If file is too small, figure out a good growth size
	if (liFileSize.QuadPart < dwAlignedSize)
	{
		if ((dwAlignedSize - liFileSize.u.LowPart) >
			XONLINECONTENT_INCREMENTAL_GROW_FILE_SIZE)
		{
			// Grow by XONLINECONTENT_INCREMENTAL_GROW_FILE_SIZE
			dwAlignedSize = SECTOR_ALIGNMENT_ROUND_UP(
						liFileSize.u.LowPart) + 
						XONLINECONTENT_INCREMENTAL_GROW_FILE_SIZE;
		}
	}

	// Set the end of file position at dwAlignedSize
	hr = SetEndOfFileNt(pfileio->hFile, dwAlignedSize);
	if (FAILED(hr))
		return(hr);

	// Go back to installing files
	pinstall->dwFileSize = dwAlignedSize;
	pinstall->dlphase = dlphaseInstallFiles;
	
Exit:
	return(S_OK);
}

//
// Function to write to the target file and grow it if necessary
//
HRESULT CXo::contdlWriteTarget(
			PXONLINETASK_CONTENT_DOWNLOAD	pcontdl
			)
{
	HRESULT					hr = S_OK;
	PXONLINECONTENT_INSTALL	pinstall = NULL;
	PXONLINETASK_FILEIO		pfileio = NULL;
	DWORD					dwToWrite;
	DWORD					dwRemaining;
	DWORD					dwNewSize;

	Assert(pcontdl != NULL);

	pinstall = &pcontdl->install;
	pfileio = &pinstall->fileioData;

    Assert(IS_HD_SECTOR_ALIGNED(pinstall->dwWritten));
    Assert(IS_HD_SECTOR_ALIGNED(pinstall->dwFileSize));

	// See if we have a pending write
	if ((pinstall->dwFlags & XONLINECONTENT_FLAG_WRITE_PENDING) != 0)
	{
		XONLINETASK_HANDLE	hfileio = (XONLINETASK_HANDLE)pfileio;
		DWORD				dwWritten;
		
		// We have a write pending, pump the subtask until
		// the write completes
		hr = XOnlineTaskContinue(hfileio);
		if (XONLINETASK_STATUS_AVAILABLE(hr))
		{
			// Turn off the pending flag
			pinstall->dwFlags &= (~XONLINECONTENT_FLAG_WRITE_PENDING);
		
			// Write had returned results, see if it succeeded
			if (FAILED(hr))
				goto Error;

			// Succeeded, now get the results and analyze the data
			hr = GetReadWriteFileResults(hfileio, &dwWritten, NULL);
			if (FAILED(hr))
				goto Error;

			// Written bytes should be a multiple of the sector size
			Assert(IS_HD_SECTOR_ALIGNED(dwWritten));
            Assert(pinstall->dwTemp <= pinstall->cbUncompData);

			// We consume the bytes that were successfully written.
			// Move unprocessed data up to the front
			pinstall->cbUncompData -= pinstall->dwTemp;
			pinstall->cfdata.cbUncomp = (WORD)pinstall->cbUncompData;
			pinstall->dwFolderOffset += pinstall->dwTemp;
			MoveMemory(pinstall->rgbDecompress, 
						pinstall->rgbDecompress + pinstall->dwTemp,
						pinstall->cbUncompData);

			// Update written bytes
			pinstall->dwWritten += dwWritten;

			// OK, see if we have written all we need ...
			if (pinstall->dwWritten >= pinstall->dwExpected)
			{
				// Yup, written everything, chop off extra bytes if we
				// have written too much (a la unbuffered write). 
				if (pinstall->dwWritten > pinstall->dwExpected)
				{
					hr = SetEndOfFileNt(
								pinstall->fileioData.hFile, 
								pinstall->dwExpected);
					if (FAILED(hr))
						goto Error;
				}

				// We know we are done with this CFFILE, move to next
				pinstall->pcffile = NULL;
				pinstall->dlphase = dlphaseInstallFiles;
				goto Exit;
			}

			// OK, we're not quite done yet, and we're at the end of
			// this CFDATA block (maybe with some residue as well)
            Assert(pinstall->cbUncompData < XBOX_HD_SECTOR_SIZE);

			// We mark the residue with pinstall->cbUncompDone, and reset
			// CFDATA.cbUncomp to zero. This will force a new CFDATA to
			// be read, and we can combine this data together
			pinstall->dwTemp = pinstall->cbUncompData;
			pinstall->cfdata.cbUncomp = 0;

			// Back to install files
			pinstall->dlphase = dlphaseInstallFiles;
		}
	}
	else
	{
		ULARGE_INTEGER		uliOffset;

		// Figure out how much we are writing out this time, as well
		// as how many effective bytes were written (not including
		// filler for sector alignment). However, if this is a 
		// continuation file, we don't write past end.
		dwRemaining = pinstall->dwExpected - pinstall->dwWritten;

		if ((pinstall->cbUncompData >= dwRemaining) &&
			!(pinstall->pcffile->time & XONLINECONTENT_A_CONTINUED_INTO_NEXT))
		{
			pinstall->dwTemp = dwRemaining;
			dwToWrite = SECTOR_ALIGNMENT_ROUND_UP(dwRemaining);
		}
		else
		{
			dwToWrite = SECTOR_ALIGNMENT_ROUND_DOWN(pinstall->cbUncompData);
			pinstall->dwTemp = dwToWrite;
		}

		// Figure out if we need to grow the file ...
		if (pinstall->dwFileSize < (pinstall->dwWritten + dwToWrite))
		{
			// We need to grow the file anyway, figure out by how much
			dwNewSize = SECTOR_ALIGNMENT_ROUND_UP(pinstall->dwExpected);
			if ((dwNewSize - pinstall->dwFileSize) > 
						XONLINECONTENT_INCREMENTAL_GROW_FILE_SIZE)
			{
				// Grow by XONLINECONTENT_INCREMENTAL_GROW_FILE_SIZE
				dwNewSize = pinstall->dwFileSize + XONLINECONTENT_INCREMENTAL_GROW_FILE_SIZE;
			}

			hr = SetEndOfFileNt(pfileio->hFile, dwNewSize);
			if (FAILED(hr))
				return(hr);

			// Update the file size
			pinstall->dwFileSize = dwNewSize;
		}
	
		// We came in with no pending write, write out the data
		uliOffset.QuadPart = pinstall->dwWritten;
		ReadWriteFileInitializeContext(pfileio->hFile,
					pinstall->rgbDecompress,
					dwToWrite,
					uliOffset,
					pinstall->xontask.hEventWorkAvailable, 
					pfileio);

		hr = WriteFileInternal(pfileio);
		if (FAILED(hr))
			goto Error;

		// Set the flag to indicate that we are pending write complete
		pinstall->dwFlags |= XONLINECONTENT_FLAG_WRITE_PENDING;		
	}

Exit:
	return(S_OK);

Error:
	return(hr);
}

//
// Function to recursively create the directories for the target
//
HRESULT CXo::contdlCreateDirectory(
			PXONLINETASK_CONTENT_DOWNLOAD	pcontdl
			)
{
	HRESULT				hr = S_OK;
	XONLINETASK_HANDLE	hdirops;

	Assert(pcontdl != NULL);

	// Retrieve the dirops structure
	hdirops = (XONLINETASK_HANDLE)&(pcontdl->install.dirops);
	hr = XOnlineTaskContinue(hdirops);
	if (XONLINETASK_STATUS_AVAILABLE(hr))
	{
		// Create dir had returned results, see if it succeeded
		if (FAILED(hr))
			goto Exit;

		// Go back to create target phase
		hr = S_OK;
		pcontdl->install.dlphase = dlphaseCreateTarget;
	}

Exit:
	return(hr);
}

//
// Function to wipe the target location before a clean install
//
HRESULT CXo::contdlWipeTarget(
			PXONLINETASK_CONTENT_DOWNLOAD	pcontdl
			)
{
	HRESULT					hr = S_OK;
	DWORD					cbPath;
	PXONLINECONTENT_INSTALL	pinstall;

	Assert(pcontdl != NULL);

	// Retrieve the dirops structure
	pinstall = &pcontdl->install;

	// Make sure the directories are created if they are not
	// already there
	hr = XOnlineTaskContinue((XONLINETASK_HANDLE)&(pcontdl->install.dirops));
	if (XONLINETASK_STATUS_AVAILABLE(hr))
	{
		// Create dir had returned results, see if it succeeded
		if (FAILED(hr))
			goto Error;

		// Build the root target path for this package
		cbPath = XONLINECONTENT_MAX_PATH;
		hr = BuildTargetPath(
					pinstall->dwTitleId, 
					pinstall->OfferingId,
					pinstall->dwBitFlags,
					XONLINECONTENT_CACHE_FILE_NAME,
					pinstall->dirtypeTarget,
					&cbPath,
					pinstall->szPath);
		if (FAILED(hr))
			goto Error;
			
		// Make sure all the directories are created
		hr = CreateDirectoryInitializeContext(
					pinstall->szPath, 
					cbPath,
					XONLINETASK_CDFLAG_FILE_PATH,
					pinstall->xontask.hEventWorkAvailable,
					&pinstall->dirops);
		if (FAILED(hr))
			goto Error;

		// Now we can create the cache
		pinstall->dlphase = dlphaseCreateCache;
	}

Exit:
	return(hr);

Error:
	// Deal with errors swiftly
	goto Exit;
}

//
// Function to create the cache
//
HRESULT CXo::contdlCreateCache(
			PXONLINETASK_CONTENT_DOWNLOAD	pcontdl
			)
{
	HRESULT					hr = S_OK;
	PXONLINECONTENT_INSTALL	pinstall;
	PXONLINETASK_FILEIO		pfileio;
	XONLINETASK_HANDLE		hdirops;
	PXRL_ASYNC				pxrlasync;
	LARGE_INTEGER			liTemp;

	Assert(pcontdl != NULL);

	// Retrieve the dirops structure
	pinstall = &pcontdl->install;
	pxrlasync = &pcontdl->xrlasync;
	pfileio = &pinstall->fileioData;
	hdirops = (XONLINETASK_HANDLE)&(pinstall->dirops);

	// Make sure the directories are created if they are not
	// already there
	hr = XOnlineTaskContinue(hdirops);
	if (XONLINETASK_STATUS_AVAILABLE(hr))
	{
		// Create dir had returned results, see if it succeeded
		if (FAILED(hr))
			goto Error;

		// Create the cache file. This should succeed
		hr = S_OK;
		TraceSz1(Verbose, "Creating cache file: %s", pinstall->szPath);
		pfileio->hFile = CreateFile(
					pinstall->szPath, 
					GENERIC_READ | GENERIC_WRITE, 
					FILE_SHARE_READ, 
					NULL, 
					CREATE_ALWAYS, 
					FILE_ATTRIBUTE_NORMAL |
					FILE_FLAG_OVERLAPPED | 
					FILE_FLAG_NO_BUFFERING, 
					NULL);
		if (pfileio->hFile == INVALID_HANDLE_VALUE)
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			goto Error;
		}

		// Cache the next phase, and see if we have custom tasks
		pinstall->dlphaseNext = dlphaseRecvHeader;
		pinstall->dlphase = dlphasePreCustom;
	}

Exit:
	return(hr);

Error:
	// Deal with errors swiftly
	goto Exit;
}

//
// Function to wait for catref request to return
//
HRESULT CXo::contdlCatref(
			PXONLINETASK_CONTENT_DOWNLOAD	pcontdl
			)
{
	HRESULT					hr = S_OK;
	PXRL_ASYNC				pxrlasync;
	PXRL_ASYNC_EXTENDED		pxrlasyncextCatref;
	XONLINETASK_HANDLE		hCatref;
	PBYTE					pbBuffer;
	DWORD					cbBuffer;
	DWORD					dwHttpStatus = 0;
	ULARGE_INTEGER			uliContentLength;	

	Assert(pcontdl != NULL);

	pxrlasyncextCatref = &pcontdl->xrlasyncCatref;
	pxrlasync = &pxrlasyncextCatref->xrlasync;
	hCatref = (XONLINETASK_HANDLE)pxrlasyncextCatref;

	// Wait for the CATREF request to complete
	hr = XOnlineTaskContinue(hCatref);
	if (XONLINETASK_STATUS_AVAILABLE(hr))
	{
		// CATREF had returned results, see if it succeeded
		if (FAILED(hr))
			goto Error;

		// We got the entire cache, process it.
		hr = XOnlineUploadGetResults(
					hCatref, &pbBuffer, &cbBuffer, 
					NULL, &uliContentLength,
					&dwHttpStatus, NULL);
		if (FAILED(hr))
			goto Error;

		// Check if we have a favorable result from the CATREF server
		// We expect a 200 return code on success, any other code will be 
		// deemed an error.
		if (dwHttpStatus != XONLINEUPLOAD_EXSTATUS_SUCCESS)
		{
			// The CATREF request did not succeed, we will return a specific
			// return code indicating that the server is unavailable.
			hr = HRESULT_FROM_WIN32(ERROR_SERVICE_SPECIFIC_ERROR);
			goto Error;
		}

		// Now check whether the package is found in CATREF
		if (pxrlasync->hrXErr == S_FALSE)
		{
			// CATREF request succeeded, but the package is not found.
			// so we return a relevant error code
			hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
			goto Error;
		}

		// Make sure the info returned makes sense. This also implies
		// that everything that comes back fits in our buffer
		Assert(pbBuffer != NULL);
		Assert(uliContentLength.u.HighPart == 0);
		Assert(cbBuffer == uliContentLength.u.LowPart);

		// Parse the returned buffer to get the required fields
		hr = ParseReferralResults(pcontdl, pbBuffer, cbBuffer);
		if (FAILED(hr))
			goto Error;

		// OK, got the referral info, move on to check if we have
		// an existing and valid cache.
		pcontdl->install.dlphase = dlphaseCheckCache;
	}					

Exit:
	return(hr);

Error:
	TraceSz2(Verbose, "Failed to get CATREF referral (%h), HTTP response code %u", 
				hr, dwHttpStatus);

	// BUGBUG: We could possibly implement retry logic here ...
	
	// Change the error code to specifically indicate that the failure
	// occurred during CATREF referral.
	hr = HRESULT_FROM_WIN32(ERROR_SERVICE_SPECIFIC_ERROR);
	goto Exit;
}

//
// Function to see if we have a valid cache file on the hard disk (resume)
//
HRESULT CXo::contdlCheckCache(
			PXONLINETASK_CONTENT_DOWNLOAD	pcontdl
			)
{
	HRESULT					hr = S_OK;
	PXRL_ASYNC				pxrlasync = NULL;
	PXONLINECONTENT_INSTALL	pinstall = NULL;
	PXONLINETASK_FILEIO		pfileio = NULL;
	LARGE_INTEGER			liFileSize;
	ULARGE_INTEGER			uliTemp;
	DWORD					dwAlignedSize;
	DWORD					cbPath;

	Assert(pcontdl != NULL);

	pinstall = &pcontdl->install;
	pxrlasync = &pcontdl->xrlasync;
	pfileio = &pinstall->fileioData;

	// Build the root target path for this package
	cbPath = XONLINECONTENT_MAX_PATH;
	hr = BuildTargetPath(
				pinstall->dwTitleId, 
				pinstall->OfferingId,
				pinstall->dwBitFlags,
				XONLINECONTENT_CACHE_FILE_NAME,
				pinstall->dirtypeTarget,
				&cbPath,
				pinstall->szPath);
	if (FAILED(hr))
		goto Error;

	// Just create a new cache on an offline install 
	// (Don't handle resume in this case)
	if (pinstall->dwFlags & XONLINECONTENT_FLAG_OFFLINE_INSTALL)
		goto NoCache;

	// We will skip this if the file is already open. For example, if
	// we are here bacause of an aborted resume, the file is already open
	// and we would have to skip this mumbo-jumbo anyway.
	if ((pfileio->hFile == NULL) || (pfileio->hFile == INVALID_HANDLE_VALUE))
	{
		// Attempt to open the cache file
		pfileio->hFile = CreateFile(
					pinstall->szPath, 
					GENERIC_READ | GENERIC_WRITE, 
					FILE_SHARE_READ, 
					NULL, 
					OPEN_EXISTING, 
					FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN |
					FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING, 
					NULL);
		if (pfileio->hFile != INVALID_HANDLE_VALUE)
		{
			// We got a cache file here, see if we can actually use it to
			// resume from somewhere

			// Get the file size
			if (!GetFileSizeEx(pfileio->hFile, &liFileSize))
			{
				// This is a recoverable error: we will just assume there
				// is no cache file
				goto NoCache;
			}
			
			// Make sure cache size makes sense
			if (liFileSize.u.LowPart > XONLINECONTENT_COMPLETE_HEADER_SIZE)
			{
				// Figure out how much to read and sector-align
				pinstall->dwExpected = XONLINECONTENT_RESUME_MAX_READ_SIZE;
				if (liFileSize.u.LowPart < XONLINECONTENT_RESUME_MAX_READ_SIZE)
					pinstall->dwExpected = liFileSize.u.LowPart;
				dwAlignedSize = SECTOR_ALIGNMENT_ROUND_UP(pinstall->dwExpected);

				// Read in the entire cache file
				uliTemp.QuadPart = 0;
				ReadWriteFileInitializeContext(
							pfileio->hFile,
							pinstall->rgbDecompress,
							dwAlignedSize,
							uliTemp,
							pinstall->xontask.hEventWorkAvailable, 
							pfileio);

				hr = ReadFileInternal(pfileio);
				if (FAILED(hr))
					goto Error;

				// Use the existing cache
				pinstall->dlphase = dlphaseReadCache;
				pinstall->dwFlags |= XONLINECONTENT_FLAG_RESUME;
			}
		}
		else
		{
			DWORD	dwError = GetLastError();
			
			// Make sure we can't open it because it's not there
			if ((dwError == ERROR_FILE_NOT_FOUND) ||
				(dwError == ERROR_PATH_NOT_FOUND))
			{
				// See if we need to check if the package was actually properly
				// installed
				if ((pinstall->dwFlags & XONLINECONTENT_FLAG_NOT_INSTALLED) == 0)
				{
					// See if a manifest exists, and if so, whether it is signed
					hr = VerifyOrSignManifestBegin(pinstall, NULL);
					if (FAILED(hr))
					{
						// Can't open the manifest, we will re-install
						goto NoCache;
					}

					// Got a manifest, see if it's valid
					pinstall->dlphase = dlphaseVerifyInstall;					
					goto Exit;
				}
			}
			
			// This is a recoverable error: we will just assume there
			// is no cache file
			goto NoCache;
		}
	}

CreateCache:

	// See if we are going to resume
	if ((pinstall->dwFlags & XONLINECONTENT_FLAG_RESUME) == 0)
	{
		// If we get here, we are doing a straight download. Now 
		// we build the proper request from the CATREF information
		pxrlasync->wsabuf.len = pxrlasync->cbBuffer;
		pxrlasync->wsabuf.buf = (char *)pxrlasync->pBuffer;
		liFileSize.QuadPart = 0;
		
	    hr = XRL_BuildGetRequestWithResume(
						pxrlasync->serviceInfo.dwServiceID,
	    				pinstall->szResourcePath,
	    				pxrlasync->serviceInfo.serviceIP.s_addr,
	    				pxrlasync->wsabuf.buf, 
	    				&(pxrlasync->wsabuf.len), 
	    				NULL, 0, NULL, liFileSize);
	    if (FAILED(hr))
	        goto Error;

		// If the cache file is open (i.e. retry after detecting corrupt
		// cache file), then close it first.
		if (pfileio->hFile != INVALID_HANDLE_VALUE)
		{
			CloseHandle(pfileio->hFile);
			pfileio->hFile = INVALID_HANDLE_VALUE;
		}

		// Build the target path to wipe
		cbPath = XONLINECONTENT_MAX_PATH;
		hr = BuildTargetDirectory(
					pinstall->dwTitleId, 
					pinstall->OfferingId,
					pinstall->dwBitFlags,		
					pinstall->dirtypeTarget,
					&cbPath, pinstall->szPath);
		if (FAILED(hr))
			goto Exit;
		
		// Wipe the target location
		hr = RemoveDirectoryInitializeContext(
					pinstall->szPath, cbPath, 
					XONLINECONTENT_MAX_PATH, 
					(char *)pinstall->rgbDecompress, 0,
					pinstall->xontask.hEventWorkAvailable,
					&pinstall->dirops);
		if (FAILED(hr))
			goto Exit;

		pinstall->dlphase = dlphaseWipeTarget;
	}

	// Make sure something is happening
	Assert(pinstall->dlphase != dlphaseCheckCache);

Exit:
	return(hr);

Error:
	TraceSz2(Verbose, "contdlCheckCache non-recoverable error (%h, %u)", 
             hr, GetLastError());
	goto Exit;

NoCache:	
	TraceSz2(Verbose, "contdlCheckCache recoverable error (%h, %u). Creating cache", 
             hr, GetLastError());
	hr = S_OK;
	pinstall->dwFlags &= (~XONLINECONTENT_FLAG_RESUME);
	goto CreateCache;
}	

//
// Function to read the cache from disk
//
HRESULT CXo::contdlReadCache(
			PXONLINETASK_CONTENT_DOWNLOAD	pcontdl
			)
{
	HRESULT					hr = S_OK;
	PXRL_ASYNC				pxrlasync = NULL;
	PXONLINECONTENT_INSTALL	pinstall = NULL;
	PXONLINETASK_FILEIO		pfileio = NULL;
	PBYTE					pbBuffer = NULL;
	LARGE_INTEGER			liResumeFrom;
	FILETIME				ftLastWritten;
	DWORD					dwCheckpoint;
	DWORD					dwRead;

	Assert(pcontdl != NULL);

	pinstall = &pcontdl->install;
	pxrlasync = &pcontdl->xrlasync;
	pfileio = &pinstall->fileioData;

	// Wait for the read to complete
	hr = XOnlineTaskContinue((XONLINETASK_HANDLE)pfileio);
	if (XONLINETASK_STATUS_AVAILABLE(hr))
	{
		// Read had returned results, see if it succeeded
		if (FAILED(hr))
			goto Error;

		// We got the entire cache, process it.
		hr = GetReadWriteFileResults(
					(XONLINETASK_HANDLE)pfileio, &dwRead, &pbBuffer);
		if (FAILED(hr))
			goto Error;

		// Make sure we got what we expected
		Assert(pinstall->dwExpected <= dwRead);

		// Make sure the buffers are still lined up
        Assert(pbBuffer == pinstall->rgbDecompress);

		// Call function to process fixed header
		hr = ProcessFixedHeader(pcontdl, pbBuffer);
		if (FAILED(hr))
			goto Error;

		// Call another function to process the CFFOLDER entries
		// this also fills in pinstall->dwExpected
		hr = ProcessCffolderEntries(pcontdl, 
					pbBuffer + XONLINECONTENT_COMPLETE_HEADER_SIZE);
		if (FAILED(hr))
			goto Error;

		// Basic sanity check on our checkpoint
		dwCheckpoint = *(LPDWORD)(pbBuffer + XONLINECONTENT_CHECKPOINT);
		if ((dwCheckpoint >= pinstall->header.cfheader.cFolders) ||
			(dwCheckpoint >= XONLINECONTENT_MAX_CFFOLDER))
		{
			AssertSz(FALSE, "contdlReadCache: Invalid checkpoint!");
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
			goto Error;
		}

		// Set up system to start from specified folder
		hr = SetupInstallFolder(pinstall, dwCheckpoint);
		if (FAILED(hr))
			goto Error;

		// Get the file time
		if (!GetFileTime(pfileio->hFile, NULL, NULL, &ftLastWritten))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			goto Error;
		}

		// Now we have all the header data checked and verified, 
		// the cache file written and closed, we can set
		// up our CFFILE cache. It will inherit the file handle
		// from pinstall->fileioData.hFile.
		// We will first verify the CFFILE entries before we
		// use them to prevent using invalid data. We will use
		// the decompress buffer for this because it is much
		// larger and still available at this point.

		// Figure out the size of CFFILE entries
		dwRead = pinstall->dwExpected - 
						pinstall->header.cfheader.coffFiles;
		hr = CffileCacheInitialize(
					pfileio->hFile,
					pinstall->header.cfheader.coffFiles,
					pinstall->header.cfheader.cFiles,
					pinstall->rgbSymmetricKey, 
					XONLINE_KEY_LENGTH,
					dwRead,
					pinstall->rgbDecompress,
					XONLINECONTENT_LZX_OUTPUT_SIZE,
					&(pinstall->header.digestFiles),
					pinstall->xontask.hEventWorkAvailable, 
					&(pinstall->cffilecache));
		if (FAILED(hr))
			goto Error;

		// The CFFILE cache had taken over the file handle, 
		// mark this one as invalid.
		pinstall->fileioData.hFile = INVALID_HANDLE_VALUE;

		// OK, rebuild the GET request
		pxrlasync->wsabuf.len = pxrlasync->cbBuffer;
		pxrlasync->wsabuf.buf = (char *)pxrlasync->pBuffer;
		
		liResumeFrom.QuadPart = 
				pinstall->rgcffolderhmac[dwCheckpoint].cffolder.coffCabStart;
	    hr = XRL_BuildGetRequestWithResume(
	    				pxrlasync->serviceInfo.dwServiceID,
	    				pinstall->szResourcePath,
	    				pxrlasync->serviceInfo.serviceIP.s_addr,
	    				pxrlasync->wsabuf.buf, 
	    				&(pxrlasync->wsabuf.len), 
	    				NULL, 0,
	    				&ftLastWritten, 
	    				liResumeFrom);
	    if (FAILED(hr))
	        goto Error;
		
		// Next phase is to set up CFFILE cache to the correct position
		pinstall->dlphase = dlphaseVerifyCffiles;
	}

Exit:
	return(hr);

Error:
	// Now, if for any reason we fail during the cache preparation 
	// phase, we will just go back and download everything from scratch
	ResetAfterUnsuccessfulResume(pinstall);

	TraceSz1(Verbose, "Failed to read cache (%h), downloading from scratch", hr);
	
	hr = S_OK;
	goto Exit;
}

//
// Function to setup CFFILE cache
//
HRESULT CXo::contdlSetupCache(
			PXONLINETASK_CONTENT_DOWNLOAD	pcontdl
			)
{
	HRESULT					hr = S_OK;
	PXONLINECONTENT_INSTALL	pinstall = NULL;
	DWORD					dwIndex;

	Assert(pcontdl != NULL);

	pinstall = &pcontdl->install;

	// We try to get the next CFFILE entry from the cache.
	hr = CffileCacheGetNextEntry(
				&pinstall->cffilecache,
				&dwIndex,
				&pinstall->pcffile,
				&pinstall->szFileName,
				&pinstall->cbFileName);
	if (FAILED(hr))
		goto Error;

	// Now see if we got it right away ...
	if (hr == S_CFFILECACHE_IO_PENDING)
	{
		// Nope, the next entry happens to be on disk and we have
		// to load it up. There's nothing we can do now, so might
		// as well return to the dispatcher. 
		goto Exit;
	}

	if (hr == S_CFFILECACHE_NO_MORE_ITEMS)
	{
		AssertSz(FALSE, "contdlSetupCache: Invalid CFFILE data!");
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		goto Error;
	}
	
	if (pinstall->pcffile->iFolder == pinstall->dwCurrentFolder)
	{
		// Set up to install this file
		pinstall->dwExpected = pinstall->pcffile->cbFile;
		pinstall->dwWritten = 0;
		TraceSz3(Verbose, "[%u] Installing %s, %u bytes", 
                 dwIndex, pinstall->szFileName, pinstall->dwExpected);

		// Cache the next phase, and see if we have custom tasks
		pinstall->dlphaseNext = dlphaseCreateTarget;
		pinstall->dlphase = dlphasePreCustom;
	}

Exit:
	return(S_OK);

Error:
	// Now, if for any reason we fail during the cache preparation 
	// phase, we will just go back and download everything from scratch
	ResetAfterUnsuccessfulResume(pinstall);

	TraceSz1(Verbose, "Failed to read cache (%h), downloading from scratch", hr);
	goto Exit;
}

//
// Function to perform any pre-install custom tasks
//
HRESULT CXo::contdlPreCustom(
			PXONLINETASK_CONTENT_DOWNLOAD	pcontdl
			)
{
	HRESULT					hr = S_OK;
	PXONLINECONTENT_INSTALL	pinstall;

	Assert(pcontdl != NULL);

	pinstall = &pcontdl->install;

	// Proceed if we don't have any custom task
	if (pinstall->hTaskPreCustom != NULL)
	{
		// We have a task, pump it until it is done
		hr = XOnlineTaskContinue(pinstall->hTaskPreCustom);
		if (XONLINETASK_STATUS_AVAILABLE(hr))
		{
			// See if it succeeded
			if (FAILED(hr))
				goto Cleanup;

			goto Done;
		}
	}
	else
		goto Done;

Cleanup:
	return(hr);

Done:
	// Restore the cached next state
	Assert((pinstall->dlphaseNext == dlphaseRecvHeader) ||
			(pinstall->dlphaseNext == dlphaseCreateTarget) ||
			(pinstall->dlphaseNext == dlphasePostCustom));
	pinstall->dlphase = pinstall->dlphaseNext;

	// We are done with pre-download
	if (pinstall->dlphaseNext != dlphasePostCustom)
		hr = XONLINETASK_S_SUCCESS;
	else
	{
		// Return a specific code to communicate to skip the
		// actual download and go to post processing
		hr = XONLINE_S_XRL_EXTENSION_SKIP_TO_POST;
	}
	
	goto Cleanup;
}

//
// Function to see if the package is already installed
//
HRESULT CXo::contdlVerifyInstall(
			PXONLINETASK_CONTENT_DOWNLOAD	pcontdl
			)
{
	HRESULT					hr = S_OK;
	PXONLINECONTENT_INSTALL	pinstall;

	Assert(pcontdl != NULL);

	pinstall = &pcontdl->install;
	
	// We have a task, pump it until it is done
	hr = XOnlineTaskContinue((XONLINETASK_HANDLE)&(pinstall->verify));
	if (XONLINETASK_STATUS_AVAILABLE(hr))
	{
		// Close the manifest file
		CloseHandle(pinstall->verify.fileio.hFile);
		pinstall->verify.fileio.hFile = INVALID_HANDLE_VALUE;
	
		// See if it succeeded
		if (FAILED(hr))
		{
			// The manifest was there, but somehow it's not valid
			// This time, we will create the cache and download from scratch
			pinstall->dwFlags |= XONLINECONTENT_FLAG_NOT_INSTALLED;
			pinstall->dlphase = dlphaseCheckCache;
		}
		else
		{
			// Make sure success is returned
			Assert(hr == XONLINETASK_S_SUCCESS);

			// We are trying to install a package that has already
			// been installed. We are done with the download and
			// install part. Now we jump to the post installation
			// phase to complete all unfinished business
			pinstall->dlphaseNext = dlphasePostCustom;
			pinstall->dlphase = dlphasePreCustom;

			hr = S_OK;
		}		
	}

	return(hr);
}

//
// Function to verify Hmac for the CFFILE entries before
// we actually use it
//
HRESULT CXo::contdlVerifyCffiles(
			PXONLINETASK_CONTENT_DOWNLOAD	pcontdl
			)
{
	HRESULT					hr = S_OK;
	PXONLINECONTENT_INSTALL	pinstall;
	DWORD					cbLength;

	Assert(pcontdl != NULL);

	pinstall = &pcontdl->install;

	// Call the API
	hr = CffileCacheVerify(&pinstall->cffilecache);
	if (SUCCEEDED(hr))
	{
		if (hr == S_OK)
		{
			// Verification OK, now we reset the CFFILE cache
			// for enumeration
			cbLength = pinstall->dwExpected - 
							pinstall->header.cfheader.coffFiles;
			hr = CffileCacheInitialize(
						pinstall->cffilecache.hFile,
						pinstall->header.cfheader.coffFiles,
						pinstall->header.cfheader.cFiles,
						pinstall->rgbSymmetricKey, 
						XONLINE_KEY_LENGTH,
						cbLength,
						NULL,	// Use default buffer
						0,		// Use default buffer
						&(pinstall->header.digestFiles),
						pinstall->xontask.hEventWorkAvailable, 
						&(pinstall->cffilecache));
			if (FAILED(hr))
				goto Exit;

			// Figure out where to go next
			if (pinstall->dwFlags & XONLINECONTENT_FLAG_RESUME)
			{
				// We are resuming, need to set up the CFFILE cache
				pinstall->dlphase = dlphaseSetupCache;
			}
			else
			{
				// Go straight to installing files
				pinstall->dlphase = dlphaseInstallFiles;
			}
		}
		else if (hr != S_CFFILECACHE_IO_PENDING)
		{
			AssertSz(FALSE, "contdlVerifyCffiles: Unexpected return code");
		}

		hr = S_OK;
	}

Exit:
	return(hr);
}

//
// Function to write checkpoint
//
HRESULT CXo::contdlCheckpoint(
			PXONLINETASK_CONTENT_DOWNLOAD	pcontdl
			)
{
	HRESULT					hr = S_OK;
	PXONLINECONTENT_INSTALL	pinstall;
	PXONLINETASK_FILEIO		pfileio;
	XONLINETASK_HANDLE		hfileio;
	ULARGE_INTEGER			uliOffset;
	DWORD					dwCheckpoint;
	DWORD					dwSize;
	PBYTE					pbBuffer;

	Assert(pcontdl != NULL);

	pinstall = &pcontdl->install;

	// We steal the CFFILE cache context for our file I/O
	pfileio = &pinstall->cffilecache.fileio;
	hfileio = (XONLINETASK_HANDLE)pfileio;

	// In addition, we will steal the path buffer to use
	pbBuffer = (PBYTE)pinstall->szPath;

	// This is  essentially a read-modify-write operation
	if (pinstall->dwFlags & XONLINECONTENT_FLAG_READ_PENDING)
	{
		// A read is pending, see if the read has completed
		hr = XOnlineTaskContinue(hfileio);
		if (XONLINETASK_STATUS_AVAILABLE(hr))
		{
			// Turn off the flag immediately
			pinstall->dwFlags &= (~XONLINECONTENT_FLAG_READ_PENDING);
		
			// Read had returned results, see if it succeeded
			if (FAILED(hr))
				goto Error;

			hr = GetReadWriteFileResults(
						(XONLINETASK_HANDLE)pfileio, &dwSize, &pbBuffer);
			if (FAILED(hr))
				goto Error;

			if (dwSize != XBOX_HD_SECTOR_SIZE)
			{
				hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
				goto Error;
			}

			// Set the checkpoint
			*(PDWORD)(pbBuffer + XONLINECONTENT_CHECKPOINT) = pinstall->dwCurrentFolder;

			// Write out the checkpoint
			uliOffset.QuadPart = 0;
			ReadWriteFileInitializeContext(pfileio->hFile,
						pbBuffer,
						XBOX_HD_SECTOR_SIZE,
						uliOffset,
						pinstall->xontask.hEventWorkAvailable, 
						pfileio);

			hr = WriteFileInternal(pfileio);
			if (FAILED(hr))
				goto Error;

			// Set the flag to indicate that we are pending write complete
			pinstall->dwFlags |= XONLINECONTENT_FLAG_WRITE_PENDING;		
		}
	}
	else if (pinstall->dwFlags & XONLINECONTENT_FLAG_WRITE_PENDING)
	{
		// A write is pending, see if the write has completed
		hr = XOnlineTaskContinue(hfileio);
		if (XONLINETASK_STATUS_AVAILABLE(hr))
		{
			// Turn off the flag immediately
			pinstall->dwFlags &= (~XONLINECONTENT_FLAG_WRITE_PENDING);
		
			// Read had returned results, see if it succeeded
			if (FAILED(hr))
				goto Error;

			hr = GetReadWriteFileResults(
						(XONLINETASK_HANDLE)pfileio, &dwSize, &pbBuffer);
			if (FAILED(hr))
				goto Error;

            Assert(dwSize == XBOX_HD_SECTOR_SIZE);

			// Okay, go back to where we were ....
			if (pinstall->dwFlags & XONLINECONTENT_FLAG_CONTINUE_FILE)
			{
				pinstall->dlphase = dlphaseInstallFiles;
				pinstall->dwFlags &= (~XONLINECONTENT_FLAG_CONTINUE_FILE);
			}
			else
				pinstall->dlphase = dlphaseCreateTarget;
		}
	}
	else
	{
		// We need to read in the first sector that contains the 
		// checkpoint, given the fact that the cache size is always
		// rounded up to the next sector, we know the cache must
		// be at least 1 sector in size.
		uliOffset.QuadPart = 0;
		ReadWriteFileInitializeContext(pfileio->hFile,
					pbBuffer,
					XBOX_HD_SECTOR_SIZE,
					uliOffset,
					pinstall->xontask.hEventWorkAvailable, 
					pfileio);

		hr = ReadFileInternal(pfileio);
		if (FAILED(hr))
			goto Error;

		// Set the flag to indicate that we are pending read complete
		pinstall->dwFlags |= XONLINECONTENT_FLAG_READ_PENDING;		
	}
	
	return(S_OK);

Error:
	return(hr);
}

//
// Function to write DRM
//
HRESULT CXo::contdlSignDrm(
			PXONLINETASK_CONTENT_DOWNLOAD	pcontdl
			)
{
	HRESULT					hr = S_OK;
	PXONLINECONTENT_INSTALL	pinstall;
	PXONLINETASK_FILEIO		pfileio;
	XONLINETASK_HANDLE		hverify;
	LARGE_INTEGER			liSize;
	DWORD					cbPath;
	DGSTFILE_IDENTIFIER		dfi;

	Assert(pcontdl != NULL);

	pinstall = &pcontdl->install;
	pfileio = &pinstall->verify.fileio;

	// If the manifest file is not already open, open it and 
	// do some initialization
	if (!pfileio->hFile || (pfileio->hFile == INVALID_HANDLE_VALUE))
	{
		// Verify and sign the manifest
		hr = VerifyOrSignManifestBegin(pinstall, pinstall->rgbSymmetricKey);
		if (FAILED(hr))
			goto Error;

		goto Exit;
	}

	// Pump the verification task
	hverify = (XONLINETASK_HANDLE)&pinstall->verify;
	hr = XOnlineTaskContinue(hverify);
	if (XONLINETASK_STATUS_AVAILABLE(hr))
	{
		// Close the manifest file
		CloseHandle(pfileio->hFile);
		pfileio->hFile = INVALID_HANDLE_VALUE;

		// See if it succeeded
		if (FAILED(hr))
			goto Error;

		// Succeeded. Go to remove the cache file
		Assert(hr == XONLINETASK_S_SUCCESS);
		hr = S_OK;
		pinstall->dlphase = dlphaseDeleteCache;
	}

Exit:
Error:
	return(hr);
}

//
// Function to delete the cache file
//
HRESULT CXo::contdlDeleteCache(
			PXONLINETASK_CONTENT_DOWNLOAD	pcontdl
			)
{
	HRESULT					hr = S_OK;
	PXONLINECONTENT_INSTALL	pinstall;
	DWORD					cbPath;

	Assert(pcontdl != NULL);

	pinstall = &pcontdl->install;

	// Make sure the cache is closed
	CffileCacheDeinitialize(&pinstall->cffilecache);

	// Synchronously delete the cache file
	cbPath = XONLINECONTENT_MAX_PATH;
	hr = BuildTargetPath(
				pinstall->dwTitleId, 
				pinstall->OfferingId,
				pinstall->dwBitFlags,
				XONLINECONTENT_CACHE_FILE_NAME,
				pinstall->dirtypeTarget,
				&cbPath,
				pinstall->szPath);
	if (FAILED(hr))
		return(hr);

	if (!DeleteFile(pinstall->szPath))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		return(hr);
	}

	// Move on to next phase
	pinstall->dlphase = dlphasePostCustom;

	return(S_OK);
}

//
// Function to perform any post-install custom tasks
//
HRESULT CXo::contdlPostCustom(
			PXONLINETASK_CONTENT_DOWNLOAD	pcontdl
			)
{
	HRESULT					hr = S_OK;
	PXONLINECONTENT_INSTALL	pinstall;

	Assert(pcontdl != NULL);

	pinstall = &pcontdl->install;

	// Proceed if we don't have any custom task
	if (pinstall->hTaskPostCustom != NULL)
	{
		// We have a task, pump it until it is done
		hr = XOnlineTaskContinue(pinstall->hTaskPostCustom);
		if (XONLINETASK_STATUS_AVAILABLE(hr))
		{
			// See if it succeeded
			if (FAILED(hr))
				goto Cleanup;

			hr = S_OK;
			goto Done;
		}
	}
	else
		goto Done;

Cleanup:
	return(hr);

Done:
	// We are completely done at this point!
	pinstall->dlphase = dlphaseDone;
	goto Cleanup;
}

// =================================================================

//
// Task handler type
//
typedef HRESULT (CXo::*PFNCONTDL_HANDLER)(PXONLINETASK_CONTENT_DOWNLOAD);

//
// Define the handler vector
//
const PFNCONTDL_HANDLER CXo::s_rgpfncontdlHandlers[] =
{
	CXo::contdlCatref,
	CXo::contdlCheckCache,
	CXo::contdlReadCache,
	CXo::contdlWipeTarget,
	CXo::contdlCreateCache,
	CXo::contdlSetupCache,
	CXo::contdlVerifyInstall,
	CXo::contdlPreCustom,
	CXo::contdlRecvHeader,
	CXo::contdlInstallFiles,
	CXo::contdlCreateTarget,
	CXo::contdlWriteTarget,
	CXo::contdlCheckpoint,
	CXo::contdlCreateDirectory,
	CXo::contdlVerifyCffiles,
	CXo::contdlSignDrm,
	CXo::contdlDeleteCache,
	CXo::contdlPostCustom,
	0
};

//
// Implement the do work function for ContentInstall
//
// This is shared among xrldlextPreConnect, xrldlextProcessData,
// and xrldlextPostDownload
//

HRESULT CXo::contdlContinue(
			XONLINETASK_HANDLE	hTask
			)
{
	HRESULT							hr = S_OK;
	PXONLINETASK_CONTENT_DOWNLOAD	pcontdl = NULL;
	PXONLINECONTENT_INSTALL			pinstall = NULL;
	PXRL_ASYNC						pxrlasync = NULL;
	XONLINECONTENT_DLPHASE			dlphase;

#if DBG
	LARGE_INTEGER					liTimerTotal;
	LARGE_INTEGER					liTimerStart;
	LARGE_INTEGER					liTimerEnd;

	// Track service count
    m_liServiceCount.QuadPart += 1;

	// Start the total timer
	QueryPerformanceCounter(&liTimerTotal);
#endif

	Assert(hTask != NULL);

	// hTask points to the xontask field of XRL_ASYNC_EXTENDED,
	// find the containing pxrlasyncext structure
	pcontdl = CONTAINING_RECORD(hTask, XONLINETASK_CONTENT_DOWNLOAD, install);
	pinstall = &pcontdl->install;
	pxrlasync = &pcontdl->xrlasync;

#ifdef CHK_CORRUPT
	CheckCorruption(pinstall);
#endif

#if DBG
	// Start the loop timer
	QueryPerformanceCounter(&liTimerStart);
#endif

	dlphase = pinstall->dlphase;

	// Figure out what phase we are in ...
	if (pinstall->dlphase < dlphaseDone)
	{
		hr = (this->*(s_rgpfncontdlHandlers[dlphase]))(pcontdl);

#if DBG
		if (FAILED(hr))
		{
			DWORD	tagOld = t_Verbose;
			t_Verbose = TAG_ENABLE;
			TraceSz2(Verbose, "%s, %08x", s_rgszPhases[dlphase], hr);
			t_Verbose = tagOld;
		}
#endif		
	}
	else if (pinstall->dlphase != dlphaseDone)
	{
		// This is a bad state. We force it to end so we don't get stuck
		// here forever.
		AssertSz(FALSE, "contdlContinue: invalid phase!");
		hr = E_FAIL;
	}

#if DBG	
	// Stop timer
	QueryPerformanceCounter(&liTimerEnd);

	m_liTotalTime.QuadPart += (liTimerEnd.QuadPart - liTimerStart.QuadPart);
	m_liAverageTime.QuadPart = m_liTotalTime.QuadPart / m_liServiceCount.QuadPart;

#endif	

	// Bail if failed.
	if (FAILED(hr))
	{
#if DBG		
		pinstall->dlphaseError = pinstall->dlphase;
#endif		
		contdlCleanup(pcontdl);
		pxrlasync->hrFinal = hr;
		pinstall->dlphase = dlphaseDone;
	}

	// When the next state is the final state, we set the flag so we don't
	// continue.
	if (pinstall->dlphase == dlphaseDone)
	{
		// Indicate that we are done and return the final code
		hr = pxrlasync->hrFinal;
		XONLINETASK_SET_COMPLETION_STATUS(hr);

#if DBG
		TraceSz1(Verbose, "%I64u services elapsed", m_liServiceCount.QuadPart);
		TraceSz1(Verbose, "Total time: %I64u ticks", m_liTotalTime.QuadPart);
		TraceSz1(Verbose, "Average service time: %I64u ticks", m_liAverageTime.QuadPart);
		m_liServiceCount.QuadPart = 0;
		m_liTotalTime.QuadPart = 0;
		m_liAverageTime.QuadPart = 0;
#endif		
	}

#ifdef CHK_CORRUPT
	CheckCorruption(pinstall);
#endif

	// Detect state changes so we will not timeout
	if (dlphase != pinstall->dlphase)
		pxrlasync->dwLastStateChange = GetTickCount();

	return(hr);
}				

//
// Function to kick off downloading and installing a
// content package. This is the internal/Dash version because it
// allows a Title ID to be specified.
//
HRESULT CXo::ContentInstallInitializeContext(
			PXONLINETASK_CONTENT_DOWNLOAD 	pcontdl,
			DWORD							dwTitleId,
			XONLINEOFFERING_ID				OfferingId,
			XONLINEDIR_TYPE					dirtypeTarget,
			DWORD							dwFlags,
			DWORD							dwTimeout,
			XONLINETASK_HANDLE				hTaskPreCustom,
			XONLINETASK_HANDLE				hTaskPostCustom,
			HANDLE							hWorkEvent
			)
{
	HRESULT							hr = S_OK;
	PXONLINECONTENT_INSTALL			pinstall = NULL;
	PXRL_ASYNC						pxrlasync = NULL;
	PXRL_DOWNLOAD_EXTENSION			pxrldlext = NULL;

	Assert(NULL != pcontdl);

	ZeroMemory(pcontdl, sizeof(XONLINETASK_CONTENT_DOWNLOAD));
	pinstall = &pcontdl->install;
	pxrlasync = &pcontdl->xrlasync;
	pxrldlext = &(pxrlasync->xrlext.dl);

	// Fill in the blanks
	TaskInitializeContext(&pxrlasync->xontask);
	pxrlasync->xontask.hEventWorkAvailable = hWorkEvent;
	pxrlasync->pBuffer = pinstall->rgbBuffer;
	pxrlasync->cbBuffer = XONLINECONTENT_DL_BUFFER_SIZE;
	pxrlasync->hrFinal = S_OK;
	pxrlasync->uliTotalWritten.QuadPart = 0;
	pxrlasync->uliTotalReceived.QuadPart = 0;
	pxrlasync->uliContentLength.QuadPart = 0;
	pxrlasync->dwTimeoutMs = dwTimeout;

	// The socket API requires that we have an event handle in order
	// for the async I/O to happen. If the caller has not provided us
	// with an event, we have to create it here
	hr = XRL_CreateWorkEventIfNecessary(pxrlasync, &hWorkEvent);
	if (FAILED(hr))
		goto Error;

	// Initialize our subtask
	TaskInitializeContext(&pinstall->xontask);
	pinstall->xontask.pfnContinue = contdlContinue;
	pinstall->xontask.hEventWorkAvailable = hWorkEvent;
	pinstall->dlphase = dlphaseCatref;
	pinstall->dlphaseNext = dlphaseDone;
	pinstall->dwTitleId = dwTitleId;
	pinstall->OfferingId = OfferingId;
	pinstall->dirtypeTarget = dirtypeTarget;
	pinstall->dwPackageSize = 0;
	pinstall->dwInstallSize = 0;
	pinstall->dwLastXrl = 0;
	pinstall->dwFlags = dwFlags;
	pinstall->hTaskPreCustom = hTaskPreCustom;
	pinstall->hTaskPostCustom = hTaskPostCustom;

	// We need to do some special work if we are installing offline
	if (dwFlags & XONLINECONTENT_FLAG_OFFLINE_INSTALL)
	{
		// Skip over the cetref stuff
		pinstall->dlphase = dlphaseCheckCache;
	}
	
	// Set up the extension block
	pxrldlext->pfnDoneHeaders = contdlDoneHeaders;
	pxrldlext->pfnProcessData = contdlProcessData;
	pxrldlext->pfnCompleted = contdlCompleted;
	pxrldlext->pfnInitializeTask = NULL;
	pxrldlext->pfnCleanup = contdlCleanupHandler;
	pxrldlext->hTaskPreConnect = (XONLINETASK_HANDLE)pinstall;
	pxrldlext->hTaskProcessData = (XONLINETASK_HANDLE)pinstall;
	pxrldlext->hTaskPostDownload = (XONLINETASK_HANDLE)pinstall;

	// Initialize the decompressor
	LzxDecodeInit(pinstall->rgbLzxWindow,
				XONLINECONTENT_LZX_WINDOW_SIZE,
				&(pinstall->lzx));

Cleanup:	
	return(hr);

Error:

	// Failed setup, make sure we clean up everything
	if (pcontdl)
		contdlCleanup(pcontdl);
	goto Cleanup;
}

//
// Function to kick off a content download and install. This 
// is the public version that installs for the current title.
//
HRESULT CXo::XOnlineContentInstall(
			XONLINEOFFERING_ID	OfferingId,
			HANDLE				hWorkEvent,
			XONLINETASK_HANDLE	*phTask
			)
{
	HRESULT							hr = S_OK;
	LARGE_INTEGER					liTemp;
	LPCSTR							szDummy = "";
	PXONLINETASK_CONTENT_DOWNLOAD	pcontdl = NULL;

	XoEnter("XOnlineContentInstall");

	// We are responsible for allocating the context and any other
	// buffers. These buffers immediately follow the context structure
#ifndef CHK_CORRUPT	
	pcontdl = (PXONLINETASK_CONTENT_DOWNLOAD)SysAllocZ(sizeof(XONLINETASK_CONTENT_DOWNLOAD), PTAG_XONLINETASK_CONTENT_DOWNLOAD);
#else
	pcontdl = (PXONLINETASK_CONTENT_DOWNLOAD)SysAllocZ(sizeof(XONLINETASK_CONTENT_DOWNLOAD) + CHK_CORRUPT_SIZE, PTAG_XONLINETASK_CONTENT_DOWNLOAD);
#endif
	if (!pcontdl)
	{
		hr = E_OUTOFMEMORY;
		goto Error;
	}

	hr = ContentInstallInitializeContext(pcontdl, 
				m_dwTitleId, OfferingId, dirtypeTitleContent, 0,
				XONLINECONTENT_INSTALL_TIMEOUT, NULL, NULL,
				hWorkEvent);
	if (FAILED(hr))
		goto Error;

	// First, kick off a referral request
	hr = InitiateReferralRequest(OfferingId, pcontdl);
	if (FAILED(hr))
		goto Error;

	// Kick off the generic download. At this point, we don't
	// care about the timestamp or resume point, because we 
	// will have to come up with that later.
	//
	// Note: The following flag makes the download insecure
	pcontdl->xrlasync.dwFlags |= XRL_CONNECTION_INSECURE;
	liTemp.QuadPart = 0;
	hr = Download(szDummy, NULL, 0, NULL, liTemp, &pcontdl->xrlasync);
	if (FAILED(hr))
		goto Error;

	*phTask = (XONLINETASK_HANDLE)pcontdl;

Exit:
	return(XoLeave(hr));

Error:
	if (pcontdl != NULL)
		SysFree(pcontdl);
	goto Exit;
}

//
// Function to kick off a content download and install from a 
// package on the DVD to the specified title (most likely the
// title initiating this is not the recipient title of the content)
//
// The install location is:
// c:\TDATA\<dwTitleID>\$c\<OfferingId>.<dwBitFlags>\
//
HRESULT CXo::XOnlineContentInstallFromDVD(
			PSTR				szResourcePath,
			DWORD				dwTitleId,
			XONLINEOFFERING_ID	OfferingId,
			DWORD				dwBitFlags,
			PBYTE				pbSymmetricKey,
			DWORD				cbSymmetricKey,
			PBYTE				pbPublicKey,
			DWORD				cbPublicKey,
			HANDLE				hWorkEvent,
			XONLINETASK_HANDLE	*phTask
			)
{
	HRESULT							hr = S_OK;
	LARGE_INTEGER					liTemp;
	PXONLINETASK_CONTENT_DOWNLOAD	pcontdl = NULL;

	XoEnter("InstallFromDVD");

	Assert(szResourcePath);
	Assert(phTask);
	Assert(pbSymmetricKey);
	Assert(cbSymmetricKey == XONLINE_KEY_LENGTH);
	Assert(pbPublicKey);
	Assert(cbPublicKey >= XONLINECONTENT_PK_SIGNATURE_SIZE);
	Assert(cbPublicKey <= XONLINECONTENT_MAX_PUBLIC_KEY_SIZE);

	// We are responsible for allocating the context and any other
	// buffers. These buffers immediately follow the context structure
#ifndef CHK_CORRUPT	
	pcontdl = (PXONLINETASK_CONTENT_DOWNLOAD)SysAllocZ(sizeof(XONLINETASK_CONTENT_DOWNLOAD), PTAG_XONLINETASK_CONTENT_DOWNLOAD);
#else
	pcontdl = (PXONLINETASK_CONTENT_DOWNLOAD)SysAllocZ(sizeof(XONLINETASK_CONTENT_DOWNLOAD) + CHK_CORRUPT_SIZE, PTAG_XONLINETASK_CONTENT_DOWNLOAD);
#endif
	if (!pcontdl)
	{
		hr = E_OUTOFMEMORY;
		goto Error;
	}

	// Need to mount the target title TData to private drive
	hr = XoUpdateMountTitleTDataToPrivateDrive(dwTitleId);
	if (FAILED(hr))
		goto Error;

	hr = ContentInstallInitializeContext(pcontdl, 
				dwTitleId, OfferingId, dirtypeTitleContentOnF,
				XONLINECONTENT_FLAG_OFFLINE_INSTALL,
				XONLINECONTENT_INSTALL_TIMEOUT, NULL, NULL,
				hWorkEvent);
	if (FAILED(hr))
		goto Error;

	// Set the bitflags
	pcontdl->install.dwBitFlags = dwBitFlags;

	// Set up the cryptographic keys
	memcpy(pcontdl->install.rgbSymmetricKey, pbSymmetricKey, XONLINE_KEY_LENGTH);
	memcpy(pcontdl->install.rgbPublicKey, pbPublicKey, cbPublicKey);

	// Do a "download" from file
	liTemp.QuadPart = 0;
	hr = DownloadFromDVD(szResourcePath, NULL, liTemp, &pcontdl->xrlasync);
	if (FAILED(hr))
		goto Error;

	*phTask = (XONLINETASK_HANDLE)pcontdl;

Exit:
	return(XoLeave(hr));

Error:
	XoUpdateUnmountPrivateDrive();

	if (pcontdl != NULL)
		SysFree(pcontdl);
	goto Exit;
}

//
// Function to get the progress of an active content installation
//
HRESULT
CXo::XOnlineContentInstallGetProgress(
			XONLINETASK_HANDLE hTask,
			DWORD *pdwPercentDone,
			ULONGLONG *pqwNumerator,
			ULONGLONG *pqwDenominator
			)
{
	HRESULT	hr = S_OK;
	ULARGE_INTEGER	uliNumerator, uliDenominator;

    XoEnter("XOnlineContentInstallGetProgress");
    XoCheck(hTask != NULL);

	PXONLINETASK_CONTENT_DOWNLOAD pcontdl = (PXONLINETASK_CONTENT_DOWNLOAD)hTask;

	hr = XOnlineDownloadGetProgress((XONLINETASK_HANDLE)&(pcontdl->xrlasync),
                                              pdwPercentDone, &uliNumerator, &uliDenominator);
	if (pqwNumerator)
		*pqwNumerator = uliNumerator.QuadPart;
	if (pqwDenominator)
		*pqwDenominator = uliDenominator.QuadPart;
	return(XoLeave(hr));
}

HRESULT CXo::XOnlineContentGetRootDirectory(
			XONLINEOFFERING_ID	OfferingId,
			BOOL				fUserData,
			DWORD				*pcbRootDirectory,
			CHAR				*szRootDirectory
			)
{
    XoEnter("XOnlineContentGetRootDirectory");
    XoCheck(pcbRootDirectory != NULL);
    XoCheck(szRootDirectory != NULL);

	HRESULT				hr = S_OK;
	HANDLE				hFind = INVALID_HANDLE_VALUE;
	WIN32_FIND_DATA		wfd;
	DWORD				cbSize;
    CHAR				szTemplate[64];

	// Find the first directory that matches the template
	sprintf(szTemplate, XONLINECONTENT_OPEN_TEMPLATE,
				fUserData?'u':'t', OfferingId);
	hFind = FindFirstFile(szTemplate, &wfd);
	if (hFind == INVALID_HANDLE_VALUE)
		goto NotFound;

	// Skip past all files
	while ((wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
	{
		if (!FindNextFile(hFind, &wfd))
			goto NotFound;
	}

	// Use this directory name to build the path
	cbSize = strlen(XONLINECONTENT_OPEN_PATH) + 
				strlen(wfd.cFileName) - 3;
	if (*pcbRootDirectory < cbSize)
	{
		*pcbRootDirectory = cbSize;
		hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
		goto Exit;
	}
	sprintf(szRootDirectory, XONLINECONTENT_OPEN_PATH,
				fUserData?'u':'t', wfd.cFileName);
	*pcbRootDirectory = cbSize;

Exit:
	if (hFind != INVALID_HANDLE_VALUE)
		FindClose(hFind);

    return(XoLeave(hr));

NotFound:
	hr = HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND);
	goto Exit;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\billing.cpp ===
/*
 *  billing.cpp
 *
 *  XBOX Online Service.  Copyright (c) Microsoft Corporation.
 *  
 *  Author: Ben Zotto (benzotto), Steve Lamb (slamb)
 *  Created: 9/24/01
 *
 *  Implements the APIs:   XOnlineOfferingPurchase()
 *                         XOnlineOfferingCancel()
 *                         XOnlineOfferingGetDetails()
 *                          XOnlineOfferingGetDetailsGetResults()
 *                          [XOnlineOfferingPriceFormat() is elsewhere]
 *                         XOnlineOfferingVerify()
 */     

#include "xonp.h"
#include "xonlinep.h"
#include "xonver.h"
                                                     
// If the following #define is uncommented, the billing functions will always succeed
// with S_OK, without actually performing a network request.
//#define _XBILLING_DUMMY

#define     XOBILLING_TIMEOUT       60000

#define     XO_PURCHASE_BUFFER_SIZE 1024

// 64k is the most we allow in details blobs
#define     XO_DETAILS_MAX_TITLE_DATA_SIZE        65536

                                            
#define     XO_OFFERING_VERIFY_LICENSE_XRL  "/xbos/VerifyLicense.ashx"
#define     XO_OFFERING_VERIFY_BUFFER_SIZE 1024

#define     XO_OFFERING_PURCHASE_XRL "/xbos/OfferingPurchase.ashx"
#define     XO_OFFERING_CANCEL_XRL   "/xbos/OfferingCancel.ashx"
#define     XO_OFFERING_DETAILS_XRL  "/xbos/OfferingDetails.ashx"
//
// Define enumerated types that describe the states for purchasing.
//
typedef enum 
{
    xopurchWaitResponse = 0,
    xopurchDone
} XON_PURCHASE_STATES;

//
// Define enumerated types that describe the states for cancelling.
//
typedef enum 
{
    xocancelWaitResponse = 0,
    xocancelDone
} XON_CANCEL_STATES;


//
// Define enumerated types that describe the states for a details call.
//
typedef enum 
{
    xodetailsWaitResponse = 0,
    xodetailsParseResponse,
    xodetailsResultsAvail,
    xodetailsDone
} XON_DETAILS_STATES;


//
// Define enumerated types that describe the states for verify.
//
typedef enum 
{
    xoverifyCacheOpen = 0,
    xoverifyCacheOpenPump,
    xoverifyCacheLookup,
    xoverifyCacheLookupPump,
    xoverifyUpload,
    xoverifyUploadPump,
    xoverifyCacheUpdate,
    xoverifyCacheUpdatePump,
    xoverifyCacheClose,
    xoverifyCacheClosePump,
    xoverifyDone
} 
XON_OFFERING_VERIFY_STATES;


/* Wire Structs for communication with ISAPIs */

#pragma pack(push, 1)

typedef struct {
    DWORD        cbSize;
    ULONGLONG    qwUserPUID;
    DWORD        dwOfferingId;
} XO_PURCHASE_REQUEST;

typedef struct {
    DWORD       cbSize;
    ULONGLONG   qwUserPUID;
    DWORD       dwOfferingId;
} XO_CANCEL_REQUEST;

typedef struct {
    DWORD       cbSize;
    ULONGLONG   qwUserPUID;
    DWORD       dwOfferId;
    DWORD       dwDescriptionIndex;
    SHORT       sLanguageId;
} XO_DETAILS_REQUEST;
                            
typedef struct {
    DWORD cbSize;
    DWORD dwGrossWholePart;
    BYTE  bGrossFractionalPart;
    DWORD dwNetWholePart;
    BYTE  bNetFractionalPart;
    BYTE  bCurrencyFormat;
    CHAR  rgchISOCode[3];
    DWORD dwSizeOfBlob;
} XO_DETAILS_HEADER, *PXO_DETAILS_HEADER;

#pragma pack(pop)


//
// Cancel: the opaque task handle that the API consumer will hold.
//
struct XO_CANCEL_TASK
{
    XONLINETASK_CONTEXT         Context;            // Standard Task Pump context info
    XRL_ASYNC_EXTENDED      xrlULContext;       // subsumed context for upload
    
    XO_CANCEL_REQUEST       Request;            // cancel Request info
    HRESULT                 hrFinal;            // Final HRESULT
    DWORD                   dwState;            // Current state of op
    BYTE                    rgbWorkBuffer[XO_PURCHASE_BUFFER_SIZE];     // work buffer
};

struct  XO_CANCEL_TASK;
typedef XO_CANCEL_TASK * PXO_CANCEL_TASK;

//
// Purchase: the opaque task handle that the API consumer will hold.
//
struct XO_PURCHASE_TASK
{
    XONLINETASK_CONTEXT     Context;            // Standard Task Pump context info
    XRL_ASYNC_EXTENDED      xrlULContext;       // subsumed context for upload
    
    XO_PURCHASE_REQUEST     Request;            // Purchase Request info
    HRESULT                 hrFinal;            // Final HRESULT
    DWORD                   dwState;            // Current state of op
    BYTE                    rgbWorkBuffer[XO_PURCHASE_BUFFER_SIZE];     // work buffer
};

struct  XO_PURCHASE_TASK;
typedef XO_PURCHASE_TASK * PXO_PURCHASE_TASK;

//
// offering details task handle
//
struct XO_DETAILS_TASK 
{
    XONLINETASK_CONTEXT         Context;            // this task context
    XRL_ASYNC_EXTENDED          xrlULContext;       //  Upload context
    XO_DETAILS_REQUEST          Request;            // details request
    XONLINE_PRICE               GrossPrice;         // eventually holds a price struct
    XONLINE_PRICE               NetPrice;           // likewise
    HRESULT                     hrFinal;            // Final HRESULT
    DWORD                       dwState;            // Current state
};

struct XO_DETAILS_TASK;
typedef XO_DETAILS_TASK * PXO_DETAILS_TASK;


// licsense usage flags
//   defines what fields of a license should be enforced.
#define XO_LIC_TIMEREFRESH      0x0001          
#define XO_LIC_USECOUNT         0x0002          
#define XO_LIC_TIMEFROM         0x0004          
#define XO_LIC_TIMETO           0x0008
#define XO_LIC_USERID           0x0010


//
// acutal license format, retrieved from XBOS
// and stored in the local file cache.
//
#pragma pack(push, 1)
struct XO_OFFERING_LICENSE
{
   // Versioning
   DWORD cbSize;

   // Content Information
   DWORD dwTitleID;
   DWORD dwOfferingId;

   // Content Usage Conditions
   WORD       wConditionFlags;
   BYTE       byRightID;
   BYTE       byUseCount;
   FILETIME   filetimeRefresh;
   FILETIME   filetimeFrom;
   FILETIME   filetimeTo;
   ULONGLONG  qwPassportUserID;

   // signature to prevent tampering
   XCALCSIG_SIGNATURE Signature;
};
#pragma pack(pop)


// 
// index format to cached licenses
//
#pragma pack(push, 1)
struct XO_LICENSE_CACHE_INDEX
{
    DWORD dwOfferingId;
    ULONGLONG qwPuid;
};
#pragma pack(pop)


#pragma pack(push, 1)
struct XO_VERIFY_LICENSE_REQUEST
{
    DWORD       cbSize;
    DWORD       dwTitleId;
    DWORD       dwOfferId;

    ULONGLONG   qwPuids[5];
};
#pragma pack(pop)

#define LIC_XRL_PADDING 15

struct XO_OFFERING_VERIFY_LICENSE_TASK
{
    XONLINETASK_CONTEXT         Context;            // Standard Task Pump context info
    
    XONLINETASK_HANDLE          hXrlTask;           // handle for xrl task
    XONLINETASK_HANDLE          hCacheTask;         // hanlde for caching task
    XO_LICENSE_CACHE_INDEX      index;              // current index data

    HANDLE                      hCache;             // cache handle
    XONLC_CONTEXT               cacheContext;       // cache context

    XO_VERIFY_LICENSE_REQUEST   Request;            // request info
    DWORD                       cbResults;          // response size

    XO_OFFERING_LICENSE         OfferingLicense;    // license info
    BYTE                        rgbyPadding[LIC_XRL_PADDING]; // padding buffer for xrl calls

    BYTE                        nPuidIndex;         // last puid to be examined        
    
    XON_OFFERING_VERIFY_STATES  State;              // Current state of op
    HRESULT                     hrFinal;            // Final HRESULT
};

/////////////////////////////////////////////////////////////////////////////
// XOnlineOfferingPurchase()
//
// User entry point to purchase an online offering.
// 

HRESULT
CXo::XOnlineOfferingPurchase( DWORD dwUserIndex, 
                              XONLINEOFFERING_ID OfferingId, 
                              HANDLE hWorkEvent,
                              XONLINETASK_HANDLE *phTask )
{
    XoEnter("XOnlineOfferingPurchase");
    XoCheck(dwUserIndex < 4);

    ULONGLONG           qwUserPUID = 0;
    HRESULT             hr         = S_OK;
    PXO_PURCHASE_TASK   pXoPurch   = NULL;
    DWORD               cbBuffer   = XO_PURCHASE_BUFFER_SIZE;   
    PXONLINE_USER       rgUsers    = NULL;
    XUID                xUser;

    PXONLINE_SERVICE_INFO pBillingServiceInfo; 

    //  create the task context
	pXoPurch = (PXO_PURCHASE_TASK)SysAllocZ(sizeof(XO_PURCHASE_TASK), PTAG_XO_PURCHASE_TASK);
    if( !pXoPurch ) {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    // set up first state to go to on pumping...
    pXoPurch->dwState = xopurchWaitResponse;

    TaskInitializeContext( &(pXoPurch->Context) );

    // the work function entry point.
    pXoPurch->Context.pfnContinue = DoPurchaseContinue;
    pXoPurch->Context.pfnClose = DoPurchaseClose;
    pXoPurch->Context.hEventWorkAvailable = hWorkEvent;

#ifndef _XBILLING_DUMMY

    // Get UserPUID from controller id
    rgUsers = XOnlineGetLogonUsers();
    if(rgUsers == NULL) {
        hr = XONLINE_E_NO_SESSION;
        goto Error;
    }
    
    xUser = rgUsers[dwUserIndex].xuid;
    qwUserPUID = xUser.qwUserID;
    if(qwUserPUID == 0) {
        hr = XONLINE_E_USER_NOT_LOGGED_ON;
        goto Error;
    }
    // block guests from purchasing stuff!! :)
    Assert( !XOnlineIsUserGuest(xUser.dwUserFlags) );
    if( XOnlineIsUserGuest(xUser.dwUserFlags) ) {
        hr = XONLINE_E_NO_GUEST_ACCESS;
        goto Error;
    }

#endif


    // fill in payload data for the purchase operation
    pXoPurch->Request.cbSize = sizeof(XO_PURCHASE_REQUEST);
    pXoPurch->Request.qwUserPUID = qwUserPUID;
    pXoPurch->Request.dwOfferingId = OfferingId;

    // launch the upload! 

#ifndef _XBILLING_DUMMY

    hr = UploadFromMemoryInternal( 
            XONLINE_BILLING_OFFERING_SERVICE,        // service for billing
            XO_OFFERING_PURCHASE_XRL,               
            pXoPurch->rgbWorkBuffer,
            cbBuffer,
            NULL,                                   // extra headers buffer
            0,                                      // .. and count for it.
            (PBYTE)&(pXoPurch->Request),
            sizeof(XO_PURCHASE_REQUEST),
            XOBILLING_TIMEOUT,
            hWorkEvent,                             // event handle.
            &(pXoPurch->xrlULContext)
        );

#endif

    if( hr != S_OK ) {
        goto Error;
    }       
            
    // pass back the uber-task-handle.  it's opaque and carries our extra data.
    *phTask = (XONLINETASK_HANDLE)pXoPurch;
    
    // we're OK, exit here
    goto Exit;

Error:
    // Failed setup, make sure we clean up everything
    if (pXoPurch)
        SysFree(pXoPurch);

Exit:   
    return(XoLeave(hr));
}


// DoPurchaseContinue()
//
// This is the entry point for the purchase task pump
//
HRESULT CXo::DoPurchaseContinue( XONLINETASK_HANDLE     hTask )
{

    HRESULT             hr       = S_OK;
    PXO_PURCHASE_TASK   pXoPurch = (PXO_PURCHASE_TASK)hTask;

    Assert(hTask != NULL);

    // The first and only working state, we're waiting for a response here.
    //
    if (pXoPurch->dwState == xopurchWaitResponse) {


#ifdef _XBILLING_DUMMY
    
        pXoPurch->hrFinal = S_OK;
        hr = XONLINETASK_S_SUCCEEDED;
        pXoPurch->dwState = xopurchDone;
        goto Exit;
#endif
        
        // all we do in this is pump on the upload.
        hr = XOnlineTaskContinue( (XONLINETASK_HANDLE)(&(pXoPurch->xrlULContext)));

        // done with the upload? 
        if( hr != XONLINETASK_S_RUNNING ) {
            
            // get final result (will be either S_OK aka XONLINETASK_S_SUCCEEDED, 
            // or from X-Err field on error).
            pXoPurch->hrFinal = hr;

            // we're done
            pXoPurch->dwState = xopurchDone;
        }
    }

    // When the next state is xopurchDone, we are done.
    // 
    if (pXoPurch->dwState == xopurchDone)
    {
        // Indicate that we are done and return the final code
        hr = pXoPurch->hrFinal;
        goto Exit;
    }

Exit:   
    return(hr);
}


// DoPurchaseClose()
//
// Performs an "new school" XOnlineTaskClose on a purchase task.
//
VOID CXo::DoPurchaseClose(XONLINETASK_HANDLE hTask)
{
    PXO_PURCHASE_TASK   pXoPurch = (PXO_PURCHASE_TASK)hTask;

    Assert(hTask != NULL);

    // Do we need to ensure that we've completed?
    Assert(pXoPurch->dwState == xopurchDone);

    // Close the upload task's handle first
    XRL_CleanupHandler(&(pXoPurch->xrlULContext.xrlasync));

    // ...And get rid of our own resources
    SysFree(pXoPurch);
}


/////////////////////////////////////////////////////////////////////////////
// XOnlineOfferingCancel()
//
// User entry point to cancel an online offering.
// 

HRESULT 
CXo::XOnlineOfferingCancel(  DWORD dwUserIndex, 
                             XONLINEOFFERING_ID OfferingId, 
                             HANDLE hWorkEvent,
                             XONLINETASK_HANDLE *phTask )
{
    XoEnter("XOnlineOfferingCancel");
    XoCheck(dwUserIndex < 4);

    ULONGLONG           qwUserPUID = 0;
    HRESULT             hr         = S_OK;
    PXO_CANCEL_TASK     pXoCancel  = NULL;
    PXONLINE_USER       rgUsers    = NULL;
    XUID                xUser;
    DWORD               cbBuffer   = XO_PURCHASE_BUFFER_SIZE;   
    
    PXONLINE_SERVICE_INFO pBillingServiceInfo; 

    //  create the task context
	pXoCancel = (PXO_CANCEL_TASK)SysAllocZ(sizeof(XO_CANCEL_TASK), PTAG_XO_CANCEL_TASK);
    if( !pXoCancel )
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    // set up first state to go to on pumping...
    pXoCancel->dwState = xocancelWaitResponse;

    TaskInitializeContext( &(pXoCancel->Context) );

    // the work function entry point.
    pXoCancel->Context.pfnContinue = DoCancelContinue;
    pXoCancel->Context.pfnClose = DoCancelClose;
    pXoCancel->Context.hEventWorkAvailable = hWorkEvent;


#ifndef _XBILLING_DUMMY

    // Get UserPUID from controller id
    rgUsers = XOnlineGetLogonUsers();
    if(rgUsers == NULL) {
        hr = XONLINE_E_NO_SESSION;
        goto Error;
    }

    xUser = rgUsers[dwUserIndex].xuid;
    qwUserPUID = xUser.qwUserID;
    if(qwUserPUID == 0) {
        hr = XONLINE_E_USER_NOT_LOGGED_ON;
        goto Error;
    }
    // block guests 
    Assert( !XOnlineIsUserGuest(xUser.dwUserFlags) );
    if( XOnlineIsUserGuest(xUser.dwUserFlags) ) {
        hr = XONLINE_E_NO_GUEST_ACCESS;
        goto Error;
    }
#endif


    // fill in payload data for the cancel operation
    pXoCancel->Request.cbSize = sizeof(XO_CANCEL_REQUEST);
    pXoCancel->Request.qwUserPUID = qwUserPUID;
    pXoCancel->Request.dwOfferingId = OfferingId;

    // launch the upload! 

#ifndef _XBILLING_DUMMY

    hr = UploadFromMemoryInternal( 
            XONLINE_BILLING_OFFERING_SERVICE,       // service for billing
            XO_OFFERING_CANCEL_XRL,             
            pXoCancel->rgbWorkBuffer,
            cbBuffer,
            NULL,                                   // extra headers buffer
            0,                                      // .. and count for it.
            (PBYTE)&(pXoCancel->Request),
            sizeof(XO_CANCEL_REQUEST),
            XOBILLING_TIMEOUT,
            hWorkEvent,                             // event handle.
            &(pXoCancel->xrlULContext)
        );

#endif

    if( hr != S_OK ) {
        goto Error;
    }       
            
    // pass back the uber-task-handle.  it's opaque and carries our extra data.
    *phTask = (XONLINETASK_HANDLE)pXoCancel;
    
    // we're OK, exit here
    goto Exit;

Error:
    // Failed setup, make sure we clean up everything
    if (pXoCancel)
        SysFree(pXoCancel);

Exit:   
    return(XoLeave(hr));
}


// DoCancelContinue()
//
// This is the entry point for the offer cancel task pump
//
HRESULT CXo::DoCancelContinue(XONLINETASK_HANDLE hTask)
{

    HRESULT             hr       = S_OK;
    PXO_CANCEL_TASK     pXoCancel = (PXO_CANCEL_TASK)hTask;

    Assert(hTask != NULL);

    // The first and only working state, we're waiting for a response here.
    //
    if (pXoCancel->dwState == xocancelWaitResponse) {


#ifdef _XBILLING_DUMMY
    
        pXoCancel->hrFinal = S_OK;
        hr = XONLINETASK_S_SUCCEEDED;
        pXoCancel->dwState = xocancelDone;
        goto Exit;
#endif
        
        // all we do in this is pump on the upload.
        hr = XOnlineTaskContinue( (XONLINETASK_HANDLE)(&(pXoCancel->xrlULContext)));

        // done with the upload? 
        if( hr != XONLINETASK_S_RUNNING ) {
            
            // get final result (will be either S_OK aka XONLINETASK_S_SUCCEEDED, 
            // or from X-Err field on error).
            pXoCancel->hrFinal = hr;

            // we're done
            pXoCancel->dwState = xocancelDone;
        }
    }

    // When the next state is xocancelDone, we are done.
    // 
    if (pXoCancel->dwState == xocancelDone)
    {
        // Indicate that we are done and return the final code
        hr = pXoCancel->hrFinal;
        goto Exit;
    }

Exit:   
    return(hr);
}


// DoCancelClose()
//
// Performs an "new school" XOnlineTaskClose on a cancel task.
//
VOID CXo::DoCancelClose(XONLINETASK_HANDLE hTask)
{
    PXO_CANCEL_TASK pXoCancel = (PXO_CANCEL_TASK)hTask;

    Assert(hTask != NULL);

    // Do we need to ensure that we've completed?
    Assert(pXoCancel->dwState == xocancelDone);

    // Close the upload task's handle first
    XRL_CleanupHandler(&(pXoCancel->xrlULContext.xrlasync));

    // ...And get rid of our own resources
    SysFree(pXoCancel);
}


/////////////////////////////////////////////////////////////////////////////
// XOnlineOfferingGetDetails()
//
// User entry point to get details for an online offering.
// 
HRESULT
CXo::XOnlineOfferingGetDetails ( DWORD                   dwUserIndex,
                                 XONLINEOFFERING_ID      OfferingId,
                                 WORD                    wLanguage,
                                 DWORD                   dwDescriptionIndex,
                                 PBYTE                   pbBuffer,
                                 DWORD                   cbBuffer,
                                 HANDLE                  hWorkEvent,
                                 XONLINETASK_HANDLE      *phTask )
{
    XoEnter("XOnlineOfferingGetDetails");
    XoCheck(dwUserIndex < 4);
    XoCheck(OfferingId != 0);
    XoCheck(cbBuffer != 0);

    HRESULT                     hr         = S_OK;
    ULONGLONG                   qwUserPUID = 0;
    PXO_DETAILS_TASK            pDetails   = NULL;
    PXONLINE_USER               rgUsers    = NULL;
    XUID                        xUser;
    CHAR                        szContentType[25];
    DWORD                       cbContentType;

    // Get UserPUID from controller id
    rgUsers = XOnlineGetLogonUsers();
    if(rgUsers == NULL) {
        hr = XONLINE_E_NO_SESSION;
        goto Error;
    }
    xUser = rgUsers[dwUserIndex].xuid;
    qwUserPUID = xUser.qwUserID;
    if(qwUserPUID == 0) {
        hr = XONLINE_E_USER_NOT_LOGGED_ON;
        goto Error;
    }
    // block guests 
    Assert( !XOnlineIsUserGuest(xUser.dwUserFlags) );
    if( XOnlineIsUserGuest(xUser.dwUserFlags) )
    {
        hr = XONLINE_E_NO_GUEST_ACCESS;
        goto Error;
    }

	// We are responsible for allocating the context and the work buffer
	// The work buffer are the specified bytes immediately following the
	// context structure
	pDetails = (PXO_DETAILS_TASK)SysAlloc(sizeof(PXO_DETAILS_TASK) + (pbBuffer ? 0 : cbBuffer), PTAG_XO_DETAILS_TASK);
	if (!pDetails)
	{
		hr = E_OUTOFMEMORY;
		goto Error;
	}

    // Initialize the context
    ZeroMemory(pDetails, sizeof(PXO_DETAILS_TASK));

    // Set up the buffer 
    if (!pbBuffer)
        pbBuffer = (PBYTE)(pDetails + 1);

    // the work function entry point.
    TaskInitializeContext(&(pDetails->Context));
    pDetails->Context.pfnContinue           = DoDetailsContinue;
    pDetails->Context.pfnClose              = DoDetailsClose;
    pDetails->Context.hEventWorkAvailable   = hWorkEvent;
    pDetails->dwState = xodetailsWaitResponse;
    
    // Load up the request infomation
    pDetails->Request.cbSize             = sizeof(XO_DETAILS_REQUEST);
    pDetails->Request.qwUserPUID         = qwUserPUID;
    pDetails->Request.dwOfferId          = OfferingId;
    pDetails->Request.dwDescriptionIndex = dwDescriptionIndex;
    if( wLanguage == LANGUAGE_CURRENT ) {
        pDetails->Request.sLanguageId = (short)XGetLanguage();    // use whatever the dash is set to now... 
    } else {
        pDetails->Request.sLanguageId = wLanguage;              // ...or override the dash's default
    }

    // Build the content type header
    cbContentType = sprintf(szContentType, 
                            "Content-type: xon/%x\r\n", XONLINE_BILLING_OFFERING_SERVICE);  

    hr = UploadFromMemoryInternal(
                XONLINE_BILLING_OFFERING_SERVICE,
                XO_OFFERING_DETAILS_XRL,
                pbBuffer,
                cbBuffer,
                (PBYTE)szContentType,
                cbContentType,
                (PBYTE)&(pDetails->Request),
                pDetails->Request.cbSize,
                XOBILLING_TIMEOUT,
                hWorkEvent,
                &(pDetails->xrlULContext));


    if( FAILED(hr) ) {
        goto Error;
    } else {
        
        hr = S_OK;
        // pass back the uber-task-handle.  it's opaque and carries our extra data.
        *phTask = (XONLINETASK_HANDLE)pDetails;
        goto Exit;
    }

Error:
    // since something messed up, we need to clean up the mess
    if( pDetails ) 
        SysFree( pDetails );
    
Exit:
    return hr;
}

// DoDetailsContinue()
//
// This is the entry point for the details task pump
//
HRESULT CXo::DoDetailsContinue( XONLINETASK_HANDLE      hTask )
{
    HRESULT             hr         = S_OK;
    PXO_DETAILS_TASK    pXoDetails = (PXO_DETAILS_TASK)hTask;

    Assert(hTask != NULL);

    switch(pXoDetails->dwState) {
        case xodetailsWaitResponse:

            // The first working state, we're waiting for a response here.
            //

            // all we do here is pump on the upload.
            hr = XOnlineTaskContinue( (XONLINETASK_HANDLE)(&(pXoDetails->xrlULContext)));

            // done with the upload? 
            if( hr != XONLINETASK_S_RUNNING ) {
        
                // we might have a real problem here.  in which case, we can jump right
                // to the done state, because there will be no results to process.
                if( hr != XONLINETASK_S_SUCCESS) {  
                    pXoDetails->hrFinal = hr;
                    pXoDetails->dwState = xodetailsDone;
                } else {
                    
                    // we're successfully done here, now we need to figure out the rest of it!
                    pXoDetails->hrFinal = XONLINETASK_S_SUCCESS;
                    pXoDetails->dwState = xodetailsParseResponse;
                    hr = XONLINETASK_S_RUNNING;         // so that *our* task can keep going.
                }
            }
            break;

        case xodetailsParseResponse:

            XOParsePrices(hTask);
            pXoDetails->dwState = xodetailsResultsAvail;
            hr = XONLINETASK_S_RESULTS_AVAIL;
            goto Exit;

        case xodetailsResultsAvail:
            
            // we STAY HERE until GetResults() is called. 
            hr = XONLINETASK_S_RESULTS_AVAIL;
            goto Exit;

        case xodetailsDone:

            // all done here, apparently.  use the upload HR, whether success or not.
            hr = pXoDetails->hrFinal;
            goto Exit;

        default:
            AssertSz(FALSE, "DoDetailsContinue: bad state");
    }

Exit:   
    return hr;
}


// DoDetailsClose()
//
// Performs an "new school" XOnlineTaskClose on a details task.
// Allows closures when results are waiting.
//
VOID CXo::DoDetailsClose(XONLINETASK_HANDLE hTask)
{
    PXO_DETAILS_TASK    pXoDetails = (PXO_DETAILS_TASK)hTask;

    Assert(hTask != NULL);

    // Do we need to ensure that we've completed?
    Assert(pXoDetails->dwState >= xodetailsResultsAvail);

    // Close the upload task's handle first
    XRL_CleanupHandler(&(pXoDetails->xrlULContext.xrlasync));

    // ...And get rid of our own resources
    SysFree(pXoDetails);
}

// XOParsePrices()
//
//  Helper function to unpack price data from details header into meaningful
//  price structs to help the client.
//
VOID CXo::XOParsePrices(XONLINETASK_HANDLE hTask)
{
    WCHAR                isoCode[3];
    PXO_DETAILS_TASK     pXoDetails = (PXO_DETAILS_TASK)hTask;
    
    Assert(pXoDetails != NULL);

    PXO_DETAILS_HEADER   header     = (PXO_DETAILS_HEADER)(pXoDetails->xrlULContext.xrlasync.pBuffer);


    // we're in trouble if the header size isn't what's expected.
    Assert(header->cbSize >= sizeof(XO_DETAILS_HEADER));
    Assert(header->cbSize == (sizeof(XO_DETAILS_HEADER)+(header->dwSizeOfBlob))); 

    // assign the ISO codes -- inelegant thunking (casting) from unicode to ascii is OK because
    //  the ISO codes are always in [A-Z] interval.
    Assert((header->rgchISOCode[0] >> 8) == 0x0);       // make sure thunking is OK
    Assert((header->rgchISOCode[1] >> 8) == 0x0);
    Assert((header->rgchISOCode[2] >> 8) == 0x0);
    pXoDetails->GrossPrice.rgchISOCurrencyCode[0] = pXoDetails->NetPrice.rgchISOCurrencyCode[0] = (CHAR)header->rgchISOCode[0];
    pXoDetails->GrossPrice.rgchISOCurrencyCode[1] = pXoDetails->NetPrice.rgchISOCurrencyCode[1] = (CHAR)header->rgchISOCode[1];
    pXoDetails->GrossPrice.rgchISOCurrencyCode[2] = pXoDetails->NetPrice.rgchISOCurrencyCode[2] = (CHAR)header->rgchISOCode[2];

    // currency format byte
    pXoDetails->GrossPrice.bCurrencyFormat = pXoDetails->NetPrice.bCurrencyFormat = header->bCurrencyFormat;

    // assign gross price
    pXoDetails->GrossPrice.dwWholePart = header->dwGrossWholePart;
    pXoDetails->GrossPrice.dwFractionalPart = header->bGrossFractionalPart;

    // assign net price
    pXoDetails->NetPrice.dwWholePart = header->dwNetWholePart;
    pXoDetails->NetPrice.dwFractionalPart = header->bNetFractionalPart;

}

/////////////////////////////////////////////////////////////////////////////
// XOnlineOfferingGetDetailsGetResults()
//
// User entry point to get results from the details.  All results are optional;
// pass in NULL and you get nothing, pass in a valid pointer and you'll get
// the results you want. 
// 
HRESULT
CXo::XOnlineOfferingDetailsGetResults    ( XONLINETASK_HANDLE      hTask,
                                           PBYTE                   *pDetailsBuffer,
                                           DWORD                   *pcbDetailsLength,
                                           XONLINE_PRICE           *pGrossPrice,
                                           XONLINE_PRICE           *pNetPrice )
{
    XoEnter("XOnlineOfferingDetailsGetResults");
    XoCheck(hTask != NULL);

    PXO_DETAILS_TASK    pXoDetails = (PXO_DETAILS_TASK)hTask;
    PXO_DETAILS_HEADER  pHeader;

    Assert(pXoDetails->dwState == xodetailsResultsAvail);
           
    // since the current state seems to check out OK, load up all the desired args.
    pHeader = (PXO_DETAILS_HEADER)(pXoDetails->xrlULContext.xrlasync.pBuffer);

    if( pcbDetailsLength ) {
        *pcbDetailsLength = pHeader->dwSizeOfBlob;
    }

    if( pDetailsBuffer ) {
        if(pHeader->dwSizeOfBlob) { 
            *pDetailsBuffer = (BYTE *)(pHeader + 1);
        } else {
            *pDetailsBuffer = NULL;
        }
    }

    if( pGrossPrice ) {
        *pGrossPrice = pXoDetails->GrossPrice;
    }

    if( pNetPrice ) {
        *pNetPrice = pXoDetails->NetPrice;
    }

    // since the results have done been gotten, we can allow the consumer to 
    // see the task as complete.
    pXoDetails->dwState = xodetailsDone;

    return S_OK;
}

//---------------------------------------------------------
//
// XOnlineOfferingGetDetailsMaxSize()
//
//      Returns the size of the buffer to pass into a details
//          request. Allows the user to specify a max cap for
//          data that this title uses (thus reducing the buffer
//          size needed).  Otherwise, pass in 0 and get the max
//          possible.  Synchronous.
// 

DWORD CXo::XOnlineOfferingDetailsMaxSize(DWORD cbTitleSpecificDataMaxSize)
{
    XoEnter_("XOnlineOfferingDetailsMaxSize", 0);

    if (!cbTitleSpecificDataMaxSize)
        cbTitleSpecificDataMaxSize = XO_DETAILS_MAX_TITLE_DATA_SIZE ;

    cbTitleSpecificDataMaxSize += sizeof(XO_DETAILS_HEADER);
    return(cbTitleSpecificDataMaxSize);
}



//---------------------------------------------------------
//
// XOnlineOfferingVerify()
//
//      User entry point to verify rights to an offering. 
// 

HRESULT
CXo::XOnlineOfferingVerifyLicense( DWORD dwOfferingId, 
                                   DWORD dwUserAccounts,
                                   HANDLE hWorkEvent,
                                   XONLINETASK_HANDLE *phTask )
{
    XoEnter("XOnlineOfferingVerify");
    XoCheck(phTask != NULL);
    HRESULT hr                                      = XONLINETASK_S_RUNNING;
    XO_OFFERING_VERIFY_LICENSE_TASK* pVerifyTask    = NULL;
    PXONLINE_USER pUsers                            = NULL;

    //
    //  create the task context
    //

    pVerifyTask = (XO_OFFERING_VERIFY_LICENSE_TASK*)SysAllocZ(sizeof(XO_OFFERING_VERIFY_LICENSE_TASK),
        PTAG_XO_OFFERING_VERIFY_LICENSE_TASK);
    if( !pVerifyTask ) 
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    TaskInitializeContext( &(pVerifyTask->Context) );
    pVerifyTask->Context.pfnContinue            = VerifyLicenseTaskContinue;
    pVerifyTask->Context.pfnClose               = VerifyLicenseTaskClose;
    pVerifyTask->Context.hEventWorkAvailable    = hWorkEvent;
    

    //
    // set up license specific stuff
    //
    pVerifyTask->Request.cbSize     = sizeof(XO_VERIFY_LICENSE_REQUEST);
    pVerifyTask->Request.dwOfferId  = dwOfferingId;
    pVerifyTask->Request.dwTitleId  = m_dwTitleId;
    pVerifyTask->cbResults          = sizeof(XO_OFFERING_LICENSE) + LIC_XRL_PADDING;
        
    // 
    // populate list of users.  guests don't count.
    //
    // TODO: set machine account. waiting for an api from tony.
    //
    pVerifyTask->Request.qwPuids[0] = 0xffffffffffffffff;
    
    pUsers = XOnlineGetLogonUsers();

    if (dwUserAccounts & XONLINE_LOGON_CONTROLLER1 && !XOnlineIsUserGuest(pUsers[0].xuid.dwUserFlags))
    {
        pVerifyTask->Request.qwPuids[1] = pUsers[0].xuid.qwUserID;
    }
    if (dwUserAccounts & XONLINE_LOGON_CONTROLLER2 && !XOnlineIsUserGuest(pUsers[1].xuid.dwUserFlags))
    {
        pVerifyTask->Request.qwPuids[2] = pUsers[1].xuid.qwUserID;
    }
    if (dwUserAccounts & XONLINE_LOGON_CONTROLLER3 && !XOnlineIsUserGuest(pUsers[2].xuid.dwUserFlags))
    {
        pVerifyTask->Request.qwPuids[3] = pUsers[2].xuid.qwUserID;
    }
    if (dwUserAccounts & XONLINE_LOGON_CONTROLLER4 && !XOnlineIsUserGuest(pUsers[3].xuid.dwUserFlags))
    {
        pVerifyTask->Request.qwPuids[4] = pUsers[3].xuid.qwUserID;
    }

    
    // BUGBUG: remove me!
    pVerifyTask->Request.qwPuids[0] = 23;
    pVerifyTask->Request.qwPuids[1] = 2;
    // END BUGBUG


    // 
    // start off by searching for the license in the cache
    //
    pVerifyTask->State = xoverifyCacheOpen;    
    
    pVerifyTask->index.dwOfferingId = dwOfferingId;
    pVerifyTask->cacheContext.pbIndexData = (PBYTE)&(pVerifyTask->index);
    
    pVerifyTask->cacheContext.pbRecordBuffer = (PBYTE)&(pVerifyTask->OfferingLicense);
    pVerifyTask->cacheContext.dwRecordBufferSize = sizeof(XO_OFFERING_LICENSE);

    
    hr = DoVerifyCacheOpen(pVerifyTask);
    
    *phTask = (XONLINETASK_HANDLE)pVerifyTask; 

Cleanup:    
    if (FAILED(hr) && pVerifyTask) 
    {
        SysFree(pVerifyTask);
        *phTask = NULL;
    }

    return(hr);
}

//---------------------------------------------------------
//
// VerifyLicenseTaskContinue()
//
//  Callback fn for the verify task pump
//
HRESULT CXo::VerifyLicenseTaskContinue(XONLINETASK_HANDLE hTask)
{
    HRESULT hr                                      = XONLINETASK_S_SUCCESS;
    DWORD dwUploadFlags                             = 0;
    XO_OFFERING_VERIFY_LICENSE_TASK* pVerifyTask    = (XO_OFFERING_VERIFY_LICENSE_TASK*)hTask;

    Assert(hTask != NULL);


    switch (pVerifyTask->State) 
    {
    case xoverifyCacheOpen:
    case xoverifyCacheOpenPump:
        hr = DoVerifyCacheOpen(pVerifyTask);
        break;

    case xoverifyCacheLookup:
    case xoverifyCacheLookupPump:
        hr = DoVerifyCacheLookup(pVerifyTask);
        break;

    case xoverifyUpload:
    case xoverifyUploadPump:
        hr = DoVerifyServerRequest(pVerifyTask);            
        break;

    case xoverifyCacheUpdate:
    case xoverifyCacheUpdatePump:
        hr = DoVerifyCacheUpdate(pVerifyTask);            
        break;
    
    case xoverifyCacheClose:
    case xoverifyCacheClosePump:
        hr = DoVerifyCacheClose(pVerifyTask);            
        break;

    case xoverifyDone:
        hr = pVerifyTask->hrFinal;
        break;

    default:
        // unknown state!
        ASSERT(FALSE);
        break;

    } 

    
    if (hr != XONLINETASK_S_RUNNING)
    {
        pVerifyTask->State = xoverifyDone;
        pVerifyTask->hrFinal = hr;
    }

    return hr;
}

//---------------------------------------------------------
//
// VerifyLicenseTaskClose
//
//  Closes the handle associated with this task and
//  all sub-handles.
//
VOID CXo::VerifyLicenseTaskClose(XONLINETASK_HANDLE hTask)
{
    XO_OFFERING_VERIFY_LICENSE_TASK* pVerifyTask    = (XO_OFFERING_VERIFY_LICENSE_TASK*)hTask;
    
    Assert(hTask != NULL);

    //
    // clean up cache handle
    //
    if (pVerifyTask->hCache)
    {
        pVerifyTask->hCache = NULL;
    }

    if (pVerifyTask->hCacheTask != NULL)
    {
        XOnlineTaskClose(pVerifyTask->hCacheTask);
        pVerifyTask->hCacheTask = NULL;
    }
    
    //
    // clean up xrl handle
    //
    if (pVerifyTask->hXrlTask != NULL)
    {
        XOnlineTaskClose(pVerifyTask->hXrlTask);
        pVerifyTask->hXrlTask = NULL;
    }
    
    
    // 
    // clean up our own task
    //
    SysFree(pVerifyTask);
}


//---------------------------------------------------------
//
// DoVerifyCacheOpen
//
//  Opens the cache.
//
HRESULT CXo::DoVerifyCacheOpen(XO_OFFERING_VERIFY_LICENSE_TASK* pVerifyTask)
{
    HRESULT hr = XONLINETASK_S_RUNNING;

    if (pVerifyTask->State == xoverifyCacheOpen)
    {
        ASSERT(pVerifyTask->hCacheTask == NULL);
        pVerifyTask->State = xoverifyCacheOpenPump;
        hr = CacheOpen(XONLC_TYPE_LICENSING, NULL, pVerifyTask->Context.hEventWorkAvailable, &(pVerifyTask->hCache), &(pVerifyTask->hCacheTask));

        goto Cleanup;
    }

    ASSERT(pVerifyTask->State == xoverifyCacheOpenPump);
    
    hr = XOnlineTaskContinue(pVerifyTask->hCacheTask);

Cleanup:
    if (hr == XONLINETASK_S_SUCCESS)
    {
        // done opening, proceed to next task
        pVerifyTask->State = xoverifyCacheLookup;
        hr = XONLINETASK_S_RUNNING;
    }

    return hr;
}


//---------------------------------------------------------
//
// DoVerifyCacheLookup
//
//  Checks the local cache for any valid licenses.
//
HRESULT CXo::DoVerifyCacheLookup(XO_OFFERING_VERIFY_LICENSE_TASK* pVerifyTask)
{
    HRESULT hr = XONLINETASK_S_RUNNING;
    int i;


    //
    // if there's an existing task, keep puming it.
    //
    if (pVerifyTask->State == xoverifyCacheLookupPump)
    {
        hr = XOnlineTaskContinue(pVerifyTask->hCacheTask);
        if (hr == XONLINETASK_S_RUNNING || FAILED(hr))
        {
            goto Cleanup;
        }

        pVerifyTask->State = xoverifyCacheLookup;

        // found the cached item!
        hr = VerifyRights(&(pVerifyTask->OfferingLicense), pVerifyTask->index.qwPuid);
        if (SUCCEEDED(hr))                                                                             
        {
            goto Cleanup;
        }
    }

    ASSERT(pVerifyTask->State == xoverifyCacheLookup);


    // 
    // search cache using the remaining puids
    //
    for(; pVerifyTask->nPuidIndex < 5; pVerifyTask->nPuidIndex++)
    {
        if (pVerifyTask->Request.qwPuids[pVerifyTask->nPuidIndex] == 0)
        {
            continue;
        }
        
        pVerifyTask->index.qwPuid = pVerifyTask->Request.qwPuids[pVerifyTask->nPuidIndex];
    
        
        hr = CacheLookup(pVerifyTask->hCache, &(pVerifyTask->cacheContext));
        if (FAILED(hr))
        {
            goto Cleanup;
        }

        if (!pVerifyTask->cacheContext.bValidDataInCache)
        {
            continue;
        }
        
        // found item, need to retrieve from disk?
        if (pVerifyTask->cacheContext.bCallRetrieveNext)
        {
            pVerifyTask->State = xoverifyCacheLookupPump;
            hr = CacheRetrieve(pVerifyTask->hCache, pVerifyTask->hCacheTask, &(pVerifyTask->cacheContext));
            if (hr == XONLINETASK_S_RUNNING || FAILED(hr))
            {
                goto Cleanup;
            }

            // retrieve succeeded, no need to pump
            pVerifyTask->State = xoverifyCacheLookup;
        }
        
        // is this really the right license?
        hr = VerifyRights(&(pVerifyTask->OfferingLicense), pVerifyTask->index.qwPuid);
        if (SUCCEEDED(hr))
        {
            goto Cleanup;
        }
    }

    // 
    // no cached license found, proceed to upload
    //
    //ASSERT(pVerifyTask->hCacheTask == NULL);
    pVerifyTask->State = xoverifyUpload;
    hr = XONLINETASK_S_RUNNING;
    
Cleanup:
    return hr;
}


//---------------------------------------------------------
// VerifyRights
//
//  checks if the given puid has rights according
//  to the data stored in a license.
//
HRESULT CXo::VerifyRights(XO_OFFERING_LICENSE* pLic, ULONGLONG puid)
{
    HRESULT hr = XONLINE_E_OFFERING_PERMISSION_DENIED;
    FILETIME ft; 
    FILETIME ftNow;
    
#ifdef XONLINE_FEATURE_XBOX 
    XCALCSIG_SIGNATURE Signature;
    HANDLE hSig;

    // check signature
    hSig = XCalculateSignatureBegin(XCALCSIG_FLAG_NON_ROAMABLE);
    XCalculateSignatureUpdate(hSig, (PBYTE)pLic, sizeof(XO_OFFERING_LICENSE) - sizeof(XCALCSIG_SIGNATURE));
    XCalculateSignatureEnd(hSig, &Signature);

    if (memcmp(&Signature, &(pLic->Signature), sizeof(XCALCSIG_SIGNATURE)) != 0)
    {
        goto Cleanup;
    }
#endif
       
    // check puid
    if (pLic->wConditionFlags & XO_LIC_USERID)
    {
        if (pLic->qwPassportUserID != puid)
        {
            goto Cleanup;
        }
    }
    
    GetSystemTimeAsFileTime(&ftNow);

    // check license refresh time
    if (pLic->wConditionFlags & XO_LIC_TIMEREFRESH)
    {
        if (CompareFileTime(&(pLic->filetimeRefresh), &ftNow) == -1)
        {
            goto Cleanup;
        }
    }

    // check when this license starts
    if (pLic->wConditionFlags & XO_LIC_TIMEFROM)
    {
        if (CompareFileTime(&(pLic->filetimeFrom), &ftNow) == 1)
        {
            goto Cleanup;
        }
    }

    // check whenthis license ends
    if (pLic->wConditionFlags & XO_LIC_TIMETO)
    {
        if (CompareFileTime(&(pLic->filetimeTo), &ftNow) == -1)
        {
            goto Cleanup;
        }
    }

    // all checks passed, they're good to go!
    hr = XONLINETASK_S_SUCCESS;

Cleanup:
    return hr;
}

//---------------------------------------------------------
// DoVerifyServerRequest
//
//  asks the server if the user has rights to this offering.
//  if it does, task->OfferingLicense is filled with the
//  license.
//
HRESULT CXo::DoVerifyServerRequest(XO_OFFERING_VERIFY_LICENSE_TASK* pVerifyTask)
{
    HRESULT hr = XONLINETASK_S_RUNNING;

    #ifndef _XBILLING_DUMMY
    // TODO: handle this case.   They're most likely not logged in.
    Assert(SUCCEEDED(XOnlineGetServiceInfo(XONLINE_BILLING_OFFERING_SERVICE, NULL)));
    #endif

    //
    // if the task hasnt been opened, create it
    //
    if (pVerifyTask->State == xoverifyUpload)
    {
        pVerifyTask->State = xoverifyUploadPump;
        
        //
        // launch the upload
        //
        hr = XOnlineUploadFromMemory(
                XONLINE_BILLING_OFFERING_SERVICE,
                XO_OFFERING_VERIFY_LICENSE_XRL,
                (PBYTE)&(pVerifyTask->OfferingLicense),
                &(pVerifyTask->cbResults),
                NULL,
                0,
                (PBYTE)&(pVerifyTask->Request),
                sizeof(XO_VERIFY_LICENSE_REQUEST),
                XOBILLING_TIMEOUT,
                pVerifyTask->Context.hEventWorkAvailable,
                &(pVerifyTask->hXrlTask)
            );

        goto Cleanup;
    }
    
    ASSERT(pVerifyTask->State == xoverifyUploadPump);

    hr = XOnlineTaskContinue(pVerifyTask->hXrlTask);
    if (hr == XONLINETASK_S_SUCCESS)
    {
        // TODO: make sure the license is in the response

        // found a license -- add it to the cache.
        pVerifyTask->State = xoverifyCacheUpdate;
        hr = XONLINETASK_S_RUNNING;

        // note: even if adding it to the cache fails, license
        // check will succeed.
        pVerifyTask->hrFinal = S_OK;
        goto Cleanup;
    }


    
Cleanup:

    return hr;
}

//---------------------------------------------------------
// DoVerifyCacheUpdate
//
//  Updates the local cache with the new offering license.
//
HRESULT CXo::DoVerifyCacheUpdate(XO_OFFERING_VERIFY_LICENSE_TASK* pVerifyTask)
{
    HRESULT hr;

    if (pVerifyTask->State == xoverifyCacheUpdate)
    {                                                  
#ifdef XONLINE_FEATURE_XBOX 
        //
        // set signature
        //
        XCALCSIG_SIGNATURE Signature;
        HANDLE hSig;
        
        hSig = XCalculateSignatureBegin(XCALCSIG_FLAG_NON_ROAMABLE);
        XCalculateSignatureUpdate(hSig, (PBYTE)&(pVerifyTask->OfferingLicense), sizeof(XO_OFFERING_LICENSE) - sizeof(XCALCSIG_SIGNATURE));
        XCalculateSignatureEnd(hSig, &(pVerifyTask->OfferingLicense.Signature));
#endif
        
        
        pVerifyTask->State = xoverifyCacheUpdatePump;

        // 
        // set index                                 y
        //
        pVerifyTask->index.dwOfferingId = pVerifyTask->OfferingLicense.dwOfferingId;
        if (pVerifyTask->OfferingLicense.wConditionFlags & XO_LIC_USERID)
        {
            // index on user puid
            pVerifyTask->index.qwPuid   = pVerifyTask->OfferingLicense.qwPassportUserID;
        }
        else
        {
            // index on machine puid
            pVerifyTask->index.qwPuid   = pVerifyTask->Request.qwPuids[0];
        }

        pVerifyTask->cacheContext.pbIndexData        = (PBYTE)&(pVerifyTask->index);
        pVerifyTask->cacheContext.pbRecordBuffer     = (PBYTE)&(pVerifyTask->OfferingLicense);
        pVerifyTask->cacheContext.dwRecordBufferSize = sizeof(XO_OFFERING_LICENSE);


        

        //
        // update cache
        //
        hr = CacheUpdate(pVerifyTask->hCache, pVerifyTask->hCacheTask, (PBYTE)&(pVerifyTask->index), (PBYTE)&(pVerifyTask->OfferingLicense));
        goto Cleanup;
    }

    ASSERT(pVerifyTask->State == xoverifyCacheUpdatePump);
    
    hr = XOnlineTaskContinue(pVerifyTask->hCacheTask);
    if (hr == XONLINETASK_S_SUCCESS)
    {
        pVerifyTask->State = xoverifyCacheClose;
        hr = XONLINETASK_S_RUNNING;
    }

Cleanup:
    return hr;
}

//---------------------------------------------------------
//
// DoVerifyCacheClose
//
//  Opens the cache.
//
HRESULT CXo::DoVerifyCacheClose(XO_OFFERING_VERIFY_LICENSE_TASK* pVerifyTask)
{
    HRESULT hr = XONLINETASK_S_RUNNING;

    ASSERT(pVerifyTask->hCache != NULL);

    if (pVerifyTask->State == xoverifyCacheClose)
    {
        pVerifyTask->State = xoverifyCacheClosePump;
        hr = CacheClose(pVerifyTask->hCache);

        goto Cleanup;
    }

    ASSERT(pVerifyTask->State == xoverifyCacheClosePump);
    
    hr = XOnlineTaskContinue(pVerifyTask->hCacheTask);

Cleanup:
    if (hr == XONLINETASK_S_SUCCESS)
    {
        // all done
        pVerifyTask->State = xoverifyDone;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\contenum.cpp ===
/*++

Copyright (c) Microsoft Corporation

Author:
    Keith Lau (keithlau), Ben Lewis (t-blewis)

Description:
	Module implementing content enumeration

Module Name:

    contenum.c

--*/

#include "xonp.h"
#include "xonver.h"

//
// Define the search path for title enumeration
//
#define XONLINECONTENT_TITLES_SEARCH_PATH	"\\\\.\\c:\\tdata\\*.*"

//
// Define a macro to do offset to pointer conversion
//
#define CONVERT_IN_PLACE(pitem, citem, type)	\
		{\
			DWORD dwOffset;\
			dwOffset = (DWORD)(pitem);\
			if (dwOffset)\
			{\
				if ((dwOffset > cbRecord) ||\
					((dwOffset + (citem * sizeof(type))) > (cbRecord + 1)))\
					goto InvalidData;\
				pitem = (type *)((PBYTE)prechdr + dwOffset);\
			}\
			else\
				pitem = NULL;\
		}

//
// Function to validate and relocate a single metadata record
//
// The validation is mainly length validation and does not really 
// include checking to see the values are 'good'. Relocation refers
// to the process of converting relative offsets within the structure
// to memory pointers.
//
// IMPORTANT: The following code assumes the following:
//    sizeof(DWORD) == sizeof(WCHAR *)
// 
// If we decide to upgrade to a 64-bit platform, we will need to
// fix this.
//
HRESULT CXo::ValidateAndRelocateCatalogRecord(
			PXONLINEOFFERING_ENUM_RESP_RECORD	prechdr,
			DWORD								cbRecord
			)
{
	PXONLINEOFFERING_INFO	pInfo;
	
	// Sanity check of the record size
	if (cbRecord < sizeof(XONLINEOFFERING_ENUM_RESP_RECORD))
		goto InvalidData;

	// Do in-place swap from relative offsets to pointers
	pInfo = &(prechdr->OfferingInfo);
	CONVERT_IN_PLACE(pInfo->pbTitleSpecificData, 
				pInfo->cbTitleSpecificData, BYTE);
	return(S_OK);

InvalidData:
	return(HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
}

//
// Function to parse offering enumeration results
//
HRESULT CXo::ParseEnumerationResults(
			PXONLINETASK_OFFERING_ENUM	pcontenum
			)
{
	HRESULT						hr = S_OK;
	PBYTE						pbBuffer;
	DWORD						cbReceived;
	DWORD						cbCurrent = 0;
	DWORD						cbRecord;
	DWORD						iIndex = 0;
	DWORD						dwOffset;
	PXRL_ASYNC					pxrlasync;
	PXONLINEOFFERING_INFO		*rgInfoSlot;
	PXONLINEOFFERING_INFO		pInfo;
	PXONLINEOFFERING_ENUM_SERVER		penum;
	PXONLINEOFFERING_ENUM_REQ			penumreq;
	PXONLINEOFFERING_ENUM_RESP_HEADER	presphdr;
	PXONLINEOFFERING_ENUM_RESP_RECORD	prechdr;

	Assert(pcontenum != NULL);

	penum = &(pcontenum->enumdata.server);
	penumreq = &(penum->enumreq);
	pxrlasync = &(penum->xrlasyncext.xrlasync);

	pcontenum->dwResults = 0;
	pbBuffer = pxrlasync->pBuffer;
	cbReceived = pxrlasync->dwCurrent;

	// If content length is zero, then there are zero results
	if (!cbReceived)
	{
		if (pxrlasync->uliContentLength.QuadPart == 0)
			goto Cleanup;
		else
			goto InvalidData;
	}

	// Sanity check
	if ((cbReceived < sizeof(XONLINEOFFERING_ENUM_RESP_HEADER)) ||
		(cbReceived > pxrlasync->cbBuffer))
		goto InvalidData;

	// Initialize our pointers
	presphdr = (PXONLINEOFFERING_ENUM_RESP_HEADER)pbBuffer;
	cbCurrent = sizeof(XONLINEOFFERING_ENUM_RESP_HEADER);
	pbBuffer += cbCurrent;
	prechdr = (PXONLINEOFFERING_ENUM_RESP_RECORD)pbBuffer;

	// Verify information
	if (cbReceived != presphdr->Header.cbSize)
		goto InvalidData;
	if (presphdr->cRecords > penumreq->Params.dwMaxResults)
		goto InvalidData;

	// Find the result vector
	rgInfoSlot = (PXONLINEOFFERING_INFO *)(pcontenum + 1);

	//
	// Process records
	//
	while (iIndex < presphdr->cRecords)
	{
		if (presphdr->Header.cbSize < 
				(cbCurrent + sizeof(XONLINEOFFERING_ENUM_RESP_RECORD)))
			goto InvalidData;

		cbRecord = prechdr->cbRecordSize;
		cbCurrent += cbRecord;
		if (presphdr->Header.cbSize < cbCurrent)
			goto InvalidData;

		// Sanity check of the record size
		if (cbRecord < sizeof(XONLINEOFFERING_ENUM_RESP_RECORD))
			goto InvalidData;
			
		// Fill in the result vector
		pInfo = &(prechdr->OfferingInfo);
		rgInfoSlot[iIndex] = pInfo;

		// Validate and relocate record
		hr = ValidateAndRelocateCatalogRecord(prechdr, cbRecord);
		if (FAILED(hr))
			goto Error;
		
		// Move to the next record
		iIndex++;
		pbBuffer += cbRecord;
		prechdr = (PXONLINEOFFERING_ENUM_RESP_RECORD)pbBuffer;
	}

	// Keep track of the last offering ID parsed so for 
	// continuation requests
	penum->OfferingIdLast = pInfo->OfferingId;

	// Mark how many items are returned
	pcontenum->dwResults = iIndex;

	// Finally, figure out if we have more results
	pcontenum->fPartial = ((presphdr->fFlags & XONLINEOFFERING_RESP_FLAG_MORE_RESULTS) != 0);

Cleanup:
	return(hr);

Error:
	goto Cleanup;

InvalidData:
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	goto Error;
}

//
// Implement the do work function for enumeration post-upload subtask
//
HRESULT CXo::contenumPostUploadContinue(
			XONLINETASK_HANDLE	hTask
			)
{
	HRESULT								hr;
	PXONLINETASK_OFFERING_ENUM			pcontenum;
	PXONLINEOFFERING_ENUM_SERVER		penum;
	PXONLINEOFFERING_ENUM_RESP_HEADER	pHeader;

	// We can make very tight assumptions and validate here
	Assert(hTask != NULL);

	// hTask points to the xontaskPostUpload field of XONLINEOFFERING_ENUM_SERVER,
	// find the containing XONLINEOFFERING_ENUM_SERVER structure
	penum = CONTAINING_RECORD(hTask, XONLINEOFFERING_ENUM_SERVER, xontaskPostUpload);
	pcontenum = CONTAINING_RECORD(penum, XONLINETASK_OFFERING_ENUM, enumdata);

	// Just skip this if the HTTP response is a failure
	if (XONLINEUPLOAD_EXSTATUS_ANYERROR(
				penum->xrlasyncext.xrlasync.dwExtendedStatus))
	{
		return(penum->xrlasyncext.xrlasync.hrXErr);
	}
	else
	{
		// Parse and validate the enumeration data here; this 
		// handles the case where there are no results.
		hr = ParseEnumerationResults(pcontenum);
		if (FAILED(hr))
			return(hr);
	}

	return(XONLINETASK_S_SUCCESS);
}				

//
// Function to kick off an enumeration request given an
// XONLINETASK_CONTENT_ENUM structure that is filled in.
//
HRESULT CXo::InitiateEnumerationRequest(
			PXONLINEOFFERING_ENUM_SERVER	penum,
			PBYTE							pbBuffer,
			DWORD							cbBuffer,
			HANDLE							hWorkEvent
			)
{
	HRESULT						hr;
	PXRL_ASYNC_EXTENDED			pxrlasyncext;
	PXONLINETASK_CONTEXT		pxontaskPost;
	PXONLINETASK_CONTEXT		pxontaskEnum;
	PXONLINEOFFERING_ENUM_REQ	penumreq;
	XONLINE_SERVICE_INFO		serviceCatref;
	CHAR						szContentType[XONLINE_MAX_CONTENT_TYPE_SIZE];
	DWORD						cbContentType;

	pxrlasyncext = &(penum->xrlasyncext);
	pxontaskEnum = &(penum->xontaskEnum);
	pxontaskPost = &(penum->xontaskPostUpload);
	penumreq = &(penum->enumreq);


	// Set up enum task context
	TaskInitializeContext(pxontaskEnum);
	pxontaskEnum->hEventWorkAvailable = hWorkEvent;
	pxontaskEnum->pfnContinue = contenumContinue;
	pxontaskEnum->pfnClose    = (PFNXONLINE_TASK_CLOSE)contenumClose;

	// Set up the enumeration post-upload task context
	TaskInitializeContext(pxontaskPost);
	pxontaskPost->hEventWorkAvailable = hWorkEvent;
	pxontaskPost->pfnContinue = contenumPostUploadContinue;

	// Build the content type header
	cbContentType = sprintf(szContentType, 
				"Content-type: xon/%x\r\n", XONLINE_BILLING_OFFERING_SERVICE);
				
	// The enumeration is actually a POST request. Just call
	// UploadFromMemoryInternal
	hr = UploadFromMemoryInternal(
				XONLINE_BILLING_OFFERING_SERVICE,
				XONLINEOFFERING_ENUMERATE_XRL,
				pbBuffer,
				cbBuffer,
				(PBYTE)szContentType,
				cbContentType,
				(PBYTE)penumreq,
				penumreq->Header.cbSize,
				XONLINEOFFERING_ENUMERATE_TIMEOUT,
				hWorkEvent,
				pxrlasyncext);
	if (FAILED(hr))
		return(hr);

	// Minor pre-meditated hack: essentially, an enumeration request
	// is almost the same as a plain upload, except that we want to
	// install a post-upload task to parse and validate the results.
	// 
	// I didn't want to duplicate most of the code here, so I decided
	// to call UploadFromMemoryInternal, and add a post-upload
	// task here.
	pxrlasyncext->xrlasync.xrlext.ul.hTaskPostUpload = 
				(XONLINETASK_HANDLE)pxontaskPost;

	return(S_OK);
}

//
// Implement the do work function for enumeration
//
HRESULT CXo::contenumContinue(
			XONLINETASK_HANDLE	hTask
			)
{
	HRESULT							hr;
	PXONLINETASK_OFFERING_ENUM		pcontenum;
	PXONLINEOFFERING_ENUM_SERVER	penum;
	PXRL_ASYNC						pxrlasync;

	// We can make very tight assumptions and validate here
	Assert(hTask != NULL);

	pcontenum = (PXONLINETASK_OFFERING_ENUM)hTask;
	penum = &(pcontenum->enumdata.server);
	pxrlasync = &(penum->xrlasyncext.xrlasync);

	switch (penum->State)
	{
	case enumsrvUpload:

		// We are in the middle of an upload, let's pump the upload task
		hr = XOnlineTaskContinue(
					(XONLINETASK_HANDLE)&(penum->xrlasyncext));
		if (XONLINETASK_STATUS_AVAILABLE(hr))
		{
			// If we hit a hard failure, then just abort
			if (FAILED(hr))
				goto Exception;
		
			// See if the upload succeeded
			if (XONLINETASK_STATUS_SUCCESSFUL_COMPLETION(hr))
			{
				// Yes, this upload succeeded. If the fPartial flag is
				// set (by contenumPostUploadContinue), then we know we have 
				// more results and might have to post another upload to 
				// get them. If not, then we are done
				if (!pcontenum->fPartial)
					goto Done;

				// Set next state to enumsrvResults phase and return 
				// special exception code. We will stay in this phase 
				// until the title calls XOnlineOfferingEnumerateGetResults.
				penum->State = enumsrvResults;
				hr = XONLINETASK_S_RESULTS_AVAIL;
				goto Exception;
			}

			// XRL stuff should not return any intermediate exceptions.
			// Just to be safe we will Assert if we get here
			AssertSz(FALSE, "contenumContinue: unexpected XRL result");
		}
		break;

	case enumsrvResults:

		// We will not get out of this state until the caller calls 
		// XOnlineOfferingEnumerateGetResults.
		hr = XONLINETASK_S_RESULTS_AVAIL;
		goto Exception;

	case enumsrvContinue:

		// We have more results to gather. Kick off another upload
		// Place the last encountered offering ID in the resume slot
		penum->enumreq.ResumePosition = penum->OfferingIdLast;

		pcontenum->fPartial = FALSE;

		// Initiate the enumeration request
		hr = InitiateEnumerationRequest(
					penum, 
					pxrlasync->pBuffer, 
					pxrlasync->cbBuffer, 
					pxrlasync->xontask.hEventWorkAvailable);
		if (FAILED(hr))
			goto Exception;

		// Set the state back to upload
		penum->State = enumsrvUpload;
		goto Exit;

	case enumsrvDone:
		goto Done;

	default:
		AssertSz(FALSE, "contdlContinue: invalid state!");
		hr = E_FAIL;
		goto Exception;
	}

Exit:	
	return(XONLINETASK_S_RUNNING);

Done:
	return(XONLINETASK_S_SUCCESS);

Exception:
	return(hr);
}				

//
// Implement the close function for enumeration
//
HRESULT CXo::contenumClose(
			XONLINETASK_HANDLE	hTask
			)
{
	PXONLINETASK_OFFERING_ENUM		pcontenum;
	PXONLINEOFFERING_ENUM_SERVER	penum;

	// We can make very tight assumptions and validate here
	Assert(hTask != NULL);

	pcontenum = (PXONLINETASK_OFFERING_ENUM)hTask;
	penum = &(pcontenum->enumdata.server);
	
	// The upload task controls all resources, so turn around and
	// close the upload task, then free ourself
	XRL_CleanupHandler(&(penum->xrlasyncext.xrlasync));
	SysFree(hTask);
	
	return(S_OK);
}

HRESULT CXo::ContentEnumerateServerBegin(
			DWORD							dwTitleId,
			DWORD							dwUserIndex,
			PXONLINEOFFERING_ENUM_PARAMS	pEnumParams,
			PBYTE							pbBuffer,
			DWORD							cbBuffer,
			HANDLE							hWorkEvent,
			PXONLINETASK_OFFERING_ENUM		pcontenum
			)
{
	HRESULT							hr = S_OK;
	PXONLINE_USER					pUsers;
	PXONLINEOFFERING_ENUM_SERVER	penum;
	PXONLINEOFFERING_ENUM_REQ		penumreq;

	Assert(pcontenum != NULL);
	Assert(pbBuffer != NULL);
	Assert(pEnumParams != NULL);
        Assert(dwUserIndex < XONLINE_MAX_LOGON_USERS);

	// Get the server enumeration data context
	penum = &(pcontenum->enumdata.server);
	penumreq = &(penum->enumreq);


	// Set up the enumeration request message
	penumreq->Header.cbSize = sizeof(XONLINEOFFERING_ENUM_REQ);
	penumreq->Header.dwReserved = 0;

	penumreq->dwTitleId = dwTitleId;
	penumreq->cbClientBuffer = cbBuffer;
	penumreq->dwRating = XGetParentalControlSetting();
	penumreq->ResumePosition = 0;	// Begin new enumeration

	// Get the PUID
	pUsers = XOnlineGetLogonUsers();
	if (pUsers)
	{
		penumreq->Puid = pUsers[dwUserIndex].xuid.qwUserID;

		// Make sure the user is not a guest
		if (XOnlineIsUserGuest(pUsers[dwUserIndex].xuid.dwUserFlags))
		{
			hr = XONLINE_E_NO_GUEST_ACCESS;
			goto Exit;
		}
	}
	else
		penumreq->Puid = 0;

	// Copy the enum params over
	memcpy(&(penumreq->Params), pEnumParams, sizeof(XONLINEOFFERING_ENUM_PARAMS));
	
	// Initiate the enumeration request
	hr = InitiateEnumerationRequest(penum, pbBuffer, cbBuffer, hWorkEvent);

Exit:	
	return(hr);
}

//
// Implement the OnData do work function for Local enumeration 
//
HRESULT CXo::ContentEnumerateLocalContinue(
			XONLINETASK_HANDLE	hTask
			)
{
	PXONLINETASK_OFFERING_ENUM	pcontenum;
	PXONLINEOFFERING_ENUM_LOCAL	plocalenum;
	PXONLINEOFFERING_INFO		*rgInfoSlot;
	PXONLINEOFFERING_INFO		pInfo;

	// We can make very tight assumptions and validate here
	Assert(hTask != NULL);

	// hTask points to the xontaskPostUpload field of XONLINECONTENT_ENUM_HD,
	// find the containing XONLINECONTENT_ENUM_HD structure
	plocalenum = CONTAINING_RECORD(hTask, XONLINEOFFERING_ENUM_LOCAL, xontask);
	pcontenum = CONTAINING_RECORD(plocalenum, XONLINETASK_OFFERING_ENUM, enumdata);

	// If we are continuing to a new set of records, reset the counter
	if (pcontenum->fPartial)
	{
		pcontenum->fPartial = FALSE;
		pcontenum->dwResults = 0;
	}

	rgInfoSlot = (PXONLINEOFFERING_INFO *)(pcontenum + 1);
	pInfo = ((PXONLINEOFFERING_INFO)plocalenum->pbBuffer) + pcontenum->dwResults;
	ZeroMemory(pInfo, sizeof(XONLINEOFFERING_INFO));

	// Make sure this is a valid content directory name
	if (SUCCEEDED(ParseContentDirName(plocalenum->szPath, 
					&(pInfo->OfferingId), &(pInfo->dwBitFlags))))
	{
		// Now apply the bit filter to see if this is a match
		if ((!plocalenum->dwBitFilter) ||
			((plocalenum->dwBitFilter & pInfo->dwBitFlags) != 0))
		{
			// This one's a match, so save it
			rgInfoSlot[pcontenum->dwResults++] = pInfo;

			// See if we have reached our capacity yet
			if ((pcontenum->dwResults >= pcontenum->dwMaxResults) ||
				(((pcontenum->dwResults + 1) * sizeof(XONLINEOFFERING_INFO)) > plocalenum->cbBuffer))
			{
				// Indicate a set of partial results is available to the caller
				pcontenum->fPartial = TRUE;
				goto ResultsAvail;
			}
		}
	}
	
	return(XONLINETASK_S_SUCCESS);

ResultsAvail:	
	return(XONLINETASK_S_RESULTS_AVAIL);
}	

//
// Implement the OnDone handler for Local enumeration 
//
HRESULT CXo::ContentEnumerateLocalDone(
			XONLINETASK_HANDLE	hTask
			)
{
	PXONLINETASK_OFFERING_ENUM	pcontenum;
	PXONLINEOFFERING_ENUM_LOCAL	plocalenum;

	Assert(hTask != NULL);

	// hTask points to the xontaskPostUpload field of XONLINECONTENT_ENUM_HD,
	// find the containing XONLINECONTENT_ENUM_HD structure
	plocalenum = CONTAINING_RECORD(hTask, XONLINEOFFERING_ENUM_LOCAL, xontaskDone);
	pcontenum = CONTAINING_RECORD(plocalenum, XONLINETASK_OFFERING_ENUM, enumdata);

	// If we are continuing to a new set of records, reset the counter
	if (pcontenum->fPartial)
	{
		pcontenum->fPartial = FALSE;
		pcontenum->dwResults = 0;
	}

	// This task must return success immediately
	return(XONLINETASK_S_SUCCESS);
}

HRESULT CXo::ContentEnumerateLocalBegin(
			PSTR							szRootPath,
			PXONLINEOFFERING_ENUM_PARAMS	pEnumParams,
			PBYTE							pbBuffer,
			DWORD							cbBuffer,
			HANDLE							hWorkEvent,
			PXONLINETASK_OFFERING_ENUM		pcontenum
			)
{
	HRESULT						hr = S_OK;
	PXONLINEOFFERING_ENUM_LOCAL	plocalenum;
	DWORD						cbPath;
	PSTR						szPath;

	// There's a minimum buffer requirement here
	Assert(pcontenum != NULL);
	Assert(pEnumParams != NULL);
    Assert(cbBuffer >= (sizeof(XONLINEOFFERING_INFO) + XBOX_HD_SECTOR_SIZE));

	// Set up the specific search path for titles
	cbPath = strlen(szRootPath);
	if (cbPath >= XONLINECONTENT_MAX_PATH)
	{
		hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
		goto Exit;
	}
	
	// Initialize plocalenum
	plocalenum = &(pcontenum->enumdata.local);
	szPath = plocalenum->szPath;
	strcpy(szPath, szRootPath);
	plocalenum->pbBuffer = pbBuffer;
	plocalenum->cbBuffer = cbBuffer;
	plocalenum->dwBitFilter = pEnumParams->dwBitFilter;

	// Initialize the OnData task
	TaskInitializeContext(&plocalenum->xontask);
	plocalenum->xontask.pfnContinue = ContentEnumerateLocalContinue;
	plocalenum->xontask.hEventWorkAvailable = hWorkEvent;

	// Initialize the OnDone task
	TaskInitializeContext(&plocalenum->xontaskDone);
	plocalenum->xontaskDone.pfnContinue = ContentEnumerateLocalDone;
	plocalenum->xontaskDone.hEventWorkAvailable = hWorkEvent;

	if (hWorkEvent)
		SetEvent(hWorkEvent);

	// Kick off the directory enumeration
	hr = EnumerateDirectoryInitializeContext(
				szPath,
				cbPath,
				XONLINECONTENT_MAX_PATH-1,
				XONLINETASK_EDFLAG_ENUMERATE_DIRS,
				(XONLINETASK_HANDLE)&(plocalenum->xontask),
				(XONLINETASK_HANDLE)&(plocalenum->xontaskDone),
				hWorkEvent, 
				&(plocalenum->dirops));
	if (FAILED(hr))
		goto Exit;

Exit:
	return(hr);
}

HRESULT 
CXo::XOnlineOfferingEnumerate(
			XONLINEOFFERING_ENUM_DEVICE		edDevice,
			DWORD							dwUserIndex,
			PXONLINEOFFERING_ENUM_PARAMS	pEnumParams,
			PBYTE							pbBuffer,
			DWORD							cbBuffer,
			HANDLE							hWorkEvent,
			XONLINETASK_HANDLE				*phTask
			)
{
    XoEnter("XOnlineOfferingEnumerate");
    XoCheck(edDevice < XONLINEOFFERING_ENUM_DEVICE_MAX);
	XoCheck(pEnumParams != NULL);
	XoCheck(cbBuffer != 0);
	XoCheck(phTask != NULL);

	HRESULT						hr = S_OK;
	DWORD						cbResultVector;
	PXONLINETASK_OFFERING_ENUM	pcontenum;
	CHAR						szTemp[XONLINECONTENT_MAX_PATH];

	// We are responsible for allocating the context and the work buffer
	// The work buffer are the specified bytes immediately following the
	// context structure
	cbResultVector = sizeof(PXONLINEOFFERING_INFO *) * pEnumParams->dwMaxResults;
	pcontenum = (PXONLINETASK_OFFERING_ENUM)SysAlloc(sizeof(XONLINETASK_OFFERING_ENUM) +
        cbResultVector + (pbBuffer?0:cbBuffer), PTAG_XONLINETASK_OFFERING_ENUM);
	if (!pcontenum)
	{
		hr = E_OUTOFMEMORY;
		goto Error;
	}

	// Initialize the context
	ZeroMemory(pcontenum, sizeof(XONLINETASK_OFFERING_ENUM));
	
	// Set up the buffer 
	if (!pbBuffer)
		pbBuffer = (PBYTE)(pcontenum + 1) + cbResultVector;

	// Save the device type for later
	pcontenum->edDevice = edDevice;
	pcontenum->fPartial = FALSE;
	pcontenum->dwResults = 0;
	pcontenum->dwMaxResults = pEnumParams->dwMaxResults;

	// This essentially finds out what kind of enumeration is requested
	// and calls the appropriate function
	switch (edDevice)
	{
	case XONLINEOFFERING_ENUM_DEVICE_ONLINE:
		hr = ContentEnumerateServerBegin(
					m_dwTitleId,
					dwUserIndex,
					pEnumParams,
					pbBuffer, 
					cbBuffer, 
					hWorkEvent,
					pcontenum);
		break;

	case XONLINEOFFERING_ENUM_DEVICE_HD:
		hr = ContentEnumerateLocalBegin(
					XONLINECONTENT_HD_SEARCH_PATH,
					pEnumParams,
					pbBuffer, 
					cbBuffer, 
					hWorkEvent,
					pcontenum);
		break;

	case XONLINEOFFERING_ENUM_DEVICE_DVD:
		sprintf(szTemp, XONLINECONTENT_DVD_SEARCH_PATH, m_dwTitleId);
		hr = ContentEnumerateLocalBegin(
					szTemp,
					pEnumParams,
					pbBuffer, 
					cbBuffer, 
					hWorkEvent,
					pcontenum);
		break;

	default:
		AssertSz(FALSE, "XOnlineOfferingEnumerate: Invalid device!");
		hr = E_INVALIDARG;
	}

	if (FAILED(hr))
		goto Error;

	// OK< now return the context as the task handle
	*phTask = (XONLINETASK_HANDLE)pcontenum;

Cleanup:	
	return(XoLeave(hr));

Error:
	if (pcontenum)
		SysFree(pcontenum);
	goto Cleanup;
}

HRESULT 
CXo::XOnlineOfferingEnumerateGetResults(
			XONLINETASK_HANDLE		hTask,
		    PXONLINEOFFERING_INFO	**prgpOfferingInfo,
		    DWORD					*pdwReturnedResults,
		    BOOL					*pfMoreResults
		    )
{
    XoEnter("XOnlineOfferingEnumerateGetResults");
    XoCheck(hTask != NULL);

	HRESULT						hr;
	PXONLINETASK_OFFERING_ENUM	pcontenum;

	pcontenum = (PXONLINETASK_OFFERING_ENUM)hTask;
	if (prgpOfferingInfo)
		*prgpOfferingInfo = (PXONLINEOFFERING_INFO *)(pcontenum + 1);
	if (pdwReturnedResults)
		*pdwReturnedResults = pcontenum->dwResults;
	if (pfMoreResults)
		*pfMoreResults = pcontenum->fPartial;

	// Let's clear the results so that the caller can get the next batch
	if (pcontenum->edDevice == XONLINEOFFERING_ENUM_DEVICE_ONLINE)
		pcontenum->enumdata.server.State = enumsrvContinue;

	return(XoLeave(S_OK));
}

DWORD CXo::XOnlineOfferingEnumerateMaxSize(
    		PXONLINEOFFERING_ENUM_PARAMS	pEnumParams,
		    DWORD							cbTitleSpecificDataMaxSize
			)
{
    XoEnter_("XOnlineOfferingEnumerateMaxSize", 0);
    XoCheck_(pEnumParams != NULL, 0);

	// Need a little bit of fluff for hrad-disk enum because of 
	// non-buffered reads
	if (!cbTitleSpecificDataMaxSize)
		cbTitleSpecificDataMaxSize = XONLINEOFFERING_ENUM_MAX_TITLE_DATA_SIZE;

	cbTitleSpecificDataMaxSize += sizeof(XONLINEOFFERING_ENUM_RESP_RECORD);
	return((pEnumParams->dwMaxResults * cbTitleSpecificDataMaxSize) + XBOX_HD_SECTOR_SIZE);
}

// =================================================================
// Title enumeration stuff
//

HRESULT CXo::EnumerateTitlesContinue(
			XONLINETASK_HANDLE	hTask
			)
{
	HRESULT	hr = XONLINETASK_S_SUCCESS;
	PXONLINECONTENT_ENUM_TITLES ptitleenum;
	PXONLINETASK_DIROPS			pdirops;

	Assert(hTask != NULL);

	// The the containing record
	ptitleenum = CONTAINING_RECORD(hTask, XONLINECONTENT_ENUM_TITLES, xontask);
	pdirops = &(ptitleenum->dirops);

	if (SUCCEEDED(ConvertToTitleId(pdirops->szPath, 
				ptitleenum->rgdwTitleId + ptitleenum->dwTitleId)))
	{
		// This one,s a real title ID, so save it
		ptitleenum->dwTitleId += 1;

		// See if we have reached our capacity yet
		if (ptitleenum->dwTitleId >= ptitleenum->dwMaxResults)
		{
			// Yeah, pause the operation so the caller can get this
			// batch of results
			hr = XONLINETASK_S_RESULTS_AVAIL;
		}
	}

	return(hr);
}

HRESULT
CXo::XOnlineEnumerateTitlesBegin(
			DWORD dwMaxResults,
			OPTIONAL HANDLE hWorkEvent,
			XONLINETASK_HANDLE *phTask
			)
{
    XoEnter("XOnlineEnumerateTitlesBegin");
    XoCheck(dwMaxResults != 0);

	HRESULT						hr = S_OK;
	PXONLINECONTENT_ENUM_TITLES ptitleenum;
	DWORD						cbPath;
	PSTR						szPath;
	
	// Allocate structure plus space to hold the specified number of title IDs.
	ptitleenum = (PXONLINECONTENT_ENUM_TITLES)SysAlloc(sizeof(XONLINECONTENT_ENUM_TITLES) + 
        (dwMaxResults * sizeof(DWORD)) + XONLINECONTENT_MAX_PATH, PTAG_XONLINECONTENT_ENUM_TITLES);

	if (!ptitleenum)
	{
		hr = E_OUTOFMEMORY;
		goto Error;
	}

	// Initialize ptitleenum
	ZeroMemory(ptitleenum, sizeof(XONLINECONTENT_ENUM_TITLES));
	ptitleenum->rgdwTitleId = (DWORD *)(ptitleenum + 1);
	ptitleenum->dwTitleId = 0;
	ptitleenum->dwMaxResults = dwMaxResults;

	// Initialize the OnData task
	TaskInitializeContext(&ptitleenum->xontask);
	ptitleenum->xontask.pfnContinue = EnumerateTitlesContinue;
	ptitleenum->xontask.hEventWorkAvailable = hWorkEvent;
	if (hWorkEvent)
		SetEvent(hWorkEvent);

	// Set up the specific search path for titles
	szPath = (PSTR)(ptitleenum->rgdwTitleId + dwMaxResults);
	strcpy(szPath, XONLINECONTENT_TITLES_SEARCH_PATH);
	cbPath = strlen(szPath);

	// Kick off the directory enumeration
	hr = EnumerateDirectoryInitializeContext(
				szPath,
				cbPath,
				XONLINECONTENT_MAX_PATH-1,
				XONLINETASK_EDFLAG_ENUMERATE_DIRS,
				(XONLINETASK_HANDLE)&(ptitleenum->xontask),
				NULL,
				hWorkEvent, 
				&(ptitleenum->dirops));
	if (FAILED(hr))
		goto Error;

	// Return the task handle
	*phTask = (XONLINETASK_HANDLE)ptitleenum;

Exit:
	return(XoLeave(hr));

Error:
	// Abort the operation
	if (ptitleenum)
		SysFree(ptitleenum);
		
	goto Exit;
}

HRESULT 
CXo::XOnlineEnumerateTitlesContinue(
			XONLINETASK_HANDLE hTask
			)
{
    XoEnter("XOnlineEnumerateTitlesContinue");
    XoCheck(hTask != NULL);
    
	PXONLINECONTENT_ENUM_TITLES ptitleenum;

	ptitleenum = (PXONLINECONTENT_ENUM_TITLES)hTask;

	// Reset the counter and continue the enumeration
	ptitleenum->dwTitleId = 0;

	return(XoLeave(S_OK));
}	

HRESULT 
CXo::XOnlineEnumerateTitlesGetResults(
			XONLINETASK_HANDLE hTask,
			DWORD **prgTitleID,
			DWORD *pdwTitleID
			)
{
    XoEnter("XOnlineEnumerateTitlesGetResults");
    XoCheck(hTask != NULL);

	PXONLINECONTENT_ENUM_TITLES ptitleenum;

	ptitleenum = (PXONLINECONTENT_ENUM_TITLES)hTask;

	if (prgTitleID)
		*prgTitleID = ptitleenum->rgdwTitleId;
	if (pdwTitleID)
		*pdwTitleID = ptitleenum->dwTitleId;

	return(XoLeave(S_OK));
}

#if 0

/*
	This downloads all the headers for the current title into pBuffer. 	
*/

DWORD offset;

#define ADVANCE(buf, length, end) \
		{\
			Assert(buf != NULL); \
			if (buf + length > end) return E_BADNETWORKDATA; \
			buf += length; \
			offset += length; \
		}

#define ACCESS(pvar, buf, type, end) \
		{\
			pvar = (type *)buf; \
			ADVANCE(buf, sizeof(type), end); \
		}
			

HRESULT CatalogDVD(
			PBYTE pbBuffer,
			DWORD cbBuffer,
			DWORD dwMaxResults,
			DWORD dwStart,
			XONLINETASK_HANDLE *phTask, 
			HANDLE hWorkEvent 
			)
{
	HRESULT hr;
	HANDLE hFile;
	ULARGE_INTEGER ul;

	cbBuffer -= (cbBuffer % XBOX_HD_SECTOR_SIZE); //make it fit to multiple of sector size

	
// Remarks:
// The file to read from must have been opened with FILE_FLAG_OVERLAPPED
// and FILE_FLAG_NO_BUFFERING. This also means that the following must be true:
// 1) the buffer must be DWORD aligned,
// 2) the starting offset of the read must be sector aligned (XBOX_HD_SECTOR_SIZE)
// 3) the number of bytes to read must be a multiple of XBOX_HD_SECTOR_SIZE.
//
	hFile = CreateFile(XONLINE_DVD_ENUM_FILE, GENERIC_READ, FILE_SHARE_READ, NULL,
						OPEN_EXISTING, FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING, NULL);

	if (INVALID_HANDLE_VALUE == hFile)
		return HRESULT_FROM_WIN32(GetLastError());


	ul.QuadPart = 0;

	hr = ReadFile(hFile, pbBuffer, cbBuffer, ul, hWorkEvent, phTask);

	return hr;
}
							 
//
// Main do work function
//
HRESULT EnumerateTitlesWork(
			XONLINETASK_OP		op,
			XONLINETASK_HANDLE	hTask, 
			DWORD				dwUntilTickCount,
			DWORD				*pdwWorkFlags
			)
{
	HRESULT				hr = S_OK;
	WIN32_FIND_DATA		wfd;
	DWORD				dwError;

	LARGE_INTEGER lFreq, lStart, lNow, lMax;
	PXONLINETASK_HDENUM	phdenum;

	QueryPerformanceCounter(&lStart); //to init GoodTime
	QueryPerformanceFrequency(&lFreq);

	lMax.QuadPart = (dwUntilTickCount * lFreq.QuadPart / (__int64)1000000);

	phdenum = (PXONLINETASK_HDENUM)hTask;
	
	Assert(op < XONLINETASK_MAX_OP);
	Assert(hTask != NULL);

	// Reset the work flags
	XONLINETASK_WORKFLAGS_RESET(pdwWorkFlags);

	// Always signal the event. If we actually do any async work, we 
	// will reset the event. This makes sure we don't stall
	if (phdenum->xontask.hEventWorkAvailable)
		SetEvent(phdenum->xontask.hEventWorkAvailable);

	switch (op)
	{
	case XONLINETASK_DOWORK:

		//loop until out of time
		do
		{
			// get the next file
			if (phdenum->hFind == INVALID_HANDLE_VALUE)
			{
				phdenum->hFind = FindFirstFile(XONLINE_ENUMERATE_HD_DIR, &wfd);
				
				if (phdenum->hFind == INVALID_HANDLE_VALUE)
				{
					dwError = GetLastError();
					if ((dwError == ERROR_PATH_NOT_FOUND) ||
						(dwError == ERROR_FILE_NOT_FOUND))
					{
						// No files are found. that's cool - just means no results
						EnumerateTitlesCleanup(phdenum);
						XONLINETASK_WORKFLAGS_SET_DONT_CONTINUE(pdwWorkFlags);
						//don't free task just yet - need data to work
						goto Exit; 
					}

					hr = HRESULT_FROM_WIN32(dwError);
					goto Error;
				}
			}
			else
			{
				if (!FindNextFile(phdenum->hFind, &wfd))
				{
					//no more files....buwahahaha - end of function
					EnumerateTitlesCleanup(phdenum);
					XONLINETASK_WORKFLAGS_SET_DONT_CONTINUE(pdwWorkFlags);
					//don't free task just yet - need data to work
					goto Exit; 
				}
			}

			//add directory
			if (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
			{
				phdenum->rgTitleID[phdenum->iCurrent++] = atoi(wfd.cFileName);
				if (phdenum->iCurrent >= phdenum->cTitleID)
				{
					//got max results
					EnumerateTitlesCleanup(phdenum);
					XONLINETASK_WORKFLAGS_SET_DONT_CONTINUE(pdwWorkFlags);
					//don't free task just yet - need data to work
					goto Exit; 
				}
			}

			QueryPerformanceCounter(&lNow);

		} while (lNow.QuadPart - lStart.QuadPart < lMax.QuadPart);

		break;
		
	case XONLINETASK_CANCEL:
		hr = E_ABORT;
		EnumerateTitlesCleanup(phdenum);
		XONLINETASK_WORKFLAGS_SET_DONT_CONTINUE(pdwWorkFlags);
		break;
	
	case XONLINETASK_RELEASE:
		EnumerateTitlesCleanup(phdenum);
		SysFree(phdenum);
		XONLINETASK_WORKFLAGS_SET_DONT_CONTINUE(pdwWorkFlags);
		break;
		
	default:
		AssertSz(FALSE, "EnumerateTitlesWork: Bad OP");
		hr = E_NOTIMPL;
	}

Exit:
	return(S_OK);

Error:
	// Error, abort the task.
	XONLINETASK_WORKFLAGS_SET_DONT_CONTINUE(pdwWorkFlags);
	return(hr);
}



//
// Cleanup function
//
VOID EnumerateTitlesCleanup(
			PXONLINETASK_HDENUM phdenum
			)
{
	if (phdenum->hFind != INVALID_HANDLE_VALUE)
	{
		CloseHandle(phdenum->hFind);
		phdenum->hFind = INVALID_HANDLE_VALUE;
	}
}

//
// Implement the OnData do work function for HD enumeration 
//
HRESULT ContentEnumerateHDContinue(
			XONLINETASK_HANDLE	hTask, 
			DWORD				dwUntilTickCount
			)
{
	HRESULT						hr = S_OK;
	PXONLINETASK_CONTENT_ENUM	pcontenum;
	PXONLINECONTENT_ENUM_HD		phdenum;
	PXON_CATREF_ENUM_REC_HDR	prechdr;
	PXONLINETASK_FILEIO			pfileio;
	PXONLINECATALOG				*rgCatalogSlot;
	PXONLINECATALOG				pcatalog;
	ULARGE_INTEGER				uliOrigin;
	DWORD						dwWorkFlags;
	DWORD						cbPath;
	DWORD						dwSize;
	PBYTE						pbBuffer;
	PSTR						szPath;

	// We can make very tight assumptions and validate here
	Assert(hTask != NULL);

	XONLINETASK_WORKFLAGS_RESET(pdwWorkFlags);

	// Only service do work
	if (op == XONLINETASK_DOWORK)
	{
		// hTask points to the xontaskPostUpload field of XONLINECONTENT_ENUM_HD,
		// find the containing XONLINECONTENT_ENUM_HD structure
		phdenum = CONTAINING_RECORD(hTask, XONLINECONTENT_ENUM_HD, xontask);
		pcontenum = CONTAINING_RECORD(penum, XONLINETASK_CONTENT_ENUM, enumdata);
		pfileio = &(phdenum->fileio);

		// There are two states here: open file and kick of async read; and 
		// parse read results and close file. This is switched through the
		// hFile value. This means it is very important to make sure the file
		// is properly closed and set back to INVALID_HANDLE_VALUE every time
		// immediately after use.
		if (pfileio->hFile == INVALID_HANDLE_VALUE)
		{
			szPath = phdenum->szPath;
			// Yup, new directory entry found. Validate the directory name and
			// attempt to open the metadata file.
			hr = ConvertToLowerContentId(szPath, &(phdenum->ContentId));
			if (FAILED(hr))
				goto Done;

			// Build the file path in-place
			cbPath = strlen(szPath);
			szPath[cbPath++] = '\\';
			strcpy(szPath + cbPath, XONLINECONTENT_MANIFEST_FILE_NAME);
			cbPath += strlen(XONLINECONTENT_MANIFEST_FILE_NAME);
			dwSize = strlen(XONLINECONTENT_HD_ROOT_PATH);
			memmove(szPath + dwSize, szPath, cbPath + 1);
			memcpy(szPath, XONLINECONTENT_HD_ROOT_PATH, dwSize);

			// Open the file, skip it if it can't be opened
			pfileio->hFile = CreateFile(
						szPath,
						GENERIC_READ,
						FILE_SHARE_READ,
						NULL,
						OPEN_EXISTING,
						FILE_FLAG_OVERLAPPED | 
						FILE_FLAG_NO_BUFFERING |
						FILE_FLAG_SEQUENTIAL_SCAN,
						NULL);
			if (pfileio->hFile == INVALID_HANDLE_VALUE)
				goto Done;

			// Make sure our read buffer is DWORD-aligned
			dwSize = pfileio->pbBuffer & (sizeof(DWORD) - 1);
			if (dwSize)
			{
				dwSize = sizeof(DWORD) - dwSize;
				pfileio->pbBuffer += dwSize;
				pfileio->cbBuffer -= dwSize;
			}

			// Make sure buffer size if sector-aligned
			dwSize = pfileio->cbBuffer & ~(XBOX_HD_SECTOR_SIZE - 1);
			if (dwSize == 0)
			{
				// Not enough buffer to read, so we are actually done
				// with the current batch. We will close the file so that
				// the next continuation will retry this item. This is
				// not optimal because we will try to call CreateFile
				// twice, but this helps us keep the directory enumeration
				// framework much cleaner.
				XONLINETASK_WORKFLAGS_SET_PARTIAL_RESULTS(pdwWorkFlags);
				pcontenum->fPartial = TRUE;
				hr = S_FALSE;
				goto Cleanup;
			}

			// Now kick off a read to load its contents
			uliOrigin.QuadPart = 0;
			ReadWriteFileInitializeContext(pfileio->hFile,
						pfileio->pbBuffer, dwSize, uliOrigin, 
						phdenum->xontask.hEventWorkAvailable, 
						pfileio);

			hr = ReadFileInternal(pfileio);
			if (FAILED(hr))
				goto Error;
		}
		else
		{
			// We will pump until the read returns
			hr = XOnlineTaskContinue((XONLINETASK_HANDLE)pfileio, 0, &dwWorkFlags);
			if (XONLINETASK_WORKFLAGS_CONTAINS_DONT_CONTINUE(dwWorkFlags))
			{
				// Skip this entry if the read had failed
				if (FAILED(hr))
					goto Done;

				// Get the read results
				hr = GetReadWriteFileResults(
							(XONLINETASK_HANDLE)pfileio, &dwSize, &pbBuffer);
				if (FAILED(hr))
					goto Done;

				// Validate and relocate the record, skip this record if failed
				prechdr = (PXON_CATREF_ENUM_REC_HDR)pbBuffer;
				pcatalog = &(prechdr->Catalog);
				
				hr = ValidateAndRelocateCatalogRecord(prechdr, dwSize);
				if (FAILED(hr))
					goto Done;

				// This is a good record, we actually add this to our result list
				rgCatalogSlot = (PXONLINECATALOG *)(pcontenum + 1);
				rgCatalogSlot[pcontenum->dwResults++] = pcatalog;

				// See if we reached the desired number of records yet
				if (pcontenum->dwResults == pcontenum->dwMaxResults)
				{
					XONLINETASK_WORKFLAGS_SET_PARTIAL_RESULTS(pdwWorkFlags);
					pcontenum->fPartial = TRUE;
					goto Cleanup;
				}

				// Done this directory item, move on to the next one
				goto Done;
			}
		}
	}

Exit:
	return(hr);

Done:	
	// Clear out the error and fall thru the error path
	hr = S_OK;

Cleanup:
Error:
	if (pfileio->hFile != INVALID_HANDLE_VALUE)
	{
		// Make sure the file is closed promptly
		CloseHandle(pfileio->hFile);
		pfileio->hFile = INVALID_HANDLE_VALUE;
	}
	
	// Set the don't continue flag to indicate we are done with this
	// directory
	XONLINETASK_WORKFLAGS_SET_DONT_CONTINUE(pdwWorkFlags);
	goto Exit;
}				


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\contrm.cpp ===
/*++

Copyright (c) Microsoft Corporation

Author:
    Keith Lau (keithlau)

Description:
	Module implementing content removal

Module Name:

    contrm.c

--*/

#include "xonp.h"
#include "xonver.h"

//#define CHK_CORRUPT
#ifdef CHK_CORRUPT

#define CHK_CORRUPT_SIZE		65536

VOID CXo::CheckCorruption(
			PXONLINETASK_CONTENT_REMOVE	pcontrm
			)
{
	PBYTE	pbEnd = (PBYTE)(pcontrm + 1);
	PDWORD	pdwGate;
	DWORD	dw;
	
	pbEnd += (XONLINECONTENT_MAX_PATH * 2);
	pdwGate = (PDWORD)pbEnd;
	
	for (dw = 0; dw < (CHK_CORRUPT_SIZE >> 2); dw++, pdwGate++)
		if (*pdwGate)
		{
			AssertSz(FALSE, "CORRUPT");
		}
}

#endif

#if DBG

const char * const CXo::s_rgszRemovePhases[rmphaseDone] =
{
	"rmphaseRemoveDrm",
	"rmphaseRemoveTitleData",
	"rmphaseRemoveUserData"
};

#endif

//
// Function to Delete the DRM file
//
HRESULT CXo::contrmRemoveDrm(
			PXONLINETASK_CONTENT_REMOVE	pcontrm
			)
{
	HRESULT				hr = S_OK;
	DWORD				dwError;
	PXONLINETASK_DIROPS	pdirops = &pcontrm->dirops;

	// Just plain delete the file and move on
	if (!DeleteFile(pdirops->szPath))
	{
		// We will proceed if the DRM file is not found. This
		// lets us to reclaim disk space for an incomplete 
		// content package
		dwError = GetLastError();
		if ((dwError != ERROR_FILE_NOT_FOUND) &&
			(dwError != ERROR_PATH_NOT_FOUND))
		{
			// Cannot remove DRM file
			hr = HRESULT_FROM_WIN32(dwError);
			goto Error;
		}
	}

	// Figure out the path to title content data
	pdirops->cbPath = pdirops->cbMax;
	hr = XOnlineContentGetRootDirectory(
				pcontrm->OfferingId, FALSE,	// fUserData
				&(pdirops->cbPath),
				pdirops->szPath);
	if (FAILED(hr))
		goto Error;
		
	// Set up the directory operation to recursively remove the
	// title content data for this package
	hr = RemoveDirectoryInitializeContext(
				pdirops->szPath, 
				pdirops->cbPath,
				pdirops->cbMax,
				pdirops->szDir,
				0,
				pcontrm->xontask.hEventWorkAvailable,
				pdirops);
	if (FAILED(hr))
		goto Error;

	// Next phase is to remove all title data
	pcontrm->rmphase = rmphaseRemoveTitleData;

Error:
	return(hr);
}

//
// Function to Delete all title content
//
HRESULT CXo::contrmRemoveTitleData(
			PXONLINETASK_CONTENT_REMOVE	pcontrm
			)
{
	HRESULT				hr = S_OK;
	PXONLINETASK_DIROPS	pdirops = &pcontrm->dirops;

	// Wait for the subtask to complete
	hr = XOnlineTaskContinue((XONLINETASK_HANDLE)pdirops);
	if (XONLINETASK_STATUS_AVAILABLE(hr))
	{
		// Returned results, see if it succeeded
		if (FAILED(hr))
			goto Error;

		// OK, all title data is deleted, now try to delete all
		// user content data
		pdirops->cbPath = pdirops->cbMax;
		hr = XOnlineContentGetRootDirectory(
					pcontrm->OfferingId, TRUE,	// fUserData
					&(pdirops->cbPath),
					pdirops->szPath);
		if (SUCCEEDED(hr))
		{
			// Set up the directory operation to recursively remove the
			// title content data for this package
			hr = RemoveDirectoryInitializeContext(
						pdirops->szPath, 
						pdirops->cbPath,
						pdirops->cbMax,
						pdirops->szDir,
						0,
						pcontrm->xontask.hEventWorkAvailable,
						pdirops);
			if (FAILED(hr))
				goto Error;

			// Next phase is to remove all title data
			pcontrm->rmphase = rmphaseRemoveUserData;
		}
		else
		{
			// No user data, we are done
			hr = S_OK;
			pcontrm->rmphase = rmphaseDone;
		}
	}
	
Error:
	return(hr);
}

//
// Function to Delete all user content
//
HRESULT CXo::contrmRemoveUserData(
			PXONLINETASK_CONTENT_REMOVE	pcontrm
			)
{
	HRESULT				hr = S_OK;
	PXONLINETASK_DIROPS	pdirops = &pcontrm->dirops;

	// Wait for the subtask to complete
	hr = XOnlineTaskContinue((XONLINETASK_HANDLE)pdirops);
	if (XONLINETASK_STATUS_AVAILABLE(hr))
	{
		// Returned results, see if it succeeded
		if (FAILED(hr))
			goto Error;

		// We're done.
		hr = S_OK;
		pcontrm->rmphase = rmphaseDone;
	}
	
Error:
	return(hr);
}

//
// Function to cleanup
//
HRESULT CXo::contrmCleanup(
			PXONLINETASK_CONTENT_REMOVE	pcontrm
			)
{
	HRESULT	hr = S_OK;

	// Make sure we cancel any directory operations
	if ((pcontrm->rmphase == rmphaseRemoveTitleData) ||
		(pcontrm->rmphase == rmphaseRemoveUserData))
	{
		DiropsCleanup(&pcontrm->dirops);
	}
	return(hr);
}

//
// Implement the do work function for XOnlineContentRemove
//

HRESULT CXo::contrmContinue(
			XONLINETASK_HANDLE	hTask
			)
{
	HRESULT						hr = S_OK;
	PXONLINETASK_CONTENT_REMOVE	pcontrm = NULL;
	PXONLINETASK_DIROPS			pdirops = NULL;

#if DBG
	LARGE_INTEGER				liTimerTotal;
	LARGE_INTEGER				liTimerEnd;
	LARGE_INTEGER				liTimerStart;
	XONLINECONTENT_RMPHASE		rmphase;

	// Track service count
	m_lirmServiceCount.QuadPart += 1;

	// Start the total timer
	QueryPerformanceCounter(&liTimerTotal);
#endif

	Assert(hTask != NULL);

	// hTask points to the xontask field of XONLINETASK_CONTENT_REMOVE,
	// find the containing pcontrm structure
	pcontrm = CONTAINING_RECORD(hTask, XONLINETASK_CONTENT_REMOVE, xontask);
	pdirops = &pcontrm->dirops;

	// Make sure the event is always signalled
	if (pcontrm->xontask.hEventWorkAvailable != NULL)
		SetEvent(pcontrm->xontask.hEventWorkAvailable);

#ifdef CHK_CORRUPT
	CheckCorruption(pcontrm);
#endif

#if DBG
	// Start the loop timer
	QueryPerformanceCounter(&liTimerStart);
	rmphase = pcontrm->rmphase;
#endif

	// Figure out what phase we are in ...
	switch (pcontrm->rmphase)
	{
	case rmphaseRemoveDrm:
		hr = contrmRemoveDrm(pcontrm);
		break;
		
	case rmphaseRemoveTitleData:
		hr = contrmRemoveTitleData(pcontrm);
		break;
		
	case rmphaseRemoveUserData:
		hr = contrmRemoveUserData(pcontrm);
		break;
		
	default:
		// This is a bad state. We force it to end so we don't get stuck
		// here forever.
		AssertSz(FALSE, "contrmContinue: invalid phase!");
		hr = E_FAIL;
	}

#if DBG	
	// Stop timer
	QueryPerformanceCounter(&liTimerEnd);

    m_lirmTotalTime.QuadPart += (liTimerEnd.QuadPart - liTimerStart.QuadPart);
	m_lirmAverageTime.QuadPart = m_lirmTotalTime.QuadPart / m_lirmServiceCount.QuadPart;

//	TraceSz3(Verbose, "%s, %I64u us", s_rgszRemovePhases[rmphase], (liTimerEnd.QuadPart - liTimerStart.QuadPart));
	
#endif	

	// Bail if failed.
	if (FAILED(hr))
	{
		contrmCleanup(pcontrm);
		pcontrm->rmphase = rmphaseDone;
	}

	// When the next state is the final state, we set the flag so we don't
	// continue.
	if (pcontrm->rmphase == rmphaseDone)
	{
		// Indicate that we are done and return the final code
		XONLINETASK_SET_COMPLETION_STATUS(hr);

#if DBG
		TraceSz1(Verbose, "%I64u services elapsed", m_lirmServiceCount.QuadPart);
		TraceSz1(Verbose, "Total time: %I64u ticks", m_lirmTotalTime.QuadPart);
		TraceSz1(Verbose, "Average service time: %I64u ticks", m_lirmAverageTime.QuadPart);
		m_lirmServiceCount.QuadPart = 0;
		m_lirmTotalTime.QuadPart = 0;
		m_lirmAverageTime.QuadPart = 0;
#endif		
	}

#ifdef CHK_CORRUPT
	CheckCorruption(pcontrm);
#endif

	return(hr);
}				

//
// Function to close the task handle
//
VOID CXo::contrmClose(
			XONLINETASK_HANDLE	hTask
			)
{			
	PXONLINETASK_CONTENT_REMOVE	pcontrm = (PXONLINETASK_CONTENT_REMOVE)hTask;
	
	contrmCleanup(pcontrm);
	SysFree(pcontrm);
}

//
// Function to kick off the removal of a content package. This is 
// the internal/Dash version because it allows a Title ID to be 
// specified.
//
HRESULT CXo::ContentRemoveInternal(
			DWORD					dwTitleId,
			XONLINEOFFERING_ID		OfferingId,
			DWORD					dwFlags,
			HANDLE					hWorkEvent,
			XONLINETASK_HANDLE		*phTask
			)
{
	HRESULT						hr = S_OK;
	PXONLINETASK_CONTENT_REMOVE pcontrm = NULL;
	PXONLINETASK_DIROPS			pdirops = NULL;
	PBYTE						pbPath = NULL;
	PBYTE						pbDir = NULL;
	DWORD						cbSize;

    Assert(NULL != phTask);

	// We are responsible for allocating the context and any other
	// buffers. These buffers immediately follow the context structure
	cbSize = sizeof(XONLINETASK_CONTENT_REMOVE) + (XONLINECONTENT_MAX_PATH * 2);
	
#ifdef CHK_CORRUPT	
	cbSize += CHK_CORRUPT_SIZE;
#endif

	pcontrm = (PXONLINETASK_CONTENT_REMOVE)SysAlloc(cbSize, PTAG_XONLINETASK_CONTENT_REMOVE);
	if (!pcontrm)
	{
		hr = E_OUTOFMEMORY;
		goto Error;
	}

	ZeroMemory(pcontrm, cbSize);
	pdirops = &pcontrm->dirops;
	pbPath = (PBYTE)(pcontrm + 1);
	pbDir = pbPath + XONLINECONTENT_MAX_PATH;

	// Fill in the blanks
	TaskInitializeContext(&pcontrm->xontask);
	pcontrm->xontask.hEventWorkAvailable = hWorkEvent;
	pcontrm->xontask.pfnContinue = contrmContinue;
	pcontrm->xontask.pfnClose = contrmClose;
	pcontrm->rmphase = rmphaseRemoveDrm;
	pcontrm->dwFlags = dwFlags;
	pcontrm->dwTitleId = dwTitleId;
	pcontrm->OfferingId = OfferingId;

	// Build the path to the DRM file, it must be in the
	// title data area
	cbSize = XONLINECONTENT_MAX_PATH;
	hr = BuildExistingContentPath(
				dwTitleId, OfferingId, 
				XONLINECONTENT_MANIFEST_FILE_NAME,
				dirtypeTitleContent,
				&cbSize, (PSTR)pbPath);
	if (FAILED(hr))
		goto Error;

	// Set up the dirops context
	pdirops->szPath = (PSTR)pbPath;
	pdirops->cbPath = cbSize;
	pdirops->szDir = (PSTR)pbDir;
	pdirops->cbMax = XONLINECONTENT_MAX_PATH;

	// We need to set the event here to signal more work is
	// immediately required
	if ((hWorkEvent != NULL) && (SetEvent(hWorkEvent) == FALSE))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Error;
	}

	// Return the context as an opaque handle
	*phTask = (XONLINETASK_HANDLE)pcontrm;

Cleanup:	
	return(hr);

Error:

	// Failed setup, make sure we clean up everything
	if (pcontrm)
	{
		contrmCleanup(pcontrm);
		SysFree(pcontrm);
	}	
	goto Cleanup;
}

//
// Function to kick off a content removal. This is the public version 
// that removes the specified content package for the current title.
//
HRESULT CXo::XOnlineContentRemove(
			XONLINEOFFERING_ID		OfferingId,
			HANDLE					hWorkEvent,
			XONLINETASK_HANDLE		*phTask
			)
{
    XoEnter("XOnlineContentRemove");
	return(XoLeave(ContentRemoveInternal(m_dwTitleId, OfferingId, 0, hWorkEvent, phTask)));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\decalign.cpp ===
/*
 * decalign.c
 *
 * Decoding aligned offset block
 */

#include "xonp.h"
#include "xonver.h"

static long special_decode_aligned_block(t_decoder_context *context, long bufpos, int amount_to_decode)
{
	ulong	match_pos;
	ulong	temp_pos;
	long	bufpos_end;
	int		match_length;
	int		c;
	ulong	dec_bitbuf;
	char	dec_bitcount;
	byte   *dec_input_curpos;
	byte   *dec_end_input_pos;
	byte   *dec_mem_window;
	ulong	m;

	/*
	 * Store commonly used variables locally
	 */
	dec_bitcount	  = context->dec_bitcount;
	dec_bitbuf		  = context->dec_bitbuf;
	dec_input_curpos  = context->dec_input_curpos;
	dec_end_input_pos = context->dec_end_input_pos;
	dec_mem_window	  = context->dec_mem_window;

	bufpos_end = bufpos + amount_to_decode;

	while (bufpos < bufpos_end)
	{
		/*
		 * Decode an item
		 */
		DECODE_MAIN_TREE(c);

		if ((c -= NUM_CHARS) < 0)
		{
#ifdef TRACING
			TracingLiteral(bufpos, (byte) c);
#endif
			dec_mem_window[bufpos] = (byte) c;
			dec_mem_window[context->dec_window_size + bufpos] = (byte) c;
			bufpos++;
		}
		else
		{
	 		/*
	  		 * Get match length slot
	  		 */
			if ((match_length = c & NUM_PRIMARY_LENGTHS) == NUM_PRIMARY_LENGTHS)
			{
				DECODE_LEN_TREE_NOEOFCHECK(match_length);
			}

	 		/*
	  		 * Get match position slot
	  		 */
			m = c >> NL_SHIFT;

			if (m > 2)
			{
				if (dec_extra_bits[ m ] >= 3)
				{
					if (dec_extra_bits[m]-3)
					{
						/* no need to getbits17 */
	    				GET_BITS_NOEOFCHECK(dec_extra_bits[ m ] - 3, temp_pos);
					}
					else
					{
						temp_pos = 0;
					}

	    			match_pos = MP_POS_minus2[m] + (temp_pos << 3);

	    			DECODE_ALIGNED_NOEOFCHECK(temp_pos);
	    			match_pos += temp_pos;
				}
				else
				{
					if (dec_extra_bits[m])
					{
	    				GET_BITS_NOEOFCHECK(dec_extra_bits[ m ], match_pos);

						match_pos += MP_POS_minus2[m];
					}
					else
					{
                        match_pos = 1; // MP_POS_minus2[m==3];
					}
				}

				context->dec_last_matchpos_offset[2] = context->dec_last_matchpos_offset[1];
				context->dec_last_matchpos_offset[1] = context->dec_last_matchpos_offset[0];
				context->dec_last_matchpos_offset[0] = match_pos;
			}
			else
	 		{
				match_pos = context->dec_last_matchpos_offset[m];

				if (m)
				{
					context->dec_last_matchpos_offset[m] = context->dec_last_matchpos_offset[0];
					context->dec_last_matchpos_offset[0] = match_pos;
				}
	 		}

			match_length += MIN_MATCH;

			if (context->dec_extra_long_matches)
			{
				if ( match_length == MAX_MATCH ) {

				//
				//  Fetch extra match length in addition to MAX_MATCH, which
				//  is encoded like this:
				//
				//      0xxxxxxxx          (8-bit value)
				//      10xxxxxxxxxx       (10-bit value plus 2^8)
				//      110xxxxxxxxxxxx    (12-bit value plus 2^8 plus 2^10)
				//      111xxxxxxxxxxxxxxx (15-bit value)
				//
				//  15 bits is the largest possible because a match cannot
				//  span a 32K boundary.
				//
				//  We know we'll read at least 9 bits, so read 9 bits first
				//  and then determine how many additional to read based on
				//  the first 3 bits of that.
				//

				ULONG ExtraMatchLength;
				ULONG ExtraMatchLengthResidue;

				GET_BITS_NOEOFCHECK( 9, ExtraMatchLength );

				if ( ExtraMatchLength & ( 1 << 8 )) {
				    if ( ExtraMatchLength & ( 1 << 7 )) {
				        if ( ExtraMatchLength & ( 1 << 6 )) {

				            //
				            //  First 3 bits are '111', so that means remaining
				            //  6 bits are the first 6 bits of the 15 bit value
				            //  meaning we must read 9 more bits.
				            //

				            ExtraMatchLength = ( ExtraMatchLength & (( 1 << 6 ) - 1 )) << 9;
				            GET_BITS_NOEOFCHECK( 9, ExtraMatchLengthResidue );
				            ExtraMatchLength |= ExtraMatchLengthResidue;
				            }

				        else {

				            //
				            //  First 3 bits are '110', so that means remaining
				            //  6 bits are the first 6 bits of the 12 bit value
				            //  meaning we must read 6 more bits.  Then we add
				            //  2^8 plus 2^10 to the value.
				            //

				            ExtraMatchLength = ( ExtraMatchLength & (( 1 << 6 ) - 1 )) << 6;
				            GET_BITS_NOEOFCHECK( 6, ExtraMatchLengthResidue );
				            ExtraMatchLength |= ExtraMatchLengthResidue;
				            ExtraMatchLength += ( 1 << 8 ) + ( 1 << 10 );
				            }
				        }

				    else {

				        //
				        //  First 2 bits are '10', so that means remaining
				        //  7 bits are the first 7 bits of the 10 bit value
				        //  meaning we must read 3 more bits.  Then we add
				        //  2^8 to the value.
				        //

				        ExtraMatchLength = ( ExtraMatchLength & (( 1 << 7 ) - 1 )) << 3;
				        GET_BITS_NOEOFCHECK( 3, ExtraMatchLengthResidue );
				        ExtraMatchLength |= ExtraMatchLengthResidue;
				        ExtraMatchLength += ( 1 << 8 );
				        }
				    }

				else {

				    //
				    //  First bit is a '0', so that means remaining 8 bits are
				    //  the 8 bit value to add to the match length.  No need to
				    //  mask off the leading '0'.
				    //

				    }

				match_length += ExtraMatchLength;

				}
			}

#ifdef TRACING
			TracingMatch(bufpos,
				bufpos-match_pos,
				context->dec_window_size,
				match_length,
				m);
#endif

			do
			{
                dec_mem_window[bufpos] = dec_mem_window[(bufpos-match_pos) & context->dec_window_mask];

				if (bufpos < MAX_MATCH)
					dec_mem_window[context->dec_window_size+bufpos] = dec_mem_window[bufpos];

				bufpos++;
			} while (--match_length > 0);
		}
	}

	context->dec_bitcount	  = dec_bitcount;
	context->dec_bitbuf		  = dec_bitbuf;
	context->dec_input_curpos = dec_input_curpos;

    return bufpos;
}


#ifndef ASM_DECODE_ALIGNED_OFFSET_BLOCK
long fast_decode_aligned_offset_block(t_decoder_context *context, long bufpos, int amount_to_decode)
{
	ulong	match_pos;
	ulong	temp_pos;
	long	bufpos_end;
	long	decode_residue;
	int		match_length;
	int		c;
	ulong	dec_bitbuf;
	char	dec_bitcount;
	byte   *dec_input_curpos;
	byte   *dec_end_input_pos;
	byte   *dec_mem_window;
	ulong	match_ptr;
	ulong	m;

	/*
	 * Store commonly used variables locally
	 */
	dec_bitcount	  = context->dec_bitcount;
	dec_bitbuf		  = context->dec_bitbuf;
	dec_input_curpos  = context->dec_input_curpos;
	dec_end_input_pos = context->dec_end_input_pos;
	dec_mem_window	  = context->dec_mem_window;

	bufpos_end = bufpos + amount_to_decode;

	while (bufpos < bufpos_end)
	{
		/*
		 * Decode an item
		 */
		DECODE_MAIN_TREE(c);

		if ((c -= NUM_CHARS) < 0)
		{
#ifdef TRACING
			TracingLiteral(bufpos, (byte) c);
#endif
			dec_mem_window[bufpos++] = (byte) c;
		}
		else
		{
	 		/*
	  		 * Get match length slot
	  		 */
			if ((match_length = c & NUM_PRIMARY_LENGTHS) == NUM_PRIMARY_LENGTHS)
			{
				DECODE_LEN_TREE_NOEOFCHECK(match_length);
			}

	 		/*
	  		 * Get match position slot
	  		 */
			m = c >> NL_SHIFT;

			if (m > 2)
			{
				if (dec_extra_bits[ m ] >= 3)
				{
					if (dec_extra_bits[m]-3)
					{
						/* no need to getbits17 */
	    				GET_BITS_NOEOFCHECK(dec_extra_bits[ m ] - 3, temp_pos);
					}
					else
					{
						temp_pos = 0;
					}

	    			match_pos = MP_POS_minus2[m] + (temp_pos << 3);

	    			DECODE_ALIGNED_NOEOFCHECK(temp_pos);
	    			match_pos += temp_pos;
				}
				else
				{
					if (dec_extra_bits[m])
					{
	    				GET_BITS_NOEOFCHECK(dec_extra_bits[ m ], match_pos);

						match_pos += MP_POS_minus2[m];
					}
					else
					{
						match_pos = MP_POS_minus2[m];
					}
				}

				context->dec_last_matchpos_offset[2] = context->dec_last_matchpos_offset[1];
				context->dec_last_matchpos_offset[1] = context->dec_last_matchpos_offset[0];
				context->dec_last_matchpos_offset[0] = match_pos;
			}
			else
	 		{
				match_pos = context->dec_last_matchpos_offset[m];

				if (m)
				{
					context->dec_last_matchpos_offset[m] = context->dec_last_matchpos_offset[0];
					context->dec_last_matchpos_offset[0] = match_pos;
				}
	 		}

			match_length += MIN_MATCH;
			match_ptr = (bufpos - match_pos) & context->dec_window_mask;

			if (context->dec_extra_long_matches)
			{
				if ( match_length == MAX_MATCH ) {

				//
				//  See detailed explanation above.
				//

				ULONG ExtraMatchLength, ExtraMatchLengthResidue;

				GET_BITS_NOEOFCHECK( 9, ExtraMatchLength );

				if ( ExtraMatchLength & ( 1 << 8 )) {
				    if ( ExtraMatchLength & ( 1 << 7 )) {
				        if ( ExtraMatchLength & ( 1 << 6 )) {
				            ExtraMatchLength = ( ExtraMatchLength & (( 1 << 6 ) - 1 )) << 9;
				            GET_BITS_NOEOFCHECK( 9, ExtraMatchLengthResidue );
				            ExtraMatchLength |= ExtraMatchLengthResidue;
				            }
				        else {
				            ExtraMatchLength = ( ExtraMatchLength & (( 1 << 6 ) - 1 )) << 6;
				            GET_BITS_NOEOFCHECK( 6, ExtraMatchLengthResidue );
				            ExtraMatchLength |= ExtraMatchLengthResidue;
				            ExtraMatchLength += ( 1 << 8 ) + ( 1 << 10 );
				            }
				        }
				    else {
				        ExtraMatchLength = ( ExtraMatchLength & (( 1 << 7 ) - 1 )) << 3;
				        GET_BITS_NOEOFCHECK( 3, ExtraMatchLengthResidue );
				        ExtraMatchLength |= ExtraMatchLengthResidue;
				        ExtraMatchLength += ( 1 << 8 );
				        }
				    }

				match_length += ExtraMatchLength;
				}
			}

#ifdef TRACING
			TracingMatch(bufpos,
				bufpos - match_pos,
				context->dec_window_size,
				match_length,
				m);
#endif
			do
			{
				dec_mem_window[bufpos++] = dec_mem_window[match_ptr++];
			} while (--match_length > 0);
		}
	}

	context->dec_bitcount	  = dec_bitcount;
	context->dec_bitbuf		  = dec_bitbuf;
	context->dec_input_curpos = dec_input_curpos;

	/* should be zero */
	decode_residue = bufpos - bufpos_end;

    bufpos &= context->dec_window_mask;
	context->dec_bufpos = bufpos;

	return decode_residue;
}
#endif


int decode_aligned_offset_block(
    t_decoder_context * context, 
    long                BufPos, 
    int                 amount_to_decode
)
{
    /*
     * Special case code when BufPos is near the beginning of the window;
     * we must properly update our MAX_MATCH wrapper bytes.
     */
    if (BufPos < MAX_MATCH)
    {
        long    new_bufpos;
        long    amount_to_slowly_decode;

        amount_to_slowly_decode = min(MAX_MATCH-BufPos, amount_to_decode);

        /*
         * It's ok to end up decoding more than we wanted if we
         * restricted it to decoding only MAX_MATCH; there's
         * no guarantee a match doesn't straddle MAX_MATCH
         */
        new_bufpos = special_decode_aligned_block(
            context,
            BufPos,
            amount_to_slowly_decode
        );

        amount_to_decode -= (new_bufpos-BufPos);

        context->dec_bufpos = BufPos = new_bufpos;

        /*
         * Note: if amount_to_decode < 0 then we're in trouble
         */
        if (amount_to_decode <= 0)
            return amount_to_decode;
    }

    return fast_decode_aligned_offset_block(context, BufPos, amount_to_decode);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\contver.cpp ===
/*++

Copyright (c) Microsoft Corporation

Author:
    Keith Lau (keithlau)

Description:
	Module implementing content verification

Module Name:

    contver.c

--*/

#include "xonp.h"
#include "xonver.h"
#include <shahmac.h>

//#define CHK_CORRUPT
#ifdef CHK_CORRUPT

#define CHK_CORRUPT_SIZE		65536

VOID CXo::CheckCorruption(
			PXONLINETASK_CONTENT_VERIFY	pcontver
			)
{
	PBYTE	pbEnd = (PBYTE)(pcontrm + 1);
	PDWORD	pdwGate;
	DWORD	dw;
	
	pbEnd += (XONLINECONTENT_MAX_PATH * 2);
	pdwGate = (PDWORD)pbEnd;
	
	for (dw = 0; dw < (CHK_CORRUPT_SIZE >> 2); dw++, pdwGate++)
		if (*pdwGate)
		{
			AssertSz(FALSE, "CORRUPT");
		}
}

#endif

#if DBG

const char * const CXo::s_rgszVerifyPhases[verphaseDone] =
{
	"verphaseReadDrm",
	"verphaseWriteDrm"
};

#endif

#ifdef XONLINE_FEATURE_XBOX

//
// Global function to check if a manifest matches the
// supplied title and version info. This is also needed 
// by the global version of DigestVerifySynchronous
//
HRESULT DigestVerifyHeader(
			XONLINEDIR_TYPE			dirtype,
			PDGSTFILE_IDENTIFIER	pdfiDigest,
			PDGSTFILE_HEADER		pdfh,
			DWORD					dwFlags
			)
{
	HRESULT					hr = S_OK;
	BOOL					fFailed = FALSE;
	PDGSTFILE_IDENTIFIER	pdfi;

	Assert(pdfiDigest);
	Assert(pdfh);
	
	pdfi = &(pdfh->dfi);

	// Here we do different checks depending on what
	// type of operations we are doing
	switch (dirtype)
	{
	case dirtypeTitleContent:
	case dirtypeTitleContentOnF:
	
		// Skip this if content is shareable
		if ((pdfh->wFlags & DGSTFILE_HEADER_FLAG_SHARED) == 0)
		{
			// Everything's gotta match
			if (memcmp(pdfi, pdfiDigest, 
						sizeof(DGSTFILE_IDENTIFIER)) != 0)
				fFailed = TRUE;
		}
		break;

	case dirtypeTitleUpdate:
	case dirtypeTitleUpdateOnF:
	case dirtypeDashUpdate0:
	case dirtypeDashUpdate1:
	case dirtypeTempDiff:

		// Make sure the digest is for the same title
		fFailed = TRUE;
		if (pdfi->dwTitleId == pdfiDigest->dwTitleId)
		{
			DWORD	dwVerCurrent, dwVerNew;
			
			// Then do a version check - the digest must be a newer version
			// than the caller's current version
			dwVerNew = MAKE_DWORD_VERSION(
								pdfi->wTitleVersionHi, 
								pdfi->wTitleVersionLo);
			dwVerCurrent = MAKE_DWORD_VERSION(
								pdfiDigest->wTitleVersionHi, 
								pdfiDigest->wTitleVersionLo);
			if (dwFlags & XONLINECONTENT_VERIFY_FLAG_ALLOW_SAME_VERSION)
			{
				// We allow the same version, this should be only used
				// to verify and sign a new update
				if (dwVerNew >= dwVerCurrent)
					fFailed = FALSE;
			}
			else
			{
				// By default, the version must be newer than the 
				// current version
				if (dwVerNew > dwVerCurrent)
					fFailed = FALSE;
			}
		}
		break;
		
	default:
		AssertSz(FALSE, "DigestVerifyHeader: bad dirtype");
		fFailed = TRUE;
	}

	if (fFailed)
	{
		// This is not the right digest
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		goto Error;
	}

	// Now we need to make sure the parental control rating
	// on this box allows the content to be installed/run
	if (XGetParentalControlSetting() < pdfh->wRating)
	{
		// Parental control rating of this content exceeds the
		// setting on the box - cannot install/run content
		hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
		goto Error;
	}

Exit:
	return(hr);

Error:
	goto Exit;
}

//
// Refactored global function to verify content digests. This is
// for code that exists outside of CXo
//
HRESULT DigestVerifySynchronous(
			PSTR					szManifestFilePath,
			XONLINEDIR_TYPE			dirtype,
			PDGSTFILE_IDENTIFIER	pdfi,
			DWORD					dwFlags,
			PBYTE					pbAlternateKey
			)
{
	HRESULT				hr = S_OK;
	HANDLE				hFile = INVALID_HANDLE_VALUE;
	PBYTE				pbBuffer = NULL;
	DWORD				cbSize;
	LARGE_INTEGER		liSize;
	PDGSTFILE_HEADER	pdfh;
    BYTE				shactx[XC_SERVICE_SHA_CONTEXT_SIZE];
    BYTE				rgbDigest[XC_DIGEST_LEN];

	Assert(szManifestFilePath);

	// Open the digest file
	hFile = CreateFile(szManifestFilePath, 
				GENERIC_READ, 
				0, 	// No sharing to prevent mishaps
				NULL, 
				OPEN_EXISTING, 
				FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, 
				NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Error;
	}

	if (!GetFileSizeEx(hFile, &liSize))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Error;
	}

	if (liSize.QuadPart > XONLINECONTENT_MANIFEST_MAX_FILE_SIZE)
	{
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		goto Error;
	}
	
	// Allocate the buffer
	cbSize = liSize.u.LowPart;
	pbBuffer = (PBYTE)LocalAlloc(LMEM_FIXED, cbSize);
	if (!pbBuffer)
	{
		hr = E_OUTOFMEMORY;
		goto Error;
	}

	// Read in the file
	if (!ReadFile(hFile, pbBuffer, cbSize, &cbSize, NULL))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Error;
	}

	// Now make sure the digest file identifier matches up
    if (cbSize < sizeof(DGSTFILE_HEADER))
    {
    	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    	goto Error;
    }

	// Point to the header
	pdfh = (PDGSTFILE_HEADER)(pbBuffer);

	// Run the digest
	XShaHmacInitialize(pbAlternateKey?pbAlternateKey:(BYTE *)(*XboxHDKey),
				XBOX_KEY_LENGTH, shactx);
	XShaHmacUpdate(shactx, 
				pbBuffer + XC_DIGEST_LEN, cbSize - XC_DIGEST_LEN);
	XShaHmacComputeFinal(shactx, 
				pbAlternateKey?pbAlternateKey:(BYTE *)(*XboxHDKey), 
				XBOX_KEY_LENGTH, rgbDigest);
	if (memcmp(rgbDigest, pdfh->rgbSignature, XC_DIGEST_LEN) != 0)
    {
    	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    	goto Error;
    }

	// Verify info
	hr = DigestVerifyHeader(dirtype, pdfi, pdfh, dwFlags);
	if (FAILED(hr))
		goto Error;

Exit:
	if (hFile != INVALID_HANDLE_VALUE)
		CloseHandle(hFile);

	if (pbBuffer)
		LocalFree(pbBuffer);
	return(hr);

Error:
	goto Exit;
}

#else

HRESULT DigestVerifyHeader(
			XONLINEDIR_TYPE			dirtype,
			PDGSTFILE_IDENTIFIER	pdfiDigest,
			PDGSTFILE_HEADER		pdfh,
			DWORD					dwFlags
			)
{
	return(E_NOTIMPL);
}

#endif

//
// Function to read DRM
//
HRESULT CXo::contverReadDrm(
			PXONLINETASK_CONTENT_VERIFY	pcontver
			)
{
	HRESULT				hr = S_OK;
	PXONLINETASK_FILEIO	pfileio = &pcontver->fileio;
	XONLINETASK_HANDLE	hfileio = (XONLINETASK_HANDLE)pfileio;
	ULARGE_INTEGER		uliOffset;
	DWORD				dwRead;
	PBYTE				pbRead;
	BYTE				rgbDigestPerBox[XC_DIGEST_LEN];
	BYTE				rgbDigestPackage[XC_DIGEST_LEN];
	PDGSTFILE_HEADER		pdfh;

	// Wait for the subtask to complete
	hr = XOnlineTaskContinue(hfileio);
	if (XONLINETASK_STATUS_AVAILABLE(hr))
	{
		// Returned results, see if it succeeded
		if (FAILED(hr))
			goto Exit;

		// Succeeded, now get the results and analyze the data
		hr = GetReadWriteFileResults(hfileio, &dwRead, &pbRead);
		if (FAILED(hr))
			goto Exit;

		pcontver->dwBytesRead += dwRead;

		// First, we need to skip the first XC_DIGEST_LEN bytes
		// because this is the digest slot
		if (!pcontver->pbHeader)
		{
			// Now make sure the digest file identifier matches up
            if (dwRead < sizeof(DGSTFILE_HEADER))
            {
            	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            	goto Exit;
            }
			pdfh = (PDGSTFILE_HEADER)pbRead;
			
			dwRead -= XC_DIGEST_LEN;
			pbRead += XC_DIGEST_LEN;
			pcontver->pbHeader = pcontver->pbBuffer;

			// Advance the read buffer if necessary
			if (pcontver->dwFileSize > XBOX_HD_SECTOR_SIZE)
			{
				pcontver->pbBuffer += XBOX_HD_SECTOR_SIZE;
				pcontver->cbBuffer -= XBOX_HD_SECTOR_SIZE;
			}

			// Check the digest header information
			hr = DigestVerifyHeader(pcontver->dirtype, 
						&(pcontver->dfi), pdfh, pcontver->dwFlags);
			if (FAILED(hr))
				goto Exit;
		}

		// Update the SHA HMAC
		XShaHmacUpdate(pcontver->shactxPerBox, pbRead, dwRead);
		if (pcontver->pbKeyPackage)
		{
			XShaHmacUpdate(pcontver->shactxPackage, pbRead, dwRead);
		}

		// Now, see if we need to read more 
		if (pcontver->dwFileSize > pcontver->dwBytesRead)
		{
			// Still need to read more
			uliOffset.QuadPart = pcontver->dwBytesRead;
			ReadWriteFileInitializeContext(pfileio->hFile,
						pcontver->pbBuffer, pcontver->cbBuffer, uliOffset, 
						pcontver->xontask.hEventWorkAvailable, 
						pfileio);

			hr = ReadFileInternal(pfileio);
			goto Exit;
		}
		else if (pcontver->dwFileSize == pcontver->dwBytesRead)
		{
			// Done reading, now calculate the final SHA HMAC value
			XShaHmacComputeFinal(pcontver->shactxPerBox,
						pcontver->pbKeyPerBox, XBOX_KEY_LENGTH,
						rgbDigestPerBox);

			// Now, if the digest matches the per-box digest, then 
			// this is a valid manifest
			if (memcmp(rgbDigestPerBox, pcontver->pbHeader, XC_DIGEST_LEN) == 0)
			{
				// Done
				hr = S_OK;
				pcontver->verphase = verphaseDone;
				goto Exit;
			}

			// If we are not in signing mode, this is a bad manifest
			if (pcontver->pbKeyPackage &&
				((pcontver->dwFlags & 
					(XONLINECONTENT_VERIFY_FLAG_SIGN | 
					 XONLINECONTENT_VERIFY_FLAG_USER_KEY)) != 0))
			{
				XShaHmacComputeFinal(pcontver->shactxPackage,
							pcontver->pbKeyPackage, XC_SYMMETRIC_KEY_SIZE,
							rgbDigestPackage);

				// Now, if the digest matches the package digest, then 
				// we will need to re-sign this manifest with the per-box key
				if (memcmp(rgbDigestPackage, pcontver->pbHeader, XC_DIGEST_LEN) == 0)
				{
					// OK, if we only wanted to verify, then we are done
					if (pcontver->dwFlags & XONLINECONTENT_VERIFY_FLAG_USER_KEY)
					{
						hr = S_OK;
						pcontver->verphase = verphaseDone;
						goto Exit;
					}
					
					// Replace the header digest with the per-box digest
					memcpy(pcontver->pbHeader, rgbDigestPerBox, XC_DIGEST_LEN);

					// Write it back out
					uliOffset.QuadPart = 0;
					ReadWriteFileInitializeContext(pfileio->hFile,
								pcontver->pbHeader, XBOX_HD_SECTOR_SIZE, 
								uliOffset, 
								pcontver->xontask.hEventWorkAvailable, 
								pfileio);

					hr = WriteFileInternal(pfileio);
					if (FAILED(hr))
						goto Exit;
				
					// Next phase is to wait for the write to complete
					pcontver->verphase = verphaseWriteDrm;
					goto Exit;
				}
			}

			// If we get here, the check has failed; fall thru ...
		}
		
		// Bad state, fail on the safe side
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		goto Exit;
	}

Exit:
	return(hr);
}

//
// Function to wait for write DRM to complete
//
HRESULT CXo::contverWriteDrm(
			PXONLINETASK_CONTENT_VERIFY	pcontver
			)
{
	HRESULT				hr = S_OK;
	XONLINETASK_HANDLE	hfileio = (XONLINETASK_HANDLE)&(pcontver->fileio);
	DWORD				dwWritten;

	// Wait for the subtask to complete
 	hr = XOnlineTaskContinue(hfileio);
	if (XONLINETASK_STATUS_AVAILABLE(hr))
	{
		// Returned results, see if it succeeded
		if (FAILED(hr))
			goto Error;

		// Succeeded, now get the results and analyze the data
		hr = GetReadWriteFileResults(hfileio, &dwWritten, NULL);
		if (FAILED(hr))
			goto Error;

		Assert(dwWritten == XBOX_HD_SECTOR_SIZE);

		// Well, if the file size is less than one sector, chop it off
		if (pcontver->dwFileSize < XBOX_HD_SECTOR_SIZE)
		{
			hr = SetEndOfFileNt(pcontver->fileio.hFile, pcontver->dwFileSize);
			if (FAILED(hr))
				goto Error;
		}
			
		// We're done.
		pcontver->verphase = verphaseDone;
	}
	
Error:
	return(hr);
}

//
// Function to cleanup
//
HRESULT CXo::contverCleanup(
			PXONLINETASK_CONTENT_VERIFY	pcontver
			)
{
	if (pcontver->fileio.hFile != INVALID_HANDLE_VALUE)
	{
		CloseHandle(pcontver->fileio.hFile);
		pcontver->fileio.hFile = INVALID_HANDLE_VALUE;
	}
	return(S_OK);
}

//
// Implement the do work function for XOnlineContentVerify
//
HRESULT CXo::contverContinue(
			XONLINETASK_HANDLE	hTask
			)
{
	HRESULT						hr = S_OK;
	PXONLINETASK_CONTENT_VERIFY	pcontver = NULL;
	PXONLINETASK_FILEIO			pfileio = NULL;

#if DBG
	LARGE_INTEGER				liTimerTotal;
	LARGE_INTEGER				liTimerEnd;
	LARGE_INTEGER				liTimerStart;
	XONLINECONTENT_VERPHASE		verphase;

	// Track service count
	m_liverServiceCount.QuadPart += 1;

	// Start the total timer
	QueryPerformanceCounter(&liTimerTotal);
#endif

	Assert(hTask != NULL);

	// hTask points to the xontask field of XONLINETASK_CONTENT_VERIFY
	// find the containing pcontver structure
	pcontver = CONTAINING_RECORD(hTask, XONLINETASK_CONTENT_VERIFY, xontask);
	pfileio = &pcontver->fileio;

#ifdef CHK_CORRUPT
	CheckCorruption(pcontver);
#endif

#if DBG
	// Start the loop timer
	QueryPerformanceCounter(&liTimerStart);
	verphase = pcontver->verphase;
#endif

	// Figure out what phase we are in ...
	switch (pcontver->verphase)
	{
	case verphaseReadDrm:
		hr = contverReadDrm(pcontver);
		break;
		
	case verphaseWriteDrm:
		hr = contverWriteDrm(pcontver);
		break;
		
	default:
		// This is a bad state. We force it to end so we don't get stuck
		// here forever.
		AssertSz(FALSE, "contverContinue: invalid phase!");
		hr = E_FAIL;
	}

#if DBG	
	// Stop timer
	QueryPerformanceCounter(&liTimerEnd);

	m_liverTotalTime.QuadPart += (liTimerEnd.QuadPart - liTimerStart.QuadPart);
	m_liverAverageTime.QuadPart = m_liverTotalTime.QuadPart / m_liverServiceCount.QuadPart;

//	TraceSz2(Verbose, "%s, %I64u us", s_rgszVerifyPhases[verphase], (liTimerEnd.QuadPart - liTimerStart.QuadPart));
	
#endif	

	// Bail if failed.
	if (FAILED(hr))
	{
		contverCleanup(pcontver);
		pcontver->verphase = verphaseDone;
	}

	// When the next state is the final state, we set the flag so we don't
	// continue.
	if (pcontver->verphase == verphaseDone)
	{
		// Indicate that we are done and return the final code
		XONLINETASK_SET_COMPLETION_STATUS(hr);

#if DBG
		TraceSz1(Verbose, "%I64u services elapsed", m_liverServiceCount.QuadPart);
		TraceSz1(Verbose, "Total time: %I64u ticks", m_liverTotalTime.QuadPart);
		TraceSz1(Verbose, "Average service time: %I64u ticks", m_liverAverageTime.QuadPart);
		m_liverServiceCount.QuadPart = 0;
		m_liverTotalTime.QuadPart = 0;
		m_liverAverageTime.QuadPart = 0;
#endif		
	}

#ifdef CHK_CORRUPT
	CheckCorruption(pcontver);
#endif

	return(hr);
}				

//
// Function to close the task handle
//
VOID CXo::contverClose(
			XONLINETASK_HANDLE	hTask
			)
{
	PXONLINETASK_CONTENT_VERIFY	pcontver = (PXONLINETASK_CONTENT_VERIFY)hTask;

	contverCleanup(pcontver);
	SysFree(pcontver);
}

//
// Function to initialize the context for content verification
//
HRESULT CXo::ContentVerifyInitializeContext(
			HANDLE						hFile,
			DWORD						dwFileSize,
			PBYTE						pbBuffer,
			DWORD						cbBuffer,
			PBYTE						pbKeyPackage,
			DWORD						dwFlags,
			PDGSTFILE_IDENTIFIER		pdfi,
			XONLINEDIR_TYPE				dirtype,
			HANDLE						hWorkEvent,
			PXONLINETASK_CONTENT_VERIFY	pcontver
			)
{
	HRESULT	hr = S_OK;

    Assert(hFile != INVALID_HANDLE_VALUE);
    Assert(NULL != pbBuffer);
    Assert(cbBuffer >= (XBOX_HD_SECTOR_SIZE * 2));
    Assert(NULL != pcontver);

	// If the file is too small, fail immediately
    if (dwFileSize < XC_DIGEST_LEN)
    	return(HRESULT_FROM_WIN32(ERROR_INVALID_DATA));

	// Align buffer size with sector size
	cbBuffer &= (~(XBOX_HD_SECTOR_SIZE - 1));

	ZeroMemory(pcontver, sizeof(XONLINETASK_CONTENT_VERIFY));

	// Fill in the blanks
	TaskInitializeContext(&pcontver->xontask);
	pcontver->xontask.hEventWorkAvailable = hWorkEvent;
	pcontver->xontask.pfnContinue = contverContinue;
	pcontver->xontask.pfnClose = contverClose;
	pcontver->verphase = verphaseReadDrm;
	pcontver->fileio.hFile = hFile;
	pcontver->dwFileSize = dwFileSize;
	pcontver->dwBytesRead = 0;
	pcontver->pbHeader = NULL;
	pcontver->pbBuffer = pbBuffer;
	pcontver->cbBuffer = cbBuffer;
	pcontver->pbKeyPackage = pbKeyPackage;
	pcontver->dwFlags = dwFlags;
	pcontver->dirtype = dirtype;

	CopyMemory(&(pcontver->dfi), pdfi, sizeof(DGSTFILE_IDENTIFIER));

	// Get the real per-box key
	pcontver->pbKeyPerBox = GetHdKey();

	// Initialize our contexts for SHA HMAC calculations
	XShaHmacInitialize(
				pcontver->pbKeyPerBox,
				XBOX_KEY_LENGTH,
				pcontver->shactxPerBox);

	// Initialize for per-package if the key is supplied
	if (pbKeyPackage)
	{
		XShaHmacInitialize(
					pbKeyPackage,
					XC_SYMMETRIC_KEY_SIZE,
					pcontver->shactxPackage);
	}

	return(S_OK);
}

//
// Function to begin content verification
//
HRESULT CXo::ContentVerifyBegin(
			PXONLINETASK_CONTENT_VERIFY	pcontver
			)
{
	HRESULT						hr = S_OK;
	ULARGE_INTEGER				uliOffset;
	DWORD						dwReadSize;
	PXONLINETASK_FILEIO			pfileio = NULL;

    Assert(NULL != pcontver);
	pfileio = &pcontver->fileio;

	// OK, now kick off a file read. Take extra care to not overrun
	// the buffer
	dwReadSize = (pcontver->dwFileSize > pcontver->cbBuffer)?
					pcontver->cbBuffer:pcontver->dwFileSize;
	dwReadSize = SECTOR_ALIGNMENT_ROUND_UP(dwReadSize);
    Assert(dwReadSize <= pcontver->cbBuffer);
	
	uliOffset.QuadPart = 0;
	ReadWriteFileInitializeContext(pfileio->hFile,
				pcontver->pbBuffer, dwReadSize, uliOffset, 
				pcontver->xontask.hEventWorkAvailable, 
				pfileio);

	hr = ReadFileInternal(pfileio);
	if (FAILED(hr))
		goto Error;

	// Next phase is read Drm
	pcontver->verphase = verphaseReadDrm;

Error:
	return(hr);
}

//
// Function to kick off content verification. This is 
// the internal/Dash version because it allows a Title ID to be 
// specified.
//
HRESULT CXo::ContentVerifyInternal(
			PDGSTFILE_IDENTIFIER	pdfi,
			PBYTE					pbBuffer,
			DWORD					*pcbBuffer,
			DWORD					dwFlags,
			XONLINEDIR_TYPE			dirtype,
			HANDLE					hWorkEvent,
			XONLINETASK_HANDLE		*phTask
			)
{
	HRESULT						hr = S_OK;
	PXONLINETASK_CONTENT_VERIFY pcontver = NULL;
	PXONLINETASK_FILEIO			pfileio = NULL;
	ULARGE_INTEGER				uliOffset;
	HANDLE						hFile = INVALID_HANDLE_VALUE;
	BYTE						szPath[XONLINECONTENT_MAX_PATH];
	DWORD						cbSize;
	DWORD						cbActual;

	Assert(NULL != phTask);
	Assert(NULL != pcbBuffer);

    cbSize = XBOX_HD_SECTOR_SIZE * 2;
    if (*pcbBuffer && (*pcbBuffer < cbSize))
    {
    	// Buffer too small, tell caller what the minimum is
    	*pcbBuffer = cbSize;
    	return(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));
    }

	// Build the path to the DRM file, it must be in the
	// title data area
 	cbSize = XONLINECONTENT_MAX_PATH;
	hr = BuildExistingContentPath(
				pdfi->dwTitleId,
				pdfi->OfferingId, 
				XONLINECONTENT_MANIFEST_FILE_NAME,
				dirtypeTitleContent,
				&cbSize,
				(CHAR *)szPath);
	if (FAILED(hr))
	{
		*pcbBuffer = cbSize;
		goto Error;
	}

	// Open the manifest
	hFile = CreateFile(
				(LPSTR)szPath, 
				GENERIC_READ | GENERIC_WRITE, 
				0, 	// No sharing to prevent mishaps
				NULL, 
				OPEN_EXISTING, 
				FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN |
				FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING, 
				NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		// If the manifest is not found then the installation 
		// is invalid
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Error;
	}

	if (!GetFileSizeEx(hFile, (PLARGE_INTEGER)&uliOffset))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Error;
	}

	// Make sure the file size makes sense
	if ((uliOffset.QuadPart <= XC_DIGEST_LEN) ||
		(uliOffset.QuadPart > XONLINECONTENT_MANIFEST_MAX_FILE_SIZE))
	{
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		goto Error;
	}

	// Return the manifest size to the caller in case this is
	// interesting information
	*pcbBuffer = uliOffset.u.LowPart;

    // Don't allocate for buffer if caller already specified one
    if (pbBuffer)
    {
    	cbSize = 0;
    	cbActual = SECTOR_ALIGNMENT_ROUND_DOWN(*pcbBuffer);
    }
    else if (*pcbBuffer > 0)
    {
    	cbSize = SECTOR_ALIGNMENT_ROUND_DOWN(*pcbBuffer);
    	if (cbSize < (XBOX_HD_SECTOR_SIZE * 2))
    		cbSize = (XBOX_HD_SECTOR_SIZE * 2);
    	cbActual = cbSize;
    }
    else
    {
    	// Zero *pcbBuffer is a special case to say "allocate a buffer
    	// that holds the whole file"
    	cbSize = SECTOR_ALIGNMENT_ROUND_UP(uliOffset.u.LowPart);
    	*pcbBuffer = cbActual = cbSize;
    }

	// We are responsible for allocating the context
	cbSize += sizeof(XONLINETASK_CONTENT_VERIFY);
	
#ifdef CHK_CORRUPT	
	cbSize += CHK_CORRUPT_SIZE;
#endif

	pcontver = (PXONLINETASK_CONTENT_VERIFY)SysAlloc(cbSize, PTAG_XONLINETASK_CONTENT_VERIFY);
	if (!pcontver)
	{
		hr = E_OUTOFMEMORY;
		goto Error;
	}

	if (!pbBuffer)
		pbBuffer = (PBYTE)(pcontver + 1);

	// Now transfer the handle over
	pfileio = &pcontver->fileio;
	pfileio->hFile = hFile;
	hFile = INVALID_HANDLE_VALUE;

	// Initialize the context
	hr = ContentVerifyInitializeContext(
				pfileio->hFile, uliOffset.u.LowPart, 
				pbBuffer, cbActual, 
				NULL, dwFlags, pdfi, dirtype,
				hWorkEvent, pcontver);
	if (FAILED(hr))
		goto Error;

	// Kick off the verification
	hr = ContentVerifyBegin(pcontver);
	if (FAILED(hr))
		goto Error;

	// Return the context as an opaque handle
	*phTask = (XONLINETASK_HANDLE)pcontver;

Cleanup:
	return(hr);

Error:

	// Failed setup, make sure we clean up everything
	if (pcontver)
	{
		contverCleanup(pcontver);
		SysFree(pcontver);
	}
	if (hFile != INVALID_HANDLE_VALUE)
		CloseHandle(hFile);
	goto Cleanup;
}

//
// Function to kick off a content verification
//
HRESULT CXo::XOnlineContentVerify(
			XONLINEOFFERING_ID		OfferingId,
			PBYTE					pbBuffer,
			DWORD					*pcbBuffer,
			HANDLE					hWorkEvent,
			XONLINETASK_HANDLE		*phTask
			)
{
    XoEnter("XOnlineContentVerify");

	DGSTFILE_IDENTIFIER	dfi;

	dfi.dwTitleId = m_dwTitleId;
	dfi.OfferingId = OfferingId;
	dfi.wTitleVersionHi = 0;
	dfi.wTitleVersionLo = 0;

	return(XoLeave(ContentVerifyInternal(&dfi, pbBuffer, pcbBuffer, 0, dirtypeTitleContent, hWorkEvent, phTask)));
}

//
// Function to kick off a digest verification task
//
HRESULT CXo::DigestVerify(
			PSTR						szManifestFileName,
			XONLINEDIR_TYPE				dirtype,
			PBYTE						pbBuffer,
			DWORD						*pcbBuffer,
			PBYTE						pbAlternateKey,
			HANDLE						hWorkEvent,
			PXONLINETASK_CONTENT_VERIFY	pcontver
			)
{
	HRESULT	hr = S_OK;
	HANDLE	hFile = INVALID_HANDLE_VALUE;
	CHAR	szPath[MAX_PATH];
	DWORD	cbPath = MAX_PATH;
	DWORD	dwFlags = pbAlternateKey?XONLINECONTENT_VERIFY_FLAG_USER_KEY:0;
	LARGE_INTEGER		liSize;
	DGSTFILE_IDENTIFIER	dfi;

	Assert(szManifestFileName);
	Assert(pbBuffer);
	Assert(pcbBuffer);
	Assert(*pcbBuffer > sizeof(DGSTFILE_HEADER));
	Assert(pcontver);

	// Compute where the digest file is
	hr = BuildTargetPath(0, 0, 0, szManifestFileName,
				dirtype, &cbPath, szPath);
	if (FAILED(hr))
		goto Error;

	// Open the digest file
	hFile = CreateFile(szPath, 
				GENERIC_READ, 
				0, 	// No sharing to prevent mishaps
				NULL, 
				OPEN_EXISTING, 
				FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN |
				FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING, 
				NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Error;
	}

	if (!GetFileSizeEx(hFile, &liSize))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Error;
	}

	// The digest file should be smaller than our buffer
	cbPath = *pcbBuffer;
	*pcbBuffer = liSize.u.LowPart;
	if (liSize.QuadPart > cbPath)
	{
		hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
		goto Error;
	}

	// Simply kick off a content verify
	dfi.OfferingId = 0;
	dfi.dwTitleId = m_dwTitleId;
	MAKE_COMPOSITE_VERSION(m_dwTitleVersion, &dfi.wTitleVersionHi, &dfi.wTitleVersionLo);
	
	hr = ContentVerifyInitializeContext(
				hFile, liSize.u.LowPart,
				pbBuffer, cbPath,
				pbAlternateKey, dwFlags,
				&dfi, dirtype, hWorkEvent, pcontver);
	if (FAILED(hr))
		goto Error;

	hr = ContentVerifyBegin(pcontver);
	if (FAILED(hr))
		goto Error;

Exit:
	return(hr);

Error:
	if (hFile != INVALID_HANDLE_VALUE)
		CloseHandle(hFile);
	goto Exit;
}

//
// ====================================================
// Functions to access SHA1 signatures in digest files
//
// Note: in order to use these functions, the caller must load the 
// digest file in its entirety into memory. The preferred method
// to do this is by figuring out the digest file size and calling 
// ContentVerifyInitializeContext and supplying a buffer large 
// enough to fit the entire file. This is because ContentVerify
// actually checks the signature of the digest file to make sure
// the digest file is authentic.
//

//
// API to begin a digest file enumeration
//
HRESULT EnumerateDigestInitializeContext(
			PBYTE					pbDigestData,
			DWORD					cbDigestData,
			PDGSTFILE_ENUM_CONTEXT	pContext
			)
{
	DWORD	cEntries;
	DWORD	cbSize = sizeof(DGSTFILE_HEADER);
	
	Assert(cbDigestData > cbSize);
	Assert(pbDigestData);
	Assert(pContext);

	pContext->dwCurrent = 0;
	pContext->cbDigestData = cbDigestData;
	pContext->pbDigestData = pbDigestData;

	// Overlay the header
	pContext->pHeader = (PDGSTFILE_HEADER)pbDigestData;
	cbDigestData -= cbSize;
	pbDigestData += cbSize;

	// Find the offset vector
	cEntries = pContext->pHeader->cDigestEntries;
	Assert(cEntries > 0);
	cbSize = cEntries * sizeof(DWORD);
	Assert(cbSize < cbDigestData);
	pContext->rgdwOffsetVector = (DWORD *)pbDigestData;
	cbDigestData -= cbSize;
	pbDigestData += cbSize;

	return(S_OK);
}

//
// API to get entries in a digest file (returns a reference to the
// data instead of a copy)
//
HRESULT EnumerateDigestNext(
			PDGSTFILE_ENUM_CONTEXT	pContext,
			PSTR					*ppszFileName,
			PDGSTFILE_FILE_DATA		*ppData
			)
{
	DWORD	dwBaseOffset;

	Assert(pContext);
	Assert(ppszFileName);
	Assert(ppData);

	if (pContext->dwCurrent >= pContext->pHeader->cDigestEntries)
		return(HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS));

	// The fixed structure comes first
	dwBaseOffset = pContext->rgdwOffsetVector[pContext->dwCurrent];
	*ppData = (PDGSTFILE_FILE_DATA)(pContext->pbDigestData + dwBaseOffset);
	dwBaseOffset += sizeof(DGSTFILE_FILE_DATA);

	// Figure out where the string is ...
	dwBaseOffset += (((*ppData)->wSections - 1) * sizeof(DGST_SECTION_DATA));
	dwBaseOffset += (*ppData)->bReservedSize;
	*ppszFileName = (PSTR)(pContext->pbDigestData + dwBaseOffset);

	dwBaseOffset += (strlen(*ppszFileName) + 1);
	Assert(pContext->cbDigestData >= dwBaseOffset);
	(pContext->dwCurrent)++;
	return(S_OK);
}

//
// API to find a specific entry in a digest file (returns a reference to the
// data instead of a copy)
//
HRESULT EnumerateDigestFind(
			PDGSTFILE_ENUM_CONTEXT	pContext,
			PSTR					pszFileName,
			PDGSTFILE_FILE_DATA		*ppData
			)
{
	PDWORD	pdwOffset;
	DWORD	dwBaseOffset;
	DWORD	i;

	Assert(pContext);
	Assert(pszFileName);
	Assert(ppData);

	for (i = 0, pdwOffset = pContext->rgdwOffsetVector; 
		 i < pContext->pHeader->cDigestEntries; 
		 i++, pdwOffset++)
	{
		// The fixed structure comes first
		dwBaseOffset = *pdwOffset;
		*ppData = (PDGSTFILE_FILE_DATA)(pContext->pbDigestData + dwBaseOffset);
		dwBaseOffset += sizeof(DGSTFILE_FILE_DATA);

		// Figure out where the string is ...
		dwBaseOffset += (((*ppData)->wSections - 1) * sizeof(DGST_SECTION_DATA));
		dwBaseOffset += (*ppData)->bReservedSize;
		if (!_stricmp(pszFileName, (PSTR)(pContext->pbDigestData + dwBaseOffset)))
			return(S_OK);
			
		dwBaseOffset += (strlen(pszFileName) + 1);
		Assert(pContext->cbDigestData >= dwBaseOffset);
	}

	return(HRESULT_FROM_WIN32(ERROR_NOT_FOUND));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\decblk.cpp ===
/*
 * decblk.c
 *
 * main decoder module
 */

#include "xonp.h"
#include "xonver.h"

/*
 * Decode a block type
 */
static int decode_block(
	t_decoder_context	*context, 
	lzx_block_type		block_type, 
	long				bufpos, 
    long                amount_to_decode
)
{
    int result;

	if (block_type == BLOCKTYPE_ALIGNED)
        result = decode_aligned_offset_block(context, bufpos, (int) amount_to_decode);
	else if (block_type == BLOCKTYPE_VERBATIM)
        result = decode_verbatim_block(context, bufpos, (int) amount_to_decode);
	else if (block_type == BLOCKTYPE_UNCOMPRESSED)
        result = decode_uncompressed_block(context, bufpos, (int) amount_to_decode);
	else /* no other block types exist */
		result = -1;

	return result;
}



/*
 * Main decode entrypoint
 */
long NEAR decode_data(t_decoder_context *context, long bytes_to_decode)
{                                                                                                                                                                                                                                          
	ulong			amount_can_decode;
	long			total_decoded;

	total_decoded = 0;

	while (bytes_to_decode > 0)          
	{
		if (context->dec_decoder_state == DEC_STATE_START_NEW_BLOCK)
		{
			ulong	temp1;                                                                                           
			ulong	temp2;
			ulong	temp3;
			bool	do_translation;

			/*
			 * If this is the first time this group, then get the
			 * file size for translation.
			 */
			if (context->dec_first_time_this_group)
			{
				context->dec_first_time_this_group = false;

				do_translation = (bool) (getbits(context, 1) != 0);

				if (do_translation)
				{
					ulong high, low;

					high = getbits(context, 16);
					low  = getbits(context, 16);
					context->dec_current_file_size = (high<<16)|low;
				}
				else
				{
					context->dec_current_file_size = 0;
				}
			}

            /*
             * If the last block we decoded was uncompressed, then
             * we need to skip the pad byte (if it exists), and
             * initialise the decoder's bit buffer
             */
            if (context->dec_block_type == BLOCKTYPE_UNCOMPRESSED)
            {
                /*
                 * If block size was odd, a pad byte is required
                 */
                if (context->dec_original_block_size & 1)
                {
                    if (context->dec_input_curpos < context->dec_end_input_pos)
                        context->dec_input_curpos++;
                }

                /* so that initialise_decoder_bitbuf() will succeed */
                context->dec_block_type = BLOCKTYPE_INVALID;

                initialise_decoder_bitbuf(context);
            }

			/* get the block type */
            context->dec_block_type = (lzx_block_type) getbits(context, 3);

			/* get size of block (in uncompressed bytes) to decode */
			temp1 = getbits(context, 8);
			temp2 = getbits(context, 8);
			temp3 = getbits(context, 8);

			/*
			 * How large is the block we're going to decode?
			 * It can be from 0...16777215 bytes (16MB)
			 */
            context->dec_block_size =
            context->dec_original_block_size = (temp1<<16) + (temp2<<8) + (temp3);

			/* if block is an aligned type, read the aligned offset tree */
			if (context->dec_block_type == BLOCKTYPE_ALIGNED)
				read_aligned_offset_tree(context);

			/* read trees */
			if (context->dec_block_type == BLOCKTYPE_VERBATIM || 
      			context->dec_block_type == BLOCKTYPE_ALIGNED)
			{
	 			/*	backup old trees */
	 			memcpy(
                    context->dec_main_tree_prev_len, 
                    context->dec_main_tree_len, 
	 				MAIN_TREE_ELEMENTS
	 			);

	 			memcpy(
                    context->dec_secondary_length_tree_prev_len,
                    context->dec_secondary_length_tree_len,
	 				NUM_SECONDARY_LENGTHS
	 			);

				read_main_and_secondary_trees(context);
			}
			else if (context->dec_block_type == BLOCKTYPE_UNCOMPRESSED)
			{
                if (handle_beginning_of_uncompressed_block(context) == false)
                    return -1;
			}
			else 
			{
				/* no other block types are supported at this time */
                return -1;
			}

			context->dec_decoder_state = DEC_STATE_DECODING_DATA;
		}

		/*
		 * Keep decoding until the whole block has been decoded
		 */
		while ((context->dec_block_size > 0) && (bytes_to_decode > 0))
		{
            int decode_residue;

			amount_can_decode = min(context->dec_block_size, bytes_to_decode);
		
	 		/* shouldn't happen */
	 		if (amount_can_decode == 0)
                return -1;

 			decode_residue = decode_block(
				context, 
				context->dec_block_type, 
				context->dec_bufpos, 
				amount_can_decode
			);

	 		/*
	 		 * We should have decoded exactly the amount we wanted,
			 * since the encoder makes sure that no matches span 32K
			 * boundaries.
			 *
	 		 * If the data was corrupted, it's possible that we decoded
			 * up to MAX_MATCH bytes more than we wanted to.
  			 */
	 		if (decode_residue != 0)
	    	{
				/* error, we didn't decode what we wanted! */
                return -1;
			}

	 		context->dec_block_size -= amount_can_decode;
			bytes_to_decode -= amount_can_decode;
			total_decoded += amount_can_decode;
		}

		if (context->dec_block_size == 0)
		{
			context->dec_decoder_state = DEC_STATE_START_NEW_BLOCK;
		}

		if (bytes_to_decode == 0)
		{
			initialise_decoder_bitbuf(context);
		}
	}

    copy_data_to_output(
		context,
		total_decoded, 
		context->dec_bufpos ? 
			&context->dec_mem_window[context->dec_bufpos - total_decoded] : 
			&context->dec_mem_window[context->dec_window_size - total_decoded]
	);

    return total_decoded;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\decin.cpp ===
/*
 * decin.c
 *
 * Decoder inputting of compressed data
 */

#include "xonp.h"
#include "xonver.h"

/*
 * Initialises the bit buffer state
 */
void NEAR initialise_decoder_bitbuf(t_decoder_context *context)
{
	byte *p;

    /*
     * If we're decoding an uncompressed block, don't use the
     * bit buffer; we're reading directly out of the input.
     */
    if (context->dec_block_type == BLOCKTYPE_UNCOMPRESSED)
        return;

    if ((context->dec_input_curpos + sizeof(ulong)) > context->dec_end_input_pos)
        return;

    p = context->dec_input_curpos;

	context->dec_bitbuf =
        ((ulong) p[2] | (((ulong) p[3]) << 8)) |
        ((((ulong) p[0] | (((ulong) p[1]) << 8))) << 16);

	context->dec_bitcount = 16;
    context->dec_input_curpos += 4;
}


/*
 * Initialise input buffer and bitwise i/o
 */
void NEAR init_decoder_input(t_decoder_context *context)
{
   initialise_decoder_bitbuf(context);
}


void NEAR fillbuf(t_decoder_context *context, int n)
{
	context->dec_bitbuf <<= n;            					
	context->dec_bitcount -= (char)n;
	
	if (context->dec_bitcount <= 0)      					
	{                                 				
		if (context->dec_input_curpos >= context->dec_end_input_pos)	
        {
            context->dec_error_condition = true;
            return;
        }

        context->dec_bitbuf |= ((((ulong) *context->dec_input_curpos | (((ulong) *(context->dec_input_curpos+1)) << 8))) << (-context->dec_bitcount));
        context->dec_input_curpos += 2;
        context->dec_bitcount += 16;

		if (context->dec_bitcount <= 0)							
		{                                 				
            if (context->dec_input_curpos >= context->dec_end_input_pos)
            {
                context->dec_error_condition = true;
                return;
            }

            context->dec_bitbuf |= ((((ulong) *context->dec_input_curpos | (((ulong) *(context->dec_input_curpos+1)) << 8))) << (-context->dec_bitcount));
            context->dec_input_curpos += 2;
			context->dec_bitcount += 16;               			
		}												
   }                                    				
}


ulong NEAR getbits(t_decoder_context *context, int n)
{
	ulong value;

	value = context->dec_bitbuf >> (32-(n));			
	fillbuf(context, n);

	return value;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\contutil.cpp ===
/*++

Copyright (c) Microsoft Corporation

Author:
    Keith Lau (keithlau)

Description:
	Module implementing utility functions for content delivery

Module Name:

    contutil.c

--*/

#include "xonp.h"
#include "xonver.h"

//
// Builds the target directory.
//
// Note: Coming in, *pcbTargetDirectory must count the NULL terminator,
// coming out, *pcbTargetDirectory does NOT include NULL terminator
//
HRESULT BuildTargetDirectory(
			DWORD				dwTitleId,
			XONLINEOFFERING_ID	OfferingId,
			DWORD				dwBitFlags,
			XONLINEDIR_TYPE		dirtype,
			DWORD				*pcbTargetDirectory,
			CHAR				*szTargetDirectory
			)
{
	DWORD	dwSize;

	// Build a switch statement to handle different directory types
	switch (dirtype)
	{
	case dirtypeTitleContent:
	case dirtypeUserContent:
	
		// Target is content
		dwSize = strlen(XONLINECONTENT_BASE_PATH) + 8;
		if (dwSize >= *pcbTargetDirectory)
			goto Error;
		
		*pcbTargetDirectory = sprintf(
					szTargetDirectory, 
					XONLINECONTENT_BASE_PATH,
					(dirtype==dirtypeUserContent)?'u':
						((dirtype==dirtypeTitleContent)?'t':'d'), 
					OfferingId, dwBitFlags);
		break;

	case dirtypeDVDContent:
	
		// Target is content
		dwSize = strlen(XONLINECONTENT_DVD_PATH) + 13;
		if (dwSize >= *pcbTargetDirectory)
			goto Error;
		
		*pcbTargetDirectory = sprintf(
					szTargetDirectory, 
					XONLINECONTENT_DVD_PATH,
					dwTitleId, OfferingId, dwBitFlags);
		break;
		
	case dirtypeTitleUpdate:
	
		// Target is title update
		dwSize = strlen(AUTOUPD_TITLE_READ_PATH);
		if (dwSize >= *pcbTargetDirectory)
			goto Error;

		strcpy(szTargetDirectory, AUTOUPD_TITLE_READ_PATH);
		*pcbTargetDirectory = dwSize;
		break;

	case dirtypeTitleUpdateOnF:
	
		// Target is title update
		dwSize = strlen(AUTOUPD_TITLE_TARGET_PATH);
		if (dwSize >= *pcbTargetDirectory)
			goto Error;

		strcpy(szTargetDirectory, AUTOUPD_TITLE_TARGET_PATH);
		*pcbTargetDirectory = dwSize;
		break;
		
	case dirtypeDashUpdate0:
	case dirtypeDashUpdate1:

		// Target is dash update
		dwSize = strlen(AUTOUPD_DASH_TARGET_PATH);
		if (dwSize >= *pcbTargetDirectory)
			goto Error;

		*pcbTargetDirectory = sprintf(
					szTargetDirectory,
					AUTOUPD_DASH_TARGET_PATH,
					(dirtype==dirtypeDashUpdate0)?'0':'1');
		break;
		
	case dirtypeTempDiff:

		// Target is temp directory for file diffs
		dwSize = strlen(AUTOUPD_TEMP_DIFF);
		if (dwSize >= *pcbTargetDirectory)
			goto Error;

		strcpy(szTargetDirectory, AUTOUPD_TEMP_DIFF);
		*pcbTargetDirectory = dwSize;
		break;
		
	case dirtypeTempUpdate:

		// Target is temp directory for expanded dash files
		dwSize = strlen(AUTOUPD_TEMP_UPDATE);
		if (dwSize >= *pcbTargetDirectory)
			goto Error;

		strcpy(szTargetDirectory, AUTOUPD_TEMP_UPDATE);
		*pcbTargetDirectory = dwSize;
		break;

	case dirtypeDashRoot:

		// Target is the root of dash
		dwSize = strlen(AUTOUPD_DASH_ROOT);
		if (dwSize >= *pcbTargetDirectory)
			goto Error;

		strcpy(szTargetDirectory, AUTOUPD_DASH_ROOT);
		*pcbTargetDirectory = dwSize;
		break;

	case dirtypeDVDTitleRoot:

		// Target is the root of dash
		dwSize = strlen(AUTOUPD_DVD_TITLE_ROOT);
		if (dwSize >= *pcbTargetDirectory)
			goto Error;

		strcpy(szTargetDirectory, AUTOUPD_DVD_TITLE_ROOT);
		*pcbTargetDirectory = dwSize;
		break;

	case dirtypeTitleContentOnF:
	
		// Target is title update
		dwSize = strlen(XONLINECONTENT_TITLE_CONTENT_F) + 8;
		if (dwSize >= *pcbTargetDirectory)
			goto Error;

		sprintf(szTargetDirectory, XONLINECONTENT_TITLE_CONTENT_F,
					OfferingId, dwBitFlags);
		*pcbTargetDirectory = dwSize;
		break;
		
	default:
		AssertSz(FALSE, "BuildTargetDirectory: Bad dirtype");
	}

	return(S_OK);
	
Error:
	*pcbTargetDirectory = dwSize;
	return(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));
}

//
// Builds the target file path
//
// Note: Coming in, *pcbTargetDirectory must count the NULL terminator,
// coming out, *pcbTargetDirectory does NOT include NULL terminator
//
HRESULT BuildTargetPath(
			DWORD				dwTitleId,
			XONLINEOFFERING_ID	OfferingId,
			DWORD				dwBitFlags,
			CHAR				*szPostfix,
			XONLINEDIR_TYPE		dirtype,
			DWORD				*pcbTargetPath,
			CHAR				*szTargetPath
			)
{
	HRESULT	hr = S_OK;
	DWORD	dwLength;
	DWORD	cbPostfix;

	// Build the directory portion
	dwLength = *pcbTargetPath;
	cbPostfix = strlen(szPostfix);

	// Build target base directory
	hr = BuildTargetDirectory(dwTitleId, OfferingId, dwBitFlags,
				dirtype, &dwLength, szTargetPath);
	if (FAILED(hr))
		goto Error;

	(*pcbTargetPath) -= dwLength;
	szTargetPath += dwLength;

	// Check size
	if ((*pcbTargetPath) <= cbPostfix)
	{
		hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
		goto Error;
	}

	// Copy the postfix path over
	strcpy(szTargetPath, szPostfix);

Error:
	*pcbTargetPath = dwLength + cbPostfix;
	return(hr);
}

//
// This function first locates the content path for the specified
// content offering, then uses that path to build a full path to 
// the specified file. This function fails if a content directory 
// does not exist for the specified content offering.
//
HRESULT CXo::BuildExistingContentPath(
			DWORD				dwTitleId,
			XONLINEOFFERING_ID	OfferingId,
			CHAR				*szPostfix,
			XONLINEDIR_TYPE		dirtype,
			DWORD				*pcbTargetPath,
			CHAR				*szTargetPath
			)
{
	HRESULT	hr = S_OK;
	DWORD	dwLength;
	DWORD	cbPostfix;

	// Only support content offerings
    Assert((dirtype == dirtypeTitleContent) || (dirtype == dirtypeUserContent));

	// Build the directory portion
	dwLength = *pcbTargetPath;
	cbPostfix = strlen(szPostfix);

	// Find the base directory for the content
	hr = XOnlineContentGetRootDirectory(
				OfferingId, 
				(dirtype == dirtypeUserContent),
				&dwLength,
				szTargetPath);
	if (FAILED(hr))
		goto Error;

	// Append the specified postfix
	if ((dwLength + cbPostfix) >= (*pcbTargetPath))
	{
		hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
		goto Error;
	}
	strcpy(szTargetPath + dwLength, szPostfix);

Error:
	*pcbTargetPath = dwLength + cbPostfix;
	return(hr);
}

//
// Function to set the end-of-file position
//
HRESULT CXo::SetEndOfFileNt(
			HANDLE	hFile,
			DWORD	dwSize
			)
{
	FILE_END_OF_FILE_INFORMATION	feofi;
	IO_STATUS_BLOCK					iosb;
	NTSTATUS						Status;

	// Set the end of file location to the file size we need
	feofi.EndOfFile.QuadPart = dwSize;
	Status = NtSetInformationFile(hFile, 
				&iosb, 
				(PVOID)&feofi, sizeof(FILE_END_OF_FILE_INFORMATION),
				FileEndOfFileInformation);
    if (!NT_SUCCESS(Status)) 
		return(HRESULT_FROM_WIN32(RtlNtStatusToDosError(Status)));
	return(S_OK);
}

//
// Function to convert a hex string to a ULONGLONG
//
HRESULT CXo::HexStringToUlonglong(
			PSTR		szHexValue,
			DWORD		cbHexValue,
			ULONGLONG	*pullValue
			)
{
	ULONGLONG	ull = 0;
	DWORD 		i, c, len;

	len = cbHexValue?cbHexValue:strlen(szHexValue);
	if (len <= 16)
	{
		for (i = 0; i < len; i++)
		{
			c = szHexValue[(len - 1) - i];
			if ((c >= '0') && (c <= '9'))
				c = c - '0';
			else if ((c >= 'a') && ( c <= 'f'))
				c = (c - 'a') + 10;
			else if ((c >= 'A') && ( c <= 'F'))
				c = (c - 'A') + 10;
			else
				goto Error;
				
			ull |= (c << (i * 4));
		}

		*pullValue = ull;
		return(S_OK);
	}

Error:	
	return(HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
}

//
// Function to determine if a directory name is a valid title ID.
// If so, then the directory name will be converted to the Title ID 
// value. Otherwise, this function will return ERROR_INVALID_DATA.
//
HRESULT CXo::ConvertToTitleId(
			PSTR	szTitleId,
			DWORD	*pdwTitleId
			)
{
	HRESULT		hr;
	ULONGLONG	ull;
	hr = HexStringToUlonglong(szTitleId, 8, &ull);
	*pdwTitleId = (DWORD)ull;
	return(hr);
}

//
// Function to determine if a directory name is a valid offering ID.
// If so, then the directory name will be converted to the offering ID 
// value. Otherwise, this function will return ERROR_INVALID_DATA.
//
HRESULT CXo::ConvertToOfferingId(
			PSTR				szOfferingId,
			XONLINEOFFERING_ID	*pOfferingId
			)
{
	HRESULT		hr;
	ULONGLONG	ull;
	hr = HexStringToUlonglong(szOfferingId, 8, &ull);
	*pOfferingId = (DWORD)ull;
	return(hr);
}


//
// Function to parse a content directory name, validating and splitting
// it into its components
//
HRESULT CXo::ParseContentDirName(
			PSTR				szContentDir,
			XONLINEOFFERING_ID	*pOfferingId,
			DWORD				*pdwBitFilter
			)
{
	HRESULT	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	PSTR	pTemp = strchr(szContentDir, '.');

	if (pTemp)
	{
		*pTemp++ = '\0';
		hr = ConvertToOfferingId(szContentDir, pOfferingId);
		if (FAILED(hr))
			goto Error;

		hr = ConvertToTitleId(pTemp, pdwBitFilter);
		if (FAILED(hr))
			goto Error;
	}

Error:	
	return(hr);
}

//
// Function to kick off a referral request given an offering ID
// and a pointer to the XONLINETASK_CONTENT_DOWNLOAD data structure
// that is initiating this content referral action.
//
// Note that the xrlasync member of pcontdl must already been filled in 
// because this function will refer to members in pcontdl->xrlasync. In
// particular, the hEventWorkAvailable field.
//
HRESULT CXo::InitiateReferralRequest(
			XONLINEOFFERING_ID				OfferingId,
			PXONLINETASK_CONTENT_DOWNLOAD	pcontdl
			)
{
    HRESULT hr;
	PXRL_ASYNC_EXTENDED				pxrlasyncextCatref;
	XONLINE_SERVICE_INFO			serviceCatref;
	PXONLINECONTENT_REFERRAL_REQ	prefreq;
	PXONLINE_USER					pusers;
	CHAR							szContentType[XONLINE_MAX_CONTENT_TYPE_SIZE];
	DWORD							cbContentType;
	DWORD							i;
	
	Assert(pcontdl != NULL);

	// Set up the async context and the service
	pxrlasyncextCatref = &pcontdl->xrlasyncCatref;

	// Fill in the request data. We hijack the general buffer as the
	// request buffer
	prefreq = (PXONLINECONTENT_REFERRAL_REQ)(pcontdl->install.rgbBuffer);
	prefreq->Header.cbSize = sizeof(XONLINECONTENT_REFERRAL_REQ);
	prefreq->Header.dwReserved = 0;
	prefreq->dwTitleId = pcontdl->install.dwTitleId;
	prefreq->OfferingId = OfferingId;
	prefreq->dwRating = XGetParentalControlSetting();
	prefreq->MachineId = 0; // BUGBUG: Tony will provide API

	// Now get the user credentials
	pusers = XOnlineGetLogonUsers();
	for (i = 0; i < XONLINE_MAX_LOGON_USERS; i++)
	{
		// If the user is a guest then s/he has no rights
		if (!pusers)
			prefreq->Puid[i] = 0;
		else if (XOnlineIsUserGuest(pusers[i].xuid.dwUserFlags))
			prefreq->Puid[i] = 0;
		else
			prefreq->Puid[i] = pusers[i].xuid.qwUserID;
	}

	// Build the content type header
	cbContentType = sprintf(szContentType, 
				"Content-type: xon/%x\r\n", XONLINE_BILLING_OFFERING_SERVICE);

	// Kick off the data upload, note we use the LZX decompression
	// buffer as the scratch pad
	return(UploadFromMemoryInternal(
				XONLINE_BILLING_OFFERING_SERVICE,
				XONLINECONTENT_REFERRAL_XRL,
				pcontdl->install.rgbDecompress,
				XONLINECONTENT_LZX_OUTPUT_SIZE,
				(PBYTE)szContentType,
				cbContentType,
				(PBYTE)prefreq,
				prefreq->Header.cbSize,
				XONLINECONTENT_REFERRAL_TIMEOUT,
				pcontdl->xrlasync.xontask.hEventWorkAvailable,
				pxrlasyncextCatref));
}

//
// Function to parse referral results for both download referrals
// and autoupdate referrals.
//
HRESULT CXo::ParseReferralResults(
			PXONLINETASK_CONTENT_DOWNLOAD	pcontdl,
			PBYTE							pbBuffer,
			DWORD							cbBuffer
			)
{
	HRESULT					hr = S_OK;
	PXONLINECONTENT_INSTALL	pinstall;
	PXONLINEREFERRAL_RESP	presphdr;
	PXONLINE_SERVICE_INFO	pxsi;
	PBYTE					pbURI;
	DWORD					cbURI;
	PBYTE					pbHost;
	DWORD					cbHost;
	DWORD					dwEnd;
	DWORD					i;
	ULARGE_INTEGER			uliFreeSpace;
	ULARGE_INTEGER			uliTotalSpace;
	PXONLINEREFERRAL_LOCATION	plocation;
	PXONLINEREFERRAL_LOCATION	pcurloc = NULL;

	Assert(pcontdl != NULL);
	Assert(pbBuffer != NULL);

	pinstall = &pcontdl->install;

	// Over lay the data structure on the buffer and extract the
	// results.
	presphdr = (PXONLINEREFERRAL_RESP)pbBuffer;

	// Do some validation. Since the data came from the wire, we 
	// will actually do run-time validation and fail if anything 
	// looks fishy. 
	if (presphdr->Header.cbSize != cbBuffer)
		goto InvalidData;
	if (presphdr->cLocations == 0)
		goto InvalidData;
	if (presphdr->cLocations <= pinstall->dwLastXrl)
		pinstall->dwLastXrl = 0;

	// Symmetric Key
	memcpy(pinstall->rgbSymmetricKey, 
				presphdr->rgbSymKey, XONLINEREFERRAL_SYM_KEY_SIZE);

	// Public Key
	memcpy(pinstall->rgbPublicKey, 
				presphdr->rgbPubKey, XONLINEREFERRAL_PUB_KEY_SIZE);

	// Package bit flags
	pinstall->dwBitFlags = presphdr->dwBitFlags;

	// Package size
	pinstall->dwPackageSize = presphdr->dwPackageSize;
	pinstall->dwInstallSize = presphdr->dwInstallSize;

	// OK, now we check to make sure there is sufficient disk space
	// for this package. Note if GetDiskFreeSpace fails, we will go 
	// ahead and install this simply because it's a better experience
	// than a cryptic error message. If the disk becomes full, then
	// ERROR_DISK_FULL will be returned later in XOnlineTaskContinue.
	if (GetDiskFreeSpaceEx("T:\\", &uliFreeSpace, &uliTotalSpace, NULL))
	{
		// See if there is sufficient space, note that install size is 
		// ,resured in blocks
		if ((uliFreeSpace.QuadPart / XBOX_CLUSTER_SIZE) < presphdr->dwInstallSize)
		{
			hr = HRESULT_FROM_WIN32(ERROR_DISK_FULL);
			goto Error;
		}
	}

	// The XRL locations are a packed array of XONLINEREFERRAL_LOCATION
	Assert(pinstall->dwLastXrl < presphdr->cLocations);
	
	dwEnd = sizeof(XONLINEREFERRAL_RESP);
	for (i = 0; i < presphdr->cLocations; i++)
	{
		plocation = (PXONLINEREFERRAL_LOCATION)(pbBuffer + dwEnd);
		dwEnd += (sizeof(WORD) + sizeof(WORD) + plocation->cbXrl);

		if (dwEnd > cbBuffer)
			goto InvalidData;
		if (plocation->cbXrl == 0)
			goto InvalidData;
		if (plocation->cbXrl > XONLINEREFERRAL_MAX_XRL_SIZE)
			goto InvalidData;
		if (pbBuffer[dwEnd - 1] != '\0')
			goto InvalidData;

		// Skip the ones that we already tried
		if (i >= pinstall->dwLastXrl)
		{
			// OK, extract the information into pcontdl.

			// XRL path to the content
			pbHost = (PBYTE)plocation->szXrl;
			cbHost = plocation->cbXrl - 1;
			hr = XRL_SkipToURI(pbHost, cbHost, &pbURI, &cbURI);
			if (FAILED(hr))
				continue;

			// Make sure we got a host
			if ((pbURI == pbHost) || (cbURI == 0))
				continue;

			// Copy the URI over
			memcpy(pinstall->szResourcePath, pbURI, cbURI);
			pinstall->szResourcePath[cbURI] = '\0';

			// Convert the host string to an IP address
			hr = XRL_ConvertToIPAddressAndPort(pbHost, cbHost - cbURI, 
						&(pinstall->xsiDownload.serviceIP.s_addr),
						&(pinstall->xsiDownload.wServicePort));
			if (FAILED(hr))
				continue;

			// Fill in the rest of the download service info
			pinstall->xsiDownload.dwServiceID = 0;
			pinstall->xsiDownload.wReserved = 0;

			// OK, done our best-effort verification, assign the donwload
			// service to our xrlasync structure
			RtlCopyMemory( &pcontdl->xrlasync.serviceInfo, &(pinstall->xsiDownload), sizeof(pcontdl->xrlasync.serviceInfo) );

			TraceSz2(Verbose, "Referral: downloading: %s on port %u\r\n", 
						pbHost, pinstall->xsiDownload.wServicePort);

			// Bump the XRL so we will try something else the next time
			pinstall->dwLastXrl = (i + 1);

			// Found a candidate, break out
			break;
		}
	}

	// If none of the XRLs are good then we fail
	if (i >= presphdr->cLocations)
		goto InvalidData;

	hr = S_OK;

Exit:
	return(hr);

Error:
	goto Exit;

InvalidData:
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	goto Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\decout.cpp ===
/*
 * decout.c
 *
 * Decoder outputting
 */

#include "xonp.h"
#include "xonver.h"

void copy_data_to_output(t_decoder_context *context, long amount, const byte *data)
{
    if (context->dec_output_buffer == NULL)
        return;

    memcpy(
        context->dec_output_buffer,
        data,
        amount
    );

    /* perform jump translation */
    if ((context->dec_current_file_size != 0) && (context->dec_num_cfdata_frames < E8_CFDATA_FRAME_THRESHOLD))
    {
        decoder_translate_e8(
            context,
            context->dec_output_buffer,
            amount
        );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\decuncmp.cpp ===
/*
 * decuncmp.c
 *
 * Decoding uncompressed blocks
 */

#include "xonp.h"
#include "xonver.h"

int decode_uncompressed_block(t_decoder_context *context, long bufpos, int amount_to_decode)
{
	long	bytes_decoded = 0;
	long	bufpos_end;
	long	decode_residue;
    ulong   bufpos_start;
    ulong   end_copy_pos;
    byte *  p;

    bufpos_start = bufpos;
	bufpos_end = bufpos + amount_to_decode;

    p = context->dec_input_curpos;

	while (bufpos < bufpos_end)
	{
        if (p >= context->dec_end_input_pos)
		return -1; // input overflow

#ifdef TRACING
		TracingLiteral(bufpos, *p);
#endif
		context->dec_mem_window[bufpos++] = *p++;
	}

    context->dec_input_curpos = p;

    /*
     * Make sure the MAX_MATCH bytes starting at window[window_size]
     * are always the same as the first MAX_MATCH bytes starting at
     * window[0].  This is for our optimisation in decverb.c and
     * decalign.c which allows us to not have to & window_mask all the
     * time.
     */
    end_copy_pos = min(MAX_MATCH, bufpos_end);

    /*
     * Keep copying until we hit MAX_MATCH or the number of bytes
     * we decoded
     */
    while (bufpos_start < end_copy_pos)
    {
        context->dec_mem_window[bufpos_start + context->dec_window_size] =
            context->dec_mem_window[bufpos_start];
        bufpos_start++;
    }

	decode_residue = bufpos - bufpos_end;

	bufpos &= context->dec_window_mask;
	context->dec_bufpos = bufpos;

    return (int) decode_residue;
}


bool handle_beginning_of_uncompressed_block(t_decoder_context *context)
{
    int     i;

    /*
     * we want to read the 16 bits already in bitbuf, so backtrack
     * the input pointer by 2 bytes.
     */
    context->dec_input_curpos -= 2;

    if (context->dec_input_curpos+4 >= context->dec_end_input_pos)
        return false;

	/*
	 * update LRU repeated offset list
	 */
    for (i = 0; i < NUM_REPEATED_OFFSETS; i++)
    {
        context->dec_last_matchpos_offset[i] =
            ((ulong) *(  (byte *) context->dec_input_curpos)    )        |
            ((ulong) *( ((byte *) context->dec_input_curpos) + 1) << 8)  |
            ((ulong) *( ((byte *) context->dec_input_curpos) + 2) << 16) |
            ((ulong) *( ((byte *) context->dec_input_curpos) + 3) << 24);

        context->dec_input_curpos += 4; /* increment by 4 bytes */
    }

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\dectree.cpp ===
/*
 * dectree.c
 *
 * Decoding the encoded tree structures
 *
 * To save much code size, the fillbuf()/getbits() calls have
 * been made into functions, rather than being inlined macros.
 * The macros actually take up a lot of space.  There is no
 * performance loss from doing so here.
 */
#include "xonp.h"
#include "xonver.h"

/* number of elements in pre-tree */
#define NUM_DECODE_SMALL	20

/* lookup table size */
#define DS_TABLE_BITS		8

/* macro to decode a pre-tree element */
#define DECODE_SMALL(item) \
{ \
	item = small_table[context->dec_bitbuf >> (32-DS_TABLE_BITS) ]; \
	if (item < 0)								\
	{											\
      mask = (1L << (32-1-DS_TABLE_BITS));      \
      do										\
      {											\
			item = -item;						\
            if (context->dec_bitbuf & mask)     \
				item = leftright_s[2*item+1];	\
			else								\
				item = leftright_s[2*item];		\
			mask >>= 1;							\
		} while (item < 0);						\
   }											\
   fillbuf(context, small_bitlen[item]);		\
}

/*
 * Reads a compressed tree structure
 */
static bool NEAR ReadRepTree(
	t_decoder_context	*context,
	int					num_elements,
	byte				*lastlen,
	byte				*len
)
{
	ulong	mask;
	int		i;
	int		consecutive;
	byte	small_bitlen[24];
	short	small_table[1 << DS_TABLE_BITS];
	short	leftright_s [2*(2 * 24 - 1)];
	short	Temp;

	/* Declare this inline to help compilers see the optimisation */
	static const byte Modulo17Lookup[] =
	{
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16
	};

	/* read pre-tree */
	for (i = 0; i < NUM_DECODE_SMALL; i++)
	{
		small_bitlen[i] = (byte) getbits(context, 4);
	}

    /* exceeded input buffer? */
    if (context->dec_error_condition)
        return false;

	/* make a table for this pre-tree */
	make_table(
		context,
		NUM_DECODE_SMALL, 
		small_bitlen, 
		DS_TABLE_BITS, 
		small_table, 
		leftright_s
	);

	for (i = 0; i < num_elements; i++)
	{
		DECODE_SMALL(Temp);

        /* exceeded input buffer? */
        if (context->dec_error_condition)
            return false;

		/* Repeat "TREE_ENC_REP_MIN...TREE_ENC_REP_MIN+(1<<TREE_ENC_REPZ_FIRST_EXTRA_BITS)-1" zeroes */
		if (Temp == 17)
		{
			/* code 17 means "a small number of repeated zeroes" */
			consecutive = (byte) getbits(context, TREE_ENC_REPZ_FIRST_EXTRA_BITS);
			consecutive += TREE_ENC_REP_MIN;

			/* boundary check */
			if (i + consecutive >= num_elements)
				consecutive = num_elements-i;

			while (consecutive-- > 0)
				len[i++] = 0;

			i--;
		}
		else if (Temp == 18)
		{
			/* code 18 means "a large number of repeated zeroes" */

			/* Repeat "TREE_ENC_REP_MIN+(1<<TREE_ENC_REPZ_FIRST_EXTRA_BITS)-1...<ditto>+(1<<TREE_ENC_REPZ_SECOND_EXTRA_BITS)-1" zeroes */
			consecutive = (byte) getbits(context, TREE_ENC_REPZ_SECOND_EXTRA_BITS);
			consecutive += (TREE_ENC_REP_MIN+TREE_ENC_REP_ZERO_FIRST);

			/* boundary check */
			if (i + consecutive >= num_elements)
				consecutive = num_elements-i;

			while (consecutive-- > 0)
				len[i++] = 0;

			i--;
		}
		else if (Temp == 19)
		{
			byte	value;

			/* code 19 means "a small number of repeated somethings" */
			/* Repeat "TREE_ENC_REP_MIN...TREE_ENC_REP_MIN+(1<<TREE_ENC_REP_SAME_EXTRA_BITS)-1" elements */
			consecutive = (byte) getbits(context, TREE_ENC_REP_SAME_EXTRA_BITS);
			consecutive += TREE_ENC_REP_MIN;

			/* boundary check */
			if (i + consecutive >= num_elements)
				consecutive = num_elements-i;

			/* get the element number to repeat */
			DECODE_SMALL(Temp);
			value = Modulo17Lookup[(lastlen[i] - Temp)+17];

			while (consecutive-- > 0)
				len[i++] = value;

			i--;
		}
		else
		{
			len[i] = Modulo17Lookup[(lastlen[i] - Temp)+17];
		}
	}

    /* exceeded input buffer? */
    if (context->dec_error_condition)
        return false;
    else
        return true;
}


bool NEAR read_main_and_secondary_trees(t_decoder_context *context)
{
	/* read first 256 elements (characters) of the main tree */
    if (false == ReadRepTree(
		context,
		256, 
        context->dec_main_tree_prev_len, 
        context->dec_main_tree_len))
    {
        return false;
    }

	/*
	 * read remaining elements (primary match lengths * positions)
	 * of the main tree
	 */
    if (false == ReadRepTree(
		context,
		context->dec_num_position_slots*NUM_LENGTHS, 
        &context->dec_main_tree_prev_len[256], 
        &context->dec_main_tree_len[256]))
    {
        return false;
    }

	/* create lookup table for the main tree */
    if (false == make_table(
		context,
		MAIN_TREE_ELEMENTS, 
        context->dec_main_tree_len, 
		MAIN_TREE_TABLE_BITS,
        context->dec_main_tree_table, 
        context->dec_main_tree_left_right))
    {
        return false;
    }

	/* read secondary length tree */
    if (false == ReadRepTree(
		context,
		NUM_SECONDARY_LENGTHS, 
        context->dec_secondary_length_tree_prev_len, 
        context->dec_secondary_length_tree_len))
    {
        return false;
    }

	/* create lookup table for the secondary length tree */
    if (false == make_table(
		context,
		NUM_SECONDARY_LENGTHS, 
        context->dec_secondary_length_tree_len, 
		SECONDARY_LEN_TREE_TABLE_BITS,
        context->dec_secondary_length_tree_table,
        context->dec_secondary_length_tree_left_right))
    {
        return false;
    }

    return true;
}


/* read 8 element aligned offset tree */
bool NEAR read_aligned_offset_tree(t_decoder_context *context)
{
	int		i;

	/* read bit lengths of the 8 codes */
	for (i = 0; i < 8; i++)
	{
        context->dec_aligned_len[i] = (byte) getbits(context, 3);
	}

    if (context->dec_error_condition)
        return false;

	/*
	 * Make table with no left/right, and byte Table[] instead of
	 * short Table[]
	 */
    if (false == make_table_8bit(
		context,
        context->dec_aligned_len, 
        (byte *) context->dec_aligned_table))
    {
        return false;
    }

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\decverb.cpp ===
/*
 * decverb.c
 *
 * Decoding verbatim-bit blocks
 */

#include "xonp.h"
#include "xonver.h"

static long special_decode_verbatim_block(
    t_decoder_context   *context,
    long                BufPos,
    int                 amount_to_decode
)
{
	ulong	match_pos;
	long    bufpos_end;
	int		match_length;
	int		c;
	ulong	dec_bitbuf;
	byte    *dec_input_curpos;
	byte    *dec_end_input_pos;
	byte	*dec_mem_window;
	char	dec_bitcount;
	ulong	m;

	/*
	 * Store commonly used variables locally
	 */
	dec_bitcount	  = context->dec_bitcount;
	dec_bitbuf		  = context->dec_bitbuf;
	dec_input_curpos  = context->dec_input_curpos;
	dec_end_input_pos = context->dec_end_input_pos;
	dec_mem_window	  = context->dec_mem_window;

    bufpos_end = BufPos + amount_to_decode;

    /*
     * We may overflow by up to MAX_MATCH
     */
    while (BufPos < bufpos_end)
	{
		/* decode an item from the main tree */
		DECODE_MAIN_TREE(c);

		if ((c -= NUM_CHARS) < 0)
		{
	 		/*	it's a character */
			/* note: c - 256 == c if c is a byte */
#ifdef TRACING
            TracingLiteral(BufPos, (byte) c);
#endif
            context->dec_mem_window[BufPos] = (byte) c;

            /* we know BufPos < bufpos_end here, so no need to check for overflow */
            context->dec_mem_window[context->dec_window_size+BufPos] = (byte) c;
            BufPos++;
		}
		else
		{
	 		/* get match length header */
			if ((match_length = c & NUM_PRIMARY_LENGTHS) == NUM_PRIMARY_LENGTHS)
			{
				/* get match length footer if necessary */
				DECODE_LEN_TREE_NOEOFCHECK(match_length);
			}

			/* get match position slot */
			m = c >> NL_SHIFT;

	  		/* read any extra bits for the match position */
			if (m > 2) 
			{
				if (m > 3) /* dec_extra_bits[m] != 0 */
				{
	    			GET_BITS17_NOEOFCHECK(dec_extra_bits[ m ], match_pos);
					match_pos += MP_POS_minus2[m];
				}
				else
				{
                    match_pos = 1; // MP_POS_minus2[3];
				}

				/*
				 * Add match base to "extra bits".  Our match base
				 * table has 2 subtracted from all the elements.
				 *
				 * This is because encoded positions 0,1,2 denote
				 * repeated offsets.  Encoded position 3 denotes
				 * a match 1 character away, 4 encodes 2 away, etc.  
				 * Hence the subtraction of 2, which has been
				 * incorporated into the table.
				 */

				/* update LRU repeated offset list */
				context->dec_last_matchpos_offset[2] = context->dec_last_matchpos_offset[1];
				context->dec_last_matchpos_offset[1] = context->dec_last_matchpos_offset[0];
				context->dec_last_matchpos_offset[0] = match_pos;
			}
			else
	 		{
				/* positions 0, 1, 2 denote repeated offsets */
				match_pos = context->dec_last_matchpos_offset[m];

				if (m)
				{
					context->dec_last_matchpos_offset[m] = context->dec_last_matchpos_offset[0];
					context->dec_last_matchpos_offset[0] = match_pos;
				}
	 		}

			/* match lengths range from 2...257 */
			match_length += MIN_MATCH; 

			if (context->dec_extra_long_matches)
			{
				if ( match_length == MAX_MATCH ) {

				//
				//  See detailed explanation in decalign.c
				//

				ULONG ExtraMatchLength, ExtraMatchLengthResidue;

				GET_BITS_NOEOFCHECK( 9, ExtraMatchLength );

				if ( ExtraMatchLength & ( 1 << 8 )) {
				    if ( ExtraMatchLength & ( 1 << 7 )) {
				        if ( ExtraMatchLength & ( 1 << 6 )) {
				            ExtraMatchLength = ( ExtraMatchLength & (( 1 << 6 ) - 1 )) << 9;
				            GET_BITS_NOEOFCHECK( 9, ExtraMatchLengthResidue );
				            ExtraMatchLength |= ExtraMatchLengthResidue;
				            }
				        else {
				            ExtraMatchLength = ( ExtraMatchLength & (( 1 << 6 ) - 1 )) << 6;
				            GET_BITS_NOEOFCHECK( 6, ExtraMatchLengthResidue );
				            ExtraMatchLength |= ExtraMatchLengthResidue;
				            ExtraMatchLength += ( 1 << 8 ) + ( 1 << 10 );
				            }
				        }
				    else {
				        ExtraMatchLength = ( ExtraMatchLength & (( 1 << 7 ) - 1 )) << 3;
				        GET_BITS_NOEOFCHECK( 3, ExtraMatchLengthResidue );
				        ExtraMatchLength |= ExtraMatchLengthResidue;
				        ExtraMatchLength += ( 1 << 8 );
				        }
				    }

				match_length += ExtraMatchLength;
				}
			}
			
#ifdef TRACING
			TracingMatch(BufPos,
				BufPos - match_pos,
				context->dec_window_size,
				match_length,
				m);
#endif

			/* copy match data */
			do
			{
				context->dec_mem_window[BufPos] = context->dec_mem_window[(BufPos-match_pos) & context->dec_window_mask];

                /* replicate bytes */
                if (BufPos < MAX_MATCH) // BUGBUG: what does this do?  Does it need to be more than MAX_MATCH now?
                    context->dec_mem_window[context->dec_window_size+BufPos] = context->dec_mem_window[BufPos];

				BufPos++;
			} while (--match_length > 0);
		}
	}

	context->dec_bitcount	  = dec_bitcount;
	context->dec_bitbuf		  = dec_bitbuf;
	context->dec_input_curpos = dec_input_curpos;

    return BufPos;
}


long fast_decode_verbatim_block(t_decoder_context *context, long BufPos, int amount_to_decode)
{
	ulong	match_pos;
	ulong	match_ptr;
	long	bufpos_end;
	long	decode_residue;
	int		match_length;
	int		c;
	ulong	dec_bitbuf;
    byte   *dec_input_curpos;
    byte   *dec_end_input_pos;
	byte	*dec_mem_window;
	char	dec_bitcount;
	ulong	m;

	/*
	 * Store commonly used variables locally
	 */
	dec_bitcount	  = context->dec_bitcount;
	dec_bitbuf		  = context->dec_bitbuf;
	dec_input_curpos  = context->dec_input_curpos;
	dec_end_input_pos = context->dec_end_input_pos;
	dec_mem_window	  = context->dec_mem_window;

	bufpos_end = BufPos + amount_to_decode;

	while (BufPos < bufpos_end)
	{
		/* decode an item from the main tree */
		DECODE_MAIN_TREE(c);

		if ((c -= NUM_CHARS) < 0)
		{
	 		/*	it's a character */
			/* note: c - 256 == c if c is a byte */
#ifdef TRACING
			TracingLiteral(BufPos, (byte) c);
#endif
			context->dec_mem_window[BufPos++] = (byte) c;
		}
		else
		{
	 		/* get match length header */
			if ((match_length = c & NUM_PRIMARY_LENGTHS) == NUM_PRIMARY_LENGTHS)
			{
				/* get match length footer if necessary */
				DECODE_LEN_TREE_NOEOFCHECK(match_length);
			}

			/* get match position slot */
			m = c >> NL_SHIFT;

	  		/* read any extra bits for the match position */
			if (m > 2) 
			{
				if (m > 3) /* dec_extra_bits[m] != 0 */
				{
	    			GET_BITS17_NOEOFCHECK(dec_extra_bits[ m ], match_pos);
					match_pos += MP_POS_minus2[m];
				}
				else
				{
					match_pos = MP_POS_minus2[3];
				}

				/*
				 * Add match base to "extra bits".  Our match base
				 * table has 2 subtracted from all the elements.
				 *
				 * This is because encoded positions 0,1,2 denote
				 * repeated offsets.  Encoded position 3 denotes
				 * a match 1 character away, 4 encodes 2 away, etc.  
				 * Hence the subtraction of 2, which has been
				 * incorporated into the table.
				 */

				/* update LRU repeated offset list */
				context->dec_last_matchpos_offset[2] = context->dec_last_matchpos_offset[1];
				context->dec_last_matchpos_offset[1] = context->dec_last_matchpos_offset[0];
				context->dec_last_matchpos_offset[0] = match_pos;
			}
			else
	 		{
				/* positions 0, 1, 2 denote repeated offsets */
				match_pos = context->dec_last_matchpos_offset[m];

				if (m)
				{
					context->dec_last_matchpos_offset[m] = context->dec_last_matchpos_offset[0];
					context->dec_last_matchpos_offset[0] = match_pos;
				}
	 		}

			/* match lengths range from 2...257 */
			match_length += MIN_MATCH; 
			
			if (context->dec_extra_long_matches)
			{
				if ( match_length == MAX_MATCH ) {

				//
				//  See detailed explanation in decalign.c
				//

				ULONG ExtraMatchLength, ExtraMatchLengthResidue;

				GET_BITS_NOEOFCHECK( 9, ExtraMatchLength );

				if ( ExtraMatchLength & ( 1 << 8 )) {
				    if ( ExtraMatchLength & ( 1 << 7 )) {
				        if ( ExtraMatchLength & ( 1 << 6 )) {
				            ExtraMatchLength = ( ExtraMatchLength & (( 1 << 6 ) - 1 )) << 9;
				            GET_BITS_NOEOFCHECK( 9, ExtraMatchLengthResidue );
				            ExtraMatchLength |= ExtraMatchLengthResidue;
				            }
				        else {
				            ExtraMatchLength = ( ExtraMatchLength & (( 1 << 6 ) - 1 )) << 6;
				            GET_BITS_NOEOFCHECK( 6, ExtraMatchLengthResidue );
				            ExtraMatchLength |= ExtraMatchLengthResidue;
				            ExtraMatchLength += ( 1 << 8 ) + ( 1 << 10 );
				            }
				        }
				    else {
				        ExtraMatchLength = ( ExtraMatchLength & (( 1 << 7 ) - 1 )) << 3;
				        GET_BITS_NOEOFCHECK( 3, ExtraMatchLengthResidue );
				        ExtraMatchLength |= ExtraMatchLengthResidue;
				        ExtraMatchLength += ( 1 << 8 );
				        }
				    }

				match_length += ExtraMatchLength;
				}
			}

#ifdef TRACING
			TracingMatch(BufPos,
				BufPos - match_pos,
				context->dec_window_size,
				match_length,
				m);
#endif

			match_ptr = (BufPos - match_pos) & context->dec_window_mask;

			/* copy match data */
			do
			{
				context->dec_mem_window[BufPos++] = context->dec_mem_window[match_ptr++];
			} while (--match_length > 0);
		}
	}

	context->dec_bitcount	  = dec_bitcount;
	context->dec_bitbuf		  = dec_bitbuf;
	context->dec_input_curpos = dec_input_curpos;

	/* should be zero */
	decode_residue = BufPos - bufpos_end;

	BufPos &= context->dec_window_mask;
	context->dec_bufpos = BufPos;

	return decode_residue;
}

int decode_verbatim_block(t_decoder_context *context, long BufPos, int amount_to_decode)
{
    /*
     * Special case code when BufPos is near the beginning of the window;
     * we must properly update our MAX_MATCH wrapper bytes.
     */
    if (BufPos < MAX_MATCH)
    {
        long    new_bufpos;
        long    amount_to_slowly_decode;

        amount_to_slowly_decode = min(MAX_MATCH-BufPos, amount_to_decode);

        /*
         * It's ok to end up decoding more than we wanted if we
         * restricted it to decoding only MAX_MATCH; there's
         * no guarantee a match doesn't straddle MAX_MATCH
         */
        new_bufpos = special_decode_verbatim_block(
            context,
            BufPos,
            amount_to_slowly_decode
        );

        amount_to_decode -= (new_bufpos-BufPos);

        context->dec_bufpos = BufPos = new_bufpos;

        /*
         * Note: if amount_to_decode < 0 then we're in trouble
         */
        if (amount_to_decode <= 0)
            return amount_to_decode;
    }

    return fast_decode_verbatim_block(context, BufPos, amount_to_decode);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\difpatch.cpp ===
/*++

Copyright (c) Microsoft Corporation

Author:
    Keith Lau (keithlau)

Description:
	Module implementing Differential compression and online updates

Module Name:

    difpatch.c

--*/

#include "xonp.h"
#include "xonver.h"

#ifdef XONLINE_FEATURE_XBOX

#include "xboxp.h"
#include "xlaunch.h"

//
// Online Autoupdate states
//
// Note: these are executed as subtasks of XOnlineContentInstall
//
typedef enum
{
	// Pre-install custom task phases
	xoupdPreInitialize = 0,
	xoupdCountFiles,			// Dash update only
	xoupdFormatTemp,
	xoupdDoneDVDPreInit,		// DVD update only

	// Post-install custom task phases
	xoupdPostInitialize,
	xoupdVerifyPatchDigest,
	xoupdVerifyTargetDigest,
	xoupdWipeTarget,
	xoupdOpenPatch,
	xoupdOpenSource,
	xoupdCreateTarget,
	xoupdCreateDirectory,
	xoupdReadSource,
	xoupdReadPatch,
	xoupdDecodeData,
	xoupdWriteTarget,
	xoupdCloseFiles,
	xoupdCopyDigest,
	xoupdCopyOtherFiles, 		// Dash update only
	xoupdSignDigest,
	xoupdWriteConfig,
	xoupdCleanupTemp,
	xoupdCleanupOfflineDashFiles,
	xoupdDone,

} AUTOUPD_ONLINE_STATES;

#if DBG
//
// String names for states
//
const char * const g_rgszxoupdStates[xoupdDone] =
{
	"xoupdPreInitialize",
	"xoupdCountFiles",
	"xoupdFormatTemp",
	"xoupdDoneDVDPreInit", 
	"xoupdPostInitialize",
	"xoupdVerifyPatchDigest",
	"xoupdVerifyTargetDigest",
	"xoupdWipeTarget",
	"xoupdOpenPatch",
	"xoupdOpenSource",
	"xoupdCreateTarget",
	"xoupdCreateDirectory",
	"xoupdReadSource",
	"xoupdReadPatch",
	"xoupdDecodeData",
	"xoupdWriteTarget",
	"xoupdCloseFiles",
	"xoupdCopyDigest",
	"xoupdCopyOtherFiles",
	"xoupdSignDigest",
	"xoupdWriteConfig",
	"xoupdCleanupTemp",
	"xoupdCleanupOfflineDashFiles"
};
#endif

//
// History window size boundaries. These should match those used 
// in the patch generation tool
//
#define AUTOUPD_MIN_WINDOW_SIZE			(1 << 17)	// 128KB
#define AUTOUPD_MAX_WINDOW_SIZE			(1 << 25)	// 32MB

//
// Max size for patch file header (64KB)
// 
// Note: this is chosen to be enough records to fill the
// hard drive twice using the formula:
// (8GB / AUTOUPD_WINDOW_SIZE) * 2 * AUTOUPD_INTERLEAVE_ENTRY + slack
//
#define AUTOUPD_FILE_MAX_HEADER_SIZE	(1 << 16)

//
// We'll set 4 chunks for the patch data buffer
//
#define AUTOUPD_PATCH_BUFFER_SIZE		(CHUNK_SIZE << 2)

//
// Patch application subtask for online autoupdate
//
struct XONLINEAUTOUPD_ONLINE
{
	XONLINETASK_CONTEXT			xontask;

	AUTOUPD_ONLINE_STATES		State;
	AUTOUPD_ONLINE_STATES		NextState;
	XONLINEDIR_TYPE				dirtypeTarget;	// Diff source (none for DVD)
	XONLINEDIR_TYPE				dirtypeSource;	// Diff/update target
	WORD						wOldVersionHi;
	WORD						wOldVersionLo;

	// Bit flags
	BOOL						fFirstDashUpdate:1;
	BOOL						fFDriveMounted:1;

	// Current patch file header information
	PAUTOUPD_PATCH_FILE_INFO	papfInfo;
	DWORD						cbapfInfo;

	// Current file info
	PSTR						szCurrentFile;
	PDGSTFILE_FILE_DATA			pdfdPatch;
	PDGSTFILE_FILE_DATA			pdfdTarget;
	DWORD						dwSourceSize;
	DWORD						cbDecoded;

	// Contexts for enumerating digest entries
	DWORD						cbPatchDigest;
	DWORD						cbTargetDigest;
	DGSTFILE_ENUM_CONTEXT		dgstenumPatch;
	DGSTFILE_ENUM_CONTEXT		dgstenumTarget;

	// File handles for the three-way patch files
	HANDLE						hPatch;
	HANDLE						hSource;
	HANDLE						hTarget;

	// Context for tracking progress
	AUTOUPD_PROGRESS_CONTEXT	progress;

	// Context for offline dash removal
	XONLINETASK_DEL_OLD_DASH	xondod;
	
	// Task context for verifying digest files
	XONLINETASK_CONTENT_VERIFY	contver;

	// Task context for directory create/remove operations
	XONLINETASK_DIROPS			dirops;

	// Task context for copying directories
	XONLINETASK_DIRCOPY			dircopy;

	// LZX decoder context
	XONLINE_LZXDECODER_CONTEXT	lzx;
	DWORD						dwWindowSize;

	// Current raw title key
	BYTE	rgbTitleKey[XBOX_KEY_LENGTH];

	// Context for calulcating SHA1 signatures
	BYTE	shactxPatch[XC_SERVICE_SHA_CONTEXT_SIZE];
	BYTE	shactxTarget[XC_SERVICE_SHA_CONTEXT_SIZE];

	// Various data buffers
	BYTE	rgbHeaderInfo[AUTOUPD_FILE_MAX_HEADER_SIZE];
	BYTE	rgbPatchDigest[XONLINECONTENT_MANIFEST_MAX_FILE_SIZE];
	BYTE	rgbTargetDigest[XONLINECONTENT_MANIFEST_MAX_FILE_SIZE];
	BYTE	rgbPatchData[AUTOUPD_PATCH_BUFFER_SIZE];
	BYTE	rgbOutput[CHUNK_SIZE];
	BYTE	rgbDecodeWindow[AUTOUPD_MAX_WINDOW_SIZE];
};

//
// Online autoupdate task context
//
struct XONLINETASK_AUTOUPD_ONLINE
{
	XONLINETASK_CONTENT_DOWNLOAD	contdl;
	XONLINEAUTOUPD_ONLINE			autoupd;	
	
};

//
// Function to return the required window size for patch application
//
#ifndef ROUNDUP2
#define ROUNDUP2(x, n) ((((ULONG)(x)) + (((ULONG)(n)) - 1 )) & ~(((ULONG)(n)) - 1 ))
#endif

DWORD AutoupdateLzxWindowSize(
			DWORD OldDataSize,
			DWORD NewDataSize
			)
{
	ULONG WindowSize;
	ULONG DataSize;

	DataSize = ROUNDUP2(OldDataSize, CHUNK_SIZE) + NewDataSize;

	if (DataSize <= AUTOUPD_MIN_WINDOW_SIZE)
		return(AUTOUPD_MIN_WINDOW_SIZE);

	WindowSize = AUTOUPD_MAX_WINDOW_SIZE;

	while ((WindowSize >> 1) >= DataSize)
		WindowSize = WindowSize >> 1;

	return(WindowSize);
}

//
// Function to kick off an autoupdate referral request given a pointer 
// to the XONLINETASK_AUTOUPD_ONLINE data structure that is initiating 
// this autoupdate referral action, the title ID, machine ID, and the
// current dash version (dash update only).
//
// Note that the xrlasync member of pxoupd->contdl must already been 
// filled in because this function will refer to members in 
// pxoupd->contdl.xrlasync. In particular, the hEventWorkAvailable field.
//
HRESULT CXo::InitiateAutoupdateReferralRequest(
			DWORD						dwTitleId,
			ULONGLONG					qwMachineId,
			DWORD						dwCurrentDashVersion,
			PXONLINETASK_AUTOUPD_ONLINE	pxoupd
			)
{
    HRESULT hr;
	PXONLINETASK_CONTENT_DOWNLOAD	pcontdl;
	PXRL_ASYNC_EXTENDED				pxrlasyncextCatref;
	XONLINE_SERVICE_INFO			serviceCatref;
	PXONLINEUPDATE_REFERRAL_REQ		prefreq;
	PXONLINE_USER					pusers;
	CHAR							szContentType[XONLINE_MAX_CONTENT_TYPE_SIZE];
	DWORD							cbContentType;
	DWORD							i;
	
	Assert(pxoupd != NULL);

	// Set up the async context and the service
	pcontdl = &pxoupd->contdl;
	pxrlasyncextCatref = &pcontdl->xrlasyncCatref;

	// Fill in the request data. We hijack the general buffer as the
	// request buffer
	prefreq = (PXONLINEUPDATE_REFERRAL_REQ)(pcontdl->install.rgbBuffer);
	prefreq->Header.cbSize = sizeof(XONLINEUPDATE_REFERRAL_REQ);
	prefreq->Header.dwReserved = 0;
	prefreq->dwTitleId = dwTitleId;
	prefreq->dwDashVersion = dwCurrentDashVersion;
	prefreq->qwMachineId = qwMachineId;

	// Build the content type header
	cbContentType = sprintf(szContentType, 
				"Content-type: xon/%x\r\n", XONLINE_AUTO_UPDATE_SERVICE);

	// Kick off the data upload, note we use the LZX decompression
	// buffer as the scratch pad
	return(UploadFromMemoryInternal(
				XONLINE_AUTO_UPDATE_SERVICE,
				XONLINEAUTOUPD_REFERRAL_XRL,
				pcontdl->install.rgbDecompress,
				XONLINECONTENT_LZX_OUTPUT_SIZE,
				(PBYTE)szContentType,
				cbContentType,
				(PBYTE)prefreq,
				prefreq->Header.cbSize,
				XONLINEAUTOUPD_REFERRAL_TIMEOUT,
				pcontdl->xrlasync.xontask.hEventWorkAvailable,
				pxrlasyncextCatref));
}

//
// Per-file task handler to count the number of files and total size
//
HRESULT CXo::UpdateOnlineCountFilesContinue(
			XONLINETASK_HANDLE	hTask
			)
{
	ULARGE_INTEGER				uliAlignedSize;
	PXONLINETASK_DIRCOPY		pdircopy;
	PXONLINEAUTOUPD_ONLINE		pautoupd;
	PAUTOUPD_PROGRESS_CONTEXT	papc;
	WIN32_FIND_DATA				*pwfd;

	Assert(hTask != NULL);

	// Locate the containing object
	pdircopy = CONTAINING_RECORD(hTask, XONLINETASK_DIRCOPY, xontaskOnFile);
	pautoupd = CONTAINING_RECORD(pdircopy, XONLINEAUTOUPD_ONLINE, dircopy);
	papc = &pautoupd->progress;
	pwfd = &(pdircopy->dircrawl.wfd);

	// Get the context (which is a progress context) and add the values
	(papc->dwFilesTotal)++;
	uliAlignedSize.u.LowPart = pwfd->nFileSizeLow;
	uliAlignedSize.u.HighPart = pwfd->nFileSizeHigh;
	papc->uliBytesTotal.QuadPart += uliAlignedSize.QuadPart;
	
	uliAlignedSize.QuadPart += (XBOX_CLUSTER_SIZE - 1);
	uliAlignedSize.QuadPart /= XBOX_CLUSTER_SIZE;
	uliAlignedSize.QuadPart *= XBOX_CLUSTER_SIZE;
	papc->uliActualBytesRequired.QuadPart += uliAlignedSize.QuadPart;

	return(XONLINETASK_S_SUCCESS);
}

//
// Implement all the state handlers
// 
HRESULT CXo::xoupdPreInitializeHandler(
			PXONLINEAUTOUPD_ONLINE	pautoupd
			)
{
	HRESULT	hr = S_OK;
	DWORD	cbSize;
	PXONLINETASK_AUTOUPD_ONLINE	ptask;
	PXONLINECONTENT_INSTALL		pinstall;

	Assert(pautoupd);

	// We need to reach in and get the content download context
	ptask = CONTAINING_RECORD(pautoupd, XONLINETASK_AUTOUPD_ONLINE, autoupd);
	pinstall = &(ptask->contdl.install);

	// Set up the progress context
	ZeroMemory(&pautoupd->progress, sizeof(AUTOUPD_PROGRESS_CONTEXT));
	pautoupd->progress.uliBytesTotal.QuadPart = pinstall->dwInstallSize;

	// Well, we need to clean up the old dash files, so
	// set up the context anyway
	hr = XOnlineUpdateDeleteOfflineDash(
				pautoupd->xontask.hEventWorkAvailable, &pautoupd->xondod);
	if (FAILED(hr))
		goto Error;

	// If we are updating from DVD, the source will be dirtypeNone. In
	// this case, we are just done preinit
	if (pautoupd->dirtypeSource == dirtypeNone)
	{
		pautoupd->State = xoupdDoneDVDPreInit;
		goto Exit;
	}

	// We do different things depending on whether this is a title update
	if (pautoupd->dirtypeTarget == dirtypeTitleUpdateOnF)
	{
		// Title update
		pautoupd->State = xoupdFormatTemp;
	}
	else
	{
		// Make sure we are doing a dash update
		Assert((pautoupd->dirtypeTarget == dirtypeDashUpdate0) ||
				(pautoupd->dirtypeTarget == dirtypeDashUpdate1));

		// Make sure the source is the other dash partition
		Assert(((pautoupd->dirtypeTarget == dirtypeDashUpdate0) &&
				(pautoupd->dirtypeSource == dirtypeDashUpdate1)) ||
				(pautoupd->dirtypeSource == dirtypeDashUpdate0));

		// Dash update, this means we will need to copy the dash
		// files over to the update target. Since this copy may take
		// quite a while, it would be nice to include this in the
		// progress indicator. We will do a quick crawl of the 
		// source dash installation to calculate how many bytes will
		// be copied so we can factor this into the progress.
		TaskInitializeContext(&pautoupd->dircopy.xontaskOnFile);
		pautoupd->dircopy.xontaskOnFile.pfnContinue = UpdateOnlineCountFilesContinue;
		pautoupd->dircopy.xontaskOnFile.hEventWorkAvailable = pautoupd->xontask.hEventWorkAvailable;

		// Compute the source location
		sprintf((char *)pautoupd->rgbOutput, AUTOUPD_DASH_TARGET_PATH, 
				(pautoupd->dirtypeSource == dirtypeDashUpdate1)?'1':'0');

		// Set up the dircrawl context to count the number of files to install
		hr = DircrawlInitializeContext(
					(char *)pautoupd->rgbOutput, NULL, MAX_PATH, 0, NULL, 
					(XONLINETASK_HANDLE)&(pautoupd->dircopy.xontaskOnFile),
					pautoupd->xontask.hEventWorkAvailable,
					&(pautoupd->dircopy.dircrawl));
		if (FAILED(hr))
			goto Error;

		pautoupd->State = xoupdCountFiles;
	}

Exit:
	return(hr);

Error:
	goto Exit;
}

HRESULT CXo::xoupdCountFilesHandler(
			PXONLINEAUTOUPD_ONLINE	pautoupd
			)
{
	HRESULT			hr = S_OK;

	Assert(pautoupd);

	// Keep pumping until the task is done
	hr = XOnlineTaskContinue((XONLINETASK_HANDLE)&(pautoupd->dircopy));
	if (XONLINETASK_STATUS_AVAILABLE(hr))
	{
		// See if it succeeded
		if (FAILED(hr))
			goto Error;
		hr = S_OK;
		
		// Move on to the next state
		pautoupd->State = xoupdFormatTemp;
	}

Exit:
	return(hr);

Error:
	goto Exit;
}

HRESULT CXo::xoupdFormatTempHandler(
			PXONLINEAUTOUPD_ONLINE	pautoupd
			)
{
	HRESULT	hr;
	PXONLINETASK_AUTOUPD_ONLINE	ptask;
	PXONLINECONTENT_INSTALL		pinstall;

	Assert(pautoupd);

	// We need to reach in and get the content download context
	ptask = CONTAINING_RECORD(pautoupd, XONLINETASK_AUTOUPD_ONLINE, autoupd);
	pinstall = &(ptask->contdl.install);

	// We will format the temp partition to make sure we will have
	// enough space if the package is not already installed and that
	// a resume is not in progress
	if ((pinstall->dwFlags & (XONLINECONTENT_FLAG_RESUME | XONLINECONTENT_FLAG_NOT_INSTALLED)) 
				== XONLINECONTENT_FLAG_NOT_INSTALLED)
	{
		TraceSz(Verbose, "AUTOUPD: Formatting utility drive");
	
		// Blow away the utility drive
		if (!XFormatUtilityDrive())
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			goto Error;
		}
	}

	// We are done pre-install processing. Pre-set the next state
	// to Post-install initialization
	pautoupd->State = xoupdPostInitialize;
	hr = XONLINETASK_S_SUCCESS;

Exit:
	return(hr);

Error:
	goto Exit;
}

HRESULT CXo::xoupdDoneDVDPreInitHandler(
			PXONLINEAUTOUPD_ONLINE	pautoupd
			)
{
	HRESULT	hr = S_OK;

	Assert(pautoupd);

	// Based on the type of DVD update (we won't get here if it's
	// an online update), figure out what the next state should be
	// for the post-processing
	if (pautoupd->dirtypeTarget == dirtypeTitleUpdateOnF)
		pautoupd->State = xoupdDone;
	else
		pautoupd->State = xoupdWriteConfig;

	// Done all pre-init stuff
	return(XONLINETASK_S_SUCCESS);
}

HRESULT CXo::xoupdPostInitializeHandler(
			PXONLINEAUTOUPD_ONLINE	pautoupd
			)
{
	HRESULT	hr = S_OK;

	Assert(pautoupd);

	// Kick of a verify
	pautoupd->cbPatchDigest = XONLINECONTENT_MANIFEST_MAX_FILE_SIZE;
	hr = DigestVerify(
				XONLINECONTENT_MANIFEST_FILE_NAME,
				dirtypeTempDiff, 
				pautoupd->rgbPatchDigest,
				&(pautoupd->cbPatchDigest), NULL, // pbAlternateKey
				pautoupd->xontask.hEventWorkAvailable,
				&(pautoupd->contver));
	if (FAILED(hr))
		goto Exit;

	// Go to the next state
	pautoupd->State = xoupdVerifyPatchDigest;

Exit:	
	return(hr);

}

HRESULT CXo::xoupdVerifyPatchDigestHandler(
			PXONLINEAUTOUPD_ONLINE	pautoupd
			)
{
	Assert(pautoupd);

	HRESULT				hr = S_OK;
	DWORD				cbSize;
	XONLINETASK_HANDLE	hTask = (XONLINETASK_HANDLE)&(pautoupd->contver);

	// Wait for the subtask to complete
	hr = XOnlineTaskContinue(hTask);
	if (XONLINETASK_STATUS_AVAILABLE(hr))
	{
		// Returned results, see if it succeeded
		if (FAILED(hr))
			goto Exit;

		Assert(hr == XONLINETASK_S_SUCCESS);

		// Cleanup the previous task
		contverCleanup(&pautoupd->contver);

		// Set up the enumeration context for the patch digest
		hr = EnumerateDigestInitializeContext(
					pautoupd->rgbPatchDigest,
					pautoupd->cbPatchDigest,
					&(pautoupd->dgstenumPatch));
		if (FAILED(hr))
			goto Exit;

		// Get the title key
		cbSize = XBOX_KEY_LENGTH;
		hr = XoUpdateGetRawTitleKey(m_dwTitleId, pautoupd->rgbTitleKey, &cbSize);
		if (FAILED(hr))
			goto Exit;

		// Okay, now verify the target digest
		pautoupd->cbTargetDigest = XONLINECONTENT_MANIFEST_MAX_FILE_SIZE;
		hr = DigestVerify(
					XONLINEAUTOUPD_TARGET_MANIFEST_FILE_NAME,
					dirtypeTempDiff, 
					pautoupd->rgbTargetDigest,
					&(pautoupd->cbTargetDigest),
					pautoupd->rgbTitleKey,
					pautoupd->xontask.hEventWorkAvailable,
					&(pautoupd->contver));
		if (FAILED(hr))
			goto Exit;

		// Go to the next state
		pautoupd->State = xoupdVerifyTargetDigest;
	}

Exit:	
	return(hr);
}

HRESULT CXo::xoupdVerifyTargetDigestHandler(
			PXONLINEAUTOUPD_ONLINE	pautoupd
			)
{
	Assert(pautoupd);

	HRESULT				hr = S_OK;
	DWORD				cbSize;
	XONLINETASK_HANDLE	hTask = (XONLINETASK_HANDLE)&(pautoupd->contver);

	// Wait for the subtask to complete
	hr = XOnlineTaskContinue(hTask);
	if (XONLINETASK_STATUS_AVAILABLE(hr))
	{
		// Returned results, see if it succeeded
		if (FAILED(hr))
			goto Exit;

		Assert(hr == XONLINETASK_S_SUCCESS);

		// Cleanup the verification task
		contverCleanup(&pautoupd->contver);

		// Set up the enumeration context for the target digest
		hr = EnumerateDigestInitializeContext(
					pautoupd->rgbTargetDigest,
					pautoupd->cbTargetDigest,
					&(pautoupd->dgstenumTarget));
		if (FAILED(hr))
			goto Exit;

		// Build the target path, use rgbOutput as the scratchpad
		cbSize = MAX_PATH;
		hr = BuildTargetDirectory(0, 0, 0, 
					pautoupd->dirtypeTarget,
					&cbSize, (char *)pautoupd->rgbOutput);
		if (FAILED(hr))
			goto Exit;
		
		// Wipe the target location
		hr = RemoveDirectoryInitializeContext(
					(char *)pautoupd->rgbOutput, cbSize, 
					MAX_PATH, (char *)pautoupd->rgbPatchData, 0,
					pautoupd->xontask.hEventWorkAvailable,
					&(pautoupd->dirops));
		if (FAILED(hr))
			goto Exit;

		// Go to the next state
		pautoupd->NextState = xoupdOpenPatch;
		pautoupd->State = xoupdWipeTarget;
	}

Exit:	
	return(hr);
}

HRESULT CXo::xoupdWipeTargetHandler(
			PXONLINEAUTOUPD_ONLINE	pautoupd
			)
{
	Assert(pautoupd);

	HRESULT				hr = S_OK;
	DWORD				cbSize;
	XONLINETASK_HANDLE	hTask = (XONLINETASK_HANDLE)&(pautoupd->dirops);

	// Wait for the subtask to complete
	hr = XOnlineTaskContinue(hTask);
	if (XONLINETASK_STATUS_AVAILABLE(hr))
	{
		// Returned results, see if it succeeded
		if (FAILED(hr))
			goto Exit;

		Assert(hr == XONLINETASK_S_SUCCESS);

		// Now create the root directory
		cbSize = MAX_PATH;
		hr = BuildTargetDirectory(0, 0, 0, 
					pautoupd->dirtypeTarget,
					&cbSize, (char *)pautoupd->rgbOutput);
		if (FAILED(hr))
			goto Exit;

		pautoupd->rgbOutput[--cbSize] = '\0';
		if (!CreateDirectory((LPCSTR)pautoupd->rgbOutput, NULL))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			goto Exit;
		}

		// Go to the next state
		pautoupd->State = pautoupd->NextState;
		pautoupd->NextState = xoupdDone;
	}

Exit:	
	return(hr);
}

HRESULT CXo::xoupdOpenPatchHandler(
			PXONLINEAUTOUPD_ONLINE	pautoupd
			)
{
	HRESULT				hr = S_OK;
	HANDLE				hFile = INVALID_HANDLE_VALUE;
	DWORD				cbSize;
	LARGE_INTEGER		liSize;

	Assert(pautoupd);

	// Get the next entry in the digest file
	hr = EnumerateDigestNext(
			&(pautoupd->dgstenumPatch), 
			&(pautoupd->szCurrentFile), &(pautoupd->pdfdPatch));
	if (FAILED(hr))
	{
		if (hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
		{
			// We are done, move on
			hr = S_OK;
			pautoupd->State = xoupdCopyDigest;
		}
		goto Error;
	}

	// Skip over digest files
	if (!_stricmp(pautoupd->szCurrentFile, XONLINECONTENT_MANIFEST_FILE_NAME) ||
		!_stricmp(pautoupd->szCurrentFile, XONLINEAUTOUPD_TARGET_MANIFEST_FILE_NAME))
	{
		goto Exit;
	}

	// Build the location
	Assert(pautoupd->szCurrentFile);
	Assert(pautoupd->pdfdPatch);
	cbSize = MAX_PATH;
	hr = BuildTargetPath(0, 0, 0, pautoupd->szCurrentFile, 
				dirtypeTempDiff, &cbSize, (char *)pautoupd->rgbOutput);
	if (FAILED(hr))
		goto Error;

	// Attempt to open the file
	TraceSz1(Verbose, "AUTOUPD: Opening patch file %s.", pautoupd->rgbOutput);

	hFile = CreateFile((LPCSTR)pautoupd->rgbOutput,
				GENERIC_READ, 
				0, 	// No sharing to prevent mishaps
				NULL, 
				OPEN_EXISTING, 
				FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, 
				NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Error;
	}

	// Figure out how big the patch file is ...
	if (!GetFileSizeEx(hFile, &liSize))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Error;
	}

	// Make sure the size is the same as in the digest file record
	Assert(pautoupd->pdfdPatch->wSections == 1);
	if (liSize.QuadPart != pautoupd->pdfdPatch->dwFileSize)
	{
		Assert(FALSE);
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		goto Error;
	}

	// Read the patch file header
	if (!ReadFile(hFile, pautoupd->rgbPatchData, 
				AUTOUPD_FILE_MAX_HEADER_SIZE, &cbSize, NULL))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Error;
	}

	// Parse the header info into our struct
	pautoupd->cbapfInfo = AUTOUPD_FILE_MAX_HEADER_SIZE;
	pautoupd->papfInfo = (PAUTOUPD_PATCH_FILE_INFO)pautoupd->rgbHeaderInfo;
	hr = ParsePatchHeader(
				pautoupd->rgbPatchData, &cbSize, 
				pautoupd->rgbHeaderInfo, &(pautoupd->cbapfInfo));
	if (FAILED(hr))
		goto Error;

	// Run the checksum for the header data
	Assert(pautoupd->pdfdPatch->rgSectionData[0].dwSectionStart == 0);
	Assert(pautoupd->pdfdPatch->rgSectionData[0].dwSectionSize == liSize.QuadPart);
	XcSHAInit(pautoupd->shactxPatch);
	XcSHAUpdate(pautoupd->shactxPatch, pautoupd->rgbPatchData, cbSize);

	AUTOUPD_BUMP_PROGRESS(&pautoupd->progress, cbSize);

	// Figure out what size to use for the LZX decoder for this file
	if (pautoupd->papfInfo->dwWindowSizeBits)
	{
		// Window size is explicitly specified, use it as long as it is
		// in range
		pautoupd->dwWindowSize = (1 << pautoupd->papfInfo->dwWindowSizeBits);
		if ((pautoupd->papfInfo->dwWindowSizeBits > 31) ||
			(pautoupd->dwWindowSize > AUTOUPD_MAX_WINDOW_SIZE))
		{
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
			goto Error;
		}
	}
	else
	{
		// Figure out based on the new and old data sizes
		pautoupd->dwWindowSize = AutoupdateLzxWindowSize(
					pautoupd->papfInfo->dwOldFileSize,
					pautoupd->papfInfo->dwNewFileSize);
	}

	TraceSz1(Verbose, "AUTOUPD: Using %u bytes for decode window", 
				pautoupd->dwWindowSize);

	// Set up the LZX decoder; every file can have its own buffer size
	LzxDecodeInit(pautoupd->rgbDecodeWindow,
				pautoupd->dwWindowSize,
				&(pautoupd->lzx));

	// Enable extra long matches for the differential patch engine
	LzxEnableExtraLongMatches(&(pautoupd->lzx));
	
	// Set the file pointer where the patch data starts
	liSize.QuadPart = cbSize;
	if (!SetFilePointerEx(hFile, liSize, &liSize, FILE_BEGIN))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Error;
	}

	// Hand over the handle to pautoupd
	pautoupd->hPatch = hFile;

	// Move to the next state
	if (!pautoupd->papfInfo->dwPatchDataSize)
		pautoupd->State = xoupdCloseFiles;
	else
		pautoupd->State = xoupdOpenSource;

Exit:	
	return(hr);

Error:
	if (hFile != INVALID_HANDLE_VALUE)
		CloseHandle(hFile);
	goto Exit;
}

HRESULT CXo::xoupdOpenSourceHandler(
			PXONLINEAUTOUPD_ONLINE	pautoupd
			)
{
	HRESULT			hr = S_OK;
	HANDLE			hFile = INVALID_HANDLE_VALUE;
	LARGE_INTEGER	liSize;
	DWORD			cbSize;

	Assert(pautoupd);

	// Build the location
	Assert(pautoupd->szCurrentFile);
	cbSize = MAX_PATH;
	hr = BuildTargetPath(0, 0, 0, pautoupd->szCurrentFile, pautoupd->dirtypeSource, 
				&cbSize, (char *)pautoupd->rgbOutput);
	if (FAILED(hr))
		goto Error;

	// Attempt to open the file
	TraceSz1(Verbose, "AUTOUPD: Opening source file %s.", pautoupd->rgbOutput);

	hFile = CreateFile((LPCSTR)pautoupd->rgbOutput,
				GENERIC_READ, 
				0, 	// No sharing to prevent mishaps
				NULL, 
				OPEN_EXISTING, 
				FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, 
				NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Error;
	}

	// Figure out how big the patch file is ...
	if (!GetFileSizeEx(hFile, &liSize))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Error;
	}

	// Save the file size for later
	pautoupd->dwSourceSize = liSize.u.LowPart;

	// Hand over the file handle to pautoupd
	pautoupd->hSource = hFile;

	// Move to the next state
	pautoupd->State = xoupdCreateTarget;
	
Exit:	
	return(hr);

Error:
	if (hFile != INVALID_HANDLE_VALUE)
		CloseHandle(hFile);
	goto Exit;
}

HRESULT CXo::xoupdCreateTargetHandler(
			PXONLINEAUTOUPD_ONLINE	pautoupd
			)
{
	HRESULT	hr = S_OK;
	HANDLE	hFile = INVALID_HANDLE_VALUE;
	DWORD	cbSize;
	PAUTOUPD_PATCH_FILE_INFO	papfInfo;

	Assert(pautoupd);

	// Get the next entry in the digest file
	hr = EnumerateDigestFind(
			&(pautoupd->dgstenumTarget), 
			pautoupd->szCurrentFile, &(pautoupd->pdfdTarget));
	if (FAILED(hr))
		goto Error;

	// Make sure the digest file size and the expected size match
	Assert(pautoupd->pdfdTarget);
	papfInfo = pautoupd->papfInfo;
	if (papfInfo->dwNewFileSize != pautoupd->pdfdTarget->dwFileSize)
	{
		Assert(FALSE);
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		goto Error;
	}

	// Build the target path
	cbSize = MAX_PATH;
	hr = BuildTargetPath(0, 0, 0, pautoupd->szCurrentFile, 
				pautoupd->dirtypeTarget, &cbSize, (char *)pautoupd->rgbOutput);
	if (FAILED(hr))
		goto Error;

	// We will always create a new file.
	hFile = CreateFile((LPCSTR)pautoupd->rgbOutput, 
				GENERIC_READ | GENERIC_WRITE, 
				FILE_SHARE_READ, 
				NULL, 
				CREATE_ALWAYS, 
				FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, 
				NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		DWORD	dwError = GetLastError();
		if (dwError == ERROR_PATH_NOT_FOUND)
		{
			// Directory does not exist, go ahead and create it
			hr = CreateDirectoryInitializeContext(
						(char *)pautoupd->rgbOutput, 
						cbSize,
						XONLINETASK_CDFLAG_FILE_PATH,
						pautoupd->xontask.hEventWorkAvailable,
						&pautoupd->dirops);
			if (FAILED(hr))
				goto Error;

			// Process this subtask
			pautoupd->State = xoupdCreateDirectory;
			goto Exit;
		}

		hr = HRESULT_FROM_WIN32(dwError);
		goto Error;
	}

	// Initialize the SHA context
	XcSHAInit(pautoupd->shactxTarget);

	// Hand over the file to pautoupd
	pautoupd->hTarget = hFile;
	
	// File created, move on to next state
	pautoupd->State = xoupdReadSource;

Exit:
	return(hr);

Error:
	if (hFile != INVALID_HANDLE_VALUE)
		CloseHandle(hFile);
	goto Exit;
}

HRESULT CXo::xoupdCreateDirectoryHandler(
			PXONLINEAUTOUPD_ONLINE	pautoupd
			)
{
	HRESULT	hr = S_OK;
	XONLINETASK_HANDLE	hdirops;

	Assert(pautoupd);

	// Retrieve the dirops structure
	hdirops = (XONLINETASK_HANDLE)&(pautoupd->dirops);
	hr = XOnlineTaskContinue(hdirops);
	if (XONLINETASK_STATUS_AVAILABLE(hr))
	{
		// Create dir had returned results, see if it succeeded
		if (FAILED(hr))
			goto Exit;

		// Go back to create target phase
		hr = S_OK;
		pautoupd->State = xoupdCreateTarget;
	}

Exit:
	return(hr);
}

HRESULT CXo::xoupdReadSourceHandler(
			PXONLINEAUTOUPD_ONLINE	pautoupd
			)
{
	HRESULT	hr = S_OK;
	DWORD			cbRead;
	LARGE_INTEGER		liSize;
	LARGE_INTEGER		liOffset;
	PAUTOUPD_PATCH_FILE_INFO	papfInfo;
	PAUTOUPD_INTERLEAVE_ENTRY	paie;

	Assert(pautoupd);
	Assert(pautoupd->hSource != INVALID_HANDLE_VALUE);

	// Make sure what we are reading makes sense
	papfInfo = pautoupd->papfInfo;
	Assert(papfInfo);	
	if (papfInfo->dwInterleaveCurrent >= papfInfo->dwInterleaveEntries)
	{
		Assert(FALSE);
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		goto Error;
	}
	
	paie = papfInfo->rgInterleaveInfo + papfInfo->dwInterleaveCurrent;
	if (((paie->dwOldOffset + paie->dwOldLength) > pautoupd->dwSourceSize) ||
		(paie->dwOldLength > pautoupd->dwWindowSize))
	{
		Assert(FALSE);
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		goto Error;
	}

	// OK, read the specified region
	liOffset.QuadPart = paie->dwOldOffset;
	if (!SetFilePointerEx(pautoupd->hSource, liOffset, &liOffset, FILE_BEGIN))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Error;
	}

	if (!ReadFile(pautoupd->hSource, pautoupd->rgbDecodeWindow, 
				paie->dwOldLength, &cbRead, NULL))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Error;
	}
	Assert(paie->dwOldLength == cbRead);

	// Insert this into the LZX dictionary
	if (!LzxPopulateDictionary(&pautoupd->lzx, 
				pautoupd->rgbDecodeWindow, paie->dwOldLength))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Error;
	}

	AUTOUPD_BUMP_PROGRESS(&pautoupd->progress, paie->dwOldLength);

	// Reset file progress
	papfInfo->dwTargetWritten = 0;

	// Move on to the next state
	pautoupd->State = xoupdReadPatch;
	
Exit:
	return(hr);

Error:
	goto Exit;
}

HRESULT CXo::xoupdReadPatchHandler(
			PXONLINEAUTOUPD_ONLINE	pautoupd
			)
{
	HRESULT	hr = S_OK;
	DWORD	cbRead;
	PAUTOUPD_PATCH_FILE_INFO	papfInfo;

	Assert(pautoupd);
	Assert(pautoupd->hPatch != INVALID_HANDLE_VALUE);

	papfInfo = pautoupd->papfInfo;
	Assert(papfInfo);

	// We can come here as a result of xoupdReadSource, but we might
	// have already read all the data. In this case, we will jump directly
	// to the next state
	if (papfInfo->dwPatchDataSize == 0)
		goto Skip;

	// If we have any unused patch data, move it to the front of
	// the buffer and account for it ...
	Assert(papfInfo->dwDataSize >= papfInfo->dwCurrent);
	papfInfo->dwDataSize -= papfInfo->dwCurrent;
	if (papfInfo->dwDataSize)
	{
		MoveMemory(pautoupd->rgbPatchData, 
					pautoupd->rgbPatchData + papfInfo->dwCurrent,
					papfInfo->dwDataSize);
	}
	papfInfo->dwCurrent = 0;

	// Read in the patch data, one buffer at a time
	if (!ReadFile(pautoupd->hPatch, 
				pautoupd->rgbPatchData + papfInfo->dwDataSize,
				AUTOUPD_PATCH_BUFFER_SIZE - papfInfo->dwDataSize, 
				&cbRead, NULL))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Error;
	}

	// Run the checksum for the NEW patch data
	XcSHAUpdate(pautoupd->shactxPatch, 
				pautoupd->rgbPatchData + papfInfo->dwDataSize, cbRead);

	AUTOUPD_BUMP_PROGRESS(&pautoupd->progress, cbRead);

	// Adjust our markers
	// Note: the patch generation program is known to create patch files that
	// are slightly larger than needed. We will allow for that with caution.
	if (cbRead > papfInfo->dwPatchDataSize)
		cbRead = papfInfo->dwPatchDataSize;
	papfInfo->dwDataSize += cbRead;
	papfInfo->dwPatchDataSize -= cbRead;

	// Another sanity check. This is important because this should
	// never happen
	if (*(WORD *)(pautoupd->rgbPatchData) >= AUTOUPD_PATCH_BUFFER_SIZE)
	{
		Assert(FALSE);
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		goto Error;
	}

Skip:
	// Move to the next state
	pautoupd->State = xoupdDecodeData;

Exit:	
	return(hr);

Error:
	goto Exit;
}

HRESULT CXo::xoupdDecodeDataHandler(
			PXONLINEAUTOUPD_ONLINE	pautoupd
			)
{
	HRESULT	hr = S_OK;
	DWORD	dwRemaining;
	DWORD	cbPatchData;
	PAUTOUPD_PATCH_FILE_INFO	papfInfo;
	PAUTOUPD_INTERLEAVE_ENTRY	paie;

	Assert(pautoupd);

	// Figure out what we need to do next
	papfInfo = pautoupd->papfInfo;
	Assert(papfInfo);	
	Assert(papfInfo->dwInterleaveCurrent <= papfInfo->dwInterleaveEntries);
	
	paie = papfInfo->rgInterleaveInfo + papfInfo->dwInterleaveCurrent;
	if (papfInfo->dwTargetWritten >= paie->dwNewLength)
	{
		Assert(papfInfo->dwTargetWritten == paie->dwNewLength);

		// See if we are done with this file
		(papfInfo->dwInterleaveCurrent)++;
		if (papfInfo->dwInterleaveCurrent == papfInfo->dwInterleaveEntries)
		{
			// Done with this file. Close all resources
			pautoupd->State = xoupdCloseFiles;
		}
		else
		{
			// Not done yet, load the next interleave entry
			pautoupd->State = xoupdReadSource;
		}
		goto Exit;
	}

	// We are still working on this file.
	dwRemaining = paie->dwNewLength - papfInfo->dwTargetWritten;
	if (dwRemaining > CHUNK_SIZE)
		dwRemaining = CHUNK_SIZE;

	cbPatchData = *(WORD *)(pautoupd->rgbPatchData + papfInfo->dwCurrent);
	if ((papfInfo->dwCurrent + cbPatchData + sizeof(WORD)) > papfInfo->dwDataSize)
	{
		// There is not enough patch data left in the buffer, we will
		// need to load more patch data
		pautoupd->State = xoupdReadPatch;
		goto Exit;
	}

	// Skip past the length WORD
	papfInfo->dwCurrent += 2;

	// Decode tis chunk of data
	if (!LzxDecode(&pautoupd->lzx, dwRemaining, 
				pautoupd->rgbPatchData + papfInfo->dwCurrent,
				cbPatchData, pautoupd->rgbOutput, &pautoupd->cbDecoded))
	{
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		goto Error;
	}
	Assert(pautoupd->cbDecoded == dwRemaining);

	// Consume the patch data
	papfInfo->dwCurrent += cbPatchData;

	// Write out this data
	pautoupd->State = xoupdWriteTarget;
	
Exit:	
	return(hr);

Error:
	goto Exit;
}

HRESULT CXo::xoupdWriteTargetHandler(
			PXONLINEAUTOUPD_ONLINE	pautoupd
			)
{
	HRESULT	hr = S_OK;
	DWORD	cbSize;

	Assert(pautoupd);
	Assert(pautoupd->hTarget != INVALID_HANDLE_VALUE);

	// Write out the data
	if (!WriteFile(pautoupd->hTarget, pautoupd->rgbOutput,
				pautoupd->cbDecoded, &cbSize, NULL))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Error;
	}
	Assert(cbSize == pautoupd->cbDecoded);

	// Run the checksum
	XcSHAUpdate(pautoupd->shactxTarget, 
				pautoupd->rgbOutput, pautoupd->cbDecoded);

	// Update the pointers
	pautoupd->papfInfo->dwTargetWritten += pautoupd->cbDecoded;

	// Return to decode pahse
	pautoupd->State = xoupdDecodeData;

Exit:
	return(hr);

Error:
	goto Exit;
}

HRESULT CXo::xoupdCloseFilesHandler(
			PXONLINEAUTOUPD_ONLINE	pautoupd
			)
{
	HRESULT	hr = S_OK;
	BYTE	rgbDigest[XCALCSIG_SIGNATURE_SIZE];

	Assert(pautoupd);

	if (pautoupd->papfInfo->dwPatchDataSize)
	{
		Assert(pautoupd->pdfdPatch);
		Assert(pautoupd->pdfdTarget);

		// Compute the final checksum for the patch file and make
		// sure it is authentic
		XcSHAFinal(pautoupd->shactxPatch, rgbDigest);
		if (memcmp(pautoupd->pdfdPatch->rgSectionData[0].rgbSignature,
					rgbDigest, XCALCSIG_SIGNATURE_SIZE) != 0)
		{
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
			goto Error;
		}

		// Compute the final checksum for the Target file and make
		// sure it is authentic
		XcSHAFinal(pautoupd->shactxTarget, rgbDigest);
		if (memcmp(pautoupd->pdfdTarget->rgSectionData[0].rgbSignature,
					rgbDigest, XCALCSIG_SIGNATURE_SIZE) != 0)
		{
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
			goto Error;
		}
	}

	TraceSz1(Verbose, "AUTOUPD: Files verified for %s.", pautoupd->szCurrentFile);

	// Move on to the next patch file
	pautoupd->State = xoupdOpenPatch;

Exit:

	// In any case, close all files
	if (pautoupd->hPatch != INVALID_HANDLE_VALUE)
	{
		CloseHandle(pautoupd->hPatch);
		pautoupd->hPatch = INVALID_HANDLE_VALUE;
	}
	if (pautoupd->hSource != INVALID_HANDLE_VALUE)
	{
		CloseHandle(pautoupd->hSource);
		pautoupd->hSource = INVALID_HANDLE_VALUE;
	}
	if (pautoupd->hTarget != INVALID_HANDLE_VALUE)
	{
		CloseHandle(pautoupd->hTarget);
		pautoupd->hTarget = INVALID_HANDLE_VALUE;
	}

	return(hr);

Error:
	goto Exit;
}

HRESULT CXo::xoupdCopyDigestHandler(
			PXONLINEAUTOUPD_ONLINE	pautoupd
			)
{
	HRESULT	hr = S_OK;
	HANDLE	hFile = INVALID_HANDLE_VALUE;
	DWORD	cbSize;
	LARGE_INTEGER		liSize;
	DGSTFILE_IDENTIFIER	dfi;

	// Copy the unsigned digest over to the destination
	cbSize = MAX_PATH;
	hr = BuildTargetPath(0, 0, 0, 
				XONLINEAUTOUPD_TARGET_MANIFEST_FILE_NAME,
				dirtypeTempDiff, &cbSize, (char *)pautoupd->rgbDecodeWindow);
	if (FAILED(hr))
		goto Error;

	cbSize = MAX_PATH;
	hr = BuildTargetPath(0, 0, 0, 
				XONLINECONTENT_MANIFEST_FILE_NAME,
				pautoupd->dirtypeTarget, &cbSize, (char *)pautoupd->rgbOutput);
	if (FAILED(hr))
		goto Error;

	if (!CopyFile((LPCSTR)pautoupd->rgbDecodeWindow, (LPCSTR)pautoupd->rgbOutput, TRUE))		
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Error;
	}

	// Open the digest file
	TraceSz1(Verbose, "AUTOUPD: Opening digest %s for signing.", pautoupd->rgbOutput);

	hFile = CreateFile((LPCSTR)pautoupd->rgbOutput,
				GENERIC_READ | GENERIC_WRITE, 
				0, 	// No sharing to prevent mishaps
				NULL, 
				OPEN_EXISTING, 
				FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN |
				FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING, 
				NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Error;
	}

	if (!GetFileSizeEx(hFile, &liSize))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Error;
	}

	// Now set up to sign this digest later
	dfi.dwTitleId = m_dwTitleId;
	dfi.OfferingId = 0;
	dfi.wTitleVersionHi = pautoupd->wOldVersionHi;
	dfi.wTitleVersionLo = pautoupd->wOldVersionLo;
	hr = ContentVerifyInitializeContext(
				hFile, liSize.u.LowPart,
				pautoupd->rgbTargetDigest, 
				XONLINECONTENT_MANIFEST_MAX_FILE_SIZE,
				pautoupd->rgbTitleKey,
				XONLINECONTENT_VERIFY_FLAG_SIGN,
				&dfi, pautoupd->dirtypeTarget,
				pautoupd->xontask.hEventWorkAvailable,
				&pautoupd->contver);
	if (FAILED(hr))
		goto Error;

	// Kick it off!
	hr = ContentVerifyBegin(&pautoupd->contver);
	if (FAILED(hr))
		goto Error;

	// Figure out what to do next
	if (pautoupd->dirtypeTarget == dirtypeTitleUpdateOnF)
		pautoupd->State = xoupdSignDigest;
	else
	{
		// Dash update, now we need to copy the other files.
		// We set the noreplace file to make sure we don't 
		// overwrite any existing patched files.
		sprintf((char *)pautoupd->rgbDecodeWindow, AUTOUPD_DASH_TARGET_PATH, 
				(pautoupd->dirtypeSource == dirtypeDashUpdate1)?'1':'0');
		sprintf((char *)pautoupd->rgbPatchData, AUTOUPD_DASH_TARGET_PATH, 
				(pautoupd->dirtypeTarget == dirtypeDashUpdate1)?'1':'0');
		hr = CopyDirectoryInitializeContext(
					(char *)pautoupd->rgbDecodeWindow, 
					(char *)pautoupd->rgbPatchData, MAX_PATH, 
					XONLINETASK_DCFLAG_NOREPLACE,
					pautoupd->xontask.hEventWorkAvailable,
					&(pautoupd->dircopy));
		if (FAILED(hr))
			goto Error;
			
		pautoupd->State = xoupdCopyOtherFiles;
	}

Exit:	
	return(hr);

Error:
	if (hFile != INVALID_HANDLE_VALUE)
		CloseHandle(hFile);
	goto Exit;
}

HRESULT CXo::xoupdCopyOtherFilesHandler(
			PXONLINEAUTOUPD_ONLINE	pautoupd
			)
{
	HRESULT	hr = S_OK;

	Assert(pautoupd);

	// Wait for the subtask to complete
	hr = XOnlineTaskContinue((XONLINETASK_HANDLE)&(pautoupd->dircopy));
	if (XONLINETASK_STATUS_AVAILABLE(hr))
	{
		// Returned results, see if it succeeded
		if (FAILED(hr))
			goto Error;
		hr = S_OK;

		// Move on to sign the digest
		pautoupd->State = xoupdSignDigest;
	}

Exit:	
	return(hr);

Error:
	goto Exit;
}

HRESULT CXo::xoupdSignDigestHandler(
			PXONLINEAUTOUPD_ONLINE	pautoupd
			)
{
	HRESULT				hr = S_OK;
	AUTOUPD_DASH_CONFIG	adc;
	
	Assert(pautoupd);

	// Wait for the subtask to complete
	hr = XOnlineTaskContinue((XONLINETASK_HANDLE)&(pautoupd->contver));
	if (XONLINETASK_STATUS_AVAILABLE(hr))
	{
		// Returned results, see if it succeeded
		if (FAILED(hr))
			goto Error;
		hr = S_OK;

		// Cleanup the task
		contverCleanup(&pautoupd->contver);

		// Now the update is completely installed, update the boot
		// switcher to boot to this version
		if (pautoupd->dirtypeTarget != dirtypeTitleUpdateOnF)
		{
			adc.dwActiveDirectory = 
					(pautoupd->dirtypeTarget == dirtypeDashUpdate1)?1:0;
			hr = XoUpdateWriteDashConfig(&adc);
			if (FAILED(hr))
				goto Error;
		}

		// Move on to sign the digest
		pautoupd->State = xoupdCleanupTemp;
	}

Exit:	
	return(hr);

Error:
	goto Exit;
}

HRESULT CXo::xoupdWriteConfigHandler(
			PXONLINEAUTOUPD_ONLINE	pautoupd
			)
{
	HRESULT				hr = S_OK;
	AUTOUPD_DASH_CONFIG	adc;

	Assert(pautoupd);

	// If this is the first dash update, we will also need to install 
	// the switcher xbe in the root
	if (pautoupd->fFirstDashUpdate)
	{
		// We will clobber the old one if it exists
		hr = XoUpdateInstallSwitcher(dirtypeDashUpdate0);
		if (FAILED(hr))
			goto Error;
	}

	// Now the update is completely installed, update the boot
	// switcher to boot to this version
	adc.dwActiveDirectory = 
			(pautoupd->dirtypeTarget == dirtypeDashUpdate1)?1:0;
	hr = XoUpdateWriteDashConfig(&adc);
	if (FAILED(hr))
		goto Error;

	// Cleanup temp
	pautoupd->State = xoupdCleanupTemp;

Exit:
	return(hr);

Error:
	goto Exit;
}

HRESULT CXo::xoupdCleanupTempHandler(
			PXONLINEAUTOUPD_ONLINE	pautoupd
			)
{
	HRESULT	hr = S_OK;

	// Just to try to hide our patch mechanism, we will 
	// format our temp partition before we complete
	if (pautoupd->dirtypeSource != dirtypeNone)
	{
		if (!XFormatUtilityDrive())
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			goto Error;
		}
	}

	if (pautoupd->fFirstDashUpdate)
	{
		pautoupd->NextState = xoupdDone;
		pautoupd->State = xoupdCleanupOfflineDashFiles;
	}
	else
		pautoupd->State = xoupdDone;		

Exit:		
	return(hr);

Error:
	goto Exit;
}

HRESULT CXo::xoupdCleanupOfflineDashFilesHandler(
			PXONLINEAUTOUPD_ONLINE	pautoupd
			)
{
	HRESULT	hr = S_OK;

	// Wait for the subtask to complete
	hr = XOnlineTaskContinue((XONLINETASK_HANDLE)&(pautoupd->xondod));
	if (XONLINETASK_STATUS_AVAILABLE(hr))
	{
		// Returned results, see if it succeeded
		if (FAILED(hr))
			goto Error;
		hr = S_OK;

		// Figure out next state
		pautoupd->State = pautoupd->NextState;
		pautoupd->NextState = xoupdDone;
	}

Exit:
	return(S_OK);

Error:
	goto Exit;
}

// =================================================================

//
// Task handler type
//
typedef HRESULT (CXo::*PFNAUTOUPD_ONLINE_HANDLER)(PXONLINEAUTOUPD_ONLINE);

//
// Define the handler vector
//
const PFNAUTOUPD_ONLINE_HANDLER CXo::s_rgpfnxoupdHandlers[] =
{
	// Pre-install handlers
	CXo::xoupdPreInitializeHandler,
	CXo::xoupdCountFilesHandler,
	CXo::xoupdFormatTempHandler,
	CXo::xoupdDoneDVDPreInitHandler,

	// Post-install handlers
	CXo::xoupdPostInitializeHandler,
	CXo::xoupdVerifyPatchDigestHandler,
	CXo::xoupdVerifyTargetDigestHandler,
	CXo::xoupdWipeTargetHandler,
	CXo::xoupdOpenPatchHandler,
	CXo::xoupdOpenSourceHandler,
	CXo::xoupdCreateTargetHandler,
	CXo::xoupdCreateDirectoryHandler,
	CXo::xoupdReadSourceHandler,
	CXo::xoupdReadPatchHandler,
	CXo::xoupdDecodeDataHandler,
	CXo::xoupdWriteTargetHandler,
	CXo::xoupdCloseFilesHandler,
	CXo::xoupdCopyDigestHandler,
	CXo::xoupdCopyOtherFilesHandler,
	CXo::xoupdSignDigestHandler,
	CXo::xoupdWriteConfigHandler,
	CXo::xoupdCleanupTempHandler,
	CXo::xoupdCleanupOfflineDashFilesHandler
};

//
// Implement the top-level do work function
//
// This is shared among the contdlPreCustom and contdlPostCustom
// custom task handlers in XOnlineContentInstall
//
HRESULT CXo::xoupdContinue(
			XONLINETASK_HANDLE	hTask
			)
{
	HRESULT						hr = S_OK;
	PXONLINETASK_AUTOUPD_ONLINE	pxoupd;
	PXONLINEAUTOUPD_ONLINE		pautoupd = (PXONLINEAUTOUPD_ONLINE)hTask;
	PXRL_ASYNC					pxrlasync;
	AUTOUPD_ONLINE_STATES		State;

	Assert(pautoupd);

	pxoupd = CONTAINING_RECORD(pautoupd, XONLINETASK_AUTOUPD_ONLINE, autoupd);
	pxrlasync = &(pxoupd->contdl.xrlasync);

	State = pautoupd->State;

	// Figure out what phase we are in ...
	if (pautoupd->State < xoupdDone)
	{
		hr = (this->*(s_rgpfnxoupdHandlers[State]))(pautoupd);

#if DBG
		if (FAILED(hr))
		{
			DWORD	tagOld = t_Verbose;
			t_Verbose = TAG_ENABLE;
			TraceSz2(Verbose, "%s, %08x", g_rgszxoupdStates[State], hr);
			t_Verbose = tagOld;
		}
#endif		
	}
	else if (pautoupd->State != xoupdDone)
	{
		// This is a bad state. We force it to end so we don't get stuck
		// here forever.
		AssertSz(FALSE, "xoupdContinue: invalid phase!");
		hr = E_FAIL;
	}

	// Bail if failed.
	if (FAILED(hr))
	{
		pxrlasync->hrFinal = hr;
		pautoupd->State = xoupdDone;
	}

	// When the next state is the final state, we set the flag so we don't
	// continue.
	if (pautoupd->State >= xoupdDone)
	{
		// Indicate that we are done and return the final code
		hr = pxrlasync->hrFinal;
		XONLINETASK_SET_COMPLETION_STATUS(hr);
	}

	// If we are making progress, make sure we update the last 
	// state change timestamp so XRL will not timeout
	if (pautoupd->State != State)
		pxrlasync->dwLastStateChange = GetTickCount();
	
	return(hr);
}				

//
// Function to do a master cleanup. This always comes from XRL
//
VOID CXo::AutoupdateCleanup(
			PVOID	pvxrlasync
			)
{
	PXRL_ASYNC						pxrlasync = (PXRL_ASYNC)pvxrlasync;
	PXONLINETASK_AUTOUPD_ONLINE		pxoupd;
	PXONLINETASK_CONTENT_DOWNLOAD	pcontdl;
	PXONLINEAUTOUPD_ONLINE			pautoupd;

	Assert(pxrlasync);

	pcontdl = CONTAINING_RECORD(pxrlasync, XONLINETASK_CONTENT_DOWNLOAD, xrlasync);
	pxoupd = CONTAINING_RECORD(pcontdl, XONLINETASK_AUTOUPD_ONLINE, contdl);
	pautoupd = &pxoupd->autoupd;

	// Close all explicit handles
	if (pautoupd->hPatch != INVALID_HANDLE_VALUE)
	{
		CloseHandle(pautoupd->hPatch);
		pautoupd->hPatch = INVALID_HANDLE_VALUE;
	}
	if (pautoupd->hSource != INVALID_HANDLE_VALUE)
	{
		CloseHandle(pautoupd->hSource);
		pautoupd->hSource = INVALID_HANDLE_VALUE;
	}
	if (pautoupd->hTarget != INVALID_HANDLE_VALUE)
	{
		CloseHandle(pautoupd->hTarget);
		pautoupd->hTarget = INVALID_HANDLE_VALUE;
	}

	// Unmount any mapped drives
	if (pautoupd->fFDriveMounted)
	{
		XoUpdateUnmountPrivateDrive();
		pautoupd->fFDriveMounted = FALSE;
	}

	// Cleanup any subtask contexts
	contverCleanup(&pautoupd->contver);
	DiropsCleanup(&pautoupd->dirops);
	DircrawlCleanup(&(pautoupd->dircopy.dircrawl));

	contdlCleanup(pcontdl);
}

//
// Function to initialize the context for an online autoupdate
//
// Note: this assumes ContentInstallInitializeContext is already called
//
HRESULT CXo::AutoupdateInitializeContext(
			PXONLINETASK_AUTOUPD_ONLINE	pxoupd,
			DWORD						dwTitleId,
			DWORD						dwTitleOldVersion,
			BOOL						fOnline,
			PBYTE						pbTitleKey,
			HANDLE						hWorkEvent
			)
{
	HRESULT							hr = S_OK;
	PXONLINETASK_CONTENT_DOWNLOAD	pcontdl = NULL;
	PXONLINEAUTOUPD_ONLINE			pautoupd = NULL;
	AUTOUPD_DASH_CONFIG				adc;

	Assert(pxoupd);

	pcontdl = &pxoupd->contdl;
	pautoupd = &pxoupd->autoupd;

	// Determine what kind of update this is, and set the target
	// locations appropriately.
	if (dwTitleId == AUTOUPD_DASH_TITLE_ID)
	{
		// We are updating the dash, we will need to find the active
		// partition and then set the target to the inactive partition.
		hr = XoUpdateMountDashPartition();
		if (FAILED(hr))
			goto Error;

		// Figure out the currently active copy of the dash
		hr = XoUpdateReadDashConfig(&adc, TRUE);
		if (FAILED(hr))
		{
			if (hr == HRESULT_FROM_WIN32(ERROR_NOT_FOUND))
			{
				// This is the offline dash
				adc.dwActiveDirectory = 1;
				pautoupd->fFirstDashUpdate = TRUE;
				hr = S_OK;
			}
			else
				goto Error;
		}

		// Set the target directory, fall back to 0 if necessary
		if (adc.dwActiveDirectory == 0)
			pautoupd->dirtypeTarget = dirtypeDashUpdate1;
		else
			pautoupd->dirtypeTarget = dirtypeDashUpdate0;

		if (fOnline)
		{
			// The offline dash cannot be updated via Online
			if (pautoupd->fFirstDashUpdate)
			{
				hr = HRESULT_FROM_WIN32(XONLINE_E_LOGON_UPDATE_REQUIRED);
				goto Error;
			}

			// Set the appropriate source dirtype
			pautoupd->dirtypeSource =
					(pautoupd->dirtypeTarget == dirtypeDashUpdate0)?
						dirtypeDashUpdate1:dirtypeDashUpdate0;
		}
		else
		{
			// Source directory type for offline updates is none
			pautoupd->dirtypeSource = dirtypeNone;
		}
				
	}
	else
	{
		// Title update is straightforward
		pautoupd->dirtypeTarget = dirtypeTitleUpdateOnF;
		
		if (fOnline)
			pautoupd->dirtypeSource = dirtypeDVDTitleRoot;
		else
			pautoupd->dirtypeSource = dirtypeNone;
	}

	// Online updates require a title key
	if (!fOnline)
		memcpy(pautoupd->rgbTitleKey, pbTitleKey, XBOX_KEY_LENGTH);				

	// One more caveat: we will override the cleanup function for
	// download to use our cleanup handler, which will cleanup
	// everything for download and for our stuff.
	pcontdl->xrlasync.xrlext.dl.pfnCleanup = AutoupdateCleanup;

	// Set up the autoupdate context
	TaskInitializeContext(&pautoupd->xontask);
	pautoupd->xontask.pfnContinue = xoupdContinue;
	pautoupd->xontask.hEventWorkAvailable = hWorkEvent;
	pautoupd->State = xoupdPreInitialize;
	pautoupd->NextState = xoupdDone;
	pautoupd->dwWindowSize = 0;

	MAKE_COMPOSITE_VERSION(dwTitleOldVersion,
				&pautoupd->wOldVersionHi, &pautoupd->wOldVersionLo);

	pautoupd->hPatch = INVALID_HANDLE_VALUE;
	pautoupd->hSource = INVALID_HANDLE_VALUE;
	pautoupd->hTarget = INVALID_HANDLE_VALUE;

	// If the target is to the title area, we will have to mount
	// the title to F drive
	if (pautoupd->dirtypeTarget == dirtypeTitleUpdateOnF)
	{
		hr = XoUpdateMountTitleTDataToPrivateDrive(dwTitleId);
		if (FAILED(hr))
			goto Error;

		pautoupd->fFDriveMounted = TRUE;
	}
	else
		pautoupd->fFDriveMounted = FALSE;

Exit:
	return(hr);

Error:
	AutoupdateCleanup(&pxoupd->contdl.xrlasync);
	goto Exit;
}

//
// Function to kick off an async online autoupdate
//
HRESULT CXo::AutoupdateOnline(
			DWORD				dwTitleId,
			DWORD				dwTitleOldVersion,
			PBYTE				pbTitleKey,
			HANDLE				hWorkEvent,
			PXONLINETASK_HANDLE	phTask
			)
{
	HRESULT							hr = S_OK;
	LARGE_INTEGER					liTemp;
	ULONGLONG						qwMachineId;
	LPCSTR							szDummy = "";
	PXONLINETASK_AUTOUPD_ONLINE		pxoupd = NULL;
	PXONLINETASK_CONTENT_DOWNLOAD	pcontdl;
	PXONLINEAUTOUPD_ONLINE			pautoupd;

	XoEnter("AutoupdateOnline");

	Assert(phTask);

	// First, allocate the context
	pxoupd = (PXONLINETASK_AUTOUPD_ONLINE)SysAllocZ(
			sizeof(XONLINETASK_AUTOUPD_ONLINE), PTAG_XONLINETASK_AUTOUPD_ONLINE);
	if (!pxoupd)
	{
		hr = E_OUTOFMEMORY;
		goto Error;
	}

	TraceSz1(Verbose, "AUTOUPD: Allocating %u bytes for context.", 
				sizeof(XONLINETASK_AUTOUPD_ONLINE));

	// Initialize the content download task
	pcontdl = &pxoupd->contdl;
	pautoupd = &pxoupd->autoupd;
	hr = ContentInstallInitializeContext(pcontdl, 
				dwTitleId, 0, dirtypeTempDiff, 0,
				XONLINECONTENT_INSTALL_TIMEOUT, 
				(XONLINETASK_HANDLE)pautoupd,	// hTaskPreCustom
				(XONLINETASK_HANDLE)pautoupd,	// hTaskPostCustom
				hWorkEvent);
	if (FAILED(hr))
		goto Error;

	// Content install will create an event if one was not specified
	// we pick it out from pcontdl->xrlasync.xontask
	hWorkEvent = pcontdl->xrlasync.xontask.hEventWorkAvailable;

	// Set up the autoupd context
	hr = AutoupdateInitializeContext(pxoupd, 
				dwTitleId, dwTitleOldVersion, TRUE,	// fOnline
				pbTitleKey, hWorkEvent);
	if (FAILED(hr))
		goto Error;

	// Get the current machine ID
	hr = _XOnlineGetMachineID(&qwMachineId);
	if (FAILED(hr))
		goto Error;

	// First, kick off an autoupdate referral request
	hr = InitiateAutoupdateReferralRequest(dwTitleId, 
				qwMachineId, dwTitleOldVersion, pxoupd);
	if (FAILED(hr))
		goto Error;

	// Kick off the generic download. At this point, we don't
	// care about the timestamp or resume point, because we 
	// will have to come up with that later.
	liTemp.QuadPart = 0;
	hr = Download(szDummy, NULL, 0, NULL, liTemp, &(pxoupd->contdl.xrlasync));
	if (FAILED(hr))
		goto Error;

	*phTask = (XONLINETASK_HANDLE)pxoupd;

Exit:
	return(XoLeave(hr));

Error:
	if (pxoupd)
		SysFree(pxoupd);
	goto Exit;
}

//
// Function to kick off an async DVD autoupdate
//
HRESULT CXo::AutoupdateFromDVD(
			PSTR				szUpdatePath,
			DWORD				dwTitleId,
			DWORD				dwTitleOldVersion,
			PBYTE				pbTitleKey,
			PBYTE				pbSymmetricKey,
			DWORD				cbSymmetricKey,
			PBYTE				pbPublicKey,
			DWORD				cbPublicKey,
			HANDLE				hWorkEvent,
			PXONLINETASK_HANDLE	phTask
			)
{
	HRESULT							hr = S_OK;
	LARGE_INTEGER					liTemp;
	PXONLINETASK_AUTOUPD_ONLINE		pxoupd = NULL;
	PXONLINETASK_CONTENT_DOWNLOAD	pcontdl;
	PXONLINEAUTOUPD_ONLINE			pautoupd;

	XoEnter("AutoupdateFromDVD");

	Assert(phTask);
	Assert(pbSymmetricKey);
	Assert(cbSymmetricKey == XONLINE_KEY_LENGTH);
	Assert(pbPublicKey);
	Assert(cbPublicKey >= XONLINECONTENT_PK_SIGNATURE_SIZE);
	Assert(cbPublicKey <= XONLINECONTENT_MAX_PUBLIC_KEY_SIZE);

	// First, allocate the context
	pxoupd = (PXONLINETASK_AUTOUPD_ONLINE)SysAllocZ(
			sizeof(XONLINETASK_AUTOUPD_ONLINE), PTAG_XONLINETASK_AUTOUPD_ONLINE);
	if (!pxoupd)
	{
		hr = E_OUTOFMEMORY;
		goto Error;
	}

	TraceSz1(Verbose, "AUTOUPD: Allocating %u bytes for context.", 
				sizeof(XONLINETASK_AUTOUPD_ONLINE));

	// Initialize the content download task
	pcontdl = &pxoupd->contdl;
	pautoupd = &pxoupd->autoupd;
	hr = ContentInstallInitializeContext(pcontdl, 
				dwTitleId, 0, dirtypeTempDiff,
				XONLINECONTENT_FLAG_OFFLINE_INSTALL,
				XONLINECONTENT_INSTALL_TIMEOUT, 
				(XONLINETASK_HANDLE)pautoupd,	// hTaskPreCustom
				(XONLINETASK_HANDLE)pautoupd,	// hTaskPostCustom
				hWorkEvent);
	if (FAILED(hr))
		goto Error;

	// Content install will create an event if one was not specified
	// we pick it out from pcontdl->xrlasync.xontask
	hWorkEvent = pcontdl->xrlasync.xontask.hEventWorkAvailable;

	// Set up the autoupd context
	hr = AutoupdateInitializeContext(pxoupd, 
				dwTitleId, dwTitleOldVersion, FALSE, // fOnline
				pbTitleKey, hWorkEvent);
	if (FAILED(hr))
		goto Error;

	// Force the target dirtype
	pcontdl->install.dirtypeTarget = pautoupd->dirtypeTarget;

	// Set up the cryptographic keys
	memcpy(pcontdl->install.rgbSymmetricKey, pbSymmetricKey, XONLINE_KEY_LENGTH);
	memcpy(pcontdl->install.rgbPublicKey, pbPublicKey, cbPublicKey);

	// Emulate a "download" from file
	liTemp.QuadPart = 0;
	hr = DownloadFromDVD(szUpdatePath, NULL, liTemp, &(pxoupd->contdl.xrlasync));
	if (FAILED(hr))
		goto Error;

	*phTask = (XONLINETASK_HANDLE)pxoupd;

Exit:
	return(XoLeave(hr));

Error:
	if (pxoupd)
		SysFree(pxoupd);
	goto Exit;
}

//
// Method to get the current update progress
//
HRESULT CXo::AutoupdateGetProgress(
			XONLINETASK_HANDLE	hTask,
			DWORD				*pdwPercentDone,
			ULONGLONG			*pqwNumerator,
			ULONGLONG			*pqwDenominator
			)
{
	HRESULT	hr = S_OK;
	PXONLINETASK_AUTOUPD_ONLINE		pxoupd = (PXONLINETASK_AUTOUPD_ONLINE)hTask;
	PXONLINETASK_CONTENT_DOWNLOAD	pcontdl;
	PXONLINEAUTOUPD_ONLINE			pautoupd;
	PAUTOUPD_PROGRESS_CONTEXT		papc;
	ULONGLONG						qwNumerator;
	ULONGLONG						qwDenominator;
	DWORD							dwPercentDone;

	XoEnter("AutoupdateGetProgress");

	Assert(pxoupd);

	pcontdl = &pxoupd->contdl;
	pautoupd = &pxoupd->autoupd;
	papc = &pautoupd->progress;

	// This is a perfect example of progress aggregation. 
	//
	// Progress is calculated on three phases:
	// i) Download & install
	// ii) Patch application
	// iii) Copying unchanged files (dash only)
	
	// First, we get the progress for the download
	hr = XOnlineContentInstallGetProgress(
				(XONLINETASK_HANDLE)pcontdl,
				&dwPercentDone,
				&qwNumerator, 
				&qwDenominator);
	if (FAILED(hr))
		goto Error;

	// We will need to add the patch application to the fraction
	qwDenominator += papc->uliBytesTotal.QuadPart;
	qwNumerator += papc->uliBytesProcessed.QuadPart;

	// We will also adjust the progress if unpatched files are to
	// be copied as well (will remain 0 if title update)
	qwNumerator += pautoupd->dircopy.uliBytesCopied.QuadPart;

	// Update the perect completed
	if (qwDenominator)
	{
		dwPercentDone = (DWORD)
					((qwNumerator * 100) / qwDenominator);
	}
	else
		dwPercentDone = 0;

	if (pdwPercentDone)
		*pdwPercentDone = dwPercentDone;
	if (pqwNumerator)
		*pqwNumerator = qwNumerator;
	if (pqwDenominator)
		*pqwDenominator = qwDenominator;
		
Exit:
	return(XoLeave(hr));

Error:
	goto Exit;
}

const OBJECT_STRING	   g_DDosDevicePrefix = CONSTANT_OBJECT_STRING(OTEXT("\\??\\D:"));
const CHAR             g_szDVDDevicePrefix[] = "\\Device\\Cdrom0";
const CHAR             g_szDashUpdater[] = "y:\\update.xbe";
const CHAR             g_szTitleUpdater[] = "d:\\update.xbe";

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)    (sizeof(a)/sizeof((a)[0]))
#endif

DWORD RebootToUpdaterWhilePreservingDDrive(
		    LPCSTR lpTitlePath,
		    PLAUNCH_UPDATE_INFO plui
		    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE LinkHandle;
    OCHAR szLinkTarget[MAX_PATH * 2];
    OCHAR szDDrivePath[MAX_PATH * 2];
    OBJECT_STRING LinkTarget;
    int cch;

    szDDrivePath[0] = '\0';

    //
    // If the D: drive is mapped in some unique fashion, preserve that mapping
    // across the reboot
    //

    InitializeObjectAttributes(&Obja,
                               (POBJECT_STRING) &g_DDosDevicePrefix,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtOpenSymbolicLinkObject(&LinkHandle, &Obja);

    if (NT_SUCCESS(Status))
    {
        LinkTarget.Buffer = szLinkTarget;
        LinkTarget.Length = 0;
        LinkTarget.MaximumLength = sizeof(szLinkTarget);

        Status = NtQuerySymbolicLinkObject(LinkHandle, &LinkTarget, NULL);

        NtClose(LinkHandle);
    }

    if (NT_SUCCESS(Status))
    {
        lstrcpynA(szDDrivePath,
                  szLinkTarget,
                  min(ARRAYSIZE(szDDrivePath), (LinkTarget.Length / sizeof(CHAR)) + 1));
    }
    else
    {
        /* Got no path.  The D: drive should always be mapped to something, so
         * we're in trouble if we get here.  Fall back on the DVD device
         * path */
        ASSERT(FALSE);
        strcpy(szDDrivePath, g_szDVDDevicePrefix);
    }

    return(XWriteTitleInfoAndReboot(&(lpTitlePath[3]),
                                    szDDrivePath,
                                    LDT_TITLE_UPDATE,
                                    XeImageHeader()->Certificate->TitleID,
                                    (PLAUNCH_DATA)plui));
}

#endif

DWORD CXo::XOnlineLaunchNewImage(
			LPCSTR			lpTitlePath,
			PLAUNCH_DATA	pLaunchData
			)
{
#ifdef XONLINE_FEATURE_XBOX
    //
    // We require the path is NULL or D:\something
    //

    if ((NULL != lpTitlePath) &&
        ((('D' != lpTitlePath[0]) && ('d' != lpTitlePath[0])) ||
         (':' != lpTitlePath[1]) ||
         ('\\' != lpTitlePath[2])))
    {
        XDBGWRN("XAPI", "XLaunchNewImage() ignoring invalid lpTitlePath (%s)", lpTitlePath);
        return ERROR_INVALID_PARAMETER;
    }

    if (NULL == lpTitlePath)
    {
        //
        // NULL lpTitlePath means reboot to the dashboard - don't preserve D: drive mapping
        //
		// Update the dash if necessary. Note this API will not return if 
		// the Dash needs updating.
        UpdateDashIfNecessary();

        return XWriteTitleInfoAndReboot(NULL,
                                        NULL,
                                        (NULL != pLaunchData) ? LDT_LAUNCH_DASHBOARD : LDT_NONE,
                                        XeImageHeader()->Certificate->TitleID,
                                        pLaunchData);
    }
    else
    {
        NTSTATUS Status;
        OBJECT_ATTRIBUTES Obja;
        HANDLE LinkHandle;
        OCHAR szLinkTarget[MAX_PATH * 2];
        OCHAR szDDrivePath[MAX_LAUNCH_PATH];
        OBJECT_STRING LinkTarget;
        int cch;

        szDDrivePath[0] = '\0';

        //
        // If the D: drive is mapped in some unique fashion, preserve that mapping
        // across the reboot
        //

        InitializeObjectAttributes(&Obja,
                                   (POBJECT_STRING) &g_DDosDevicePrefix,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        Status = NtOpenSymbolicLinkObject(&LinkHandle, &Obja);

        if (NT_SUCCESS(Status))
        {
            LinkTarget.Buffer = szLinkTarget;
            LinkTarget.Length = 0;
            LinkTarget.MaximumLength = sizeof(szLinkTarget);

            Status = NtQuerySymbolicLinkObject(LinkHandle, &LinkTarget, NULL);

            NtClose(LinkHandle);
        }

        if (NT_SUCCESS(Status))
        {
            lstrcpynA(szDDrivePath,
                      szLinkTarget,
                      min(ARRAYSIZE(szDDrivePath), (LinkTarget.Length / sizeof(CHAR)) + 1));
        }
        else
        {
            /* Got no path.  The D: drive should always be mapped to something, so
             * we're in trouble if we get here.  Fall back on the DVD device
             * path */
            ASSERT(FALSE);
            strcpy(szDDrivePath, g_szDVDDevicePrefix);
        }

        return XWriteTitleInfoAndReboot(&(lpTitlePath[3]),
                                        szDDrivePath,
                                        (NULL != pLaunchData) ? LDT_TITLE : LDT_NONE,
                                        XeImageHeader()->Certificate->TitleID,
                                        pLaunchData);
    }
#else
	return(ERROR_NOT_SUPPORTED);
#endif        
}


//
// Autoupdate API
//
HRESULT CXo::XOnlineTitleUpdate(
			DWORD				dwContext
			)
{
	HRESULT	hr = S_OK;
	DWORD	dwError;
	DWORD	cbTitleKey;

	XoEnter("XOnlineTitleUpdate");

#ifdef XONLINE_FEATURE_XBOX

	LAUNCH_UPDATE_INFO	lui;

	// Set up the launch info
	lui.dwReason = 0;
	lui.dwContext = dwContext;
	lui.dwParameter1 = 0;
	lui.dwParameter2 = 0;
	lui.dwTitleId = m_dwTitleId;
	lui.dwBaseVersion = m_dwTitleVersion;
	lui.dwUpdateFlags = LAUNCH_UPDATE_FLAG_ONLINE;

	cbTitleKey = XONLINE_KEY_LENGTH;
	hr = XoUpdateGetRawTitleKey(m_dwTitleId, lui.rgbTitleKey, &cbTitleKey);
	if (FAILED(hr))
		goto Error;

	// Reboot; this shouldn't come back
	dwError = RebootToUpdaterWhilePreservingDDrive(
				(m_dwTitleId == AUTOUPD_DASH_TITLE_ID)?
					g_szDashUpdater:g_szTitleUpdater, &lui);
	hr = HRESULT_FROM_WIN32(dwError);

#else
	hr = E_NOTIMPL;
	goto Error;
#endif

Exit:	
	return(XoLeave(hr));

Error:
	goto Exit;
}

HRESULT CXo::XOnlineTitleUpdateFromDVD(
			DWORD				dwContext,
			PSTR				szUpdatePath,
			DWORD				dwTitleId,
			PBYTE				pbSymmetricKey,
			DWORD				cbSymmetricKey,
			PBYTE				pbPublicKey,
			DWORD				cbPublicKey
			)
{
	HRESULT	hr = S_OK;
	DWORD	dwError;
	DWORD	cbTitleKey;

	XoEnter("XOnlineTitleUpdateFromDVD");
	XoCheck(szUpdatePath != NULL);
	XoCheck(pbSymmetricKey != NULL);
	XoCheck(cbSymmetricKey == XONLINE_KEY_LENGTH);
	XoCheck(pbPublicKey != NULL);
	XoCheck(cbPublicKey >= XONLINECONTENT_PK_SIGNATURE_SIZE);

#ifdef XONLINE_FEATURE_XBOX

	LAUNCH_UPDATE_INFO	lui;

	XoCheck(cbPublicKey <= sizeof(lui.rgbPublicKey));

	// Set up the launch info
	lui.dwReason = 0;
	lui.dwContext = dwContext;
	lui.dwParameter1 = 0;
	lui.dwParameter2 = 0;
	lui.dwTitleId = dwTitleId;
	lui.dwBaseVersion = m_dwTitleVersion;
	lui.dwUpdateFlags = 0;
	lui.cbPublicKey = cbPublicKey;

	cbTitleKey = XONLINE_KEY_LENGTH;
	hr = XoUpdateGetRawTitleKey(m_dwTitleId, lui.rgbTitleKey, &cbTitleKey);
	if (FAILED(hr))
		goto Error;

	memcpy(lui.rgbSymmetricKey, pbSymmetricKey, XONLINE_KEY_LENGTH);
	memcpy(lui.rgbPublicKey, pbPublicKey, cbPublicKey);

	strncpy(lui.szUpdatePath, szUpdatePath, MAX_PATH);

	// Reboot; this shouldn't come back
	// Always use the updater in the DVD because it is newer
	dwError = RebootToUpdaterWhilePreservingDDrive(g_szTitleUpdater, &lui);
	hr = HRESULT_FROM_WIN32(dwError);

#else
	hr = E_NOTIMPL;
	goto Error;
#endif

Exit:	
	return(XoLeave(hr));

Error:
	goto Exit;
}

HRESULT CXo::XOnlineTitleUpdateGetProgress(
			XONLINETASK_HANDLE	hTask,
			DWORD				*pdwPercentDone,
			ULONGLONG			*pqwNumerator,
			ULONGLONG			*pqwDenominator
			)
{
	HRESULT	hr = S_OK;

	XoEnter("XOnlineTitleUpdateGetProgress");
	XoCheck(hTask != NULL);
	
#ifdef XONLINE_FEATURE_XBOX

	hr = AutoupdateGetProgress(hTask, pdwPercentDone,
				pqwNumerator, pqwDenominator);
	if (FAILED(hr))
		goto Error;

#else
	hr = E_NOTIMPL;
	goto Error;
#endif

Exit:	
	return(XoLeave(hr));

Error:
	goto Exit;
}

//
// Intenral Autoupdate API
//
HRESULT CXo::XOnlineTitleUpdateInternal(
			DWORD				dwTitleId,
			DWORD				dwTitleOldVersion,
			PBYTE				pbTitleKey,
			HANDLE				hWorkEvent,
			PXONLINETASK_HANDLE	phTask
			)
{
	HRESULT	hr = S_OK;

	XoEnter("XOnlineTitleUpdateInternal");
	XoCheck(phTask != NULL);

#ifdef XONLINE_FEATURE_XBOX

	hr = AutoupdateOnline(dwTitleId, dwTitleOldVersion, 
				pbTitleKey, hWorkEvent, phTask);
	if (FAILED(hr))
		goto Error;

#else
	hr = E_NOTIMPL;
	goto Error;
#endif

Exit:	
	return(XoLeave(hr));

Error:
	goto Exit;
}

HRESULT CXo::XOnlineTitleUpdateFromDVDInternal(
			PSTR				szUpdatePath,
			DWORD				dwTitleId,
			DWORD				dwTitleOldVersion,
			PBYTE				pbTitleKey,
			PBYTE				pbSymmetricKey,
			DWORD				cbSymmetricKey,
			PBYTE				pbPublicKey,
			DWORD				cbPublicKey,
			HANDLE				hWorkEvent,
			PXONLINETASK_HANDLE	phTask
			)
{
	HRESULT	hr = S_OK;

	XoEnter("XOnlineTitleUpdateFromDVDInternal");
	XoCheck(phTask != NULL);

#ifdef XONLINE_FEATURE_XBOX

	hr = AutoupdateFromDVD(szUpdatePath,
				dwTitleId, dwTitleOldVersion, pbTitleKey, 
				pbSymmetricKey, cbSymmetricKey,
				pbPublicKey, cbPublicKey,
				hWorkEvent, phTask);
	if (FAILED(hr))
		goto Error;

#else
	hr = E_NOTIMPL;
	goto Error;
#endif

Exit:	
	return(XoLeave(hr));

Error:
	goto Exit;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\decxlat.cpp ===
/*
 * xlat.c
 *
 * Translate
 */

#include "xonp.h"
#include "xonver.h"

void NEAR init_decoder_translation(t_decoder_context *context)
{
	context->dec_instr_pos = 0;
}

void NEAR decoder_translate_e8(t_decoder_context *context, byte *mem, long bytes)
{
	ulong   end_instr_pos;
	byte    temp[6];
	byte    *mem_backup;

	if (bytes <= 6)
	{
		context->dec_instr_pos += bytes;
		return;
	}

	mem_backup = mem;

	/* backup these bytes */
	memcpy(temp, &mem[bytes-6], 6);

	/* overwrite them with 0xE8 */
	memset(&mem[bytes-6], 0xE8, 6);

	end_instr_pos = context->dec_instr_pos + bytes - 6;

	while (1)
	{
		unsigned long   absolute;

		/*
		 * We are guaranteed to hit one of the 6 0xE8's we stuck at the
		 * end of the buffer, even if we ran into some corrupted data
		 * that resulted in our jumping over 5 bytes due to a translation
		 */
		while (*mem++ != 0xE8)
			context->dec_instr_pos++;

		if (context->dec_instr_pos >= end_instr_pos)
			break;

		/*
		 * There are 5 or more bytes in the buffer
		 * (i.e. E8 xx xx xx xx)
		 *
		 * We have a complete offset available to (potentially) translate
		 */
		absolute = *(UNALIGNED ulong *) mem;

		if (absolute < context->dec_current_file_size)
		{
			/* absolute >= 0 && absolute < dec_current_file_size */

			*(UNALIGNED ulong *) mem = absolute - context->dec_instr_pos;
		}
		else if ((ulong) (-(long) absolute) <= context->dec_instr_pos)
		{
			/* absolute >= -instr_pos && absolute < 0 */
			*(UNALIGNED ulong *) mem = absolute + context->dec_current_file_size;
		}

		mem += 4;
		context->dec_instr_pos += 5;
	}

	context->dec_instr_pos = end_instr_pos + 6;

	/* restore these bytes */
	memcpy(&mem_backup[bytes-6], temp, 6);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\dirops.cpp ===
/*++

Copyright (c) Microsoft Corporation

Author:
    Keith Lau (keithlau)

Description:
	Module implementing asynchronous directory operations

Module Name:

    dirops.c

--*/

#include "xonp.h"
#include "xonver.h"

//
// Helper functions
//

//
// Scans the path string backwards to find the parent dir.
//
// Note: *pdwIndex does not include the NULL terminator
//
HRESULT CXo::FindParentPath(
			PSTR		szPath,
			DWORD		*pdwIndex
			)
{
	DWORD	dwIndex = *pdwIndex;
	PSTR	pCurrent = szPath + dwIndex;

	// Make sure we have more data, we should never get here
	if (!dwIndex)
		return(E_FAIL);
		
	Assert(*pCurrent == '\0');

	// Walk backwards and find the next backslash
	do 
	{
		dwIndex--;
		pCurrent--;
		if (*pCurrent == '\\')
		{
			*pCurrent = '\0';
			*pdwIndex = dwIndex;
			return(S_OK);
		}

	} while (dwIndex);

	// This is an invalid path!
	return(E_FAIL);
}

//
// Scans the path string forward to restore the child path.
//
// Note: cbPath does not include the NULL terminator
//
HRESULT CXo::RestoreChildPath(
			PSTR		szPath,
			DWORD		cbPath,
			DWORD		*pdwIndex
			)
{
	DWORD	dwIndex = *pdwIndex;
	PSTR	pCurrent = szPath + dwIndex;

	// Make sure we're not at the end already
	if (dwIndex >= cbPath)
		return(E_FAIL);
		
	Assert(*pCurrent == '\0');

	// Restore the backslash
	*pCurrent = '\\';

	// Walk forward until we find a NULL terminator
	while (dwIndex < cbPath)
	{
		pCurrent++;
		dwIndex++;
		if (*pCurrent == '\0')
		{
			*pdwIndex = dwIndex;

			// See if this is the entire file path
			if (dwIndex == cbPath)
				return(S_FALSE);

			// This is just a directory
			return(S_OK);
		}
	}

	// This is an invalid path!
	return(E_FAIL);
}

//
// Function to take care of creating directories
//
HRESULT CXo::DoCreateDirectories(
			PXONLINETASK_DIROPS	pdirops
			)
{
	HRESULT						hr = S_OK;
	WIN32_FILE_ATTRIBUTE_DATA	fad;
	DWORD						dwError;

	Assert(pdirops != NULL);

	// See if we are in create mode, or still trying to find a directory
	// that exists
	if ((pdirops->dwFlags & XONLINETASK_CDFLAG_CREATE_MODE) == 0)
	{
		// Test if the this directory exists
		if (!GetFileAttributesEx(pdirops->szPath, GetFileExInfoStandard, &fad))
		{
			dwError = GetLastError();
			if ((dwError == ERROR_PATH_NOT_FOUND) ||
				(dwError == ERROR_FILE_NOT_FOUND))
			{
				// If we're at the front and still the directory does not exist,
				// then we are quire screwed ...
				if (!pdirops->dwIndex)
				{
					hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
					goto Error;
				}

				// Go back and get the parent
				hr = FindParentPath(pdirops->szPath, &pdirops->dwIndex);
				if (FAILED(hr))
					goto Error;

				// Keep searching
				goto Exit;
			}
			
			// If we are at the root, then start creating directories
			if ((strlen(pdirops->szPath) == 2) && (pdirops->szPath[1] == ':'))
				goto CreateDirectory;

			// Failed to get file attributes for some reason.
			hr = HRESULT_FROM_WIN32(dwError);
			goto Error;
		}

		// Make sure it's a directory
		if ((fad.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
		{
			hr = HRESULT_FROM_WIN32(ERROR_FILE_EXISTS);
			goto Error;
		}

CreateDirectory:

		// OK, this directory exists, set the flag to create subdirectories
		// from here
		pdirops->dwFlags |= XONLINETASK_CDFLAG_CREATE_MODE;
	}

	// See if we should be creating directories
	if ((pdirops->dwFlags & XONLINETASK_CDFLAG_CREATE_MODE) != 0)
	{
		// Find the child and recursively create directories
		hr = RestoreChildPath(pdirops->szPath, pdirops->cbPath, &pdirops->dwIndex);
		if (FAILED(hr))
			goto Error;

		if (hr == S_FALSE)
		{
			// We came back to the full oringinal path. Now, if the path
			// contains a file name, then we are done. Alternatively, if
			// the path is a directory, we will also create this dir.
			if (pdirops->dwFlags & XONLINETASK_CDFLAG_FILE_PATH)
			{
				// We are done
				hr = XONLINETASK_S_SUCCESS;
				goto Exit;
			}
			hr = S_OK;
		}

		// Create the directory
//		TraceSz1(Verbose, "Creating directory: %s", pdirops->szPath);
		if (!CreateDirectory(pdirops->szPath, NULL))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			goto Error;
		}

		if (hr == S_FALSE)
		{
			// We are done
			hr = XONLINETASK_S_SUCCESS;
		}
	}

Exit:
	pdirops->hr = hr;
	return(hr);

Error:
	// Error, abort the task.
	goto Exit;
}

//
// Helper function to determine if a file/dir is in a skip list
//
BOOL CXo::IsInSkipList(
			PXONLINEDIROPS_SKIP_LIST	pSkipList,
			PSTR						szPath
			)
{
	for (DWORD i = 0; i < pSkipList->dwEntries; i++)
		if (_stricmp(szPath, pSkipList->rgszSkipPath[i]) == 0)
			return(TRUE);
	return(FALSE);
}

//
// Function to take care of recursively removing a directory
//
HRESULT CXo::DoRemoveDirectory(
			PXONLINETASK_DIROPS	pdirops
			)
{
	HRESULT			hr = S_OK;
	WIN32_FIND_DATA	wfd;
	DWORD			dwError;

	Assert(pdirops != NULL);

	// If we are popping from a parent, we will try to delete the parent
	// directories until we hit a brick wall
	if ((pdirops->dwFlags & XONLINETASK_RDFLAG_POPDIR) != 0)
	{
//		TraceSz1(Verbose, "Removing directory %s\n", pdirops->szPath);
		if (!RemoveDirectory(pdirops->szPath))
		{
			dwError = GetLastError();
			if (dwError == ERROR_DIR_NOT_EMPTY)
			{
				// Well, this directory is not empty, we will
				// restart enumeration from here.
				pdirops->szPath[pdirops->cbCurrent++] = '\\';
				pdirops->szPath[pdirops->cbCurrent] = '\0';
				pdirops->dwFlags &= (~XONLINETASK_RDFLAG_POPDIR);
				goto Exit;
			}
			else if ((dwError != ERROR_PATH_NOT_FOUND) &&
				(dwError != ERROR_FILE_NOT_FOUND))
			{
				hr = HRESULT_FROM_WIN32(dwError);
				goto Error;
			}
		}

		// See if we are done. First we add back the trailing backslah, and if
		// this length is equal to the path length, then we are done.
		if ((pdirops->cbCurrent + 1) == pdirops->cbPath)
		{
			// Yup, set the don't continue flag
			hr = XONLINETASK_S_SUCCESS;
			goto Exit;
		}

		// OK, now revert to parent path
		hr = FindParentPath(pdirops->szPath, &(pdirops->cbCurrent));
		if (FAILED(hr))
			goto Error;

		goto Exit;
	}

	if (pdirops->hFind == INVALID_HANDLE_VALUE)
	{
		// Start off the find file operation
		strcpy(pdirops->szPath + pdirops->cbCurrent, "*.*");
		
		pdirops->hFind = FindFirstFile(pdirops->szPath, &wfd);
		pdirops->szPath[pdirops->cbCurrent] = '\0';
		
		if (pdirops->hFind == INVALID_HANDLE_VALUE)
		{
			dwError = GetLastError();
			if ((dwError == ERROR_PATH_NOT_FOUND) ||
				(dwError == ERROR_FILE_NOT_FOUND))
			{
				// No files are found. Enter pop mode to delete the current
				// directory.
				pdirops->szPath[--pdirops->cbCurrent] = '\0';
				pdirops->dwFlags |= XONLINETASK_RDFLAG_POPDIR;
				goto Exit;
			}

			// Some other error
			hr = HRESULT_FROM_WIN32(dwError);
			goto Error;
		}
	}
	else
	{
		// Continue ...
		if (!FindNextFile(pdirops->hFind, &wfd))
		{
			DWORD	dwError = GetLastError();
			if (dwError == ERROR_NO_MORE_FILES)
			{
				// Close the find handle properly
				FindClose(pdirops->hFind);
				pdirops->hFind = INVALID_HANDLE_VALUE;

				// No more items, see if we have to recurse
				// to a subdirectory
				if (pdirops->szDir[0] != '\0')
				{
					// Need to recurse, concatenate the directory
					if ((pdirops->cbCurrent + pdirops->cbDir + 1) >= pdirops->cbMax)
					{
						hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
						goto Error;
					}

					// Build the child directory path
					strcpy(pdirops->szPath + pdirops->cbCurrent, pdirops->szDir);
					pdirops->cbCurrent += pdirops->cbDir;
					pdirops->szPath[(pdirops->cbCurrent)++] = '\\';
					pdirops->szPath[pdirops->cbCurrent] = '\0';
					pdirops->szDir[0] = '\0';
					pdirops->cbDir = 0;
					goto Exit;
				}
				else
				{
					// Alright, we are done with this directory, delete it
					pdirops->szPath[--(pdirops->cbCurrent)] = '\0';

					// Set the state to popping
					pdirops->dwFlags |= XONLINETASK_RDFLAG_POPDIR;
					goto Exit;
				}
			}
			
			hr = HRESULT_FROM_WIN32(GetLastError());
			goto Error;
		}
	}

	// Special processing for directories
	if (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
	{
		// Save the first directory we encounter so we know where
		// to recurse later
		if (pdirops->szDir[0] == '\0')
		{
			pdirops->cbDir = strlen(wfd.cFileName);
			if ((pdirops->cbDir + pdirops->cbCurrent) >= pdirops->cbMax)
			{
				hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
				goto Error;
			}

			// Create the full path to see if it is in the skip list
			strcpy(pdirops->szDir, pdirops->szPath);
			pdirops->szDir[pdirops->cbCurrent] = '\\';
			strcpy(pdirops->szDir + (pdirops->cbCurrent + 1), wfd.cFileName);

			// Accept or reject depending on whether the directory is in 
			// the skip list
			if (IsInSkipList(&pdirops->DirsToSkip, pdirops->szDir))
				pdirops->szDir[0] = '\0';
			else
				strcpy(pdirops->szDir, wfd.cFileName);
		}

		// Leave
		goto Exit;
	}

	// Build the file path
	if ((pdirops->cbCurrent + strlen(wfd.cFileName)) >= pdirops->cbMax)
	{
		// Name too long!
		hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
		goto Error;
	}

	// Delete the file if it's not in our skip list
	strcpy(pdirops->szPath + pdirops->cbCurrent, wfd.cFileName);
	if (!IsInSkipList(&pdirops->FilesToSkip, pdirops->szPath))
	{
		if (!DeleteFile(pdirops->szPath))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			goto Error;
		}
	}

	// Restore the path
	pdirops->szPath[pdirops->cbCurrent] = '\0';

Exit:
	pdirops->hr = hr;
	return(hr);

Error:
	// Error, abort the task.
	goto Exit;
}

//
// Function to take care of enumerating the contents of a directory
//
HRESULT CXo::DoEnumerateDirectory(
			PXONLINETASK_DIROPS	pdirops
			)
{
	HRESULT			hr = S_OK;
	WIN32_FIND_DATA	wfd;
	BOOL			fDir;
	DWORD			dwWorkFlags;
	DWORD			dwError;

	Assert(pdirops != NULL);

	// There are only two states: Find the next match, or pump a
	// caller-supplied subtask until it is done.
	if ((pdirops->dwFlags & XONLINETASK_EDFLAG_SUBTASK) == 0)
	{
		// We need to get the first/next match
		if (pdirops->hFind == INVALID_HANDLE_VALUE)
		{
			pdirops->hFind = FindFirstFile(pdirops->szPath, &wfd);
			if (pdirops->hFind == INVALID_HANDLE_VALUE)
			{
				dwError = GetLastError();
				if ((dwError == ERROR_FILE_NOT_FOUND) ||
					(dwError == ERROR_PATH_NOT_FOUND))
				{
					// We are done enumerating.
					hr = XONLINETASK_S_SUCCESS;
					goto NoMoreFiles;
				}
				
				hr = HRESULT_FROM_WIN32(dwError);
				goto Error;
			}
		}
		else if (!FindNextFile(pdirops->hFind, &wfd))
		{
			dwError = GetLastError();
			if (dwError == ERROR_NO_MORE_FILES)
			{
				// We are done enumerating.
				hr = XONLINETASK_S_SUCCESS;
				goto NoMoreFiles;
			}
			
			hr = HRESULT_FROM_WIN32(dwError);
			goto Error;
		}

		// Do simple filetering based on user flags
		fDir = ((wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)?TRUE:FALSE;
		if ((fDir && ((pdirops->dwFlags & XONLINETASK_EDFLAG_ENUMERATE_DIRS) != 0)) ||
			(!fDir && ((pdirops->dwFlags & XONLINETASK_EDFLAG_ENUMERATE_FILES) != 0)))
		{
			// Got a match, proceed to subtask
			Assert(pdirops->hTaskOnData != NULL);

			// Save a copy of the filename in the space provided
			pdirops->cbPath = strlen(wfd.cFileName);
			if (pdirops->cbPath > pdirops->cbMax)
			{
				hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
				goto Error;
			}
			strcpy(pdirops->szPath, wfd.cFileName);

			pdirops->dwFlags |= XONLINETASK_EDFLAG_SUBTASK;
		}
	}
	else
	{
		// We are in the subtask, just keep pumping until the subtask
		// finishes, and get the next item
		hr = XOnlineTaskContinue(pdirops->hTaskOnData);
		if (XONLINETASK_STATUS_AVAILABLE(hr))
		{
			// Bail if the subtask indicated failure
			if (FAILED(hr))
				goto Error;

			// Move on if we are done, otherwise, let the result
			// code percolate up
			pdirops->dwFlags &= (~XONLINETASK_EDFLAG_SUBTASK);
			if (XONLINETASK_STATUS_SUCCESSFUL_COMPLETION(hr))
				hr = S_OK;
		}
	}

Exit:
	return(hr);

Error:
	// Error, abort the task.
	goto Exit;

NoMoreFiles:
	// No more files, see if we have an OnDone subtask
	if (pdirops->hTaskOnDone)
	{
		hr = XOnlineTaskContinue(pdirops->hTaskOnDone);
		if (XONLINETASK_STATUS_AVAILABLE(hr))
		{
			if (FAILED(hr))
				goto Error;

			Assert(hr == XONLINETASK_S_SUCCESS);
			hr = XONLINETASK_S_SUCCESS;
		}
	}
	else
		hr = XONLINETASK_S_SUCCESS;
		
	goto Exit;
}

//
// Main functions
//

//
// Cleanup function
//
VOID CXo::DiropsCleanup(
			PXONLINETASK_DIROPS	pdirops
			)
{
	if (pdirops->hFind != INVALID_HANDLE_VALUE)
	{
		CloseHandle(pdirops->hFind);
		pdirops->hFind = INVALID_HANDLE_VALUE;
	}
}

//
// Main do work function
//
HRESULT CXo::DiropsContinue(
			XONLINETASK_HANDLE	hTask
			)
{
	HRESULT				hr = S_OK;
	PXONLINETASK_DIROPS	pdirops = (PXONLINETASK_DIROPS)hTask;

	Assert(hTask != NULL);

	// Always signal the event. If we actually do any async work, we 
	// will reset the event. This makes sure we don't stall
	if (pdirops->xontask.hEventWorkAvailable)
		SetEvent(pdirops->xontask.hEventWorkAvailable);

	// Call the function to take care of this
	switch (pdirops->dirop)
	{
	case diropCreateDirectory:
		hr = DoCreateDirectories(pdirops);
		break;

	case diropRemoveDirectory:
		hr = DoRemoveDirectory(pdirops);
		break;

	case diropEnumerateDirectory:
		hr = DoEnumerateDirectory(pdirops);
		break;
	}
		
	pdirops->hr = hr;
	return(hr);
}

//
// Function to close a dirops context
//
VOID CXo::DiropsClose(
			XONLINETASK_HANDLE	hTask
			)
{
	PXONLINETASK_DIROPS	pdirops = (PXONLINETASK_DIROPS)hTask;
	
	DiropsCleanup(pdirops);
	SysFree(pdirops);
}

//
// Function to initialize a dirops context
//
HRESULT CXo::DiropsInitializeContext(
			XONLINEDIROPS_OPS	dirop,
			PSTR				szPath,
			DWORD				cbPath,
			DWORD				cbMax,
			PSTR				szDir,
			DWORD				dwFlags,
			XONLINETASK_HANDLE	hTaskOnData,
			XONLINETASK_HANDLE	hTaskOnDone,
			HANDLE				hWorkEvent,
			PXONLINETASK_DIROPS	pdirops
			)
{
	HRESULT	hr = S_OK;
	DWORD	i;

	Assert(dirop < diropMaxOp);
	Assert(pdirops != NULL);
	Assert(szPath != NULL);
	Assert(cbPath != 0);
	Assert(szPath[cbPath] == '\0');

	// Fill in the blanks
	ZeroMemory(pdirops, sizeof(XONLINETASK_DIROPS));
	pdirops->hr = S_OK;
	pdirops->dirop = dirop;
	pdirops->szPath = szPath;
	pdirops->cbPath = cbPath;
	pdirops->cbCurrent = cbPath;
	pdirops->cbMax = cbMax;
	pdirops->dwIndex = cbPath;
	pdirops->szDir = szDir;
	pdirops->dwFlags = dwFlags & XONLINETASK_CDFLAGS_USER;
	pdirops->hFind = INVALID_HANDLE_VALUE;
	pdirops->hTaskOnData = hTaskOnData;
	pdirops->hTaskOnDone = hTaskOnDone;

	TaskInitializeContext(&pdirops->xontask);
	pdirops->xontask.pfnContinue = DiropsContinue;
	pdirops->xontask.pfnClose = DiropsClose;
	pdirops->xontask.hEventWorkAvailable = hWorkEvent;
	if (hWorkEvent)
		SetEvent(hWorkEvent);

	// See if we need to do special work here
	switch (pdirops->dirop)
	{
	case diropCreateDirectory:

		// Validate user flags
        Assert((dwFlags & (~XONLINETASK_CDFLAG_FILE_PATH)) == 0);
		
		if (pdirops->dwFlags & XONLINETASK_CDFLAG_FILE_PATH)
		{
			// It's a file, so chop off the last part		
			hr = FindParentPath(pdirops->szPath, &pdirops->dwIndex);
			if (FAILED(hr))
				return(hr);
		}
		break;

	case diropRemoveDirectory:

		// Validate user flags
		Assert(dwFlags == 0);
		Assert(cbPath > 0);

		// Add trailiing backslash if necessary
		if (szPath[cbPath - 1] != '\\')
		{
			strcpy(szPath + pdirops->cbCurrent, "\\");
			pdirops->cbCurrent++;
			pdirops->cbPath++;
		}

		// Clear up the skip lists. This will have to be explicitly set
		// later on
		pdirops->DirsToSkip.dwEntries = 0;
		pdirops->FilesToSkip.dwEntries = 0;
		break;

	case diropEnumerateDirectory:

		// We need hTaskOnData for enumerate
        Assert(hTaskOnData != NULL);
		
		// Validate user flags
        Assert((dwFlags & (~XONLINETASK_EDFLAG_ENUMERATE_ALL)) == 0);
        Assert((dwFlags & (XONLINETASK_EDFLAG_ENUMERATE_ALL)) != 0);
		break;
	}

	return(S_OK);
}

//
// Implementation of directory crawler
//
typedef enum
{
	dircrawlCrawlDir = 0,
	dircrawlOnDir,
	dircrawlOnFile,
	dircrawlCleanup,
	dircrawlDone

} XONLINEDIRCRAWL_PHASE;

//
// Implement handlers for each state
//
HRESULT CXo::dircrawlCrawlDirHandler(
			PXONLINETASK_DIRCRAWL	pdircrawl
			)
{
	HRESULT			hr = S_OK;
	DWORD			dwError;
	DWORD			dwDepth;
	DWORD			cbSize;

	Assert(pdircrawl != NULL);

	// If we don't have an active find handle for the current search
	// depth, establish one
	dwDepth = pdircrawl->dwDepth;
	if (pdircrawl->rghFind[dwDepth] == INVALID_HANDLE_VALUE)
	{
		// Start off the find file operation
		strcpy(pdircrawl->szPath + pdircrawl->cbPath, "*.*");
		
		pdircrawl->rghFind[dwDepth] = 
					FindFirstFile(pdircrawl->szPath, &pdircrawl->wfd);
		pdircrawl->szPath[pdircrawl->cbPath] = '\0';
		
		if (pdircrawl->rghFind[dwDepth] == INVALID_HANDLE_VALUE)
		{
			dwError = GetLastError();
			if ((dwError == ERROR_PATH_NOT_FOUND) ||
				(dwError == ERROR_FILE_NOT_FOUND))
				goto NoMoreFiles;

			// Some other error
			hr = HRESULT_FROM_WIN32(dwError);
			goto Error;
		}
	}
	else
	{
		// Continue ...
		if (!FindNextFile(pdircrawl->rghFind[dwDepth], &pdircrawl->wfd))
		{
			dwError = GetLastError();
			if (dwError == ERROR_NO_MORE_FILES)
			{
				// Close the find handle properly
				FindClose(pdircrawl->rghFind[dwDepth]);
				pdircrawl->rghFind[dwDepth] = INVALID_HANDLE_VALUE;

NoMoreFiles:

				// Done with this directory, pop back to parent
				if (!dwDepth)
				{
					// We are already at the root node, we're done
					pdircrawl->dwState = dircrawlCleanup;
				}
				else
				{
					// Pop to parent, and fix up the paths
					pdircrawl->dwDepth = --dwDepth;

					// Chomp off the triailing backslash
					pdircrawl->szPath[--(pdircrawl->cbPath)] = '\0';
					hr = FindParentPath(pdircrawl->szPath, &(pdircrawl->cbPath));
					if (FAILED(hr))
						goto Error;

					// Add back the trailing backslash
					pdircrawl->szPath[(pdircrawl->cbPath)++] = '\\';
					pdircrawl->szPath[pdircrawl->cbPath] = '\0';

					if (pdircrawl->szTarget)
					{
						// Chomp off the triailing backslash
						pdircrawl->szTarget[--(pdircrawl->cbTarget)] = '\0';
						hr = FindParentPath(pdircrawl->szTarget, &(pdircrawl->cbTarget));
						if (FAILED(hr))
							goto Error;

						// Add back the trailing backslash
						pdircrawl->szTarget[(pdircrawl->cbTarget)++] = '\\';
						pdircrawl->szTarget[pdircrawl->cbTarget] = '\0';
					}
				}

				goto Exit;
			}

			hr = HRESULT_FROM_WIN32(GetLastError());
			goto Error;
		}
	}

	// We found an entry, make sure we don't overrun the buffer
	cbSize = strlen(pdircrawl->wfd.cFileName);
    Assert((pdircrawl->cbPath + cbSize) < pdircrawl->cbMax);

	// See if this is a directory
	if (pdircrawl->wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
	{
		// This is a directory, so we will recurse into this directory
		// but make sure we are not overrunning the depth limitation
        Assert(dwDepth < (MAX_CRAWL_DEPTH - 1));

		// Compute the recurse path
		strcpy(pdircrawl->szPath + pdircrawl->cbPath, pdircrawl->wfd.cFileName);
		pdircrawl->cbPath += cbSize;
		pdircrawl->szPath[(pdircrawl->cbPath)++] = '\\';
		pdircrawl->szPath[pdircrawl->cbPath] = '\0';

		// Maintain the optional target path if the caller specified one
		if (pdircrawl->szTarget)
		{
            Assert((pdircrawl->cbTarget + cbSize) < pdircrawl->cbMax);
			strcpy(pdircrawl->szTarget + pdircrawl->cbTarget, pdircrawl->wfd.cFileName);
			pdircrawl->cbTarget += cbSize;
			pdircrawl->szTarget[(pdircrawl->cbTarget)++] = '\\';
			pdircrawl->szTarget[pdircrawl->cbTarget] = '\0';
		}

		// Increase the depth
		pdircrawl->dwDepth = ++dwDepth;

		// If there is a per-directory task installed, then go and process
		// this directory record
		if (pdircrawl->hTaskOnDir)
		{
			pdircrawl->dwState = dircrawlOnDir;
		}

		// Leave
		goto Exit;
	}

	// If there is a per-file task installed, then go and process
	// this file record
	if (pdircrawl->hTaskOnFile)
	{
		pdircrawl->dwState = dircrawlOnFile;
	}

Exit:
	return(S_OK);

Error:
	// Error, abort the task.
	pdircrawl->hr = hr;
	return(hr);
}
	
HRESULT CXo::dircrawlOnDirHandler(
			PXONLINETASK_DIRCRAWL	pdircrawl
			)
{
	HRESULT	hr = S_OK;

	Assert(pdircrawl->hTaskOnDir != NULL);

	// We won't be here unless we have an on-directory task. So
	// we keep pumping until the task completes
	hr = XOnlineTaskContinue(pdircrawl->hTaskOnDir);
	if (XONLINETASK_STATUS_AVAILABLE(hr))
	{
		// See if it succeeded
		if (FAILED(hr))
			goto Error;

		// Succeeded. Now continue to crawl
		pdircrawl->dwState = dircrawlCrawlDir;
	}		

	return(S_OK);

Error:
	// Error, abort the task.
	pdircrawl->hr = hr;
	return(hr);
}

HRESULT CXo::dircrawlOnFileHandler(
			PXONLINETASK_DIRCRAWL	pdircrawl
			)
{
	HRESULT	hr = S_OK;

	Assert(pdircrawl->hTaskOnFile != NULL);

	// We won't be here unless we have an on-file task. So
	// we keep pumping until the task completes
	hr = XOnlineTaskContinue(pdircrawl->hTaskOnFile);
	if (XONLINETASK_STATUS_AVAILABLE(hr))
	{
		// See if it succeeded
		if (FAILED(hr))
			goto Error;

		// Succeeded. Now continue to crawl
		pdircrawl->dwState = dircrawlCrawlDir;
	}		

	return(S_OK);

Error:
	// Error, abort the task.
	pdircrawl->hr = hr;
	return(hr);
}

//
// Cleanup function
//
VOID CXo::DircrawlCleanup(
			PXONLINETASK_DIRCRAWL	pdircrawl
			)
{
	for (DWORD i = 0; i < pdircrawl->dwDepth; i++)
		if (pdircrawl->rghFind[i] != INVALID_HANDLE_VALUE)
		{
			CloseHandle(pdircrawl->rghFind[i]);
			pdircrawl->rghFind[i] = INVALID_HANDLE_VALUE;
		}
}

//
// Cleanup Handler
//
HRESULT CXo::dircrawlCleanupHandler(
			PXONLINETASK_DIRCRAWL	pdircrawl
			)
{
	DircrawlCleanup(pdircrawl);
	pdircrawl->dwState = dircrawlDone;
	return(S_OK);
}

//
// Define the handler function type
//

//
// Define the handler array
//
const PFNDIRCRAWL_HANDLER CXo::s_rgpfndircrawlHandlers[] =
{
    CXo::dircrawlCrawlDirHandler,
    CXo::dircrawlOnDirHandler,
    CXo::dircrawlOnFileHandler,
    CXo::dircrawlCleanupHandler
};
			
//
// Main do work function
//
HRESULT CXo::DircrawlContinue(
			XONLINETASK_HANDLE	hTask
			)
{
	HRESULT					hr = S_OK;
	PXONLINETASK_DIRCRAWL	pdircrawl = (PXONLINETASK_DIRCRAWL)hTask;

	Assert(hTask != NULL);

	// Always signal the event. If we actually do any async work, we 
	// will reset the event. This makes sure we don't stall
	if (pdircrawl->xontask.hEventWorkAvailable)
		SetEvent(pdircrawl->xontask.hEventWorkAvailable);

	// Call the function to take care of this
	if (pdircrawl->dwState < dircrawlDone)
	{
		// Call our handler to do more work
		hr = (this->*s_rgpfndircrawlHandlers[pdircrawl->dwState])(pdircrawl);
	}
	else if (pdircrawl->dwState != dircrawlDone)
	{
        AssertSz(FALSE, "DircrawlContinue: Bad state");
		pdircrawl->dwState = dircrawlDone;
		pdircrawl->hr = E_NOTIMPL;
	}

	// Make sure we exit the state machine if we're done
	if (pdircrawl->dwState == dircrawlDone)
	{
		hr = pdircrawl->hr;
		XONLINETASK_SET_COMPLETION_STATUS(hr);
		goto Exit;
	}
	
Exit:
	return(hr);
}

//
// Function to close a dircrawl
//
VOID CXo::DircrawlClose(
			XONLINETASK_HANDLE	hTask
			)
{
	PXONLINETASK_DIRCRAWL	pdircrawl = (PXONLINETASK_DIRCRAWL)hTask;

	DircrawlCleanup(pdircrawl);		
	SysFree(pdircrawl);
}		

//
// Function to initialize a directory crawl context. 
//
// Note: Both source and target paths must be directory paths with
// a trailing backslash '\\'. The source and target path buffers
// must remain valid throughout the copy process.
//
HRESULT CXo::DircrawlInitializeContext(
			PSTR					szPath,
			PSTR					szTarget,
			DWORD					cbMaxPath,
			DWORD					dwFlags,
			XONLINETASK_HANDLE		hTaskOnDir,
			XONLINETASK_HANDLE		hTaskOnFile,
			HANDLE					hWorkEvent,
			PXONLINETASK_DIRCRAWL	pdircrawl
			)
{
	HRESULT	hr = S_OK;
	DWORD	cbPath;
	DWORD	i;

	Assert(pdircrawl != NULL);
	Assert(szPath != NULL);

	ZeroMemory(pdircrawl, sizeof(XONLINETASK_DIRCRAWL));
	
	cbPath = strlen(szPath);
    Assert(cbPath && (cbPath < cbMaxPath) && (szPath[cbPath-1] == '\\'));
	pdircrawl->cbPath = cbPath;
	pdircrawl->szPath = szPath;
	
	if (szTarget)
	{
		cbPath = strlen(szTarget);
        Assert(cbPath && (cbPath < cbMaxPath) && (szTarget[cbPath-1] =='\\'));
		pdircrawl->cbTarget = cbPath;
		pdircrawl->szTarget = szTarget;
	}

	// Fill in the blanks
	pdircrawl->hr = S_OK;
	pdircrawl->cbMax = cbMaxPath;
	pdircrawl->dwState = dircrawlCrawlDir;
	pdircrawl->dwFlags = dwFlags;
	pdircrawl->hTaskOnDir = hTaskOnDir;
	pdircrawl->hTaskOnFile = hTaskOnFile;

	for (i = 0; i < MAX_CRAWL_DEPTH; i++)
		pdircrawl->rghFind[i] = INVALID_HANDLE_VALUE;
	pdircrawl->dwDepth = 0;

	TaskInitializeContext(&pdircrawl->xontask);
	pdircrawl->xontask.pfnContinue = DircrawlContinue;
	pdircrawl->xontask.pfnClose = DircrawlClose;
	pdircrawl->xontask.hEventWorkAvailable = hWorkEvent;
	if (hWorkEvent)
		SetEvent(hWorkEvent);

	return(S_OK);
}

//
// Simple per-directory task handler to do a directory copy
//
HRESULT CXo::DirCopyDirContinue(
			XONLINETASK_HANDLE	hTask
			)
{
	PXONLINETASK_DIRCOPY	pdircopy;

	Assert(hTask != NULL);

	// Locate the containing object
	pdircopy = CONTAINING_RECORD(hTask, XONLINETASK_DIRCOPY, xontaskOnDir);

	// All we do is create the directory
	if (!CreateDirectory(pdircopy->dircrawl.szTarget, NULL))
		return(HRESULT_FROM_WIN32(GetLastError()));

	return(XONLINETASK_S_SUCCESS);
}

//
// Simple per-file task handler to do a directory copy
//
HRESULT CXo::DirCopyFileContinue(
			XONLINETASK_HANDLE	hTask
			)
{
	HRESULT					hr = XONLINETASK_S_SUCCESS;
	PXONLINETASK_DIRCOPY	pdircopy;
	PXONLINETASK_DIRCRAWL	pdircrawl;
	ULARGE_INTEGER			uliSize;
	DWORD					cbSize;
	DWORD					cbTarget;

	Assert(hTask != NULL);

	// Locate the containing object
	pdircopy = CONTAINING_RECORD(hTask, XONLINETASK_DIRCOPY, xontaskOnFile);
	pdircrawl = &pdircopy->dircrawl;

	// Build the source and target paths for copy, making sure not to overrun
	// the buffers
	pdircrawl = &pdircopy->dircrawl;
	cbSize = strlen(pdircrawl->wfd.cFileName);
	Assert(pdircrawl->szTarget != NULL);
    Assert(pdircrawl->cbPath + cbSize < pdircrawl->cbMax);
    Assert(pdircrawl->cbTarget + cbSize < pdircrawl->cbMax);

	// Build the fill copy paths
	cbSize = pdircrawl->cbPath;
	cbTarget = pdircrawl->cbTarget;
	strcpy(pdircrawl->szPath + cbSize, pdircrawl->wfd.cFileName);
	strcpy(pdircrawl->szTarget + cbTarget, pdircrawl->wfd.cFileName);

	// All we do is create the directory
	if (!CopyFile(pdircrawl->szPath, pdircrawl->szTarget, 
				(pdircrawl->dwFlags & XONLINETASK_DCFLAG_NOREPLACE)?TRUE:FALSE))
	{
		DWORD dwError = GetLastError();

		if (!(pdircrawl->dwFlags & XONLINETASK_DCFLAG_NOREPLACE) ||
			(dwError != ERROR_ALREADY_EXISTS))
			hr = HRESULT_FROM_WIN32(dwError);
	}
	else
	{
		// Update the statistics
		(pdircopy->dwFilesCopied)++;
		uliSize.u.LowPart = pdircrawl->wfd.nFileSizeLow;
		uliSize.u.HighPart = pdircrawl->wfd.nFileSizeHigh;
		pdircopy->uliBytesCopied.QuadPart += uliSize.QuadPart;
	}

	// Restore the path strings
	pdircrawl->cbPath = cbSize;
	pdircrawl->szPath[cbSize] = '\0';
	pdircrawl->cbTarget = cbTarget;
	pdircrawl->szTarget[cbTarget] = '\0';

	return(hr);
}

//
// Function to set up a context for a directory copy
//
// Note: Both source and target paths must be directory paths with
// a trailing backslash '\\'. The source and target path buffers
// must remain valid throughout the copy process.
//
HRESULT CXo::CopyDirectoryInitializeContext(
			PSTR					szSourceDirectory,
			PSTR					szTargetDirectory,
			DWORD					cbMaxPath,
			DWORD					dwFlags,
			HANDLE					hWorkEvent,
			PXONLINETASK_DIRCOPY	pdircopy
			)
{
	HRESULT	hr = S_OK;

	// Set up the subtasks
	TaskInitializeContext(&pdircopy->xontaskOnDir);
	pdircopy->xontaskOnDir.pfnContinue = DirCopyDirContinue;
	pdircopy->xontaskOnDir.hEventWorkAvailable = hWorkEvent;
	
	TaskInitializeContext(&pdircopy->xontaskOnFile);
	pdircopy->xontaskOnFile.pfnContinue = DirCopyFileContinue;
	pdircopy->xontaskOnFile.hEventWorkAvailable = hWorkEvent;

	// Reset the counters
	pdircopy->dwFilesCopied = 0;
	pdircopy->uliBytesCopied.QuadPart = 0;

	// Set up the crawl context
	hr = DircrawlInitializeContext(
				szSourceDirectory,
				szTargetDirectory,
				cbMaxPath,
				dwFlags,
				(XONLINETASK_HANDLE)&pdircopy->xontaskOnDir,
				(XONLINETASK_HANDLE)&pdircopy->xontaskOnFile,
				hWorkEvent,
				&pdircopy->dircrawl);
	return(hr);
}

// =====================================================================
// External APIs
//

//
// Function to kick off create directory
//
HRESULT CXo::DiropsCreateDirectory(
			PSTR				szDirectoryPath,
			DWORD				dwFlags,
			HANDLE				hWorkEvent,
			XONLINETASK_HANDLE	*phTask
			)
{
	HRESULT				hr = S_OK;
	PXONLINETASK_DIROPS	pdirops = NULL;
	PSTR				szPath = NULL;
	DWORD				cbPath;

	Assert(phTask != NULL);
	Assert(szDirectoryPath != NULL);

	cbPath = strlen(szDirectoryPath);

	// Allocate the task context, tack on the directory path
	// at the end
	pdirops = (PXONLINETASK_DIROPS)SysAlloc(sizeof(XONLINETASK_DIROPS) + cbPath + 1, PTAG_XONLINETASK_DIROPS);
	if (!pdirops)
		return(E_OUTOFMEMORY);

	// Set up the directory buffer
	szPath = (PSTR)(pdirops + 1);
	strcpy(szPath, szDirectoryPath);

	// Initialize the context
	hr = DiropsInitializeContext(
				diropCreateDirectory,
				szPath,
				cbPath,
				0,
				NULL,
				dwFlags,
				NULL,
				NULL,
				hWorkEvent, 
				pdirops);
	if (FAILED(hr))
		goto Error;

	// Return the opaque handle
	*phTask = (XONLINETASK_HANDLE)pdirops;

Cleanup:
	return(hr);

Error:
	if (pdirops)
	{
		SysFree(pdirops);
	}
	goto Cleanup;
}

//
// Function to kick off remove directory
//
HRESULT CXo::DiropsRemoveDirectory(
			PSTR				szDirectoryPath,
			DWORD				cbMaxPathSize,
			DWORD				dwFlags,
			HANDLE				hWorkEvent,
			XONLINETASK_HANDLE	*phTask
			)
{
	HRESULT				hr = S_OK;
	PXONLINETASK_DIROPS	pdirops = NULL;
	PSTR				szPath = NULL;
	PSTR				szDir = NULL;
	DWORD				cbPath;

	Assert(phTask != NULL);
	Assert(szDirectoryPath != NULL);

	cbPath = strlen(szDirectoryPath);
	if (cbMaxPathSize <= cbPath)
		return(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));

	// Allocate the task context, tack on the directory path
	// at the end
	pdirops = (PXONLINETASK_DIROPS)SysAlloc(sizeof(XONLINETASK_DIROPS) + (cbMaxPathSize * 2), PTAG_XONLINETASK_DIROPS);
	if (!pdirops)
		return(E_OUTOFMEMORY);

	// Set up the directory buffer
	szPath = (PSTR)(pdirops + 1);
	strcpy(szPath, szDirectoryPath);
	szDir = szPath + cbMaxPathSize;

	// Initialize the context
	hr = DiropsInitializeContext(
				diropRemoveDirectory,
				szPath,
				cbPath,
				cbMaxPathSize,
				szDir,
				dwFlags,
				NULL,
				NULL,
				hWorkEvent, 
				pdirops);
	if (FAILED(hr))
		goto Error;

	// Return the opaque handle
	*phTask = (XONLINETASK_HANDLE)pdirops;

Cleanup:
	return(hr);

Error:
	if (pdirops)
	{
		SysFree(pdirops);
	}
	goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\download.cpp ===
/*++

Copyright (c) Microsoft Corporation

Author:
    Keith Lau (keithlau)

Description:
	Module implementing XRL download APIs:
		XOnlineDownloadToMemory
		XOnlineDownloadFile

Module Name:

    download.c

--*/

#include "xonp.h"
#include "xonver.h"

//
// Define enumerated types that describe the states for each operation
//
typedef enum
{
	xrldlPreConnect = 0,
	xrldlConnect,
	xrldlSend,
	xrldlReceive,
	xrldlProcessData,
	xrldlPostDownload,
	xrldlCleanup,
	xrldlDone

} XON_DOWNLOAD_STATES;

typedef enum
{
	xrldfGrowFile,
	xrldfWriteFile, 
	xrldfDone

} XON_DOWNLOAD_FILE_STATES;

//
// ==============================================================
//   S T A T E   M A C H I N E   D E F I N I T I O N S
// ==============================================================
//

// Define the state machines for XOnlineDownload

//
// State 0: Pre-connect extension state
//
HRESULT CXo::xrldlPreConnectHandler(
			PXRL_ASYNC	pxrlasync
			)
{
	HRESULT					hr = S_OK;
	PXRL_DOWNLOAD_EXTENSION	pxrldlext = &(pxrlasync->xrlext.dl);

    Assert(pxrldlext->hTaskPreConnect != NULL);

	// Simple logic: keep pumping the handle until we are told to 
	// stop, then move on to the connect phase
	hr = XOnlineTaskContinue(
				pxrldlext->hTaskPreConnect);
	if (XONLINETASK_STATUS_AVAILABLE(hr))
	{
		// The task had returned results, see if it succeeded
		if (FAILED(hr))
			goto Error;

		// See if the pre-connect task actually tells us to skip
		// the wire talk and skip right to the post-process
		if (hr == XONLINE_S_XRL_EXTENSION_SKIP_TO_POST)
		{
			hr = S_OK;
			
			// see if there is any post-download work
			if (pxrldlext->hTaskPostDownload)
			{
				// Make sure we initialize the task using the supplied callback
				if (pxrldlext->pfnInitializeTask)
				{
					hr = (this->*(pxrldlext->pfnInitializeTask))(
								xrldlextPostDownload, pxrlasync, 
								pxrldlext->hTaskPostDownload);
					if (FAILED(hr))
						goto Error;
				}

				// Got post download work, do that
				pxrlasync->dwCurrentState = xrldlPostDownload;
			}
			else
			{
				// Nope, jump right to cleanup
				pxrlasync->dwCurrentState = xrldlCleanup;
			}

			goto Cleanup;
		}

	    // Connect to the service asynchronously
	    hr = XRL_AsyncConnect(pxrlasync);
	    if (FAILED(hr))
    	    goto Error;

		// Set the next state
		pxrlasync->dwCurrentState = xrldlConnect;
	}

Cleanup:
	return(S_OK);

Error:
	// We encountered a hard error. Set next state to done.
	pxrlasync->hrFinal = hr;
	pxrlasync->dwCurrentState = xrldlCleanup;
	goto Cleanup;
}

//
// State 1: wait for connect loop
//
HRESULT CXo::xrldlConnectHandler(
			PXRL_ASYNC	pxrlasync
			)
{
	HRESULT				hr = S_OK;
	XONLINETASK_HANDLE	hsockio = (XONLINETASK_HANDLE)&(pxrlasync->sockio);

	// Continue until the connect completes asynchronously
	hr = XOnlineTaskContinue(hsockio);
	if (XONLINETASK_STATUS_AVAILABLE(hr))
	{
		// Connect had returned results, see if it succeeded
		if (FAILED(hr))
			goto Error;

		// Succeeded, now we can kick off sending the request. Note that wsabuf
		// was already set up during XRL_SetupDownload time.
		SendRecvInitializeContext(pxrlasync->sockio.socket,
					&pxrlasync->wsabuf, 1, 0, 
					pxrlasync->xontask.hEventWorkAvailable, &pxrlasync->sockio);

		hr = SendInternal(&pxrlasync->sockio);
		if (FAILED(hr))
			goto Error;

		// Set the next state
		pxrlasync->dwCurrentState = xrldlSend;
	}

Cleanup:
	return(S_OK);

Error:
	// We encountered a hard error. Set next state to done.
	pxrlasync->hrFinal = hr;
	pxrlasync->dwCurrentState = xrldlCleanup;
	goto Cleanup;
}

//
// State 2: send request loop
//
HRESULT CXo::xrldlSendHandler(PXRL_ASYNC pxrlasync)
{
	HRESULT				hr = S_OK;
	XONLINETASK_HANDLE	hsockio = (XONLINETASK_HANDLE)&(pxrlasync->sockio);

	// Continue until the send completes asynchronously
	hr = XOnlineTaskContinue(hsockio);
	if (XONLINETASK_STATUS_AVAILABLE(hr))
	{
		// Send had returned results, see if it succeeded
		if (FAILED(hr))
			goto Error;

		// Succeeded, now we can start receiving data from the socket.
		pxrlasync->wsabuf.len = pxrlasync->cbBuffer;
		SendRecvInitializeContext(pxrlasync->sockio.socket,
					&pxrlasync->wsabuf, 1, 0, 
					pxrlasync->xontask.hEventWorkAvailable, &pxrlasync->sockio);

		hr = RecvInternal(&pxrlasync->sockio);
		if (FAILED(hr))
			goto Error;

		// Set the next state to receive, and initialize some variables
		pxrlasync->dwCurrentState = xrldlReceive;
		pxrlasync->dwCurrent = 0;
		pxrlasync->dwTemp = XRL_FLAG_HEADER_MODE;
	}

Cleanup:
	return(S_OK);

Error:
	// We encountered a hard error. Set next state to done.
	pxrlasync->hrFinal = hr;
	pxrlasync->dwCurrentState = xrldlCleanup;
	goto Cleanup;
}

//
// State 3: receive loop
//
HRESULT CXo::xrldlReceiveHandler(PXRL_ASYNC pxrlasync)
{
	HRESULT					hr = S_OK;
	DWORD					dwBytesRead;
	BOOL					fDone;
	XONLINETASK_HANDLE		hsockio = (XONLINETASK_HANDLE)&(pxrlasync->sockio);
	PXRL_DOWNLOAD_EXTENSION pxrldlext = &(pxrlasync->xrlext.dl);

	// Continue until the receive completes asynchronously
	hr = XOnlineTaskContinue(hsockio);
	if (XONLINETASK_STATUS_AVAILABLE(hr))
	{
		// Receive had returned results, see if it succeeded
		if (FAILED(hr))
			goto Error;

		// Succeeded, now get the results and analyze the data
		hr = GetSendRecvResults(hsockio, &dwBytesRead, NULL, NULL);
		if (FAILED(hr))
			goto Error;

		// If zero bytes were read, then the server has closed connection
		if (dwBytesRead)
		{
			// We read something, analyze the data
			hr = XRL_ProcessHttp(pxrlasync, dwBytesRead, &fDone);
			if (SUCCEEDED(hr))
			{
				if (fDone)
				{
					// Call extension to process the header information
					hr = (this->*(pxrldlext->pfnDoneHeaders))(pxrlasync);
					if (FAILED(hr))
						goto Error;

				    // Adjust CONTENT read to exclude header stuff
					pxrlasync->uliTotalReceived.QuadPart += pxrlasync->dwCurrent;
				}
				else if (!IS_HEADER_MODE(pxrlasync))
				{
					// Track how much CONTENT we've downloaded
					pxrlasync->uliTotalReceived.QuadPart += dwBytesRead;
					pxrlasync->dwCurrent += dwBytesRead;
				}
			}
		}
		else
		{
			// Zero bytes read, this means that the server has closed connection.
			// this cannot be a graceful case, because if we already got all the 
			// data we expected, will will not be here asking for more data. We
			// treat this as an error case.
			hr = HRESULT_FROM_WIN32(WSAECONNRESET);
		}

		if (FAILED(hr))
			goto Error;

		// Maybe an application does not need to process the data. In this
		// case, check if we're done
		hr = (this->*(pxrldlext->pfnCompleted))(pxrlasync);
		if (FAILED(hr))
			goto Error;
			
		if (hr == S_OK)
		{
			// see if there is any post-download work
			if (pxrldlext->hTaskPostDownload)
			{
				// Make sure we initialize the task using the supplied callback
				if (pxrldlext->pfnInitializeTask)
				{
					hr = (this->*(pxrldlext->pfnInitializeTask))(xrldlextPostDownload, pxrlasync, pxrldlext->hTaskPostDownload);
					if (FAILED(hr))
						goto Error;
				}

				// Got post download work, do that
				pxrlasync->dwCurrentState = xrldlPostDownload;
			}
			else
			{
				// Nope, jump right to cleanup
				pxrlasync->dwCurrentState = xrldlCleanup;
			}

			goto Cleanup;
		}
		
		// See if we can proceed with processing the data. If this returns true
		// then we will jump to the process data phase, otherwise, we will try to
		// read more from the socket.
		if ((this->*(pxrldlext->pfnProcessData))(pxrlasync))
		{		
			// Make sure we initialize the task using the supplied callback
			if (pxrldlext->pfnInitializeTask)
			{
				hr = (this->*(pxrldlext->pfnInitializeTask))(xrldlextProcessData, pxrlasync, pxrldlext->hTaskProcessData);
				if (FAILED(hr))
					goto Error;
			}

			// Jump to the process data state
			pxrlasync->dwCurrentState = xrldlProcessData;
		}
		else
		{
			// We need more data, adjust the read buffer position and post 
			// another receive
			pxrlasync->wsabuf.buf = (char *)(pxrlasync->pBuffer + pxrlasync->dwCurrent);
			pxrlasync->wsabuf.len = pxrlasync->cbBuffer - pxrlasync->dwCurrent;
			
			SendRecvInitializeContext(pxrlasync->sockio.socket,
						&pxrlasync->wsabuf, 1, 0, 
						pxrlasync->xontask.hEventWorkAvailable, &pxrlasync->sockio);

			hr = RecvInternal(&pxrlasync->sockio);
			if (FAILED(hr))
				goto Error;
		}
	}

Cleanup:
	return(S_OK);

Error:
	// We encountered a hard error. Set next state to done.
	pxrlasync->hrFinal = hr;
	pxrlasync->dwCurrentState = xrldlDone;
	goto Cleanup;
}

//
// State 4: Process Data extension state
//
HRESULT CXo::xrldlProcessDataHandler(
			PXRL_ASYNC	pxrlasync
			)
{
	HRESULT					hr = S_OK;
	PXRL_DOWNLOAD_EXTENSION pxrldlext = &(pxrlasync->xrlext.dl);

    Assert(pxrldlext->hTaskProcessData != NULL);

	// Simple logic: keep pumping the handle until we are told to 
	// stop, then move on to the connect phase
	hr = XOnlineTaskContinue(
				pxrldlext->hTaskProcessData);
	if (XONLINETASK_STATUS_AVAILABLE(hr))
	{
		// The task had returned results, see if it succeeded
		if (FAILED(hr))
			goto Error;

		// See if we're done completely
		hr = (this->*(pxrldlext->pfnCompleted))(pxrlasync);
		if (FAILED(hr))
			goto Error;

		if (hr == S_OK)
		{
			// The download actually finished. Gracefully close the connection
			shutdown(pxrlasync->sockio.socket, SD_BOTH);
			
			// see if there is any post-download work
			if (pxrldlext->hTaskPostDownload)
			{
				// Make sure we initialize the task using the supplied callback
				if (pxrldlext->pfnInitializeTask)
				{
					hr = (this->*(pxrldlext->pfnInitializeTask))(xrldlextPostDownload, pxrlasync, pxrldlext->hTaskPostDownload);
					if (FAILED(hr))
						goto Error;
				}

				// Got post download work, do that
				pxrlasync->dwCurrentState = xrldlPostDownload;
			}
			else
			{
				// Nope, jump right to cleanup
				pxrlasync->dwCurrentState = xrldlCleanup;
			}
		}
		else
		{
			// We need more data, adjust the read buffer position and post 
			// another receive			
			pxrlasync->wsabuf.buf = (char *)(pxrlasync->pBuffer + pxrlasync->dwCurrent);
			pxrlasync->wsabuf.len = pxrlasync->cbBuffer - pxrlasync->dwCurrent;
			
			SendRecvInitializeContext(pxrlasync->sockio.socket,
						&pxrlasync->wsabuf, 1, 0, 
						pxrlasync->xontask.hEventWorkAvailable, &pxrlasync->sockio);

			hr = RecvInternal(&pxrlasync->sockio);
			if (FAILED(hr))
				goto Error;

			// Go back to receive state
			pxrlasync->dwCurrentState = xrldlReceive;
		}
	}

Cleanup:
	return(S_OK);

Error:
	// We encountered a hard error. Set next state to done.
	pxrlasync->hrFinal = hr;
	pxrlasync->dwCurrentState = xrldlCleanup;
	goto Cleanup;
}

//
// State 5: Post-download extension state
//
HRESULT CXo::xrldlPostDownloadHandler(
			PXRL_ASYNC	pxrlasync
			)
{
	HRESULT					hr = S_OK;
	PXRL_DOWNLOAD_EXTENSION pxrldlext = &(pxrlasync->xrlext.dl);

    Assert(pxrldlext->hTaskPostDownload != NULL);

	// Simple logic: keep pumping the handle until we are told to 
	// stop, then move on to the connect phase
	hr = XOnlineTaskContinue(
				pxrldlext->hTaskPostDownload);
	if (XONLINETASK_STATUS_AVAILABLE(hr))
	{
		// The task had returned results, see if it succeeded
		if (FAILED(hr))
			goto Error;

		// Alright, we're all done, jump right to cleanup
		pxrlasync->dwCurrentState = xrldlCleanup;
	}

Cleanup:
	return(S_OK);

Error:
	// We encountered a hard error. Set next state to done.
	pxrlasync->hrFinal = hr;
	pxrlasync->dwCurrentState = xrldlCleanup;
	goto Cleanup;
}

//
// State 6: cleanup
//
HRESULT CXo::xrldlCleanupHandler(PXRL_ASYNC pxrlasync)
{
	// Call the generic handler
	XRL_CleanupHandler(pxrlasync);
	
	// We are done
	pxrlasync->dwCurrentState = xrldlDone;

	return(S_OK);
}

//
// Array
// of handlers for XOnlineDownload
//
const PFNXRL_HANDLER CXo::s_rgpfnxrldlHandlers[] =
{
    CXo::xrldlPreConnectHandler,
    CXo::xrldlConnectHandler,
    CXo::xrldlSendHandler,
    CXo::xrldlReceiveHandler,
    CXo::xrldlProcessDataHandler,
    CXo::xrldlPostDownloadHandler,
    CXo::xrldlCleanupHandler
};

//
// Implement the top-level do work function
//
HRESULT CXo::xrldlContinue(
			XONLINETASK_HANDLE	hTask
			)
{
	return(XRL_MainContinue(hTask, s_rgpfnxrldlHandlers, xrldlDone));
}				

//
// Function to kick off downloading
//
HRESULT CXo::Download(
			LPCSTR				szResourcePath, 
			PBYTE				pbExtraHeaders,
			DWORD				cbExtraHeaders,
			FILETIME			*pftModifiedSince, 
			LARGE_INTEGER		liResumeFrom,
			PXRL_ASYNC			pxrlasync
			)
{
	HRESULT					hr = S_OK;
	PXRL_DOWNLOAD_EXTENSION pxrldlext = &(pxrlasync->xrlext.dl);

    Assert(NULL != pxrlasync);
    Assert(NULL != szResourcePath);
    Assert(!cbExtraHeaders || pbExtraHeaders);
    Assert(!cbExtraHeaders || cbExtraHeaders < XRL_MAX_EXTRA_HEADER_SIZE);

    // Make sure the required callbacks are supplied
    Assert(NULL != pxrlasync->xrlext.dl.pfnDoneHeaders);
    Assert(NULL != pxrlasync->xrlext.dl.pfnProcessData);
    Assert(NULL != pxrlasync->xrlext.dl.pfnCompleted);

	// Modify nothing except fill in our work function
	pxrlasync->xontask.pfnContinue = xrldlContinue;
	pxrlasync->xontask.pfnClose = XRL_MainClose;

	// The socket API requires that we have an event handle in order
	// for the async I/O to happen. If the caller has not provided us
	// with an event, we have to create it here
	hr = XRL_CreateWorkEventIfNecessary(pxrlasync, NULL);
	if (FAILED(hr))
		goto Error;

	// Make sure the event is set
	SetEvent(pxrlasync->xontask.hEventWorkAvailable);

	// Mark as download
	pxrlasync->fDownload = TRUE;

	// Determine the next state depending on whether we have
	// any pre-connect work to do ...
	if (pxrldlext->hTaskPreConnect)
	{
		// Make sure we initialize the task using the supplied callback
		if (pxrldlext->pfnInitializeTask)
		{
			hr = (this->*(pxrldlext->pfnInitializeTask))(xrldlextPreConnect, pxrlasync, pxrldlext->hTaskPreConnect);
			if (FAILED(hr))
				goto Error;
		}

    	// Next state is the pre-connect handler
		pxrlasync->dwCurrentState = xrldlPreConnect;
	}
	else
	{
	    // We have no pre-connect work, so just connect to the
	    // service asynchronously
	    hr = XRL_AsyncConnect(pxrlasync);
	    if (FAILED(hr))
    	    goto Error;

    	// Next state is the connect handler
		pxrlasync->dwCurrentState = xrldlConnect;
	}

    // Build the request headers, save the request size (i.e. send
    // buffer size) in pxrlasync->wsabuf for transmission later
	pxrlasync->wsabuf.len = pxrlasync->cbBuffer;
	pxrlasync->wsabuf.buf = (char *)pxrlasync->pBuffer;
	
    //
    // There are cases where the IP address is not known until 
    // after the PreConnect phase. We will allow that. 
    if (pxrlasync->serviceInfo.dwServiceID != XONLINE_INVALID_SERVICE)
    {
	    hr = XRL_BuildGetRequestWithResume(
	    				pxrlasync->serviceInfo.dwServiceID,
	    				szResourcePath,
	    				pxrlasync->serviceInfo.serviceIP.s_addr,
	    				(char *)pxrlasync->pBuffer, 
	    				&(pxrlasync->wsabuf.len), 
	    				pbExtraHeaders,
	    				cbExtraHeaders,
	    				pftModifiedSince, 
	    				liResumeFrom);
	}	    				
	else if (pxrldlext->hTaskPreConnect == NULL)
	{
        AssertSz(FALSE, "Uninitialized service");
		hr = E_INVALIDARG;
	}
    if (FAILED(hr))
        goto Error;

    // Initialize the last state change
    pxrlasync->dwLastStateChange = GetTickCount();

Cleanup:	
	return(hr);

Error:
	XRL_CleanupHandler(pxrlasync);
	goto Cleanup;
}

//
// Define the extension functions for XOnlineDownloadToMemory
//

//
// This function is called after all headers are received
//
HRESULT CXo::xrldtmDoneHeaders(
			PVOID	pvxrlasync
			)
{
	PXRL_ASYNC	pxrlasync = (PXRL_ASYNC)pvxrlasync;

	// Make sure the response is not an error
	if (XONLINEDOWNLOAD_EXSTATUS_ANYERROR(pxrlasync->dwExtendedStatus))
		return(HRESULT_FROM_WIN32(ERROR_BAD_NET_RESP));
		
    // Make sure we have enough space to hold the declared
    // content length
    if (pxrlasync->uliContentLength.QuadPart > pxrlasync->cbBuffer)
    {
		// Tell the caller how much buffers space is needed
		pxrlasync->cbBuffer = pxrlasync->uliContentLength.u.LowPart;
    
		// return insufficient buffer.
		return(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));
    }

    return(S_OK);
}

//
// This function returnes whether the received data should be processed
// by the process data extension
//
BOOL CXo::xrldtmProcessData(
			PVOID	pvxrlasync
			)
{
	// Never need any processing
	return(FALSE);
}

HRESULT CXo::xrldtmCompleted(
			PVOID	pvxrlasync
			)
{
	PXRL_ASYNC	pxrlasync = (PXRL_ASYNC)pvxrlasync;
	
	if (pxrlasync->uliTotalReceived.QuadPart >= pxrlasync->uliContentLength.QuadPart)
	{
		// Yes we are done
		return(S_OK);
	}
	
	return(S_FALSE);
}

//
// Function to kick off downloading a resource to memory
//
HRESULT 
CXo::XOnlineDownloadToMemory(
			DWORD		        dwServiceID,
			LPCSTR				szResourcePath, 
			PBYTE				pbBuffer,
			DWORD				cbBuffer, 
			PBYTE				pbExtraHeaders,
			DWORD				cbExtraHeaders,
			DWORD				dwTimeout,
			HANDLE				hWorkEvent,
			XONLINETASK_HANDLE	*phTask
			)
{
    XoEnter("XOnlineDownloadToMemory");
    XoCheck(NULL != szResourcePath);
    XoCheck(NULL != phTask);
    XoCheck(0 < cbBuffer);

	HRESULT					hr = S_OK;
	PXRL_ASYNC				pxrlasync = NULL;
	PXRL_ASYNC_EXTENDED		pxrlasyncext = NULL;
	PXRL_DOWNLOAD_EXTENSION pxrldlext = NULL;
	LARGE_INTEGER			liTemp;

	// We are responsible for allocating the context and the work buffer
	// The work buffer are the specified bytes immediately following the
	// context structure
	pxrlasyncext = (PXRL_ASYNC_EXTENDED)SysAlloc(sizeof(XRL_ASYNC_EXTENDED) + (pbBuffer?0:cbBuffer),
        PTAG_XONLINETASK_DOWNLOAD_MEMORY);
	if (!pxrlasyncext)
	{
		hr = E_OUTOFMEMORY;
		goto Error;
	}

	ZeroMemory(pxrlasyncext, sizeof(XRL_ASYNC_EXTENDED));
	pxrlasync = &(pxrlasyncext->xrlasync);
	pxrlasync->pBuffer = pbBuffer?pbBuffer:(PBYTE)(pxrlasyncext + 1);
	pxrlasync->cbBuffer = cbBuffer;

	// Fill in the blanks
	TaskInitializeContext(&pxrlasync->xontask);
	pxrlasync->xontask.hEventWorkAvailable = hWorkEvent;
	pxrlasync->hrFinal = S_OK;
	pxrlasync->hrXErr = S_OK;
	hr = XOnlineGetServiceInfo(dwServiceID, &pxrlasync->serviceInfo);
	Assert(SUCCEEDED(hr));
	pxrlasync->dwTimeoutMs = dwTimeout;

	// Set up the extension block
	pxrldlext = &(pxrlasync->xrlext.dl);
	pxrldlext->pfnDoneHeaders = xrldtmDoneHeaders;
	pxrldlext->pfnProcessData = xrldtmProcessData;
	pxrldlext->pfnCompleted = xrldtmCompleted;
	pxrldlext->pfnCleanup = NULL;
	pxrldlext->pfnInitializeTask = NULL;
	pxrldlext->hTaskPreConnect = NULL;
	pxrldlext->hTaskProcessData = NULL;
	pxrldlext->hTaskPostDownload = NULL;

	// Call the more generic XOnlineDownload
	liTemp.QuadPart = 0;
	hr = Download(szResourcePath, 
				pbExtraHeaders, cbExtraHeaders, 
				NULL, liTemp, pxrlasync);
	if (FAILED(hr))
		goto Error;

	// Return the context as an opaque handle
	*phTask = (XONLINETASK_HANDLE)pxrlasync;

Cleanup:	
	return(XoLeave(hr));

Error:
	// Failed setup, make sure we clean up everything
	if (pxrlasyncext)
		SysFree(pxrlasyncext);

	goto Cleanup;
}

//
// Define the extension functions for XOnlineDownloadFile
//

//
// This function is called after all headers are received
//
HRESULT CXo::xrldfDoneHeaders(
			PVOID	pvxrlasync
			)
{
	HRESULT			hr = S_OK;
	PXRL_ASYNC		pxrlasync = (PXRL_ASYNC)pvxrlasync;
	LARGE_INTEGER	liTemp;
	
	// Analyze the response code
	switch (pxrlasync->dwExtendedStatus)
	{
	case 200:
		// A 200 is coming back, which means the entire 
		// resource is returned by the server. We make sure that 
		// the file pointer is set to the beginning (a la resume)
		if (pxrlasync->uliFileSize.QuadPart > 0)
		{
			liTemp.QuadPart = 0;
			if (!SetFilePointerEx(
						pxrlasync->fileio.hFile, liTemp, &liTemp, FILE_BEGIN))
			{
				hr = HRESULT_FROM_WIN32(GetLastError());
				goto Error;
			}
		}

		// Reset these counters, note that we don't have to change
		// content length and the file size
		pxrlasync->uliTotalWritten.QuadPart = 0;
		pxrlasync->uliTotalReceived.QuadPart = 0;
		break;
		
	case 206:
		// This code is returned if a resume is attempted, and
		// that the server resource was not modified since the
		// date we supplied. This means that the server will 
		// return only the bytes that we don't already have.
		// If we get this code, the file pointer would already have
		// been set to the end of file, so we can simply let
		// WriteFile to its work.
		//
		// The content length returned will only be the remainder
		// of the data, so we add back what we already have
		pxrlasync->uliContentLength.QuadPart += 
					pxrlasync->uliTotalWritten.QuadPart;
		break;

	case 416:
		// This code means that the specified range is not 
		// satisfiable. This usually means that we already got 
		// the entire file to start with.
		//
		// This means that we are done; set the content length and
		// total written counters to the current file size
		pxrlasync->uliContentLength.QuadPart = pxrlasync->uliFileSize.QuadPart;
		pxrlasync->uliTotalWritten.QuadPart = pxrlasync->uliContentLength.QuadPart;
		break;
		
	default:
		hr = HRESULT_FROM_WIN32(ERROR_BAD_NET_RESP);
		AssertSz(SUCCEEDED(hr), "xrldfDoneHeaders");
	}

Error:
    return(hr);
}

//
// This function returnes whether the received data should be processed
// by the process data extension
//
BOOL CXo::xrldfProcessData(PVOID pvxrlasync)
{
	PXRL_ASYNC	pxrlasync = (PXRL_ASYNC)pvxrlasync;
	
	// We will proceed to writing data to disk if the following two conditions
	// are true:
	// 1) No longer parsing headers AND
	// 2a) There is at least XBOX_HD_SECTOR_SIZE bytes to write OR
	// 2b) This is the last block of data expected
	if (!IS_HEADER_MODE(pxrlasync) &&
		((pxrlasync->dwCurrent >= XBOX_HD_SECTOR_SIZE) ||
		 (pxrlasync->uliTotalReceived.QuadPart >= pxrlasync->uliContentLength.QuadPart)))
		return(TRUE);

	return(FALSE);
}

HRESULT CXo::xrldfCompleted(PVOID pvxrlasync)
{
	PXRL_ASYNC	pxrlasync = (PXRL_ASYNC)pvxrlasync;
	
	if (pxrlasync->uliTotalWritten.QuadPart >= pxrlasync->uliContentLength.QuadPart)
	{
		return(S_OK);
	}
	
	return(S_FALSE);
}

HRESULT CXo::xrldfInitializeTask(
			XRLDOWNLOAD_EXTTYPE	xrldlext,
			PVOID				pvxrlasync,
			XONLINETASK_HANDLE	hTask
			)
{
	HRESULT				hr = S_OK;
	PXRL_ASYNC			pxrlasync = (PXRL_ASYNC)pvxrlasync;
	PXRL_ASYNC_EXTENDED	pxrlasyncext = NULL;

	Assert(pxrlasync != NULL);
	Assert(hTask != NULL);

	// XOnlineDownloadFile only services xrldlextProcessData
	if (xrldlext == xrldlextProcessData)
	{
		// Find the outer containing XRL_ASYNC_EXTENDED
		pxrlasyncext = CONTAINING_RECORD(pxrlasync, XRL_ASYNC_EXTENDED, xrlasync);

		// Caveat emptor: now we need to see if the current file size needs to
		// be grown
		if (pxrlasync->uliTotalReceived.QuadPart > pxrlasync->uliFileSize.QuadPart)
		{
			// Growing the file is a synchronous operation, there is a dedicated state 
			// for that ... set up the subtask to start with growing the file
			pxrlasyncext->dwCurrentState = xrldfGrowFile;
		}
		else
		{
			DWORD	dwContentRead = pxrlasync->dwCurrent;
			
			// Make sure the write size is sector-aligned. Usually, we will write less
			// than or up to the data we have, but if this is already the last chunk, 
			// then we will write out all data (or more).
			if (pxrlasync->uliTotalReceived.QuadPart >= pxrlasync->uliContentLength.QuadPart)
				dwContentRead += (XBOX_HD_SECTOR_SIZE - 1);
			dwContentRead &= ~(XBOX_HD_SECTOR_SIZE - 1);
			
			// Write data
			ReadWriteFileInitializeContext(pxrlasync->fileio.hFile,
						pxrlasync->pBuffer, dwContentRead, 
						pxrlasync->uliTotalWritten, 
						pxrlasync->xontask.hEventWorkAvailable, &pxrlasync->fileio);

			hr = WriteFileInternal(&pxrlasync->fileio);
			if (FAILED(hr))
				goto Error;

			// Set the initial state of the subtask to wait for write complete
			pxrlasyncext->dwCurrentState = xrldfWriteFile;
		}
	}

Error:
	return(hr);
}

//
// State xrldfGrowFile: grow file
//
HRESULT CXo::xrldfGrowFileHandler(
			PXRL_ASYNC_EXTENDED	pxrlasyncext
			)
{
	HRESULT				hr = S_OK;
	PXRL_ASYNC			pxrlasync = &pxrlasyncext->xrlasync;
	LARGE_INTEGER		liGrowSize;
	DWORD				dwAlignedSize;

	// Double check that we are still sector-aligned
    Assert((pxrlasync->uliFileSize.u.LowPart & (XBOX_HD_SECTOR_SIZE - 1)) == 0);

	// Figure out how much to grow
	liGrowSize.QuadPart = pxrlasync->uliContentLength.QuadPart - 
							pxrlasync->uliFileSize.QuadPart;

	// Round up to sector alignment
	liGrowSize.QuadPart += (XBOX_HD_SECTOR_SIZE - 1);
	liGrowSize.u.LowPart &= ~(XBOX_HD_SECTOR_SIZE - 1); 

	// Limit growth if necessary
	if (liGrowSize.QuadPart > XRL_INCREMENTAL_GROW_FILE_SIZE)
		liGrowSize.QuadPart = XRL_INCREMENTAL_GROW_FILE_SIZE;

	// Seek to that offset
	if (!SetFilePointerEx(pxrlasync->fileio.hFile, 
				liGrowSize, &liGrowSize, FILE_CURRENT))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Error;
	}

	// Set end of file at that
	if (!SetEndOfFile(pxrlasync->fileio.hFile))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Error;
	}

	TraceSz1(Verbose, "Grow file to %I64u bytes", liGrowSize.QuadPart);

	// Set new file size
	pxrlasync->uliFileSize.QuadPart = liGrowSize.QuadPart;

	// Make sure the write size is sector-aligned
	dwAlignedSize = pxrlasync->dwCurrent;

	// If this is the last chunk, then make sure all data is written
	if (pxrlasync->uliTotalReceived.QuadPart >= pxrlasync->uliContentLength.QuadPart)
		dwAlignedSize += (XBOX_HD_SECTOR_SIZE - 1);
	dwAlignedSize &= ~(XBOX_HD_SECTOR_SIZE - 1);
	
	// Now we kick off the write
	ReadWriteFileInitializeContext(pxrlasync->fileio.hFile,
				pxrlasync->pBuffer, dwAlignedSize, 
				pxrlasync->uliTotalWritten, 
				pxrlasync->xontask.hEventWorkAvailable, &pxrlasync->fileio);

	hr = WriteFileInternal(&pxrlasync->fileio);
	if (FAILED(hr))
		goto Error;

	// Set next state	
	pxrlasyncext->dwCurrentState = xrldfWriteFile;

Cleanup:
	return(S_OK);

Error:
	// We encountered a hard error. End the subtask
	pxrlasync->hrFinal = hr;
	pxrlasyncext->dwCurrentState = xrldfDone;
	goto Cleanup;
}

//
// State xrldfWriteFile: write file state
//
HRESULT CXo::xrldfWriteFileHandler(
			PXRL_ASYNC_EXTENDED	pxrlasyncext
			)
{
	HRESULT				hr = S_OK;
	DWORD				dwBytesWritten;
	PXRL_ASYNC			pxrlasync = &pxrlasyncext->xrlasync;
	XONLINETASK_HANDLE	hfileio = (XONLINETASK_HANDLE)&(pxrlasync->fileio);

	// Continue until the receive completes asynchronously
	hr = XOnlineTaskContinue(hfileio);
	if (XONLINETASK_STATUS_AVAILABLE(hr))
	{
		// Receive had returned results, see if it succeeded
		if (FAILED(hr))
			goto Error;

		// Succeeded, now get the results and analyze the data
		hr = GetReadWriteFileResults(hfileio, &dwBytesWritten, NULL);
		if (FAILED(hr))
			goto Error;

//		TraceSz1(Verbose, "Wrote %u bytes", dwBytesWritten);
		
		// Track how much we have written so far
		pxrlasync->uliTotalWritten.QuadPart += dwBytesWritten;
		Assert((dwBytesWritten & (XBOX_HD_SECTOR_SIZE - 1)) == 0);

		// See how much unwritten data we have
		if (pxrlasync->dwCurrent > dwBytesWritten)
			pxrlasync->dwCurrent -= dwBytesWritten;
		else
			pxrlasync->dwCurrent = 0;
		
		// See if we have written everything we expect to receive
		if (pxrlasync->uliTotalWritten.QuadPart >= pxrlasync->uliContentLength.QuadPart)
		{
			// Done writing, see if we need to truncate the file
			if (pxrlasync->uliTotalWritten.QuadPart > pxrlasync->uliContentLength.QuadPart)
			{
				FILE_END_OF_FILE_INFORMATION	feofi;
				IO_STATUS_BLOCK					iosb;
				NTSTATUS						Status;
				
				// Truncate to real end of file using the Nt API
				feofi.EndOfFile.QuadPart = pxrlasync->uliContentLength.QuadPart;
				Status = NtSetInformationFile(pxrlasync->fileio.hFile, &iosb, 
							(PVOID)&feofi, sizeof(FILE_END_OF_FILE_INFORMATION),
							FileEndOfFileInformation);
			    if (!NT_SUCCESS(Status)) 
			    {
					hr = HRESULT_FROM_WIN32(RtlNtStatusToDosError(Status));
					goto Error;
				}
			}

			// See if we received the same number of bytes as the content length
			// had advertised
			if (pxrlasync->uliTotalReceived.QuadPart != pxrlasync->uliContentLength.QuadPart)
			{
				// We got something other than expected, we will be very strict and
				// fail the operation. 
				hr = HRESULT_FROM_WIN32(ERROR_BAD_LENGTH);
				goto Error;
			}
		}
		else
		{
			// Move any unwritten data to the front of the buffer
			if (pxrlasync->dwCurrent)
			{
//				TraceSz2(Verbose, "[%I64u] %u bytes unwritten", 
//							pxrlasync->uliTotalWritten.QuadPart,
//							pxrlasync->dwCurrent);
				
				MoveMemory(pxrlasync->pBuffer, 
							pxrlasync->pBuffer + dwBytesWritten,
							pxrlasync->dwCurrent);
			}
		}

		// We're done this subtask, return to the main download task
		pxrlasyncext->dwCurrentState = xrldfDone;
	}

Cleanup:
	return(S_OK);

Error:
	// We encountered a hard error. Set next state to cleanup.
	pxrlasync->hrFinal = hr;
	pxrlasyncext->dwCurrentState = xrldfDone;
	goto Cleanup;
}

//
// Implement the do work function for XOnlineDownloadFile subtask
//
HRESULT CXo::xrldfContinue(
			XONLINETASK_HANDLE	hTask
			)
{
	HRESULT				hr = S_OK;
	PXRL_ASYNC_EXTENDED	pxrlasyncext = NULL;
	PXRL_ASYNC			pxrlasync = NULL;

	// We can make very tight assumptions and validate here
	Assert(hTask != NULL);

	// hTask points to the xontask field of XRL_ASYNC_EXTENDED,
	// find the containing pxrlasyncext structure
	pxrlasyncext = CONTAINING_RECORD(hTask, XRL_ASYNC_EXTENDED, xontask);
	pxrlasync = &pxrlasyncext->xrlasync;

	// Figure out what state we are in ...
	switch (pxrlasyncext->dwCurrentState)
	{
	case xrldfGrowFile:
		hr = xrldfGrowFileHandler(pxrlasyncext);
		break;

	case xrldfWriteFile:
		hr = xrldfWriteFileHandler(pxrlasyncext);
		break;

	default:
		// This is a bad state. We force it to end so we don't get stuck
		// here forever.
		AssertSz(FALSE, "xrldfContinue: invalid current state!");
		pxrlasyncext->dwCurrentState = xrldfDone;
		hr = pxrlasync->hrFinal = E_FAIL;
	}

	// When the next state is the final state, we set the flag so we don't
	// continue.
	if (pxrlasyncext->dwCurrentState == xrldfDone)
	{
		// Indicate that we are done and return the final code
		hr = pxrlasync->hrFinal;
		XONLINETASK_SET_COMPLETION_STATUS(hr);
	}
	
	return(hr);
}				

//
// Function to kick off downloading a resoruce to a file
//
HRESULT 
CXo::XOnlineDownloadFile(
			DWORD       		dwServiceID,
			LPCSTR				szResourcePath, 
			PBYTE				pbBuffer,
			DWORD				cbBuffer, 
			PBYTE				pbExtraHeaders,
			DWORD				cbExtraHeaders,
			DWORD				dwFlags,
			LPCSTR				szLocalPath, 
			DWORD				dwTimeout,
			HANDLE				hWorkEvent,
			XONLINETASK_HANDLE	*phTask
			)
{
    XoEnter("XOnlineDownloadFile");
    XoCheck(szResourcePath != NULL);
    XoCheck(cbBuffer >= XBOX_HD_SECTOR_SIZE);
    XoCheck(szLocalPath != NULL);
    XoCheck(phTask != NULL);

	HRESULT						hr = S_OK;
	PXRL_ASYNC					pxrlasync = NULL;
	PXRL_ASYNC_EXTENDED			pxrlasyncext = NULL;
	BY_HANDLE_FILE_INFORMATION	bhfi;
	PXONLINETASK_FILEIO			pfileio = NULL;
	LARGE_INTEGER				liResumeFrom;
	FILETIME					ftLastWritten;
	FILETIME					*pftLastModified = NULL;
	BOOL						fForceDownload;
	PXRL_DOWNLOAD_EXTENSION 	pxrldlext = NULL;

	// The buffer size needs more validation:
	// 1) Sector size must be power of 2
	// 2) The size will be rounded down to multiples of Xbox HD sector size
    Assert((XBOX_HD_SECTOR_SIZE & (XBOX_HD_SECTOR_SIZE - 1)) == 0);
    cbBuffer &= (~(XBOX_HD_SECTOR_SIZE - 1));

	fForceDownload = ((dwFlags & XON_DF_FORCE_DOWNLOAD) != 0);

	// We are responsible for allocating the context and the work buffer
	// The work buffer are the specified bytes immediately following the
	// context structure
	pxrlasyncext = (PXRL_ASYNC_EXTENDED)SysAlloc(sizeof(XRL_ASYNC_EXTENDED) + (pbBuffer?0:cbBuffer),
        PTAG_XONLINETASK_DOWNLOAD_FILE);

	if (!pxrlasyncext)
	{
		hr = E_OUTOFMEMORY;
		goto Error;
	}

	// Initialize the context
	ZeroMemory(pxrlasyncext, sizeof(XRL_ASYNC_EXTENDED));
	pxrlasync = &pxrlasyncext->xrlasync;
	pxrlasync->pBuffer = pbBuffer?pbBuffer:(PBYTE)(pxrlasyncext + 1);
	pxrlasync->cbBuffer = cbBuffer;

	// Fill in the blanks
	TaskInitializeContext(&pxrlasync->xontask);
	pxrlasync->xontask.hEventWorkAvailable = hWorkEvent;
	pxrlasync->hrFinal = S_OK;
	pxrlasync->hrXErr = S_OK;
	hr = XOnlineGetServiceInfo(dwServiceID, &pxrlasync->serviceInfo);
	Assert(SUCCEEDED(hr));
	pxrlasync->uliTotalWritten.QuadPart = 0;
	pxrlasync->dwTimeoutMs = dwTimeout;
	pfileio = &pxrlasync->fileio;

	// Initialize our ProcessData subtask
	TaskInitializeContext(&pxrlasyncext->xontask);
	pxrlasyncext->xontask.pfnContinue = xrldfContinue;
	pxrlasyncext->xontask.hEventWorkAvailable = hWorkEvent;
	pxrlasyncext->dwCurrentState = xrldfDone;

	// Set up the extension block
	pxrldlext = &(pxrlasync->xrlext.dl);
	pxrldlext->pfnDoneHeaders = xrldfDoneHeaders;
	pxrldlext->pfnProcessData = xrldfProcessData;
	pxrldlext->pfnCompleted = xrldfCompleted;
	pxrldlext->pfnCleanup = NULL;
	pxrldlext->pfnInitializeTask = xrldfInitializeTask;
	pxrldlext->hTaskPreConnect = NULL;
	pxrldlext->hTaskProcessData = 
					(XONLINETASK_HANDLE)&(pxrlasyncext->xontask);
	pxrldlext->hTaskPostDownload = NULL;

	// Create the target file
	pfileio->hFile = CreateFile(
				szLocalPath, 
				GENERIC_READ | GENERIC_WRITE, 
				FILE_SHARE_READ, 
				NULL, 
				fForceDownload?CREATE_ALWAYS:OPEN_ALWAYS, 
				FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN |
				FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING, 
				NULL);
	if (pfileio->hFile == INVALID_HANDLE_VALUE)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Error;
	}

	// We will figure out if we will try to resume a possibly-partially
	// downloaded file ...
	liResumeFrom.QuadPart = 0;
	if (!fForceDownload)
	{
		// Get the file size
		if (!GetFileSizeEx(pfileio->hFile, &liResumeFrom))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			goto Error;
		}

		// No point resuming if the file size is zero anyway
		if (liResumeFrom.QuadPart != 0)
		{
			// Our asynchronous writes must be sector aligned, so we will
			// round it down to the sector boundary if it is somehow not
			// aligned right.
			if ((liResumeFrom.u.LowPart & (XBOX_HD_SECTOR_SIZE - 1)) != 0)
				liResumeFrom.u.LowPart &= ~(XBOX_HD_SECTOR_SIZE - 1);

			// Adjust the file pointer to the right offset
			if (!SetFilePointerEx(pfileio->hFile, 
							liResumeFrom, &liResumeFrom, FILE_BEGIN))
			{
				hr = HRESULT_FROM_WIN32(GetLastError());
				goto Error;
			}

			// Set up all our counters as if we already got liResume bytes
			pxrlasync->uliTotalReceived.QuadPart = liResumeFrom.QuadPart;
			pxrlasync->uliTotalWritten.QuadPart = liResumeFrom.QuadPart;
			pxrlasync->uliFileSize.QuadPart = liResumeFrom.QuadPart;
		
			// This will cause an attempt to resume, now we need 
			// the last write date of the file. We should not use the
			// creation time, because if the file alsready had been
			// restored before, we might be forced to download the
			// whole thing again.
			if (GetFileTime(pfileio->hFile, NULL, NULL, &ftLastWritten))
				pftLastModified = &ftLastWritten;
		}
	}	

	// Call the more generic XOnlineDownload
	hr = Download(szResourcePath, 
				pbExtraHeaders, cbExtraHeaders, 
				pftLastModified, liResumeFrom, pxrlasync);
	if (FAILED(hr))
		goto Error;

	// Return the context as an opaque handle
	*phTask = (XONLINETASK_HANDLE)pxrlasync;

Cleanup:	
	return(XoLeave(hr));

Error:

	// Failed setup, make sure we clean up everything
	if (pfileio->hFile && (pfileio->hFile != INVALID_HANDLE_VALUE))
		CloseHandle(pfileio->hFile);
	if (pxrlasyncext)
		SysFree(pxrlasyncext);
	goto Cleanup;
}

// Function to get the download progress
HRESULT
CXo::XOnlineDownloadGetProgress(
			XONLINETASK_HANDLE	hTask,
			DWORD				*pdwPercentDone,
			ULARGE_INTEGER		*puliNumerator,
			ULARGE_INTEGER		*puliDenominator
			)
{
    XoEnter("XOnlineDownloadGetProgress");
    XoCheck(hTask != NULL);

	PXRL_ASYNC	pxrlasync = (PXRL_ASYNC)hTask;

	if (puliNumerator)
		puliNumerator->QuadPart = pxrlasync->uliTotalReceived.QuadPart;
	if (puliDenominator)
		puliDenominator->QuadPart = pxrlasync->uliContentLength.QuadPart;
	if (pdwPercentDone)
	{
		if (pxrlasync->uliContentLength.QuadPart != 0)
		{
			*pdwPercentDone = 
				(DWORD)((pxrlasync->uliTotalReceived.QuadPart * 100)/
					pxrlasync->uliContentLength.QuadPart);
			if (*pdwPercentDone > 100)
				*pdwPercentDone = 100;
		}
		else
			*pdwPercentDone = 0;
	}

	return(XoLeave(S_OK));
}

// Helper function to return the results of a download
HRESULT 
CXo::XOnlineDownloadGetResults(
			XONLINETASK_HANDLE	hTask,
			LPBYTE				*ppbBuffer,
			DWORD				*pcbBuffer,
			ULARGE_INTEGER		*puliTotalReceived,
			ULARGE_INTEGER		*puliContentLength,
			DWORD				*pdwExtendedStatus,
			FILETIME			*pftTimestamp,
			FILETIME			*pftLastModified
			)
{
    XoEnter("XOnlineDownloadGetResults");
    XoCheck(hTask != NULL);

	PXRL_ASYNC	pxrlasync = (PXRL_ASYNC)hTask;

	TaskVerifyContext(&(pxrlasync->xontask));

	// Fill in all the values the caller is interested in
	if (ppbBuffer)
		*ppbBuffer = pxrlasync->pBuffer;
	if (pcbBuffer)
		*pcbBuffer = pxrlasync->dwCurrent;
	if (puliTotalReceived)
		puliTotalReceived->QuadPart = pxrlasync->uliTotalReceived.QuadPart;
	if (puliContentLength)
		puliContentLength->QuadPart = pxrlasync->uliContentLength.QuadPart;
	if (pdwExtendedStatus)
		*pdwExtendedStatus = pxrlasync->dwExtendedStatus;
	if (pftTimestamp)
		memcpy(pftTimestamp, &(pxrlasync->ftResponse), sizeof(FILETIME));
	if (pftLastModified)
		memcpy(pftLastModified, &(pxrlasync->ftLastModified), sizeof(FILETIME));

	return(XoLeave(pxrlasync->hrFinal));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\dvdload.cpp ===
/*++

Copyright (c) Microsoft Corporation

Author:
    Keith Lau (keithlau)

Description:
	Module implementing DVD "download":
		DownloadFromDVD

	This is the "catch-all" function to do any "content download"
	kind of operation using a DVD as the source instead of going
	online.

Module Name:

    dvdload.c

--*/

#include "xonp.h"
#include "xonver.h"

//
// Define enumerated types that describe the states for each operation
//
typedef enum
{
	dvddlPreConnect = 0,
	dvddlEmulateHeaders,
	dvddlProcessData,
	dvddlPostDownload,
	dvddlCleanup,
	dvddlDone

} DVD_DOWNLOAD_STATES;

//
// ==============================================================
//   S T A T E   M A C H I N E   D E F I N I T I O N S
// ==============================================================
//

//
// Note we will reuse the XRL_ASYNC struct because this provides maximum 
// compatibility for the content download code. It also has everything
// we will need anyway.
//

// Define the state machines for XOnlineDVDDownload

//
// Pre "connect" extension state
//
HRESULT CXo::dvddlPreConnectHandler(
			PXRL_ASYNC	pxrlasync
			)
{
	HRESULT					hr = S_OK;
	PXRL_DOWNLOAD_EXTENSION	pxrldlext = &(pxrlasync->xrlext.dl);

    if (!pxrldlext->hTaskPreConnect)
    	goto SkipPre;

	// Simple logic: keep pumping the handle until we are told to 
	// stop, then move on to the connect phase
	hr = XOnlineTaskContinue(pxrldlext->hTaskPreConnect);
	if (XONLINETASK_STATUS_AVAILABLE(hr))
	{
		// The task had returned results, see if it succeeded
		if (FAILED(hr))
			goto Error;

		// See if the pre-connect task actually tells us to skip
		// the "downlaod" and go right to the post-process
		if (hr == XONLINE_S_XRL_EXTENSION_SKIP_TO_POST)
		{
			hr = S_OK;
			
			// see if there is any post-download work
			if ((pxrldlext->hTaskPostDownload != NULL) &&
				(pxrldlext->pfnInitializeTask != NULL))
			{
				hr = (this->*(pxrldlext->pfnInitializeTask))(
							xrldlextPostDownload, pxrlasync, 
							pxrldlext->hTaskPostDownload);
				if (FAILED(hr))
					goto Error;
			}

			// Got post download work, do that
			pxrlasync->dwCurrentState = dvddlPostDownload;

			goto Cleanup;
		}

SkipPre:
		// Set the next state to read and process data
		pxrlasync->dwCurrentState = dvddlEmulateHeaders;
	}

Cleanup:
	return(S_OK);

Error:
	// We encountered a hard error. Set next state to done.
	pxrlasync->hrFinal = hr;
	pxrlasync->dwCurrentState = dvddlCleanup;
	goto Cleanup;
}

//
// Emulate headers extension state
//
HRESULT CXo::dvddlEmulateHeadersHandler(
			PXRL_ASYNC	pxrlasync
			)
{
	HRESULT			hr = S_OK;
	DWORD			cbRead;
	FILETIME		ftZero = { 0, 0 };
	PXRL_DOWNLOAD_EXTENSION	pxrldlext = &(pxrlasync->xrlext.dl);

	// Straightforward "download" from scratch, emulate an HTTP 200
	pxrlasync->dwExtendedStatus = 200;

	// Now see if we have to deal with the resume stuff
	if (CompareFileTime(&(pxrlasync->ftLastModified), &ftZero) != 0)
	{
		// Now see if the file on DVD is older than our specified timestamp
		if (CompareFileTime(&(pxrlasync->ftLastModified), &pxrlasync->ftResponse) > 0)
		{
			// Timestamp newer than DVD file, resume
			pxrlasync->uliContentLength.QuadPart -= pxrlasync->uliFileSize.QuadPart;
			if (pxrlasync->uliContentLength.QuadPart > 0)
				pxrlasync->dwExtendedStatus = 206;
			else
				pxrlasync->dwExtendedStatus = 416;
		}
	}

	// Enulate a "Done headers" callback
	hr = (this->*(pxrldlext->pfnDoneHeaders))(pxrlasync);
	if (FAILED(hr))
		goto Error;

	// OK, start reading data from the file, synchronously  :-)
	if (!ReadFile(pxrlasync->fileio.hFile, 
				pxrlasync->pBuffer, 
				pxrlasync->cbBuffer, &cbRead, NULL))
	{
		HRESULT_FROM_WIN32(GetLastError());
		goto Error;
	}

	// Now massage the pointers
	pxrlasync->dwCurrent = cbRead;
	pxrlasync->uliTotalReceived.QuadPart += cbRead;

	// Make sure we are NOT in header mode
	pxrlasync->dwTemp = 0;

	// Initialize the process data subtask if there is an initialization
	// function
	if (pxrldlext->pfnInitializeTask)
	{
		hr = (this->*(pxrldlext->pfnInitializeTask))(
					xrldlextProcessData, pxrlasync, 
					pxrldlext->hTaskProcessData);
		if (FAILED(hr))
			goto Error;
	}

	// Process data
	pxrlasync->dwCurrentState = dvddlProcessData;

Cleanup:
	return(S_OK);

Error:
	// We encountered a hard error. Set next state to done.
	pxrlasync->hrFinal = hr;
	pxrlasync->dwCurrentState = dvddlCleanup;
	goto Cleanup;
}

//
// Process Data extension state
//
HRESULT CXo::dvddlProcessDataHandler(
			PXRL_ASYNC	pxrlasync
			)
{
	HRESULT					hr = S_OK;
	DWORD					cbRead;
	PXRL_DOWNLOAD_EXTENSION pxrldlext = &(pxrlasync->xrlext.dl);

    Assert(pxrldlext->hTaskProcessData != NULL);

	// Simple logic: keep pumping the handle until we are told to 
	// stop, then move on to the connect phase
	hr = XOnlineTaskContinue(pxrldlext->hTaskProcessData);
	if (XONLINETASK_STATUS_AVAILABLE(hr))
	{
		// The task had returned results, see if it succeeded
		if (FAILED(hr))
			goto Error;

		// See if we're done completely
		hr = (this->*(pxrldlext->pfnCompleted))(pxrlasync);
		if (FAILED(hr))
			goto Error;

		if (hr == S_OK)
		{
			// see if there is any post-download work
			if ((pxrldlext->hTaskPostDownload != NULL) &&
				(pxrldlext->pfnInitializeTask != NULL))
			{
				hr = (this->*(pxrldlext->pfnInitializeTask))(
							xrldlextPostDownload, 
							pxrlasync, pxrldlext->hTaskPostDownload);
				if (FAILED(hr))
					goto Error;
			}

			// Got post download work, do that
			pxrlasync->dwCurrentState = dvddlPostDownload;
		}
		else
		{
			// OK, we will need to read more data into the buffer, just read
			// as much as we can fit in the remaining bytes. Synchronously   :-)
			if (!ReadFile(pxrlasync->fileio.hFile, 
						pxrlasync->pBuffer + pxrlasync->dwCurrent, 
						pxrlasync->cbBuffer - pxrlasync->dwCurrent, &cbRead, NULL))
			{
				HRESULT_FROM_WIN32(GetLastError());
				goto Error;
			}

			// If we get zero bytes, then the pacakge is invalid
			Assert(cbRead > 0);
			if (cbRead == 0)
			{
				hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
				goto Error;
			}

			// Now massage the pointers
			pxrlasync->dwCurrent += cbRead;
			pxrlasync->uliTotalReceived.QuadPart += cbRead;

			// Stay in this state ...
		}
	}

Cleanup:
	return(S_OK);

Error:
	// We encountered a hard error. Set next state to done.
	pxrlasync->hrFinal = hr;
	pxrlasync->dwCurrentState = dvddlCleanup;
	goto Cleanup;
}

//
// Post "download" extension state
//
HRESULT CXo::dvddlPostDownloadHandler(
			PXRL_ASYNC	pxrlasync
			)
{
	HRESULT					hr = S_OK;
	PXRL_DOWNLOAD_EXTENSION pxrldlext = &(pxrlasync->xrlext.dl);

    if (!pxrldlext->hTaskPostDownload)
    	goto SkipPost;

	// Simple logic: keep pumping the handle until we are told to 
	// stop, then move on to the connect phase
	hr = XOnlineTaskContinue(pxrldlext->hTaskPostDownload);
	if (XONLINETASK_STATUS_AVAILABLE(hr))
	{
		// The task had returned results, see if it succeeded
		if (FAILED(hr))
			goto Error;

SkipPost:
		// Alright, we're all done, jump right to cleanup
		pxrlasync->dwCurrentState = dvddlCleanup;
	}

Cleanup:
	return(S_OK);

Error:
	// We encountered a hard error. Set next state to done.
	pxrlasync->hrFinal = hr;
	pxrlasync->dwCurrentState = dvddlCleanup;
	goto Cleanup;
}

//
// Cleanup
//
HRESULT CXo::dvddlCleanupHandler(PXRL_ASYNC pxrlasync)
{
	// Call the generic handler
	XRL_CleanupHandler(pxrlasync);
	
	// We are done
	pxrlasync->dwCurrentState = dvddlDone;

	return(S_OK);
}

//
// Array
// of handlers for DownloadFromDVD
//
const PFNXRL_HANDLER CXo::s_rgpfndvddlHandlers[] =
{
    CXo::dvddlPreConnectHandler,
	CXo::dvddlEmulateHeadersHandler,
	CXo::dvddlProcessDataHandler,
    CXo::dvddlPostDownloadHandler,
    CXo::dvddlCleanupHandler
};

//
// Implement the top-level do work function
//
HRESULT CXo::dvddlContinue(
			XONLINETASK_HANDLE	hTask
			)
{
	return(XRL_MainContinue(hTask, s_rgpfndvddlHandlers, dvddlDone));
}				

//
// Function to kick off "downloading" from DVD
//
HRESULT CXo::DownloadFromDVD(
			LPCSTR				szResourcePath,
			FILETIME			*pftModifiedSince, 
			LARGE_INTEGER		liResumeFrom,
			PXRL_ASYNC			pxrlasync
			)
{
	HRESULT					hr = S_OK;
	HANDLE					hFile = INVALID_HANDLE_VALUE;
	PXRL_DOWNLOAD_EXTENSION pxrldlext = &(pxrlasync->xrlext.dl);
	BY_HANDLE_FILE_INFORMATION bhfi;

    Assert(NULL != pxrlasync);
    Assert(NULL != szResourcePath);

    // Make sure the required callbacks are supplied
    Assert(NULL != pxrlasync->xrlext.dl.pfnDoneHeaders);
    Assert(NULL != pxrlasync->xrlext.dl.pfnProcessData);
    Assert(NULL != pxrlasync->xrlext.dl.pfnCompleted);
    Assert(NULL != pxrldlext->hTaskProcessData);

	// Modify nothing except fill in our work function
	pxrlasync->xontask.pfnContinue = dvddlContinue;
	pxrlasync->xontask.pfnClose = XRL_MainClose;

	// The socket API requires that we have an event handle in order
	// for the async I/O to happen. If the caller has not provided us
	// with an event, we have to create it here
	hr = XRL_CreateWorkEventIfNecessary(pxrlasync, NULL);
	if (FAILED(hr))
		goto Error;

	// Make sure the event is set
	SetEvent(pxrlasync->xontask.hEventWorkAvailable);

	// Mark as download
	pxrlasync->fDownload = TRUE;

	// Determine the next state depending on whether we have
	// any pre-connect work to do ...
	if ((pxrldlext->hTaskPreConnect != NULL) && 
		(pxrldlext->pfnInitializeTask != NULL))
	{
		hr = (this->*(pxrldlext->pfnInitializeTask))(
					xrldlextPreConnect, pxrlasync, 
					pxrldlext->hTaskPreConnect);
		if (FAILED(hr))
			goto Error;
	}

	// Next state is the pre-connect handler
	pxrlasync->dwCurrentState = dvddlPreConnect;

    // Build the request headers, save the request size (i.e. send
    // buffer size) in pxrlasync->wsabuf for transmission later
	pxrlasync->wsabuf.len = pxrlasync->cbBuffer;
	pxrlasync->wsabuf.buf = (char *)pxrlasync->pBuffer;

	// Now, open the source file for synchronous reading
	hFile = CreateFile(szResourcePath,
				GENERIC_READ, 
				FILE_SHARE_READ, 
				NULL, 
				OPEN_EXISTING, 
				FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, 
				NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Error;
	}

	// Get file attributes
	if (!GetFileInformationByHandle(hFile, &bhfi))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Error;
	}

	// Save the file size
	pxrlasync->uliContentLength.u.LowPart = bhfi.nFileSizeLow;
	pxrlasync->uliContentLength.u.HighPart = bhfi.nFileSizeHigh;
	pxrlasync->uliTotalReceived.QuadPart = 0;

	if (pftModifiedSince)
	{
		// Well, try to emulate a resume, first check if the resume
		// point makes sense
		if ((pxrlasync->uliContentLength.QuadPart <= pxrlasync->uliFileSize.QuadPart))
		{
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
			goto Error;
		}

		// Save the info for later
		pxrlasync->ftLastModified = *pftModifiedSince;
		pxrlasync->ftResponse = bhfi.ftCreationTime;
		pxrlasync->uliFileSize.QuadPart = (ULONGLONG)liResumeFrom.QuadPart;
	}
	else
	{
		// Don't try to resume
		ZeroMemory(&pxrlasync->ftLastModified, sizeof(FILETIME));
	}

	// Hand over the file handle to xrlasync
	pxrlasync->fileio.hFile = hFile;
	hFile = INVALID_HANDLE_VALUE;

    // Initialize the last state change
    pxrlasync->dwLastStateChange = GetTickCount();

Cleanup:	
	return(hr);

Error:
	if (hFile != INVALID_HANDLE_VALUE)
		CloseHandle(hFile);

	XRL_CleanupHandler(pxrlasync);
	goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\krb5.cpp ===
#include "xonp.h"
#include "xonver.h"

//ASN1module_t KRB5_Module = NULL;

static int ASN1CALL ASN1Enc_PKERB_AUTHORIZATION_DATA_LIST(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_LIST *val);
static int ASN1CALL ASN1Enc_PKERB_IF_RELEVANT_AUTH_DATA(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_IF_RELEVANT_AUTH_DATA *val);
static int ASN1CALL ASN1Enc_KERB_PA_PAC_REQUEST_EX_pac_sections(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PAC_REQUEST_EX_pac_sections *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_BODY_encryption_type(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_encryption_type *val);
static int ASN1CALL ASN1Enc_PKERB_TICKET_EXTENSIONS_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_TICKET_EXTENSIONS_Seq *val);
static int ASN1CALL ASN1Enc_KERB_PRINCIPAL_NAME_name_string(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PRINCIPAL_NAME_name_string *val);
static int ASN1CALL ASN1Enc_PKERB_LAST_REQUEST_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_LAST_REQUEST_Seq *val);
static int ASN1CALL ASN1Enc_PKERB_AUTHORIZATION_DATA_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_Seq *val);
static int ASN1CALL ASN1Enc_PKERB_HOST_ADDRESSES_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_HOST_ADDRESSES_Seq *val);
static int ASN1CALL ASN1Enc_KERB_HOST_ADDRESS(ASN1encoding_t enc, ASN1uint32_t tag, KERB_HOST_ADDRESS *val);
static int ASN1CALL ASN1Enc_PKERB_HOST_ADDRESSES(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_HOST_ADDRESSES *val);
static int ASN1CALL ASN1Enc_PKERB_AUTHORIZATION_DATA(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_AUTHORIZATION_DATA *val);
static int ASN1CALL ASN1Enc_PKERB_LAST_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_LAST_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_PRINCIPAL_NAME(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PRINCIPAL_NAME *val);
static int ASN1CALL ASN1Enc_PKERB_TICKET_EXTENSIONS(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_TICKET_EXTENSIONS *val);
static int ASN1CALL ASN1Enc_KERB_TRANSITED_ENCODING(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TRANSITED_ENCODING *val);
static int ASN1CALL ASN1Enc_KERB_PA_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_DATA *val);
static int ASN1CALL ASN1Enc_PKERB_PREAUTH_DATA_LIST(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_PREAUTH_DATA_LIST *val);
static int ASN1CALL ASN1Enc_KERB_SAFE_BODY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SAFE_BODY *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_PRIV(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_PRIV *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_CRED(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_CRED *val);
static int ASN1CALL ASN1Enc_KERB_ERROR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ERROR *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_DATA *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTION_KEY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTION_KEY *val);
static int ASN1CALL ASN1Enc_KERB_CHECKSUM(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CHECKSUM *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_TIMESTAMP(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_TIMESTAMP *val);
static int ASN1CALL ASN1Enc_KERB_SALTED_ENCRYPTED_TIMESTAMP(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SALTED_ENCRYPTED_TIMESTAMP *val);
static int ASN1CALL ASN1Enc_KERB_ETYPE_INFO_ENTRY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ETYPE_INFO_ENTRY *val);
static int ASN1CALL ASN1Enc_PKERB_ETYPE_INFO(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_ETYPE_INFO *val);
static int ASN1CALL ASN1Enc_KERB_TGT_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGT_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_PKCS_SIGNATURE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PKCS_SIGNATURE *val);
static int ASN1CALL ASN1Enc_KERB_ALGORITHM_IDENTIFIER(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ALGORITHM_IDENTIFIER *val);
static int ASN1CALL ASN1Enc_KERB_SIGNATURE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNATURE *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REP(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REP *val);
static int ASN1CALL ASN1Enc_KERB_ENVELOPED_KEY_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENVELOPED_KEY_PACKAGE *val);
static int ASN1CALL ASN1Enc_KERB_REPLY_KEY_PACKAGE2(ASN1encoding_t enc, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE2 *val);
static int ASN1CALL ASN1Enc_KERB_REPLY_KEY_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE *val);
static int ASN1CALL ASN1Enc_KERB_KDC_DH_KEY_INFO(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_DH_KEY_INFO *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REQ *val);
static int ASN1CALL ASN1Enc_KERB_KERBEROS_NAME(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KERBEROS_NAME *val);
static int ASN1CALL ASN1Enc_KERB_PK_AUTHENTICATOR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PK_AUTHENTICATOR *val);
static int ASN1CALL ASN1Enc_KERB_SUBJECT_PUBLIC_KEY_INFO(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SUBJECT_PUBLIC_KEY_INFO *val);
static int ASN1CALL ASN1Enc_KERB_DH_PARAMTER(ASN1encoding_t enc, ASN1uint32_t tag, KERB_DH_PARAMTER *val);
static int ASN1CALL ASN1Enc_KERB_CERTIFICATE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CERTIFICATE *val);
static int ASN1CALL ASN1Enc_KERB_TYPED_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TYPED_DATA *val);
static int ASN1CALL ASN1Enc_KERB_KDC_ISSUED_AUTH_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_ISSUED_AUTH_DATA *val);
static int ASN1CALL ASN1Enc_KERB_PA_SERV_REFERRAL(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_SERV_REFERRAL *val);
static int ASN1CALL ASN1Enc_KERB_PA_PAC_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PAC_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_CHANGE_PASSWORD_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CHANGE_PASSWORD_DATA *val);
static int ASN1CALL ASN1Enc_KERB_ERROR_METHOD_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ERROR_METHOD_DATA *val);
static int ASN1CALL ASN1Enc_KERB_EXT_ERROR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_EXT_ERROR *val);
static int ASN1CALL ASN1Enc_KERB_PA_FOR_USER(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_FOR_USER *val);
static int ASN1CALL ASN1Enc_KERB_PA_PAC_REQUEST_EX(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PAC_REQUEST_EX *val);
static int ASN1CALL ASN1Enc_KERB_KDC_ISSUED_AUTH_DATA_elements(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_ISSUED_AUTH_DATA_elements *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ2_trusted_certifiers(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_trusted_certifiers *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ2_user_certs(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_user_certs *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REP2_kdc_cert(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REP2_kdc_cert *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REPLY_preauth_data(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REPLY_preauth_data *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_preauth_data(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REQUEST_preauth_data *val);
static int ASN1CALL ASN1Enc_KERB_TICKET(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TICKET *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_TICKET(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_TICKET *val);
static int ASN1CALL ASN1Enc_KERB_AUTHENTICATOR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AUTHENTICATOR *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_BODY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_REQUEST_BODY *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_KDC_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_KDC_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_AP_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AP_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_AP_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AP_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_AP_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_AP_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_SAFE_MESSAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SAFE_MESSAGE *val);
static int ASN1CALL ASN1Enc_KERB_PRIV_MESSAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PRIV_MESSAGE *val);
static int ASN1CALL ASN1Enc_KERB_CRED(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CRED *val);
static int ASN1CALL ASN1Enc_KERB_CRED_INFO(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CRED_INFO *val);
static int ASN1CALL ASN1Enc_KERB_TGT_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGT_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_SIGNED_REPLY_KEY_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNED_REPLY_KEY_PACKAGE *val);
static int ASN1CALL ASN1Enc_KERB_SIGNED_KDC_PUBLIC_VALUE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNED_KDC_PUBLIC_VALUE *val);
static int ASN1CALL ASN1Enc_KERB_TRUSTED_CAS(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TRUSTED_CAS *val);
static int ASN1CALL ASN1Enc_KERB_AUTH_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AUTH_PACKAGE *val);
static int ASN1CALL ASN1Enc_KERB_PA_COMPOUND_IDENTITY(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_COMPOUND_IDENTITY *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ_trusted_certifiers(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ_trusted_certifiers *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_CRED_ticket_info(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_ENCRYPTED_CRED_ticket_info *val);
static int ASN1CALL ASN1Enc_KERB_CRED_tickets(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_CRED_tickets *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_BODY_additional_tickets(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_additional_tickets *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_MARSHALLED_REQUEST_BODY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_MARSHALLED_REQUEST_BODY *val);
static int ASN1CALL ASN1Enc_KERB_AS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AS_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_TGS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGS_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_AS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_AS_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_TGS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_TGS_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REP2(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REP2 *val);
static int ASN1CALL ASN1Enc_KERB_SIGNED_AUTH_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNED_AUTH_PACKAGE *val);
static int ASN1CALL ASN1Enc_KERB_AS_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AS_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_TGS_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGS_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ2(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REQ2 *val);
static int ASN1CALL ASN1Dec_PKERB_AUTHORIZATION_DATA_LIST(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_LIST *val);
static int ASN1CALL ASN1Dec_PKERB_IF_RELEVANT_AUTH_DATA(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_IF_RELEVANT_AUTH_DATA *val);
static int ASN1CALL ASN1Dec_KERB_PA_PAC_REQUEST_EX_pac_sections(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PAC_REQUEST_EX_pac_sections *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_BODY_encryption_type(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_encryption_type *val);
static int ASN1CALL ASN1Dec_PKERB_TICKET_EXTENSIONS_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_TICKET_EXTENSIONS_Seq *val);
static int ASN1CALL ASN1Dec_KERB_PRINCIPAL_NAME_name_string(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PRINCIPAL_NAME_name_string *val);
static int ASN1CALL ASN1Dec_PKERB_LAST_REQUEST_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_LAST_REQUEST_Seq *val);
static int ASN1CALL ASN1Dec_PKERB_AUTHORIZATION_DATA_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_Seq *val);
static int ASN1CALL ASN1Dec_PKERB_HOST_ADDRESSES_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_HOST_ADDRESSES_Seq *val);
static int ASN1CALL ASN1Dec_KERB_HOST_ADDRESS(ASN1decoding_t dec, ASN1uint32_t tag, KERB_HOST_ADDRESS *val);
static int ASN1CALL ASN1Dec_PKERB_HOST_ADDRESSES(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_HOST_ADDRESSES *val);
static int ASN1CALL ASN1Dec_PKERB_AUTHORIZATION_DATA(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_AUTHORIZATION_DATA *val);
static int ASN1CALL ASN1Dec_PKERB_LAST_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_LAST_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_PRINCIPAL_NAME(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PRINCIPAL_NAME *val);
static int ASN1CALL ASN1Dec_PKERB_TICKET_EXTENSIONS(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_TICKET_EXTENSIONS *val);
static int ASN1CALL ASN1Dec_KERB_TRANSITED_ENCODING(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TRANSITED_ENCODING *val);
static int ASN1CALL ASN1Dec_KERB_PA_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_DATA *val);
static int ASN1CALL ASN1Dec_PKERB_PREAUTH_DATA_LIST(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_PREAUTH_DATA_LIST *val);
static int ASN1CALL ASN1Dec_KERB_SAFE_BODY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SAFE_BODY *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_PRIV(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_PRIV *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_CRED(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_CRED *val);
static int ASN1CALL ASN1Dec_KERB_ERROR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ERROR *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_DATA *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTION_KEY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTION_KEY *val);
static int ASN1CALL ASN1Dec_KERB_CHECKSUM(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CHECKSUM *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_TIMESTAMP(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_TIMESTAMP *val);
static int ASN1CALL ASN1Dec_KERB_SALTED_ENCRYPTED_TIMESTAMP(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SALTED_ENCRYPTED_TIMESTAMP *val);
static int ASN1CALL ASN1Dec_KERB_ETYPE_INFO_ENTRY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ETYPE_INFO_ENTRY *val);
static int ASN1CALL ASN1Dec_PKERB_ETYPE_INFO(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_ETYPE_INFO *val);
static int ASN1CALL ASN1Dec_KERB_TGT_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGT_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_PKCS_SIGNATURE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PKCS_SIGNATURE *val);
static int ASN1CALL ASN1Dec_KERB_ALGORITHM_IDENTIFIER(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ALGORITHM_IDENTIFIER *val);
static int ASN1CALL ASN1Dec_KERB_SIGNATURE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNATURE *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REP(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REP *val);
static int ASN1CALL ASN1Dec_KERB_ENVELOPED_KEY_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENVELOPED_KEY_PACKAGE *val);
static int ASN1CALL ASN1Dec_KERB_REPLY_KEY_PACKAGE2(ASN1decoding_t dec, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE2 *val);
static int ASN1CALL ASN1Dec_KERB_REPLY_KEY_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE *val);
static int ASN1CALL ASN1Dec_KERB_KDC_DH_KEY_INFO(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_DH_KEY_INFO *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REQ *val);
static int ASN1CALL ASN1Dec_KERB_KERBEROS_NAME(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KERBEROS_NAME *val);
static int ASN1CALL ASN1Dec_KERB_PK_AUTHENTICATOR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PK_AUTHENTICATOR *val);
static int ASN1CALL ASN1Dec_KERB_SUBJECT_PUBLIC_KEY_INFO(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SUBJECT_PUBLIC_KEY_INFO *val);
static int ASN1CALL ASN1Dec_KERB_DH_PARAMTER(ASN1decoding_t dec, ASN1uint32_t tag, KERB_DH_PARAMTER *val);
static int ASN1CALL ASN1Dec_KERB_CERTIFICATE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CERTIFICATE *val);
static int ASN1CALL ASN1Dec_KERB_TYPED_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TYPED_DATA *val);
static int ASN1CALL ASN1Dec_KERB_KDC_ISSUED_AUTH_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_ISSUED_AUTH_DATA *val);
static int ASN1CALL ASN1Dec_KERB_PA_SERV_REFERRAL(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_SERV_REFERRAL *val);
static int ASN1CALL ASN1Dec_KERB_PA_PAC_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PAC_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_CHANGE_PASSWORD_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CHANGE_PASSWORD_DATA *val);
static int ASN1CALL ASN1Dec_KERB_ERROR_METHOD_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ERROR_METHOD_DATA *val);
static int ASN1CALL ASN1Dec_KERB_EXT_ERROR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_EXT_ERROR *val);
static int ASN1CALL ASN1Dec_KERB_PA_FOR_USER(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_FOR_USER *val);
static int ASN1CALL ASN1Dec_KERB_PA_PAC_REQUEST_EX(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PAC_REQUEST_EX *val);
static int ASN1CALL ASN1Dec_KERB_KDC_ISSUED_AUTH_DATA_elements(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_ISSUED_AUTH_DATA_elements *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ2_trusted_certifiers(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_trusted_certifiers *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ2_user_certs(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_user_certs *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REP2_kdc_cert(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REP2_kdc_cert *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REPLY_preauth_data(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REPLY_preauth_data *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_preauth_data(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REQUEST_preauth_data *val);
static int ASN1CALL ASN1Dec_KERB_TICKET(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TICKET *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_TICKET(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_TICKET *val);
static int ASN1CALL ASN1Dec_KERB_AUTHENTICATOR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AUTHENTICATOR *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_BODY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_REQUEST_BODY *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_KDC_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_KDC_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_AP_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AP_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_AP_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AP_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_AP_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_AP_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_SAFE_MESSAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SAFE_MESSAGE *val);
static int ASN1CALL ASN1Dec_KERB_PRIV_MESSAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PRIV_MESSAGE *val);
static int ASN1CALL ASN1Dec_KERB_CRED(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CRED *val);
static int ASN1CALL ASN1Dec_KERB_CRED_INFO(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CRED_INFO *val);
static int ASN1CALL ASN1Dec_KERB_TGT_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGT_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_SIGNED_REPLY_KEY_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNED_REPLY_KEY_PACKAGE *val);
static int ASN1CALL ASN1Dec_KERB_SIGNED_KDC_PUBLIC_VALUE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNED_KDC_PUBLIC_VALUE *val);
static int ASN1CALL ASN1Dec_KERB_TRUSTED_CAS(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TRUSTED_CAS *val);
static int ASN1CALL ASN1Dec_KERB_AUTH_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AUTH_PACKAGE *val);
static int ASN1CALL ASN1Dec_KERB_PA_COMPOUND_IDENTITY(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_COMPOUND_IDENTITY *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ_trusted_certifiers(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ_trusted_certifiers *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_CRED_ticket_info(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_ENCRYPTED_CRED_ticket_info *val);
static int ASN1CALL ASN1Dec_KERB_CRED_tickets(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_CRED_tickets *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_BODY_additional_tickets(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_additional_tickets *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_MARSHALLED_REQUEST_BODY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_MARSHALLED_REQUEST_BODY *val);
static int ASN1CALL ASN1Dec_KERB_AS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AS_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_TGS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGS_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_AS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_AS_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_TGS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_TGS_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REP2(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REP2 *val);
static int ASN1CALL ASN1Dec_KERB_SIGNED_AUTH_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNED_AUTH_PACKAGE *val);
static int ASN1CALL ASN1Dec_KERB_AS_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AS_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_TGS_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGS_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ2(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REQ2 *val);
static void ASN1CALL ASN1Free_PKERB_AUTHORIZATION_DATA_LIST(PKERB_AUTHORIZATION_DATA_LIST *val);
static void ASN1CALL ASN1Free_PKERB_IF_RELEVANT_AUTH_DATA(PKERB_IF_RELEVANT_AUTH_DATA *val);
static void ASN1CALL ASN1Free_KERB_PA_PAC_REQUEST_EX_pac_sections(PKERB_PA_PAC_REQUEST_EX_pac_sections *val);
static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_BODY_encryption_type(PKERB_KDC_REQUEST_BODY_encryption_type *val);
static void ASN1CALL ASN1Free_PKERB_TICKET_EXTENSIONS_Seq(PKERB_TICKET_EXTENSIONS_Seq *val);
static void ASN1CALL ASN1Free_KERB_PRINCIPAL_NAME_name_string(PKERB_PRINCIPAL_NAME_name_string *val);
static void ASN1CALL ASN1Free_PKERB_LAST_REQUEST_Seq(PKERB_LAST_REQUEST_Seq *val);
static void ASN1CALL ASN1Free_PKERB_AUTHORIZATION_DATA_Seq(PKERB_AUTHORIZATION_DATA_Seq *val);
static void ASN1CALL ASN1Free_PKERB_HOST_ADDRESSES_Seq(PKERB_HOST_ADDRESSES_Seq *val);
static void ASN1CALL ASN1Free_KERB_HOST_ADDRESS(KERB_HOST_ADDRESS *val);
static void ASN1CALL ASN1Free_PKERB_HOST_ADDRESSES(PPKERB_HOST_ADDRESSES *val);
static void ASN1CALL ASN1Free_PKERB_AUTHORIZATION_DATA(PPKERB_AUTHORIZATION_DATA *val);
static void ASN1CALL ASN1Free_PKERB_LAST_REQUEST(PPKERB_LAST_REQUEST *val);
static void ASN1CALL ASN1Free_KERB_PRINCIPAL_NAME(KERB_PRINCIPAL_NAME *val);
static void ASN1CALL ASN1Free_PKERB_TICKET_EXTENSIONS(PPKERB_TICKET_EXTENSIONS *val);
static void ASN1CALL ASN1Free_KERB_TRANSITED_ENCODING(KERB_TRANSITED_ENCODING *val);
static void ASN1CALL ASN1Free_KERB_PA_DATA(KERB_PA_DATA *val);
static void ASN1CALL ASN1Free_PKERB_PREAUTH_DATA_LIST(PPKERB_PREAUTH_DATA_LIST *val);
static void ASN1CALL ASN1Free_KERB_SAFE_BODY(KERB_SAFE_BODY *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_PRIV(KERB_ENCRYPTED_PRIV *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_CRED(KERB_ENCRYPTED_CRED *val);
static void ASN1CALL ASN1Free_KERB_ERROR(KERB_ERROR *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_DATA(KERB_ENCRYPTED_DATA *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTION_KEY(KERB_ENCRYPTION_KEY *val);
static void ASN1CALL ASN1Free_KERB_CHECKSUM(KERB_CHECKSUM *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_TIMESTAMP(KERB_ENCRYPTED_TIMESTAMP *val);
static void ASN1CALL ASN1Free_KERB_SALTED_ENCRYPTED_TIMESTAMP(KERB_SALTED_ENCRYPTED_TIMESTAMP *val);
static void ASN1CALL ASN1Free_KERB_ETYPE_INFO_ENTRY(KERB_ETYPE_INFO_ENTRY *val);
static void ASN1CALL ASN1Free_PKERB_ETYPE_INFO(PPKERB_ETYPE_INFO *val);
static void ASN1CALL ASN1Free_KERB_TGT_REQUEST(KERB_TGT_REQUEST *val);
static void ASN1CALL ASN1Free_KERB_PKCS_SIGNATURE(KERB_PKCS_SIGNATURE *val);
static void ASN1CALL ASN1Free_KERB_ALGORITHM_IDENTIFIER(KERB_ALGORITHM_IDENTIFIER *val);
static void ASN1CALL ASN1Free_KERB_SIGNATURE(KERB_SIGNATURE *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REP(KERB_PA_PK_AS_REP *val);
static void ASN1CALL ASN1Free_KERB_ENVELOPED_KEY_PACKAGE(KERB_ENVELOPED_KEY_PACKAGE *val);
static void ASN1CALL ASN1Free_KERB_REPLY_KEY_PACKAGE2(KERB_REPLY_KEY_PACKAGE2 *val);
static void ASN1CALL ASN1Free_KERB_REPLY_KEY_PACKAGE(KERB_REPLY_KEY_PACKAGE *val);
static void ASN1CALL ASN1Free_KERB_KDC_DH_KEY_INFO(KERB_KDC_DH_KEY_INFO *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ(KERB_PA_PK_AS_REQ *val);
static void ASN1CALL ASN1Free_KERB_KERBEROS_NAME(KERB_KERBEROS_NAME *val);
static void ASN1CALL ASN1Free_KERB_PK_AUTHENTICATOR(KERB_PK_AUTHENTICATOR *val);
static void ASN1CALL ASN1Free_KERB_SUBJECT_PUBLIC_KEY_INFO(KERB_SUBJECT_PUBLIC_KEY_INFO *val);
static void ASN1CALL ASN1Free_KERB_CERTIFICATE(KERB_CERTIFICATE *val);
static void ASN1CALL ASN1Free_KERB_TYPED_DATA(KERB_TYPED_DATA *val);
static void ASN1CALL ASN1Free_KERB_KDC_ISSUED_AUTH_DATA(KERB_KDC_ISSUED_AUTH_DATA *val);
static void ASN1CALL ASN1Free_KERB_PA_SERV_REFERRAL(KERB_PA_SERV_REFERRAL *val);
static void ASN1CALL ASN1Free_KERB_CHANGE_PASSWORD_DATA(KERB_CHANGE_PASSWORD_DATA *val);
static void ASN1CALL ASN1Free_KERB_ERROR_METHOD_DATA(KERB_ERROR_METHOD_DATA *val);
static void ASN1CALL ASN1Free_KERB_PA_FOR_USER(KERB_PA_FOR_USER *val);
static void ASN1CALL ASN1Free_KERB_PA_PAC_REQUEST_EX(KERB_PA_PAC_REQUEST_EX *val);
static void ASN1CALL ASN1Free_KERB_KDC_ISSUED_AUTH_DATA_elements(PKERB_KDC_ISSUED_AUTH_DATA_elements *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ2_trusted_certifiers(PKERB_PA_PK_AS_REQ2_trusted_certifiers *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ2_user_certs(PKERB_PA_PK_AS_REQ2_user_certs *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REP2_kdc_cert(PKERB_PA_PK_AS_REP2_kdc_cert *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *val);
static void ASN1CALL ASN1Free_KERB_KDC_REPLY_preauth_data(PKERB_KDC_REPLY_preauth_data *val);
static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_preauth_data(PKERB_KDC_REQUEST_preauth_data *val);
static void ASN1CALL ASN1Free_KERB_TICKET(KERB_TICKET *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_TICKET(KERB_ENCRYPTED_TICKET *val);
static void ASN1CALL ASN1Free_KERB_AUTHENTICATOR(KERB_AUTHENTICATOR *val);
static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_BODY(KERB_KDC_REQUEST_BODY *val);
static void ASN1CALL ASN1Free_KERB_KDC_REPLY(KERB_KDC_REPLY *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_KDC_REPLY(KERB_ENCRYPTED_KDC_REPLY *val);
static void ASN1CALL ASN1Free_KERB_AP_REQUEST(KERB_AP_REQUEST *val);
static void ASN1CALL ASN1Free_KERB_AP_REPLY(KERB_AP_REPLY *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_AP_REPLY(KERB_ENCRYPTED_AP_REPLY *val);
static void ASN1CALL ASN1Free_KERB_SAFE_MESSAGE(KERB_SAFE_MESSAGE *val);
static void ASN1CALL ASN1Free_KERB_PRIV_MESSAGE(KERB_PRIV_MESSAGE *val);
static void ASN1CALL ASN1Free_KERB_CRED(KERB_CRED *val);
static void ASN1CALL ASN1Free_KERB_CRED_INFO(KERB_CRED_INFO *val);
static void ASN1CALL ASN1Free_KERB_TGT_REPLY(KERB_TGT_REPLY *val);
static void ASN1CALL ASN1Free_KERB_SIGNED_REPLY_KEY_PACKAGE(KERB_SIGNED_REPLY_KEY_PACKAGE *val);
static void ASN1CALL ASN1Free_KERB_SIGNED_KDC_PUBLIC_VALUE(KERB_SIGNED_KDC_PUBLIC_VALUE *val);
static void ASN1CALL ASN1Free_KERB_TRUSTED_CAS(KERB_TRUSTED_CAS *val);
static void ASN1CALL ASN1Free_KERB_AUTH_PACKAGE(KERB_AUTH_PACKAGE *val);
static void ASN1CALL ASN1Free_KERB_PA_COMPOUND_IDENTITY(PKERB_PA_COMPOUND_IDENTITY *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ_trusted_certifiers(PKERB_PA_PK_AS_REQ_trusted_certifiers *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_CRED_ticket_info(PKERB_ENCRYPTED_CRED_ticket_info *val);
static void ASN1CALL ASN1Free_KERB_CRED_tickets(PKERB_CRED_tickets *val);
static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_BODY_additional_tickets(PKERB_KDC_REQUEST_BODY_additional_tickets *val);
static void ASN1CALL ASN1Free_KERB_KDC_REQUEST(KERB_KDC_REQUEST *val);
static void ASN1CALL ASN1Free_KERB_MARSHALLED_REQUEST_BODY(KERB_MARSHALLED_REQUEST_BODY *val);
static void ASN1CALL ASN1Free_KERB_AS_REPLY(KERB_AS_REPLY *val);
static void ASN1CALL ASN1Free_KERB_TGS_REPLY(KERB_TGS_REPLY *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_AS_REPLY(KERB_ENCRYPTED_AS_REPLY *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_TGS_REPLY(KERB_ENCRYPTED_TGS_REPLY *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REP2(KERB_PA_PK_AS_REP2 *val);
static void ASN1CALL ASN1Free_KERB_SIGNED_AUTH_PACKAGE(KERB_SIGNED_AUTH_PACKAGE *val);
static void ASN1CALL ASN1Free_KERB_AS_REQUEST(KERB_AS_REQUEST *val);
static void ASN1CALL ASN1Free_KERB_TGS_REQUEST(KERB_TGS_REQUEST *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ2(KERB_PA_PK_AS_REQ2 *val);

typedef ASN1BerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[51] = {
    (ASN1EncFun_t) NULL,//ASN1Enc_PKERB_AUTHORIZATION_DATA_LIST,
    (ASN1EncFun_t) NULL,//ASN1Enc_PKERB_IF_RELEVANT_AUTH_DATA,
    (ASN1EncFun_t) NULL,//ASN1Enc_PKERB_PREAUTH_DATA_LIST,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_ENCRYPTED_PRIV,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTED_CRED,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_ERROR,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTED_DATA,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_ENCRYPTION_KEY,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_CHECKSUM,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTED_TIMESTAMP,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_SALTED_ENCRYPTED_TIMESTAMP,
    (ASN1EncFun_t) NULL,//ASN1Enc_PKERB_ETYPE_INFO,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_TGT_REQUEST,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_PKCS_SIGNATURE,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_PA_PK_AS_REP,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_REPLY_KEY_PACKAGE2,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_REPLY_KEY_PACKAGE,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_KDC_DH_KEY_INFO,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_PA_PK_AS_REQ,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_DH_PARAMTER,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_TYPED_DATA,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_KDC_ISSUED_AUTH_DATA,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_PA_SERV_REFERRAL,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_PA_PAC_REQUEST,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_CHANGE_PASSWORD_DATA,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_ERROR_METHOD_DATA,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_EXT_ERROR,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_PA_FOR_USER,
    (ASN1EncFun_t) ASN1Enc_KERB_PA_PAC_REQUEST_EX, //28
    (ASN1EncFun_t) ASN1Enc_KERB_TICKET, // 29
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_ENCRYPTED_TICKET,
    (ASN1EncFun_t) ASN1Enc_KERB_AUTHENTICATOR, // 31
    (ASN1EncFun_t) ASN1Enc_KERB_AP_REQUEST, // 32
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_AP_REPLY,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_ENCRYPTED_AP_REPLY,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_SAFE_MESSAGE,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_PRIV_MESSAGE,
    (ASN1EncFun_t) ASN1Enc_KERB_CRED, // 37
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_TGT_REPLY,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_SIGNED_REPLY_KEY_PACKAGE,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_AUTH_PACKAGE,
    (ASN1EncFun_t) ASN1Enc_KERB_PA_COMPOUND_IDENTITY,
    (ASN1EncFun_t) ASN1Enc_KERB_MARSHALLED_REQUEST_BODY, // 42
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_AS_REPLY,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_TGS_REPLY,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_ENCRYPTED_AS_REPLY,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_ENCRYPTED_TGS_REPLY,
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_PA_PK_AS_REP2,
    (ASN1EncFun_t) ASN1Enc_KERB_AS_REQUEST, //48
    (ASN1EncFun_t) ASN1Enc_KERB_TGS_REQUEST, //49
    (ASN1EncFun_t) NULL,//ASN1Enc_KERB_PA_PK_AS_REQ2,
};
typedef ASN1BerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[51] = {
    (ASN1DecFun_t) NULL,//ASN1Dec_PKERB_AUTHORIZATION_DATA_LIST,
    (ASN1DecFun_t) NULL,//ASN1Dec_PKERB_IF_RELEVANT_AUTH_DATA,
    (ASN1DecFun_t) NULL,//ASN1Dec_PKERB_PREAUTH_DATA_LIST,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_ENCRYPTED_PRIV,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_ENCRYPTED_CRED,
    (ASN1DecFun_t) ASN1Dec_KERB_ERROR,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_DATA,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_ENCRYPTION_KEY,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_CHECKSUM,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_ENCRYPTED_TIMESTAMP,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_SALTED_ENCRYPTED_TIMESTAMP,
    (ASN1DecFun_t) NULL,//ASN1Dec_PKERB_ETYPE_INFO,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_TGT_REQUEST,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_PKCS_SIGNATURE,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_PA_PK_AS_REP,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_REPLY_KEY_PACKAGE2,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_REPLY_KEY_PACKAGE,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_KDC_DH_KEY_INFO,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_PA_PK_AS_REQ,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_DH_PARAMTER,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_TYPED_DATA,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_KDC_ISSUED_AUTH_DATA,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_PA_SERV_REFERRAL,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_PA_PAC_REQUEST,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_CHANGE_PASSWORD_DATA,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_ERROR_METHOD_DATA,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_EXT_ERROR,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_PA_FOR_USER,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_PA_PAC_REQUEST_EX,
    (ASN1DecFun_t) ASN1Dec_KERB_TICKET,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_ENCRYPTED_TICKET,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_AUTHENTICATOR,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_AP_REQUEST,
    (ASN1DecFun_t) ASN1Dec_KERB_AP_REPLY,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_AP_REPLY,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_SAFE_MESSAGE,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_PRIV_MESSAGE,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_CRED,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_TGT_REPLY,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_SIGNED_REPLY_KEY_PACKAGE,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_AUTH_PACKAGE,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_PA_COMPOUND_IDENTITY,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_MARSHALLED_REQUEST_BODY,
    (ASN1DecFun_t) ASN1Dec_KERB_AS_REPLY,
    (ASN1DecFun_t) ASN1Dec_KERB_TGS_REPLY,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_AS_REPLY,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_TGS_REPLY,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_PA_PK_AS_REP2,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_AS_REQUEST,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_TGS_REQUEST,
    (ASN1DecFun_t) NULL,//ASN1Dec_KERB_PA_PK_AS_REQ2,
};
static const ASN1FreeFun_t freefntab[51] = {
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) NULL,
};
static const ULONG sizetab[51] = {
    SIZE_KRB5_Module_PDU_0,
    SIZE_KRB5_Module_PDU_1,
    SIZE_KRB5_Module_PDU_2,
    SIZE_KRB5_Module_PDU_3,
    SIZE_KRB5_Module_PDU_4,
    SIZE_KRB5_Module_PDU_5,
    SIZE_KRB5_Module_PDU_6,
    SIZE_KRB5_Module_PDU_7,
    SIZE_KRB5_Module_PDU_8,
    SIZE_KRB5_Module_PDU_9,
    SIZE_KRB5_Module_PDU_10,
    SIZE_KRB5_Module_PDU_11,
    SIZE_KRB5_Module_PDU_12,
    SIZE_KRB5_Module_PDU_13,
    SIZE_KRB5_Module_PDU_14,
    SIZE_KRB5_Module_PDU_15,
    SIZE_KRB5_Module_PDU_16,
    SIZE_KRB5_Module_PDU_17,
    SIZE_KRB5_Module_PDU_18,
    SIZE_KRB5_Module_PDU_19,
    SIZE_KRB5_Module_PDU_20,
    SIZE_KRB5_Module_PDU_21,
    SIZE_KRB5_Module_PDU_22,
    SIZE_KRB5_Module_PDU_23,
    SIZE_KRB5_Module_PDU_24,
    SIZE_KRB5_Module_PDU_25,
    SIZE_KRB5_Module_PDU_26,
    SIZE_KRB5_Module_PDU_27,
    SIZE_KRB5_Module_PDU_28,
    SIZE_KRB5_Module_PDU_29,
    SIZE_KRB5_Module_PDU_30,
    SIZE_KRB5_Module_PDU_31,
    SIZE_KRB5_Module_PDU_32,
    SIZE_KRB5_Module_PDU_33,
    SIZE_KRB5_Module_PDU_34,
    SIZE_KRB5_Module_PDU_35,
    SIZE_KRB5_Module_PDU_36,
    SIZE_KRB5_Module_PDU_37,
    SIZE_KRB5_Module_PDU_38,
    SIZE_KRB5_Module_PDU_39,
    SIZE_KRB5_Module_PDU_40,
    SIZE_KRB5_Module_PDU_41,
    SIZE_KRB5_Module_PDU_42,
    SIZE_KRB5_Module_PDU_43,
    SIZE_KRB5_Module_PDU_44,
    SIZE_KRB5_Module_PDU_45,
    SIZE_KRB5_Module_PDU_46,
    SIZE_KRB5_Module_PDU_47,
    SIZE_KRB5_Module_PDU_48,
    SIZE_KRB5_Module_PDU_49,
    SIZE_KRB5_Module_PDU_50,
};

/* forward declarations of values: */
/* definitions of value components: */
/* definitions of values: */

void ASN1CALL KRB5_Module_Startup(ASN1module_t pASN1Module)
{
    ASN1_InitModule(pASN1Module, 0x10000, ASN1_BER_RULE_DER, ASN1FLAGS_NOASSERT, 51, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x3562726b);
}

void ASN1CALL KRB5_Module_Cleanup(void)
{
}

static int ASN1CALL ASN1Enc_PKERB_AUTHORIZATION_DATA_LIST(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_LIST *val)
{
    if (!ASN1Enc_PKERB_AUTHORIZATION_DATA(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_AUTHORIZATION_DATA_LIST(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_LIST *val)
{
    if (!ASN1Dec_PKERB_AUTHORIZATION_DATA(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_AUTHORIZATION_DATA_LIST(PKERB_AUTHORIZATION_DATA_LIST *val)
{
    if (val) {
	ASN1Free_PKERB_AUTHORIZATION_DATA(val);
    }
}

static int ASN1CALL ASN1Enc_PKERB_IF_RELEVANT_AUTH_DATA(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_IF_RELEVANT_AUTH_DATA *val)
{
    if (!ASN1Enc_PKERB_AUTHORIZATION_DATA(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_IF_RELEVANT_AUTH_DATA(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_IF_RELEVANT_AUTH_DATA *val)
{
    if (!ASN1Dec_PKERB_AUTHORIZATION_DATA(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_IF_RELEVANT_AUTH_DATA(PKERB_IF_RELEVANT_AUTH_DATA *val)
{
    if (val) {
	ASN1Free_PKERB_AUTHORIZATION_DATA(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PAC_REQUEST_EX_pac_sections(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PAC_REQUEST_EX_pac_sections *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_PA_PAC_REQUEST_EX_pac_sections f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1BEREncS32(enc, 0x2, f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PAC_REQUEST_EX_pac_sections(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PAC_REQUEST_EX_pac_sections *val)
{
    PKERB_PA_PAC_REQUEST_EX_pac_sections *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_PA_PAC_REQUEST_EX_pac_sections)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1BERDecS32Val(dd, 0x2, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PAC_REQUEST_EX_pac_sections(PKERB_PA_PAC_REQUEST_EX_pac_sections *val)
{
    PKERB_PA_PAC_REQUEST_EX_pac_sections f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_BODY_encryption_type(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_encryption_type *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_KDC_REQUEST_BODY_encryption_type f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000008, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1BEREncS32(enc, 0x2, f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_BODY_encryption_type(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_encryption_type *val)
{
    PKERB_KDC_REQUEST_BODY_encryption_type *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000008, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_KDC_REQUEST_BODY_encryption_type)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1BERDecS32Val(dd, 0x2, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_BODY_encryption_type(PKERB_KDC_REQUEST_BODY_encryption_type *val)
{
    PKERB_KDC_REQUEST_BODY_encryption_type f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_PKERB_TICKET_EXTENSIONS_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_TICKET_EXTENSIONS_Seq *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->te_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->te_data).length, ((val)->te_data).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_TICKET_EXTENSIONS_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_TICKET_EXTENSIONS_Seq *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->te_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->te_data))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_TICKET_EXTENSIONS_Seq(PKERB_TICKET_EXTENSIONS_Seq *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->te_data);
    }
}

static int ASN1CALL ASN1Enc_KERB_PRINCIPAL_NAME_name_string(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PRINCIPAL_NAME_name_string *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_PRINCIPAL_NAME_name_string f;
    ASN1uint32_t nLenOff;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	t = lstrlenA(f->value);
	if (!ASN1DEREncCharString(enc, 0x1b, t, f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PRINCIPAL_NAME_name_string(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PRINCIPAL_NAME_name_string *val)
{
    PKERB_PRINCIPAL_NAME_name_string *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_PRINCIPAL_NAME_name_string)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1BERDecZeroCharString(dd, 0x1b, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PRINCIPAL_NAME_name_string(PKERB_PRINCIPAL_NAME_name_string *val)
{
    PKERB_PRINCIPAL_NAME_name_string f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1ztcharstring_free(f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_PKERB_LAST_REQUEST_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_LAST_REQUEST_Seq *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->last_request_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->last_request_value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_LAST_REQUEST_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_LAST_REQUEST_Seq *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->last_request_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->last_request_value))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_LAST_REQUEST_Seq(PKERB_LAST_REQUEST_Seq *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_PKERB_AUTHORIZATION_DATA_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_Seq *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->auth_data_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->auth_data).length, ((val)->auth_data).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_AUTHORIZATION_DATA_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_Seq *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->auth_data_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->auth_data))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_AUTHORIZATION_DATA_Seq(PKERB_AUTHORIZATION_DATA_Seq *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->auth_data);
    }
}

static int ASN1CALL ASN1Enc_PKERB_HOST_ADDRESSES_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_HOST_ADDRESSES_Seq *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->address_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->address).length, ((val)->address).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_HOST_ADDRESSES_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_HOST_ADDRESSES_Seq *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->address_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->address))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_HOST_ADDRESSES_Seq(PKERB_HOST_ADDRESSES_Seq *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->address);
    }
}

static int ASN1CALL ASN1Enc_KERB_HOST_ADDRESS(ASN1encoding_t enc, ASN1uint32_t tag, KERB_HOST_ADDRESS *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->addr_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->address).length, ((val)->address).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_HOST_ADDRESS(ASN1decoding_t dec, ASN1uint32_t tag, KERB_HOST_ADDRESS *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->addr_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->address))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_HOST_ADDRESS(KERB_HOST_ADDRESS *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->address);
    }
}

static int ASN1CALL ASN1Enc_PKERB_HOST_ADDRESSES(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_HOST_ADDRESSES *val)
{
    PPKERB_HOST_ADDRESSES f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_PKERB_HOST_ADDRESSES_Seq(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_HOST_ADDRESSES(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_HOST_ADDRESSES *val)
{
    PPKERB_HOST_ADDRESSES *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PPKERB_HOST_ADDRESSES)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_PKERB_HOST_ADDRESSES_Seq(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_HOST_ADDRESSES(PPKERB_HOST_ADDRESSES *val)
{
    PPKERB_HOST_ADDRESSES f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_PKERB_HOST_ADDRESSES_Seq(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_PKERB_AUTHORIZATION_DATA(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_AUTHORIZATION_DATA *val)
{
    PPKERB_AUTHORIZATION_DATA f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_PKERB_AUTHORIZATION_DATA_Seq(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_AUTHORIZATION_DATA(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_AUTHORIZATION_DATA *val)
{
    PPKERB_AUTHORIZATION_DATA *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PPKERB_AUTHORIZATION_DATA)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_PKERB_AUTHORIZATION_DATA_Seq(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_AUTHORIZATION_DATA(PPKERB_AUTHORIZATION_DATA *val)
{
    PPKERB_AUTHORIZATION_DATA f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_PKERB_AUTHORIZATION_DATA_Seq(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_PKERB_LAST_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_LAST_REQUEST *val)
{
    PPKERB_LAST_REQUEST f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_PKERB_LAST_REQUEST_Seq(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_LAST_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_LAST_REQUEST *val)
{
    PPKERB_LAST_REQUEST *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PPKERB_LAST_REQUEST)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_PKERB_LAST_REQUEST_Seq(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_LAST_REQUEST(PPKERB_LAST_REQUEST *val)
{
    PPKERB_LAST_REQUEST f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_PKERB_LAST_REQUEST_Seq(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_PRINCIPAL_NAME(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PRINCIPAL_NAME *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->name_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME_name_string(enc, 0, &(val)->name_string))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PRINCIPAL_NAME(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PRINCIPAL_NAME *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->name_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME_name_string(dd, 0, &(val)->name_string))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PRINCIPAL_NAME(KERB_PRINCIPAL_NAME *val)
{
    if (val) {
	ASN1Free_KERB_PRINCIPAL_NAME_name_string(&(val)->name_string);
    }
}

static int ASN1CALL ASN1Enc_PKERB_TICKET_EXTENSIONS(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_TICKET_EXTENSIONS *val)
{
    PPKERB_TICKET_EXTENSIONS f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_PKERB_TICKET_EXTENSIONS_Seq(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_TICKET_EXTENSIONS(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_TICKET_EXTENSIONS *val)
{
    PPKERB_TICKET_EXTENSIONS *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PPKERB_TICKET_EXTENSIONS)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_PKERB_TICKET_EXTENSIONS_Seq(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_TICKET_EXTENSIONS(PPKERB_TICKET_EXTENSIONS *val)
{
    PPKERB_TICKET_EXTENSIONS f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_PKERB_TICKET_EXTENSIONS_Seq(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_TRANSITED_ENCODING(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TRANSITED_ENCODING *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->transited_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->contents).length, ((val)->contents).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TRANSITED_ENCODING(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TRANSITED_ENCODING *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->transited_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->contents))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TRANSITED_ENCODING(KERB_TRANSITED_ENCODING *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->contents);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_DATA *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->preauth_data_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->preauth_data).length, ((val)->preauth_data).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_DATA *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->preauth_data_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->preauth_data))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_DATA(KERB_PA_DATA *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->preauth_data);
    }
}

static int ASN1CALL ASN1Enc_PKERB_PREAUTH_DATA_LIST(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_PREAUTH_DATA_LIST *val)
{
    PPKERB_PREAUTH_DATA_LIST f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_PA_DATA(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_PREAUTH_DATA_LIST(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_PREAUTH_DATA_LIST *val)
{
    PPKERB_PREAUTH_DATA_LIST *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PPKERB_PREAUTH_DATA_LIST)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_PA_DATA(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_PREAUTH_DATA_LIST(PPKERB_PREAUTH_DATA_LIST *val)
{
    PPKERB_PREAUTH_DATA_LIST f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_PA_DATA(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_SAFE_BODY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SAFE_BODY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->user_data).length, ((val)->user_data).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->timestamp))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->usec))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1BEREncU32(enc, 0x2, (val)->sequence_number))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_HOST_ADDRESS(enc, 0, &(val)->sender_address))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_HOST_ADDRESS(enc, 0, &(val)->recipient_address))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SAFE_BODY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SAFE_BODY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->user_data))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->timestamp))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->usec))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecU32Val(dd0, 0x2, (ASN1uint32_t *) &(val)->sequence_number))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_HOST_ADDRESS(dd0, 0, &(val)->sender_address))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000005) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_HOST_ADDRESS(dd0, 0, &(val)->recipient_address))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SAFE_BODY(KERB_SAFE_BODY *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->user_data);
	if ((val)->o[0] & 0x80) {
	}
	ASN1Free_KERB_HOST_ADDRESS(&(val)->sender_address);
	if ((val)->o[0] & 0x10) {
	    ASN1Free_KERB_HOST_ADDRESS(&(val)->recipient_address);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_PRIV(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_PRIV *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000001c, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->user_data).length, ((val)->user_data).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->timestamp))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->usec))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1BEREncU32(enc, 0x2, (val)->sequence_number))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_HOST_ADDRESS(enc, 0, &(val)->sender_address))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_HOST_ADDRESS(enc, 0, &(val)->recipient_address))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_PRIV(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_PRIV *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000001c, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->user_data))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->timestamp))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->usec))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecU32Val(dd0, 0x2, (ASN1uint32_t *) &(val)->sequence_number))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_HOST_ADDRESS(dd0, 0, &(val)->sender_address))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000005) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_HOST_ADDRESS(dd0, 0, &(val)->recipient_address))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_PRIV(KERB_ENCRYPTED_PRIV *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->user_data);
	if ((val)->o[0] & 0x80) {
	}
	ASN1Free_KERB_HOST_ADDRESS(&(val)->sender_address);
	if ((val)->o[0] & 0x10) {
	    ASN1Free_KERB_HOST_ADDRESS(&(val)->recipient_address);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_CRED(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_CRED *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000001d, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_CRED_ticket_info(enc, 0, &(val)->ticket_info))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->timestamp))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->usec))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_HOST_ADDRESS(enc, 0, &(val)->sender_address))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_HOST_ADDRESS(enc, 0, &(val)->recipient_address))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_CRED(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_CRED *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000001d, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1Dec_KERB_ENCRYPTED_CRED_ticket_info(dd, 0, &(val)->ticket_info))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->timestamp))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->usec))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_HOST_ADDRESS(dd0, 0, &(val)->sender_address))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000005) {
	(val)->o[0] |= 0x8;
	if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_HOST_ADDRESS(dd0, 0, &(val)->recipient_address))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_CRED(KERB_ENCRYPTED_CRED *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTED_CRED_ticket_info(&(val)->ticket_info);
	if ((val)->o[0] & 0x40) {
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_KERB_HOST_ADDRESS(&(val)->sender_address);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_KERB_HOST_ADDRESS(&(val)->recipient_address);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ERROR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ERROR *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000001e, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->client_time))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->client_usec))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->server_time))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->server_usec))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->error_code))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x20) {
	t = lstrlenA((val)->client_realm);
	if (!ASN1BEREncExplicitTag(enc, 0x80000007, &nLenOff0))
	    return 0;
	if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->client_realm))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000008, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->client_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    t = lstrlenA((val)->realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000009, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x8000000a, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->server_name))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x8) {
	if (!ASN1BEREncExplicitTag(enc, 0x8000000b, &nLenOff0))
	    return 0;
	if (!ASN1DEREncCharString(enc, 0x1b, ((val)->error_text).length, ((val)->error_text).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1BEREncExplicitTag(enc, 0x8000000c, &nLenOff0))
	    return 0;
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->error_data).length, ((val)->error_data).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ERROR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ERROR *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000001e, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->client_time))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->client_usec))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->server_time))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->server_usec))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->error_code))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000007) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000007, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->client_realm))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000008) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000008, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->client_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000009, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x8000000a, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->server_name))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000b) {
	(val)->o[0] |= 0x8;
	if (!ASN1BERDecExplicitTag(dd, 0x8000000b, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecCharString(dd0, 0x1b, &(val)->error_text))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000c) {
	(val)->o[0] |= 0x4;
	if (!ASN1BERDecExplicitTag(dd, 0x8000000c, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->error_data))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ERROR(KERB_ERROR *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x20) {
	    ASN1ztcharstring_free((val)->client_realm);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->client_name);
	}
	ASN1ztcharstring_free((val)->realm);
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->server_name);
	if ((val)->o[0] & 0x8) {
	    ASN1charstring_free(&(val)->error_text);
	}
	if ((val)->o[0] & 0x4) {
	    ASN1octetstring_free(&(val)->error_data);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_DATA *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->encryption_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->cipher_text).length, ((val)->cipher_text).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_DATA *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->encryption_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->cipher_text))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_DATA(KERB_ENCRYPTED_DATA *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->cipher_text);
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTION_KEY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTION_KEY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->keytype))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->keyvalue).length, ((val)->keyvalue).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTION_KEY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTION_KEY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->keytype))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->keyvalue))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTION_KEY(KERB_ENCRYPTION_KEY *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->keyvalue);
    }
}

static int ASN1CALL ASN1Enc_KERB_CHECKSUM(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CHECKSUM *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->checksum_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->checksum).length, ((val)->checksum).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_CHECKSUM(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CHECKSUM *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->checksum_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->checksum))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_CHECKSUM(KERB_CHECKSUM *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->checksum);
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_TIMESTAMP(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_TIMESTAMP *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->timestamp))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->usec))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_TIMESTAMP(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_TIMESTAMP *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->timestamp))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->usec))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_TIMESTAMP(KERB_ENCRYPTED_TIMESTAMP *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_KERB_SALTED_ENCRYPTED_TIMESTAMP(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SALTED_ENCRYPTED_TIMESTAMP *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->timestamp))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->usec))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->salt).length, ((val)->salt).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SALTED_ENCRYPTED_TIMESTAMP(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SALTED_ENCRYPTED_TIMESTAMP *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->timestamp))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->usec))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->salt))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SALTED_ENCRYPTED_TIMESTAMP(KERB_SALTED_ENCRYPTED_TIMESTAMP *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->salt);
    }
}

static int ASN1CALL ASN1Enc_KERB_ETYPE_INFO_ENTRY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ETYPE_INFO_ENTRY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->encryption_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->salt).length, ((val)->salt).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ETYPE_INFO_ENTRY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ETYPE_INFO_ENTRY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->encryption_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->salt))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ETYPE_INFO_ENTRY(KERB_ETYPE_INFO_ENTRY *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1octetstring_free(&(val)->salt);
	}
    }
}

static int ASN1CALL ASN1Enc_PKERB_ETYPE_INFO(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_ETYPE_INFO *val)
{
    PPKERB_ETYPE_INFO f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_ETYPE_INFO_ENTRY(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_ETYPE_INFO(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_ETYPE_INFO *val)
{
    PPKERB_ETYPE_INFO *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PPKERB_ETYPE_INFO)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_ETYPE_INFO_ENTRY(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_ETYPE_INFO(PPKERB_ETYPE_INFO *val)
{
    PPKERB_ETYPE_INFO f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_ETYPE_INFO_ENTRY(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_TGT_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGT_REQUEST *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->server_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	t = lstrlenA((val)->server_realm);
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->server_realm))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TGT_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGT_REQUEST *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->server_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->server_realm))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TGT_REQUEST(KERB_TGT_REQUEST *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->server_name);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1ztcharstring_free((val)->server_realm);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_PKCS_SIGNATURE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PKCS_SIGNATURE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->encryption_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->signature).length, ((val)->signature).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PKCS_SIGNATURE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PKCS_SIGNATURE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->encryption_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->signature))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PKCS_SIGNATURE(KERB_PKCS_SIGNATURE *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->signature);
    }
}

static int ASN1CALL ASN1Enc_KERB_ALGORITHM_IDENTIFIER(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ALGORITHM_IDENTIFIER *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier(enc, 0x6, &(val)->algorithm))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncOpenType(enc, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ALGORITHM_IDENTIFIER(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ALGORITHM_IDENTIFIER *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier(dd, 0x6, &(val)->algorithm))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOpenType2(dd, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ALGORITHM_IDENTIFIER(KERB_ALGORITHM_IDENTIFIER *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->algorithm);
	if ((val)->o[0] & 0x80) {
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_SIGNATURE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNATURE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ALGORITHM_IDENTIFIER(enc, 0, &(val)->signature_algorithm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->pkcs_signature).length, ((val)->pkcs_signature).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SIGNATURE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNATURE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ALGORITHM_IDENTIFIER(dd0, 0, &(val)->signature_algorithm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->pkcs_signature))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SIGNATURE(KERB_SIGNATURE *val)
{
    if (val) {
	ASN1Free_KERB_ALGORITHM_IDENTIFIER(&(val)->signature_algorithm);
	ASN1bitstring_free(&(val)->pkcs_signature);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REP(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REP *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1DEREncOctetString(enc, 0x80000000, ((val)->u.dh_signed_data).length, ((val)->u.dh_signed_data).value))
	    return 0;
	break;
    case 2:
	if (!ASN1DEREncOctetString(enc, 0x80000001, ((val)->u.key_package).length, ((val)->u.key_package).value))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REP(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REP *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x80000000:
	(val)->choice = 1;
	if (!ASN1BERDecOctetString(dec, 0x80000000, &(val)->u.dh_signed_data))
	    return 0;
	break;
    case 0x80000001:
	(val)->choice = 2;
	if (!ASN1BERDecOctetString(dec, 0x80000001, &(val)->u.key_package))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REP(KERB_PA_PK_AS_REP *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1octetstring_free(&(val)->u.dh_signed_data);
	    break;
	case 2:
	    ASN1octetstring_free(&(val)->u.key_package);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ENVELOPED_KEY_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENVELOPED_KEY_PACKAGE *val)
{
    ASN1uint32_t nLenOff0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->u.encrypted_data))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
	break;
    case 2:
	if (!ASN1DEREncOctetString(enc, 0x80000004, ((val)->u.pkinit_enveloped_data).length, ((val)->u.pkinit_enveloped_data).value))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENVELOPED_KEY_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENVELOPED_KEY_PACKAGE *val)
{
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x80000001:
	(val)->choice = 1;
	if (!ASN1BERDecExplicitTag(dec, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->u.encrypted_data))
	    return 0;
	if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	    return 0;
	break;
    case 0x80000004:
	(val)->choice = 2;
	if (!ASN1BERDecOctetString(dec, 0x80000004, &(val)->u.pkinit_enveloped_data))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENVELOPED_KEY_PACKAGE(KERB_ENVELOPED_KEY_PACKAGE *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_KERB_ENCRYPTED_DATA(&(val)->u.encrypted_data);
	    break;
	case 2:
	    ASN1octetstring_free(&(val)->u.pkinit_enveloped_data);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_REPLY_KEY_PACKAGE2(ASN1encoding_t enc, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE2 *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->reply_key))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1DEREncBitString(enc, 0x3, ((val)->subject_public_key).length, ((val)->subject_public_key).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_REPLY_KEY_PACKAGE2(ASN1decoding_t dec, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE2 *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->reply_key))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecBitString(dd0, 0x3, &(val)->subject_public_key))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_REPLY_KEY_PACKAGE2(KERB_REPLY_KEY_PACKAGE2 *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTION_KEY(&(val)->reply_key);
	if ((val)->o[0] & 0x80) {
	    ASN1bitstring_free(&(val)->subject_public_key);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_REPLY_KEY_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->reply_key))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_REPLY_KEY_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->reply_key))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_REPLY_KEY_PACKAGE(KERB_REPLY_KEY_PACKAGE *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTION_KEY(&(val)->reply_key);
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_DH_KEY_INFO(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_DH_KEY_INFO *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->subject_public_key).length, ((val)->subject_public_key).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_DH_KEY_INFO(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_DH_KEY_INFO *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->subject_public_key))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_DH_KEY_INFO(KERB_KDC_DH_KEY_INFO *val)
{
    if (val) {
	ASN1bitstring_free(&(val)->subject_public_key);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REQ *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x80000000, ((val)->signed_auth_pack).length, ((val)->signed_auth_pack).value))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_KERB_PA_PK_AS_REQ_trusted_certifiers(enc, 0, &(val)->trusted_certifiers))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1DEREncOctetString(enc, 0x80000003, ((val)->kdc_cert).length, ((val)->kdc_cert).value))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1DEREncOctetString(enc, 0x80000004, ((val)->encryption_cert).length, ((val)->encryption_cert).value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REQ *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecOctetString(dd, 0x80000000, &(val)->signed_auth_pack))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_KERB_PA_PK_AS_REQ_trusted_certifiers(dd, 0, &(val)->trusted_certifiers))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecOctetString(dd, 0x80000003, &(val)->kdc_cert))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecOctetString(dd, 0x80000004, &(val)->encryption_cert))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ(KERB_PA_PK_AS_REQ *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->signed_auth_pack);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_PA_PK_AS_REQ_trusted_certifiers(&(val)->trusted_certifiers);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1octetstring_free(&(val)->kdc_cert);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1octetstring_free(&(val)->encryption_cert);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KERBEROS_NAME(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KERBEROS_NAME *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t t;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    t = lstrlenA((val)->realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->principal_name))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KERBEROS_NAME(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KERBEROS_NAME *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->principal_name))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KERBEROS_NAME(KERB_KERBEROS_NAME *val)
{
    if (val) {
	ASN1ztcharstring_free((val)->realm);
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->principal_name);
    }
}

static int ASN1CALL ASN1Enc_KERB_PK_AUTHENTICATOR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PK_AUTHENTICATOR *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->kdc_name))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    t = lstrlenA((val)->kdc_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->kdc_realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->cusec))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->client_time))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PK_AUTHENTICATOR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PK_AUTHENTICATOR *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->kdc_name))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->kdc_realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->cusec))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->client_time))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PK_AUTHENTICATOR(KERB_PK_AUTHENTICATOR *val)
{
    if (val) {
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->kdc_name);
	ASN1ztcharstring_free((val)->kdc_realm);
    }
}

static int ASN1CALL ASN1Enc_KERB_SUBJECT_PUBLIC_KEY_INFO(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SUBJECT_PUBLIC_KEY_INFO *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ALGORITHM_IDENTIFIER(enc, 0, &(val)->algorithm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->subjectPublicKey).length, ((val)->subjectPublicKey).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SUBJECT_PUBLIC_KEY_INFO(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SUBJECT_PUBLIC_KEY_INFO *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ALGORITHM_IDENTIFIER(dd0, 0, &(val)->algorithm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->subjectPublicKey))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SUBJECT_PUBLIC_KEY_INFO(KERB_SUBJECT_PUBLIC_KEY_INFO *val)
{
    if (val) {
	ASN1Free_KERB_ALGORITHM_IDENTIFIER(&(val)->algorithm);
	ASN1bitstring_free(&(val)->subjectPublicKey);
    }
}

static int ASN1CALL ASN1Enc_KERB_DH_PARAMTER(ASN1encoding_t enc, ASN1uint32_t tag, KERB_DH_PARAMTER *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->prime))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->base))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->private_value_length))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_DH_PARAMTER(ASN1decoding_t dec, ASN1uint32_t tag, KERB_DH_PARAMTER *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->prime))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->base))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->private_value_length))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_KERB_CERTIFICATE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CERTIFICATE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->cert_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->cert_data).length, ((val)->cert_data).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_CERTIFICATE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CERTIFICATE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->cert_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->cert_data))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_CERTIFICATE(KERB_CERTIFICATE *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->cert_data);
    }
}

static int ASN1CALL ASN1Enc_KERB_TYPED_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TYPED_DATA *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->data_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->data_value).length, ((val)->data_value).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TYPED_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TYPED_DATA *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->data_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->data_value))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TYPED_DATA(KERB_TYPED_DATA *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->data_value);
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_ISSUED_AUTH_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_ISSUED_AUTH_DATA *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_SIGNATURE(enc, 0, &(val)->checksum))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_KDC_ISSUED_AUTH_DATA_elements(enc, 0, &(val)->elements))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_ISSUED_AUTH_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_ISSUED_AUTH_DATA *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_SIGNATURE(dd0, 0, &(val)->checksum))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1Dec_KERB_KDC_ISSUED_AUTH_DATA_elements(dd, 0, &(val)->elements))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_ISSUED_AUTH_DATA(KERB_KDC_ISSUED_AUTH_DATA *val)
{
    if (val) {
	ASN1Free_KERB_SIGNATURE(&(val)->checksum);
	ASN1Free_KERB_KDC_ISSUED_AUTH_DATA_elements(&(val)->elements);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_SERV_REFERRAL(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_SERV_REFERRAL *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->referred_server_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    t = lstrlenA((val)->referred_server_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->referred_server_realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_SERV_REFERRAL(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_SERV_REFERRAL *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->referred_server_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->referred_server_realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_SERV_REFERRAL(KERB_PA_SERV_REFERRAL *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->referred_server_name);
	}
	ASN1ztcharstring_free((val)->referred_server_realm);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PAC_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PAC_REQUEST *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncBool(enc, 0x1, (val)->include_pac))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PAC_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PAC_REQUEST *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBool(dd0, 0x1, &(val)->include_pac))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_KERB_CHANGE_PASSWORD_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CHANGE_PASSWORD_DATA *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->new_password).length, ((val)->new_password).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->target_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	t = lstrlenA((val)->target_realm);
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->target_realm))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_CHANGE_PASSWORD_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CHANGE_PASSWORD_DATA *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->new_password))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->target_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->target_realm))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_CHANGE_PASSWORD_DATA(KERB_CHANGE_PASSWORD_DATA *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->new_password);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->target_name);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1ztcharstring_free((val)->target_realm);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ERROR_METHOD_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ERROR_METHOD_DATA *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->data_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->data_value).length, ((val)->data_value).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ERROR_METHOD_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ERROR_METHOD_DATA *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->data_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->data_value))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ERROR_METHOD_DATA(KERB_ERROR_METHOD_DATA *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1octetstring_free(&(val)->data_value);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_EXT_ERROR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_EXT_ERROR *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->status))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->klininfo))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->flags))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_EXT_ERROR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_EXT_ERROR *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->status))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->klininfo))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->flags))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_KERB_PA_FOR_USER(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_FOR_USER *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->userName))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    t = lstrlenA((val)->userRealm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->userRealm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_CHECKSUM(enc, 0, &(val)->cksum))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    t = lstrlenA((val)->authentication_package);
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->authentication_package))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	    return 0;
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->authorization_data).length, ((val)->authorization_data).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_FOR_USER(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_FOR_USER *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->userName))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->userRealm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_CHECKSUM(dd0, 0, &(val)->cksum))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->authentication_package))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->authorization_data))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_FOR_USER(KERB_PA_FOR_USER *val)
{
    if (val) {
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->userName);
	ASN1ztcharstring_free((val)->userRealm);
	ASN1Free_KERB_CHECKSUM(&(val)->cksum);
	ASN1ztcharstring_free((val)->authentication_package);
	if ((val)->o[0] & 0x80) {
	    ASN1octetstring_free(&(val)->authorization_data);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PAC_REQUEST_EX(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PAC_REQUEST_EX *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncBool(enc, 0x1, (val)->include_pac))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_KERB_PA_PAC_REQUEST_EX_pac_sections(enc, 0, &(val)->pac_sections))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PAC_REQUEST_EX(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PAC_REQUEST_EX *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBool(dd0, 0x1, &(val)->include_pac))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_KERB_PA_PAC_REQUEST_EX_pac_sections(dd, 0, &(val)->pac_sections))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PAC_REQUEST_EX(KERB_PA_PAC_REQUEST_EX *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_PA_PAC_REQUEST_EX_pac_sections(&(val)->pac_sections);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_ISSUED_AUTH_DATA_elements(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_ISSUED_AUTH_DATA_elements *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_KDC_ISSUED_AUTH_DATA_elements f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_PA_DATA(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_ISSUED_AUTH_DATA_elements(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_ISSUED_AUTH_DATA_elements *val)
{
    PKERB_KDC_ISSUED_AUTH_DATA_elements *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_KDC_ISSUED_AUTH_DATA_elements)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_PA_DATA(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_ISSUED_AUTH_DATA_elements(PKERB_KDC_ISSUED_AUTH_DATA_elements *val)
{
    PKERB_KDC_ISSUED_AUTH_DATA_elements f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_PA_DATA(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ2_trusted_certifiers(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_trusted_certifiers *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_PA_PK_AS_REQ2_trusted_certifiers f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ2_trusted_certifiers(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_trusted_certifiers *val)
{
    PKERB_PA_PK_AS_REQ2_trusted_certifiers *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_PA_PK_AS_REQ2_trusted_certifiers)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ2_trusted_certifiers(PKERB_PA_PK_AS_REQ2_trusted_certifiers *val)
{
    PKERB_PA_PK_AS_REQ2_trusted_certifiers f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ2_user_certs(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_user_certs *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_PA_PK_AS_REQ2_user_certs f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_CERTIFICATE(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ2_user_certs(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_user_certs *val)
{
    PKERB_PA_PK_AS_REQ2_user_certs *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_PA_PK_AS_REQ2_user_certs)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_CERTIFICATE(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ2_user_certs(PKERB_PA_PK_AS_REQ2_user_certs *val)
{
    PKERB_PA_PK_AS_REQ2_user_certs f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_CERTIFICATE(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REP2_kdc_cert(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REP2_kdc_cert *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_PA_PK_AS_REP2_kdc_cert f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_CERTIFICATE(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REP2_kdc_cert(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REP2_kdc_cert *val)
{
    PKERB_PA_PK_AS_REP2_kdc_cert *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_PA_PK_AS_REP2_kdc_cert)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_CERTIFICATE(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REP2_kdc_cert(PKERB_PA_PK_AS_REP2_kdc_cert *val)
{
    PKERB_PA_PK_AS_REP2_kdc_cert f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_CERTIFICATE(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x8000000c, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_PA_DATA(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *val)
{
    PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x8000000c, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_PA_DATA(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *val)
{
    PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_PA_DATA(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REPLY_preauth_data(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REPLY_preauth_data *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_KDC_REPLY_preauth_data f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_PA_DATA(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REPLY_preauth_data(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REPLY_preauth_data *val)
{
    PKERB_KDC_REPLY_preauth_data *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_KDC_REPLY_preauth_data)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_PA_DATA(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REPLY_preauth_data(PKERB_KDC_REPLY_preauth_data *val)
{
    PKERB_KDC_REPLY_preauth_data f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_PA_DATA(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_preauth_data(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REQUEST_preauth_data *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_KDC_REQUEST_preauth_data f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_PA_DATA(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_preauth_data(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REQUEST_preauth_data *val)
{
    PKERB_KDC_REQUEST_preauth_data *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_KDC_REQUEST_preauth_data)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_PA_DATA(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_preauth_data(PKERB_KDC_REQUEST_preauth_data *val)
{
    PKERB_KDC_REQUEST_preauth_data f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_PA_DATA(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_TICKET(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TICKET *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000001, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->ticket_version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    t = lstrlenA((val)->realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->server_name))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	    return 0;
	if (!ASN1Enc_PKERB_TICKET_EXTENSIONS(enc, 0, &(val)->ticket_extensions))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TICKET(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TICKET *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000001, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->ticket_version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->server_name))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_PKERB_TICKET_EXTENSIONS(dd0, 0, &(val)->ticket_extensions))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TICKET(KERB_TICKET *val)
{
    if (val) {
	ASN1ztcharstring_free((val)->realm);
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->server_name);
	ASN1Free_KERB_ENCRYPTED_DATA(&(val)->encrypted_part);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_PKERB_TICKET_EXTENSIONS(&(val)->ticket_extensions);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_TICKET(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_TICKET *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000003, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->flags).length, ((val)->flags).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->key))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    t = lstrlenA((val)->client_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->client_realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->client_name))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_TRANSITED_ENCODING(enc, 0, &(val)->transited))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->authtime))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->starttime))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000007, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->endtime))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000008, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->renew_until))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000009, &nLenOff0))
	    return 0;
	if (!ASN1Enc_PKERB_HOST_ADDRESSES(enc, 0, &(val)->client_addresses))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x8000000a, &nLenOff0))
	    return 0;
	if (!ASN1Enc_PKERB_AUTHORIZATION_DATA(enc, 0, &(val)->authorization_data))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_TICKET(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_TICKET *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000003, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->flags))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->key))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->client_realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->client_name))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_TRANSITED_ENCODING(dd0, 0, &(val)->transited))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->authtime))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000006) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->starttime))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000007, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->endtime))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000008) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000008, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->renew_until))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000009) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000009, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_PKERB_HOST_ADDRESSES(dd0, 0, &(val)->client_addresses))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000a) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x8000000a, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_PKERB_AUTHORIZATION_DATA(dd0, 0, &(val)->authorization_data))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_TICKET(KERB_ENCRYPTED_TICKET *val)
{
    if (val) {
	ASN1bitstring_free(&(val)->flags);
	ASN1Free_KERB_ENCRYPTION_KEY(&(val)->key);
	ASN1ztcharstring_free((val)->client_realm);
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->client_name);
	ASN1Free_KERB_TRANSITED_ENCODING(&(val)->transited);
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x40) {
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_PKERB_HOST_ADDRESSES(&(val)->client_addresses);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_PKERB_AUTHORIZATION_DATA(&(val)->authorization_data);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_AUTHENTICATOR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AUTHENTICATOR *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000002, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->authenticator_version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    t = lstrlenA((val)->client_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->client_realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->client_name))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_CHECKSUM(enc, 0, &(val)->checksum))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->client_usec))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->client_time))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->subkey))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000007, &nLenOff0))
	    return 0;
	//if (!ASN1BEREncSX(enc, 0x2, &(val)->sequence_number))
	if (!ASN1BEREncU32(enc, 0x2, (val)->sequence_number))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000008, &nLenOff0))
	    return 0;
	if (!ASN1Enc_PKERB_AUTHORIZATION_DATA(enc, 0, &(val)->authorization_data))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_AUTHENTICATOR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AUTHENTICATOR *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000002, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->authenticator_version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->client_realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->client_name))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_CHECKSUM(dd0, 0, &(val)->checksum))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->client_usec))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->client_time))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000006) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->subkey))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000007) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000007, &dd0, &di0))
	    return 0;
	//if (!ASN1BERDecSXVal(dd0, 0x2, &(val)->sequence_number))
	if (!ASN1BERDecU32Val(dd0, 0x2, (ASN1uint32_t *) &(val)->sequence_number))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000008) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000008, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_PKERB_AUTHORIZATION_DATA(dd0, 0, &(val)->authorization_data))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_AUTHENTICATOR(KERB_AUTHENTICATOR *val)
{
    if (val) {
	ASN1ztcharstring_free((val)->client_realm);
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->client_name);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_CHECKSUM(&(val)->checksum);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_KERB_ENCRYPTION_KEY(&(val)->subkey);
	}
	/*
	if ((val)->o[0] & 0x20) {
	    ASN1intx_free(&(val)->sequence_number);
	}
	*/
	if ((val)->o[0] & 0x10) {
	    ASN1Free_PKERB_AUTHORIZATION_DATA(&(val)->authorization_data);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_BODY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_REQUEST_BODY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->kdc_options).length, ((val)->kdc_options).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->client_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    t = lstrlenA((val)->realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->server_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->starttime))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->endtime))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->renew_until))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000007, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_KDC_REQUEST_BODY_encryption_type(enc, 0, &(val)->encryption_type))
	return 0;
    if ((val)->o[0] & 0x8) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000009, &nLenOff0))
	    return 0;
	if (!ASN1Enc_PKERB_HOST_ADDRESSES(enc, 0, &(val)->addresses))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1BEREncExplicitTag(enc, 0x8000000a, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->enc_authorization_data))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1Enc_KERB_KDC_REQUEST_BODY_additional_tickets(enc, 0, &(val)->additional_tickets))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_BODY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_REQUEST_BODY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->kdc_options))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->client_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->server_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->starttime))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->endtime))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000006) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->renew_until))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000007, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1Dec_KERB_KDC_REQUEST_BODY_encryption_type(dd, 0, &(val)->encryption_type))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000009) {
	(val)->o[0] |= 0x8;
	if (!ASN1BERDecExplicitTag(dd, 0x80000009, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_PKERB_HOST_ADDRESSES(dd0, 0, &(val)->addresses))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000a) {
	(val)->o[0] |= 0x4;
	if (!ASN1BERDecExplicitTag(dd, 0x8000000a, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->enc_authorization_data))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000b) {
	(val)->o[0] |= 0x2;
	if (!ASN1Dec_KERB_KDC_REQUEST_BODY_additional_tickets(dd, 0, &(val)->additional_tickets))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_BODY(KERB_KDC_REQUEST_BODY *val)
{
    if (val) {
	ASN1bitstring_free(&(val)->kdc_options);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->client_name);
	}
	ASN1ztcharstring_free((val)->realm);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->server_name);
	}
	if ((val)->o[0] & 0x20) {
	}
	if ((val)->o[0] & 0x10) {
	}
	ASN1Free_KERB_KDC_REQUEST_BODY_encryption_type(&(val)->encryption_type);
	if ((val)->o[0] & 0x8) {
	    ASN1Free_PKERB_HOST_ADDRESSES(&(val)->addresses);
	}
	if ((val)->o[0] & 0x4) {
	    ASN1Free_KERB_ENCRYPTED_DATA(&(val)->enc_authorization_data);
	}
	if ((val)->o[0] & 0x2) {
	    ASN1Free_KERB_KDC_REQUEST_BODY_additional_tickets(&(val)->additional_tickets);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_REPLY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_KERB_KDC_REPLY_preauth_data(enc, 0, &(val)->preauth_data))
	    return 0;
    }
    t = lstrlenA((val)->client_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->client_realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->client_name))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_TICKET(enc, 0, &(val)->ticket))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_REPLY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_KERB_KDC_REPLY_preauth_data(dd, 0, &(val)->preauth_data))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->client_realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->client_name))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_TICKET(dd0, 0, &(val)->ticket))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REPLY(KERB_KDC_REPLY *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_KDC_REPLY_preauth_data(&(val)->preauth_data);
	}
	ASN1ztcharstring_free((val)->client_realm);
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->client_name);
	ASN1Free_KERB_TICKET(&(val)->ticket);
	ASN1Free_KERB_ENCRYPTED_DATA(&(val)->encrypted_part);
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_KDC_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_KDC_REPLY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->session_key))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1Enc_PKERB_LAST_REQUEST(enc, 0, &(val)->last_request))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->key_expiration))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->flags).length, ((val)->flags).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->authtime))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->starttime))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000007, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->endtime))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000008, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->renew_until))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    t = lstrlenA((val)->server_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000009, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->server_realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x8000000a, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->server_name))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x8000000b, &nLenOff0))
	    return 0;
	if (!ASN1Enc_PKERB_HOST_ADDRESSES(enc, 0, &(val)->client_addresses))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Enc_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(enc, 0, &(val)->encrypted_pa_data))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_KDC_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_KDC_REPLY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->session_key))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1Dec_PKERB_LAST_REQUEST(dd0, 0, &(val)->last_request))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->key_expiration))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->flags))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->authtime))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000006) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->starttime))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000007, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->endtime))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000008) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000008, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->renew_until))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000009, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->server_realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x8000000a, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->server_name))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000b) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x8000000b, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_PKERB_HOST_ADDRESSES(dd0, 0, &(val)->client_addresses))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000c) {
	(val)->o[0] |= 0x8;
	if (!ASN1Dec_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(dd, 0, &(val)->encrypted_pa_data))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_KDC_REPLY(KERB_ENCRYPTED_KDC_REPLY *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTION_KEY(&(val)->session_key);
	ASN1Free_PKERB_LAST_REQUEST(&(val)->last_request);
	if ((val)->o[0] & 0x80) {
	}
	ASN1bitstring_free(&(val)->flags);
	if ((val)->o[0] & 0x40) {
	}
	if ((val)->o[0] & 0x20) {
	}
	ASN1ztcharstring_free((val)->server_realm);
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->server_name);
	if ((val)->o[0] & 0x10) {
	    ASN1Free_PKERB_HOST_ADDRESSES(&(val)->client_addresses);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(&(val)->encrypted_pa_data);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_AP_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AP_REQUEST *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000e, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->ap_options).length, ((val)->ap_options).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_TICKET(enc, 0, &(val)->ticket))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->authenticator))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_AP_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AP_REQUEST *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000e, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->ap_options))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_TICKET(dd0, 0, &(val)->ticket))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->authenticator))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_AP_REQUEST(KERB_AP_REQUEST *val)
{
    if (val) {
	ASN1bitstring_free(&(val)->ap_options);
	ASN1Free_KERB_TICKET(&(val)->ticket);
	ASN1Free_KERB_ENCRYPTED_DATA(&(val)->authenticator);
    }
}

static int ASN1CALL ASN1Enc_KERB_AP_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AP_REPLY *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000f, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_AP_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AP_REPLY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000f, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_AP_REPLY(KERB_AP_REPLY *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTED_DATA(&(val)->encrypted_part);
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_AP_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_AP_REPLY *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000001b, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->client_time))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->client_usec))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->subkey))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1BEREncU32(enc, 0x2, (val)->sequence_number))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_AP_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_AP_REPLY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000001b, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->client_time))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->client_usec))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->subkey))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecU32Val(dd0, 0x2, (ASN1uint32_t *) &(val)->sequence_number))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_AP_REPLY(KERB_ENCRYPTED_AP_REPLY *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_ENCRYPTION_KEY(&(val)->subkey);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_SAFE_MESSAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SAFE_MESSAGE *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000014, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_SAFE_BODY(enc, 0, &(val)->safe_body))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_CHECKSUM(enc, 0, &(val)->checksum))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SAFE_MESSAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SAFE_MESSAGE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000014, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_SAFE_BODY(dd0, 0, &(val)->safe_body))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_CHECKSUM(dd0, 0, &(val)->checksum))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SAFE_MESSAGE(KERB_SAFE_MESSAGE *val)
{
    if (val) {
	ASN1Free_KERB_SAFE_BODY(&(val)->safe_body);
	ASN1Free_KERB_CHECKSUM(&(val)->checksum);
    }
}

static int ASN1CALL ASN1Enc_KERB_PRIV_MESSAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PRIV_MESSAGE *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000015, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PRIV_MESSAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PRIV_MESSAGE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000015, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PRIV_MESSAGE(KERB_PRIV_MESSAGE *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTED_DATA(&(val)->encrypted_part);
    }
}

static int ASN1CALL ASN1Enc_KERB_CRED(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CRED *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000016, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_CRED_tickets(enc, 0, &(val)->tickets))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_CRED(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CRED *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000016, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1Dec_KERB_CRED_tickets(dd, 0, &(val)->tickets))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_CRED(KERB_CRED *val)
{
    if (val) {
	ASN1Free_KERB_CRED_tickets(&(val)->tickets);
	ASN1Free_KERB_ENCRYPTED_DATA(&(val)->encrypted_part);
    }
}

static int ASN1CALL ASN1Enc_KERB_CRED_INFO(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CRED_INFO *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->key))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	t = lstrlenA((val)->principal_realm);
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->principal_realm))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->principal_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1DEREncBitString(enc, 0x3, ((val)->flags).length, ((val)->flags).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->authtime))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->starttime))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->endtime))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000007, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->renew_until))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x1) {
	t = lstrlenA((val)->service_realm);
	if (!ASN1BEREncExplicitTag(enc, 0x80000008, &nLenOff0))
	    return 0;
	if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->service_realm))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[1] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000009, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->service_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[1] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x8000000a, &nLenOff0))
	    return 0;
	if (!ASN1Enc_PKERB_HOST_ADDRESSES(enc, 0, &(val)->client_addresses))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_CRED_INFO(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CRED_INFO *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 2);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->key))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->principal_realm))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->principal_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecBitString(dd0, 0x3, &(val)->flags))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->authtime))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000005) {
	(val)->o[0] |= 0x8;
	if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->starttime))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000006) {
	(val)->o[0] |= 0x4;
	if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->endtime))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000007) {
	(val)->o[0] |= 0x2;
	if (!ASN1BERDecExplicitTag(dd, 0x80000007, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->renew_until))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000008) {
	(val)->o[0] |= 0x1;
	if (!ASN1BERDecExplicitTag(dd, 0x80000008, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->service_realm))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000009) {
	(val)->o[1] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000009, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->service_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000a) {
	(val)->o[1] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x8000000a, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_PKERB_HOST_ADDRESSES(dd0, 0, &(val)->client_addresses))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_CRED_INFO(KERB_CRED_INFO *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTION_KEY(&(val)->key);
	if ((val)->o[0] & 0x80) {
	    ASN1ztcharstring_free((val)->principal_realm);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->principal_name);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1bitstring_free(&(val)->flags);
	}
	if ((val)->o[0] & 0x10) {
	}
	if ((val)->o[0] & 0x8) {
	}
	if ((val)->o[0] & 0x4) {
	}
	if ((val)->o[0] & 0x2) {
	}
	if ((val)->o[0] & 0x1) {
	    ASN1ztcharstring_free((val)->service_realm);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->service_name);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_PKERB_HOST_ADDRESSES(&(val)->client_addresses);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_TGT_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGT_REPLY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_TICKET(enc, 0, &(val)->ticket))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TGT_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGT_REPLY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_TICKET(dd0, 0, &(val)->ticket))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TGT_REPLY(KERB_TGT_REPLY *val)
{
    if (val) {
	ASN1Free_KERB_TICKET(&(val)->ticket);
    }
}

static int ASN1CALL ASN1Enc_KERB_SIGNED_REPLY_KEY_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNED_REPLY_KEY_PACKAGE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_REPLY_KEY_PACKAGE2(enc, 0, &(val)->reply_key_package))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_SIGNATURE(enc, 0, &(val)->reply_key_signature))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SIGNED_REPLY_KEY_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNED_REPLY_KEY_PACKAGE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_REPLY_KEY_PACKAGE2(dd0, 0, &(val)->reply_key_package))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_SIGNATURE(dd0, 0, &(val)->reply_key_signature))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SIGNED_REPLY_KEY_PACKAGE(KERB_SIGNED_REPLY_KEY_PACKAGE *val)
{
    if (val) {
	ASN1Free_KERB_REPLY_KEY_PACKAGE2(&(val)->reply_key_package);
	ASN1Free_KERB_SIGNATURE(&(val)->reply_key_signature);
    }
}

static int ASN1CALL ASN1Enc_KERB_SIGNED_KDC_PUBLIC_VALUE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNED_KDC_PUBLIC_VALUE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_SUBJECT_PUBLIC_KEY_INFO(enc, 0, &(val)->kdc_public_value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_SIGNATURE(enc, 0, &(val)->kdc_public_value_sig))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SIGNED_KDC_PUBLIC_VALUE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNED_KDC_PUBLIC_VALUE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_SUBJECT_PUBLIC_KEY_INFO(dd0, 0, &(val)->kdc_public_value))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_SIGNATURE(dd0, 0, &(val)->kdc_public_value_sig))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SIGNED_KDC_PUBLIC_VALUE(KERB_SIGNED_KDC_PUBLIC_VALUE *val)
{
    if (val) {
	ASN1Free_KERB_SUBJECT_PUBLIC_KEY_INFO(&(val)->kdc_public_value);
	ASN1Free_KERB_SIGNATURE(&(val)->kdc_public_value_sig);
    }
}

static int ASN1CALL ASN1Enc_KERB_TRUSTED_CAS(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TRUSTED_CAS *val)
{
    ASN1uint32_t nLenOff0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_KERBEROS_NAME(enc, 0, &(val)->u.principal_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
	break;
    case 2:
	if (!ASN1DEREncOctetString(enc, 0x80000001, ((val)->u.ca_name).length, ((val)->u.ca_name).value))
	    return 0;
	break;
    case 3:
	if (!ASN1DEREncOctetString(enc, 0x80000002, ((val)->u.issuer_and_serial).length, ((val)->u.issuer_and_serial).value))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TRUSTED_CAS(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TRUSTED_CAS *val)
{
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x80000000:
	(val)->choice = 1;
	if (!ASN1BERDecExplicitTag(dec, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_KERBEROS_NAME(dd0, 0, &(val)->u.principal_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	    return 0;
	break;
    case 0x80000001:
	(val)->choice = 2;
	if (!ASN1BERDecOctetString(dec, 0x80000001, &(val)->u.ca_name))
	    return 0;
	break;
    case 0x80000002:
	(val)->choice = 3;
	if (!ASN1BERDecOctetString(dec, 0x80000002, &(val)->u.issuer_and_serial))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TRUSTED_CAS(KERB_TRUSTED_CAS *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_KERB_KERBEROS_NAME(&(val)->u.principal_name);
	    break;
	case 2:
	    ASN1octetstring_free(&(val)->u.ca_name);
	    break;
	case 3:
	    ASN1octetstring_free(&(val)->u.issuer_and_serial);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_AUTH_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AUTH_PACKAGE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PK_AUTHENTICATOR(enc, 0, &(val)->pk_authenticator))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_SUBJECT_PUBLIC_KEY_INFO(enc, 0, &(val)->client_public_value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_AUTH_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AUTH_PACKAGE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PK_AUTHENTICATOR(dd0, 0, &(val)->pk_authenticator))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_SUBJECT_PUBLIC_KEY_INFO(dd0, 0, &(val)->client_public_value))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_AUTH_PACKAGE(KERB_AUTH_PACKAGE *val)
{
    if (val) {
	ASN1Free_KERB_PK_AUTHENTICATOR(&(val)->pk_authenticator);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_SUBJECT_PUBLIC_KEY_INFO(&(val)->client_public_value);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_COMPOUND_IDENTITY(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_COMPOUND_IDENTITY *val)
{
    PKERB_PA_COMPOUND_IDENTITY f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_TICKET(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_COMPOUND_IDENTITY(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_COMPOUND_IDENTITY *val)
{
    PKERB_PA_COMPOUND_IDENTITY *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_PA_COMPOUND_IDENTITY)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_TICKET(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_COMPOUND_IDENTITY(PKERB_PA_COMPOUND_IDENTITY *val)
{
    PKERB_PA_COMPOUND_IDENTITY f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_TICKET(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ_trusted_certifiers(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ_trusted_certifiers *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_PA_PK_AS_REQ_trusted_certifiers f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_TRUSTED_CAS(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ_trusted_certifiers(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ_trusted_certifiers *val)
{
    PKERB_PA_PK_AS_REQ_trusted_certifiers *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_PA_PK_AS_REQ_trusted_certifiers)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_TRUSTED_CAS(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ_trusted_certifiers(PKERB_PA_PK_AS_REQ_trusted_certifiers *val)
{
    PKERB_PA_PK_AS_REQ_trusted_certifiers f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_TRUSTED_CAS(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_CRED_ticket_info(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_ENCRYPTED_CRED_ticket_info *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_ENCRYPTED_CRED_ticket_info f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_CRED_INFO(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_CRED_ticket_info(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_ENCRYPTED_CRED_ticket_info *val)
{
    PKERB_ENCRYPTED_CRED_ticket_info *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_ENCRYPTED_CRED_ticket_info)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_CRED_INFO(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_CRED_ticket_info(PKERB_ENCRYPTED_CRED_ticket_info *val)
{
    PKERB_ENCRYPTED_CRED_ticket_info f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_CRED_INFO(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_CRED_tickets(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_CRED_tickets *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_CRED_tickets f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_TICKET(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_CRED_tickets(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_CRED_tickets *val)
{
    PKERB_CRED_tickets *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_CRED_tickets)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_TICKET(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_CRED_tickets(PKERB_CRED_tickets *val)
{
    PKERB_CRED_tickets f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_TICKET(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_BODY_additional_tickets(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_additional_tickets *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_KDC_REQUEST_BODY_additional_tickets f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x8000000b, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_TICKET(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_BODY_additional_tickets(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_additional_tickets *val)
{
    PKERB_KDC_REQUEST_BODY_additional_tickets *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x8000000b, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_KDC_REQUEST_BODY_additional_tickets)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_TICKET(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_BODY_additional_tickets(PKERB_KDC_REQUEST_BODY_additional_tickets *val)
{
    PKERB_KDC_REQUEST_BODY_additional_tickets f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_TICKET(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_REQUEST *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_KERB_KDC_REQUEST_preauth_data(enc, 0, &(val)->preauth_data))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_KDC_REQUEST_BODY(enc, 0, &(val)->request_body))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_REQUEST *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_KERB_KDC_REQUEST_preauth_data(dd, 0, &(val)->preauth_data))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_KDC_REQUEST_BODY(dd0, 0, &(val)->request_body))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REQUEST(KERB_KDC_REQUEST *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_KDC_REQUEST_preauth_data(&(val)->preauth_data);
	}
	ASN1Free_KERB_KDC_REQUEST_BODY(&(val)->request_body);
    }
}

static int ASN1CALL ASN1Enc_KERB_MARSHALLED_REQUEST_BODY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_MARSHALLED_REQUEST_BODY *val)
{
    if (!ASN1Enc_KERB_KDC_REQUEST_BODY(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_MARSHALLED_REQUEST_BODY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_MARSHALLED_REQUEST_BODY *val)
{
    if (!ASN1Dec_KERB_KDC_REQUEST_BODY(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_MARSHALLED_REQUEST_BODY(KERB_MARSHALLED_REQUEST_BODY *val)
{
    if (val) {
	ASN1Free_KERB_KDC_REQUEST_BODY(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_AS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AS_REPLY *val)
{
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000b, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_KDC_REPLY(enc, 0, val))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_AS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AS_REPLY *val)
{
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000b, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_KDC_REPLY(dd0, 0, val))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_AS_REPLY(KERB_AS_REPLY *val)
{
    if (val) {
	ASN1Free_KERB_KDC_REPLY(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_TGS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGS_REPLY *val)
{
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000d, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_KDC_REPLY(enc, 0, val))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TGS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGS_REPLY *val)
{
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000d, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_KDC_REPLY(dd0, 0, val))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TGS_REPLY(KERB_TGS_REPLY *val)
{
    if (val) {
	ASN1Free_KERB_KDC_REPLY(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_AS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_AS_REPLY *val)
{
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000019, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_KDC_REPLY(enc, 0, val))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_AS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_AS_REPLY *val)
{
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000019, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_KDC_REPLY(dd0, 0, val))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_AS_REPLY(KERB_ENCRYPTED_AS_REPLY *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTED_KDC_REPLY(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_TGS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_TGS_REPLY *val)
{
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000001a, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_KDC_REPLY(enc, 0, val))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_TGS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_TGS_REPLY *val)
{
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000001a, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_KDC_REPLY(dd0, 0, val))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_TGS_REPLY(KERB_ENCRYPTED_TGS_REPLY *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTED_KDC_REPLY(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REP2(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REP2 *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->key_package))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENVELOPED_KEY_PACKAGE(enc, 0, &(val)->temp_key_package))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_SIGNED_KDC_PUBLIC_VALUE(enc, 0, &(val)->signed_kdc_public_value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_KERB_PA_PK_AS_REP2_kdc_cert(enc, 0, &(val)->kdc_cert))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REP2(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REP2 *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->key_package))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENVELOPED_KEY_PACKAGE(dd0, 0, &(val)->temp_key_package))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_SIGNED_KDC_PUBLIC_VALUE(dd0, 0, &(val)->signed_kdc_public_value))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x20;
	if (!ASN1Dec_KERB_PA_PK_AS_REP2_kdc_cert(dd, 0, &(val)->kdc_cert))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REP2(KERB_PA_PK_AS_REP2 *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_ENCRYPTED_DATA(&(val)->key_package);
	}
	ASN1Free_KERB_ENVELOPED_KEY_PACKAGE(&(val)->temp_key_package);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_KERB_SIGNED_KDC_PUBLIC_VALUE(&(val)->signed_kdc_public_value);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_KERB_PA_PK_AS_REP2_kdc_cert(&(val)->kdc_cert);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_SIGNED_AUTH_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNED_AUTH_PACKAGE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_AUTH_PACKAGE(enc, 0, &(val)->auth_package))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_SIGNATURE(enc, 0, &(val)->auth_package_signature))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SIGNED_AUTH_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNED_AUTH_PACKAGE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_AUTH_PACKAGE(dd0, 0, &(val)->auth_package))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_SIGNATURE(dd0, 0, &(val)->auth_package_signature))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SIGNED_AUTH_PACKAGE(KERB_SIGNED_AUTH_PACKAGE *val)
{
    if (val) {
	ASN1Free_KERB_AUTH_PACKAGE(&(val)->auth_package);
	ASN1Free_KERB_SIGNATURE(&(val)->auth_package_signature);
    }
}

static int ASN1CALL ASN1Enc_KERB_AS_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AS_REQUEST *val)
{
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000a, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_KDC_REQUEST(enc, 0, val))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_AS_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AS_REQUEST *val)
{
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000a, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_KDC_REQUEST(dd0, 0, val))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_AS_REQUEST(KERB_AS_REQUEST *val)
{
    if (val) {
	ASN1Free_KERB_KDC_REQUEST(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_TGS_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGS_REQUEST *val)
{
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000c, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_KDC_REQUEST(enc, 0, val))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TGS_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGS_REQUEST *val)
{
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000c, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_KDC_REQUEST(dd0, 0, val))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TGS_REQUEST(KERB_TGS_REQUEST *val)
{
    if (val) {
	ASN1Free_KERB_KDC_REQUEST(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ2(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REQ2 *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_SIGNED_AUTH_PACKAGE(enc, 0, &(val)->signed_auth_pack))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_KERB_PA_PK_AS_REQ2_user_certs(enc, 0, &(val)->user_certs))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_KERB_PA_PK_AS_REQ2_trusted_certifiers(enc, 0, &(val)->trusted_certifiers))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->serial_number))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ2(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REQ2 *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_SIGNED_AUTH_PACKAGE(dd0, 0, &(val)->signed_auth_pack))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_KERB_PA_PK_AS_REQ2_user_certs(dd, 0, &(val)->user_certs))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_KERB_PA_PK_AS_REQ2_trusted_certifiers(dd, 0, &(val)->trusted_certifiers))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->serial_number))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ2(KERB_PA_PK_AS_REQ2 *val)
{
    if (val) {
	ASN1Free_KERB_SIGNED_AUTH_PACKAGE(&(val)->signed_auth_pack);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_PA_PK_AS_REQ2_user_certs(&(val)->user_certs);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_KERB_PA_PK_AS_REQ2_trusted_certifiers(&(val)->trusted_certifiers);
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\kerberos.cpp ===
//+-----------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation
//
//------------------------------------------------------------------------

#include "xonp.h"
#include "xboxp.h"
#include "xonver.h"
#include <md4.h>

NTSTATUS rc4HmacEncrypt(CScratchMemoryAllocator * pScratchMemoryAllocator, PUCHAR pbKey, ULONG KeySize,
                        ULONG MessageType, PUCHAR pbInput, ULONG cbInput, PUCHAR pbOutput, PULONG pcbOutput);
NTSTATUS rc4HmacDecrypt(PUCHAR pbKey, ULONG KeySize, ULONG MessageType, PUCHAR pbInput, ULONG cbInput,
                        PUCHAR pbOutput, PULONG pcbOutput);

#define RC4_CONFOUNDER_LEN  8

typedef struct _RC4_MDx_HEADER {
    UCHAR Checksum[MD5_LEN];
    UCHAR Confounder[RC4_CONFOUNDER_LEN];
} RC4_MDx_HEADER, *PRC4_MDx_HEADER;

const XBOX_LIBRARY_VERSION g_ClientVersion = { VER_PRODUCTVERSION };

//
// Sizes for scratch memory during various request
//

#define SCRATCH_MEMORY_SIZE_FOR_BuildAsRequest 2000
#define SCRATCH_MEMORY_SIZE_FOR_VerifyAsReply 2000
#define SCRATCH_MEMORY_SIZE_FOR_BuildTgsRequest 3000
#define SCRATCH_MEMORY_SIZE_FOR_VerifyTgsReply 3000
#define SCRATCH_MEMORY_SIZE_FOR_BuildApRequest 2000
#define SCRATCH_MEMORY_SIZE_FOR_VerifyApReply 2000

//
// Please be very careful when moving around code in this cpp file.
// Make sure you read the scratch memory allocator code and
// understand how memory is manipulated before change the code.
//

//DefineTag(ScratchMemoryVerbose,TAG_ENABLE);
DefineTag(ScratchMemoryVerbose,0);
DefineTag(ScratchMemoryAlloc,0);

DefineTag(KerbVerbose,TAG_ENABLE);
DefineTag(KerbWarn,TAG_ENABLE);
DefineTag(KerbASN1,0);

// ---------------------------------------------------------------------------------------

typedef LONG KERBERR, *PKERBERR;

typedef KERB_HOST_ADDRESS *PKERB_HOST_ADDRESS;
typedef KERB_PRINCIPAL_NAME *PKERB_PRINCIPAL_NAME;
typedef KERB_REALM *PKERB_REALM;
typedef KERB_TIME *PKERB_TIME;
typedef KERB_ENCRYPTED_DATA *PKERB_ENCRYPTED_DATA;
typedef KERB_TICKET *PKERB_TICKET;
typedef KERB_TRANSITED_ENCODING *PKERB_TRANSITED_ENCODING;
typedef KERB_ENCRYPTION_KEY *PKERB_ENCRYPTION_KEY;
typedef KERB_ENCRYPTED_TICKET *PKERB_ENCRYPTED_TICKET;
typedef KERB_CHECKSUM *PKERB_CHECKSUM;
typedef KERB_AUTHENTICATOR *PKERB_AUTHENTICATOR;
typedef KERB_PA_DATA *PKERB_PA_DATA;
typedef KERB_KDC_REQUEST_BODY *PKERB_KDC_REQUEST_BODY;
typedef KERB_KDC_REQUEST *PKERB_KDC_REQUEST;
typedef KERB_AS_REQUEST *PKERB_AS_REQUEST;
typedef KERB_TGS_REQUEST *PKERB_TGS_REQUEST;
typedef KERB_KDC_REPLY *PKERB_KDC_REPLY;
typedef KERB_AS_REPLY *PKERB_AS_REPLY;
typedef KERB_TGS_REPLY *PKERB_TGS_REPLY;
typedef KERB_ENCRYPTED_KDC_REPLY *PKERB_ENCRYPTED_KDC_REPLY;
typedef KERB_ENCRYPTED_AS_REPLY *PKERB_ENCRYPTED_AS_REPLY;
typedef KERB_ENCRYPTED_TGS_REPLY *PKERB_ENCRYPTED_TGS_REPLY;
typedef KERB_AP_OPTIONS *PKERB_AP_OPTIONS;
typedef KERB_AP_REQUEST *PKERB_AP_REQUEST;
typedef KERB_AP_REPLY *PKERB_AP_REPLY;
typedef KERB_ENCRYPTED_AP_REPLY *PKERB_ENCRYPTED_AP_REPLY;
typedef KERB_SAFE_BODY *PKERB_SAFE_BODY;
typedef KERB_SAFE_MESSAGE *PKERB_SAFE_MESSAGE;
typedef KERB_PRIV_MESSAGE *PKERB_PRIV_MESSAGE;
typedef KERB_ENCRYPTED_PRIV *PKERB_ENCRYPTED_PRIV;
typedef KERB_ERROR *PKERB_ERROR;
typedef KERB_ERROR_METHOD_DATA *PKERB_ERROR_METHOD_DATA;
typedef struct PKERB_AUTHORIZATION_DATA_s KERB_AUTHORIZATION_DATA;
typedef struct PKERB_TICKET_EXTENSIONS_s KERB_TICKET_EXTENSIONS;
typedef KERB_CRED *PKERB_CRED;
typedef KERB_ENCRYPTED_CRED *PKERB_ENCRYPTED_CRED;
typedef KERB_CRED_INFO *PKERB_CRED_INFO;
typedef struct PKERB_LAST_REQUEST_s KERB_LAST_REQUEST;
typedef struct PKERB_HOST_ADDRESSES_s KERB_HOST_ADDRESSES;
typedef struct PKERB_ETYPE_INFO_s KERB_ETYPE_INFO;
typedef KERB_ETYPE_INFO_ENTRY * PKERB_ETYPE_INFO_ENTRY;
typedef KERB_ENCRYPTED_TIMESTAMP *PKERB_ENCRYPTED_TIMESTAMP;
typedef struct PKERB_PREAUTH_DATA_LIST_s KERB_PREAUTH_DATA_LIST, *PKERB_PREAUTH_DATA_LIST;
typedef KERB_TICKET_FLAGS *PKERB_TICKET_FLAGS;
typedef KERB_PA_PAC_REQUEST *PKERB_PA_PAC_REQUEST;

#ifndef MIDL_PASS

typedef struct KERB_PRINCIPAL_NAME_name_string_s KERB_PRINCIPAL_NAME_ELEM, *PKERB_PRINCIPAL_NAME_ELEM;
typedef struct KERB_KDC_REQUEST_BODY_encryption_type_s KERB_CRYPT_LIST, *PKERB_CRYPT_LIST;
typedef struct KERB_KDC_REQUEST_BODY_additional_tickets_s KERB_TICKET_LIST, *PKERB_TICKET_LIST;
typedef struct KERB_KDC_REQUEST_preauth_data_s KERB_PA_DATA_LIST, *PKERB_PA_DATA_LIST;
typedef struct KERB_KDC_REPLY_preauth_data_s KERB_REPLY_PA_DATA_LIST, *PKERB_REPLY_PA_DATA_LIST;
typedef struct KERB_CRED_tickets_s KERB_CRED_TICKET_LIST, *PKERB_CRED_TICKET_LIST;
typedef struct KERB_ENCRYPTED_CRED_ticket_info_s KERB_CRED_INFO_LIST, *PKERB_CRED_INFO_LIST;
typedef struct KERB_PA_PK_AS_REQ2_user_certs_s KERB_CERTIFICATE_LIST, *PKERB_CERTIFICATE_LIST;
typedef struct KERB_PA_PK_AS_REQ2_trusted_certifiers_s KERB_CERTIFIER_LIST, *PKERB_CERTIFIER_LIST;
typedef struct KERB_KDC_ISSUED_AUTH_DATA_elements_s KERB_KDC_AUTH_DATA_LIST, *PKERB_KDC_AUTH_DATA_LIST;

#endif // MIDL_PASS

typedef KERB_KDC_ISSUED_AUTH_DATA *PKERB_KDC_ISSUED_AUTH_DATA;
typedef struct PKERB_IF_RELEVANT_AUTH_DATA_ KERB_IF_RELEVANT_AUTH_DATA;
typedef KERB_DH_PARAMTER *PKERB_DH_PARAMTER;
typedef KERB_PA_PK_AS_REQ *PKERB_PA_PK_AS_REQ;
typedef KERB_PA_PK_AS_REQ2 *PKERB_PA_PK_AS_REQ2;
typedef KERB_SIGNED_AUTH_PACKAGE *PKERB_SIGNED_AUTH_PACKAGE;
typedef KERB_AUTH_PACKAGE *PKERB_AUTH_PACKAGE;
typedef KERB_PK_AUTHENTICATOR *PKERB_PK_AUTHENTICATOR;
typedef KERB_SIGNED_REPLY_KEY_PACKAGE *PKERB_SIGNED_REPLY_KEY_PACKAGE;
typedef struct ASN1objectidentifier_s KERB_OBJECT_ID, *PKERB_OBJECT_ID;
typedef KERB_REPLY_KEY_PACKAGE *PKERB_REPLY_KEY_PACKAGE;
typedef KERB_PA_PK_AS_REP *PKERB_PA_PK_AS_REP;
typedef KERB_PA_PK_AS_REP2 *PKERB_PA_PK_AS_REP2;
typedef KERB_CERTIFICATE *PKERB_CERTIFICATE;
typedef KERB_SIGNED_KDC_PUBLIC_VALUE *PKERB_SIGNED_KDC_PUBLIC_VALUE;
typedef KERB_SUBJECT_PUBLIC_KEY_INFO *PKERB_SUBJECT_PUBLIC_KEY_INFO;
typedef KERB_ALGORITHM_IDENTIFIER *PKERB_ALGORITHM_IDENTIFIER;
typedef KERB_SIGNATURE *PKERB_SIGNATURE;
typedef KERB_TGT_REPLY *PKERB_TGT_REPLY;
typedef KERB_TGT_REQUEST *PKERB_TGT_REQUEST;
typedef KERB_PA_SERV_REFERRAL *PKERB_PA_SERV_REFERRAL;
typedef KERB_CHANGE_PASSWORD_DATA *PKERB_CHANGE_PASSWORD_DATA;

#define                     KERB_KDC_OPTIONS_reserved 0x80000000
#define                     KERB_KDC_OPTIONS_forwardable 0x40000000
#define                     KERB_KDC_OPTIONS_forwarded 0x20000000
#define                     KERB_KDC_OPTIONS_proxiable 0x10000000
#define                     KERB_KDC_OPTIONS_proxy 0x08000000
#define                     KERB_KDC_OPTIONS_postdated 0x02000000
#define                     KERB_KDC_OPTIONS_allow_postdate 0x04000000
#define                     KERB_KDC_OPTIONS_unused7 0x01000000
#define                     KERB_KDC_OPTIONS_renewable 0x00800000
#define                     KERB_KDC_OPTIONS_unused9 0x00400000
#define                     KERB_KDC_OPTIONS_name_canonicalize 0x00010000
#define                     KERB_KDC_OPTIONS_renewable_ok 0x00000010
#define                     KERB_KDC_OPTIONS_enc_tkt_in_skey 0x00000008
#define                     KERB_KDC_OPTIONS_renew 0x00000002
#define                     KERB_KDC_OPTIONS_validate 0x00000001

#define                     KERB_AP_OPTIONS_reserved 0x80000000
#define                     KERB_AP_OPTIONS_use_session_key 0x40000000
#define                     KERB_AP_OPTIONS_mutual_required 0x20000000
#define                     KERB_AP_OPTIONS_reserved1 0x00000001

//
// these #define's are done for the conversion from the old oss compiler to the
// new telis compiler.
//
#define KERB_AUTHENTICATOR_sequence_number                      sequence_number
#define KERB_ENCRYPTED_TICKET_client_addresses                  client_addresses
#define KERB_ENCRYPTED_TICKET_renew_until                       renew_until
#define KERB_CRED_INFO_renew_until                              renew_until
#define KERB_KDC_REQUEST_BODY_renew_until                       renew_until
#define KERB_KDC_REQUEST_BODY_server_name                       server_name
#define KERB_KDC_REQUEST_preauth_data                           preauth_data
#define KERB_AUTHENTICATOR_sequence_number                      sequence_number
#define KERB_ENCRYPTED_AP_REPLY_sequence_number                 sequence_number
#define KERB_AUTHENTICATOR_subkey                               subkey
#define KERB_ENCRYPTED_AP_REPLY_subkey                          subkey
#define KERB_TGT_REQUEST_server_name                            server_name
#define KERB_ERROR_client_name                                  client_name
#define KERB_ENCRYPTED_TIMESTAMP_usec                           usec
#define KERB_KDC_REQUEST_BODY_client_name                       client_name
#define KERB_KDC_REPLY_preauth_data                             preauth_data
#define KERB_ENCRYPTED_TIMESTAMP_usec                           usec
#define KERB_ENCRYPTED_KDC_REPLY_starttime                      starttime
#define KERB_CRED_INFO_starttime                                starttime
#define KERB_ENCRYPTED_KDC_REPLY_renew_until                    renew_until
#define KERB_ENCRYPTED_TICKET_authorization_data                authorization_data
#define KERB_ENCRYPTED_TICKET_starttime                         starttime
#define KERB_ENCRYPTED_PRIV_sequence_number                     sequence_number
#define KERB_KDC_REQUEST_BODY_starttime                         starttime
#define KERB_ENCRYPTED_KDC_REPLY_client_addresses               client_addresses

//
// Message types
//

#define KRB_AS_REQ      10      // Request for initial authentication
#define KRB_AS_REP      11      // Response to  KRB_AS_REQ request
#define KRB_TGS_REQ     12      // Request for authentication based on TGT
#define KRB_TGS_REP     13      // Response to KRB_TGS_REQ request
#define KRB_AP_REQ      14      // application request to server
#define KRB_AP_REP      15      // Response to KRB_AP_REQ_MUTUAL
#define KRB_TGT_REQ     16      // Request for TGT for user-to-user
#define KRB_TGT_REP     17      // Reply to TGT request
#define KRB_SAFE        20      // Safe (checksummed) application message
#define KRB_PRIV        21      // Private (encrypted) application message
#define KRB_CRED        22      // Private (encrypted) message to forward
                                // credentials
#define KRB_ERROR       30      // Error response

//
// Name types
//

#define KRB_NT_UNKNOWN   0                // Name type not known
#define KRB_NT_PRINCIPAL 1                // Just the name of the principal as in DCE, or for users
#define KRB_NT_PRINCIPAL_AND_ID -131      // Name of the principal and its SID.
#define KRB_NT_SRV_INST  2                // Service and other unique instance (krbtgt)
#define KRB_NT_SRV_INST_AND_ID -132       // SPN and SID
#define KRB_NT_SRV_HST   3                // Service with host name as instance (telnet, rcommands)
#define KRB_NT_SRV_XHST  4                // Service with host as remaining components
#define KRB_NT_UID       5                // Unique ID
#define KRB_NT_ENTERPRISE_PRINCIPAL 10    // UPN or SPN
#define KRB_NT_ENT_PRINCIPAL_AND_ID -130  // UPN and SID

//
// MS extensions, negative according to the RFC
//

#define KRB_NT_MS_PRINCIPAL         -128        // NT4 style name

#define KRB_NT_MS_PRINCIPAL_AND_ID  -129        // nt4 style name with sid

#define KERB_IS_MS_PRINCIPAL(_x_) (((_x_) <= KRB_NT_MS_PRINCIPAL) || ((_x_) >= KRB_NT_ENTERPRISE_PRINCIPAL))

//
// Pre-auth data types
//
#define KRB5_PADATA_NONE                0
#define KRB5_PADATA_AP_REQ              1
#define KRB5_PADATA_TGS_REQ             KRB5_PADATA_AP_REQ
#define KRB5_PADATA_ENC_TIMESTAMP       2
#define KRB5_PADATA_PW_SALT             3
#define KRB5_PADATA_ENC_UNIX_TIME       5  /* timestamp encrypted in key */
#define KRB5_PADATA_ENC_SANDIA_SECURID  6  /* SecurId passcode */
#define KRB5_PADATA_SESAME              7  /* Sesame project */
#define KRB5_PADATA_OSF_DCE             8  /* OSF DCE */
#define KRB5_CYBERSAFE_SECUREID         9  /* Cybersafe */
#define KRB5_PADATA_AFS3_SALT           10 /* Cygnus */
#define KRB5_PADATA_ETYPE_INFO          11 /* Etype info for preauth */
#define KRB5_PADATA_SAM_CHALLENGE       12 /* draft challenge system */
#define KRB5_PADATA_SAM_RESPONSE        13 /* draft challenge system response */
#define KRB5_PADATA_PK_AS_REQ           14 /* pkinit */
#define KRB5_PADATA_PK_AS_REP           15 /* pkinit */
#define KRB5_PADATA_PK_AS_SIGN          16 /* pkinit */
#define KRB5_PADATA_PK_KEY_REQ          17 /* pkinit */
#define KRB5_PADATA_PK_KEY_REP          18 /* pkinit */
#define KRB5_PADATA_REFERRAL_INFO       20 /* referral names for canonicalization */
#define KRB5_PADATA_PAC_REQUEST         128 /* allow client do request or ignore PAC */
#define KRB5_PADATA_S4U                 129 /* S4U */
#define KRB5_PADATA_COMPOUND_IDENTITY   130 /* authenticate multiple identities */
#define KRB5_PADATA_PAC_REQUEST_EX      131 /* allow client do request, ignore PAC or specify what sections */
#define KRB5_PADATA_CLIENT_VERSION      132 /* allow client do report version info */

//
// PAC type for PASSPORT PUID
//
#define PAC_CLIENT_IDENTITY             13
#define PAC_COMPOUND_IDENTITY           14
#define PAC_PASSPORT_PUIDS              20

//
// Authorization data types
//
#define KERB_AUTH_OSF_DCE               64
#define KERB_AUTH_SESAME                65

//
// NT authorization data type definitions
//

#define KERB_AUTH_DATA_PAC              128     // entry id for a PAC in authorization data

#define KERB_AUTH_DATA_IF_RELEVANT      1       // entry id for optional auth data
#define KERB_AUTH_DATA_KDC_ISSUED       4       // entry id for data generated & signed by KDC

//
// KDC service principal
//
#define KDC_PRINCIPAL_NAME              "krbtgt"
#define KERB_HOST_STRING                "host"
#define SECURITY_GATEWAY_STRING         "sg"

//
// SALT flags for encryption, from rfc1510 update 3des enctype
//

#define KERB_ENC_TIMESTAMP_SALT         1
#define KERB_TICKET_SALT                2
#define KERB_AS_REP_SALT                3
#define KERB_TGS_REQ_SESSKEY_SALT       4
#define KERB_TGS_REQ_SUBKEY_SALT        5
#define KERB_TGS_REQ_AP_REQ_AUTH_CKSUM_SALT     6
#define KERB_TGS_REQ_AP_REQ_AUTH_SALT   7
#define KERB_TGS_REP_SALT               8
#define KERB_TGS_REP_SUBKEY_SALT        9
#define KERB_AP_REQ_AUTH_CKSUM_SALT     10
#define KERB_AP_REQ_AUTH_SALT           11
#define KERB_AP_REP_SALT                12
#define KERB_PRIV_SALT                  13
#define KERB_CRED_SALT                  14
#define KERB_SAFE_SALT                  15
#define KERB_NON_KERB_SALT              16
#define KERB_NON_KERB_CKSUM_SALT        17
#define KERB_KERB_ERROR_SALT            18
#define KERB_KDC_ISSUED_CKSUM_SALT      19
#define KERB_MANDATORY_TKT_EXT_CKSUM_SALT       20
#define KERB_AUTH_DATA_TKT_EXT_CKSUM_SALT       21
#define KERB_PA_COMPOUND_IDENTITY_SALT  1024

//
// TODO remove KERB_PA_WITH_IDENTITY_SALT
//
#define KERB_PA_WITH_IDENTITY_SALT      1024

//
//Types for AP error data
//

#define KERB_AP_ERR_TYPE_NTSTATUS             1
#define KERB_AP_ERR_TYPE_SKEW_RECOVERY        2

// Revision of the Kerberos Protocol.  MS uses Version 5, Revision 6
#define KERBEROS_VERSION    5
#define KERBEROS_REVISION   6

// Encryption Types:
// These encryption types are supported by the default MS KERBSUPP DLL
// as crypto systems.  Values over 127 are local values, and may be changed
// without notice.

#define KERB_ETYPE_NULL             0
#define KERB_ETYPE_DES_CBC_CRC      1
#define KERB_ETYPE_DES_CBC_MD4      2
#define KERB_ETYPE_DES_CBC_MD5      3

#define KERB_ETYPE_OLD_RC4_MD4          128
#define KERB_ETYPE_OLD_RC4_PLAIN        129
#define KERB_ETYPE_OLD_RC4_LM           130
#define KERB_ETYPE_OLD_RC4_SHA          131
#define KERB_ETYPE_OLD_DES_PLAIN        132

#define KERB_ETYPE_RC4_MD4          -128
#define KERB_ETYPE_RC4_PLAIN2       -129
#define KERB_ETYPE_RC4_LM           -130
#define KERB_ETYPE_RC4_SHA          -131
#define KERB_ETYPE_DES_PLAIN        -132
#define KERB_ETYPE_RC4_HMAC_OLD     -133
#define KERB_ETYPE_RC4_PLAIN_OLD    -134
#define KERB_ETYPE_RC4_HMAC_OLD_EXP -135
#define KERB_ETYPE_RC4_PLAIN_OLD_EXP -136
#define KERB_ETYPE_RC4_PLAIN        -140
#define KERB_ETYPE_RC4_PLAIN_EXP    -141

//
// In use types
//
#define KERB_ETYPE_DES_CBC_MD5_NT                          20
#define KERB_ETYPE_RC4_HMAC_NT                             23
#define KERB_ETYPE_RC4_HMAC_NT_EXP                         24

// Checksum algorithms.
// These algorithms are keyed internally for our use.

#define KERB_CHECKSUM_NONE  0
#define KERB_CHECKSUM_CRC32         1
#define KERB_CHECKSUM_MD4           2
#define KERB_CHECKSUM_KRB_DES_MAC   4
#define KERB_CHECKSUM_MD5           7
#define KERB_CHECKSUM_MD5_DES       8


#define KERB_CHECKSUM_LM            -130
#define KERB_CHECKSUM_SHA1          -131
#define KERB_CHECKSUM_REAL_CRC32    -132
#define KERB_CHECKSUM_DES_MAC       -133
#define KERB_CHECKSUM_DES_MAC_MD5   -134
#define KERB_CHECKSUM_MD25          -135
#define KERB_CHECKSUM_RC4_MD5       -136
#define KERB_CHECKSUM_MD5_HMAC      -137                // used by netlogon
#define KERB_CHECKSUM_HMAC_MD5      -138                // used by Kerberos

#define AUTH_REQ_ALLOW_FORWARDABLE      0x00000001
#define AUTH_REQ_ALLOW_PROXIABLE        0x00000002
#define AUTH_REQ_ALLOW_POSTDATE         0x00000004
#define AUTH_REQ_ALLOW_RENEWABLE        0x00000008
#define AUTH_REQ_ALLOW_NOADDRESS        0x00000010
#define AUTH_REQ_ALLOW_ENC_TKT_IN_SKEY  0x00000020
#define AUTH_REQ_ALLOW_VALIDATE         0x00000040
#define AUTH_REQ_VALIDATE_CLIENT        0x00000080
#define AUTH_REQ_OK_AS_DELEGATE         0x00000100
#define AUTH_REQ_PREAUTH_REQUIRED       0x00000200


#define AUTH_REQ_PER_USER_FLAGS         (AUTH_REQ_ALLOW_FORWARDABLE \
                                         AUTH_REQ_ALLOW_PROXIABLE \
                                         AUTH_REQ_ALLOW_POSTDATE \
                                         AUTH_REQ_ALLOW_RENEWABLE \
                                         AUTH_REQ_ALLOW_VALIDATE )
//
// Ticket Flags:
//
#define KERB_TICKET_FLAGS_reserved          0x80000000
#define KERB_TICKET_FLAGS_forwardable       0x40000000
#define KERB_TICKET_FLAGS_forwarded         0x20000000
#define KERB_TICKET_FLAGS_proxiable         0x10000000
#define KERB_TICKET_FLAGS_proxy             0x08000000
#define KERB_TICKET_FLAGS_may_postdate      0x04000000
#define KERB_TICKET_FLAGS_postdated         0x02000000
#define KERB_TICKET_FLAGS_invalid           0x01000000
#define KERB_TICKET_FLAGS_renewable         0x00800000
#define KERB_TICKET_FLAGS_initial           0x00400000
#define KERB_TICKET_FLAGS_pre_authent       0x00200000
#define KERB_TICKET_FLAGS_hw_authent        0x00100000
#define KERB_TICKET_FLAGS_ok_as_delegate    0x00040000
#define KERB_TICKET_FLAGS_name_canonicalize 0x00010000
#define KERB_TICKET_FLAGS_reserved1         0x00000001

//
// Useful globals
//

extern TimeStamp g_KerbGlobalWillNeverTime;

//
// From kerberr.h
//

#define KERB_SUCCESS(_kerberr_) ((KERBERR)(_kerberr_) == KDC_ERR_NONE)

// These are the error codes as defined by the Kerberos V5 R5.2
// spec, section 8.3


#define KDC_ERR_NONE                  ((KERBERR) 0x0 ) // 0 No error
#define KDC_ERR_NAME_EXP              ((KERBERR) 0x1 ) // 1 Client's entry in database has expired
#define KDC_ERR_SERVICE_EXP           ((KERBERR) 0x2 ) // 2 Server's entry in database has expired
#define KDC_ERR_BAD_PVNO              ((KERBERR) 0x3 ) // 3 Requested protocol version number not supported
#define KDC_ERR_C_OLD_MAST_KVNO       ((KERBERR) 0x4 ) // 4 Client's key encrypted in old master key
#define KDC_ERR_S_OLD_MAST_KVNO       ((KERBERR) 0x5 ) // 5 Server's key encrypted in old master key
#define KDC_ERR_C_PRINCIPAL_UNKNOWN   ((KERBERR) 0x6 ) // 6 Client not found in Kerberos database
#define KDC_ERR_S_PRINCIPAL_UNKNOWN   ((KERBERR) 0x7 ) // 7 Server not found in Kerberos database
#define KDC_ERR_PRINCIPAL_NOT_UNIQUE  ((KERBERR) 0x8 ) // 8 Multiple principal entries in database
#define KDC_ERR_NULL_KEY              ((KERBERR) 0x9 ) // 9 The client or server has a null key
#define KDC_ERR_CANNOT_POSTDATE       ((KERBERR) 0xA ) // 10 Ticket not eligible for postdating
#define KDC_ERR_NEVER_VALID           ((KERBERR) 0xB ) // 11 Requested start time is later than end time
#define KDC_ERR_POLICY                ((KERBERR) 0xC ) // 12 KDC policy rejects request
#define KDC_ERR_BADOPTION             ((KERBERR) 0xD ) // 13 KDC cannot accommodate requested option
#define KDC_ERR_ETYPE_NOTSUPP         ((KERBERR) 0xE ) // 14 KDC has no support for encryption type
#define KDC_ERR_SUMTYPE_NOSUPP        ((KERBERR) 0xF ) // 15 KDC has no support for checksum type
#define KDC_ERR_PADATA_TYPE_NOSUPP    ((KERBERR) 0x10 ) // 16 KDC has no support for padata type
#define KDC_ERR_TRTYPE_NO_SUPP        ((KERBERR) 0x11 ) // 17 KDC has no support for transited type
#define KDC_ERR_CLIENT_REVOKED        ((KERBERR) 0x12 ) // 18 Clients credentials have been revoked
#define KDC_ERR_SERVICE_REVOKED       ((KERBERR) 0x13 ) // 19 Credentials for server have been revoked
#define KDC_ERR_TGT_REVOKED           ((KERBERR) 0x14 ) // 20 TGT has been revoked
#define KDC_ERR_CLIENT_NOTYET         ((KERBERR) 0x15 ) // 21 Client not yet valid - try again later
#define KDC_ERR_SERVICE_NOTYET        ((KERBERR) 0x16 ) // 22 Server not yet valid - try again later
#define KDC_ERR_KEY_EXPIRED           ((KERBERR) 0x17 ) // 23 Password has expired - change password to reset
#define KDC_ERR_PREAUTH_FAILED        ((KERBERR) 0x18 ) // 24 Pre-authentication information was invalid
#define KDC_ERR_PREAUTH_REQUIRED      ((KERBERR) 0x19 ) // 25 Additional pre-authenticationrequired [40]
#define KDC_ERR_SERVER_NOMATCH        ((KERBERR) 0x1A ) // 26 Requested server and ticket don't match
#define KDC_ERR_MUST_USE_USER2USER    ((KERBERR) 0x1B ) // 27 Server principal valid for user2user only
#define KDC_ERR_PATH_NOT_ACCPETED     ((KERBERR) 0x1C ) // 28 KDC Policy rejects transited path
#define KDC_ERR_SVC_UNAVAILABLE       ((KERBERR) 0x1D ) // 29 A service is not available
#define KRB_AP_ERR_BAD_INTEGRITY      ((KERBERR) 0x1F ) // 31 Integrity check on decrypted field failed
#define KRB_AP_ERR_TKT_EXPIRED        ((KERBERR) 0x20 ) // 32 Ticket expired
#define KRB_AP_ERR_TKT_NYV            ((KERBERR) 0x21 ) // 33 Ticket not yet valid
#define KRB_AP_ERR_REPEAT             ((KERBERR) 0x22 ) // 34 Request is a replay
#define KRB_AP_ERR_NOT_US             ((KERBERR) 0x23 ) // 35 The ticket isn't for us
#define KRB_AP_ERR_BADMATCH           ((KERBERR) 0x24 ) // 36 Ticket and authenticator don't match
#define KRB_AP_ERR_SKEW               ((KERBERR) 0x25 ) // 37 Clock skew too great
#define KRB_AP_ERR_BADADDR            ((KERBERR) 0x26 ) // 38 Incorrect net address
#define KRB_AP_ERR_BADVERSION         ((KERBERR) 0x27 ) // 39 Protocol version mismatch
#define KRB_AP_ERR_MSG_TYPE           ((KERBERR) 0x28 ) // 40 Invalid msg type
#define KRB_AP_ERR_MODIFIED           ((KERBERR) 0x29 ) // 41 Message stream modified
#define KRB_AP_ERR_BADORDER           ((KERBERR) 0x2A ) // 42 Message out of order
#define KRB_AP_ERR_ILL_CR_TKT         ((KREBERR) 0x2B ) // 43 Illegal cross realm ticket
#define KRB_AP_ERR_BADKEYVER          ((KERBERR) 0x2C ) // 44 Specified version of key is not available
#define KRB_AP_ERR_NOKEY              ((KERBERR) 0x2D ) // 45 Service key not available
#define KRB_AP_ERR_MUT_FAIL           ((KERBERR) 0x2E ) // 46 Mutual authentication failed
#define KRB_AP_ERR_BADDIRECTION       ((KERBERR) 0x2F ) // 47 Incorrect message direction
#define KRB_AP_ERR_METHOD             ((KERBERR) 0x30 ) // 48 Alternative authentication method required
#define KRB_AP_ERR_BADSEQ             ((KERBERR) 0x31 ) // 49 Incorrect sequence number in message
#define KRB_AP_ERR_INAPP_CKSUM        ((KERBERR) 0x32 ) // 50 Inappropriate type of checksum in message
#define KRB_AP_PATH_NOT_ACCEPTED      ((KERBERR) 0x33 ) // 51 Policy rejects transited path
#define KRB_ERR_RESPONSE_TOO_BIG      ((KERBERR) 0x34 ) // 52 Response too big for UDP, retry with TCP
#define KRB_ERR_GENERIC               ((KERBERR) 0x3C ) // 60 Generic error (description in e-text)
#define KRB_ERR_FIELD_TOOLONG         ((KERBERR) 0x3D ) // 61 Field is too long for this implementation
#define KDC_ERR_CLIENT_NOT_TRUSTED    ((KERBERR) 0x3E ) // 62 (pkinit)
#define KDC_ERR_KDC_NOT_TRUSTED       ((KERBERR) 0x3F ) // 63 (pkinit)
#define KDC_ERR_INVALID_SIG           ((KERBERR) 0x40 ) // 64 (pkinit)
#define KDC_ERR_KEY_TOO_WEAK          ((KERBERR) 0x41 ) // 65 (pkinit)
#define KDC_ERR_CERTIFICATE_MISMATCH  ((KERBERR) 0x42 ) // 66 (pkinit)
#define KRB_AP_ERR_NO_TGT             ((KERBERR) 0x43 ) // 67 (user-to-user)
#define KDC_ERR_WRONG_REALM           ((KERBERR) 0x44 ) // 68 (user-to-user)
#define KRB_AP_ERR_USER_TO_USER_REQUIRED ((KERBERR) 0x45 ) // 69 (user-to-user)
#define KDC_ERR_CANT_VERIFY_CERTIFICATE ((KERBERR) 0x46 ) // 70 (pkinit)
#define KDC_ERR_INVALID_CERTIFICATE     ((KERBERR) 0x47 ) // 71 (pkinit)
#define KDC_ERR_REVOKED_CERTIFICATE     ((KERBERR) 0x48 ) // 72 (pkinit)
#define KDC_ERR_REVOCATION_STATUS_UNKNOWN ((KERBERR) 0x49 ) // 73 (pkinit)
#define KDC_ERR_REVOCATION_STATUS_UNAVAILABLE ((KERBERR) 0x4a ) // 74 (pkinit)
#define KDC_ERR_CLIENT_NAME_MISMATCH    ((KERBERR) 0x4b ) // 75 (pkinit)
#define KDC_ERR_KDC_NAME_MISMATCH       ((KERBERR) 0x4c ) // 76 (pkinit)

#define KDC_ERR_MORE_DATA             ((KERBERR) 0x80000001 )

//
// Default flags for use in ticket requests
//
#define KERB_DEFAULT_TICKET_FLAGS ( KERB_KDC_OPTIONS_name_canonicalize )

//
//  Following macro is used to initialize UNICODE strings
//
#define CONSTANT_UNICODE_STRING(s)   { sizeof( s ) - sizeof( WCHAR ), sizeof( s ), s }
#define NULL_UNICODE_STRING {0 , 0, NULL }
#define EMPTY_UNICODE_STRING(s) { (s)->Buffer = NULL; (s)->Length = 0; (s)->MaximumLength = 0; }

#define KerbSetTime(_d_, _s_) (_d_)->QuadPart = (_s_)

#define KerbAddOffsetToTime(_d_, _offset_) (_d_)->QuadPart += (_offset_)

#define KerbGetOffsetBetweenTime(_d_, _s_) ((_s_)->QuadPart - (_d_)->QuadPart)

#define KerbGetTime(_x_) ((_x_).QuadPart)

#define KerbSetTimeInMinutes(_x_, _m_) (_x_)->QuadPart = (LONGLONG) 10000000 * 60 * (_m_)

#define KerbMapKerbNtStatusToNtStatus(x) (x)


//////////////////////////////////////////////////////////////////////////
//
// Structures
//
//////////////////////////////////////////////////////////////////////////

typedef struct _KERB_PREAUTH_DATA {
    ULONG Flags;
} KERB_PREAUTH_DATA, *PKERB_PREAUTH_DATA;

//
// KDC-Kerberos interaction
//

#define KERB_DEFAULT_AP_REQ_CSUM        KERB_CHECKSUM_MD5

#define KerbFreeData(a,b)

VOID
KerbCreateKeyFromBuffer(
    OUT PKERB_ENCRYPTION_KEY NewKey,
    IN PUCHAR Buffer,
    IN ULONG BufferSize,
    IN ULONG EncryptionType
    )
{
    NewKey->keytype = EncryptionType;
    NewKey->keyvalue.length = BufferSize;
    NewKey->keyvalue.value = (PUCHAR) Buffer;
}


KERBERR NTAPI
KerbCreateAuthenticator(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN PKERB_ENCRYPTION_KEY pkKey,
    IN ULONG EncryptionType,
    IN ULONG SequenceNumber,
    IN LPSTR ClientName,
    IN LPSTR ClientRealm,
    IN PTimeStamp ptsTime,
    IN OPTIONAL PKERB_CHECKSUM Checksum,
    IN BOOLEAN KdcRequest,
    OUT PKERB_ENCRYPTED_DATA Authenticator
    );

KERBERR NTAPI
KerbUnpackKdcReplyBody(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN PKERB_ENCRYPTED_DATA EncryptedReplyBody,
    IN PKERB_ENCRYPTION_KEY Key,
    IN ULONG Pdu,
    OUT PKERB_ENCRYPTED_KDC_REPLY * ReplyBody
    );

KERBERR NTAPI
KerbPackData(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN PVOID Data,
    IN ULONG PduValue,
    OUT PULONG DataSize,
    OUT PUCHAR * MarshalledData
    );

KERBERR NTAPI
KerbUnpackData(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN PUCHAR Data,
    IN ULONG DataSize,
    IN ULONG PduValue,
    OUT PVOID * DecodedData
    );

#define KerbUnpackAsReply( pScratchMemoryAllocator, ReplyMessage, ReplySize, Reply ) \
    KerbUnpackData( \
        (pScratchMemoryAllocator), \
        (ReplyMessage), \
        (ReplySize), \
        KERB_AS_REPLY_PDU, \
        (PVOID *) (Reply) \
        )

#define KerbFreeAsReply( Request)

#define KerbUnpackTgsReply( pScratchMemoryAllocator, ReplyMessage, ReplySize, Reply ) \
    KerbUnpackData( \
        (pScratchMemoryAllocator), \
        (ReplyMessage), \
        (ReplySize), \
        KERB_TGS_REPLY_PDU, \
        (PVOID *) (Reply) \
        )

#define KerbFreeTgsReply( Request) 

#define KerbFreeKdcReplyBody( Request)

#define KerbPackAsRequest( pScratchMemoryAllocator, RequestMessage, RequestSize, MarshalledRequest )\
    KerbPackData( \
        (pScratchMemoryAllocator), \
        (PVOID) (RequestMessage), \
        KERB_AS_REQUEST_PDU, \
        (RequestSize), \
        (MarshalledRequest) \
        )

#define KerbFreeAsRequest( Request)

#define KerbPackTgsRequest( pScratchMemoryAllocator, RequestMessage, RequestSize, MarshalledRequest )\
    KerbPackData( \
        (pScratchMemoryAllocator), \
        (PVOID) (RequestMessage), \
        KERB_TGS_REQUEST_PDU, \
        (RequestSize), \
        (MarshalledRequest) \
        )

#define KerbFreeTgsRequest( Request)

#define KerbPackEncryptedData( pScratchMemoryAllocator, EncryptedData, DataSize, MarshalledData ) \
    KerbPackData( \
        (pScratchMemoryAllocator), \
        (PVOID) (EncryptedData), \
        KERB_ENCRYPTED_DATA_PDU, \
        (DataSize), \
        (PUCHAR *) (MarshalledData) \
        )

#define KerbUnpackEncryptedData( pScratchMemoryAllocator, EncryptedData,DataSize,Data ) \
    KerbUnpackData( \
        (pScratchMemoryAllocator), \
        (EncryptedData), \
        (DataSize), \
        KERB_ENCRYPTED_DATA_PDU, \
        (PVOID *) (Data) \
        )

#define KerbFreeEncryptedData( EncryptedData)

#define KerbPackApRequest( pScratchMemoryAllocator, ApRequestMessage, ApRequestSize, MarshalledApRequest ) \
    KerbPackData( \
        (pScratchMemoryAllocator), \
        (PVOID) (ApRequestMessage), \
        KERB_AP_REQUEST_PDU, \
        (ApRequestSize), \
        (MarshalledApRequest) \
        )

#define KerbUnpackApReply( pScratchMemoryAllocator, ApReplyMessage,ApReplySize, ApReply) \
    KerbUnpackData( \
        (pScratchMemoryAllocator), \
        (ApReplyMessage), \
        (ApReplySize), \
        KERB_AP_REPLY_PDU, \
        (PVOID *) (ApReply) \
        )

#define KerbFreeApReply( Reply)

#define KerbUnpackApReplyBody( pScratchMemoryAllocator, ApReplyBodyMessage,ApReplyBodySize, ApReplyBody) \
    KerbUnpackData( \
        (pScratchMemoryAllocator), \
        (ApReplyBodyMessage), \
        (ApReplyBodySize), \
        KERB_ENCRYPTED_AP_REPLY_PDU, \
        (PVOID *) (ApReplyBody) \
        )

#define KerbFreeApReplyBody( ReplyBody)

#define KerbPackEncryptedCred( pScratchMemoryAllocator, EncryptedCred, CredSize, MarshalledCred ) \
    KerbPackData( \
        (pScratchMemoryAllocator), \
        (PVOID) (EncryptedCred), \
        KERB_ENCRYPTED_CRED_PDU, \
        (CredSize), \
        (MarshalledCred) \
        )

#define KerbUnpackEncryptedCred( pScratchMemoryAllocator, EncryptedCred,CredSize,Cred ) \
    KerbUnpackData( \
        (pScratchMemoryAllocator), \
        (EncryptedCred), \
        (CredSize), \
        KERB_ENCRYPTED_CRED_PDU, \
        (PVOID *) (Cred) \
        )

#define KerbFreeEncryptedCred( EncryptedCred)

#define KerbPackKerbCred( pScratchMemoryAllocator, KerbCred, KerbCredSize, MarshalledKerbCred ) \
    KerbPackData( \
        (pScratchMemoryAllocator), \
        (PVOID) (KerbCred), \
        KERB_CRED_PDU, \
        (KerbCredSize), \
        (MarshalledKerbCred) \
        )

#define KerbUnpackKerbCred( pScratchMemoryAllocator, MarshalledKerbCred,KerbCredSize,KerbCred ) \
    KerbUnpackData( \
        (pScratchMemoryAllocator), \
        (MarshalledKerbCred), \
        (KerbCredSize), \
        KERB_CRED_PDU, \
        (PVOID *) (KerbCred) \
        )

#define KerbFreeKerbCred( KerbCred) \
    KerbFreeData( \
        KERB_CRED_PDU, \
        (PVOID) (KerbCred) \
        )

#define KerbPackKerbError( pScratchMemoryAllocator, ErrorMessage, ErrorSize, MarshalledError ) \
    KerbPackData( \
        (pScratchMemoryAllocator), \
        (PVOID) (ErrorMessage), \
        KERB_ERROR_PDU, \
        (ErrorSize), \
        (MarshalledError) \
        )

#define KerbUnpackKerbError( pScratchMemoryAllocator, ErrorMessage, ErrorSize, Error ) \
    KerbUnpackData( \
        (pScratchMemoryAllocator), \
        (ErrorMessage), \
        (ErrorSize), \
        KERB_ERROR_PDU, \
        (PVOID *) (Error) \
        )

#define KerbFreeKerbError( Error )

#define KerbPackEncryptedTime( pScratchMemoryAllocator, EncryptedTimeMessage, EncryptedTimeSize, MarshalledEncryptedTime ) \
    KerbPackData( \
        (pScratchMemoryAllocator), \
        (PVOID) (EncryptedTimeMessage), \
        KERB_ENCRYPTED_TIMESTAMP_PDU, \
        (EncryptedTimeSize), \
        (MarshalledEncryptedTime) \
        )

#define KerbUnpackEncryptedTime( pScratchMemoryAllocator, EncryptedTimeMessage, EncryptedTimeSize, EncryptedTime ) \
    KerbUnpackData( \
        (pScratchMemoryAllocator), \
        (EncryptedTimeMessage), \
        (EncryptedTimeSize), \
        KERB_ENCRYPTED_TIMESTAMP_PDU, \
        (PVOID *) (EncryptedTime) \
        )

#define KerbFreeEncryptedTime( EncryptedTime )

KERBERR NTAPI
KerbEncryptDataEx(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    OUT PKERB_ENCRYPTED_DATA EncryptedData,
    IN ULONG DataSize,
    IN PUCHAR Data,
    IN ULONG Algorithm,
    IN ULONG UsageFlags,
    IN PKERB_ENCRYPTION_KEY Key
    );

KERBERR NTAPI
KerbDecryptDataEx(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN PKERB_ENCRYPTED_DATA EncryptedData,
    IN PKERB_ENCRYPTION_KEY pkKey,
    IN ULONG UsageFlags,
    OUT PULONG DataSize,
    OUT PUCHAR Data
    );

INLINE ULONG
KerbGetEncryptionOverhead()
{
    return sizeof(RC4_MDx_HEADER);
}

KERBERR
KerbConstructPrincipalName(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    OUT PKERB_PRINCIPAL_NAME PrincipalName,
    IN ULONG NameType,
    IN LPSTR pComp1,
    IN LPSTR pComp2 = NULL
    );

KERBERR
KerbMultiStringToPrincipalName(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN LPSTR pMultiString,
    OUT PKERB_PRINCIPAL_NAME PrincipalName
    );

KERBERR
KerbPrincipalNameToMultiString(
    IN PKERB_PRINCIPAL_NAME PrincipalName,
    IN DWORD dwMultiStringMaxLength,
    OUT LPSTR pMultiString
    );

VOID
KerbConvertLargeIntToGeneralizedTime(
    OUT PKERB_TIME ClientTime,
    OUT OPTIONAL LONG* ClientUsec,
    IN PTimeStamp TimeStamp
    );

VOID
KerbConvertGeneralizedTimeToLargeInt(
    OUT PTimeStamp TimeStamp,
    IN PKERB_TIME ClientTime,
    IN int ClientUsec
    );

PKERB_PA_DATA
KerbFindPreAuthDataEntry(
    IN ULONG EntryId,
    IN PKERB_PA_DATA_LIST AuthData
    );

KERBERR
KerbCreateApRequest(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN LPSTR ClientName,
    IN LPSTR ClientRealm,
    IN PKERB_ENCRYPTION_KEY SessionKey,
    IN ULONG Nonce,
    IN PTimeStamp pAuthenticatorTime,
    IN PKERB_TICKET ServiceTicket,
    IN ULONG ApOptions,
    IN OPTIONAL PKERB_CHECKSUM Checksum,
    IN BOOLEAN KdcRequest,
    OUT PULONG RequestSize,
    OUT PUCHAR * Request
    );

NTSTATUS
KerbMapKerbError(
    IN KERBERR KerbError
    );

ULONG
KerbConvertUlongToFlagUlong(
    IN ULONG Flag
    );

VOID
KerbGetCurrentTime(
    OUT PTimeStamp pCurrentTime
    );
    
VOID
KerbUpdateCurrentTime(
    IN TimeStamp NewCurrentTime
    );

BOOLEAN
md5Hmac(
    IN PBYTE pbKeyMaterial,
    IN ULONG cbKeyMaterial,
    IN PBYTE pbData,
    IN ULONG cbData,
    IN PBYTE pbData2,
    IN ULONG cbData2,
    OUT PBYTE HmacData
    );

INLINE KERBERR
KerbAllocateEncryptionBuffer(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN ULONG EncryptionType,
    IN ULONG BufferSize,
    OUT PULONG EncryptionBufferSize,
    OUT PBYTE * EncryptionBuffer
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;

    *EncryptionBufferSize = sizeof(RC4_MDx_HEADER) + BufferSize;

    *EncryptionBuffer = (PBYTE) pScratchMemoryAllocator->Alloc(*EncryptionBufferSize);
    if (*EncryptionBuffer == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
    }
    return(KerbErr);

}


//+-------------------------------------------------------------------------
// Start CPP code
//+-------------------------------------------------------------------------

KERB_CRYPT_LIST g_RC4HMAC_CryptList = { NULL , KERB_ETYPE_RC4_HMAC_NT };

NTSTATUS
KerbComputeRequestBodyChecksum(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN PKERB_KDC_REQUEST_BODY RequestBody,
    OUT PKERB_CHECKSUM Checksum
    )
{
    KERB_MESSAGE_BUFFER MarshalledRequestBody = {0, NULL};
    NTSTATUS Status = STATUS_SUCCESS;
    MD5_CTX MD5Context;

    RtlZeroMemory(
        Checksum,
        sizeof(KERB_CHECKSUM)
        );

    //
    // Allocate enough space for the checksum
    //
    Checksum->checksum.value = (PUCHAR) pScratchMemoryAllocator->Alloc(MD5_LEN);
    if (Checksum->checksum.value == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    Checksum->checksum.length = MD5_LEN;
    Checksum->checksum_type = KERB_CHECKSUM_MD5;

    {
        CReleaseAllScratchMemoryUponDestruction onlyPreserveThisMemory( pScratchMemoryAllocator );
    
        if (!KERB_SUCCESS(KerbPackData(
                            pScratchMemoryAllocator,
                            RequestBody,
                            KERB_MARSHALLED_REQUEST_BODY_PDU,
                            &MarshalledRequestBody.BufferSize,
                            &MarshalledRequestBody.Buffer
                            )))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        //
        // Now checksum the buffer
        //

        MD5Init(&MD5Context);
        MD5Update(&MD5Context, MarshalledRequestBody.Buffer, MarshalledRequestBody.BufferSize);
        MD5Final(&MD5Context);
        RtlCopyMemory(Checksum->checksum.value, MD5Context.digest, MD5_LEN);
    }
    
Cleanup:
    if (Status != STATUS_SUCCESS)
    {
        TraceSz1( KerbWarn, "KerbComputeRequestBodyChecksum failure status 0x%X", Status );
    }
    return(Status);
}

//+-------------------------------------------------------------------------

NTSTATUS
KerbAddTimestampPreAuth(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN PKERB_ENCRYPTION_KEY UserKey,
    IN PTimeStamp pAuthTime,
    OUT PKERB_PA_DATA_LIST * PreAuthData
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_PA_DATA_LIST ListElement = NULL;
    KERB_ENCRYPTED_TIMESTAMP Timestamp = {0};
    PBYTE EncryptedTime = NULL;
    ULONG EncryptedTimeSize = 0;
    KERB_ENCRYPTED_DATA EncryptedData;
    void* pTempBuffer;

    RtlZeroMemory( &EncryptedData, sizeof(KERB_ENCRYPTED_DATA) );

    //
    // Build the output element
    //

    ListElement = (PKERB_PA_DATA_LIST) pScratchMemoryAllocator->Alloc(sizeof(KERB_PA_DATA_LIST));
    if (ListElement == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    {
        CReleaseAllScratchMemoryUponDestruction onlyPreserveThisMemory( pScratchMemoryAllocator );    

        //
        // Now build the encrypted timestamp
        //
        KerbConvertLargeIntToGeneralizedTime(
            &Timestamp.timestamp,
            &Timestamp.KERB_ENCRYPTED_TIMESTAMP_usec,
            pAuthTime
            );

        Timestamp.bit_mask = KERB_ENCRYPTED_TIMESTAMP_usec_present;

        KerbErr = KerbPackEncryptedTime(
                    pScratchMemoryAllocator,
                    &Timestamp,
                    &EncryptedTimeSize,
                    &EncryptedTime
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        //
        // Now encrypt the time
        //

        KerbErr = KerbAllocateEncryptionBuffer(
                    pScratchMemoryAllocator,
                    UserKey->keytype,
                    EncryptedTimeSize,
                    &EncryptedData.cipher_text.length,
                    &EncryptedData.cipher_text.value
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            Status = KerbMapKerbError(KerbErr);
            goto Cleanup;
        }


        KerbErr = KerbEncryptDataEx(
                    pScratchMemoryAllocator,
                    &EncryptedData,
                    EncryptedTimeSize,
                    EncryptedTime,
                    UserKey->keytype,
                    KERB_ENC_TIMESTAMP_SALT,
                    UserKey
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        //
        // Now pack the encrypted data
        //

        KerbErr = KerbPackEncryptedData(
                    pScratchMemoryAllocator,
                    &EncryptedData,
                    (PULONG) &ListElement->value.preauth_data.length,
                    (PUCHAR *) &ListElement->value.preauth_data.value
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        //
        // Preserve the only piece of memory we care about
        //
        pTempBuffer = PreserveThisMemory( &onlyPreserveThisMemory, &ListElement->value.preauth_data.value, ListElement->value.preauth_data.length );
        if (pTempBuffer == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
    }
    
    ListElement->value.preauth_data_type = KRB5_PADATA_ENC_TIMESTAMP;
    ListElement->next = *PreAuthData;
    *PreAuthData = ListElement;

Cleanup:
    if (Status != STATUS_SUCCESS)
    {
        TraceSz1( KerbWarn, "KerbAddTimestampPreAuth failure status 0x%X", Status );
    }
    return(Status);
}

//+-------------------------------------------------------------------------

PKERB_PA_DATA
KerbFindPreAuthDataEntry(
    IN ULONG EntryId,
    IN PKERB_PA_DATA_LIST AuthData
    )
{
    PKERB_PA_DATA_LIST TempData = AuthData;

    while (TempData != NULL)
    {
        if (TempData->value.preauth_data_type == (int) EntryId)
        {
            break;
        }
        TempData = TempData->next;
    }
    return(TempData  != NULL ? &TempData->value : NULL);
}


//--------------------------------------------------------------------------

void KerbComputeKdcRequestNonceHmacKey(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN PKERB_ENCRYPTION_KEY pClientKey,
    IN DWORD nonce,
    OUT PBYTE pNonceHmacKey
    )
{
    MD5_CTX Md5Context;
    UCHAR Key[MD5_LEN];
    ULONG ulSalt = KERB_KDC_REQ_NONCE_CKSUM_SALT;
    
    Assert(MD5_LEN == XONLINE_KEY_LENGTH);
    Assert(MD5_LEN == pClientKey->keyvalue.length);

    md5Hmac(
        pClientKey->keyvalue.value,
        pClientKey->keyvalue.length,
        (PBYTE)"signaturekey",
        sizeof("signaturekey"),
        NULL,
        0,
        Key
        );
        
    MD5Init(&Md5Context);
    
    MD5Update(&Md5Context, (BYTE*)&ulSalt, sizeof(ulSalt));

    MD5Update(&Md5Context, (BYTE*)&nonce, sizeof(nonce));
    
    MD5Final(&Md5Context);

    md5Hmac(
        Key,
        MD5_LEN,
        Md5Context.digest,
        MD5_LEN,
        NULL,
        0,
        pNonceHmacKey
        );
}

//+-------------------------------------------------------------------------

KERBERR
KerbVerifyAccountCreationPreAuth(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN PKERB_PA_DATA PreAuthData,
    IN PKERB_ENCRYPTION_KEY ClientKey,
    IN OUT PXKERB_TGT_CONTEXT pTGTContext
    )
{
    KERBERR KerbErr;
    BYTE abNonceHmacKey[XONLINE_KEY_LENGTH];
    KERB_ENCRYPTION_KEY NonceHmacKey;
    PKERB_ENCRYPTED_DATA EncryptedData = NULL;
    DWORD dwDecryptedDataLen;
    DWORD i;
    
    CReleaseAllScratchMemoryUponDestruction onlyPreserveThisMemory( pScratchMemoryAllocator );

    //
    // Unpack the pre-auth data into an encrypted data first.
    //
    KerbErr = KerbUnpackEncryptedData(
                pScratchMemoryAllocator,
                PreAuthData->preauth_data.value,
                PreAuthData->preauth_data.length,
                &EncryptedData
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    if (EncryptedData->cipher_text.length != KerbGetEncryptionOverhead() + sizeof(XKERB_PA_XBOX_ACCOUNT_CREATION))
    {
        AssertSz2( FALSE, "KerbVerifyAccountCreationPreAuth: Preauth size is %d, should be %d",
            EncryptedData->cipher_text.length,
            KerbGetEncryptionOverhead() + sizeof(XKERB_PA_XBOX_ACCOUNT_CREATION)
            );
        KerbErr = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    //
    // Try all nonces
    //
    for (i=0; i<pTGTContext->ctNumNonces; ++i)
    {
        KerbComputeKdcRequestNonceHmacKey(
            pScratchMemoryAllocator,
            ClientKey,
            pTGTContext->Nonce[i],
            abNonceHmacKey
            );

        KerbCreateKeyFromBuffer(
            &NonceHmacKey,
            abNonceHmacKey,
            XONLINE_KEY_LENGTH,
            KERB_ETYPE_RC4_HMAC_NT
            );

        //
        // Now decrypt the encrypted data (in place)
        //
        KerbErr = KerbDecryptDataEx(
                    pScratchMemoryAllocator,
                    EncryptedData,
                    &NonceHmacKey,
                    KERB_PA_XBOX_ACCOUNT_CREATION_SALT,
                    (PULONG) &dwDecryptedDataLen,
                    (BYTE*)pTGTContext->pAccountCreationPreAuth
                    );
        if (KERB_SUCCESS(KerbErr))
        {
            break;
        }
    }
    
    if (i == pTGTContext->ctNumNonces)
    {
        KerbErr = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    Assert( dwDecryptedDataLen == sizeof(XKERB_PA_XBOX_ACCOUNT_CREATION) );
    
    KerbErr = KDC_ERR_NONE;

Cleanup:
    if (!KERB_SUCCESS(KerbErr))
    {
        TraceSz1( KerbWarn, "KerbVerifyAccountCreationPreAuth failure KerbErr 0x%X", KerbErr );
    }
    return(KerbErr);
}

//+-------------------------------------------------------------------------


KERBERR
KerbVerifyServiceAddressPreAuth(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN PKERB_PA_DATA PreAuthData,
    IN PKERB_ENCRYPTION_KEY TGTSessionKey,
    IN PXKERB_SERVICE_CONTEXT pXKerbServiceContext,
    OUT PXKERB_PA_XBOX_SERVICE_ADDRESS pPAServiceAddress
    )
{
    KERBERR KerbErr;
    BYTE abNonceHmacKey[XONLINE_KEY_LENGTH];
    KERB_ENCRYPTION_KEY NonceHmacKey;
    PKERB_ENCRYPTED_DATA EncryptedData = NULL;
    DWORD dwDecryptedDataLen;
    DWORD i;
    
    CReleaseAllScratchMemoryUponDestruction onlyPreserveThisMemory( pScratchMemoryAllocator );
    
    //
    // Unpack the pre-auth data into an encrypted data first.
    //
    KerbErr = KerbUnpackEncryptedData(
                pScratchMemoryAllocator,
                PreAuthData->preauth_data.value,
                PreAuthData->preauth_data.length,
                &EncryptedData
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    if (EncryptedData->cipher_text.length != KerbGetEncryptionOverhead() + sizeof(XKERB_PA_XBOX_SERVICE_ADDRESS))
    {
        AssertSz2( FALSE, "KerbVerifyServiceAddressPreAuth: Preauth size is %d, should be %d",
            EncryptedData->cipher_text.length,
            KerbGetEncryptionOverhead() + sizeof(XKERB_PA_XBOX_SERVICE_ADDRESS)
            );
        KerbErr = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    //
    // Try all nonces
    //
    for (i=0; i<pXKerbServiceContext->ctNumNonces; ++i)
    {
        KerbComputeKdcRequestNonceHmacKey(
            pScratchMemoryAllocator,
            TGTSessionKey,
            pXKerbServiceContext->Nonce[i],
            abNonceHmacKey
            );

        KerbCreateKeyFromBuffer(
            &NonceHmacKey,
            abNonceHmacKey,
            XONLINE_KEY_LENGTH,
            KERB_ETYPE_RC4_HMAC_NT
            );

        //
        // Now decrypt the encrypted data (in place)
        //
        KerbErr = KerbDecryptDataEx(
                    pScratchMemoryAllocator,
                    EncryptedData,
                    &NonceHmacKey,
                    KERB_PA_XBOX_SERVICE_ADDRESS_SALT,
                    (PULONG) &dwDecryptedDataLen,
                    (BYTE*)pPAServiceAddress
                    );
        if (KERB_SUCCESS(KerbErr))
        {
            break;
        }
    }
    
    if (i == pXKerbServiceContext->ctNumNonces)
    {
        KerbErr = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }
    
    Assert( dwDecryptedDataLen == sizeof(XKERB_PA_XBOX_SERVICE_ADDRESS) );
    
#ifdef XNET_FEATURE_TRACE
    {
        char buffer1[256],buf[32];
        DWORD k;
        buffer1[0] = '\0';
        for (k=0; k<pPAServiceAddress->dwNumServices; ++k)
        {
            sprintf(buf," %d(0x%X):%d", pPAServiceAddress->serviceResult[k].dwServiceID, pPAServiceAddress->serviceResult[k].hr, pPAServiceAddress->serviceResult[k].wServicePort);
            strcat(buffer1, buf);
        }
        TraceSz14( AuthVerbose, "KerbVerifyServiceAddressPreAuth HR:0x%X IP:%d.%d.%d.%d User HR:FLGS: 0x%X:%X 0x%X:%X 0x%X:%X 0x%X:%X Services:%s",
            pPAServiceAddress->hr,
            pPAServiceAddress->siteIPAddress.S_un.S_un_b.s_b1,
            pPAServiceAddress->siteIPAddress.S_un.S_un_b.s_b2,
            pPAServiceAddress->siteIPAddress.S_un.S_un_b.s_b3,
            pPAServiceAddress->siteIPAddress.S_un.S_un_b.s_b4,
            pPAServiceAddress->hrUser[0],
            pPAServiceAddress->dwUserFlags[0],
            pPAServiceAddress->hrUser[1],
            pPAServiceAddress->dwUserFlags[1],
            pPAServiceAddress->hrUser[2],
            pPAServiceAddress->dwUserFlags[2],
            pPAServiceAddress->hrUser[3],
            pPAServiceAddress->dwUserFlags[3],
            buffer1 );
    }
#endif

    KerbErr = KDC_ERR_NONE;

Cleanup:
    if (!KERB_SUCCESS(KerbErr))
    {
        TraceSz1( KerbWarn, "KerbVerifyServiceAddressPreAuth failure KerbErr 0x%X", KerbErr );
    }

    return(KerbErr);
}

//+-------------------------------------------------------------------------

NTSTATUS
KerbAddPacRequestPreAuth(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN BOOL fIncludePAC,
    IN OUT PKERB_PA_DATA_LIST * PreAuthData
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_PA_DATA_LIST ListElement = NULL;
    PKERB_PA_DATA_LIST LastElement = NULL;
    KERB_PA_PAC_REQUEST_EX PacRequestEx = {0};
    KERB_PA_PAC_REQUEST_EX_pac_sections_Element PacSections[2];
    
    ListElement = (PKERB_PA_DATA_LIST) pScratchMemoryAllocator->Alloc(sizeof(KERB_PA_DATA_LIST));
    if (ListElement == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RtlZeroMemory( &PacRequestEx, sizeof(KERB_PA_PAC_REQUEST_EX) );

    if (fIncludePAC)
    {
        PacRequestEx.include_pac = TRUE;
        PacRequestEx.bit_mask = pac_sections_present;
        PacRequestEx.pac_sections = &PacSections[0];

        PacSections[0].next = &PacSections[1];
        PacSections[0].value = PAC_CLIENT_IDENTITY;
        PacSections[1].next = NULL;
        PacSections[1].value = PAC_COMPOUND_IDENTITY;
    }
    else
    {
        PacRequestEx.include_pac = FALSE;
    }
    
    //
    // Marshall the type into the list element.
    //
    if (!KERB_SUCCESS(KerbPackData(
                        pScratchMemoryAllocator,
                        (PKERB_PA_PAC_REQUEST)(&PacRequestEx),
                        KERB_PA_PAC_REQUEST_EX_PDU,
                        (PULONG) &ListElement->value.preauth_data.length,
                        (PUCHAR *) &ListElement->value.preauth_data.value
                        )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    
    ListElement->value.preauth_data_type = KRB5_PADATA_PAC_REQUEST_EX;

    //
    // We want this to go at the end, so that it will override any other
    // pa-data that may enable a PAC.
    //

    LastElement = *PreAuthData;
    if (LastElement != NULL)
    {
        while (LastElement->next != NULL)
        {
            LastElement = LastElement->next;
        }
        LastElement->next = ListElement;
    }
    else
    {
        *PreAuthData = ListElement;
    }

    ListElement->next = NULL;
    ListElement = NULL;

Cleanup:
    if (Status != STATUS_SUCCESS)
    {
        TraceSz1( KerbWarn, "KerbAddPacRequestPreAuth failure status 0x%X", Status );
    }

    return(Status);
}


//+-------------------------------------------------------------------------
// Add the preauth to tell the server this is an Xbox
//+-------------------------------------------------------------------------

NTSTATUS
KerbAddClientVersionPreAuth(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN PKERB_ENCRYPTION_KEY ClientKey,
    IN DWORD nonce,
    IN OUT PKERB_PA_DATA_LIST * PreAuthData
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_PA_DATA_LIST ListElement;
    char acVersionString[256];
    DWORD dwVersionStringLen;
    BYTE abNonceHmacKey[XONLINE_KEY_LENGTH];
    KERB_ENCRYPTION_KEY NonceHmacKey;
    KERB_ENCRYPTED_DATA EncryptedData;
    void* pTempBuffer;

    ListElement = (PKERB_PA_DATA_LIST) pScratchMemoryAllocator->Alloc(sizeof(KERB_PA_DATA_LIST));
    if (ListElement == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    {
        CReleaseAllScratchMemoryUponDestruction onlyPreserveThisMemory( pScratchMemoryAllocator );
    
        KerbComputeKdcRequestNonceHmacKey(
            pScratchMemoryAllocator,
            ClientKey,
            nonce,
            abNonceHmacKey
            );

        KerbCreateKeyFromBuffer(
            &NonceHmacKey,
            abNonceHmacKey,
            XONLINE_KEY_LENGTH,
            KERB_ETYPE_RC4_HMAC_NT
            );

        //
        // Now build the client version string
        //
        CXo * pXo = pScratchMemoryAllocator->GetXoPtr();
        dwVersionStringLen = sprintf(acVersionString, "Xbox Version=%s Title=0x%X TitleVersion=%d",
                                     VER_PRODUCTVERSION_STR, pXo->GetTitleId(), pXo->GetTitleVersion()) + 1;

        //
        // Encrypt the client version string 
        //
        KerbErr = KerbAllocateEncryptionBuffer(
                    pScratchMemoryAllocator,
                    NonceHmacKey.keytype,
                    dwVersionStringLen,
                    &EncryptedData.cipher_text.length,
                    &EncryptedData.cipher_text.value
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            Status = KerbMapKerbError(KerbErr);
            goto Cleanup;
        }

        KerbErr = KerbEncryptDataEx(
                    pScratchMemoryAllocator,
                    &EncryptedData,
                    dwVersionStringLen,
                    (BYTE*)acVersionString,
                    NonceHmacKey.keytype,
                    KERB_PA_CLIENT_VER_SALT,
                    &NonceHmacKey
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        //
        // Now pack the encrypted data
        //
        KerbErr = KerbPackEncryptedData(
                    pScratchMemoryAllocator,
                    &EncryptedData,
                    (PULONG) &ListElement->value.preauth_data.length,
                    (PUCHAR *) &ListElement->value.preauth_data.value
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        //
        // Preserve the only piece of memory we care about
        //
        pTempBuffer = PreserveThisMemory( &onlyPreserveThisMemory, &ListElement->value.preauth_data.value, ListElement->value.preauth_data.length );
        if (pTempBuffer == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
    }

    //
    // Fill in remaining preauth fields, and put in list
    //
    ListElement->value.preauth_data_type = KRB5_PADATA_CLIENT_VERSION;
    ListElement->next = *PreAuthData;
    *PreAuthData = ListElement;

Cleanup:
    if (Status != STATUS_SUCCESS)
    {
        TraceSz1( KerbWarn, "KerbAddClientVersionPreAuth failure status 0x%X", Status );
    }
    return(Status);
}

//--------------------------------------------------------------------------

NTSTATUS
KerbAddCompoundIdentityPreAuth(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN PXKERB_TGT_CONTEXT pSingleTGTContext,
    IN OUT PKERB_PA_DATA_LIST * PreAuthData
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_PA_DATA_LIST ListElement;
    PKERB_TICKET pTicket;
    PKERB_PA_COMPOUND_IDENTITY TicketList;
    void* pTempBuffer;
    
    Assert(pScratchMemoryAllocator != NULL);
    Assert(pSingleTGTContext != NULL);
    Assert(PreAuthData != NULL);

    ListElement = (PKERB_PA_DATA_LIST) pScratchMemoryAllocator->Alloc(sizeof(KERB_PA_DATA_LIST));
    if (ListElement == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    {
        CReleaseAllScratchMemoryUponDestruction onlyPreserveThisMemory( pScratchMemoryAllocator );

        //
        // Reconstruct kerb ticket structure from packed data
        //
        pTicket = NULL;
        KerbErr = KerbUnpackData(
                    pScratchMemoryAllocator,
                    pSingleTGTContext->Ticket,
                    pSingleTGTContext->dwTicketLength,
                    KERB_TICKET_PDU,
                    (PVOID*)&pTicket
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        //
        // Allocate memory for the element in the ticket list.
        //
        TicketList = (PKERB_PA_COMPOUND_IDENTITY)pScratchMemoryAllocator->Alloc(sizeof(KERB_PA_COMPOUND_IDENTITY_Element));
        if (TicketList == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        //
        // Stick the ticket into the ticket list.
        //
        TicketList->value = *pTicket;
        TicketList->next = NULL;

        KerbErr = KerbPackData(pScratchMemoryAllocator,
                               &TicketList,                           
                               KERB_PA_COMPOUND_IDENTITY_PDU,
                               &ListElement->value.preauth_data.length,
                               &ListElement->value.preauth_data.value);
        if (!KERB_SUCCESS(KerbErr))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto    Cleanup;
        }

        //
        // Preserve the only piece of memory we care about
        //
        pTempBuffer = PreserveThisMemory( &onlyPreserveThisMemory, &ListElement->value.preauth_data.value, ListElement->value.preauth_data.length );
        if (pTempBuffer == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
    }
    
    ListElement->value.preauth_data_type = KRB5_PADATA_COMPOUND_IDENTITY;
    ListElement->next = *PreAuthData;
    *PreAuthData = ListElement;

Cleanup:
    if (Status != STATUS_SUCCESS)
    {
        TraceSz1( KerbWarn, "KerbAddCompoundIdentityPreAuth failure status 0x%X", Status );
    }
    return(Status);
}

//--------------------------------------------------------------------------

void KerbComputeCompoundIdentityKey(
    IN PKERB_ENCRYPTION_KEY pClientKey,
    IN PXKERB_TGT_CONTEXT pSingleTGTContext,
    OUT PBYTE pCompoundKey
    )
{
    MD5_CTX Md5Context;
    UCHAR Key[MD5_LEN];
    ULONG ulSalt = KERB_PA_COMPOUND_IDENTITY_SALT;
    
    Assert(MD5_LEN == XONLINE_KEY_LENGTH);
    Assert(MD5_LEN == pClientKey->keyvalue.length);
    Assert (pSingleTGTContext != NULL);

    md5Hmac(
        pClientKey->keyvalue.value,
        pClientKey->keyvalue.length,
        (PBYTE)"signaturekey",
        sizeof("signaturekey"),
        NULL,
        0,
        Key
        );
        
    MD5Init(&Md5Context);
    MD5Update(&Md5Context, (PUCHAR)&ulSalt, sizeof(ulSalt));

    MD5Update(&Md5Context, pSingleTGTContext->SessionKey, sizeof(pSingleTGTContext->SessionKey));

    MD5Final(&Md5Context);

    md5Hmac(
        Key,
        MD5_LEN,
        Md5Context.digest,
        MD5_LEN,
        NULL,
        0,
        pCompoundKey
        );
}


//--------------------------------------------------------------------------


NTSTATUS
KerbAddXboxServiceRequestPreAuth(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN PKERB_ENCRYPTION_KEY ClientKey,
    IN PXKERB_TGT_CONTEXT pCombinedTGTContext,
    IN DWORD nonce,
    IN XKERB_SERVICE_CONTEXT* pXKerbServiceContext,
    IN OUT PKERB_PA_DATA_LIST* PreAuthData
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_PA_DATA_LIST ListElement = NULL;
    PXKERB_PA_XBOX_SERVICE_REQUEST pXboxServicePreAuth;
    BYTE abNonceHmacKey[XONLINE_KEY_LENGTH];
    KERB_ENCRYPTION_KEY NonceHmacKey;
    KERB_ENCRYPTED_DATA EncryptedData;
    void* pTempBuffer;
    DWORD i;

    RtlZeroMemory( &EncryptedData, sizeof(KERB_ENCRYPTED_DATA) );

    pXboxServicePreAuth = (PXKERB_PA_XBOX_SERVICE_REQUEST)_alloca( sizeof(XKERB_PA_XBOX_SERVICE_REQUEST) );
    if (pXboxServicePreAuth == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    
    RtlZeroMemory( pXboxServicePreAuth, sizeof(XKERB_PA_XBOX_SERVICE_REQUEST) );
    
    ListElement = (PKERB_PA_DATA_LIST) pScratchMemoryAllocator->Alloc(sizeof(KERB_PA_DATA_LIST));
    if (ListElement == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    {
        CReleaseAllScratchMemoryUponDestruction onlyPreserveThisMemory( pScratchMemoryAllocator );
        CXo * pXo = pScratchMemoryAllocator->GetXoPtr();
        
        //
        // Fill in info to the struct
        //
        pXboxServicePreAuth->wServiceRequestVersion = XONLINE_SERVICE_REQUEST_VERSION;

#ifdef XONLINE_FEATURE_XBOX
        ULONG ulType, ulSize;
        Status = ExQueryNonVolatileSetting(XC_FACTORY_ETHERNET_ADDR, &ulType, pXboxServicePreAuth->abEthernetAddr, sizeof(pXboxServicePreAuth->abEthernetAddr), &ulSize);
        Assert(NT_SUCCESS(Status) && ulSize == sizeof(pXboxServicePreAuth->abEthernetAddr));
#endif

        pXboxServicePreAuth->clientVersion = g_ClientVersion;
        pXboxServicePreAuth->dwTitleID = pXo->GetTitleId();
        pXboxServicePreAuth->dwTitleVersion = pXo->GetTitleVersion();
        pXboxServicePreAuth->dwTitleRegion = pXo->GetTitleGameRegion();

        for (i=0; i<XONLINE_MAX_LOGON_USERS; ++i)
        {
            pXboxServicePreAuth->qwUserID[i] = pCombinedTGTContext->UserID[i];
        }

        for (i=0; i<pXKerbServiceContext->dwNumServices; ++i)
        {
            pXboxServicePreAuth->dwServiceID[i] = pXKerbServiceContext->dwServiceID[i];
        }
        pXboxServicePreAuth->dwNumServices = pXKerbServiceContext->dwNumServices;

#ifdef XNET_FEATURE_TRACE
        {
            char buffer1[256],buf[32];
            DWORD k;
            buffer1[0] = '\0';
            for (k=0; k<pXboxServicePreAuth->dwNumServices; ++k)
            {
                sprintf(buf," %d", pXboxServicePreAuth->dwServiceID[k]);
                strcat(buffer1, buf);
            }
            TraceSz8( AuthVerbose, "KerbAddXboxServiceRequestPreAuth packed Title:0x%X:%d:0x%X User: 0x%016I64X 0x%016I64X 0x%016I64X 0x%016I64X Service:%s",
                pXboxServicePreAuth->dwTitleID,
                pXboxServicePreAuth->dwTitleVersion,
                pXboxServicePreAuth->dwTitleRegion,
                pXboxServicePreAuth->qwUserID[0],
                pXboxServicePreAuth->qwUserID[1],
                pXboxServicePreAuth->qwUserID[2],
                pXboxServicePreAuth->qwUserID[3],
                buffer1 );
        }
#endif

        //
        // Compute the Nonce HMAC key
        //
        KerbComputeKdcRequestNonceHmacKey(
            pScratchMemoryAllocator,
            ClientKey,
            nonce,
            abNonceHmacKey
            );

        KerbCreateKeyFromBuffer(
            &NonceHmacKey,
            abNonceHmacKey,
            XONLINE_KEY_LENGTH,
            KERB_ETYPE_RC4_HMAC_NT
            );

        //
        // Encrypt the pre-auth
        //
        KerbErr = KerbAllocateEncryptionBuffer(
                    pScratchMemoryAllocator,
                    NonceHmacKey.keytype,
                    sizeof(XKERB_PA_XBOX_SERVICE_REQUEST),
                    &EncryptedData.cipher_text.length,
                    &EncryptedData.cipher_text.value
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            Status = KerbMapKerbError(KerbErr);
            goto Cleanup;
        }

        KerbErr = KerbEncryptDataEx(
                    pScratchMemoryAllocator,
                    &EncryptedData,
                    sizeof(XKERB_PA_XBOX_SERVICE_REQUEST),
                    (PUCHAR)pXboxServicePreAuth,
                    NonceHmacKey.keytype,
                    KERB_PA_XBOX_SERVICE_REQUEST_SALT,
                    &NonceHmacKey
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        //
        // Now pack the encrypted data
        //
        KerbErr = KerbPackEncryptedData(
                    pScratchMemoryAllocator,
                    &EncryptedData,
                    (PULONG) &ListElement->value.preauth_data.length,
                    (PUCHAR *) &ListElement->value.preauth_data.value
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        //
        // Preserve the only piece of memory we care about
        //
        pTempBuffer = PreserveThisMemory( &onlyPreserveThisMemory, &ListElement->value.preauth_data.value, ListElement->value.preauth_data.length );
        if (pTempBuffer == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
    }

    ListElement->value.preauth_data_type = KRB5_PADATA_XBOX_SERVICE_REQUEST;
    ListElement->next = *PreAuthData;
    *PreAuthData = ListElement;

Cleanup:
    if (Status != STATUS_SUCCESS)
    {
        TraceSz1( KerbWarn, "KerbAddXboxServiceRequestPreAuth failure status 0x%X", Status );
    }
    return(Status);
}

//--------------------------------------------------------------------------


NTSTATUS
CXo::XkerbBuildAsRequest(
    IN BOOL fMachineAccount,
    IN PXONLINEP_USER User,
    OUT PUCHAR pbRequestMessage,
    IN OUT PULONG pdwRequestMessageLength,
    IN OUT PXKERB_TGT_CONTEXT pTGTContext
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr = KDC_ERR_NONE;
    KERB_KDC_REQUEST TicketRequest;
    PKERB_KDC_REQUEST_BODY RequestBody = &TicketRequest.request_body;
    ULONG KdcFlagOptions;
    LPSTR pszTargetRealm;
    TimeStamp authTime;
    KERB_ENCRYPTION_KEY ClientKey;
    KERB_ENCRYPTION_KEY CompoundKey;
    KERB_MESSAGE_BUFFER RequestMessage;
    PUCHAR pbScratchMemory;
    char acPrincipleBuffer[XONLINE_KERBEROS_PRINCIPLE_NAME_SIZE];
    CScratchMemoryAllocator ScratchMemoryAllocator;
    DWORD i,j;
    
    Assert( pTGTContext->ctNumNonces < MAX_KERB_RETRIES + MAX_TIME_ADJUSTMENTS );

    //
    // Initialize scratch memory
    //
    pbScratchMemory = (PUCHAR)ScratchMemoryAllocator.ScratchMemoryInitialize( SCRATCH_MEMORY_SIZE_FOR_BuildAsRequest, pbRequestMessage, *pdwRequestMessageLength, this );
    if (pbScratchMemory == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RtlZeroMemory(&TicketRequest, sizeof(TicketRequest));
    
    KerbCreateKeyFromBuffer(
        &ClientKey,
        User->key,
        XONLINE_KEY_LENGTH,
        KERB_ETYPE_RC4_HMAC_NT
        );

    //
    // Stick all the PA data in the request
    //
    TicketRequest.KERB_KDC_REQUEST_preauth_data = NULL;

    if (pTGTContext->pInputTGTContext != NULL)
    {
        //
        // Compute compound identity keys
        //
        KerbComputeCompoundIdentityKey(
            &ClientKey,
            pTGTContext->pInputTGTContext,
            pTGTContext->CompoundKey
            );

        //
        // Do the PA-COMPOUND-IDENTITY first because it consumes the most memory
        //
        Status = KerbAddCompoundIdentityPreAuth(
                    &ScratchMemoryAllocator,
                    pTGTContext->pInputTGTContext,
                    &TicketRequest.KERB_KDC_REQUEST_preauth_data
                    );
        if (!NT_SUCCESS(Status))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
    }
    else
    {
        RtlCopyMemory( pTGTContext->CompoundKey, ClientKey.keyvalue.value, XONLINE_KEY_LENGTH );
    }
    
    KerbCreateKeyFromBuffer(
        &CompoundKey,
        pTGTContext->CompoundKey,
        XONLINE_KEY_LENGTH,
        KERB_ETYPE_RC4_HMAC_NT
        );

    //
    // Add the preauth to tell the server to include the PUID PAC.
    //

    Status = KerbAddPacRequestPreAuth(
                &ScratchMemoryAllocator,
                TRUE,
                &TicketRequest.KERB_KDC_REQUEST_preauth_data
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Get time for Timestamp Preauth
    //
    KerbGetCurrentTime(&authTime);
    // KerbAddOffsetToTime(&authTime, pTGTContext->qwTimeOffset);
    
    //
    // Add the standard timestamp pre-auth
    //
    Status = KerbAddTimestampPreAuth(
                &ScratchMemoryAllocator,
                &CompoundKey,
                &authTime,
                &TicketRequest.KERB_KDC_REQUEST_preauth_data
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Add special Xbox Pre-auth data
    //
    Status = KerbAddClientVersionPreAuth(
                &ScratchMemoryAllocator,
                &ClientKey,
                RequestBody->nonce,
                &TicketRequest.KERB_KDC_REQUEST_preauth_data
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    if (TicketRequest.KERB_KDC_REQUEST_preauth_data != NULL)
    {
        TicketRequest.bit_mask |= KERB_KDC_REQUEST_preauth_data_present;
    }

    //
    // Build the request
    //

    KdcFlagOptions = KerbConvertUlongToFlagUlong(KERB_DEFAULT_TICKET_FLAGS);
    RequestBody->kdc_options.value = (PUCHAR) &KdcFlagOptions;
    RequestBody->kdc_options.length = sizeof(ULONG) * 8;

    XNetRandom((BYTE *)&RequestBody->nonce, sizeof(RequestBody->nonce));

    KerbConvertLargeIntToGeneralizedTime(
        &RequestBody->endtime,
        NULL,
        &g_KerbGlobalWillNeverTime
        );

    //
    // Copy all the names into the request message
    //
    strcpy(acPrincipleBuffer,User->name);
    if (User->kingdom[0] != '\0')
    {
        strcat(acPrincipleBuffer,KINGDOM_SEPERATOR_STRING);
        strcat(acPrincipleBuffer,User->kingdom);
    }
    if (User->domain[0] != '\0')
    {
        strcat(acPrincipleBuffer,"@");
        strcat(acPrincipleBuffer,User->domain);
    }
    KerbErr = KerbConstructPrincipalName(
                &ScratchMemoryAllocator,
                &RequestBody->KERB_KDC_REQUEST_BODY_client_name,
                KRB_NT_ENTERPRISE_PRINCIPAL,
                acPrincipleBuffer
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RequestBody->bit_mask |= KERB_KDC_REQUEST_BODY_client_name_present;

    pszTargetRealm = fMachineAccount ? XBOX_REALM : (char*)User->realm;
    Assert( strlen(pszTargetRealm) <= XONLINE_MAX_REALM_NAME_LENGTH );
    strcpy(pTGTContext->TargetRealm, pszTargetRealm);

    //
    // Fill in the strings in the ticket request
    //
    KerbErr = KerbConstructPrincipalName(
                &ScratchMemoryAllocator,
                &RequestBody->KERB_KDC_REQUEST_BODY_server_name,
                KRB_NT_SRV_INST,
                KDC_PRINCIPAL_NAME,
                pszTargetRealm
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    RequestBody->bit_mask |= KERB_KDC_REQUEST_BODY_server_name_present;

    RequestBody->realm = (char*)User->realm;
    
    TicketRequest.version = KERBEROS_VERSION;
    TicketRequest.message_type = KRB_AS_REQ;

    //
    // Build crypt list
    //

    RequestBody->encryption_type = &g_RC4HMAC_CryptList;

    //
    // Pack the request
    //
    RequestMessage.BufferSize = *pdwRequestMessageLength;
    RequestMessage.Buffer = pbRequestMessage;
    KerbErr = KerbPackAsRequest(
                &ScratchMemoryAllocator,
                &TicketRequest,
                &RequestMessage.BufferSize,
                &RequestMessage.Buffer
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    *pdwRequestMessageLength = RequestMessage.BufferSize;

    j = 0;
    if (pTGTContext->pInputTGTContext != NULL)
    {
        for (i=0; i<XONLINE_MAX_LOGON_USERS; ++i)
        {
            if (pTGTContext->pInputTGTContext->UserID[i] != 0)
            {
                pTGTContext->UserID[j++] = pTGTContext->pInputTGTContext->UserID[i];
            }
        }
    }
    if (!fMachineAccount)
    {
        pTGTContext->UserID[j++] = User->xuid.qwUserID;
    }
    Assert( j <= XONLINE_MAX_LOGON_USERS );
    pTGTContext->Nonce[pTGTContext->ctNumNonces++] = RequestBody->nonce;
    RtlCopyMemory( pTGTContext->ClientKey, User->key, XONLINE_KEY_LENGTH );
    Status = KDC_ERR_NONE;
    
    //
    // Verbose trace info
    //
    TraceSz7( KerbVerbose,"XkerbBuildAsRequest try %d generated %d byte request for User:%s%c%s@%s Realm:%s",
        pTGTContext->ctNumNonces,
        RequestMessage.BufferSize, User->name, KINGDOM_SEPERATOR_CHAR, User->kingdom, User->domain, User->realm
        );

Cleanup:
    return(Status);
}

//--------------------------------------------------------------------------

NTSTATUS
CXo::XkerbVerifyAsReply(
    IN PUCHAR pbReplyMessage,
    IN ULONG dwReplyMessageLength,
    IN OUT PXKERB_TGT_CONTEXT pTGTContext
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_KDC_REPLY KdcReply = NULL;
    PKERB_ENCRYPTED_KDC_REPLY ReplyBody = NULL;
    KERB_ENCRYPTION_KEY CompoundKey;
    PKERB_ERROR ErrorMessage = NULL;
    PUCHAR pEncodedTicket;
    PKERB_PA_DATA pPreAuthData;
    PUCHAR pbScratchMemory;
    CScratchMemoryAllocator ScratchMemoryAllocator;
    DWORD i;
    
    //
    // Initialize scratch memory
    //
    pbScratchMemory = (PUCHAR)ScratchMemoryAllocator.ScratchMemoryInitialize( SCRATCH_MEMORY_SIZE_FOR_VerifyAsReply, NULL, 0, this );
    if (pbScratchMemory == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    KerbErr = KerbUnpackAsReply(
                &ScratchMemoryAllocator,
                pbReplyMessage,
                dwReplyMessageLength,
                &KdcReply
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        //
        // Try to unpack it as  kerb_error
        //
        KerbErr =  KerbUnpackKerbError(
                        &ScratchMemoryAllocator,
                        pbReplyMessage,
                        dwReplyMessageLength,
                        &ErrorMessage
                        );
        if (KERB_SUCCESS(KerbErr))
        {
            KerbErr = (KERBERR) ErrorMessage->error_code;
            TraceSz1( KerbWarn,"XkerbVerifyAsReply: Got KerbError 0x%X", KerbErr );

            Status = KerbMapKerbError(KerbErr);

            //
            // Check for time skew. If so, calculate the skew and retry
            //
            if (KerbErr == KRB_AP_ERR_SKEW)
            {
                TimeStamp KdcTime;
                //TimeStamp XboxTime;

                KerbConvertGeneralizedTimeToLargeInt(
                    &KdcTime,
                    &ErrorMessage->server_time,
                    ErrorMessage->server_usec
                    );

                //KerbGetCurrentTime(&XboxTime);
                //pTGTContext->qwTimeOffset = KerbGetOffsetBetweenTime( &XboxTime, &KdcTime );
                KerbUpdateCurrentTime( KdcTime );
                
                Status = STATUS_TIME_DIFFERENCE_AT_DC;
                goto Cleanup;
            }
            else
            {
                Status = KerbMapKerbError(KerbErr);
                goto Cleanup;
            }
        }
        else
        {
            Status = STATUS_INTERNAL_ERROR;
        }

        goto Cleanup;
    }

    KerbCreateKeyFromBuffer(
        &CompoundKey,
        pTGTContext->CompoundKey,
        XONLINE_KEY_LENGTH,
        KERB_ETYPE_RC4_HMAC_NT
        );

    //
    // Get the XKERB_PA_XBOX_ACCOUNT_CREATION pre-auth, if present
    //
    if ((KdcReply->bit_mask & KERB_KDC_REPLY_preauth_data_present) != 0)
    {
        CReleaseAllScratchMemoryUponDestruction onlyPreserveThisMemory( &ScratchMemoryAllocator );
    
        pPreAuthData = KerbFindPreAuthDataEntry(
                        KRB5_PADATA_XBOX_ACCOUNT_CREATION,
                        (PKERB_PA_DATA_LIST)KdcReply->preauth_data
                        );
        if (pPreAuthData != NULL)
        {
            //
            // Allocate pre-auth using SysAlloc
            // Do not use KerbAllocate here! You will end up with scratch memory!
            //
            pTGTContext->pAccountCreationPreAuth = (PXKERB_PA_XBOX_ACCOUNT_CREATION)SysAlloc(sizeof(XKERB_PA_XBOX_ACCOUNT_CREATION), PTAG_XKERB_PA_XBOX_ACCOUNT_CREATION);
            if (pTGTContext->pAccountCreationPreAuth == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            //
            // Check the pre-auth reply
            //
            KerbErr = KerbVerifyAccountCreationPreAuth(
                &ScratchMemoryAllocator,
                pPreAuthData,
                &CompoundKey,
                pTGTContext
                );
            if (!KERB_SUCCESS(KerbErr))
            {
                Status = KerbErr;
                goto Cleanup;
            }
        }
    }
    
    {
        CReleaseAllScratchMemoryUponDestruction onlyPreserveThisMemory( &ScratchMemoryAllocator );

        //
        // Pack ticket into marshalled form for caching
        //
        pTGTContext->dwTicketLength = 0;
        pEncodedTicket = NULL;
        KerbErr = KerbPackData(
                    &ScratchMemoryAllocator,
                    &KdcReply->ticket,
                    KERB_TICKET_PDU,
                    &pTGTContext->dwTicketLength,
                    &pEncodedTicket
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        if (pTGTContext->dwTicketLength > XONLINE_MAX_TICKET_LENGTH)
        {
            TraceSz1( KerbWarn, "XkerbVerifyAsReply: got a ticket too big: %d", pTGTContext->dwTicketLength );
            Status = STATUS_LOGON_FAILURE;
            goto Cleanup;
        }

        RtlCopyMemory(
            pTGTContext->Ticket,
            pEncodedTicket,
            pTGTContext->dwTicketLength
            );
    }
    
    //
    // Now unpack the reply body:
    //
    KerbErr = KerbUnpackKdcReplyBody(
                &ScratchMemoryAllocator,
                &KdcReply->encrypted_part,
                &CompoundKey,
                KERB_ENCRYPTED_AS_REPLY_PDU,
                &ReplyBody
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    //
    // Verify the nonce is correct:
    //
    for (i=0; i<pTGTContext->ctNumNonces; ++i)
    {
        if (pTGTContext->Nonce[i] == (DWORD)ReplyBody->nonce)
        {
            break;
        }
    }
    if (i == pTGTContext->ctNumNonces)
    {
        TraceSz3( KerbWarn, "XkerbVerifyAsReply: All %d Nonces don't match: 0x%X vs 0x%X", i, pTGTContext->Nonce[0], ReplyBody->nonce);
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    //
    // Cache the session key
    //
    if (ReplyBody->session_key.keytype != KERB_ETYPE_RC4_HMAC_NT ||
        ReplyBody->session_key.keyvalue.length != XONLINE_KEY_LENGTH)
    {
        TraceSz( KerbWarn, "XkerbVerifyAsReply: got a session key of the wrong type or length" );
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    RtlCopyMemory( pTGTContext->SessionKey, ReplyBody->session_key.keyvalue.value, XONLINE_KEY_LENGTH );

    //
    // Copy the principal name (might be different because of name canonicalization)
    //
    KerbErr = KerbPrincipalNameToMultiString(
        &KdcReply->client_name,
        sizeof(pTGTContext->ClientName),
        pTGTContext->ClientName
        );
    if (!KERB_SUCCESS(KerbErr))
    {
        TraceSz( KerbWarn, "XkerbVerifyAsReply: returned client name is too long" );
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }        

    if ( strlen(KdcReply->client_realm) <= XONLINE_MAX_REALM_NAME_LENGTH )
    {
        strcpy(pTGTContext->ClientRealm, KdcReply->client_realm);    
    }
    else
    {
        TraceSz( KerbWarn, "XkerbVerifyAsReply: returned client realm is too long" );
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }        

    //
    // Cache expiration time
    //
    KerbConvertGeneralizedTimeToLargeInt(
        &pTGTContext->ExpirationTime,
        &ReplyBody->endtime,
        0
        );
    
    KerbConvertGeneralizedTimeToLargeInt(
        &pTGTContext->StartTime,
        &ReplyBody->starttime,
        0
        );
    
    //
    // Verbose trace info
    //
    TraceSz2( KerbVerbose,"XkerbVerifyAsReply: extracted %d byte ticket from %d byte reply",
        pTGTContext->dwTicketLength, dwReplyMessageLength
        );

Cleanup:
    return(Status);
}

//--------------------------------------------------------------------------


NTSTATUS
CXo::XkerbBuildTgsRequest(
    IN PXKERB_TGT_CONTEXT pCombinedTGTContext,
    OUT PUCHAR pbRequestMessage,
    IN OUT PULONG pdwRequestMessageLength,
    IN OUT PXKERB_SERVICE_CONTEXT pXKerbServiceContext
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr;
    KERB_PA_DATA_LIST ApRequest;
    KERB_CHECKSUM RequestChecksum;
    ULONG KdcFlagOptions;
    KERB_KDC_REQUEST TicketRequest;
    PKERB_KDC_REQUEST_BODY RequestBody = &TicketRequest.request_body;
    KERB_MESSAGE_BUFFER RequestMessage;
    KERB_ENCRYPTION_KEY SessionKey;
    PKERB_TICKET pTGT = NULL;
    CHAR buffer[16];
    void* pTempBuffer;
    DWORD i;
    PUCHAR pbScratchMemory;
    CScratchMemoryAllocator ScratchMemoryAllocator;

    Assert(pCombinedTGTContext != NULL);
    Assert(pXKerbServiceContext != NULL);
#ifndef TESTKERB
    Assert(pXKerbServiceContext->dwNumServices != 0);
#endif
    Assert(pXKerbServiceContext->ctNumNonces < MAX_KERB_RETRIES + MAX_TIME_ADJUSTMENTS);

    //
    // Initialize scratch memory
    //
    pbScratchMemory = (PUCHAR)ScratchMemoryAllocator.ScratchMemoryInitialize( SCRATCH_MEMORY_SIZE_FOR_BuildTgsRequest, pbRequestMessage, *pdwRequestMessageLength, this );
    if (pbScratchMemory == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Initialize structures
    //
    RtlZeroMemory(
        &ApRequest,
        sizeof(KERB_PA_DATA_LIST)
        );

    RtlZeroMemory(
        &RequestChecksum,
        sizeof(KERB_CHECKSUM)
        );

    RtlZeroMemory(
        &TicketRequest,
        sizeof(KERB_KDC_REQUEST)
        );

    RtlCopyMemory( pXKerbServiceContext->ServiceRealm, pCombinedTGTContext->TargetRealm, sizeof(pXKerbServiceContext->ServiceRealm) );
    Assert( pXKerbServiceContext->UserID[0] == pCombinedTGTContext->UserID[0] );
    Assert( pXKerbServiceContext->UserID[1] == pCombinedTGTContext->UserID[1] );
    Assert( pXKerbServiceContext->UserID[2] == pCombinedTGTContext->UserID[2] );
    Assert( pXKerbServiceContext->UserID[3] == pCombinedTGTContext->UserID[3] );

    //
    // Fill in the ticket request with the defaults.
    //
    KerbConvertLargeIntToGeneralizedTime(
        &RequestBody->endtime,
        NULL,
        &g_KerbGlobalWillNeverTime // BUGBUG: use HasNeverTime instead
        );

    KerbConvertLargeIntToGeneralizedTime(
        &RequestBody->KERB_KDC_REQUEST_BODY_renew_until,
        NULL,
        &g_KerbGlobalWillNeverTime // BUGBUG: use HasNeverTime instead
        );

    XNetRandom((BYTE *)&RequestBody->nonce, sizeof(RequestBody->nonce));
    
    //
    // Build crypt list
    //

    RequestBody->encryption_type = &g_RC4HMAC_CryptList;

    //
    // Fill in the strings in the ticket request
    //
    sprintf( buffer, "S%d", pXKerbServiceContext->dwServiceID[0] );
    
    KerbErr = KerbConstructPrincipalName(
                &ScratchMemoryAllocator,
                &RequestBody->KERB_KDC_REQUEST_BODY_server_name,
                KRB_NT_SRV_INST,
                SECURITY_GATEWAY_STRING,
                buffer
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    RequestBody->bit_mask |= KERB_KDC_REQUEST_BODY_server_name_present;

    KdcFlagOptions = KerbConvertUlongToFlagUlong(KERB_DEFAULT_TICKET_FLAGS);
    RequestBody->kdc_options.length = sizeof(ULONG) * 8;
    RequestBody->kdc_options.value = (PUCHAR) &KdcFlagOptions;

    //
    // Marshall the request and compute a checksum of it
    //
    RequestBody->realm = pXKerbServiceContext->ServiceRealm;
    
    //
    // Construct encryption key struct for session key
    //
    KerbCreateKeyFromBuffer(
        &SessionKey,
        pCombinedTGTContext->SessionKey,
        XONLINE_KEY_LENGTH,
        KERB_ETYPE_RC4_HMAC_NT
        );

    {
        CReleaseAllScratchMemoryUponDestruction onlyPreserveThisMemory( &ScratchMemoryAllocator );
    
        //
        // Now compute a checksum of that data
        //

        Status = KerbComputeRequestBodyChecksum(
                    &ScratchMemoryAllocator,
                    RequestBody,
                    &RequestChecksum
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
        
        KerbErr = KerbUnpackData(
                    &ScratchMemoryAllocator,
                    pCombinedTGTContext->Ticket,
                    pCombinedTGTContext->dwTicketLength,
                    KERB_TICKET_PDU,
                    (PVOID*)&pTGT
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        //
        // Create the AP request to the KDC for the ticket to the service
        //
        KerbGetCurrentTime(&pXKerbServiceContext->AuthenticatorTime[pXKerbServiceContext->ctNumNonces]);

        KerbErr = KerbCreateApRequest(
                    &ScratchMemoryAllocator,
                    pCombinedTGTContext->ClientName,
                    pCombinedTGTContext->ClientRealm,
                    &SessionKey,
                    RequestBody->nonce,
                    &pXKerbServiceContext->AuthenticatorTime[pXKerbServiceContext->ctNumNonces],
                    pTGT,
                    0,                              // no AP options
                    &RequestChecksum,
                    TRUE,                           // kdc request
                    (PULONG) &ApRequest.value.preauth_data.length,
                    &ApRequest.value.preauth_data.value
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        //
        // Preserve the only piece of memory we care about
        //
        pTempBuffer = PreserveThisMemory( &onlyPreserveThisMemory, &ApRequest.value.preauth_data.value, ApRequest.value.preauth_data.length );
        if (pTempBuffer == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
    }
    
    ApRequest.next = NULL;
    ApRequest.value.preauth_data_type = KRB5_PADATA_TGS_REQ;
    TicketRequest.KERB_KDC_REQUEST_preauth_data = &ApRequest;
    TicketRequest.bit_mask |= KERB_KDC_REQUEST_preauth_data_present;

    //
    // Add the preauth to tell the server to include the PUID PAC.
    //
    Status = KerbAddPacRequestPreAuth(
                &ScratchMemoryAllocator,
                FALSE,
                &TicketRequest.KERB_KDC_REQUEST_preauth_data
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Add Xbox pre-auth info
    //
    Status = KerbAddXboxServiceRequestPreAuth(
                &ScratchMemoryAllocator,
                &SessionKey,
                pCombinedTGTContext,
                RequestBody->nonce,
                pXKerbServiceContext,
                &TicketRequest.KERB_KDC_REQUEST_preauth_data
                );
    if (!NT_SUCCESS(Status))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    
    //
    // Add version and message type info
    //

    TicketRequest.version = KERBEROS_VERSION;
    TicketRequest.message_type = KRB_TGS_REQ;

    //
    // Pack the request
    //
    RequestMessage.BufferSize = *pdwRequestMessageLength;
    RequestMessage.Buffer = pbRequestMessage;
    KerbErr = KerbPackTgsRequest(
                &ScratchMemoryAllocator,
                &TicketRequest,
                &RequestMessage.BufferSize,
                &RequestMessage.Buffer
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    *pdwRequestMessageLength = RequestMessage.BufferSize;

    pXKerbServiceContext->Nonce[pXKerbServiceContext->ctNumNonces++] = RequestBody->nonce;
    Status = KDC_ERR_NONE;

    //
    // Verbose trace info
    //
    TraceSz3( KerbVerbose,"XkerbBuildTgsRequest try %d generated %d byte request with %d byte Combined TGT",
        pXKerbServiceContext->ctNumNonces,
        RequestMessage.BufferSize,
        pCombinedTGTContext->dwTicketLength,
        );

Cleanup:
    return(Status);
}

//--------------------------------------------------------------------------

NTSTATUS
CXo::XkerbVerifyTgsReply(
    IN PXONLINEP_USER pUsers,
    IN PXKERB_TGT_CONTEXT pCombinedTGTContext,
    IN PUCHAR pbReplyMessage,
    IN ULONG dwReplyMessageLength,
    IN OUT PXKERB_SERVICE_CONTEXT pXKerbServiceContext
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr;
    PKERB_KDC_REPLY KdcReply = NULL;
    PKERB_ENCRYPTED_KDC_REPLY ReplyBody = NULL;
    KERB_ENCRYPTION_KEY SessionKey;
    PKERB_PA_DATA pPreAuthData;
    PXKERB_PA_XBOX_SERVICE_ADDRESS pPAServiceAddress = NULL;
    PUCHAR pEncodedTicket;
    DWORD i,j;
    PUCHAR pbScratchMemory;
    CScratchMemoryAllocator ScratchMemoryAllocator;

    Assert(pCombinedTGTContext != NULL);
    Assert(pXKerbServiceContext != NULL);

    //
    // Initialize scratch memory
    //
    pbScratchMemory = (PUCHAR)ScratchMemoryAllocator.ScratchMemoryInitialize( SCRATCH_MEMORY_SIZE_FOR_VerifyTgsReply, NULL, 0, this );
    if (pbScratchMemory == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Unpack the reply
    //
    KerbErr = KerbUnpackTgsReply(
                &ScratchMemoryAllocator,
                pbReplyMessage,
                dwReplyMessageLength,
                &KdcReply
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        PKERB_ERROR ErrorMessage = NULL;

        //
        // Try to unpack it as  kerb_error
        //

        KerbErr =  KerbUnpackKerbError(
                        &ScratchMemoryAllocator,
                        pbReplyMessage,
                        dwReplyMessageLength,
                        &ErrorMessage
                        );
        if (KERB_SUCCESS(KerbErr))
        {
            KerbErr = (KERBERR) ErrorMessage->error_code;
            TraceSz1( KerbWarn,"XkerbVerifyTgsReply: Got KerbError 0x%X", KerbErr );

            //
            // Check for time skew. If we got a skew error, record the time
            // skew between here and the KDC in the ticket so we can retry
            // with the correct time.
            //

            if (KerbErr == KRB_AP_ERR_SKEW)
            {
                TimeStamp KdcTime;

                KerbConvertGeneralizedTimeToLargeInt(
                    &KdcTime,
                    &ErrorMessage->server_time,
                    ErrorMessage->server_usec
                    );

                KerbUpdateCurrentTime( KdcTime );
                
                Status = STATUS_TIME_DIFFERENCE_AT_DC;
                goto Cleanup;
            }
            KerbFreeKerbError(ErrorMessage);
            Status = KerbMapKerbError(KerbErr);
        }
        else
        {
            Status = STATUS_LOGON_FAILURE;
        }
        goto Cleanup;
    }

    //
    // Construct encryption key struct for session key
    //
    KerbCreateKeyFromBuffer(
        &SessionKey,
        pCombinedTGTContext->SessionKey,
        XONLINE_KEY_LENGTH,
        KERB_ETYPE_RC4_HMAC_NT
        );

    //
    // Get the XKERB_PA_XBOX_SERVICE_ADDRESS pre-auth
    //
    pPreAuthData = KerbFindPreAuthDataEntry(
                    KRB5_PADATA_XBOX_SERVICE_ADDRESS,
                    (PKERB_PA_DATA_LIST)KdcReply->preauth_data
                    );
    if (pPreAuthData == NULL)
    {
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    //
    // Allocate Service Address reply memory on stack
    //
    pPAServiceAddress = (PXKERB_PA_XBOX_SERVICE_ADDRESS) _alloca( sizeof(XKERB_PA_XBOX_SERVICE_ADDRESS) );
    if (pPAServiceAddress == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Check the pre-auth reply
    //
    KerbErr = KerbVerifyServiceAddressPreAuth(
        &ScratchMemoryAllocator,
        pPreAuthData,
        &SessionKey,
        pXKerbServiceContext,
        pPAServiceAddress
        );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbErr;
        goto Cleanup;
    }

    //
    // Check the master return HRESULT
    //
    pXKerbServiceContext->hr = pPAServiceAddress->hr;
    if (SUCCEEDED(pPAServiceAddress->hr))
    {
        //
        // Handle the returned Service address results
        //
        pXKerbServiceContext->siteIPAddress = pPAServiceAddress->siteIPAddress;
        Assert( pPAServiceAddress->dwNumServices <= XONLINE_MAX_NUMBER_SERVICE );
        Assert( pPAServiceAddress->dwNumServices == pXKerbServiceContext->dwNumServices );
        for (i=0; i<pXKerbServiceContext->dwNumServices; ++i)
        {
            // Should be same as pPAServiceAddress->dwNumServices
            for (j=0; j<pXKerbServiceContext->dwNumServices; ++j)
            {
                if ( pXKerbServiceContext->dwServiceID[i] == pPAServiceAddress->serviceResult[j].dwServiceID )
                {
                    pXKerbServiceContext->hrService[i] = pPAServiceAddress->serviceResult[j].hr;
                    pXKerbServiceContext->wServicePort[i] = pPAServiceAddress->serviceResult[j].wServicePort;
                    break;
                }
            }
        }

        //
        // Pass returned authorization info about users
        //
        if ( pUsers != NULL )
        {
            for (i=0; i<XONLINE_MAX_LOGON_USERS; ++i)
            {
                for (j=0; j<XONLINE_MAX_LOGON_USERS; ++j)
                {
                    if (pUsers[i].xuid.qwUserID == pCombinedTGTContext->UserID[j])
                    {
                        // Use 'or' to avoid clobbering the guest bits.
                        pUsers[i].xuid.dwUserFlags |= pPAServiceAddress->dwUserFlags[j];
                        pUsers[i].hr = pPAServiceAddress->hrUser[j];
                        break;                    
                    }
                }
            }
        }
    }
    
    //
    // Cache the ticket
    //
    {
        CReleaseAllScratchMemoryUponDestruction onlyPreserveThisMemory( &ScratchMemoryAllocator );

        pXKerbServiceContext->dwTicketLength = 0;
        pEncodedTicket = NULL;
        KerbErr = KerbPackData(
                    &ScratchMemoryAllocator,
                    &KdcReply->ticket,
                    KERB_TICKET_PDU,
                    &pXKerbServiceContext->dwTicketLength,
                    &pEncodedTicket
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        if (pXKerbServiceContext->dwTicketLength > XONLINE_MAX_TICKET_LENGTH)
        {
            TraceSz1( KerbWarn, "XkerbVerifyTgsReply: got a ticket too big: %d", pXKerbServiceContext->dwTicketLength );
            Status = STATUS_LOGON_FAILURE;
            goto Cleanup;
        }

        RtlCopyMemory(
            pXKerbServiceContext->Ticket,
            pEncodedTicket,
            pXKerbServiceContext->dwTicketLength
            );
    }
    
    //
    // Now unpack the reply body:
    //
    KerbErr = KerbUnpackKdcReplyBody(
                &ScratchMemoryAllocator,
                &KdcReply->encrypted_part,
                &SessionKey,
                KERB_ENCRYPTED_TGS_REPLY_PDU,
                &ReplyBody
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    //
    // Verify the nonce is correct:
    //
    for (i=0; i<pXKerbServiceContext->ctNumNonces; ++i)
    {
        if (pXKerbServiceContext->Nonce[i] == (DWORD)ReplyBody->nonce)
        {
            break;
        }
    }
    if (i == pXKerbServiceContext->ctNumNonces)
    {
        TraceSz3( KerbWarn, "XkerbVerifyTgsReply: All %d Nonces don't match: 0x%X vs 0x%X", i, pXKerbServiceContext->Nonce[0], ReplyBody->nonce);
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    //
    // Cache the session key
    //
    if (ReplyBody->session_key.keytype != KERB_ETYPE_RC4_HMAC_NT ||
        ReplyBody->session_key.keyvalue.length != XONLINE_KEY_LENGTH)
    {
        TraceSz2( KerbWarn, "XkerbVerifyTgsReply got a session key of the wrong type (%d) or length(%d)",
            ReplyBody->session_key.keytype, ReplyBody->session_key.keyvalue.length
            );
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    RtlCopyMemory( pXKerbServiceContext->SessionKey, ReplyBody->session_key.keyvalue.value, XONLINE_KEY_LENGTH );

    //
    // Copy the principal name (might be different because of name canonicalization)
    //
    KerbErr = KerbPrincipalNameToMultiString(
        &KdcReply->client_name,
        sizeof(pXKerbServiceContext->ClientName),
        pXKerbServiceContext->ClientName
        );
    if (!KERB_SUCCESS(KerbErr))
    {
        TraceSz( KerbWarn, "XkerbVerifyTgsReply: returned client name is too long" );
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }        

    if ( strlen(KdcReply->client_realm) <= XONLINE_MAX_REALM_NAME_LENGTH )
    {
        strcpy(pXKerbServiceContext->ClientRealm, KdcReply->client_realm);    
    }
    else
    {
        TraceSz( KerbWarn, "XkerbVerifyTgsReply: returned client realm is too long" );
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }        

    //
    // Cache the expiration time
    //
    KerbConvertGeneralizedTimeToLargeInt(
        &pXKerbServiceContext->ExpirationTime,
        &ReplyBody->endtime,
        0
        );
    
    KerbConvertGeneralizedTimeToLargeInt(
        &pXKerbServiceContext->StartTime,
        &ReplyBody->starttime,
        0
        );
    
    //
    // Verbose trace info
    //
    TraceSz2( KerbVerbose,"XkerbVerifyTgsReply: extracted %d byte ticket from %d byte reply",
        pXKerbServiceContext->dwTicketLength, dwReplyMessageLength
        );

Cleanup:
    return(Status);
}


//--------------------------------------------------------------------------
    
NTSTATUS
CXo::XkerbBuildApRequest(
    IN PXKERB_SERVICE_CONTEXT pServiceContext,
    OUT LARGE_INTEGER * pliTime,
    IN BYTE * pbSha,
    IN UINT cbSha, 
    OUT PUCHAR pbRequestMessage,
    IN OUT UINT * pdwRequestMessageLength
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr;
    ULONG ApOptions = KERB_AP_OPTIONS_mutual_required;
    ULONG RequestSize;
    PUCHAR RequestStart;
    PUCHAR MarshalledApRequest;
    ULONG ApRequestSize;
    KERB_ENCRYPTION_KEY SessionKey;
    PKERB_TICKET pTicket = NULL;
    KERB_CHECKSUM RequestChecksum;
    PUCHAR pbScratchMemory;
    CScratchMemoryAllocator ScratchMemoryAllocator;

    //
    // Initialize scratch memory
    //
    pbScratchMemory = (PUCHAR)ScratchMemoryAllocator.ScratchMemoryInitialize( SCRATCH_MEMORY_SIZE_FOR_BuildApRequest, pbRequestMessage, *pdwRequestMessageLength, this );
    if (pbScratchMemory == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Set the authenticator time
    //
    KerbGetCurrentTime( pliTime );

    //
    // Construct encryption key struct for session key
    //
    KerbCreateKeyFromBuffer(
        &SessionKey,
        pServiceContext->SessionKey,
        XONLINE_KEY_LENGTH,
        KERB_ETYPE_RC4_HMAC_NT
        );

    //
    // Construct kerb ticket structure from packed data
    //
    KerbErr = KerbUnpackData(
                &ScratchMemoryAllocator,
                pServiceContext->Ticket,
                pServiceContext->dwTicketLength,
                KERB_TICKET_PDU,
                (PVOID*)&pTicket
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Setup the application checksum
    //
    RtlZeroMemory( &RequestChecksum, sizeof(KERB_CHECKSUM) );
    RequestChecksum.checksum.value = pbSha;
    RequestChecksum.checksum.length = cbSha;
    RequestChecksum.checksum_type = KERB_CHECKSUM_SHA1;

    //
    // Create the AP request
    //
    ApRequestSize = *pdwRequestMessageLength;
    MarshalledApRequest = pbRequestMessage;
    KerbErr = KerbCreateApRequest(
                &ScratchMemoryAllocator,
                pServiceContext->ClientName,
                pServiceContext->ClientRealm,
                &SessionKey,
                0, // KerbAllocateNonce(),
                pliTime,
                pTicket,
                ApOptions,
                &RequestChecksum,
                FALSE,                          // not a KDC request
                &ApRequestSize,
                &MarshalledApRequest
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    *pdwRequestMessageLength = ApRequestSize;

    TraceSz2( KerbVerbose, "XkerbBuildApRequest built Ap request %d bytes long (%X checksum)",
        ApRequestSize, XConfigChecksum(pbRequestMessage, *pdwRequestMessageLength) );

Cleanup:
    return(Status);
}

//--------------------------------------------------------------------------

NTSTATUS
CXo::XkerbVerifyApReply(
    IN PXKERB_SERVICE_CONTEXT pServiceContext,
    IN LARGE_INTEGER * pliTime,
    OUT BYTE * pbSha,
    IN UINT cbSha, 
    IN PUCHAR pbReplyMessage,
    IN UINT dwReplyMessageLength
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr;
    PKERB_AP_REPLY Reply = NULL;
    PKERB_ENCRYPTED_AP_REPLY ReplyBody = NULL;
    KERB_TIME ReplyAuthenticatorTime;
    long ReplyAuthenticatorUsec;
    KERB_ENCRYPTION_KEY SessionKey;
    PUCHAR pbScratchMemory;
    CScratchMemoryAllocator ScratchMemoryAllocator;

    TraceSz2( KerbVerbose, "XkerbVerifyApReply got Ap reply %d bytes long (%X checksum)",
        dwReplyMessageLength, XConfigChecksum(pbReplyMessage, dwReplyMessageLength) );

    //
    // Initialize scratch memory
    //
    pbScratchMemory = (PUCHAR)ScratchMemoryAllocator.ScratchMemoryInitialize( SCRATCH_MEMORY_SIZE_FOR_VerifyApReply, NULL, 0, this );
    if (pbScratchMemory == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    if (!KERB_SUCCESS(KerbUnpackApReply(
                        &ScratchMemoryAllocator,
                        pbReplyMessage,
                        dwReplyMessageLength,
                        &Reply
                        )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    if ((Reply->version != KERBEROS_VERSION) ||
        (Reply->message_type != KRB_AP_REP))
    {
        TraceSz2( KerbWarn, "XkerbVerifyApReply: Illegal version (0x%X) or message type (0x%X)",
            Reply->version, Reply->message_type
            );
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    //
    // Construct encryption key struct for session key
    //
    KerbCreateKeyFromBuffer(
        &SessionKey,
        pServiceContext->SessionKey,
        XONLINE_KEY_LENGTH,
        KERB_ETYPE_RC4_HMAC_NT
        );

    //
    // Now decrypt the encrypted part.
    //
    KerbErr = KerbDecryptDataEx(
                &ScratchMemoryAllocator,
                &Reply->encrypted_part,
                &SessionKey,
                KERB_AP_REP_SALT,
                (PULONG) &Reply->encrypted_part.cipher_text.length,
                Reply->encrypted_part.cipher_text.value
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        if (KerbErr == KRB_ERR_GENERIC)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            Status = STATUS_LOGON_FAILURE;
        }
        goto Cleanup;
    }

    //
    // Decode the contents now
    //
    if (!KERB_SUCCESS(KerbUnpackApReplyBody(
                        &ScratchMemoryAllocator,
                        Reply->encrypted_part.cipher_text.value,
                        Reply->encrypted_part.cipher_text.length,
                        &ReplyBody)))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    KerbConvertLargeIntToGeneralizedTime(
        &ReplyAuthenticatorTime,
        &ReplyAuthenticatorUsec,
        pliTime
        );
        
    if ((ReplyAuthenticatorUsec != ReplyBody->client_usec) ||
        memcmp( &ReplyAuthenticatorTime, &(ReplyBody->client_time), sizeof(ReplyAuthenticatorTime) ))
    {
        TraceSz( KerbWarn, "XkerbVerifyApReply: clientTime and clientUsec verification failed" );
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    //
    // Check to see if a session key was sent back.
    // This session key is the returned application checksum.
    //
    if ((ReplyBody->bit_mask & KERB_ENCRYPTED_AP_REPLY_subkey_present) == 0)
    {
        TraceSz( KerbWarn, "XkerbVerifyApReply didn't get a application checksum" );
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    if (ReplyBody->KERB_ENCRYPTED_AP_REPLY_subkey.keytype != KERB_CHECKSUM_SHA1 ||
        ReplyBody->KERB_ENCRYPTED_AP_REPLY_subkey.keyvalue.length != cbSha)
    {
        TraceSz2( KerbWarn, "XkerbVerifyApReply got a session key of the wrong type (%d) or length(%d)",
            ReplyBody->KERB_ENCRYPTED_AP_REPLY_subkey.keytype, ReplyBody->KERB_ENCRYPTED_AP_REPLY_subkey.keyvalue.length
            );
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    RtlCopyMemory( pbSha, ReplyBody->KERB_ENCRYPTED_AP_REPLY_subkey.keyvalue.value, cbSha );

    Status = STATUS_SUCCESS;

Cleanup:
    return(Status);
}

//+-------------------------------------------------------------------------

VOID
KerbConvertGeneralizedTimeToLargeInt(
    OUT PTimeStamp TimeStamp,
    IN PKERB_TIME ClientTime,
    IN int ClientUsec
    )
{
    KERB_TIME ZeroTime;
    TIME_FIELDS TimeFields;

    //
    // Special case zero time
    //

    RtlZeroMemory(
        &ZeroTime,
        sizeof(KERB_TIME)
        );

    ZeroTime.universal = TRUE;

    //
    // Skip this check after 3/1/97 - no clients should send this sort of
    // zero time
    //
    if (RtlEqualMemory(
            &ZeroTime,
            ClientTime,
            sizeof(KERB_TIME)
            ))
    {
        KerbSetTime(TimeStamp,0);
        return;
    }

    //
    // Check for MIT zero time
    //

    ZeroTime.year = 1970;
    ZeroTime.month = 1;
    ZeroTime.day = 1;

    if (RtlEqualMemory(
            &ZeroTime,
            ClientTime,
            sizeof(KERB_TIME)
            ))
    {
        KerbSetTime(TimeStamp,0);
        return;
    }
    else
    {
        TimeFields.Year = ClientTime->year;
        TimeFields.Month = ClientTime->month;
        TimeFields.Day = ClientTime->day;
        TimeFields.Hour = ClientTime->hour;
        TimeFields.Minute = ClientTime->minute;
        TimeFields.Second = ClientTime->second;
        TimeFields.Milliseconds = ClientTime->millisecond;  // to convert from micro to milli
        TimeFields.Weekday = 0;

#ifndef TIMESTAMPISINT64
        RtlTimeFieldsToTime(
            &TimeFields,
            TimeStamp
            );
#else // TIMESTAMPISINT64
        LARGE_INTEGER TempTimeStamp;
        RtlTimeFieldsToTime(
            &TimeFields,
            &TempTimeStamp
            );
        *TimeStamp = TempTimeStamp.QuadPart;
#endif // TIMESTAMPISINT64

        //
        // add in any micro seconds
        //

        KerbGetTime(*TimeStamp) += ClientUsec * 10;

    }

}


//+-------------------------------------------------------------------------

VOID
KerbConvertLargeIntToGeneralizedTime(
    OUT PKERB_TIME ClientTime,
    OUT OPTIONAL LONG* ClientUsec,
    IN PTimeStamp TimeStamp
    )
{
    TIME_FIELDS TimeFields;

    //
    // This zeroing is needed or else a useless byte in the middle might be different
    //
    RtlZeroMemory(
        ClientTime,
        sizeof(KERB_TIME)
        );

    //
    // Special case zero time
    //

    if (KerbGetTime(*TimeStamp) == 0)
    {
        //
        // BUGBUG: For MIT compatibility, time zero is 1/1/70
        //

        ClientTime->year = 1970;
        ClientTime->month = 1;
        ClientTime->day = 1;

        if (ARGUMENT_PRESENT(ClientUsec))

        {
            *ClientUsec  = 0;
        }
        ClientTime->universal = TRUE;
    }
    else
    {

        RtlTimeToTimeFields(
            (LARGE_INTEGER*)TimeStamp,
            &TimeFields
            );

        //
        // Generalized times can only contains years up to four digits.
        //

        if (TimeFields.Year > 2037)
        {
            ClientTime->year = 2037;
        }
        else
        {
            ClientTime->year = TimeFields.Year;
        }
        ClientTime->month = (ASN1uint8_t) TimeFields.Month;
        ClientTime->day = (ASN1uint8_t) TimeFields.Day;
        ClientTime->hour = (ASN1uint8_t) TimeFields.Hour;
        ClientTime->minute = (ASN1uint8_t) TimeFields.Minute;
        ClientTime->second = (ASN1uint8_t) TimeFields.Second;

        // BUGBUG: MIT kerberos does not support millseconds
        //
        // ClientTime->millisec = TimeFields.Milliseconds;
        //

        ClientTime->millisecond = 0;

        if (ARGUMENT_PRESENT(ClientUsec))
        {
            //
            // The low part of time is 100 nanoseconds, so one 10th of that
            // is microseconds. We only want the microseconds not included
            // in the milliseconds above.
            //
            //
            // BUGBUG: since we don't includ milliseconds above, use the whole
            // thing here.
            //

#ifndef TIMESTAMPISINT64
            *ClientUsec = (TimeStamp->LowPart / 10) % 1000000;
#else // TIMESTAMPISINT64
            *ClientUsec = (int) ((*TimeStamp / 10) % 1000000);
#endif // TIMESTAMPISINT64
        }

        ClientTime->diff = 0;
        ClientTime->universal = TRUE;
    }

}

//+---------------------------------------------------------------------------

KERBERR NTAPI
KerbCreateAuthenticator(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN PKERB_ENCRYPTION_KEY pkKey,
    IN ULONG EncryptionType,
    IN ULONG SequenceNumber,
    IN PTimeStamp pAuthenticatorTime,
    IN LPSTR ClientName,
    IN LPSTR ClientRealm,
    IN OPTIONAL PKERB_CHECKSUM Checksum,
    IN BOOLEAN KdcRequest,
    OUT PKERB_ENCRYPTED_DATA Authenticator
    )
{
    KERB_AUTHENTICATOR InternalAuthenticator;
    PKERB_AUTHENTICATOR AuthPointer = &InternalAuthenticator;
    ULONG cbAuthenticator;
    PUCHAR PackedAuthenticator;
    KERBERR KerbErr = KDC_ERR_NONE;

    Authenticator->cipher_text.value = NULL;

    RtlZeroMemory(
        &InternalAuthenticator,
        sizeof(KERB_AUTHENTICATOR)
        );

    // Build an authenticator

    InternalAuthenticator.authenticator_version = KERBEROS_VERSION;

    InternalAuthenticator.client_realm = ClientRealm;
    
    KerbErr = KerbMultiStringToPrincipalName(
                pScratchMemoryAllocator,
                ClientName,
                &InternalAuthenticator.client_name
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Stick the correct time in the authenticator
    //

    KerbConvertLargeIntToGeneralizedTime(
        &InternalAuthenticator.client_time,
        &InternalAuthenticator.client_usec,
        pAuthenticatorTime
        );

    InternalAuthenticator.bit_mask |= KERB_AUTHENTICATOR_sequence_number_present;

    InternalAuthenticator.KERB_AUTHENTICATOR_sequence_number = SequenceNumber;

    //
    // If the checksum is present, include it and set it in the bitmask
    //

    if (ARGUMENT_PRESENT(Checksum))
    {
        InternalAuthenticator.checksum = *Checksum;
        InternalAuthenticator.bit_mask |= checksum_present;
    }

    cbAuthenticator = 0;
    PackedAuthenticator = NULL;
    KerbErr = KerbPackData(
                pScratchMemoryAllocator,
                AuthPointer,
                KERB_AUTHENTICATOR_PDU,
                &cbAuthenticator,
                &PackedAuthenticator
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    //
    // Now we need to encrypt the buffer
    //

        KerbErr = KerbAllocateEncryptionBuffer(
                pScratchMemoryAllocator,
                EncryptionType,
                cbAuthenticator,
                &Authenticator->cipher_text.length,
                &Authenticator->cipher_text.value
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }


    KerbErr = KerbEncryptDataEx(
                pScratchMemoryAllocator,
                Authenticator,
                cbAuthenticator,
                PackedAuthenticator,
                EncryptionType,
                KdcRequest ? KERB_TGS_REQ_AP_REQ_AUTH_SALT : KERB_AP_REQ_AUTH_SALT,
                pkKey
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

Cleanup:
    if (!KERB_SUCCESS(KerbErr))
    {
        TraceSz1( KerbWarn, "KerbCreateAuthenticator failure KerbErr 0x%X", KerbErr );
    }
    return(KerbErr);
}


//+-------------------------------------------------------------------------

KERBERR NTAPI
KerbUnpackKdcReplyBody(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN PKERB_ENCRYPTED_DATA EncryptedReplyBody,
    IN PKERB_ENCRYPTION_KEY Key,
    IN ULONG Pdu,
    OUT PKERB_ENCRYPTED_KDC_REPLY * ReplyBody
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    PUCHAR MarshalledReply = NULL;
    ULONG ReplySize;

    *ReplyBody = NULL;
    MarshalledReply = (PUCHAR) pScratchMemoryAllocator->Alloc(EncryptedReplyBody->cipher_text.length);

    if (MarshalledReply == NULL)
    {
        return(KRB_ERR_GENERIC);
    }

    //
    // First decrypt the buffer
    //

    ReplySize = EncryptedReplyBody->cipher_text.length;
    KerbErr = KerbDecryptDataEx(
                pScratchMemoryAllocator,
                EncryptedReplyBody,
                Key,
                (Pdu == KERB_AS_REPLY_PDU) ? KERB_AS_REP_SALT : KERB_TGS_REP_SALT,
                &ReplySize,
                MarshalledReply
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    KerbErr = KerbUnpackData(
                pScratchMemoryAllocator,
                MarshalledReply,
                ReplySize,
                Pdu,
                (PVOID *) ReplyBody
                );

    if (!KERB_SUCCESS(KerbErr))
    {

        //
        // MIT KDCs send back TGS reply bodies instead of AS reply bodies
        // so try TGS here
        //

        if (Pdu == KERB_ENCRYPTED_AS_REPLY_PDU)
        {
            KerbErr = KerbUnpackData(
                        pScratchMemoryAllocator,
                        MarshalledReply,
                        ReplySize,
                        KERB_ENCRYPTED_TGS_REPLY_PDU,
                        (PVOID *) ReplyBody
                        );
        }
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

    }
Cleanup:
    if (!KERB_SUCCESS(KerbErr) && (*ReplyBody != NULL))
    {
        *ReplyBody = NULL;
    }
    return(KerbErr);
}

//+-------------------------------------------------------------------------

KERBERR
KerbCreateApRequest(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN LPSTR ClientName,
    IN LPSTR ClientRealm,
    IN PKERB_ENCRYPTION_KEY SessionKey,
    IN ULONG Nonce,
    IN PTimeStamp pAuthenticatorTime,
    IN PKERB_TICKET ServiceTicket,
    IN ULONG ApOptions,
    IN OPTIONAL PKERB_CHECKSUM Checksum,
    IN BOOLEAN KdcRequest,
    OUT PULONG RequestSize,
    OUT PUCHAR * Request
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    KERB_AP_REQUEST ApRequest;
    ULONG ApFlags;
    void* pTempBuffer;
    BOOL fDestinationBufferUnspecified = (*Request == NULL);
    
    RtlZeroMemory(
        &ApRequest,
        sizeof(KERB_AP_REQUEST)
        );

    //
    // Fill in the AP request structure.
    //

    ApRequest.version = KERBEROS_VERSION;
    ApRequest.message_type = KRB_AP_REQ;
    ApFlags = KerbConvertUlongToFlagUlong(ApOptions);
    ApRequest.ap_options.value = (PUCHAR) &ApFlags;
    ApRequest.ap_options.length = sizeof(ULONG) * 8;
    ApRequest.ticket = *ServiceTicket;

    {
        CReleaseAllScratchMemoryUponDestruction onlyPreserveThisMemory( pScratchMemoryAllocator );
        
        //
        // Create the authenticator for the request
        //

        KerbErr = KerbCreateAuthenticator(
                    pScratchMemoryAllocator,
                    SessionKey,
                    SessionKey->keytype,
                    Nonce,
                    pAuthenticatorTime,
                    ClientName,
                    ClientRealm,
                    Checksum,
                    KdcRequest,
                    &ApRequest.authenticator
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        //
        // Now marshall the request
        //
        KerbErr = KerbPackApRequest(
                    pScratchMemoryAllocator,
                    &ApRequest,
                    RequestSize,
                    Request
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }

        if (fDestinationBufferUnspecified)
        {
            //
            // Preserve the only piece of memory we care about
            //
            pTempBuffer = PreserveThisMemory( &onlyPreserveThisMemory, Request, *RequestSize );
            if (pTempBuffer == NULL)
            {
                KerbErr = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }
        }
    }
    
Cleanup:
    if (!KERB_SUCCESS(KerbErr))
    {
        TraceSz1( KerbWarn, "KerbCreateApRequest failure KerbErr 0x%X", KerbErr );
    }
    return(KerbErr);
}

//+-------------------------------------------------------------------------

KERBERR
KerbInitAsn(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN OUT ASN1encoding_t * pEnc,
    IN OUT ASN1decoding_t * pDec
    )
{
    KERBERR KerbErr = KRB_ERR_GENERIC;
    ASN1module_t pASN1Module = pScratchMemoryAllocator->GetXoPtr()->GetASN1Module();
    ASN1error_e Asn1Err;

    if (pEnc != NULL)
    {
            Asn1Err = ASN1_CreateEncoder(
                                     pScratchMemoryAllocator,
                                     pASN1Module,
                                     pEnc,
                                     NULL,           // pbBuf
                                     0,              // cbBufSize
                                     NULL            // pParent
                                     );
    }
    else
    {
            Asn1Err = ASN1_CreateDecoder(
                                     pScratchMemoryAllocator,
                                     pASN1Module,
                                     pDec,
                                     NULL,           // pbBuf
                                     0,              // cbBufSize
                                     NULL            // pParent
                                     );
    }

    if (ASN1_SUCCESS != Asn1Err)
    {
            goto Cleanup;
    }

    KerbErr = KDC_ERR_NONE;

Cleanup:
    if (!KERB_SUCCESS(KerbErr))
    {
        TraceSz1( KerbWarn, "KerbInitAsn failure KerbErr 0x%X", KerbErr );
    }

    return(KerbErr);
}


//+-------------------------------------------------------------------------

VOID
KerbTermAsn(
        IN ASN1encoding_t pEnc,
        IN ASN1decoding_t pDec
    )
{
    if (pEnc != NULL)
    {
            ASN1_CloseEncoder(pEnc);
    }
    else if (pDec != NULL)
    {
            ASN1_CloseDecoder(pDec);
    }
}

//+-------------------------------------------------------------------------

KERBERR NTAPI
KerbPackData(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN PVOID Data,
    IN ULONG PduValue,
    OUT PULONG DataSize,
    OUT PUCHAR * MarshalledData
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    int Result = 0;
    PUCHAR Buffer = NULL;
    ASN1encoding_t pEnc = NULL;
    ASN1error_e Asn1Err;
    void* pTempBuffer;

    KerbErr = KerbInitAsn(
                pScratchMemoryAllocator,
                &pEnc,          // we are encoding
                NULL
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    {
        CReleaseAllScratchMemoryUponDestruction onlyPreserveThisMemory( pScratchMemoryAllocator );
        //
        // Encode the data type.
        //

        Assert( (*MarshalledData == NULL && *DataSize == 0) || (*MarshalledData != NULL && *DataSize != 0) );
        AssertSz( *DataSize <= 10000, "Passing buffer larger than 10K, most likely an error");
                
        TraceSz1( KerbASN1, "ASN encoding pdu #%d", PduValue );
        if (*MarshalledData != NULL)
        {
            Asn1Err = ASN1_Encode(
                        pEnc,
                        Data,
                        PduValue,
                        ASN1ENCODE_SETBUFFER,
                        *MarshalledData,         
                        *DataSize                        
                        );
        }
        else
        {
            Asn1Err = ASN1_Encode(
                        pEnc,
                        Data,
                        PduValue,
                        ASN1ENCODE_ALLOCATEBUFFER,
                        NULL,                       // pbBuf
                        0                           // cbBufSize
                        );
        }
        if (!ASN1_SUCCEEDED(Asn1Err))
        {
            KerbErr = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        else
        {
            if ( *MarshalledData != NULL )
            {
                //
                // Caller specified a destination buffer
                //
                if (*MarshalledData == pEnc->buf)
                {
                    //
                    // Caller's destination buffer was used, that's what we want
                    //
                    *DataSize = pEnc->len;
                }
                else
                {
                    //
                    // Caller's destination buffer was too small, report failure
                    //
                    *DataSize = 0;
                    *MarshalledData = NULL;
                    KerbErr = STATUS_INSUFFICIENT_RESOURCES;
                    goto Cleanup;
                }
            }
            else
            {
                //
                // Caller didn't specify a destination buffer
                //
                *DataSize = pEnc->len;
                *MarshalledData = pEnc->buf;
                //
                // Preserve the only piece of memory we care about
                //
                pTempBuffer = PreserveThisMemory( &onlyPreserveThisMemory, MarshalledData, *DataSize );
                if (pTempBuffer == NULL)
                {
                    KerbErr = KRB_ERR_GENERIC;
                    goto Cleanup;
                }
            }
        }

        KerbTermAsn(pEnc, NULL);
    }

Cleanup:
    if (!KERB_SUCCESS(KerbErr))
    {
        TraceSz1( KerbWarn, "KerbPackData failure KerbErr 0x%X", KerbErr );
    }
    return(KerbErr);
}


//+-------------------------------------------------------------------------

KERBERR NTAPI
KerbUnpackData(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN PUCHAR Data,
    IN ULONG DataSize,
    IN ULONG PduValue,
    OUT PVOID * DecodedData
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    ASN1decoding_t pDec = NULL;
        ASN1error_e Asn1Err;

    Assert((DataSize != 0) && (Data != NULL));

    KerbErr = KerbInitAsn(
                pScratchMemoryAllocator,
                NULL,
                &pDec           // we are decoding
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    TraceSz1( KerbASN1, "ASN decoding pdu #%d", PduValue );
    *DecodedData = NULL;
    Asn1Err = ASN1_Decode(
                pDec,
                DecodedData,
                PduValue,
                ASN1DECODE_SETBUFFER,
                (BYTE *) Data,
                DataSize
                );

    if (!ASN1_SUCCEEDED(Asn1Err))
    {

        if ((ASN1_ERR_BADARGS == Asn1Err) ||
            (ASN1_ERR_EOD == Asn1Err))
        {
            KerbErr = KDC_ERR_MORE_DATA;
        }
        else
        {
            KerbErr = KRB_ERR_GENERIC;
        }
        *DecodedData = NULL;
    }

    KerbTermAsn(NULL, pDec);

Cleanup:
    return(KerbErr);
}

//+-------------------------------------------------------------------------

NTSTATUS
KerbMapKerbError(
    IN KERBERR KerbError
    )
{
    NTSTATUS Status;
    switch(KerbError) {
    case KDC_ERR_NONE:
        Status = STATUS_SUCCESS;
        break;
    case KDC_ERR_CLIENT_REVOKED:
        Status = STATUS_ACCOUNT_DISABLED;
        break;
    case KDC_ERR_KEY_EXPIRED:
        Status = STATUS_PASSWORD_EXPIRED;
        break;
    case KRB_ERR_GENERIC:
        Status = STATUS_INSUFFICIENT_RESOURCES;
        break;
    case KRB_AP_ERR_SKEW:
        Status = STATUS_TIME_DIFFERENCE_AT_DC;
        break;
    case KDC_ERR_POLICY:
        Status = STATUS_ACCOUNT_RESTRICTION;
        break;
    case KDC_ERR_C_PRINCIPAL_UNKNOWN:
        Status = STATUS_NO_SUCH_USER;
        break;
    case KDC_ERR_S_PRINCIPAL_UNKNOWN:
        Status = STATUS_NO_TRUST_SAM_ACCOUNT;
        break;
    case KRB_AP_ERR_MODIFIED:
    case KDC_ERR_PREAUTH_FAILED:
        //
        // BUGBUG: use wronge_server_password
        //

        Status = STATUS_WRONG_PASSWORD;
        break;
    case KRB_ERR_RESPONSE_TOO_BIG:
        Status = STATUS_INVALID_BUFFER_SIZE;
        break;
    case KDC_ERR_PADATA_TYPE_NOSUPP:
        Status = STATUS_NOT_SUPPORTED;
        break;
    case KRB_AP_ERR_NOT_US:
        Status = SEC_E_WRONG_PRINCIPAL;
        break;

    case KDC_ERR_SVC_UNAVAILABLE:
        Status = STATUS_NO_LOGON_SERVERS;
        break;
    case KDC_ERR_WRONG_REALM:
        Status = STATUS_NO_SUCH_USER;
        break;
    case KDC_ERR_INVALID_CERTIFICATE:
        Status = STATUS_INVALID_PARAMETER;
        break;
    case KDC_ERR_REVOKED_CERTIFICATE:
        Status = CRYPT_E_REVOKED;
        break;
    case KDC_ERR_REVOCATION_STATUS_UNKNOWN:
        Status = CRYPT_E_NO_REVOCATION_CHECK;
        break;
    case KDC_ERR_REVOCATION_STATUS_UNAVAILABLE:
        Status = CRYPT_E_REVOCATION_OFFLINE;
        break;
    case KDC_ERR_CLIENT_NAME_MISMATCH:
        //
        // BUGBUG: wrong error
        //
        Status = STATUS_OBJECT_TYPE_MISMATCH;
        break;
    case KDC_ERR_KDC_NAME_MISMATCH:
        //
        // BUGBUG: wrong error
        //
        Status = STATUS_OBJECT_TYPE_MISMATCH;
        break;

    default:
        Status = STATUS_LOGON_FAILURE;
    }
    return(Status);

}

//+-------------------------------------------------------------------------

ULONG
KerbConvertUlongToFlagUlong(
    IN ULONG Flag
    )
{
    ULONG ReturnFlag;

    ((PUCHAR) &ReturnFlag)[0] = ((PUCHAR) &Flag)[3];
    ((PUCHAR) &ReturnFlag)[1] = ((PUCHAR) &Flag)[2];
    ((PUCHAR) &ReturnFlag)[2] = ((PUCHAR) &Flag)[1];
    ((PUCHAR) &ReturnFlag)[3] = ((PUCHAR) &Flag)[0];

    return(ReturnFlag);
}

#define MAXTIMEQUADPART (LONGLONG)0x7FFFFF36D5969FFF
#define MAXTIMEHIGHPART 0x7FFFFF36
#define MAXTIMELOWPART  0xD5969FFF

TimeStamp g_KerbGlobalWillNeverTime = { MAXTIMELOWPART, MAXTIMEHIGHPART };

//+-------------------------------------------------------------------------

VOID
KerbGetCurrentTime(
    OUT PTimeStamp pCurrentTime
    )
{
    GetSystemTimeAsFileTime((PFILETIME) pCurrentTime);
    
    return;
}
    
//+-------------------------------------------------------------------------

VOID
KerbUpdateCurrentTime(
    IN TimeStamp NewCurrentTime
    )
{
#ifdef XONLINE_FEATURE_WINDOWS
    SYSTEMTIME SystemTime;
    BOOL f = FileTimeToSystemTime( (FILETIME*)&NewCurrentTime, &SystemTime );
    Assert( f );
    f = SetSystemTime( &SystemTime );
    Assert( f );
#else
    NTSTATUS status;
    status = NtSetSystemTime( (PLARGE_INTEGER)&NewCurrentTime, NULL );
    Assert( status == STATUS_SUCCESS );
#endif
 
    TraceSz( KerbWarn,"KerbUpdateCurrentTime: Clock was corrected based on KDC reply" );
 
    return;
}

//+---------------------------------------------------------------------------

KERBERR NTAPI
KerbEncryptDataEx(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    OUT PKERB_ENCRYPTED_DATA EncryptedData,
    IN ULONG DataSize,
    IN PUCHAR Data,
    IN ULONG Algorithm,
    IN ULONG UsageFlags,
    IN PKERB_ENCRYPTION_KEY Key
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr = KDC_ERR_NONE;

    //
    // Initialize header
    //

    EncryptedData->encryption_type = KERB_ETYPE_RC4_HMAC_NT;

    Status =  rc4HmacEncrypt(
                pScratchMemoryAllocator,
                (PUCHAR) Key->keyvalue.value,
                Key->keyvalue.length,
                UsageFlags,
                Data,
                DataSize,
                EncryptedData->cipher_text.value,
                &EncryptedData->cipher_text.length
                );

    if (!NT_SUCCESS(Status))
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }

Cleanup:
    if (!KERB_SUCCESS(KerbErr))
    {
        TraceSz1( KerbWarn, "KerbEncryptDataEx failure KerbErr 0x%X", KerbErr );
    }
    return KerbErr;
}

//+---------------------------------------------------------------------------

KERBERR NTAPI
KerbDecryptDataEx(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN PKERB_ENCRYPTED_DATA EncryptedData,
    IN PKERB_ENCRYPTION_KEY pkKey,
    IN ULONG UsageFlags,
    OUT PULONG DataSize,
    OUT PUCHAR Data
    )
{
    NTSTATUS    Status  = STATUS_SUCCESS;
    KERBERR     KerbErr = KDC_ERR_NONE;

    Status = rc4HmacDecrypt(
                (PUCHAR) pkKey->keyvalue.value,
                pkKey->keyvalue.length,
                UsageFlags,
                EncryptedData->cipher_text.value,
                EncryptedData->cipher_text.length,
                Data,
                DataSize
                );

    if (!NT_SUCCESS(Status))
    {
        KerbErr = KRB_AP_ERR_MODIFIED;
        goto Cleanup;
    }

Cleanup:
    return KerbErr;
}

//------------------------------------------------------------------------

KERBERR
KerbConstructPrincipalName(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    OUT PKERB_PRINCIPAL_NAME PrincipalName,
    IN ULONG NameType,
    IN LPSTR pComp1,
    IN LPSTR pComp2
    )
{
    PKERB_PRINCIPAL_NAME_ELEM Elem1,Elem2;
    KERBERR Status = KDC_ERR_NONE;

    PrincipalName->name_type = (int) NameType;

    Assert( pComp1 != NULL );
    
    Elem1 = (PKERB_PRINCIPAL_NAME_ELEM) pScratchMemoryAllocator->Alloc(sizeof(KERB_PRINCIPAL_NAME_ELEM));
    if (Elem1 == NULL)
    {
        Status = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    Elem1->value = pComp1;
    Elem1->next = NULL;
    PrincipalName->name_string = Elem1;

    if ( pComp2 != NULL )
    {
        Elem2 = (PKERB_PRINCIPAL_NAME_ELEM) pScratchMemoryAllocator->Alloc(sizeof(KERB_PRINCIPAL_NAME_ELEM));
        if (Elem2 == NULL)
        {
            Status = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        Elem2->value = pComp2;
        Elem2->next = NULL;
        Elem1->next = Elem2;
    }
    
Cleanup:
    return(Status);
}

//------------------------------------------------------------------------

KERBERR
KerbMultiStringToPrincipalName(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN LPSTR pMultiString,
    OUT PKERB_PRINCIPAL_NAME PrincipalName
    )
{
    PKERB_PRINCIPAL_NAME_ELEM Elem1,Elem2;
    KERBERR Status = KDC_ERR_NONE;
    LPSTR pNextComponent;
    
    RtlZeroMemory( PrincipalName, sizeof(KERB_PRINCIPAL_NAME) );

    PrincipalName->name_type = atoi(pMultiString);

    pNextComponent = pMultiString + strlen(pMultiString) + 1;

    Elem1 = NULL;
    
    while (*pNextComponent != '\0')
    {
        Elem2 = (PKERB_PRINCIPAL_NAME_ELEM) pScratchMemoryAllocator->Alloc(sizeof(KERB_PRINCIPAL_NAME_ELEM));
        if (Elem2 == NULL)
        {
            Status = KRB_ERR_GENERIC;
            goto Cleanup;
        }
        Elem2->value = pNextComponent;
        Elem2->next = NULL;
        if (Elem1 != NULL)
        {
            Elem1->next = Elem2;
        }
        else
        {
            PrincipalName->name_string = Elem2;
        }
        Elem1 = Elem2;
        pNextComponent += strlen(pNextComponent) + 1;        
    }

Cleanup:
    return(Status);
}

//------------------------------------------------------------------------

KERBERR
KerbPrincipalNameToMultiString(
    IN PKERB_PRINCIPAL_NAME PrincipalName,
    IN DWORD dwMultiStringMaxLength,
    OUT LPSTR pMultiString
    )
{
    PKERB_PRINCIPAL_NAME_ELEM Elem;
    KERBERR Status = KDC_ERR_NONE;
    DWORD dwNextComponentLength;
    LPSTR pNextComponent;

    Assert( dwMultiStringMaxLength >= 32 );

    sprintf( pMultiString, "%d", PrincipalName->name_type );

    pNextComponent = pMultiString + strlen(pMultiString) + 1;

    //
    // pMultiString is now pointing at the end of buffer
    //
    pMultiString += dwMultiStringMaxLength;
    
    Elem = PrincipalName->name_string;
    
    while (Elem != NULL)
    {
        dwNextComponentLength = strlen( Elem->value ) + 1;
        if (pNextComponent + dwNextComponentLength + 1 > pMultiString)
        {
            Status = KRB_ERR_GENERIC;
            goto Cleanup;
        }

        memcpy(pNextComponent, Elem->value, dwNextComponentLength);
        pNextComponent += dwNextComponentLength;
        
        Elem = Elem->next;
    }
    *pNextComponent = '\0';

Cleanup:
    return(Status);
}

//////////////////////////////////////////////////////////////////////////

BOOLEAN
md5Hmac(
    IN PBYTE pbKeyMaterial,
    IN ULONG cbKeyMaterial,
    IN PBYTE pbData,
    IN ULONG cbData,
    IN PBYTE pbData2,
    IN ULONG cbData2,
    OUT PBYTE HmacData
    )
{
    BOOLEAN fRet = FALSE;
#define HMAC_K_PADSIZE              64
    BYTE Kipad[HMAC_K_PADSIZE];
    BYTE Kopad[HMAC_K_PADSIZE];
    BYTE HMACTmp[HMAC_K_PADSIZE+MD5_LEN];
    ULONG dwBlock;
    msr_MD5_CTX Md5Hash;

    // truncate
    if (cbKeyMaterial > HMAC_K_PADSIZE)
        cbKeyMaterial = HMAC_K_PADSIZE;


    RtlZeroMemory(Kipad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kipad, pbKeyMaterial, cbKeyMaterial);

    RtlZeroMemory(Kopad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kopad, pbKeyMaterial, cbKeyMaterial);


    //
    // Kipad, Kopad are padded sMacKey. Now XOR across...
    //

    for(dwBlock=0; dwBlock<HMAC_K_PADSIZE/sizeof(DWORD); dwBlock++)
    {
        ((DWORD*)Kipad)[dwBlock] ^= 0x36363636;
        ((DWORD*)Kopad)[dwBlock] ^= 0x5C5C5C5C;
    }


    //
    // prepend Kipad to data, Hash to get H1
    //

    msr_MD5Init(&Md5Hash);
    msr_MD5Update(&Md5Hash, Kipad, HMAC_K_PADSIZE);
    if (cbData != 0)
    {
        msr_MD5Update(&Md5Hash, pbData, cbData);
    }
    if (cbData2 != 0)
    {
        msr_MD5Update(&Md5Hash, pbData2, cbData2);
    }

    // Finish off the hash
    msr_MD5Final(&Md5Hash);

    // prepend Kopad to H1, hash to get HMAC
    RtlCopyMemory(HMACTmp, Kopad, HMAC_K_PADSIZE);
    RtlCopyMemory(HMACTmp+HMAC_K_PADSIZE, Md5Hash.digest, MD5_LEN);

    // final hash: output value into passed-in buffer
    msr_MD5Init(&Md5Hash);
    msr_MD5Update(&Md5Hash,HMACTmp, sizeof(HMACTmp));
    msr_MD5Final(&Md5Hash);
    RtlCopyMemory(
        HmacData,
        Md5Hash.digest,
        MD5_LEN
        );

    return TRUE;
}

NTSTATUS NTAPI
rc4HmacEncrypt(
    IN CScratchMemoryAllocator* pScratchMemoryAllocator,
    IN PUCHAR pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    OUT PUCHAR pbOutput,
    OUT PULONG pcbOutput
    )
{
    PRC4_MDx_HEADER CryptHeader = (PRC4_MDx_HEADER) pbOutput;
    BYTE StateKey[MD5_LEN];
    BYTE LocalKey[MD5_LEN];
    ULONG Offset = 0;
    BYTE Rc4KeyStruct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];

    md5Hmac(
        pbKey,
        KeySize,
        (PBYTE) &MessageType,
        sizeof(ULONG),
        NULL,
        0,
        StateKey
        );

    Offset = sizeof(RC4_MDx_HEADER);
    RtlMoveMemory(
        pbOutput + Offset,
        pbInput,
        cbInput
        );
    *pcbOutput = cbInput + Offset;

    //
    // Create the header - the confounder & checksum
    //

    RtlZeroMemory(
        CryptHeader->Checksum,
        MD5_LEN
        );

    pScratchMemoryAllocator->GetXoPtr()->XNetRandom(CryptHeader->Confounder, RC4_CONFOUNDER_LEN);

    //
    // Checksum everything but the checksum
    //

    md5Hmac(
        StateKey,
        MD5_LEN,
        pbOutput+MD5_LEN,
        *pcbOutput-MD5_LEN,
        NULL,
        0,
        CryptHeader->Checksum
        );


    //
    // HMAC the checksum into the key
    //

    md5Hmac(
        StateKey,
        MD5_LEN,
        CryptHeader->Checksum,
        MD5_LEN,
        NULL,
        0,
        LocalKey
        );

    XcRC4Key( Rc4KeyStruct, MD5_LEN, LocalKey );

    //
    // Encrypt everything but the checksum
    //

    XcRC4Crypt( Rc4KeyStruct, *pcbOutput-MD5_LEN, pbOutput+MD5_LEN );

    return(S_OK);
}

NTSTATUS
rc4HmacDecrypt(
    IN PUCHAR pbKey,
    IN ULONG KeySize,
    IN ULONG MessageType,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    OUT PUCHAR pbOutput,
    OUT PULONG pcbOutput)
{
    RC4_MDx_HEADER TempHeader;
    BYTE StateKey[MD5_LEN];
    BYTE TempChecksum[MD5_LEN];
    ULONG Offset = sizeof(RC4_MDx_HEADER);
    BYTE LocalKey[MD5_LEN];
    BYTE Rc4KeyStruct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];


    if (cbInput < Offset)
    {
        return(STATUS_INVALID_PARAMETER);
    }

    md5Hmac(
        pbKey,
        KeySize,
        (PBYTE) &MessageType,
        sizeof(ULONG),
        NULL,
        0,
        StateKey
        );

    //
    // Copy the input to the output before decrypting
    //

    RtlCopyMemory(
        &TempHeader,
        pbInput,
        Offset
        );

    *pcbOutput = cbInput - Offset;
    RtlMoveMemory(
        pbOutput,
        pbInput + Offset,
        *pcbOutput
        );


    //
    // Build the decryption key from the checksum and the
    // real key
    //

    md5Hmac(
        StateKey,
        MD5_LEN,
        TempHeader.Checksum,
        MD5_LEN,
        NULL,
        0,
        LocalKey
        );

    XcRC4Key( Rc4KeyStruct, MD5_LEN, LocalKey );

    //
    // Now decrypt the two buffers
    //

    XcRC4Crypt( Rc4KeyStruct, Offset - MD5_LEN, TempHeader.Confounder );
    XcRC4Crypt( Rc4KeyStruct, *pcbOutput, pbOutput );

    //
    // Now verify the checksum. First copy it out of the way, zero the
    // header
    //


    md5Hmac(
        StateKey,
        MD5_LEN,
        TempHeader.Confounder,
        Offset-MD5_LEN,
        pbOutput,
        *pcbOutput,
        TempChecksum
        );

    if (RtlEqualMemory(
            TempHeader.Checksum,
            TempChecksum,
            MD5_LEN
            ) != TRUE)
    {
        return(STATUS_UNSUCCESSFUL);
    }

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\krb5.h ===
#ifndef _KRB5_Module_H_
#define _KRB5_Module_H_

#include "msasn1.h"

typedef struct KERB_PA_PAC_REQUEST_EX_pac_sections_s * PKERB_PA_PAC_REQUEST_EX_pac_sections;

typedef struct KERB_KDC_REQUEST_BODY_encryption_type_s * PKERB_KDC_REQUEST_BODY_encryption_type;

typedef struct KERB_PRINCIPAL_NAME_name_string_s * PKERB_PRINCIPAL_NAME_name_string;

typedef struct PKERB_HOST_ADDRESSES_s * PPKERB_HOST_ADDRESSES;

typedef struct PKERB_AUTHORIZATION_DATA_s * PPKERB_AUTHORIZATION_DATA;

typedef struct PKERB_LAST_REQUEST_s * PPKERB_LAST_REQUEST;

typedef struct PKERB_TICKET_EXTENSIONS_s * PPKERB_TICKET_EXTENSIONS;

typedef struct PKERB_PREAUTH_DATA_LIST_s * PPKERB_PREAUTH_DATA_LIST;

typedef struct PKERB_ETYPE_INFO_s * PPKERB_ETYPE_INFO;

typedef struct KERB_KDC_ISSUED_AUTH_DATA_elements_s * PKERB_KDC_ISSUED_AUTH_DATA_elements;

typedef struct KERB_PA_PK_AS_REQ2_trusted_certifiers_s * PKERB_PA_PK_AS_REQ2_trusted_certifiers;

typedef struct KERB_PA_PK_AS_REQ2_user_certs_s * PKERB_PA_PK_AS_REQ2_user_certs;

typedef struct KERB_PA_PK_AS_REP2_kdc_cert_s * PKERB_PA_PK_AS_REP2_kdc_cert;

typedef struct KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data_s * PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data;

typedef struct KERB_KDC_REPLY_preauth_data_s * PKERB_KDC_REPLY_preauth_data;

typedef struct KERB_KDC_REQUEST_preauth_data_s * PKERB_KDC_REQUEST_preauth_data;

typedef struct KERB_PA_COMPOUND_IDENTITY_s * PKERB_PA_COMPOUND_IDENTITY;

typedef struct KERB_PA_PK_AS_REQ_trusted_certifiers_s * PKERB_PA_PK_AS_REQ_trusted_certifiers;

typedef struct KERB_ENCRYPTED_CRED_ticket_info_s * PKERB_ENCRYPTED_CRED_ticket_info;

typedef struct KERB_CRED_tickets_s * PKERB_CRED_tickets;

typedef struct KERB_KDC_REQUEST_BODY_additional_tickets_s * PKERB_KDC_REQUEST_BODY_additional_tickets;

typedef ASN1ztcharstring_t KERB_PRINCIPAL_NAME_name_string_Seq;

typedef ASN1int32_t KERB_KDC_REQUEST_BODY_encryption_type_Seq;

typedef ASN1int32_t KERB_PA_PAC_REQUEST_EX_pac_sections_Seq;

typedef ASN1ztcharstring_t KERB_REALM;

typedef PPKERB_AUTHORIZATION_DATA PKERB_AUTHORIZATION_DATA_LIST;
#define PKERB_AUTHORIZATION_DATA_LIST_PDU 0
#define SIZE_KRB5_Module_PDU_0 sizeof(PKERB_AUTHORIZATION_DATA_LIST)

typedef ASN1bitstring_t KERB_KDC_OPTIONS;

typedef ASN1generalizedtime_t KERB_TIME;

typedef ASN1intx_t KERB_SEQUENCE_NUMBER_LARGE;

typedef ASN1uint32_t KERB_SEQUENCE_NUMBER;

typedef ASN1bitstring_t KERB_TICKET_FLAGS;

typedef ASN1bitstring_t KERB_AP_OPTIONS;

typedef ASN1open_t NOCOPYANY;

typedef ASN1int32_t KERB_CERTIFICATE_SERIAL_NUMBER;

typedef PPKERB_AUTHORIZATION_DATA PKERB_IF_RELEVANT_AUTH_DATA;
#define PKERB_IF_RELEVANT_AUTH_DATA_PDU 1
#define SIZE_KRB5_Module_PDU_1 sizeof(PKERB_IF_RELEVANT_AUTH_DATA)

typedef struct KERB_PA_PAC_REQUEST_EX_pac_sections_s {
    PKERB_PA_PAC_REQUEST_EX_pac_sections next;
    KERB_PA_PAC_REQUEST_EX_pac_sections_Seq value;
} KERB_PA_PAC_REQUEST_EX_pac_sections_Element, *KERB_PA_PAC_REQUEST_EX_pac_sections;

typedef struct KERB_KDC_REQUEST_BODY_encryption_type_s {
    PKERB_KDC_REQUEST_BODY_encryption_type next;
    KERB_KDC_REQUEST_BODY_encryption_type_Seq value;
} KERB_KDC_REQUEST_BODY_encryption_type_Element, *KERB_KDC_REQUEST_BODY_encryption_type;

typedef struct PKERB_TICKET_EXTENSIONS_Seq {
    ASN1int32_t te_type;
    ASN1octetstring_t te_data;
} PKERB_TICKET_EXTENSIONS_Seq;

typedef struct KERB_PRINCIPAL_NAME_name_string_s {
    PKERB_PRINCIPAL_NAME_name_string next;
    KERB_PRINCIPAL_NAME_name_string_Seq value;
} KERB_PRINCIPAL_NAME_name_string_Element, *KERB_PRINCIPAL_NAME_name_string;

typedef struct PKERB_LAST_REQUEST_Seq {
    ASN1int32_t last_request_type;
    KERB_TIME last_request_value;
} PKERB_LAST_REQUEST_Seq;

typedef struct PKERB_AUTHORIZATION_DATA_Seq {
    ASN1int32_t auth_data_type;
    ASN1octetstring_t auth_data;
} PKERB_AUTHORIZATION_DATA_Seq;

typedef struct PKERB_HOST_ADDRESSES_Seq {
    ASN1int32_t address_type;
    ASN1octetstring_t address;
} PKERB_HOST_ADDRESSES_Seq;

typedef struct KERB_HOST_ADDRESS {
    ASN1int32_t addr_type;
    ASN1octetstring_t address;
} KERB_HOST_ADDRESS;

typedef struct PKERB_HOST_ADDRESSES_s {
    PPKERB_HOST_ADDRESSES next;
    PKERB_HOST_ADDRESSES_Seq value;
} PKERB_HOST_ADDRESSES_Element, *PKERB_HOST_ADDRESSES;

typedef struct PKERB_AUTHORIZATION_DATA_s {
    PPKERB_AUTHORIZATION_DATA next;
    PKERB_AUTHORIZATION_DATA_Seq value;
} PKERB_AUTHORIZATION_DATA_Element, *PKERB_AUTHORIZATION_DATA;

typedef struct PKERB_LAST_REQUEST_s {
    PPKERB_LAST_REQUEST next;
    PKERB_LAST_REQUEST_Seq value;
} PKERB_LAST_REQUEST_Element, *PKERB_LAST_REQUEST;

typedef struct KERB_PRINCIPAL_NAME {
    ASN1int32_t name_type;
    PKERB_PRINCIPAL_NAME_name_string name_string;
} KERB_PRINCIPAL_NAME;

typedef struct PKERB_TICKET_EXTENSIONS_s {
    PPKERB_TICKET_EXTENSIONS next;
    PKERB_TICKET_EXTENSIONS_Seq value;
} PKERB_TICKET_EXTENSIONS_Element, *PKERB_TICKET_EXTENSIONS;

typedef struct KERB_TRANSITED_ENCODING {
    ASN1int32_t transited_type;
    ASN1octetstring_t contents;
} KERB_TRANSITED_ENCODING;

typedef struct KERB_PA_DATA {
    ASN1int32_t preauth_data_type;
    ASN1octetstring_t preauth_data;
} KERB_PA_DATA;

typedef struct PKERB_PREAUTH_DATA_LIST_s {
    PPKERB_PREAUTH_DATA_LIST next;
    KERB_PA_DATA value;
} PKERB_PREAUTH_DATA_LIST_Element, *PKERB_PREAUTH_DATA_LIST;
#define PKERB_PREAUTH_DATA_LIST_PDU 2
#define SIZE_KRB5_Module_PDU_2 sizeof(PKERB_PREAUTH_DATA_LIST_Element)

typedef struct KERB_SAFE_BODY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1octetstring_t user_data;
#   define KERB_SAFE_BODY_timestamp_present 0x80
    KERB_TIME timestamp;
#   define KERB_SAFE_BODY_usec_present 0x40
    ASN1int32_t usec;
#   define KERB_SAFE_BODY_sequence_number_present 0x20
    KERB_SEQUENCE_NUMBER sequence_number;
    KERB_HOST_ADDRESS sender_address;
#   define KERB_SAFE_BODY_recipient_address_present 0x10
    KERB_HOST_ADDRESS recipient_address;
} KERB_SAFE_BODY;

typedef struct KERB_ENCRYPTED_PRIV {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1octetstring_t user_data;
#   define KERB_ENCRYPTED_PRIV_timestamp_present 0x80
    KERB_TIME timestamp;
#   define KERB_ENCRYPTED_PRIV_usec_present 0x40
    ASN1int32_t usec;
#   define KERB_ENCRYPTED_PRIV_sequence_number_present 0x20
    KERB_SEQUENCE_NUMBER sequence_number;
    KERB_HOST_ADDRESS sender_address;
#   define KERB_ENCRYPTED_PRIV_recipient_address_present 0x10
    KERB_HOST_ADDRESS recipient_address;
} KERB_ENCRYPTED_PRIV;
#define KERB_ENCRYPTED_PRIV_PDU 3
#define SIZE_KRB5_Module_PDU_3 sizeof(KERB_ENCRYPTED_PRIV)

typedef struct KERB_ENCRYPTED_CRED {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PKERB_ENCRYPTED_CRED_ticket_info ticket_info;
#   define nonce_present 0x80
    ASN1int32_t nonce;
#   define KERB_ENCRYPTED_CRED_timestamp_present 0x40
    KERB_TIME timestamp;
#   define KERB_ENCRYPTED_CRED_usec_present 0x20
    ASN1int32_t usec;
#   define sender_address_present 0x10
    KERB_HOST_ADDRESS sender_address;
#   define KERB_ENCRYPTED_CRED_recipient_address_present 0x8
    KERB_HOST_ADDRESS recipient_address;
} KERB_ENCRYPTED_CRED;
#define KERB_ENCRYPTED_CRED_PDU 4
#define SIZE_KRB5_Module_PDU_4 sizeof(KERB_ENCRYPTED_CRED)

typedef struct KERB_ERROR {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    ASN1int32_t message_type;
#   define client_time_present 0x80
    KERB_TIME client_time;
#   define client_usec_present 0x40
    ASN1int32_t client_usec;
    KERB_TIME server_time;
    ASN1int32_t server_usec;
    ASN1int32_t error_code;
#   define client_realm_present 0x20
    KERB_REALM client_realm;
#   define KERB_ERROR_client_name_present 0x10
    KERB_PRINCIPAL_NAME client_name;
    KERB_REALM realm;
    KERB_PRINCIPAL_NAME server_name;
#   define error_text_present 0x8
    ASN1charstring_t error_text;
#   define error_data_present 0x4
    ASN1octetstring_t error_data;
} KERB_ERROR;
#define KERB_ERROR_PDU 5
#define SIZE_KRB5_Module_PDU_5 sizeof(KERB_ERROR)

typedef struct KERB_ENCRYPTED_DATA {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t encryption_type;
#   define version_present 0x80
    ASN1int32_t version;
    ASN1octetstring_t cipher_text;
} KERB_ENCRYPTED_DATA;
#define KERB_ENCRYPTED_DATA_PDU 6
#define SIZE_KRB5_Module_PDU_6 sizeof(KERB_ENCRYPTED_DATA)

typedef struct KERB_ENCRYPTION_KEY {
    ASN1int32_t keytype;
    ASN1octetstring_t keyvalue;
} KERB_ENCRYPTION_KEY;
#define KERB_ENCRYPTION_KEY_PDU 7
#define SIZE_KRB5_Module_PDU_7 sizeof(KERB_ENCRYPTION_KEY)

typedef struct KERB_CHECKSUM {
    ASN1int32_t checksum_type;
    ASN1octetstring_t checksum;
} KERB_CHECKSUM;
#define KERB_CHECKSUM_PDU 8
#define SIZE_KRB5_Module_PDU_8 sizeof(KERB_CHECKSUM)

typedef struct KERB_ENCRYPTED_TIMESTAMP {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_TIME timestamp;
#   define KERB_ENCRYPTED_TIMESTAMP_usec_present 0x80
    ASN1int32_t usec;
} KERB_ENCRYPTED_TIMESTAMP;
#define KERB_ENCRYPTED_TIMESTAMP_PDU 9
#define SIZE_KRB5_Module_PDU_9 sizeof(KERB_ENCRYPTED_TIMESTAMP)

typedef struct KERB_SALTED_ENCRYPTED_TIMESTAMP {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_TIME timestamp;
#   define KERB_SALTED_ENCRYPTED_TIMESTAMP_usec_present 0x80
    ASN1int32_t usec;
    ASN1octetstring_t salt;
} KERB_SALTED_ENCRYPTED_TIMESTAMP;
#define KERB_SALTED_ENCRYPTED_TIMESTAMP_PDU 10
#define SIZE_KRB5_Module_PDU_10 sizeof(KERB_SALTED_ENCRYPTED_TIMESTAMP)

typedef struct KERB_ETYPE_INFO_ENTRY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t encryption_type;
#   define salt_present 0x80
    ASN1octetstring_t salt;
} KERB_ETYPE_INFO_ENTRY;

typedef struct PKERB_ETYPE_INFO_s {
    PPKERB_ETYPE_INFO next;
    KERB_ETYPE_INFO_ENTRY value;
} PKERB_ETYPE_INFO_Element, *PKERB_ETYPE_INFO;
#define PKERB_ETYPE_INFO_PDU 11
#define SIZE_KRB5_Module_PDU_11 sizeof(PKERB_ETYPE_INFO_Element)

typedef struct KERB_TGT_REQUEST {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    ASN1int32_t message_type;
#   define KERB_TGT_REQUEST_server_name_present 0x80
    KERB_PRINCIPAL_NAME server_name;
#   define server_realm_present 0x40
    KERB_REALM server_realm;
} KERB_TGT_REQUEST;
#define KERB_TGT_REQUEST_PDU 12
#define SIZE_KRB5_Module_PDU_12 sizeof(KERB_TGT_REQUEST)

typedef struct KERB_PKCS_SIGNATURE {
    ASN1int32_t encryption_type;
    ASN1octetstring_t signature;
} KERB_PKCS_SIGNATURE;
#define KERB_PKCS_SIGNATURE_PDU 13
#define SIZE_KRB5_Module_PDU_13 sizeof(KERB_PKCS_SIGNATURE)

typedef struct KERB_ALGORITHM_IDENTIFIER {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1objectidentifier_t algorithm;
#   define parameters_present 0x80
    NOCOPYANY parameters;
} KERB_ALGORITHM_IDENTIFIER;

typedef struct KERB_SIGNATURE {
    KERB_ALGORITHM_IDENTIFIER signature_algorithm;
    ASN1bitstring_t pkcs_signature;
} KERB_SIGNATURE;

typedef struct KERB_PA_PK_AS_REP {
    ASN1choice_t choice;
    union {
#	define dh_signed_data_chosen 1
	ASN1octetstring_t dh_signed_data;
#	define key_package_chosen 2
	ASN1octetstring_t key_package;
    } u;
} KERB_PA_PK_AS_REP;
#define KERB_PA_PK_AS_REP_PDU 14
#define SIZE_KRB5_Module_PDU_14 sizeof(KERB_PA_PK_AS_REP)

typedef struct KERB_ENVELOPED_KEY_PACKAGE {
    ASN1choice_t choice;
    union {
#	define encrypted_data_chosen 1
	KERB_ENCRYPTED_DATA encrypted_data;
#	define pkinit_enveloped_data_chosen 2
	ASN1octetstring_t pkinit_enveloped_data;
    } u;
} KERB_ENVELOPED_KEY_PACKAGE;

typedef struct KERB_REPLY_KEY_PACKAGE2 {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_ENCRYPTION_KEY reply_key;
    ASN1int32_t nonce;
#   define subject_public_key_present 0x80
    ASN1bitstring_t subject_public_key;
} KERB_REPLY_KEY_PACKAGE2;
#define KERB_REPLY_KEY_PACKAGE2_PDU 15
#define SIZE_KRB5_Module_PDU_15 sizeof(KERB_REPLY_KEY_PACKAGE2)

typedef struct KERB_REPLY_KEY_PACKAGE {
    KERB_ENCRYPTION_KEY reply_key;
    ASN1int32_t nonce;
} KERB_REPLY_KEY_PACKAGE;
#define KERB_REPLY_KEY_PACKAGE_PDU 16
#define SIZE_KRB5_Module_PDU_16 sizeof(KERB_REPLY_KEY_PACKAGE)

typedef struct KERB_KDC_DH_KEY_INFO {
    ASN1int32_t nonce;
    ASN1bitstring_t subject_public_key;
} KERB_KDC_DH_KEY_INFO;
#define KERB_KDC_DH_KEY_INFO_PDU 17
#define SIZE_KRB5_Module_PDU_17 sizeof(KERB_KDC_DH_KEY_INFO)

typedef struct KERB_PA_PK_AS_REQ {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1octetstring_t signed_auth_pack;
#   define KERB_PA_PK_AS_REQ_trusted_certifiers_present 0x80
    PKERB_PA_PK_AS_REQ_trusted_certifiers trusted_certifiers;
#   define KERB_PA_PK_AS_REQ_kdc_cert_present 0x40
    ASN1octetstring_t kdc_cert;
#   define encryption_cert_present 0x20
    ASN1octetstring_t encryption_cert;
} KERB_PA_PK_AS_REQ;
#define KERB_PA_PK_AS_REQ_PDU 18
#define SIZE_KRB5_Module_PDU_18 sizeof(KERB_PA_PK_AS_REQ)

typedef struct KERB_KERBEROS_NAME {
    KERB_REALM realm;
    KERB_PRINCIPAL_NAME principal_name;
} KERB_KERBEROS_NAME;

typedef struct KERB_PK_AUTHENTICATOR {
    KERB_PRINCIPAL_NAME kdc_name;
    KERB_REALM kdc_realm;
    ASN1int32_t cusec;
    KERB_TIME client_time;
    ASN1int32_t nonce;
} KERB_PK_AUTHENTICATOR;

typedef struct KERB_SUBJECT_PUBLIC_KEY_INFO {
    KERB_ALGORITHM_IDENTIFIER algorithm;
    ASN1bitstring_t subjectPublicKey;
} KERB_SUBJECT_PUBLIC_KEY_INFO;

typedef struct KERB_DH_PARAMTER {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t prime;
    ASN1int32_t base;
#   define private_value_length_present 0x80
    ASN1int32_t private_value_length;
} KERB_DH_PARAMTER;
#define KERB_DH_PARAMTER_PDU 19
#define SIZE_KRB5_Module_PDU_19 sizeof(KERB_DH_PARAMTER)

typedef struct KERB_CERTIFICATE {
    ASN1int32_t cert_type;
    ASN1octetstring_t cert_data;
} KERB_CERTIFICATE;

typedef struct KERB_TYPED_DATA {
    ASN1int32_t data_type;
    ASN1octetstring_t data_value;
} KERB_TYPED_DATA;
#define KERB_TYPED_DATA_PDU 20
#define SIZE_KRB5_Module_PDU_20 sizeof(KERB_TYPED_DATA)

typedef struct KERB_KDC_ISSUED_AUTH_DATA {
    KERB_SIGNATURE checksum;
    PKERB_KDC_ISSUED_AUTH_DATA_elements elements;
} KERB_KDC_ISSUED_AUTH_DATA;
#define KERB_KDC_ISSUED_AUTH_DATA_PDU 21
#define SIZE_KRB5_Module_PDU_21 sizeof(KERB_KDC_ISSUED_AUTH_DATA)

typedef struct KERB_PA_SERV_REFERRAL {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define referred_server_name_present 0x80
    KERB_PRINCIPAL_NAME referred_server_name;
    KERB_REALM referred_server_realm;
} KERB_PA_SERV_REFERRAL;
#define KERB_PA_SERV_REFERRAL_PDU 22
#define SIZE_KRB5_Module_PDU_22 sizeof(KERB_PA_SERV_REFERRAL)

typedef struct KERB_PA_PAC_REQUEST {
    ASN1bool_t include_pac;
} KERB_PA_PAC_REQUEST;
#define KERB_PA_PAC_REQUEST_PDU 23
#define SIZE_KRB5_Module_PDU_23 sizeof(KERB_PA_PAC_REQUEST)

typedef struct KERB_CHANGE_PASSWORD_DATA {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1octetstring_t new_password;
#   define target_name_present 0x80
    KERB_PRINCIPAL_NAME target_name;
#   define target_realm_present 0x40
    KERB_REALM target_realm;
} KERB_CHANGE_PASSWORD_DATA;
#define KERB_CHANGE_PASSWORD_DATA_PDU 24
#define SIZE_KRB5_Module_PDU_24 sizeof(KERB_CHANGE_PASSWORD_DATA)

typedef struct KERB_ERROR_METHOD_DATA {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t data_type;
#   define data_value_present 0x80
    ASN1octetstring_t data_value;
} KERB_ERROR_METHOD_DATA;
#define KERB_ERROR_METHOD_DATA_PDU 25
#define SIZE_KRB5_Module_PDU_25 sizeof(KERB_ERROR_METHOD_DATA)

typedef struct KERB_EXT_ERROR {
    ASN1int32_t status;
    ASN1int32_t klininfo;
    ASN1int32_t flags;
} KERB_EXT_ERROR;
#define KERB_EXT_ERROR_PDU 26
#define SIZE_KRB5_Module_PDU_26 sizeof(KERB_EXT_ERROR)

typedef struct KERB_PA_FOR_USER {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_PRINCIPAL_NAME userName;
    KERB_REALM userRealm;
    KERB_CHECKSUM cksum;
    ASN1ztcharstring_t authentication_package;
#   define KERB_PA_FOR_USER_authorization_data_present 0x80
    ASN1octetstring_t authorization_data;
} KERB_PA_FOR_USER;
#define KERB_PA_FOR_USER_PDU 27
#define SIZE_KRB5_Module_PDU_27 sizeof(KERB_PA_FOR_USER)

typedef struct KERB_PA_PAC_REQUEST_EX {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t include_pac;
#   define pac_sections_present 0x80
    PKERB_PA_PAC_REQUEST_EX_pac_sections pac_sections;
} KERB_PA_PAC_REQUEST_EX;
#define KERB_PA_PAC_REQUEST_EX_PDU 28
#define SIZE_KRB5_Module_PDU_28 sizeof(KERB_PA_PAC_REQUEST_EX)

typedef struct KERB_KDC_ISSUED_AUTH_DATA_elements_s {
    PKERB_KDC_ISSUED_AUTH_DATA_elements next;
    KERB_PA_DATA value;
} KERB_KDC_ISSUED_AUTH_DATA_elements_Element, *KERB_KDC_ISSUED_AUTH_DATA_elements;

typedef struct KERB_PA_PK_AS_REQ2_trusted_certifiers_s {
    PKERB_PA_PK_AS_REQ2_trusted_certifiers next;
    KERB_PRINCIPAL_NAME value;
} KERB_PA_PK_AS_REQ2_trusted_certifiers_Element, *KERB_PA_PK_AS_REQ2_trusted_certifiers;

typedef struct KERB_PA_PK_AS_REQ2_user_certs_s {
    PKERB_PA_PK_AS_REQ2_user_certs next;
    KERB_CERTIFICATE value;
} KERB_PA_PK_AS_REQ2_user_certs_Element, *KERB_PA_PK_AS_REQ2_user_certs;

typedef struct KERB_PA_PK_AS_REP2_kdc_cert_s {
    PKERB_PA_PK_AS_REP2_kdc_cert next;
    KERB_CERTIFICATE value;
} KERB_PA_PK_AS_REP2_kdc_cert_Element, *KERB_PA_PK_AS_REP2_kdc_cert;

typedef struct KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data_s {
    PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data next;
    KERB_PA_DATA value;
} KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data_Element, *KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data;

typedef struct KERB_KDC_REPLY_preauth_data_s {
    PKERB_KDC_REPLY_preauth_data next;
    KERB_PA_DATA value;
} KERB_KDC_REPLY_preauth_data_Element, *KERB_KDC_REPLY_preauth_data;

typedef struct KERB_KDC_REQUEST_preauth_data_s {
    PKERB_KDC_REQUEST_preauth_data next;
    KERB_PA_DATA value;
} KERB_KDC_REQUEST_preauth_data_Element, *KERB_KDC_REQUEST_preauth_data;

typedef struct KERB_TICKET {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t ticket_version;
    KERB_REALM realm;
    KERB_PRINCIPAL_NAME server_name;
    KERB_ENCRYPTED_DATA encrypted_part;
#   define ticket_extensions_present 0x80
    PPKERB_TICKET_EXTENSIONS ticket_extensions;
} KERB_TICKET;
#define KERB_TICKET_PDU 29
#define SIZE_KRB5_Module_PDU_29 sizeof(KERB_TICKET)

typedef struct KERB_ENCRYPTED_TICKET {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_TICKET_FLAGS flags;
    KERB_ENCRYPTION_KEY key;
    KERB_REALM client_realm;
    KERB_PRINCIPAL_NAME client_name;
    KERB_TRANSITED_ENCODING transited;
    KERB_TIME authtime;
#   define KERB_ENCRYPTED_TICKET_starttime_present 0x80
    KERB_TIME starttime;
    KERB_TIME endtime;
#   define KERB_ENCRYPTED_TICKET_renew_until_present 0x40
    KERB_TIME renew_until;
#   define KERB_ENCRYPTED_TICKET_client_addresses_present 0x20
    PPKERB_HOST_ADDRESSES client_addresses;
#   define KERB_ENCRYPTED_TICKET_authorization_data_present 0x10
    PPKERB_AUTHORIZATION_DATA authorization_data;
} KERB_ENCRYPTED_TICKET;
#define KERB_ENCRYPTED_TICKET_PDU 30
#define SIZE_KRB5_Module_PDU_30 sizeof(KERB_ENCRYPTED_TICKET)

typedef struct KERB_AUTHENTICATOR {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t authenticator_version;
    KERB_REALM client_realm;
    KERB_PRINCIPAL_NAME client_name;
#   define checksum_present 0x80
    KERB_CHECKSUM checksum;
    ASN1int32_t client_usec;
    KERB_TIME client_time;
#   define KERB_AUTHENTICATOR_subkey_present 0x40
    KERB_ENCRYPTION_KEY subkey;
#   define KERB_AUTHENTICATOR_sequence_number_present 0x20
    //KERB_SEQUENCE_NUMBER_LARGE sequence_number;
    KERB_SEQUENCE_NUMBER sequence_number;
#   define KERB_AUTHENTICATOR_authorization_data_present 0x10
    PPKERB_AUTHORIZATION_DATA authorization_data;
} KERB_AUTHENTICATOR;
#define KERB_AUTHENTICATOR_PDU 31
#define SIZE_KRB5_Module_PDU_31 sizeof(KERB_AUTHENTICATOR)

typedef struct KERB_KDC_REQUEST_BODY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_KDC_OPTIONS kdc_options;
#   define KERB_KDC_REQUEST_BODY_client_name_present 0x80
    KERB_PRINCIPAL_NAME client_name;
    KERB_REALM realm;
#   define KERB_KDC_REQUEST_BODY_server_name_present 0x40
    KERB_PRINCIPAL_NAME server_name;
#   define KERB_KDC_REQUEST_BODY_starttime_present 0x20
    KERB_TIME starttime;
    KERB_TIME endtime;
#   define KERB_KDC_REQUEST_BODY_renew_until_present 0x10
    KERB_TIME renew_until;
    ASN1int32_t nonce;
    PKERB_KDC_REQUEST_BODY_encryption_type encryption_type;
#   define addresses_present 0x8
    PPKERB_HOST_ADDRESSES addresses;
#   define enc_authorization_data_present 0x4
    KERB_ENCRYPTED_DATA enc_authorization_data;
#   define additional_tickets_present 0x2
    PKERB_KDC_REQUEST_BODY_additional_tickets additional_tickets;
} KERB_KDC_REQUEST_BODY;

typedef struct KERB_KDC_REPLY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    ASN1int32_t message_type;
#   define KERB_KDC_REPLY_preauth_data_present 0x80
    PKERB_KDC_REPLY_preauth_data preauth_data;
    KERB_REALM client_realm;
    KERB_PRINCIPAL_NAME client_name;
    KERB_TICKET ticket;
    KERB_ENCRYPTED_DATA encrypted_part;
} KERB_KDC_REPLY;

typedef struct KERB_ENCRYPTED_KDC_REPLY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_ENCRYPTION_KEY session_key;
    PPKERB_LAST_REQUEST last_request;
    ASN1int32_t nonce;
#   define key_expiration_present 0x80
    KERB_TIME key_expiration;
    KERB_TICKET_FLAGS flags;
    KERB_TIME authtime;
#   define KERB_ENCRYPTED_KDC_REPLY_starttime_present 0x40
    KERB_TIME starttime;
    KERB_TIME endtime;
#   define KERB_ENCRYPTED_KDC_REPLY_renew_until_present 0x20
    KERB_TIME renew_until;
    KERB_REALM server_realm;
    KERB_PRINCIPAL_NAME server_name;
#   define KERB_ENCRYPTED_KDC_REPLY_client_addresses_present 0x10
    PPKERB_HOST_ADDRESSES client_addresses;
#   define encrypted_pa_data_present 0x8
    PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data encrypted_pa_data;
} KERB_ENCRYPTED_KDC_REPLY;

typedef struct KERB_AP_REQUEST {
    ASN1int32_t version;
    ASN1int32_t message_type;
    KERB_AP_OPTIONS ap_options;
    KERB_TICKET ticket;
    KERB_ENCRYPTED_DATA authenticator;
} KERB_AP_REQUEST;
#define KERB_AP_REQUEST_PDU 32
#define SIZE_KRB5_Module_PDU_32 sizeof(KERB_AP_REQUEST)

typedef struct KERB_AP_REPLY {
    ASN1int32_t version;
    ASN1int32_t message_type;
    KERB_ENCRYPTED_DATA encrypted_part;
} KERB_AP_REPLY;
#define KERB_AP_REPLY_PDU 33
#define SIZE_KRB5_Module_PDU_33 sizeof(KERB_AP_REPLY)

typedef struct KERB_ENCRYPTED_AP_REPLY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_TIME client_time;
    ASN1int32_t client_usec;
#   define KERB_ENCRYPTED_AP_REPLY_subkey_present 0x80
    KERB_ENCRYPTION_KEY subkey;
#   define KERB_ENCRYPTED_AP_REPLY_sequence_number_present 0x40
    KERB_SEQUENCE_NUMBER sequence_number;
} KERB_ENCRYPTED_AP_REPLY;
#define KERB_ENCRYPTED_AP_REPLY_PDU 34
#define SIZE_KRB5_Module_PDU_34 sizeof(KERB_ENCRYPTED_AP_REPLY)

typedef struct KERB_SAFE_MESSAGE {
    ASN1int32_t version;
    ASN1int32_t message_type;
    KERB_SAFE_BODY safe_body;
    KERB_CHECKSUM checksum;
} KERB_SAFE_MESSAGE;
#define KERB_SAFE_MESSAGE_PDU 35
#define SIZE_KRB5_Module_PDU_35 sizeof(KERB_SAFE_MESSAGE)

typedef struct KERB_PRIV_MESSAGE {
    ASN1int32_t version;
    ASN1int32_t message_type;
    KERB_ENCRYPTED_DATA encrypted_part;
} KERB_PRIV_MESSAGE;
#define KERB_PRIV_MESSAGE_PDU 36
#define SIZE_KRB5_Module_PDU_36 sizeof(KERB_PRIV_MESSAGE)

typedef struct KERB_CRED {
    ASN1int32_t version;
    ASN1int32_t message_type;
    PKERB_CRED_tickets tickets;
    KERB_ENCRYPTED_DATA encrypted_part;
} KERB_CRED;
#define KERB_CRED_PDU 37
#define SIZE_KRB5_Module_PDU_37 sizeof(KERB_CRED)

typedef struct KERB_CRED_INFO {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    KERB_ENCRYPTION_KEY key;
#   define principal_realm_present 0x80
    KERB_REALM principal_realm;
#   define principal_name_present 0x40
    KERB_PRINCIPAL_NAME principal_name;
#   define flags_present 0x20
    KERB_TICKET_FLAGS flags;
#   define authtime_present 0x10
    KERB_TIME authtime;
#   define KERB_CRED_INFO_starttime_present 0x8
    KERB_TIME starttime;
#   define endtime_present 0x4
    KERB_TIME endtime;
#   define KERB_CRED_INFO_renew_until_present 0x2
    KERB_TIME renew_until;
#   define service_realm_present 0x1
    KERB_REALM service_realm;
#   define service_name_present 0x8000
    KERB_PRINCIPAL_NAME service_name;
#   define KERB_CRED_INFO_client_addresses_present 0x4000
    PPKERB_HOST_ADDRESSES client_addresses;
} KERB_CRED_INFO;

typedef struct KERB_TGT_REPLY {
    ASN1int32_t version;
    ASN1int32_t message_type;
    KERB_TICKET ticket;
} KERB_TGT_REPLY;
#define KERB_TGT_REPLY_PDU 38
#define SIZE_KRB5_Module_PDU_38 sizeof(KERB_TGT_REPLY)

typedef struct KERB_SIGNED_REPLY_KEY_PACKAGE {
    KERB_REPLY_KEY_PACKAGE2 reply_key_package;
    KERB_SIGNATURE reply_key_signature;
} KERB_SIGNED_REPLY_KEY_PACKAGE;
#define KERB_SIGNED_REPLY_KEY_PACKAGE_PDU 39
#define SIZE_KRB5_Module_PDU_39 sizeof(KERB_SIGNED_REPLY_KEY_PACKAGE)

typedef struct KERB_SIGNED_KDC_PUBLIC_VALUE {
    KERB_SUBJECT_PUBLIC_KEY_INFO kdc_public_value;
    KERB_SIGNATURE kdc_public_value_sig;
} KERB_SIGNED_KDC_PUBLIC_VALUE;

typedef struct KERB_TRUSTED_CAS {
    ASN1choice_t choice;
    union {
#	define principal_name_chosen 1
	KERB_KERBEROS_NAME principal_name;
#	define ca_name_chosen 2
	ASN1octetstring_t ca_name;
#	define issuer_and_serial_chosen 3
	ASN1octetstring_t issuer_and_serial;
    } u;
} KERB_TRUSTED_CAS;

typedef struct KERB_AUTH_PACKAGE {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_PK_AUTHENTICATOR pk_authenticator;
#   define client_public_value_present 0x80
    KERB_SUBJECT_PUBLIC_KEY_INFO client_public_value;
} KERB_AUTH_PACKAGE;
#define KERB_AUTH_PACKAGE_PDU 40
#define SIZE_KRB5_Module_PDU_40 sizeof(KERB_AUTH_PACKAGE)

typedef struct KERB_PA_COMPOUND_IDENTITY_s {
    PKERB_PA_COMPOUND_IDENTITY next;
    KERB_TICKET value;
} KERB_PA_COMPOUND_IDENTITY_Element, *KERB_PA_COMPOUND_IDENTITY;
#define KERB_PA_COMPOUND_IDENTITY_PDU 41
#define SIZE_KRB5_Module_PDU_41 sizeof(KERB_PA_COMPOUND_IDENTITY_Element)

typedef struct KERB_PA_PK_AS_REQ_trusted_certifiers_s {
    PKERB_PA_PK_AS_REQ_trusted_certifiers next;
    KERB_TRUSTED_CAS value;
} KERB_PA_PK_AS_REQ_trusted_certifiers_Element, *KERB_PA_PK_AS_REQ_trusted_certifiers;

typedef struct KERB_ENCRYPTED_CRED_ticket_info_s {
    PKERB_ENCRYPTED_CRED_ticket_info next;
    KERB_CRED_INFO value;
} KERB_ENCRYPTED_CRED_ticket_info_Element, *KERB_ENCRYPTED_CRED_ticket_info;

typedef struct KERB_CRED_tickets_s {
    PKERB_CRED_tickets next;
    KERB_TICKET value;
} KERB_CRED_tickets_Element, *KERB_CRED_tickets;

typedef struct KERB_KDC_REQUEST_BODY_additional_tickets_s {
    PKERB_KDC_REQUEST_BODY_additional_tickets next;
    KERB_TICKET value;
} KERB_KDC_REQUEST_BODY_additional_tickets_Element, *KERB_KDC_REQUEST_BODY_additional_tickets;

typedef struct KERB_KDC_REQUEST {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    ASN1int32_t message_type;
#   define KERB_KDC_REQUEST_preauth_data_present 0x80
    PKERB_KDC_REQUEST_preauth_data preauth_data;
    KERB_KDC_REQUEST_BODY request_body;
} KERB_KDC_REQUEST;

typedef KERB_KDC_REQUEST_BODY KERB_MARSHALLED_REQUEST_BODY;
#define KERB_MARSHALLED_REQUEST_BODY_PDU 42
#define SIZE_KRB5_Module_PDU_42 sizeof(KERB_MARSHALLED_REQUEST_BODY)

typedef KERB_KDC_REPLY KERB_AS_REPLY;
#define KERB_AS_REPLY_PDU 43
#define SIZE_KRB5_Module_PDU_43 sizeof(KERB_AS_REPLY)

typedef KERB_KDC_REPLY KERB_TGS_REPLY;
#define KERB_TGS_REPLY_PDU 44
#define SIZE_KRB5_Module_PDU_44 sizeof(KERB_TGS_REPLY)

typedef KERB_ENCRYPTED_KDC_REPLY KERB_ENCRYPTED_AS_REPLY;
#define KERB_ENCRYPTED_AS_REPLY_PDU 45
#define SIZE_KRB5_Module_PDU_45 sizeof(KERB_ENCRYPTED_AS_REPLY)

typedef KERB_ENCRYPTED_KDC_REPLY KERB_ENCRYPTED_TGS_REPLY;
#define KERB_ENCRYPTED_TGS_REPLY_PDU 46
#define SIZE_KRB5_Module_PDU_46 sizeof(KERB_ENCRYPTED_TGS_REPLY)

typedef struct KERB_PA_PK_AS_REP2 {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define key_package_present 0x80
    KERB_ENCRYPTED_DATA key_package;
    KERB_ENVELOPED_KEY_PACKAGE temp_key_package;
#   define signed_kdc_public_value_present 0x40
    KERB_SIGNED_KDC_PUBLIC_VALUE signed_kdc_public_value;
#   define KERB_PA_PK_AS_REP2_kdc_cert_present 0x20
    PKERB_PA_PK_AS_REP2_kdc_cert kdc_cert;
} KERB_PA_PK_AS_REP2;
#define KERB_PA_PK_AS_REP2_PDU 47
#define SIZE_KRB5_Module_PDU_47 sizeof(KERB_PA_PK_AS_REP2)

typedef struct KERB_SIGNED_AUTH_PACKAGE {
    KERB_AUTH_PACKAGE auth_package;
    KERB_SIGNATURE auth_package_signature;
} KERB_SIGNED_AUTH_PACKAGE;

typedef KERB_KDC_REQUEST KERB_AS_REQUEST;
#define KERB_AS_REQUEST_PDU 48
#define SIZE_KRB5_Module_PDU_48 sizeof(KERB_AS_REQUEST)

typedef KERB_KDC_REQUEST KERB_TGS_REQUEST;
#define KERB_TGS_REQUEST_PDU 49
#define SIZE_KRB5_Module_PDU_49 sizeof(KERB_TGS_REQUEST)

typedef struct KERB_PA_PK_AS_REQ2 {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_SIGNED_AUTH_PACKAGE signed_auth_pack;
#   define user_certs_present 0x80
    PKERB_PA_PK_AS_REQ2_user_certs user_certs;
#   define KERB_PA_PK_AS_REQ2_trusted_certifiers_present 0x40
    PKERB_PA_PK_AS_REQ2_trusted_certifiers trusted_certifiers;
#   define serial_number_present 0x20
    KERB_CERTIFICATE_SERIAL_NUMBER serial_number;
} KERB_PA_PK_AS_REQ2;
#define KERB_PA_PK_AS_REQ2_PDU 50
#define SIZE_KRB5_Module_PDU_50 sizeof(KERB_PA_PK_AS_REQ2)


extern void ASN1CALL KRB5_Module_Startup(ASN1module_t pASN1Module);
extern void ASN1CALL KRB5_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */

#endif /* _KRB5_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\localcache.cpp ===
//-----------------------------------------------------------------------------
// File: LocalCache.cpp
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "xonp.h"
#include "xonver.h"

//----------------------------------------------------------------------------
//
// Constants & typedefs
//
//----------------------------------------------------------------------------

typedef enum
{
    XONLC_PARAMS_MAX_CACHED_ITEMS = 0,
    XONLC_PARAMS_MRU_LIST_SIZE,
    XONLC_PARAMS_INDEX_DATA_SIZE,
    XONLC_PARAMS_KEY_DATA_SIZE,
    XONLC_PARAMS_CACHED_DATA_SIZE,
    XONLC_MAX_PARAMS
} XONLC_PARAMS;

//
// Define the cache ops
//
typedef enum
{
    XONLC_OPS_OPEN = 0,
    XONLC_OPS_UPDATE,
	XONLC_OPS_FLUSH,
    XONLC_OPS_RETRIEVE,
    XONLC_OPS_RESET,
    XONLC_OPS_CLOSE,
    XONLC_OPS_UPDATE_RECORD,
    XONLC_OPS_UPDATE_INDEX,
    XONLC_OPS_UPDATE_MRU_LIST,
    XONLC_OPS_MAX_OPS
} XONLC_OPS;

//
// Define the task states
//
typedef enum
{
    XONLC_STATE_INITIALIZE = 0,
    XONLC_STATE_DONE,
    XONLC_STATE_READ,
    XONLC_STATE_WRITE,
    XONLC_STATE_RETRIEVE,
    XONLC_STATE_CONT_RETRIEVE,
    XONLC_STATE_UPDATE_MRU,
    XONLC_STATE_UPDATE_INDEX,
    XONLC_STATE_UPDATE_RECORD,
    XONLC_STATE_RESET
} XONLC_STATE;

class   CCacheTask;
typedef CCacheTask XONLINETASK_CACHE;
typedef CCacheTask* PXONLINETASK_CACHE;

//
// Miscelaneous
//

#define XONLC_SIGNATURE_SIZE        12
#define XONLC_UTIL_SECTOR_SIZE      (XBOX_HD_SECTOR_SIZE - XONLC_SIGNATURE_SIZE)
#define AVAILABLE                   '*'
#define XONLC_MAX_BUFFERS           4   // Number of sectors allocated for the buffer 
#define XONLC_UNLIMITED_BUFFERS     0xFFFFFFFF
#define GET_INDEX_DATA              TRUE
#define DONT_GET_INDEX_DATA         FALSE
#define WRITE_LAST_CHECK_BYTE       TRUE
#define DONT_WRITE_LAST_CHECK_BYTE  FALSE

typedef DWORD TIMESTAMP;
typedef BYTE  CHECKINFO;
typedef DWORD INDEXPOS;

//----------------------------------------------------------------------------
//
// The parameters that define the size of the cache
//
//----------------------------------------------------------------------------

const WORD g_xonCacheParams[XONLC_MAX_CACHE_TYPES][XONLC_MAX_PARAMS] = {
    { 20  , 1   , sizeof(XONLINE_RECENT_LOGON_TIME)    , FIELD_OFFSET(XONLINE_RECENT_LOGON_TIME, lastLogon)   , 0     },  // XONLC_TYPE_RECENT_LOGON_TIME
    { 40  , 1   , FIELD_OFFSET(XKERB_TGT_CONTEXT, ctNumNonces) , FIELD_OFFSET(XKERB_TGT_CONTEXT, StartTime) , sizeof(XKERB_TGT_CONTEXT) - FIELD_OFFSET(XKERB_TGT_CONTEXT, ClientName) },  // XONLC_TYPE_COMBINED_USER_TICKETS
    { 40  , 1   , FIELD_OFFSET(XKERB_SERVICE_CONTEXT, ctNumNonces) , FIELD_OFFSET(XKERB_SERVICE_CONTEXT, StartTime) , sizeof(XKERB_SERVICE_CONTEXT) - FIELD_OFFSET(XKERB_SERVICE_CONTEXT, siteIPAddress) },  // XONLC_TYPE_SERVICE_TICKETS
    { 10  , 0   , 16    , 8   , 14000 },  // XONLC_TYPE_BUDDY_LIST
    { 10  , 0   , 16    , 8   , 800   },  // XONLC_TYPE_MUTE_LIST
    { 500 , 1   , 8     , 8   , 28    },  // XONLC_TYPE_LICENSING
    { 2   , 0   , 8     , 8   , 2000  },  // XONLC_TYPE_BILLING
    { 20  , 1   , 4     , 4   , 32    },  // XONLC_TYPE_TITLEDATA
    { 1   , 0   , 120   , 1   , 0     },  // XONLC_TYPE_GAMEINVITE
    { 20  , 1   , 41    , 8   , 0     },  // XONLC_TYPE_TEST1
    { 15  , 0   , 52    , 8   , 10000 }  // XONLC_TYPE_TEST2
};

//----------------------------------------------------------------------------
//
// Cache structure
//
// HEADER
// Max cached items | MRU List size | Index data size | Key data size | Cached data size | Timestamp Increment (LRU)|
// MRU LIST
// Check byte | Index Data for MRU1 | Cached Data for MRU1 | Check byte |
// INDEX
// Check byte for cached data | Timestamp | Index Data - key | Index Data - immediate data |  ...
// CACHED DATA
// Check byte | Rec #1 | Check byte | ...
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
// Class CHeader - describes the structure of the header in the cache file
//
//----------------------------------------------------------------------------
class CHeader
{
public:
    DWORD          dwMaxCachedItems;
    DWORD          dwMRUListSize;
    DWORD          cbIndexDataSize;
    DWORD          cbKeyDataSize;
    DWORD          cbCachedDataSize;
    TIMESTAMP      dwTimestampIncrement;
}; 

//----------------------------------------------------------------------------
//
// CAddress - used to navigate through the cache file
//
//----------------------------------------------------------------------------
class CAddress
{
public:
    DWORD           dwPosition;            // Position in index of the item described by the address
    DWORD           dwSize;                // Size of the item described by the address
    DWORD           dwSectorBegin;         // Sector where the item starts
    DWORD           dwOffsetBegin;         // Offset in the first sector of the item - relative to the UTIL sector space
    DWORD           dwSectorEnd;           // Sector where the item ends
    DWORD           dwOffsetEnd;           // Offset in the last sector of the item - relative to the UTIL sector space


    //
    // Constructors
    //
    CAddress();
    CAddress(const CAddress&);

    CAddress& operator=(const CAddress&);

    //
    // Increments an address
    //
    VOID IncrementAddress(DWORD dwAmmount);

    //
    // Decrements an address
    //
    VOID DecrementAddress(DWORD dwAmmount);

    //
    // Creates a relative address within a buffer 
    //
    VOID MakeRelativeAddress();

    //
    // Gets the address after cutting the first dwSectors
    //
    VOID CutFirstSectors(DWORD dwSectors);

    //
    // Gets the address after cutting the last dwSectors
    //
    VOID CutLastSectors(DWORD dwSectors);

    //
    // Computes the address
    //
    INLINE VOID FillAddress(
            IN DWORD              dwItemBegin,
            IN DWORD              dwItemEnd,
            IN DWORD              dwPos
            )
    {
        dwSectorBegin = dwItemBegin / XONLC_UTIL_SECTOR_SIZE;
        dwOffsetBegin = dwItemBegin % XONLC_UTIL_SECTOR_SIZE;

        dwSectorEnd = dwItemEnd / XONLC_UTIL_SECTOR_SIZE;
        dwOffsetEnd = dwItemEnd % XONLC_UTIL_SECTOR_SIZE;

        dwPosition = dwPos;
        dwSize = dwItemEnd - dwItemBegin + 1;
    }

};

//----------------------------------------------------------------------------
//
// CSector - describes the structure of a sector on disk
//
//----------------------------------------------------------------------------
class CSector
{
public:
    BYTE                          pbUtilSectorSpace[XONLC_UTIL_SECTOR_SIZE];
    BYTE                          pbSignature[XONLC_SIGNATURE_SIZE];
}; 

//----------------------------------------------------------------------------
//
// CCacheTask - used in the async work pump for XOnline 
//
//----------------------------------------------------------------------------
class CCacheTask
{
    XONLINETASK_CONTEXT           m_xonTask;           // Core task structure 
    
    XONLC_OPS                     m_cacheOp;           // Cache operation performed by the task
    XONLC_CACHE_HANDLE            m_hCache;            // Handle to the cache
    XONLC_STATE                   m_state;             // State in operation

    XONLINETASK_HANDLE            m_hSubtask;          // Generic async subtask handle

    PXONLC_CONTEXT                m_pContext;          // Context used to pass input data to the task
    PBYTE                         m_pbIndexData;       // Input data to update tasks        
    PBYTE                         m_pbRecord;          // Input data to update tasks
    BOOL                          m_bWriteIndex;       // Write or not the index and MRU element to the disk

    HRESULT                       m_hr;                // HRESULT returned by the task

    CXo *                         m_pXo;               // Pointer to CXo that created this task

public:
    //
    // Function to initialize the task context
    //
    VOID InitializeContext( 
            IN XONLC_CACHE_HANDLE   hCache, 
            IN HANDLE               hWorkEvent,
            IN CXo *                pXo
            );

    //
    // Sets the current task's parameters
    //
    VOID SetCurrentTaskParams(
            IN XONLC_OPS            cacheOp,
            IN PBYTE                pbIndexData = NULL,
            IN PBYTE                pbRecord = NULL,
            IN PXONLC_CONTEXT       pContext = NULL,
            IN BOOL                 bWriteIndex = TRUE
            );

    //
    // Async cores for async APIs
    //
    HRESULT DoOpenCache();

    HRESULT DoUpdateCache();

	HRESULT DoIndexFlush();

    HRESULT DoRetrieve();

    HRESULT DoResetCache();

    HRESULT DoCloseCache();

    //
    // Async cores for async private functions
    //
    HRESULT DoUpdateRecordPriv();

    HRESULT DoUpdateIndexPriv();

    HRESULT DoUpdateMRUListPriv();

    //
    // Methods to start async jobs
    //
    HRESULT DoOpenCacheBegin();

    HRESULT DoUpdateCacheBegin();

	HRESULT DoIndexFlushBegin();

    HRESULT DoRetrieveBegin();

    HRESULT DoResetCacheBegin(); 

    HRESULT DoCloseCacheBegin();

    HRESULT DoUpdateRecordPrivBegin();

    HRESULT DoUpdateIndexPrivBegin();

    HRESULT DoUpdateMRUListPrivBegin();

    //
    // Get state
    //
    INLINE XONLC_OPS GetOp()
    {
        return(m_cacheOp);
    }

    //
    // Get HRESULT
    //
    INLINE HRESULT GetHR()
    {
        return (m_hr);
    }

    //
    // Forces the task to completion 
    //
    VOID ForceCompletion();


private:
    //
    // Checks if the size read/written is correct
    //
    HRESULT CheckReadWrite( IN DWORD dwExpectedSize );

    //
    // Starts async job for new chunk of record
    //
    HRESULT UpdateNewChunk(IN CAddress *pAddress );

    //
    // Checks if the retrieved sectors are valid
    //
    HRESULT CheckRetrievedSectors(BOOL bLastChunk);

    //
    // Finish async work when state is XONLC_STATE_DONE
    //
    VOID FinishAsyncWork();

    //
    // Finish async work when state is XONLC_STATE_DONE - used in the Priv async functions
    // Doesn't unlock the cache
    //
    VOID FinishAsyncWorkPriv();

};

//----------------------------------------------------------------------------
//
// CLocalCache - main class, implements the functionality of the local cache
//
//----------------------------------------------------------------------------
class CLocalCache
{
public:

    //
    // Initialize/Terminate cache
    //
    HRESULT Initialize(XONLC_TYPE type , PFNXONLC_COMPARE_HANDLER pfnCompare, HANDLE hWorkEvent, CXo * pXo);
    void    Delete();

    //
    // Open cache file on disk
    //
    HRESULT OpenCacheFile();

    //
    // Makes sure there is enough space on disk for a new created cache - initializes first block
    //
    HRESULT PrepareNewCache();

    //
    // Checks the parameters for the uploaded cache
    //
    BOOL IsCacheCorrupted();

    //
    // Locks the cache
    //
    INLINE VOID LockCache()
    {
        m_bCacheLock = TRUE;
    }

    //
    // Unlocks the cache
    //
    INLINE VOID UnlockCache()
    {
        m_bCacheLock = FALSE;
    }

    //
    // Checks if the cache is locked
    //
    INLINE BOOL IsCacheLocked()
    {
        return (m_bCacheLock);
    }

    //
    // Checks if the cache file has been opened
    //
    INLINE BOOL IsCacheFileOpen()
    {
        return (m_hCacheFile != INVALID_HANDLE_VALUE);
    }

    //
    // Starts the upload of the first block in memory - async
    //
    INLINE HRESULT StartFirstBlockUpload( IN XONLINETASK_HANDLE hTask)
    {
        ULARGE_INTEGER               uliOrigin;

        uliOrigin.QuadPart = 0;

        m_pXo->ReadWriteFileInitializeContext(
                            m_hCacheFile,
                            (LPBYTE)m_pbMemoryBlock,
                            m_dwMemoryBlockSectors * XBOX_HD_SECTOR_SIZE,
                            uliOrigin,
                            m_hWorkEvent, 
                            (PXONLINETASK_FILEIO)hTask);

        return (m_pXo->ReadFileInternal((PXONLINETASK_FILEIO)hTask));
    }

    //
    // Starts the download of the first block
    //
    INLINE HRESULT StartFirstBlockDownload(IN DWORD dwSectors , IN XONLINETASK_HANDLE hTask)
    {
        ULARGE_INTEGER               uliOrigin;

        uliOrigin.QuadPart = 0;

        PrepareSectorsForWrite(m_pbMemoryBlock, 0, dwSectors - 1);

        m_pXo->ReadWriteFileInitializeContext(
                            m_hCacheFile,
                            (LPBYTE)m_pbMemoryBlock,
                            dwSectors * sizeof(CSector),
                            uliOrigin,
                            m_hWorkEvent,  
                            (PXONLINETASK_FILEIO)hTask);

        return (m_pXo->WriteFileInternal((PXONLINETASK_FILEIO)hTask));
    }

    //
    // Gets first block size size
    //
    INLINE DWORD GetFirstBlockSize()
    {
        return(m_dwMemoryBlockSectors * XBOX_HD_SECTOR_SIZE);   
    }

    //
    // Searches the MRU List for the key specified in pContext
    //
    BOOL FindInMRUList(
            IN BOOL                               bOverwrite, // overwrite pContext->pbIndexData
            OUT PXONLC_CONTEXT                    pContext  
            );

    //
    // Searches the index for the key specified in pContext
    //
    BOOL FindInIndex(
            IN BOOL                               bOverwrite, // overwrite pContext->pbIndexData
            OUT PXONLC_CONTEXT                    pContext  
            );

    //
    // Gets work address - first chunk for the cache buffer
    //
    VOID GetWorkAddress(CAddress *pAddress);


    //
    // Reads sectors from disk - starts async job - address in hCache
    //
    HRESULT ReadSectors(
            IN CAddress                           *pAddress,
            IN XONLINETASK_HANDLE                 hTask
            );

    //
    // Write sectors to disk - starts async job - address in hCache
    //
    HRESULT WriteSectors(
            IN CAddress                           *pAddress,
            IN PBYTE                              *pbData,
            IN XONLINETASK_HANDLE                 hTask
            );

    //
    // Zeroes the address
    //
    INLINE VOID ResetCurrentAddress()
    {
        memset(&m_currentAddress , 0 , sizeof(CAddress));
    }

    //
    // Is there more work to do on update record?
    //
    INLINE BOOL ContinueUpdateRecord()
    {
        if( m_currentAddress.dwSectorEnd - m_currentAddress.dwSectorBegin >= XONLC_MAX_BUFFERS )
        {
            m_currentAddress.dwSectorBegin += XONLC_MAX_BUFFERS;
            m_currentAddress.dwOffsetBegin = 0;
            return TRUE;
        }
        return FALSE;
    }

    //
    // Starts writing the current index entry on disk
    //
    HRESULT StartWriteCurrentIndexEntry(
            IN PBYTE                              pbIndexData,
            IN XONLINETASK_HANDLE                 hTask
            );

    //
    // Start retrieving a record
    //
    HRESULT StartRetrieve(
            IN PXONLC_CONTEXT                     pContext,
            IN XONLINETASK_HANDLE                 hTask
            );

    //
    // Checks if is anything left to read for a record
    //
    INLINE BOOL ContinueRetrieve( IN PXONLC_CONTEXT pContext)
    {
        return ( UsingClientBuffer(pContext) );
    }

    //
    // Finish retrieving a record
    //
    HRESULT FinishRetrieve(
            IN PXONLC_CONTEXT                     pContext,
            IN XONLINETASK_HANDLE                 hTask
            );

    //
    // Gets the expected retrieve size taking into account wheather is the first or second call
    //
    DWORD GetExpectedRetrieveSize(
           IN PXONLC_CONTEXT                     pContext,
           IN BOOL                               bLastChunk
           );

    //
    // Checks retrieve results
    //
    HRESULT CheckRetrieveResults(
            IN PXONLC_CONTEXT                     pContext
            );

    //
    // Checks sectors integrity
    //
    HRESULT CheckRetrievedSectorsIntegrity(
            IN PXONLC_CONTEXT                     pContext,
            IN BOOL                               bLastChunk
            );


    //
    // Retrieves the address for the specified record
    //
    BOOL GetRecordAddressFromCurrentAddress();

    //
    // Sets the flag for first chunk
    //
    INLINE VOID MarkFirstUpdateChunk()
    {
        m_bUpdateFirstChunk = TRUE;
    }

    //
    // Update the current index entry in memory
    //
    VOID UpdateCurrentIndexEntry(IN PBYTE pbIndexData);

    //
    // Updates the MRU List in memory
    //
    VOID UpdateMRUList(PBYTE pbIndexData, PBYTE pbRecord);

    //
    // Checks if the cache type supports MRU list
    //
    INLINE BOOL HasMRUList()
    {
        return (0 != GetMRUListSize());
    }

    //
    // Checks if the cache type has cached data block
    //
    INLINE BOOL HasRecords()
    {
        return (0 != GetCachedDataSize());
    }

    //
    // Gets the number of sectors for the part of the cache that is uploaded in memory
    //
    INLINE DWORD GetFirstBlockSectors()
    {
        return m_dwMemoryBlockSectors;
    }

    //
    // Compute number of sectors spanned by MRU List
    //
    INLINE DWORD GetMRUListSectors()
    {
        return ComputeSectorsCount(m_dwIndexOffset);
    }

    //
    // Checks if the retrieve buffer is DWORD aligned
    //
    INLINE BOOL IsBufferDWORDAligned(IN PXONLC_CONTEXT pContext)
    {
        if( UsingClientBuffer(pContext) )
        {
            return ((((DWORD)(pContext->pbRecordBuffer)) & (sizeof(DWORD) - 1)) == 0);
        }

        return (TRUE);
    }

    //
    // Delete current index entry
    //
    VOID DeleteCurrentIndexEntry();

    //
    // Writes the first block for a new created/reset cache file 
    //
    VOID InitializeFirstBlock();

    //
    // Get handle to the file IO subtask 
    //
    INLINE XONLINETASK_HANDLE GetFileIOSubtaskHandle()
    {
        return ((XONLINETASK_HANDLE)(&m_fileIOSubtask));
    }

    //
    // Get handle to the cache subtask
    //
    INLINE XONLINETASK_HANDLE GetCacheSubtaskHandle()
    {
        return ((XONLINETASK_HANDLE)(&m_cacheSubtask));
    }

    //
    // Set the work event
    //
    INLINE BOOL SetWorkEvent()
    {
        if( NULL != m_hWorkEvent )
        {
            return (SetEvent(m_hWorkEvent));
        }

        return (TRUE);
    }

private:
    //
    // Get/Set
    //

    //
    // Gets current index entry indicated by m_currentAddress
    //
    INLINE PBYTE GetCurrentIndexEntry()
    {
        return &(m_pbMemoryBlock)[m_currentAddress.dwSectorBegin].pbUtilSectorSpace[m_currentAddress.dwOffsetBegin];
    }

    //
    // Get MRU start pointer
    //
    INLINE PBYTE GetMRUListStart()
    {
        return (PBYTE)(m_pbMemoryBlock) + sizeof(CHeader);
    }

    //
    // Gets the pointer in memory block indicated by address
    //
    INLINE PBYTE GetPointerInMemBlock( IN CAddress *pAddress )
    {
        return &(m_pbMemoryBlock[pAddress->dwSectorBegin].pbUtilSectorSpace[pAddress->dwOffsetBegin]);
    }

    //
    // Gets the pointer in the buffer of sectors indicated by address - considering sector 0 to start in buffer
    //
    INLINE PBYTE GetPointerInBuffer( IN CAddress *pAddress )
    {
        return &(m_pbBuffer[0].pbUtilSectorSpace[pAddress->dwOffsetBegin]);
    }

    //
    // Gets the total number of sectors for the file on disk
    //
    DWORD GetTotalSectors ();

    //
    // Gets the data from a given address
    //
    VOID GetDataFromAddress(
            IN CSector             *pbSectors,
            IN CAddress            *pAddress,
            IN DWORD               dwDataSize,
            OUT PBYTE              pbData
            );

    //
    // Gets data from current address
    //
    INLINE VOID GetDataFromCurrentAddress(
                IN DWORD               dwDataSize,
                OUT PBYTE              pbData
                )
    {
        GetDataFromAddress(m_pbMemoryBlock , &m_currentAddress , dwDataSize , pbData);
    }

    //
    // Gets the key from an index entry
    //
    INLINE PBYTE GetKey( PBYTE pbIndexEntry )
    {
        return pbIndexEntry + sizeof(CHECKINFO) + sizeof(TIMESTAMP);
    }

    //
    // Gets the index data from an index entry
    //
    INLINE PBYTE GetIndexData( PBYTE pbIndexEntry )
    {
        return pbIndexEntry + sizeof(CHECKINFO) + sizeof(TIMESTAMP);
    }

    //
    // Sets the index content
    //
    INLINE VOID SetIndexData( PBYTE pbIndexEntry , PBYTE pbIndexData)
    {
        memcpy(GetKey(pbIndexEntry), pbIndexData , GetIndexDataSize() );
    }

    //
    // Gets the timestamp form an index entry
    //
    INLINE TIMESTAMP GetTimestamp( PBYTE pbIndexEntry )
    {
        return *(TIMESTAMP*)(pbIndexEntry + sizeof(CHECKINFO));
    }

    //
    // Sets the timestamp for an index entry
    //
    INLINE VOID SetTimestamp( PBYTE pbIndexEntry , TIMESTAMP timeStamp )
    {
        *(TIMESTAMP*)(pbIndexEntry + sizeof(CHECKINFO)) = timeStamp;
    }

    //
    // Sets the index position for a MRU item
    //
    INLINE VOID SetIndexPosition( PBYTE pbMRUEntry , DWORD dwIndexPos )
    {
        *(DWORD*)(pbMRUEntry + sizeof(CHECKINFO)) = dwIndexPos;
    }


    //
    // Get/Set the check bytes
    //
    INLINE BYTE GetFirstByte(CSector *pbMemory , CAddress *pAddress)
    {
        return (pbMemory[pAddress->dwSectorBegin]).pbUtilSectorSpace[pAddress->dwOffsetBegin];
    }

    INLINE BYTE GetLastByte(CSector *pbMemory , CAddress *pAddress)
    {
        return (pbMemory[pAddress->dwSectorEnd]).pbUtilSectorSpace[pAddress->dwOffsetEnd];
    }

    INLINE BYTE SetFirstByte(CSector *pbMemory , CAddress *pAddress , BYTE byte)
    {
        return (pbMemory[pAddress->dwSectorBegin]).pbUtilSectorSpace[pAddress->dwOffsetBegin] = byte;
    }

    INLINE BYTE SetLastByte(CSector *pbMemory , CAddress *pAddress , BYTE byte)
    {
        return (pbMemory[pAddress->dwSectorEnd]).pbUtilSectorSpace[pAddress->dwOffsetEnd] = byte;
    }

    //
    // Retrieves the address for the specified MRU list item
    //
    BOOL GetMRUItemAddress( IN DWORD  dwPos );


    //
    // Retrieves the address for the specified index item
    //
    BOOL GetIndexItemAddress( IN DWORD dwPos );

    //
    // Sets beginning check byte
    //
    VOID SetFirstCheckByte(CSector *pbMemory , CAddress *pAddress);

    //
    // Sets end check byte
    //
    VOID SetLastCheckByte(CSector *pbMemory , CAddress *pAddress);

private:
    //
    // Size INLINE functions
    //

    INLINE DWORD GetMaxCachedItems()
    {
        return g_xonCacheParams[m_cacheType][XONLC_PARAMS_MAX_CACHED_ITEMS];
    }

    INLINE DWORD GetMRUListSize()
    {
        return g_xonCacheParams[m_cacheType][XONLC_PARAMS_MRU_LIST_SIZE];
    }

    INLINE DWORD GetKeySize()
    {
        return g_xonCacheParams[m_cacheType][XONLC_PARAMS_KEY_DATA_SIZE];
    }

    INLINE DWORD GetIndexEntrySize()
    {
        return sizeof(CHECKINFO) +       // the check byte for the cached record
               sizeof(TIMESTAMP) +      // the timestamp for LRU
               g_xonCacheParams[m_cacheType][XONLC_PARAMS_INDEX_DATA_SIZE]; 
    }

    INLINE DWORD GetIndexDataSize()
    {
        return g_xonCacheParams[m_cacheType][XONLC_PARAMS_INDEX_DATA_SIZE];
    }

    INLINE DWORD GetMRUItemSize()
    {
        return  sizeof(CHECKINFO) + // begin check byte
                sizeof(INDEXPOS)  + // index position
                g_xonCacheParams[m_cacheType][XONLC_PARAMS_INDEX_DATA_SIZE] +
                g_xonCacheParams[m_cacheType][XONLC_PARAMS_CACHED_DATA_SIZE] +
                sizeof(CHECKINFO);  // end check byte

    }

    INLINE DWORD GetRecordSize()
    {
        return  sizeof(CHECKINFO) + // begin check byte
                g_xonCacheParams[m_cacheType][XONLC_PARAMS_CACHED_DATA_SIZE] +
                sizeof(CHECKINFO); // end check byte
    }

    INLINE DWORD GetCachedDataSize()
    {
        return  g_xonCacheParams[m_cacheType][XONLC_PARAMS_CACHED_DATA_SIZE];
                
    }

private:
    //
    // Miscellaneous
    //

    //
    // Computes the offsets for index and cached records
    //
    VOID ComputeCacheOffsets();

    //
    // Checks a sector for integrity
    //
    INLINE BOOL IsSectorCorrupted(IN CSector *pSectors , IN DWORD dwPos)
    {
#ifdef XONLINE_FEATURE_XBOX 

        XCALCSIG_SIGNATURE Signature;
        HANDLE hSig = NULL;

		// Check signature
		hSig = XCalculateSignatureBegin(XCALCSIG_FLAG_NON_ROAMABLE);
		XCalculateSignatureUpdate(hSig, 
			                      (PBYTE)pSectors[dwPos].pbUtilSectorSpace, 
			                      XONLC_UTIL_SECTOR_SIZE);
		XCalculateSignatureEnd(hSig, &Signature);

		return (memcmp(&Signature, pSectors[dwPos].pbSignature, XONLC_SIGNATURE_SIZE) != 0);
#else
		return (FALSE);
#endif
    }


    //
    // Gets the number of sectors for the part of the cache that is uploaded in memory
    //
    INLINE DWORD ComputeFirstBlockSectorsCount()
    {
        return ComputeSectorsCount(m_dwCachedDataOffset);
    }


    //
    // Computes the number of sectors needed to store the info with the given size
    //
    DWORD ComputeSectorsCount( IN DWORD dwSize );

    //
    // Prepares the sectors in the specified range for writing on disk 
    //
    VOID PrepareSectorsForWrite(
            IN CSector                *pbMemoryBlock,
            IN DWORD                  dwSectorIndexBegin,
            IN DWORD                  dwSectorIndexEnd
            );

    //
    // Copies the cached record to sectors
    //
    PBYTE CopyDataToSectors(
            IN PBYTE               pbSrcData,
            IN CAddress            *pAddress,
            IN DWORD               dwMaxNumberOfBuffers,
            IN BOOL                bWriteLastCheckByte,
            OUT CSector            *pbDestData
            );

    //
    // Copies the info from a buffer into a sector array
    //
    PBYTE CopyBufferToSectors(
            IN PBYTE               pbSrcData,
            IN CAddress            *pAddress,
            OUT CSector            *pbDestData
            );

    //
    // Marks one entry given by an address as available
    //
    INLINE VOID MarkCurrentEntryAsAvailable()
    {
        (m_pbMemoryBlock[m_currentAddress.dwSectorBegin]).pbUtilSectorSpace[m_currentAddress.dwOffsetBegin] = AVAILABLE;
    }

    //
    // Checks if the current entry has been marked as available
    //
    INLINE BOOL IsCurrentEntryAvailable()
    {
        return (AVAILABLE == (m_pbMemoryBlock[m_currentAddress.dwSectorBegin]).pbUtilSectorSpace[m_currentAddress.dwOffsetBegin]);
    }

    //
    // Compare two index datas
    //
    BOOL CompareIndexData(PBYTE pbIndexData1 , PBYTE pbIndexData2);

    //
    // Checks if the client buffer is used in the process of retrieve
    //
    INLINE BOOL UsingClientBuffer(IN PXONLC_CONTEXT pContext)
    {
        //
        // We're using the client's buffer if the record size is too big to fit m_pbBuffer
        //
        return ( m_currentAddress.dwSectorEnd - m_currentAddress.dwSectorBegin >= XONLC_MAX_BUFFERS );
    }

private:
    //
    // Members
    //
    XONLC_TYPE                    m_cacheType;                  // Type of cache from the XONLC_TYPE
    HANDLE                        m_hCacheFile;                 // Handle to the file on disk
    BOOL                          m_bCacheLock;                 // Flag for locking/unlocking the cache

    CSector                       *m_pbMemoryBlock;             // The memory block that holds the first sectors
                                                                // of the cache(Header ,MRU list, Index)
    DWORD                         m_dwMemoryBlockSectors;       // Number of sectors that the memory block spans
    CHeader                       *m_pHeader;                   // Pointer to the header in memory block
    DWORD                         m_dwIndexOffset;              // The offset in file where the index starts
    DWORD                         m_dwCachedDataOffset;         // The offset in file where the cached data starts

    PFNXONLC_COMPARE_HANDLER      m_pfnCompareFunc;             // Handle to a custom comparison function(can be NULL)

    CSector                       m_pbBuffer[XONLC_MAX_BUFFERS];// Additional buffer on stack used in read/write ops  
    CAddress                      m_currentAddress;             // Address of the current item handled(mru list item, index item or record)
    BYTE                          m_bCheckByte;                 // Current check byte
    BOOL                          m_bUpdateFirstChunk;          // Flag that tells if the update just started and the first 
                                                                // check byte needs to be written
    DWORD                         m_dwCurrentIndexPos;          // The current position in index
    BOOL                          m_bFoundInMRUList;            // Flag that tells if the current item was found
                                                                // in the MRU list
    XONLINETASK_FILEIO            m_fileIOSubtask;              // Subtask structure for read/write ops
    XONLINETASK_CACHE             m_cacheSubtask;               // Subtask structure for cache private ops

    HANDLE                        m_hWorkEvent;                 // Event to be used by the subtasks

    CXo *                         m_pXo;                        // Pointer to CXo that created this cache

};


//////////////////////////////////////////////////////////////////////////////
/*CacheOpen - Routine Description:

    Opens the cache of the specified type. 

Arguments:
    cacheType[in]          One of the types of cache enumerated in XONLC_TYPE.
    pfnCompareFunc[in]     Custom comparison function handle.
    hWorkEvent[in]         Event to be set when pumping is required. Can be NULL.
    phCache[out]           Handle to the opened cache. The contents of it should be checked after the task completes.
    phTask[out]            Upon success, this out parameter returns a handle to the open task.

Return Value:

    HRESULT

Memory Allocation:

    Allocates cache structure and task handle.

Notes:
    Asynchronous
*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CXo::CacheOpen(
    IN XONLC_TYPE                           cacheType,
    IN PFNXONLC_COMPARE_HANDLER             pfnCompareFunc,
    IN HANDLE                               hWorkEvent,
    OUT PHANDLE                             phCache,
    OUT PXONLINETASK_HANDLE                 phTask
    )
{
    HRESULT hr = S_OK;

    Assert(cacheType < XONLC_MAX_CACHE_TYPES);
    Assert(NULL != phCache);
    Assert(NULL != phTask);
    Assert(NULL == m_xonCacheHandles[cacheType]);


    PXONLINETASK_CACHE pCacheTask = NULL;
    XONLC_CACHE_HANDLE hCache = NULL;

    *phCache = NULL;    
	*phTask = NULL;
    
    do
    {
        //
        // The cache needs to be created from disk - allocate memory for cache structures in memory
        //
        hCache = m_xonCacheHandles[cacheType] = (CLocalCache *)SysAllocZ(sizeof(CLocalCache), PTAG_CLocalCache);
        if( NULL ==  hCache)
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        //
        // Initialize the cache structure
        //
        hr = hCache->Initialize(cacheType, pfnCompareFunc, hWorkEvent, this);
        if( FAILED( hr ) )
        {
            break;
        }

        // Allocate the task context
        pCacheTask = (PXONLINETASK_CACHE)SysAlloc(sizeof(XONLINETASK_CACHE), PTAG_XONLINETASK_CACHE);
        if (!pCacheTask)
        {
            hr  = E_OUTOFMEMORY;
            break;
        }

        // Initialize the context
        pCacheTask->InitializeContext(hCache, hWorkEvent, this);

        //
        // Start async job
        //
        hr = pCacheTask->DoOpenCacheBegin();

    }
    while( FALSE );
    
    if( FAILED( hr ) )
    {
        if( NULL != hCache )
        {
            //
            // Cleanup allocated memory
            //
            hCache->Delete();
        }

		if( NULL != pCacheTask )
        {
			//
            // Cleanup allocated task handle
            //
			SysFree(pCacheTask);
        }
    }
    else
    {
		//
        // Lock cache for async task
        //
		hCache->LockCache();

		//
	    // Return the opaque handle
	    //	
        *phTask = (XONLINETASK_HANDLE)pCacheTask;

        //
        //  Return the handle to the newly opened cache
        //
        *phCache = hCache;
    }

    return( hr );
}

//////////////////////////////////////////////////////////////////////////////
/*CacheUpdate - Routine Description:

    Called when a record in the cache needs to be updated or, if it doesn't exist, it needs to be created. 

Arguments:
    hCache[in]         The handle to cache. The updates are addressed to a certain type of cache and the sizes for the index entries and the actual cached data are implied by this handle. 
    hTask[in]          The handle to the update task.
    pbIndexData[in]    The index entry.
    pbRecord[in]       The actual data to be cached. The buffer has to be DWORD aligned.
    
Return Value:

    HRESULT

Memory Allocation:

    No.

Notes:
    Asynchronous
*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CXo::CacheUpdate(
    IN HANDLE                             hCache,
    IN XONLINETASK_HANDLE                 hTask,
    IN PBYTE                              pbIndexData,                  
    IN PBYTE                              pbRecord,
    IN BOOL                               bWriteIndex
    )
{
    HRESULT hr = S_OK;
    PXONLINETASK_CACHE pCacheTask = NULL;
    
    Assert(hCache != NULL);
    Assert(pbIndexData != NULL);
    Assert(hTask != NULL);
    Assert(!((XONLC_CACHE_HANDLE)hCache)->HasRecords() || (pbRecord != NULL));

    do
    {
        if( ((XONLC_CACHE_HANDLE)hCache)->IsCacheLocked() )
        {
            hr = E_FAIL;
            break;
        }

        pCacheTask = (PXONLINETASK_CACHE)hTask;

        // Sets the current task parameters
        pCacheTask->SetCurrentTaskParams( XONLC_OPS_UPDATE , pbIndexData , pbRecord, NULL, bWriteIndex);

        //
        // Start async work 
        //
        hr = pCacheTask->DoUpdateCacheBegin();
    }
    while( FALSE );

    if( SUCCEEDED( hr ) )
    {
        //
        // Everything OK - lock the cache
        //
        ((XONLC_CACHE_HANDLE)hCache)->LockCache();
    }
    
    return( hr );
}

//////////////////////////////////////////////////////////////////////////////
/*CacheIndexFlush - Routine Description:

    Writes down the index. 

Arguments:
    hCache[in]          The handle to cache. 
    hTask[in]           The handle to the task.

Return Value:

    HRESULT

Memory Allocation:

    No.

Notes:
    Asynchronous
*/
//////////////////////////////////////////////////////////////////////////////

HRESULT CXo::CacheIndexFlush(HANDLE hCache, XONLINETASK_HANDLE hTask)
{
    HRESULT hr = S_OK;
    PXONLINETASK_CACHE pCacheTask = NULL;
    
    Assert(hCache != NULL);
    Assert(hTask != NULL);

    do
    {
        if( ((XONLC_CACHE_HANDLE)hCache)->IsCacheLocked() )
        {
			hr = E_FAIL;
			break;
        }

        pCacheTask = (PXONLINETASK_CACHE)hTask;

        // Sets the current task parameters
        pCacheTask->SetCurrentTaskParams( XONLC_OPS_FLUSH );

        //
        // Start async job
        //
        hr = pCacheTask->DoIndexFlushBegin();
    }
    while( FALSE );

    if( SUCCEEDED( hr ) )
    {
        //
        // Everything OK - lock the cache
        //
        ((XONLC_CACHE_HANDLE)hCache)->LockCache();
    }
    
    return( hr );

}

//////////////////////////////////////////////////////////////////////////////
/*CacheLookup - Routine Description:

    Called to lookup a given index data. 

Arguments:
    hCache[in]         The handle to cache. 
    pContext[out]      A pointer to a context structure which contains specific data describing the record to be retrieved. 

Return Value:

    HRESULT

Memory Allocation:

    No.

Notes:
    Synchronous
*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CXo::CacheLookup(
    IN HANDLE                             hCache,
    OUT PXONLC_CONTEXT                    pContext  
    )
{
    HRESULT hr = S_OK;

    Assert(hCache != NULL);
    Assert(pContext != NULL);
    Assert(pContext->pbIndexData != NULL);
            
    do
    {
        if( ((XONLC_CACHE_HANDLE)hCache)->IsCacheLocked() )
        {
            hr = E_FAIL;
            break;
        }

        ((XONLC_CACHE_HANDLE)hCache)->LockCache();

        //
        // Parse the MRU List in search of the key
        //
        if(!((XONLC_CACHE_HANDLE)hCache)->FindInMRUList(GET_INDEX_DATA, pContext))  
        {
            //
            // Key not found in MRU - parse the index
            //
            ((XONLC_CACHE_HANDLE)hCache)->FindInIndex(GET_INDEX_DATA, pContext);
        }

        if(( pContext->bValidDataInCache ) && (!pContext->bCallRetrieveNext))
        {
            ((XONLC_CACHE_HANDLE)hCache)->UpdateMRUList(pContext->pbIndexData , pContext->pbRecordBuffer);
        }

        ((XONLC_CACHE_HANDLE)hCache)->UnlockCache();
    }
    while(FALSE);

    return( hr );
}

//////////////////////////////////////////////////////////////////////////////
/*CacheRetrieve - Routine Description:

    Called after Lookup to retrieve a record from disk. 

Arguments:
    hCache[in]        The handle to cache. 
    hTask[in]         The handle to the retrieve task.
    pContext[out]     A pointer to a context structure which contains specific data describing the record to be retrieved. 
    
Return Value:

    HRESULT

Memory Allocation:

    No.

Notes:
    Asynchronous
*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CXo::CacheRetrieve(
    IN HANDLE                             hCache,
    IN XONLINETASK_HANDLE                 hTask,
    IN OUT PXONLC_CONTEXT                 pContext  
    )
{
    HRESULT hr = S_OK;
    PXONLINETASK_CACHE pCacheTask = NULL;

    Assert(hCache != NULL);
    Assert(hTask != NULL);
    Assert(pContext != NULL);
    Assert(((XONLC_CACHE_HANDLE)hCache)->HasRecords());
    Assert(pContext->pbIndexData != NULL);
    Assert(pContext->pbRecordBuffer != NULL);
    Assert(pContext->dwRecordBufferSize != 0);
    Assert((((XONLC_CACHE_HANDLE)hCache)->IsBufferDWORDAligned(pContext)));
    Assert(TRUE == pContext->bCallRetrieveNext);
    Assert(TRUE == pContext->bValidDataInCache);
        
    do
    {
        if( ((XONLC_CACHE_HANDLE)hCache)->IsCacheLocked() )
        {
            hr = E_FAIL;
            break;
        }

        pCacheTask = (PXONLINETASK_CACHE)hTask;

        // Sets the current task parameters
        pCacheTask->SetCurrentTaskParams( XONLC_OPS_RETRIEVE , NULL , NULL, pContext);

        //
        // Start async work
        //
        hr = pCacheTask->DoRetrieveBegin();
    }
    while(FALSE);

    if( SUCCEEDED( hr ) )
    {
        //
        // Everything OK - lock the cache
        //
        ((XONLC_CACHE_HANDLE)hCache)->LockCache();
    }

    return( hr );
}

//////////////////////////////////////////////////////////////////////////////
/*CacheDelete - Routine Description:

    Called to delete a given index data. 

Arguments:
    hCache[in]         The handle to cache. 
    pContext[out]      A pointer to a context structure which contains specific data describing the record to be retrieved. 

Return Value:

    HRESULT

Memory Allocation:

    No.

Notes:
    Synchronous
*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CXo::CacheDelete(
    IN HANDLE                             hCache,
    OUT PXONLC_CONTEXT                    pContext  
    )
{
    HRESULT hr = S_OK;

    Assert(hCache != NULL);
    Assert(pContext != NULL);
    Assert(pContext->pbIndexData != NULL);
        
    do
    {
        if( ((XONLC_CACHE_HANDLE)hCache)->IsCacheLocked() )
        {
            hr = E_FAIL;
            break;
        }

        ((XONLC_CACHE_HANDLE)hCache)->LockCache();
        
        //
        // Parse the MRU List in search of the key
        //
        BOOL bFound = ((XONLC_CACHE_HANDLE)hCache)->FindInMRUList(DONT_GET_INDEX_DATA, pContext);

        if(!bFound) 
        {
            //
            // Key not found in MRU - parse the index
            //
            bFound = ((XONLC_CACHE_HANDLE)hCache)->FindInIndex(DONT_GET_INDEX_DATA, pContext);
        }

        if( bFound )
        {
            ((XONLC_CACHE_HANDLE)hCache)->DeleteCurrentIndexEntry();
        }

        ((XONLC_CACHE_HANDLE)hCache)->UnlockCache();
    }
    while(FALSE);

    return( hr );
}

//////////////////////////////////////////////////////////////////////////////
/*CacheFileDelete - Routine Description:

    Deletes the actual cache file from the disk.

Arguments:
    cacheType[in]       One of the types of cache enumerated in XONLC_TYPE. 
    
Return Value:

    HRESULT

Memory Allocation:

    No.

Notes:
    Synchronous
*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CXo::CacheFileDelete(XONLC_TYPE cacheType)
{
    HRESULT hr = S_OK;

    if( NULL != m_xonCacheHandles[cacheType] )
    {
        m_xonCacheHandles[cacheType]->Delete();
        m_xonCacheHandles[cacheType] = NULL;
    }

    //
    // Delete cache file on disk
    //
    char szFileName[500];
    sprintf(szFileName , "\\Device\\Harddisk0\\partition1\\CACHE\\LocalCache%02d.bin" , cacheType);

    OBJECT_STRING FileName;
    OBJECT_ATTRIBUTES Obja;
    
    RtlInitObjectString(&FileName, szFileName);

    InitializeObjectAttributes( &Obja,
                                &FileName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );

    NTSTATUS Status = NtDeleteFile(&Obja);
    if(!NT_SUCCESS(Status)) 
    {
        hr = HRESULT_FROM_WIN32(RtlNtStatusToDosError(Status));    
    }
       
    return( hr );
}

//////////////////////////////////////////////////////////////////////////////
/*CacheReset - Routine Description:

    Discards cache content. 

Arguments:
    hCache[in]         The handle to cache. 
    hTask[in]          The handle to the reset task.

Return Value:

    HRESULT

Memory Allocation:

    No.

Notes:
    Asynchronous
*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CXo::CacheReset(HANDLE hCache, XONLINETASK_HANDLE hTask)
{
    HRESULT hr = S_OK;
    PXONLINETASK_CACHE pCacheTask = NULL;
    
    Assert(hCache != NULL);
    Assert(hTask != NULL);

    do
    {
        if( ((XONLC_CACHE_HANDLE)hCache)->IsCacheLocked() )
        {
            hr = E_FAIL;
            break;
        }

        pCacheTask = (PXONLINETASK_CACHE)hTask;

        // Initialize the current parameters
        pCacheTask->SetCurrentTaskParams( XONLC_OPS_RESET );

        //
        // Start async work
        //
        pCacheTask->DoResetCacheBegin();
    }
    while( FALSE );

    if( SUCCEEDED( hr ) )
    {
        //
        // Everything OK - lock the cache
        //
        ((XONLC_CACHE_HANDLE)hCache)->LockCache();
    }
    
    return( hr );

}


//////////////////////////////////////////////////////////////////////////////
/*CacheClose - Routine Description:

    Closes a cache type and releases the resources associated with it. 

Arguments:
    hCache[in]          The handle to cache. 
    hTask[in]           The handle to the close task.

Return Value:

    HRESULT

Memory Allocation:

    No.

Notes:
    Asynchronous
*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CXo::CacheClose(HANDLE hCache, XONLINETASK_HANDLE hTask)
{
    HRESULT hr = S_OK;
    PXONLINETASK_CACHE pCacheTask = NULL;
    
    Assert(hCache != NULL);
    Assert(hTask != NULL);

    do
    {
        if( ((XONLC_CACHE_HANDLE)hCache)->IsCacheLocked() )
        {
			//
			// Some subtask involving the cache is in progress
			//
			hr = XONLINETASK_S_RUNNING;
			while(XONLINETASK_S_RUNNING == hr)
			{
				hr = XOnlineTaskContinue(hTask);
			}

			Assert(!(((XONLC_CACHE_HANDLE)hCache)->IsCacheLocked()));
        }

        pCacheTask = (PXONLINETASK_CACHE)hTask;

        // Sets the current task parameters
        pCacheTask->SetCurrentTaskParams( XONLC_OPS_CLOSE );

        //
        // Start async job
        //
        hr = pCacheTask->DoCloseCacheBegin();
    }
    while( FALSE );

    if( SUCCEEDED( hr ) )
    {
        //
        // Everything OK - lock the cache
        //
        ((XONLC_CACHE_HANDLE)hCache)->LockCache();
    }
    
    return( hr );
}

//////////////////////////////////////////////////////////////////////////////
/*CacheClose - Routine Description:

    Closes a cache type and releases the resources associated with it. 

Arguments:
    hCache[in]          The handle to cache. 

Return Value:

    HRESULT

Memory Allocation:

    No.

Notes:
    Synchronous
*/
//////////////////////////////////////////////////////////////////////////////
HRESULT CXo::CacheClose(HANDLE hCache)
{
    HRESULT hr = S_OK;
        
    Assert(hCache != NULL);
    
    do
    {
        if( ((XONLC_CACHE_HANDLE)hCache)->IsCacheLocked() )
        {
			hr = E_FAIL;
			break;
        }

        //
        // Delete hCache will delete all the memory associated with it and 
        // will put the global array item on NULL
        //
        ((XONLC_CACHE_HANDLE)hCache)->Delete();
    }
    while( FALSE );

    return( hr );
}

//////////////////////////////////////////////////////////////////////////////
//
// Task-related internal functions
//
//////////////////////////////////////////////////////////////////////////////

//----------------------------------------------------------------------------
//
// Do work function for cache operations
//
//----------------------------------------------------------------------------
HRESULT CXo::CacheContinue(XONLINETASK_HANDLE hTask)
{
    HRESULT             hr = S_OK;
    CCacheTask          *pCacheTask = (CCacheTask*)hTask;

    Assert(hTask != NULL);

    // Call the function to take care of this
    switch (pCacheTask->GetOp())
    {
        case XONLC_OPS_OPEN:
            hr = pCacheTask->DoOpenCache();
            break;

        case XONLC_OPS_UPDATE:
            hr = pCacheTask->DoUpdateCache();
            break;

        case XONLC_OPS_FLUSH:
            hr = pCacheTask->DoIndexFlush();
            break;

        case XONLC_OPS_RETRIEVE:
            hr = pCacheTask->DoRetrieve();
            break;

        case XONLC_OPS_RESET:
            hr = pCacheTask->DoResetCache();
            break;

        case XONLC_OPS_CLOSE:
            hr = pCacheTask->DoCloseCache();
            break;

        case XONLC_OPS_UPDATE_RECORD:
            hr = pCacheTask->DoUpdateRecordPriv();
            break;

        case XONLC_OPS_UPDATE_INDEX:
            hr = pCacheTask->DoUpdateIndexPriv();
            break;

        case XONLC_OPS_UPDATE_MRU_LIST:
            hr = pCacheTask->DoUpdateMRUListPriv();
            break;
    }

    return (hr);
}

//----------------------------------------------------------------------------
//
// Close function for Cache
//
//----------------------------------------------------------------------------
VOID CXo::CacheTaskClose(XONLINETASK_HANDLE hTask)
{
    Assert(hTask != NULL);

	PXONLINETASK_CACHE pCacheTask = (PXONLINETASK_CACHE)hTask;

	pCacheTask->ForceCompletion();
   
    SysFree(pCacheTask);
}


//////////////////////////////////////////////////////////////////////////////
//
// Private async functions
//
//////////////////////////////////////////////////////////////////////////////

//----------------------------------------------------------------------------
//
// Updates the MRU list - async
//
//----------------------------------------------------------------------------
HRESULT CXo::CacheUpdateMRUListPriv(
    IN XONLC_CACHE_HANDLE                   hCache,
    IN XONLINETASK_HANDLE                   hTask,
    IN PBYTE                                pbIndexData,
    IN PBYTE                                pbRecord
    )
{

    HRESULT hr = S_OK;
    PXONLINETASK_CACHE pCacheTask = NULL;

    Assert(hCache != NULL);
    Assert(hTask != NULL);
    Assert(pbIndexData != NULL);
    Assert(!((XONLC_CACHE_HANDLE)hCache)->HasRecords() || (pbRecord != NULL));
    
    do
    {
        pCacheTask = (PXONLINETASK_CACHE)hTask;

        // Sets the current task parameters
        pCacheTask->SetCurrentTaskParams( XONLC_OPS_UPDATE_MRU_LIST , pbIndexData, pbRecord);

        //
        // Start async work
        //
        hr = pCacheTask->DoUpdateMRUListPrivBegin();

    }
    while( FALSE );
    
    return( hr );
}

//----------------------------------------------------------------------------
//
// Updates the index entry from the current cache address - async
//
//----------------------------------------------------------------------------
HRESULT CXo::CacheUpdateIndexPriv(
    IN XONLC_CACHE_HANDLE                   hCache,
    IN XONLINETASK_HANDLE                   hTask,
    IN PBYTE                                pbIndexData
    )
{
    HRESULT hr = S_OK;
    PXONLINETASK_CACHE pCacheTask = NULL;

    Assert(hCache != NULL);
    Assert(hTask != NULL);
    Assert(pbIndexData != NULL);
    
    do
    {
         pCacheTask = (PXONLINETASK_CACHE)hTask;

        // Sets the current task parameters
        pCacheTask->SetCurrentTaskParams( XONLC_OPS_UPDATE_INDEX , pbIndexData);

        //
        // Start async work
        //
        hr = pCacheTask->DoUpdateIndexPrivBegin();

    }
    while( FALSE );
    
    return( hr );
}

//----------------------------------------------------------------------------
//
// Updates the record from the current cache address - async
//
//----------------------------------------------------------------------------
HRESULT CXo::CacheUpdateRecordPriv(
    IN XONLC_CACHE_HANDLE                   hCache,
    IN XONLINETASK_HANDLE                   hTask,
    IN PBYTE                                pbRecord
    )
{
    HRESULT hr = S_OK;
    PXONLINETASK_CACHE pCacheTask = NULL;

    Assert(hCache != NULL);
    Assert(hTask != NULL);
    Assert(pbRecord != NULL);

    do
    {
        pCacheTask = (PXONLINETASK_CACHE)hTask;

        // Sets the current task parameters
        pCacheTask->SetCurrentTaskParams( XONLC_OPS_UPDATE_RECORD , NULL , pbRecord);

        //
        // Get the address of the record
        //
        BOOL bAddressValid = hCache->GetRecordAddressFromCurrentAddress();

        Assert( bAddressValid);

        //
        // Start async work
        //
        hr = pCacheTask->DoUpdateRecordPrivBegin();
      
    }
    while( FALSE );
    
    return( hr );
}

//////////////////////////////////////////////////////////////////////////////
//
// CAddress implementation
//
//////////////////////////////////////////////////////////////////////////////

//----------------------------------------------------------------------------
//
// Constructors
//
//----------------------------------------------------------------------------
CAddress::CAddress() :
        dwSectorBegin(0),
        dwOffsetBegin(0),
        dwSectorEnd(0),
        dwOffsetEnd(0),
        dwPosition(0),
        dwSize(0)
{
}

CAddress::CAddress(const CAddress& adr)
{
    dwSectorBegin = adr.dwSectorBegin;
    dwOffsetBegin = adr.dwOffsetBegin;
    dwSectorEnd = adr.dwSectorEnd;
    dwOffsetEnd = adr.dwOffsetEnd;
    dwPosition = adr.dwPosition;
    dwSize = adr.dwSize;
    
}

CAddress& CAddress::operator=(const CAddress& adr)
{
    if( &adr != this )
    {
        dwSectorBegin = adr.dwSectorBegin;
        dwOffsetBegin = adr.dwOffsetBegin;
        dwSectorEnd = adr.dwSectorEnd;
        dwOffsetEnd = adr.dwOffsetEnd;
        dwPosition = adr.dwPosition;
        dwSize = adr.dwSize;
    }
    return (*this);
}

//----------------------------------------------------------------------------
//
// Increments an address
//
//----------------------------------------------------------------------------
VOID CAddress::IncrementAddress( DWORD dwAmmount )
{
    dwOffsetBegin += dwAmmount;
    while( XONLC_UTIL_SECTOR_SIZE <= dwOffsetBegin )
    {
        dwOffsetBegin -= XONLC_UTIL_SECTOR_SIZE;
        dwSectorBegin++;
        Assert(dwSectorBegin <= dwSectorEnd);
    }
    dwSize -= dwAmmount;
}

//----------------------------------------------------------------------------
//
// Decrements an address
//
//----------------------------------------------------------------------------
VOID CAddress::DecrementAddress( DWORD dwAmmount )
{
    if( dwAmmount > dwOffsetEnd )
    {
        dwOffsetEnd += XONLC_UTIL_SECTOR_SIZE;
        Assert(dwSectorEnd != 0);
        dwSectorEnd--;
    }

    dwOffsetEnd -= dwAmmount;

    dwSize -= dwAmmount;
}

//----------------------------------------------------------------------------
//
// Creates a relative address within a buffer 
//
//----------------------------------------------------------------------------
VOID CAddress::MakeRelativeAddress()
{
    // Make relative address in the cache buffer
    //
    dwSectorEnd -= dwSectorBegin;
    dwSectorBegin = 0;
}

//----------------------------------------------------------------------------
//
// Gets the address after cutting the first dwSectors
//
//----------------------------------------------------------------------------
VOID CAddress::CutFirstSectors(DWORD dwSectors)
{
    MakeRelativeAddress();

    Assert(dwSectors <= dwSectorEnd);

    dwSectorEnd -= dwSectors;
    dwOffsetBegin = 0;

    dwSize = dwSectorEnd * XONLC_UTIL_SECTOR_SIZE + dwOffsetEnd + 1;

}

//----------------------------------------------------------------------------
//
// Gets the address after cutting the last dwSectors
//
//----------------------------------------------------------------------------
VOID CAddress::CutLastSectors(DWORD dwSectors)
{
    MakeRelativeAddress();

    Assert(dwSectors <= dwSectorEnd);

    dwSize -= (dwSectorEnd - dwSectors) * XONLC_UTIL_SECTOR_SIZE + dwOffsetEnd + 1;

    dwSectorEnd = dwSectors - 1;
    dwOffsetEnd = XONLC_UTIL_SECTOR_SIZE - 1;

}

//////////////////////////////////////////////////////////////////////////////
//
// CCacheTask implementation
//
//////////////////////////////////////////////////////////////////////////////

//----------------------------------------------------------------------------
//
// Function to initialize a context
//
//----------------------------------------------------------------------------
VOID CCacheTask::InitializeContext( 
            IN XONLC_CACHE_HANDLE   hCache, 
            IN HANDLE               hWorkEvent,
            IN CXo *                pXo
        )
{
    // Fill in the blanks
    ZeroMemory(this, sizeof(CCacheTask));
    
    m_hCache = hCache;
    m_pXo = pXo;

    m_pXo->TaskInitializeContext(&m_xonTask);
    m_xonTask.pfnContinue = CXo::CacheContinue;
    m_xonTask.pfnClose  = CXo::CacheTaskClose;
    m_xonTask.hEventWorkAvailable = hWorkEvent;
}

//----------------------------------------------------------------------------
//
// Sets the current task's parameters
//
//----------------------------------------------------------------------------
VOID CCacheTask::SetCurrentTaskParams(
            IN XONLC_OPS            cacheOp,
            IN PBYTE                pbIndexData,
            IN PBYTE                pbRecord,
            IN PXONLC_CONTEXT       pContext,
            IN BOOL                 bWriteIndex
            )
{
    m_cacheOp = cacheOp;
    m_pbIndexData = pbIndexData;
    m_pbRecord = pbRecord;
    m_pContext = pContext;
    m_bWriteIndex = bWriteIndex;

    m_hr = XONLINETASK_S_RUNNING;
    m_state = XONLC_STATE_INITIALIZE;
	m_hSubtask = NULL;
}

//----------------------------------------------------------------------------
//
// Starts async job for Open operation
//
//----------------------------------------------------------------------------
HRESULT CCacheTask::DoOpenCacheBegin()
{
    HRESULT hr = S_OK;
    BOOL fPrepareNewCache = FALSE;

    Assert(m_hCache != NULL);
    
    Assert(NULL == m_hSubtask);

    do
    {
        //
        // Open cache file on disk
        //
        hr = m_hCache->OpenCacheFile();
        if( FAILED( hr ) )
        {
            break;
        }

        if( ERROR_ALREADY_EXISTS == GetLastError() )
        {
            //
            // Start a read to load its contents
            //
            m_hSubtask = m_hCache->GetFileIOSubtaskHandle();

            hr = m_hCache->StartFirstBlockUpload(m_hSubtask);
            if (FAILED(hr))
            {
                fPrepareNewCache = TRUE;
            }
			else
			{
				m_state = XONLC_STATE_READ;
			}
        }
        else
        {
            fPrepareNewCache = TRUE;
        }

        if (fPrepareNewCache)
        {
            //
            // Set size of the file and initialize first block
            //
            hr = m_hCache->PrepareNewCache();

            if( SUCCEEDED( hr ) )
            {
                m_hr = XONLINETASK_S_SUCCESS;
                m_state = XONLC_STATE_DONE;
								
                m_hCache->SetWorkEvent();
            }
        }
    }
    while(FALSE);

    if( FAILED( hr ) )
    {
        m_state = XONLC_STATE_DONE;
        m_hr = hr;
    }

	if(XONLC_STATE_DONE == m_state)
    {
        FinishAsyncWorkPriv();
    }

    return (hr);
}

//----------------------------------------------------------------------------
//
// Does the async work for Open operation
//
//----------------------------------------------------------------------------
HRESULT CCacheTask::DoOpenCache()
{
    HRESULT                     hr = S_OK;

	Assert(NULL != m_hCache);

	if( XONLC_STATE_DONE == m_state )
    {
        // One more loop in dowork ... nothing to be done anymore
		Assert(NULL == m_hSubtask);
		m_hCache->UnlockCache();
        return (m_hr);
    }

    do
    {
        Assert(NULL != m_hSubtask);
        Assert(m_hCache->IsCacheFileOpen());

        // We will pump until the read returns
        m_hr = m_pXo->XOnlineTaskContinue(m_hSubtask);

        if(XONLINETASK_S_RUNNING != m_hr)
        {
            if (FAILED(m_hr))
            {
                m_state = XONLC_STATE_DONE;
                break;
            }

            if(XONLC_STATE_READ == m_state)
            {
                m_state = XONLC_STATE_DONE;

                hr = CheckReadWrite(m_hCache->GetFirstBlockSize());
                if( FAILED(hr) || m_hCache->IsCacheCorrupted() )
                {
                    //
                    // Reuse task handle
                    //
                    m_hSubtask = NULL;

                    m_hCache->UnlockCache();

                    m_hSubtask = m_hCache->GetCacheSubtaskHandle();
                    hr = m_pXo->CacheReset(m_hCache , m_hSubtask);

                    if( SUCCEEDED( hr ) )
                    {
                        //
                        // Jump to a RESET state
                        //
                        m_state = XONLC_STATE_RESET;
                        m_hr = XONLINETASK_S_RUNNING;
                    }
                    else
                    {
                        // Drop opening as reset didn't succeed
                        m_hr = hr;
                    }
                }
            }
            else //XONLC_STATE_RESET
            {
                //
                // RESET finished with success 
                //
                m_state = XONLC_STATE_DONE;
            }
        }
    }
    while(FALSE);

    if( XONLC_STATE_DONE == m_state )
    {
        FinishAsyncWork();

        if( XONLINETASK_STATUS_FAILED( m_hr ) )
        {
            if( m_hCache )
            {
                m_hCache->Delete();
                m_hCache = NULL;
            }
        }
    }

    return(m_hr);
}               

//----------------------------------------------------------------------------
//
// Starts the async work for Update operation
//
//----------------------------------------------------------------------------
HRESULT CCacheTask::DoUpdateCacheBegin()
{
    HRESULT                     hr = S_OK;
    XONLC_CONTEXT               context;

    Assert(m_hCache != NULL);

    Assert(NULL == m_hSubtask);

    //
    // Prepare the context for Find
    //
    memset(&context , 0 , sizeof(XONLC_CONTEXT));
    context.pbIndexData = m_pbIndexData;
            
    m_hCache->ResetCurrentAddress();

    //
    // Parse the MRU List in search of the key
    //
    if(!m_hCache->FindInMRUList(DONT_GET_INDEX_DATA, &context)) 
    {
        //
        // Key not found in MRU - parse the index
        //
        m_hCache->FindInIndex(DONT_GET_INDEX_DATA , &context);
    }

    //
    // After Find m_hCache->m_dwCurrentIndexPosition contains one of the following
    // - position of the found item;
    // - position of a free entry;
    // - position of the LRU item.
    //
         
    m_hSubtask = m_hCache->GetCacheSubtaskHandle();
    if( m_hCache->HasRecords() )
    {
        //
        // Update the specified record on disk
        //
        hr = m_pXo->CacheUpdateRecordPriv(m_hCache, m_hSubtask, m_pbRecord);

        m_state = XONLC_STATE_UPDATE_RECORD;
    }
    else
    {
        if(TRUE == m_bWriteIndex)
        {
            //
            // m_hCache->m_dwCurrentIndexPos is the position in index to be updated
            //
            hr = m_pXo->CacheUpdateIndexPriv(m_hCache, m_hSubtask, m_pbIndexData);

            m_state = XONLC_STATE_UPDATE_INDEX;
        }
        else
        {
            //
            // Synchronously write index and MRU element in the memory and we're done
            //
            m_hCache->UpdateCurrentIndexEntry(m_pbIndexData);
            m_hCache->UpdateMRUList(m_pbIndexData, NULL);

            m_hr = XONLINETASK_S_SUCCESS;
            m_state = XONLC_STATE_DONE;
        }
    }

    if( FAILED( hr ) )
    {
        m_hr = hr;
        m_state = XONLC_STATE_DONE;
    }

	if(XONLC_STATE_DONE == m_state)
    {
        FinishAsyncWorkPriv();
    }


    return (hr);

}

//----------------------------------------------------------------------------
//
// Does the async work for Update operation
//
//----------------------------------------------------------------------------
HRESULT CCacheTask::DoUpdateCache()
{
    HRESULT                     hr = S_OK;
    XONLC_CONTEXT               context;

	Assert(NULL != m_hCache);

	if( XONLC_STATE_DONE == m_state )
    {
        // One more loop in dowork ... nothing to be done anymore
        Assert(NULL == m_hSubtask);
		m_hCache->UnlockCache();
        return (m_hr);
    }
    
    do
    {
        Assert(NULL != m_hSubtask);

        /// We will pump until the write returns
        m_hr = m_pXo->XOnlineTaskContinue(m_hSubtask);

        if(XONLINETASK_S_RUNNING != m_hr)
        {
            if (FAILED(m_hr))
            {
                break;
            }

            //
            // Reuse task handle
            //
            m_hSubtask = NULL;

            //
            // If finished to UPDATE RECORD ...
            //
            if( XONLC_STATE_UPDATE_RECORD == m_state )
            {
               if(TRUE == m_bWriteIndex)
               {
                    m_hSubtask = m_hCache->GetCacheSubtaskHandle();
                    hr = m_pXo->CacheUpdateIndexPriv(m_hCache, m_hSubtask, m_pbIndexData);
                    
                    if( SUCCEEDED( hr ) )
                    {
                        //
                        // Jump to a new state: UPDATE INDEX
                        //
                        m_hr = XONLINETASK_S_RUNNING;
                        m_state = XONLC_STATE_UPDATE_INDEX;
                    }
               }
               else
               {
                    //
                    // Synchronously write index and MRU element in the memory and we're done
                    //
                    m_hCache->UpdateCurrentIndexEntry(m_pbIndexData);
                    m_hCache->UpdateMRUList(m_pbIndexData, NULL);

                    m_hr = XONLINETASK_S_SUCCESS;
                    m_state = XONLC_STATE_DONE;
			   }
            }
            else
            {
                //
                // If finished to UPDATE INDEX...
                //
                if( XONLC_STATE_UPDATE_INDEX == m_state )
                {
                    if( m_hCache->HasMRUList() )
                    {
                        m_hSubtask = m_hCache->GetCacheSubtaskHandle();
                        hr = m_pXo->CacheUpdateMRUListPriv(m_hCache, m_hSubtask, m_pbIndexData, m_pbRecord); 
                        if( SUCCEEDED( hr ) )
                        {
                            //
                            // Jump to a new state: UPDATE MRU LIST
                            //
                            m_hr = XONLINETASK_S_RUNNING;
                            m_state = XONLC_STATE_UPDATE_MRU;
                        }
                    }
                    else
                    {
                        //
                        // No MRU list...we're done
                        //
                        m_state = XONLC_STATE_DONE;
                    }
                }
                else
                {
                    //
                    // UPDATE MRU LIST finished
                    //
                    m_state = XONLC_STATE_DONE;
                }
            }
        }
    }
    while(FALSE);

    if( FAILED( hr ) )
    {
        m_hr = hr;
        m_state = XONLC_STATE_DONE;
    }

    if(XONLC_STATE_DONE == m_state)
    {
        FinishAsyncWork();
    }

    return(m_hr);
}

//----------------------------------------------------------------------------
//
// Starts the async job for IndexFlush operation
//
//----------------------------------------------------------------------------
HRESULT CCacheTask::DoIndexFlushBegin()
{
    HRESULT                     hr = S_OK;

    Assert(m_hCache != NULL);

    Assert(NULL == m_hSubtask);


    m_hSubtask = m_hCache->GetFileIOSubtaskHandle();

    hr = m_hCache->StartFirstBlockDownload(m_hCache->GetFirstBlockSectors() , m_hSubtask);

    if( FAILED( hr ) )
    {
        m_state = XONLC_STATE_DONE;
        m_hr = hr;
		FinishAsyncWorkPriv();
    }
    else
    {
        m_state = XONLC_STATE_WRITE;
    }

    return (hr);
}

//----------------------------------------------------------------------------
//
// Does the async work for IndexFlush operation
//
//----------------------------------------------------------------------------
HRESULT CCacheTask::DoIndexFlush()
{
    HRESULT                     hr = S_OK;


	if( XONLC_STATE_DONE == m_state )
    {
        // One more loop in dowork ... nothing to be done anymore
		Assert(NULL == m_hSubtask);
        return (m_hr);
    }

	Assert(NULL != m_hCache);

    do
    {
        Assert(NULL != m_hSubtask);

        // We will pump until the write returns
        m_hr = m_pXo->XOnlineTaskContinue(m_hSubtask);

        if(XONLINETASK_S_RUNNING != m_hr)
        {
            m_state = XONLC_STATE_DONE;

            if (FAILED(m_hr))
            {
                break;
            }

            // Check the write results
            hr = CheckReadWrite(m_hCache->GetFirstBlockSize());

            if( FAILED( hr ) )
            {
                m_hr = hr;
            }
        }
    }
    while(FALSE);

    if( XONLC_STATE_DONE == m_state )
    {
        FinishAsyncWork();

    }

    return(m_hr);
}

//----------------------------------------------------------------------------
//
// Starts the async work for Retrieve operation
//
//----------------------------------------------------------------------------
HRESULT CCacheTask::DoRetrieveBegin()
{
    HRESULT                     hr = S_OK;

    Assert(m_hCache != NULL);

    Assert(NULL == m_hSubtask);

    //
    // Assign a file operation task
    //
    m_hSubtask = m_hCache->GetFileIOSubtaskHandle();

    hr = m_hCache->StartRetrieve(m_pContext , m_hSubtask);

    if( FAILED( hr ) )
    {
        m_hr = hr;
        m_state = XONLC_STATE_DONE;
		FinishAsyncWorkPriv();
    }
    else
    {
        m_state = XONLC_STATE_RETRIEVE;
    }

    return (hr);

}

//----------------------------------------------------------------------------
//
// Does the async work for Retrieve operation
//
//----------------------------------------------------------------------------
HRESULT CCacheTask::DoRetrieve()
{
    HRESULT                     hr = S_OK;

    Assert(NULL != m_hCache);

	if( XONLC_STATE_DONE == m_state )
    {
        // One more loop in dowork ... nothing to be done anymore
		Assert(NULL == m_hSubtask);
        return (m_hr);
    }

    do
    {
        Assert(NULL != m_hSubtask);

        // We will pump until the read returns
        m_hr = m_pXo->XOnlineTaskContinue(m_hSubtask);

        if(XONLINETASK_S_RUNNING != m_hr)
        {
            if (FAILED(m_hr))
            {
                m_state = XONLC_STATE_DONE;
                break;
            }

            if( XONLC_STATE_CONT_RETRIEVE == m_state )
            {
                //
                // Finished CONT_RETRIEVE
                //
                m_state = XONLC_STATE_DONE;
            }

            if( XONLC_STATE_RETRIEVE == m_state )
            {
                //
                // If more data to be retrieved from disk...
                //
                if( m_hCache->ContinueRetrieve(m_pContext) )
                {
                    // Check the read results
                    hr = CheckRetrievedSectors(FALSE);

                    if( SUCCEEDED( hr ) )
                    {
                        //
                        // Reuse task handle
                        //
                        m_hSubtask = NULL;

                        //
                        // Assign a file operation task
                        //
                        m_hSubtask = m_hCache->GetFileIOSubtaskHandle();
                        
                        hr = m_hCache->FinishRetrieve(m_pContext , m_hSubtask);

                        if( SUCCEEDED( hr ) )
                        {
                            //
                            // Jump to CONT_RETRIEVE state
                            //
                            m_hr = XONLINETASK_S_RUNNING;           
                            m_state = XONLC_STATE_CONT_RETRIEVE;
                        }
                    }

                    if( FAILED( hr ))
                    {
                        //
                        // Invalidate index entry
                        //
                        m_hCache->DeleteCurrentIndexEntry();
                        break;
                    }
                }
                else
                {
                    //
                    // No more data to be retrieved from disk ... 
                    //
                    m_state = XONLC_STATE_DONE;
                }
            }

            if(XONLC_STATE_DONE == m_state)
            {
                // Check the read results
                hr = CheckRetrievedSectors(TRUE);

                if( SUCCEEDED( hr ) )
                {
                    //
                    // Check record for integrity
                    //
                    hr = m_hCache->CheckRetrieveResults(m_pContext);
                }

                if( FAILED( hr ) )
                {
                    //
                    // Invalidate index entry
                    //
                    m_hCache->DeleteCurrentIndexEntry();
                }
                else
                {
                    //
                    // Update MRU list in memory -  no more writing to disk at this time(lazy update)
                    //
                    m_hCache->UpdateMRUList(m_pContext->pbIndexData, m_pContext->pbRecordBuffer);
                }
            }
        }
    }
    while(FALSE);

    if( FAILED( hr ) )
    {
        m_hr = hr;
        m_state = XONLC_STATE_DONE;
    }

    if(XONLC_STATE_DONE == m_state)
    {
        FinishAsyncWork();
    }

    return(m_hr);
}

//----------------------------------------------------------------------------
//
// Starts async work for Reset operation
//
//----------------------------------------------------------------------------
HRESULT CCacheTask::DoResetCacheBegin()
{
    HRESULT                     hr = S_OK;

    Assert(m_hCache != NULL);

    Assert(NULL == m_hSubtask);

    m_hCache->InitializeFirstBlock();

    m_hSubtask = m_hCache->GetFileIOSubtaskHandle();

    hr = m_hCache->StartFirstBlockDownload(m_hCache->GetFirstBlockSectors() , m_hSubtask);

    if( FAILED( hr ) )
    {
        m_state = XONLC_STATE_DONE;
        m_hr = hr;
		FinishAsyncWorkPriv();
    }
    else
    {
        m_state = XONLC_STATE_WRITE;
    }

    return (hr);

}

//----------------------------------------------------------------------------
//
// Does the async work for Reset operation
//
//----------------------------------------------------------------------------
HRESULT CCacheTask::DoResetCache()
{
    HRESULT                     hr = S_OK;

	Assert(NULL != m_hCache);

	if( XONLC_STATE_DONE == m_state )
    {
        // One more loop in dowork ... nothing to be done anymore
		Assert(NULL == m_hSubtask);
        return (m_hr);
    }

    do
    {
        Assert(NULL != m_hSubtask);

        // We will pump until the write returns
        m_hr = m_pXo->XOnlineTaskContinue(m_hSubtask);

        if(XONLINETASK_S_RUNNING != m_hr)
        {
            m_state = XONLC_STATE_DONE;

            if (FAILED(m_hr))
            {
                break;
            }

            // Check the write results
            hr = CheckReadWrite(m_hCache->GetFirstBlockSize());
                
            if( FAILED( hr ) )
            {
                m_hr = hr;
            }
        }
    }
    while(FALSE);

    if(XONLC_STATE_DONE == m_state)
    {
        FinishAsyncWork();
    }

    return(m_hr);
}

//----------------------------------------------------------------------------
//
// Starts the async job for Close operation
//
//----------------------------------------------------------------------------
HRESULT CCacheTask::DoCloseCacheBegin()
{
    HRESULT                     hr = S_OK;

    Assert(m_hCache != NULL);

    Assert(NULL == m_hSubtask);


    m_hSubtask = m_hCache->GetFileIOSubtaskHandle();

    hr = m_hCache->StartFirstBlockDownload(m_hCache->GetFirstBlockSectors() , m_hSubtask);

    if( FAILED( hr ) )
    {
        m_hCache->Delete();
        m_hCache = NULL;
        m_state = XONLC_STATE_DONE;
        m_hr = hr;

		FinishAsyncWorkPriv();
    }
    else
    {
        m_state = XONLC_STATE_WRITE;
    }

    return (hr);
}

//----------------------------------------------------------------------------
//
// Does the async work for Close operation
//
//----------------------------------------------------------------------------
HRESULT CCacheTask::DoCloseCache()
{
    HRESULT                     hr = S_OK;


	if( XONLC_STATE_DONE == m_state )
    {
        // One more loop in dowork ... nothing to be done anymore
		Assert(NULL == m_hSubtask);
        return (m_hr);
    }

	Assert(NULL != m_hCache);

    do
    {
        Assert(NULL != m_hSubtask);

        // We will pump until the write returns
        m_hr = m_pXo->XOnlineTaskContinue(m_hSubtask);

        if(XONLINETASK_S_RUNNING != m_hr)
        {
            m_state = XONLC_STATE_DONE;

            if (FAILED(m_hr))
            {
                break;
            }

            // Check the write results
            hr = CheckReadWrite(m_hCache->GetFirstBlockSize());

            if( FAILED( hr ) )
            {
                m_hr = hr;
            }
        }
    }
    while(FALSE);

    if( XONLC_STATE_DONE == m_state )
    {
        FinishAsyncWork();

        m_hCache->Delete();
        m_hCache = NULL;
   }

    return(m_hr);
}

//----------------------------------------------------------------------------
//
// Starts async work for UpdateMRUList
//
//----------------------------------------------------------------------------
HRESULT CCacheTask::DoUpdateMRUListPrivBegin()
{
    HRESULT                     hr = S_OK;

    Assert(m_hCache != NULL);

    Assert(NULL == m_hSubtask);

    //
    // Updates MRU List in memory
    //
    m_hCache->UpdateMRUList(m_pbIndexData , m_pbRecord);

    m_hSubtask = m_hCache->GetFileIOSubtaskHandle();

    hr = m_hCache->StartFirstBlockDownload(m_hCache->GetMRUListSectors() , m_hSubtask);

    if( FAILED( hr ) )
    {
        m_hr = hr;
        m_state = XONLC_STATE_DONE;
		
		FinishAsyncWorkPriv();
    }
    else
    {
        m_state = XONLC_STATE_WRITE;
    }

    return (hr);
}

//----------------------------------------------------------------------------
//
// Core function for UpdateMRU List
//
//----------------------------------------------------------------------------
HRESULT CCacheTask::DoUpdateMRUListPriv()
{
    HRESULT                     hr = S_OK;
    ULARGE_INTEGER              uliOrigin;
    DWORD                       dwSize = 0;
    CAddress                    workAddress;

	Assert(NULL != m_hCache);

	if( XONLC_STATE_DONE == m_state )
    {
        // One more loop in dowork ... nothing to be done anymore
		Assert(NULL == m_hSubtask);
        return (m_hr);
    }

    do
    {
        Assert(NULL != m_hSubtask);

        // We will pump until the write returns
        m_hr = m_pXo->XOnlineTaskContinue(m_hSubtask);

        if(XONLINETASK_S_RUNNING != m_hr)
        {
            m_state = XONLC_STATE_DONE;

            if (FAILED(m_hr))
            {
                break;
            }

            // Check the write results
            hr = CheckReadWrite(XBOX_HD_SECTOR_SIZE * m_hCache->GetMRUListSectors());

        }
    }
    while(FALSE);

    if( FAILED( hr ) )
    {
        m_hr = hr;
    }

    if(XONLC_STATE_DONE == m_state)
    {
        FinishAsyncWorkPriv();
    }

    return(m_hr);
}

//----------------------------------------------------------------------------
//
// Starts async work for UpdateIndex operation
//
//----------------------------------------------------------------------------
HRESULT CCacheTask::DoUpdateIndexPrivBegin()
{
    HRESULT                     hr = S_OK;

    Assert(m_hCache != NULL);

    Assert(NULL == m_hSubtask);

    m_hSubtask = m_hCache->GetFileIOSubtaskHandle();

    hr = m_hCache->StartWriteCurrentIndexEntry(m_pbIndexData , m_hSubtask);

    if( FAILED( hr ) )
    {
        m_hr = hr;
        m_state = XONLC_STATE_DONE;

        FinishAsyncWorkPriv();
    }
    else
    {
        m_state = XONLC_STATE_WRITE;
    }

    return (hr);
}

//----------------------------------------------------------------------------
//
// Core function for UpdateIndex
//
//----------------------------------------------------------------------------
HRESULT CCacheTask::DoUpdateIndexPriv()
{
    HRESULT                     hr = S_OK;

	Assert(NULL != m_hCache);

	if( XONLC_STATE_DONE == m_state )
    {
        // One more loop in dowork ... nothing to be done anymore
		Assert(NULL == m_hSubtask);
        return (m_hr);
    }

    do
    {
        Assert(NULL != m_hSubtask);

        // We will pump until the write returns
        m_hr = m_pXo->XOnlineTaskContinue(m_hSubtask);

        if(XONLINETASK_S_RUNNING != m_hr)
        {
            m_state = XONLC_STATE_DONE;

            if (FAILED(m_hr))
            {
                break;
            }


            // Check the read/write results
            hr = CheckReadWrite(XBOX_HD_SECTOR_SIZE);
        }
    }
    while(FALSE);

    if( FAILED( hr ) )
    {
        m_hr = hr;
    }

    if(XONLC_STATE_DONE == m_state)
    {
        FinishAsyncWorkPriv();
    }

    return(m_hr);
}

//----------------------------------------------------------------------------
//
// Starts async work for UpdateRecord
//
//----------------------------------------------------------------------------
HRESULT CCacheTask::DoUpdateRecordPrivBegin()
{
    HRESULT                     hr = S_OK;
    CAddress                    workAddress;

    Assert(m_hCache != NULL);

    Assert(NULL == m_hSubtask);

    //
    // Get first chunk of maximum XONLC_MAX_BUFFERS sectors
    //
    m_hCache->GetWorkAddress(&workAddress);

    //
    // Update first chunk, write check byte
    //
    m_hCache->MarkFirstUpdateChunk();

    m_hSubtask = m_hCache->GetFileIOSubtaskHandle();

    hr = UpdateNewChunk(&workAddress);

    if( FAILED( hr ) )
    {
        m_hr = hr;
        m_state = XONLC_STATE_DONE;

		FinishAsyncWorkPriv();
    }

    return (hr);
}

//----------------------------------------------------------------------------
//
// Core function for UpdateRecord
//
//----------------------------------------------------------------------------
HRESULT CCacheTask::DoUpdateRecordPriv()
{
    HRESULT                     hr = S_OK;
    ULARGE_INTEGER              uliOrigin;
    DWORD                       dwSize = 0;
    CAddress                    workAddress;

	Assert(NULL != m_hCache);

	if( XONLC_STATE_DONE == m_state )
    {
        // One more loop in dowork ... nothing to be done anymore
		Assert(NULL == m_hSubtask);
        return (m_hr);
    }

    //
    // Get first chunk of maximum XONLC_MAX_BUFFERS sectors
    //
    m_hCache->GetWorkAddress(&workAddress);

    do
    {
        Assert(NULL != m_hSubtask);

        // We will pump until the write returns
        m_hr = m_pXo->XOnlineTaskContinue(m_hSubtask);

        if(XONLINETASK_S_RUNNING != m_hr)
        {
            if (FAILED(m_hr))
            {
                m_state = XONLC_STATE_DONE;
                break;
            }
                
            // Check the write results
            hr = CheckReadWrite((workAddress.dwSectorEnd - workAddress.dwSectorBegin +  1) *
                                sizeof(CSector));

            if (FAILED(hr))
            {
                break;
            }

            //
            // Reuse task handle
            //
            m_hSubtask = NULL;

            if( XONLC_STATE_READ == m_state )
            {
                //
                // Write the info back to the disk
                //
                m_hSubtask = m_hCache->GetFileIOSubtaskHandle();
                hr = m_hCache->WriteSectors(&workAddress , &m_pbRecord , m_hSubtask); 

                if( SUCCEEDED( hr ) )
                {
                    m_hr = XONLINETASK_S_RUNNING;
                    m_state = XONLC_STATE_WRITE;
                }
            }
            else // XONLC_STATE_WRITE
            {
                if( m_hCache->ContinueUpdateRecord() )
                {
                    //
                    // There is more work to do - current address in cache was modified
                    //
                    m_hCache->GetWorkAddress(&workAddress);

                    m_hSubtask = m_hCache->GetFileIOSubtaskHandle();
                    hr = UpdateNewChunk(&workAddress);

                    if( SUCCEEDED( hr ) )
                    {
                        m_hr = XONLINETASK_S_RUNNING;
                    }
                }
                else
                {
                    m_state = XONLC_STATE_DONE;
                }
            }
        }
    }
    while(FALSE);

    if( FAILED( hr ) )
    {
        m_hr = hr;
        m_state = XONLC_STATE_DONE;
    }

    if(XONLC_STATE_DONE == m_state)
    {
        FinishAsyncWorkPriv();
    }

    return(m_hr);
}

//----------------------------------------------------------------------------
//
// Checks if the size read/written is correct
//
//----------------------------------------------------------------------------
HRESULT CCacheTask::CheckReadWrite( IN DWORD dwExpectedSize )
{
    DWORD dwSize = 0;
    HRESULT hr = S_OK;

    Assert(NULL != m_hSubtask);

    hr = m_pXo->GetReadWriteFileResults(m_hSubtask, &dwSize, NULL);

    if( SUCCEEDED( hr ) )
    {
        if( dwSize != dwExpectedSize )
        {
            hr = E_FAIL;
        }
    }

    return(hr);
}

//----------------------------------------------------------------------------
//
// Checks if the retrieved sectors are valid
//
//----------------------------------------------------------------------------
HRESULT CCacheTask::CheckRetrievedSectors(BOOL bLastChunk)
{
    HRESULT hr = S_OK;

    DWORD dwSize = m_hCache->GetExpectedRetrieveSize(m_pContext , bLastChunk);
    
    hr = CheckReadWrite(dwSize);

    if( SUCCEEDED( hr ) )
    {
        hr = m_hCache->CheckRetrievedSectorsIntegrity(m_pContext , bLastChunk);
    }

    return (hr);

}

//----------------------------------------------------------------------------
//
// Starts async job for new chunk of record
//
//----------------------------------------------------------------------------
HRESULT CCacheTask::UpdateNewChunk(IN CAddress *pAddress)
{

    HRESULT hr = S_OK;

    Assert(NULL != m_hSubtask);

    if( (0 != pAddress->dwOffsetBegin) || (XONLC_UTIL_SECTOR_SIZE - 1 != pAddress->dwOffsetEnd))
    {
        //
        // There is some information in the sectors that needs to be preserved
        //
        //
        // Read the sectors that will be modified from disk
        //
        hr = m_hCache->ReadSectors( pAddress, m_hSubtask);

        m_state = XONLC_STATE_READ;

    }
    else
    {
        //
        // Directly write the sectors to the disk
        //
        hr = m_hCache->WriteSectors(pAddress , &m_pbRecord , m_hSubtask); 

        m_state = XONLC_STATE_WRITE;
    }

    return(hr);
}

//----------------------------------------------------------------------------
//
// Finish async work when state is XONLC_STATE_DONE
//
//----------------------------------------------------------------------------
VOID CCacheTask::FinishAsyncWork()
{
    m_hSubtask = NULL;

    if( NULL != m_hCache )
    {
        m_hCache->UnlockCache();
    }
}

//----------------------------------------------------------------------------
//
// Forces the task to completion 
//
//----------------------------------------------------------------------------
VOID CCacheTask::ForceCompletion()
{
   //
   // Some subtask involving the cache is in progress
   //
   if( NULL != m_hCache )
   {
	   if( m_hCache->IsCacheLocked() )
       {
		   if(NULL != m_hSubtask)
		   {
			   //
               // The subtask needs to be pumped - else, just unlock the cache
               //
			   do
			   {
				   m_hr = m_pXo->XOnlineTaskContinue(m_hSubtask);
			   }
			   while(XONLINETASK_S_RUNNING == m_hr);
		   }

		   // 
           //Unlock the cache so that it can be closed with an sync CacheClose() call
	       //
		   m_hCache->UnlockCache(); 
       }
  }
}

//----------------------------------------------------------------------------
//
// Finish async work when state is XONLC_STATE_DONE - used in the Priv async functions
// Doesn't unlock the cache
//
//----------------------------------------------------------------------------
VOID CCacheTask::FinishAsyncWorkPriv()
{
    m_hSubtask = NULL;
}

//////////////////////////////////////////////////////////////////////////////
//
// CLocalCache implementation
//
//////////////////////////////////////////////////////////////////////////////

void CLocalCache::Delete()
{
    Assert(this == m_pXo->m_xonCacheHandles[m_cacheType]);

    //
    // Close the cache file handle 
    //
    if( INVALID_HANDLE_VALUE != m_hCacheFile )
    {
        CloseHandle(m_hCacheFile);
    }

    //
    // Release the memory that holds the Header, MRU list and Index
    //
    if( NULL != m_pbMemoryBlock )
    {
        m_pXo->SysFree(m_pbMemoryBlock);
    }

    //
    // Last thing, release the cache handle 
    //
    m_pXo->m_xonCacheHandles[m_cacheType] = NULL;

    m_pXo->SysFree(this);
}

//----------------------------------------------------------------------------
//
// Allocates memory for the cache
//
//----------------------------------------------------------------------------

HRESULT CLocalCache::Initialize(XONLC_TYPE type , PFNXONLC_COMPARE_HANDLER pfnCompare, HANDLE hWorkEvent, CXo * pXo)
{
    HRESULT  hr = S_OK;
    
    m_cacheType = type;
    m_hCacheFile = INVALID_HANDLE_VALUE;
    m_pfnCompareFunc = pfnCompare;
    m_hWorkEvent = hWorkEvent;
    m_pXo = pXo;
    m_cacheSubtask.InitializeContext(this, hWorkEvent, pXo);

    do
    {
        //
        // Initializes the offset for index and cached data within the util space (504/sector)
        //
        ComputeCacheOffsets();

        //
        // Allocates memory for the first block
        //
        DWORD dwSectorsCount = ComputeFirstBlockSectorsCount();
        m_pbMemoryBlock = (CSector *)pXo->SysAlloc(sizeof(CSector) * dwSectorsCount, PTAG_CSector);
            
        if( NULL == m_pbMemoryBlock )
        {
            hr = E_OUTOFMEMORY;
            break;
        }
        
        m_dwMemoryBlockSectors = dwSectorsCount;
        
        //
        // Pointer to the header
        //
        m_pHeader = (CHeader*)((m_pbMemoryBlock[0]).pbUtilSectorSpace);

    }
    while( FALSE );
    
    return( hr );

}

//----------------------------------------------------------------------------
//
// Writes the first block for a new created/reset cache file 
//
//----------------------------------------------------------------------------
VOID CLocalCache::InitializeFirstBlock( )
{
    Assert( 0 != m_dwIndexOffset);

    memset(m_pbMemoryBlock , 0 , m_dwMemoryBlockSectors * XBOX_HD_SECTOR_SIZE);

    m_pHeader->dwMaxCachedItems = g_xonCacheParams[m_cacheType][XONLC_PARAMS_MAX_CACHED_ITEMS];
    m_pHeader->dwMRUListSize = g_xonCacheParams[m_cacheType][XONLC_PARAMS_MRU_LIST_SIZE];
    m_pHeader->cbIndexDataSize = g_xonCacheParams[m_cacheType][XONLC_PARAMS_INDEX_DATA_SIZE];
    m_pHeader->cbKeyDataSize = g_xonCacheParams[m_cacheType][XONLC_PARAMS_KEY_DATA_SIZE];
    m_pHeader->cbCachedDataSize = g_xonCacheParams[m_cacheType][XONLC_PARAMS_CACHED_DATA_SIZE];
    m_pHeader->dwTimestampIncrement = 1;

    for( DWORD i = 0 ; i < m_pHeader->dwMRUListSize ; i++ )
    {
        GetMRUItemAddress( i );

        //
        // Mark first character as '*' - available
        //
        MarkCurrentEntryAsAvailable();
    }

    for( i = 0 ; i < m_pHeader->dwMaxCachedItems ; i++)
    {
        GetIndexItemAddress( i );

        //
        // Mark first character as '*' - available
        //
        MarkCurrentEntryAsAvailable();

    }
  
}

//----------------------------------------------------------------------------
//
// Open cache file on disk
//
//----------------------------------------------------------------------------
HRESULT CLocalCache::OpenCacheFile()
{
    Assert(m_hCacheFile == INVALID_HANDLE_VALUE);

    HRESULT hr = S_OK;
    BOOL bDone;

    NTSTATUS Status = 0;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    OBJECT_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    
    char szFileName[500];
    sprintf(szFileName , "\\Device\\Harddisk0\\partition1\\CACHE\\LocalCache%02d.bin" , m_cacheType);

    do
    {
        bDone = TRUE;

        //
        // Open cache file on disk
        //
        RtlInitObjectString(&FileName, szFileName);

        InitializeObjectAttributes(
                        &Obja,
                        &FileName,
                        OBJ_CASE_INSENSITIVE,
                        NULL,
                        NULL
                        );

        DWORD dwDesiredAccess = GENERIC_READ | GENERIC_WRITE;

        Status = m_pXo->NtCreateFile(&m_hCacheFile,
                    (ACCESS_MASK)dwDesiredAccess | SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                    &Obja,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ,
                    FILE_OPEN_IF,
                    FILE_NON_DIRECTORY_FILE | FILE_NO_INTERMEDIATE_BUFFERING | FILE_SYNCHRONOUS_IO_NONALERT
                    );

        if ( INVALID_HANDLE_VALUE == m_hCacheFile )
        {
            if( Status == STATUS_OBJECT_PATH_NOT_FOUND )
            {
                char lpPathName[500];
                sprintf(lpPathName , "\\Device\\Harddisk0\\partition1\\CACHE\\");

                RtlInitObjectString(&FileName, lpPathName);

                InitializeObjectAttributes(
                    &Obja,
                    &FileName,
                    OBJ_CASE_INSENSITIVE,
                    NULL,
                    NULL
                    );

                Status = m_pXo->NtCreateFile(
                            &Handle,
                            FILE_LIST_DIRECTORY | SYNCHRONIZE,
                            &Obja,
                            &IoStatusBlock,
                            NULL,
                            FILE_ATTRIBUTE_NORMAL,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            FILE_CREATE,
                            FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                            );

                if ( NT_SUCCESS(Status) ) 
                {
                    NtClose(Handle);
                    bDone = FALSE;
                }
                else 
                {
                    hr = HRESULT_FROM_WIN32(RtlNtStatusToDosError(Status));
                }

            }
            else
            {
                hr = HRESULT_FROM_WIN32(RtlNtStatusToDosError(Status));
            }
        }
        else
        {
            //
            // File opened/created
            //
            if(IoStatusBlock.Information == FILE_OPENED)
            {
                SetLastError(ERROR_ALREADY_EXISTS);
            }
        }
    }
    while(!bDone);

    return(hr);
}

//----------------------------------------------------------------------------
//
// Makes sure there is enough space on disk for a new created cache - initializes first block
//
//----------------------------------------------------------------------------
HRESULT CLocalCache::PrepareNewCache()
{
    HRESULT hr = S_OK;

    //
    // We know exactly how much data to cache.
    // 
    DWORD dwAlignedSize = GetTotalSectors() * XBOX_HD_SECTOR_SIZE;

    hr = m_pXo->SetEndOfFileNt( m_hCacheFile, dwAlignedSize);
    if( SUCCEEDED( hr ) )
    {
        InitializeFirstBlock();
    }

    return(hr);

}

//----------------------------------------------------------------------------
//
// Retrieves the address for the specified MRU list item
//
//----------------------------------------------------------------------------
BOOL CLocalCache::GetMRUItemAddress(IN DWORD dwPos)
{
    if(dwPos < m_pHeader->dwMRUListSize)
    {
        DWORD dwMRUItemBegin = sizeof(CHeader) + dwPos * GetMRUItemSize();
        DWORD dwMRUItemEnd = dwMRUItemBegin + GetMRUItemSize() - 1;

        m_currentAddress.FillAddress(dwMRUItemBegin, dwMRUItemEnd, dwPos);
        return TRUE;
    }

    return FALSE;

}

//----------------------------------------------------------------------------
//
// Retrieves the address for the specified index item
//
//----------------------------------------------------------------------------
BOOL CLocalCache::GetIndexItemAddress( IN DWORD dwPos )
{
    if(dwPos < m_pHeader->dwMaxCachedItems)
    {
        DWORD dwIndexItemSize = GetIndexEntrySize();
        DWORD dwIndexItemBegin = m_dwIndexOffset;
        DWORD dwIndexSpaceToSkip = dwPos * dwIndexItemSize;
        DWORD dwSizeLeftFromSector = XONLC_UTIL_SECTOR_SIZE - m_dwIndexOffset % XONLC_UTIL_SECTOR_SIZE;
        
        while(dwIndexSpaceToSkip > dwSizeLeftFromSector)
        {
            DWORD dwUtilSpace = dwSizeLeftFromSector - dwSizeLeftFromSector % dwIndexItemSize;
            dwIndexSpaceToSkip -= dwUtilSpace;
            dwIndexItemBegin += dwSizeLeftFromSector;

            dwSizeLeftFromSector = XONLC_UTIL_SECTOR_SIZE;
        }

        if( dwSizeLeftFromSector - dwIndexSpaceToSkip >= dwIndexItemSize )
        {
            dwIndexItemBegin += dwIndexSpaceToSkip;
        }
        else
        {
            dwIndexItemBegin += dwSizeLeftFromSector;
        }
        
        DWORD dwIndexItemEnd = dwIndexItemBegin + dwIndexItemSize - 1;

        m_currentAddress.FillAddress(dwIndexItemBegin, dwIndexItemEnd, dwPos);
        return TRUE;
    }

    return FALSE;
}

//----------------------------------------------------------------------------
//
// Retrieves the address for the specified record
//
//----------------------------------------------------------------------------
BOOL CLocalCache::GetRecordAddressFromCurrentAddress( )
{
    if(m_dwCurrentIndexPos < m_pHeader->dwMaxCachedItems)
    {
        DWORD dwCacheItemBegin = m_dwCachedDataOffset + m_dwCurrentIndexPos * GetRecordSize();
        DWORD dwCacheItemEnd = dwCacheItemBegin + GetRecordSize() - 1;

        m_currentAddress.FillAddress(dwCacheItemBegin, dwCacheItemEnd, m_dwCurrentIndexPos);
        return TRUE;
    }

    return FALSE;
}

//----------------------------------------------------------------------------
//
// Prepares the sectors in the specified range for writing on disk 
//
//----------------------------------------------------------------------------
VOID CLocalCache::PrepareSectorsForWrite(
        IN CSector                *pbMemoryBlock,
        IN DWORD                  dwSectorIndexBegin,
        IN DWORD                  dwSectorIndexEnd
        )
{
    Assert(NULL != pbMemoryBlock);
    Assert(dwSectorIndexBegin <= dwSectorIndexEnd);
    Assert(dwSectorIndexEnd < GetTotalSectors());


    for( DWORD dwPos = dwSectorIndexBegin ; dwPos <= dwSectorIndexEnd ; dwPos++)
    {
#ifdef XONLINE_FEATURE_XBOX 

		XCALCSIG_SIGNATURE Signature;
		HANDLE hSig = NULL;

 		// Compute signature
		hSig = XCalculateSignatureBegin(XCALCSIG_FLAG_NON_ROAMABLE);
		XCalculateSignatureUpdate(hSig, 
			                      (PBYTE)pbMemoryBlock[dwPos].pbUtilSectorSpace, 
			                      XONLC_UTIL_SECTOR_SIZE);
		XCalculateSignatureEnd(hSig, &Signature);

		memcpy(pbMemoryBlock[dwPos].pbSignature , &Signature , XONLC_SIGNATURE_SIZE);
#else
		memset(pbMemoryBlock[dwPos].pbSignature , 0 , XONLC_SIGNATURE_SIZE );
#endif
    }

}

//----------------------------------------------------------------------------
//
// Computes the number of sectors needed to store the info with the given size
//
//----------------------------------------------------------------------------
DWORD CLocalCache::ComputeSectorsCount( IN DWORD dwSize )
{
    Assert(0 != dwSize);

    DWORD dwSectorsCount = (dwSize - 1) / XONLC_UTIL_SECTOR_SIZE;
    if( 0 != (dwSize - 1) % XONLC_UTIL_SECTOR_SIZE )
    {
        dwSectorsCount++;
    }
    return dwSectorsCount;

}

//----------------------------------------------------------------------------
//
// Gets the total number of sectors for the file on disk
//
//----------------------------------------------------------------------------
DWORD CLocalCache::GetTotalSectors ()
{
    DWORD dwCacheSize = m_dwCachedDataOffset;
    if( HasRecords() )
    {
        dwCacheSize += GetMaxCachedItems() * GetRecordSize();
    }
    
    return ComputeSectorsCount(dwCacheSize);
}

//----------------------------------------------------------------------------
//
// Computes the offsets for index and cached records
//
//----------------------------------------------------------------------------
VOID CLocalCache::ComputeCacheOffsets()
{
    DWORD dwIndexItemSize = GetIndexEntrySize();

    m_dwIndexOffset = sizeof(CHeader) + GetMRUListSize() * GetMRUItemSize();
    
    DWORD dwSizeLeftFromSector = XONLC_UTIL_SECTOR_SIZE - m_dwIndexOffset % XONLC_UTIL_SECTOR_SIZE;
    if( dwSizeLeftFromSector < dwIndexItemSize )
    {
        //
        // Index entries don't span
        //
        m_dwIndexOffset += dwSizeLeftFromSector;
        dwSizeLeftFromSector = XONLC_UTIL_SECTOR_SIZE;
    }


    m_dwCachedDataOffset = m_dwIndexOffset;

    DWORD dwIndexSize = GetMaxCachedItems() * dwIndexItemSize;

    while(dwIndexSize > dwSizeLeftFromSector)
    {
        DWORD dwUtilSpace = dwSizeLeftFromSector - dwSizeLeftFromSector % dwIndexItemSize;
        dwIndexSize -= dwUtilSpace;
        m_dwCachedDataOffset += dwSizeLeftFromSector;

        dwSizeLeftFromSector = XONLC_UTIL_SECTOR_SIZE;
    }

    m_dwCachedDataOffset += dwIndexSize ;
}

//----------------------------------------------------------------------------
//
// Checks the parameters for this uploaded cache
//
//----------------------------------------------------------------------------
BOOL CLocalCache::IsCacheCorrupted()
{
    //
    // Verify the information in header 
    //
    if( m_pHeader->dwMaxCachedItems != g_xonCacheParams[m_cacheType][XONLC_PARAMS_MAX_CACHED_ITEMS] )
    {
        return TRUE;
    }       
    if( m_pHeader->dwMRUListSize != g_xonCacheParams[m_cacheType][XONLC_PARAMS_MRU_LIST_SIZE] )
    {
        return TRUE;
    }       
    if( m_pHeader->cbIndexDataSize != g_xonCacheParams[m_cacheType][XONLC_PARAMS_INDEX_DATA_SIZE] )
    {
        return TRUE;
    }       
    if( m_pHeader->cbKeyDataSize != g_xonCacheParams[m_cacheType][XONLC_PARAMS_KEY_DATA_SIZE] )
    {
        return TRUE;
    }       
    if( m_pHeader->cbCachedDataSize != g_xonCacheParams[m_cacheType][XONLC_PARAMS_CACHED_DATA_SIZE] )
    {
        return TRUE;
    }       

    for( DWORD i = 0 ; i < m_dwMemoryBlockSectors ; i++ )
    {
        if( IsSectorCorrupted( m_pbMemoryBlock , i ) )
        {
            return TRUE;
        }
    }

    return FALSE;

}

//----------------------------------------------------------------------------
//
// Searches the MRU List for the key specified in pContext
//
//----------------------------------------------------------------------------
BOOL CLocalCache::FindInMRUList(
            IN BOOL                               bOverwrite, // overwrite pContext->pbIndexData
            OUT PXONLC_CONTEXT                    pContext  
            )
{
    PBYTE pbCandidateIndexEntry = (PBYTE)m_pbBuffer;
    PBYTE pbTargetIndexData = pContext->pbIndexData;

    pContext->bValidDataInCache = FALSE;
    
    if( 0 == GetMRUListSize() )
    {
        //
        // No MRU List for this type
        //
        return FALSE;
    }

    Assert(1 == GetMRUListSize());

    GetMRUItemAddress( 0 );
        
    if( !IsCurrentEntryAvailable() )
     {
        //
        // Get the key 
        //
        GetDataFromCurrentAddress( GetIndexEntrySize(), 
                                    pbCandidateIndexEntry);

        pContext->bValidDataInCache = CompareIndexData(pbTargetIndexData , GetKey(pbCandidateIndexEntry));

        if(pContext->bValidDataInCache)
        {
            //
            // Copy the index data from the cache
            //
            if( bOverwrite )
            {
                memcpy(pContext->pbIndexData , 
                       GetIndexData(pbCandidateIndexEntry) , 
                       GetIndexDataSize());
            }
                
            BYTE bFirstCheckByte, bLastCheckByte;

            //
            // Get first check byte
            //
            GetDataFromCurrentAddress(sizeof(CHECKINFO) , (PBYTE)(&bFirstCheckByte));

            //
            // Set new m_dwCurrentIndexPos - Skip check byte
            //
            m_currentAddress.IncrementAddress(sizeof(CHECKINFO));
                        
            GetDataFromCurrentAddress(sizeof(INDEXPOS) , (PBYTE)(&m_dwCurrentIndexPos));

            pContext->bCallRetrieveNext = TRUE;

            m_currentAddress.IncrementAddress(sizeof(INDEXPOS) + GetIndexDataSize());

            if( GetCachedDataSize() > 0 )
            {
                if( NULL != pContext->pbRecordBuffer )
                {
                    //
                    // Copy the buffer from the MRU item
                    //
                    GetDataFromCurrentAddress(pContext->dwRecordBufferSize , pContext->pbRecordBuffer);
                    pContext->bCallRetrieveNext = FALSE;
                 }
            }
            else
            {
                pContext->bCallRetrieveNext = FALSE;
            }
                        
            //
            // Get to the last check byte
            //
            m_currentAddress.IncrementAddress(GetCachedDataSize());

            GetDataFromCurrentAddress(sizeof(CHECKINFO) , (PBYTE)(&bLastCheckByte));

            if( bFirstCheckByte != bLastCheckByte )
            {
                pContext->bValidDataInCache = FALSE;

                //
                // Delete entry from MRU List
                //
                GetMRUItemAddress(0);
                MarkCurrentEntryAsAvailable();
            }
        }
    }

    m_bFoundInMRUList = pContext->bValidDataInCache;

    return (pContext->bValidDataInCache);
}

//----------------------------------------------------------------------------
//
// Searches the index for the key specified in pContext
//
//----------------------------------------------------------------------------
BOOL CLocalCache::FindInIndex(
            IN BOOL                               bOverwrite, // overwrite pContext->pbIndexData
            OUT PXONLC_CONTEXT                    pContext  
            )
{
    BOOL bDontSaveAddress = FALSE;
    CAddress savedAddress;
    DWORD dwLRUTimestamp = 0xFFFFFFFF;

    PBYTE pbCandidateIndexEntry = (PBYTE)m_pbBuffer;
    PBYTE pbTargetIndexData = pContext->pbIndexData;

    pContext->bValidDataInCache = FALSE;
    
    
    m_dwCurrentIndexPos = 0;

    for( DWORD i = 0 ; (i < GetMaxCachedItems()) && (!(pContext->bValidDataInCache)) ; i++ )
    {
        GetIndexItemAddress( i );
        
        if(IsCurrentEntryAvailable())
        {
            if( !bDontSaveAddress )
            {
                //
                // Save the free address for future use
                //
                savedAddress = m_currentAddress;
                bDontSaveAddress = TRUE;
            }
        }
        else
        {
            //
            // Get the key 
            //
            GetDataFromCurrentAddress( GetIndexEntrySize(), 
                                       pbCandidateIndexEntry);

            pContext->bValidDataInCache = CompareIndexData(pbTargetIndexData , GetKey(pbCandidateIndexEntry));

            if(pContext->bValidDataInCache)
            {
                m_dwCurrentIndexPos = m_currentAddress.dwPosition;
                
                //
                // Copy the index data from the cache
                //
                if( bOverwrite )
                {
                    memcpy(pContext->pbIndexData , 
                           GetIndexData(pbCandidateIndexEntry) , 
                           GetIndexDataSize());
                }
                
                if( GetCachedDataSize() > 0  )
                {
                    pContext->bCallRetrieveNext = TRUE;
                }
                else
                {
                    pContext->bCallRetrieveNext = FALSE;
                }
            }
            else
            {
                //
                // Entry in use, save address applying LRU logic
                //
                if( !bDontSaveAddress )
                {
                    //
                    // No free entry found yet
                    //
                    if( dwLRUTimestamp >  GetTimestamp(pbCandidateIndexEntry) )
                    {
                        savedAddress = m_currentAddress;
                        dwLRUTimestamp = GetTimestamp(pbCandidateIndexEntry);
                    }
                    else
                    {
                        //
                        // This special case is encountered only when the TIMESTAMP data type resets
                        //
                        if( GetTimestamp(pbCandidateIndexEntry) >=  m_pHeader->dwTimestampIncrement)
                        {
                            savedAddress = m_currentAddress;
                            dwLRUTimestamp = 0;
                        }
                    }
                }
            }
        }

    } // end for

    if( !pContext->bValidDataInCache )
    {
        //
        // Key not found in cache - return as the current address, the saved address of an available entry
        //
        m_currentAddress = savedAddress;

        m_dwCurrentIndexPos = m_currentAddress.dwPosition;
    }

    return (pContext->bValidDataInCache);
}

//----------------------------------------------------------------------------
//
// Gets work address - first chunk for the cache buffer
//
//----------------------------------------------------------------------------
VOID CLocalCache::GetWorkAddress(CAddress *pAddress)
{
    Assert(NULL != pAddress);
    Assert(m_currentAddress.dwSectorEnd >= m_currentAddress.dwSectorBegin);

    *pAddress = m_currentAddress;

    //
    // The maximum number of sectors we can work with at some point is XONLC_MAX_BUFFERS
    //
    if( pAddress->dwSectorEnd - pAddress->dwSectorBegin >= XONLC_MAX_BUFFERS)
    {
        pAddress->dwSectorEnd = pAddress->dwSectorBegin + XONLC_MAX_BUFFERS - 1;
        pAddress->dwOffsetEnd = XONLC_UTIL_SECTOR_SIZE - 1;
    }

    pAddress->dwSize = XONLC_UTIL_SECTOR_SIZE * (pAddress->dwSectorEnd - pAddress->dwSectorBegin) +
                       pAddress->dwOffsetEnd + 1 -
                       pAddress->dwOffsetBegin;

}

//----------------------------------------------------------------------------
//
// Gets the data from a given address
//
//----------------------------------------------------------------------------
VOID CLocalCache::GetDataFromAddress(
        IN CSector             *pbSectors,
        IN CAddress            *pAddress,
        IN DWORD               dwDataSize,
        OUT PBYTE              pbData
        )
{
    Assert(NULL != pbSectors);
    Assert(NULL != pAddress);
    Assert(NULL != pbData);

    DWORD dwSpaceLeftInSector = XONLC_UTIL_SECTOR_SIZE - pAddress->dwOffsetBegin;
    PBYTE pbStartData = (pbSectors[pAddress->dwSectorBegin]).pbUtilSectorSpace + 
                         pAddress->dwOffsetBegin;

    while(dwSpaceLeftInSector <  dwDataSize)
    {
        //
        // The data spans two sectors
        //
        memmove(pbData, pbStartData , dwSpaceLeftInSector );

        pbStartData += XONLC_SIGNATURE_SIZE + dwSpaceLeftInSector;
        pbData +=dwSpaceLeftInSector;
        dwDataSize -= dwSpaceLeftInSector;
        dwSpaceLeftInSector = XONLC_UTIL_SECTOR_SIZE;
    }

    memmove(pbData, pbStartData, dwDataSize);

}

//----------------------------------------------------------------------------
//
// Reads sectors from disk - starts async job - address in m_hCache
//
//----------------------------------------------------------------------------
HRESULT CLocalCache::ReadSectors(
        IN CAddress                           *pAddress,
        IN XONLINETASK_HANDLE                 hTask
        )
{
    Assert(NULL != pAddress);
    Assert(NULL != hTask);

    ULARGE_INTEGER              uliOrigin;
    DWORD                       dwSectors;
    
    uliOrigin.QuadPart = pAddress->dwSectorBegin * XBOX_HD_SECTOR_SIZE;
    dwSectors = pAddress->dwSectorEnd - pAddress->dwSectorBegin + 1;

    m_pXo->ReadWriteFileInitializeContext(
                            m_hCacheFile,
                            (LPBYTE)m_pbBuffer,
                            dwSectors * XBOX_HD_SECTOR_SIZE,
                            uliOrigin,
                            m_hWorkEvent, 
                            (PXONLINETASK_FILEIO)hTask);

    return( m_pXo->ReadFileInternal((PXONLINETASK_FILEIO)hTask));
}

//----------------------------------------------------------------------------
//
// Write sectors to disk - starts async job - address in m_hCache
//
//----------------------------------------------------------------------------
HRESULT CLocalCache::WriteSectors(
        IN CAddress                           *pAddress,
        IN PBYTE                              *pbData,
        IN XONLINETASK_HANDLE                 hTask
        )
{
    Assert(NULL != pbData);
    Assert(NULL != pAddress);
    Assert(NULL != hTask);

    ULARGE_INTEGER              uliOrigin;
    DWORD                       dwSectors;
    
    uliOrigin.QuadPart = pAddress->dwSectorBegin * XBOX_HD_SECTOR_SIZE;
    dwSectors = pAddress->dwSectorEnd - pAddress->dwSectorBegin + 1;

    //
    // Write the info back to the disk
    //
    CAddress workAddress(*pAddress);
    
    workAddress.MakeRelativeAddress();


    *pbData = CopyDataToSectors(*pbData , &workAddress , XONLC_MAX_BUFFERS, WRITE_LAST_CHECK_BYTE , m_pbBuffer); 

    if( pAddress->dwSectorBegin == m_dwMemoryBlockSectors - 1 )
    {
        //
        // First sector in cache is the same as the last sector uploaded in memory
        //
        PBYTE pbDest = GetPointerInMemBlock(pAddress);
        PBYTE pbSource = GetPointerInBuffer(pAddress);
        memcpy (pbDest, pbSource , XONLC_UTIL_SECTOR_SIZE - pAddress->dwOffsetBegin);
     }

    PrepareSectorsForWrite(m_pbBuffer , 0 , dwSectors - 1);

    m_pXo->ReadWriteFileInitializeContext(
                            m_hCacheFile,
                            (LPBYTE)m_pbBuffer,
                            dwSectors * XBOX_HD_SECTOR_SIZE,
                            uliOrigin,
                            m_hWorkEvent, 
                            (PXONLINETASK_FILEIO)hTask);

    return( m_pXo->WriteFileInternal((PXONLINETASK_FILEIO)hTask));
}

//----------------------------------------------------------------------------
//
// Copies the cached record to sectors
//
//----------------------------------------------------------------------------
PBYTE CLocalCache::CopyDataToSectors(
        IN PBYTE               pbSrcData,
        IN CAddress            *pAddress,
        IN DWORD               dwMaxNumberOfBuffers,
        IN BOOL                bWriteLastCheckByte,
        OUT CSector            *pbDestData
        )
{
    Assert(NULL != pbSrcData);

    if( m_bUpdateFirstChunk )
    {
        //
        // Set beginning check byte
        //
        SetFirstCheckByte(pbDestData , pAddress);

        //
        // Set first chunk flag to FALSE
        //
        m_bUpdateFirstChunk = FALSE;

    }

    //
    // If this is the last chunk, write the check byte at the end of the record
    //
    if( bWriteLastCheckByte )
    {
        if( m_currentAddress.dwSectorEnd - m_currentAddress.dwSectorBegin < dwMaxNumberOfBuffers )
        {
            //
            // Set end check byte
            //
            SetLastCheckByte(pbDestData , pAddress);
        }
    }

    return CopyBufferToSectors(pbSrcData , pAddress , pbDestData);

}

//----------------------------------------------------------------------------
//
// Copies the info from a buffer into a sector array
//
//----------------------------------------------------------------------------
PBYTE CLocalCache::CopyBufferToSectors(
        IN PBYTE               pbSrcData,
        IN CAddress            *pAddress,
        OUT CSector            *pbDestData
        )
{
    Assert(NULL != pbSrcData);
    Assert(NULL != pbDestData);
    Assert(NULL != pAddress);

    DWORD dwDataSize = pAddress->dwSize;
    DWORD dwSpaceLeftInSector = XONLC_UTIL_SECTOR_SIZE - pAddress->dwOffsetBegin;
    PBYTE pbStartData = &((pbDestData[pAddress->dwSectorBegin]).pbUtilSectorSpace[pAddress->dwOffsetBegin]);

    while(dwSpaceLeftInSector <  dwDataSize)
    {
        //
        // The data spans two sectors
        //
        memcpy(pbStartData, pbSrcData , dwSpaceLeftInSector );

        pbStartData += XONLC_SIGNATURE_SIZE + dwSpaceLeftInSector;
        pbSrcData +=dwSpaceLeftInSector;
        dwDataSize -= dwSpaceLeftInSector;
        dwSpaceLeftInSector = XONLC_UTIL_SECTOR_SIZE;
    }

    memcpy(pbStartData, pbSrcData, dwDataSize);

    return (pbSrcData + dwDataSize);
}

//----------------------------------------------------------------------------
//
// Update the current index entry in memory
//
//----------------------------------------------------------------------------
VOID CLocalCache::UpdateCurrentIndexEntry(
        IN PBYTE                              pbIndexData
        )
{
    //
    // This function gets called after updating the record 
    //
    GetIndexItemAddress(m_dwCurrentIndexPos);

    Assert(m_currentAddress.dwSectorBegin == m_currentAddress.dwSectorEnd);

    PBYTE pbIndexEntry = GetCurrentIndexEntry();

    //
    // Write the check byte for record on disk
    //
    *(CHECKINFO*)(pbIndexEntry) = m_bCheckByte;

    //
    // Copy the core index entry
    //
    SetIndexData(pbIndexEntry , pbIndexData);
    
    //
    // Write timestamp
    //
    SetTimestamp(pbIndexEntry , (m_pHeader->dwTimestampIncrement++));

}

//----------------------------------------------------------------------------
//
// Starts writing the current index entry on disk
//
//----------------------------------------------------------------------------
HRESULT CLocalCache::StartWriteCurrentIndexEntry(
        IN PBYTE                              pbIndexData,
        IN XONLINETASK_HANDLE                 hTask
        )
{
    UpdateCurrentIndexEntry(pbIndexData);

    PrepareSectorsForWrite(m_pbMemoryBlock , m_currentAddress.dwSectorBegin , m_currentAddress.dwSectorEnd );

    ULARGE_INTEGER uliOrigin;

    uliOrigin.QuadPart = m_currentAddress.dwSectorBegin * XBOX_HD_SECTOR_SIZE;

    m_pXo->ReadWriteFileInitializeContext(
                            m_hCacheFile,
                            (LPBYTE)(&(m_pbMemoryBlock[m_currentAddress.dwSectorBegin])),
                            XBOX_HD_SECTOR_SIZE,
                            uliOrigin,
                            m_hWorkEvent,  
                            (PXONLINETASK_FILEIO)hTask);

    return( m_pXo->WriteFileInternal((PXONLINETASK_FILEIO)hTask));
}

//----------------------------------------------------------------------------
//
// Start retrieving a record
//
//----------------------------------------------------------------------------
HRESULT CLocalCache::StartRetrieve(
        IN PXONLC_CONTEXT                     pContext,
        IN XONLINETASK_HANDLE                 hTask
            )
{
    Assert(NULL != hTask);

    PBYTE pbIndexEntry = (PBYTE)m_pbBuffer;

    HRESULT hr = S_OK;
    
    do
    {
        GetIndexItemAddress(m_dwCurrentIndexPos);
        GetDataFromCurrentAddress(GetIndexEntrySize() , pbIndexEntry);

        
        if( !CompareIndexData( pContext->pbIndexData , GetKey( pbIndexEntry )))
        {
            //
            // Should call Lookup first
            //
            hr = E_FAIL;
            break;
        }
        
        m_bCheckByte = *(CHECKINFO*)pbIndexEntry;

        GetRecordAddressFromCurrentAddress();


        ULARGE_INTEGER              uliOrigin;
        DWORD                       dwSectors;
        PBYTE                       pbRetrieveBuffer;
                
        uliOrigin.QuadPart = m_currentAddress.dwSectorBegin * XBOX_HD_SECTOR_SIZE;

        //
        // Check if we can use the client's buffer
        //
        if( UsingClientBuffer(pContext) )
        {
            dwSectors = pContext->dwRecordBufferSize / XBOX_HD_SECTOR_SIZE;
            pbRetrieveBuffer = pContext->pbRecordBuffer;
        }       
        else
        {
            dwSectors = m_currentAddress.dwSectorEnd - m_currentAddress.dwSectorBegin + 1;

            Assert(dwSectors <= XONLC_MAX_BUFFERS);

            pbRetrieveBuffer = (PBYTE)m_pbBuffer;
        }

        m_pXo->ReadWriteFileInitializeContext(
                            m_hCacheFile,
                            pbRetrieveBuffer,
                            dwSectors * XBOX_HD_SECTOR_SIZE,
                            uliOrigin,
                            m_hWorkEvent,  
                            (PXONLINETASK_FILEIO)hTask);

        hr = m_pXo->ReadFileInternal((PXONLINETASK_FILEIO)hTask);

    }
    while( FALSE );
    
    return( hr );
    
}

//----------------------------------------------------------------------------
//
// Finish retrieving a record
//
//----------------------------------------------------------------------------
HRESULT CLocalCache::FinishRetrieve(
            IN PXONLC_CONTEXT                     pContext,
            IN XONLINETASK_HANDLE                 hTask
            )
{
    HRESULT hr = S_OK;

    Assert(NULL != hTask);
    
    ULARGE_INTEGER              uliOrigin;
    DWORD                       dwSectors;
    PBYTE                       pbRetrieveBuffer;

    Assert(UsingClientBuffer(pContext));            
    dwSectors = m_currentAddress.dwSectorEnd - m_currentAddress.dwSectorBegin + 1;

    uliOrigin.QuadPart = (m_currentAddress.dwSectorBegin + pContext->dwRecordBufferSize / XBOX_HD_SECTOR_SIZE) 
                         * XBOX_HD_SECTOR_SIZE;

    dwSectors -= pContext->dwRecordBufferSize / XBOX_HD_SECTOR_SIZE;

    Assert(dwSectors != 0);
    
    m_pXo->ReadWriteFileInitializeContext(
                            m_hCacheFile,
                            (LPBYTE)m_pbBuffer,
                            dwSectors * XBOX_HD_SECTOR_SIZE,
                            uliOrigin,
                            m_hWorkEvent, 
                            (PXONLINETASK_FILEIO)hTask);

    return (m_pXo->ReadFileInternal((PXONLINETASK_FILEIO)hTask));
}

//----------------------------------------------------------------------------
//
// Gets the expected retrieve size taking into account wheather is the first or second call
//
//----------------------------------------------------------------------------
DWORD CLocalCache::GetExpectedRetrieveSize(
            IN PXONLC_CONTEXT                     pContext,
            IN BOOL                               bLastChunk)
{
    DWORD dwSize = 0;

    Assert(NULL != pContext);

    if( UsingClientBuffer(pContext) )
    {
        //
        // Used the client's buffer + m_pbBuffer
        //
        if( bLastChunk )
        {
            dwSize = (m_currentAddress.dwSectorEnd - m_currentAddress.dwSectorBegin + 1 - 
                        pContext->dwRecordBufferSize / XBOX_HD_SECTOR_SIZE ) * XBOX_HD_SECTOR_SIZE;
        }
        else
        {
            dwSize = (pContext->dwRecordBufferSize / XBOX_HD_SECTOR_SIZE) * XBOX_HD_SECTOR_SIZE;            
        }
    }
    else
    {
        //
        // Used only m_pbBuffer
        //
        dwSize = (m_currentAddress.dwSectorEnd - m_currentAddress.dwSectorBegin + 1) * XBOX_HD_SECTOR_SIZE;

    }

    return (dwSize);
}

//----------------------------------------------------------------------------
//
// Checks retrieve results
//
//----------------------------------------------------------------------------
HRESULT CLocalCache::CheckRetrieveResults(
        IN PXONLC_CONTEXT                     pContext
        )
{

    BYTE bFirstCheckByte, bLastCheckByte;
    CAddress workAddress(m_currentAddress);
    PBYTE pbDst = pContext->pbRecordBuffer;
    HRESULT hr = S_OK;

    if( UsingClientBuffer(pContext) )
    {
        //
        // Used the client's buffer + m_pbBuffer
        //

        //
        // First retrieve info from the client's buffer
        //
        workAddress.CutLastSectors(pContext->dwRecordBufferSize / XBOX_HD_SECTOR_SIZE);

        CSector *pSectors = (CSector*)pContext->pbRecordBuffer;

        GetDataFromAddress(pSectors , &workAddress , sizeof(bFirstCheckByte) , &bFirstCheckByte);

        workAddress.IncrementAddress(sizeof(bFirstCheckByte));

        GetDataFromAddress(pSectors , &workAddress , workAddress.dwSize , pbDst);

        //
        // Then retrieve info from m_pbBuffer
        //
        pbDst += workAddress.dwSize;

        workAddress = m_currentAddress;

        workAddress.CutFirstSectors(pContext->dwRecordBufferSize / XBOX_HD_SECTOR_SIZE);

        GetDataFromAddress(m_pbBuffer , &workAddress , workAddress.dwSize - sizeof(bLastCheckByte), pbDst);

        workAddress.IncrementAddress(workAddress.dwSize - sizeof(bLastCheckByte));

        GetDataFromAddress(m_pbBuffer , &workAddress , sizeof(bLastCheckByte) , &bLastCheckByte);

    }
    else
    {
        //
        // Used only m_pbBuffer
        //
        workAddress.MakeRelativeAddress();

        GetDataFromAddress(m_pbBuffer , &workAddress , sizeof(bFirstCheckByte) , &bFirstCheckByte);

        workAddress.IncrementAddress(sizeof(bFirstCheckByte));

        GetDataFromAddress(m_pbBuffer , &workAddress , pContext->dwRecordBufferSize , pbDst);

        workAddress.IncrementAddress(pContext->dwRecordBufferSize);

        GetDataFromAddress(m_pbBuffer , &workAddress , sizeof(bLastCheckByte) , &bLastCheckByte);
    }

    if(( bLastCheckByte != bFirstCheckByte ) ||
        (bFirstCheckByte != m_bCheckByte))
    {
        pContext->bValidDataInCache = FALSE;
        hr = E_FAIL;
    }

    return (hr);
}

//----------------------------------------------------------------------------
//
// Checks the retrieved sectors integrity
//
//----------------------------------------------------------------------------
HRESULT CLocalCache::CheckRetrievedSectorsIntegrity(
            IN PXONLC_CONTEXT                     pContext,
            IN BOOL                               bLastChunk
            )
{
    CAddress workAddress(m_currentAddress);
    DWORD dwSector;
    CSector *pSectorsToCheck = m_pbBuffer;

    if( UsingClientBuffer(pContext) )
    {
        //
        // Used the client's buffer + m_pbBuffer
        //

        if( !bLastChunk )
        {
            //
            // Check info from the client's buffer
            //
            workAddress.CutLastSectors(pContext->dwRecordBufferSize / XBOX_HD_SECTOR_SIZE);
            pSectorsToCheck = (CSector*)pContext->pbRecordBuffer; 

        }
        else
        {
            //
            // Check info from m_pbBuffer
            //
            workAddress.CutFirstSectors(pContext->dwRecordBufferSize / XBOX_HD_SECTOR_SIZE);
        }

    }
    else
    {
        //
        // Used only m_pbBuffer
        //
        workAddress.MakeRelativeAddress();

    }

    for( dwSector = workAddress.dwSectorBegin ; dwSector < workAddress.dwSectorEnd ; dwSector++ )
    {
        if(IsSectorCorrupted(pSectorsToCheck , dwSector))
        {
            pContext->bValidDataInCache = FALSE;
            return (E_FAIL);
        }
    }

    return (S_OK);
}

//----------------------------------------------------------------------------
//
// Updates the MRU List in memory
//
//----------------------------------------------------------------------------
VOID CLocalCache::UpdateMRUList(PBYTE pbIndexData, PBYTE pbRecord)
{
    if( GetMRUListSize() == 0 )
    {
        //
        // No MRU List for this cache type
        //
        return;
    }

    Assert(NULL != pbIndexData);
    
    //
    // Write the most recent one
    //
    GetMRUItemAddress(0);

    PBYTE pbFirstMRUItem = GetPointerInMemBlock(&m_currentAddress);

    SetFirstCheckByte(m_pbMemoryBlock , &m_currentAddress);

    //
    // Sets the index entry correspondent to this MRU item
    //
    SetIndexPosition(pbFirstMRUItem, m_dwCurrentIndexPos);

    
    //
    // Copy pbIndexData
    //
    m_currentAddress.IncrementAddress(sizeof(m_dwCurrentIndexPos));

    m_currentAddress.dwSize = GetIndexDataSize();

    CopyDataToSectors(pbIndexData , &m_currentAddress , 
                      XONLC_UNLIMITED_BUFFERS, DONT_WRITE_LAST_CHECK_BYTE, m_pbMemoryBlock); 
    
    //
    // Copy pbRecord
    //
    if( NULL != pbRecord )
    {
        m_currentAddress.IncrementAddress(GetIndexDataSize());

        m_currentAddress.dwSize = GetRecordSize() - sizeof(CHECKINFO);

        CopyDataToSectors(pbRecord , &m_currentAddress , 
                          XONLC_UNLIMITED_BUFFERS, WRITE_LAST_CHECK_BYTE, m_pbMemoryBlock); 

    }
    else
    {
        m_currentAddress.IncrementAddress(GetCachedDataSize());
        SetLastCheckByte(m_pbMemoryBlock , &m_currentAddress);
    }

}

//----------------------------------------------------------------------------
//
// Sets beginning check byte
//
//----------------------------------------------------------------------------
VOID CLocalCache::SetFirstCheckByte(CSector *pbMemory , CAddress *pAddress)
{
    m_bCheckByte = GetFirstByte(pbMemory, pAddress) + 1;

    //
    // Don't use AVAILABLE as check byte
    //
    if( AVAILABLE == m_bCheckByte )
    {
        m_bCheckByte++;
    }

    //
    // Set the check bytes at the beginning of the data
    //
    SetFirstByte(pbMemory, pAddress, m_bCheckByte);
    pAddress->IncrementAddress(1);
}

//----------------------------------------------------------------------------
//
// Sets end check byte
//
//----------------------------------------------------------------------------
VOID CLocalCache::SetLastCheckByte(CSector *pbMemory , CAddress *pAddress)
{
    SetLastByte(pbMemory, pAddress, m_bCheckByte);
    pAddress->DecrementAddress(1);
}

//----------------------------------------------------------------------------
//
// Compare two index datas
//
//----------------------------------------------------------------------------
BOOL CLocalCache::CompareIndexData(PBYTE pbIndexData1 , PBYTE pbIndexData2)
{
    BOOL bFound = FALSE;

    if( NULL == m_pfnCompareFunc )
    {
        //
        // Memcmp
        //
        bFound = (0 == memcmp(pbIndexData1, pbIndexData2, GetKeySize()));
    }
    else
    {
        //
        // Custom comparison function
        //
        bFound = (m_pXo->*m_pfnCompareFunc)(pbIndexData1, pbIndexData2);
    }

    return bFound;
}

//----------------------------------------------------------------------------
//
// Delete current index entry
//
//----------------------------------------------------------------------------
VOID CLocalCache::DeleteCurrentIndexEntry()
{
    Assert(m_dwCurrentIndexPos < GetMaxCachedItems());

    GetIndexItemAddress( m_dwCurrentIndexPos );

    //
    // Mark first character as '*' - available
    //
    MarkCurrentEntryAsAvailable();

    if( HasMRUList() )
    {
        if( m_bFoundInMRUList )
        {
            //
            // Delete entry from MRU List
            //
            GetMRUItemAddress(0);
            MarkCurrentEntryAsAvailable();
        }
    }

    m_dwCurrentIndexPos = GetMaxCachedItems();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\maketbl.cpp ===
/*
 * Table-building routines
 *
 * make_table() is based on ** Public Domain ** source "AR001.ZIP".
 */

#include "xonp.h"
#include "xonver.h"

/*
 * Make a decoding table for decoding nchar possible Huffman elements
 * with bit lengths given by bitlen.
 *
 * Output the main lookup table into table[] and use leftright[] for
 * supplementary information (for bitlengths > tablebits).
 *
 * The size of table[] is tablebits elements.
 */
bool NEAR make_table(
	t_decoder_context	*context,
	int     			nchar,
	const byte			*bitlen,
	byte				tablebits,
	short  				*table,
	short  				*leftright
)
{
    uint    i;
	int		ch;
    short * p;
    uint    count[17], weight[17], start[18];
    int     avail;
    uint    nextcode;
    uint    k;
	byte	len;
	byte	jutbits;

	for (i = 1; i <= 16; i++)
		count[i] = 0;

	/* count the number of elements of each bit length */
    for (i = 0; i < (uint) nchar; i++)
		count[bitlen[i]]++;

	start[1] = 0;

	for (i = 1; i <= 16; i++)
		start[i + 1] = start[i] + (count[i] << (16 - i));

    if (start[17] != 65536)
    {
        if (start[17] == 0)
        {
            /*
             * All elements are length zero
             */
            memset(table, 0, sizeof(ushort)*(1 << tablebits));
            return true; /* success */
        }
        else
        {
            return false; /* bad table */
        }
    }

	jutbits = 16 - tablebits;

	for (i = 1; i <= tablebits; i++)
	{
		start[i] >>= jutbits;
		weight[i] = 1 << (tablebits - i);
	}

	while (i <= 16)
	{
		weight[i] = 1 << (16 - i);
		i++;
	}
	
	i = start[tablebits+1] >> jutbits;

	if (i != 65536)
	{
		memset(
            &table[i],
            0,
            sizeof(ushort)*((1 << tablebits)-i)
        );
	}

	avail = nchar;

	for (ch = 0; ch < nchar; ch++)
	{
		if ((len = bitlen[ch]) == 0)
			continue;

		nextcode = start[len] + weight[len];

		if (len <= tablebits)
		{
            if (nextcode > (uint) (1 << tablebits))
                return false; /* bad table */

			for (i = start[len]; i < nextcode; i++)
				table[i] = (short)ch;

   			start[len] = nextcode;
		}
		else
		{
			byte i;

			k = start[len];
   			start[len] = nextcode;
			p = &table[k >> jutbits];

			i = len - tablebits;
			k <<= tablebits;

			do
			{
				if (*p == 0)
				{
					leftright[avail*2] = leftright[avail*2+1] = 0;
					*p = (short) -avail;
					avail++;
				}

				if ((signed short) k < 0) // if (k & 32768)
					p = &leftright[-(*p)*2+1];
				else
					p = &leftright[-(*p)*2];

				k <<= 1;
				i--;
			} while (i);

			*p = (short)ch;
		}
	}

    return true;
}

/*
 * Specialised make table routine where it is known that there are
 * only 8 elements (nchar=8) and tablebits=7 (128 byte lookup table).
 *
 * Since there can be no overflow, this will be a direct lookup.
 *
 * Important difference; the lookup table returns a byte, not a ushort.
 */
bool NEAR make_table_8bit(t_decoder_context *context, byte bitlen[], byte table[])
{
	ushort count[17], weight[17], start[18];
	ushort i;
	ushort nextcode;
	byte   len;
	byte   ch;

	for (i = 1; i <= 16; i++)
		count[i] = 0;

	for (i = 0; i < 8; i++)
		count[bitlen[i]]++;

	start[1] = 0;

	for (i = 1; i <= 16; i++)
		start[i + 1] = start[i] + (count[i] << (16 - i));

	if (start[17] != 0)
        return false; /* bad table */

	for (i = 1; i <= 7; i++)
	{
		start[i] >>= 9;
		weight[i]  = 1 << (7 - i);
	}

	while (i <= 16)
	{
		weight[i] = 1 << (16 - i);
		i++;
	}

	memset(table, 0, 1<<7);

	for (ch = 0; ch < 8; ch++)
	{
		if ((len = bitlen[ch]) == 0)
			continue;

		nextcode = start[len] + weight[len];

		if (nextcode > (1 << 7))
            return false; /* bad table */

		for (i = start[len]; i < nextcode; i++)
			table[i] = ch;

		start[len] = nextcode;
	}

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\logon.cpp ===
/*==========================================================================
 *
 *  Copyright Microsoft Corporation.  All Rights Reserved.
 *
========================================================================== */

#include "xonp.h"
#include "xonver.h"
#include <cryptkeys.h>
#include <malloc.h>
#include <xboxp.h>

DefineTag(AuthVerbose,TAG_ENABLE);
DefineTag(AuthWarn,TAG_ENABLE);

#define TEMP_SEND_REQUESTS_SEQUENTIALLY 1

#define AP_REQUEST_OVERHEAD_ABOVE_TICKET 280

#define XONLINE_AS_EXCHANGE_BUFFER_SIZE 1460
#define XONLINE_TGS_EXCHANGE_BUFFER_SIZE 1460

//
// All possible states for different logon related tasks.
//
#define LOGON_TASK_INITIAL                  0
#define LOGON_XNETWAIT_IN_PROGRESS          1
#define LOGON_START_CACHE_LOOKUP            2
#define LOGON_CACHE_RETRIEVE_IN_PROGRESS    3
#define LOGON_START_CACHE_MISS              4
#define LOGON_DNS_IN_PROGRESS               5
#define LOGON_CONNECT_IN_PROGRESS           6
#define LOGON_MISC_IN_PROGRESS              7
#define LOGON_RECV_IN_PROGRESS              8
#define LOGON_MACS_IN_PROGRESS             10
#define LOGON_GET_TGT_IN_PROGRESS          11
#define LOGON_GET_TKT_IN_PROGRESS          12
#define LOGON_CS_IN_PROGRESS               13
#define LOGON_TASK_COMPLETE                99

//
// Transport information
//
#define KERB_KDC_PORT       88

//
// Retry info
//
DWORD g_dwNumKerbRetry = MAX_KERB_RETRIES;
DWORD g_dwNumMACSRetry = MAX_KERB_RETRIES;
DWORD g_dwKerbRetryDelayInMilliSeconds[MAX_KERB_RETRIES] = { 4000, 8000, 16000, 16000 };
DWORD g_dwMACSRetryDelayInMilliSeconds[MAX_KERB_RETRIES] = { 8000, 16000, 32000, 32000 };

#define GET_XNADDR_RETRY_PERIOD_IN_MS      200
#define MAX_TOTAL_LOGON_TIME_IN_MS       90000

//
// Task context structure for the implementation of Logon task
//
struct XONLINETASK_LOGON
{
    XONLINETASK_CONTEXT xonTask;
    HRESULT hr;
    DWORD dwState;
    BYTE abEventTimer[CBEVENTTIMER];
    DWORD  dwMaxEndingTickCount;
    HANDLE hCreatedEvent;
    
    XONLINETASK_HANDLE  hGetMachineAccountTask;
    XONLINE_USER machineUser;

    XONLINETASK_HANDLE  hGetCombinedTicketTask;
    PXKERB_TGT_CONTEXT  pCombinedTGTContext;

    DWORD adwServiceIDs[XONLINE_MAX_SERVICE_REQUEST];
    DWORD cServices;
    XONLINETASK_HANDLE hGetServiceTicketTask;
    PXKERB_SERVICE_CONTEXT pXKerbServiceContext;
    BOOL fLogonTimeCached;

    HANDLE hCombinedTicketCache;
    XONLINETASK_HANDLE hCombinedTicketCacheTask;
    DWORD dwCombinedTicketCacheState;
    BOOL fNeedToFlushCombinedTicketCache;
    XKERB_TGT_CONTEXT combinedContextToCache;

    HANDLE hServiceTicketCache;
    XONLINETASK_HANDLE hServiceTicketCacheTask;
    DWORD dwServiceTicketCacheState;
    BOOL fNeedToFlushServiceTicketCache;
    XKERB_SERVICE_CONTEXT serviceContextToCache;

    XONLINETASK_HANDLE hPresenceTask;
    BOOL fAliveSent;
};

//
// Task context structure for DNS Lookup
//
struct XONLINETASK_DNS_LOOKUP
{
    XONLINETASK_CONTEXT         xonTask;
    HRESULT                     hr;
    XONLINE_DNS_CACHE_ENTRY*    pCacheEntry;
    XNDNS*                      pCurrentLookup;
};

//
// Do work function for DNSLookup
//
HRESULT CXo::DNSLookupContinue(XONLINETASK_HANDLE hTask)
{
    Assert(hTask != NULL);

    PXONLINETASK_DNS_LOOKUP  pDNSLookupTask = (PXONLINETASK_DNS_LOOKUP)hTask;
    XONLINE_DNS_CACHE_ENTRY* pCacheEntry = pDNSLookupTask->pCacheEntry;
    XNDNS* pCurrentLookup = pDNSLookupTask->pCurrentLookup;

    if (pDNSLookupTask->hr == XONLINETASK_S_RUNNING)
    {
        if (pCurrentLookup == NULL)
        {
            Assert( pCacheEntry != NULL );
            if (pCacheEntry->dwState == DNS_LOOKUP_COMPLETE)
            {
                pDNSLookupTask->hr = XONLINETASK_S_SUCCESS;
            }
            else if (pCacheEntry->dwState == DNS_LOOKUP_ERROR)
            {
                pDNSLookupTask->hr = XONLINE_E_LOGON_DNS_LOOKUP_FAILED;
            }
            else
            {
                Assert( pCacheEntry->dwState == DNS_LOOKUP_IN_PROGRESS );
            }
        }
        else if (pCurrentLookup->iStatus != WSAEINPROGRESS)
        {
            if (pCurrentLookup->iStatus == 0)
            {
                TraceSz6( AuthVerbose, "XNetDnsLookup for %s has %d result(s): %d.%d.%d.%d",
                    pCacheEntry->name, pCurrentLookup->cina,
                    pCurrentLookup->aina[0].S_un.S_un_b.s_b1, 
                    pCurrentLookup->aina[0].S_un.S_un_b.s_b2, 
                    pCurrentLookup->aina[0].S_un.S_un_b.s_b3, 
                    pCurrentLookup->aina[0].S_un.S_un_b.s_b4 );
                pCacheEntry->address = *(pCurrentLookup);
                pCacheEntry->dwState = DNS_LOOKUP_COMPLETE;
                pDNSLookupTask->pCurrentLookup = NULL;
                pDNSLookupTask->hr = XONLINETASK_S_SUCCESS;
            }
            else
            {
                TraceSz1( AuthWarn, "XNetDnsLookup failed status is 0x%X", pCurrentLookup->iStatus );
                pCacheEntry->dwState = DNS_LOOKUP_ERROR;
                pDNSLookupTask->pCurrentLookup = NULL;
                //pDNSLookupTask->hr = HRESULT_FROM_WIN32(pCurrentLookup->iStatus);
                pDNSLookupTask->hr = XONLINE_E_LOGON_DNS_LOOKUP_FAILED;
            }

            XNetDnsRelease(pCurrentLookup);
        }
    }
    
    return(pDNSLookupTask->hr);
}

//
// Do work function for DNSLookup
//
void CXo::DNSLookupClose(XONLINETASK_HANDLE hTask)
{
    Assert(hTask != NULL);

    PXONLINETASK_DNS_LOOKUP  pDNSLookupTask = (PXONLINETASK_DNS_LOOKUP)hTask;
    XNDNS* pCurrentLookup = pDNSLookupTask->pCurrentLookup;

    if (pDNSLookupTask->hr == XONLINETASK_S_RUNNING)
    {
        if (pCurrentLookup != NULL)
        {
            XNetDnsRelease(pCurrentLookup);
            Assert( pDNSLookupTask->pCacheEntry != NULL );
            pDNSLookupTask->pCacheEntry->dwState = DNS_LOOKUP_ERROR;
        }
        pDNSLookupTask->hr = XONLINE_E_LOGON_DNS_LOOKUP_FAILED;
    }
    
    pDNSLookupTask->pCurrentLookup = NULL;
    pDNSLookupTask->pCacheEntry = NULL;
}

//
// Function to kick off a DNS Lookup
//
HRESULT CXo::DNSLookup(char * pszDNSName, HANDLE hWorkEvent, XONLINETASK_DNS_LOOKUP * pDNSLookupTask)
{
    HRESULT hr = S_OK;
    int err;
    int i;
    DWORD dwPrevState;
    XONLINE_DNS_CACHE_ENTRY* pCacheEntry = NULL;
    
    Assert(pszDNSName != NULL);
    Assert(pDNSLookupTask != NULL);

    RtlZeroMemory( pDNSLookupTask, sizeof(*pDNSLookupTask) );
    
    for (i=0; i<XONLINE_NUM_DNS_CACHE_ENTRYS; ++i)
    {
        if (_stricmp(pszDNSName, m_DNSCache[i].name) == 0)
        {
            pCacheEntry = &m_DNSCache[i];
            break;
        }
    }
    
    Assert(pCacheEntry != NULL);
    if (pCacheEntry == NULL)
    {
        TraceSz1( AuthWarn, "XNetDnsLookup call with bad name: %s", pszDNSName );
        hr = XONLINE_E_LOGON_DNS_LOOKUP_FAILED;
        goto Cleanup;        
    }

    TaskInitializeContext(&(pDNSLookupTask->xonTask));
    pDNSLookupTask->xonTask.pfnContinue = DNSLookupContinue;
    pDNSLookupTask->xonTask.pfnClose = DNSLookupClose;
    pDNSLookupTask->pCacheEntry = pCacheEntry;
    pDNSLookupTask->hr = XONLINETASK_S_RUNNING;
    
    dwPrevState = InterlockedCompareExchange((PLONG)&pCacheEntry->dwState, DNS_LOOKUP_IN_PROGRESS, 0);

    switch (dwPrevState)
    {
    case DNS_LOOKUP_COMPLETE:
        //
        // DNS lookup already complete for this entry
        // SetEvent to make sure DNSLookupContinue is called
        //
        SetEvent( hWorkEvent );
        //TraceSz( AuthVerbose, "SetEvent at DNSLookup DNS_LOOKUP_COMPLETE" );
        pDNSLookupTask->hr = XONLINETASK_S_SUCCESS;
        hr = S_OK;
        break;        
    case DNS_LOOKUP_ERROR:
        pDNSLookupTask->hr = hr = XONLINE_E_LOGON_DNS_LOOKUP_FAILED;
        break;        
    case DNS_LOOKUP_IN_PROGRESS:
        //
        // DNS lookup already in progress for this entry
        // SetEvent to make sure DNSLookupContinue is called
        //
        SetEvent( hWorkEvent );
        //TraceSz( AuthVerbose, "SetEvent at DNSLookup DNS_LOOKUP_IN_PROGRESS" );
        pDNSLookupTask->hr = XONLINETASK_S_RUNNING;
        hr = S_OK;
        break;        
    case 0:
        pDNSLookupTask->xonTask.hEventWorkAvailable = hWorkEvent;
        err = XNetDnsLookup(pszDNSName, hWorkEvent, &pDNSLookupTask->pCurrentLookup);
        if (err != 0 || pDNSLookupTask->pCurrentLookup == NULL)
        {
            TraceSz( AuthWarn, "XNetDnsLookup call failed!");
            pCacheEntry->dwState = DNS_LOOKUP_ERROR;
            pDNSLookupTask->pCurrentLookup = NULL;
            pDNSLookupTask->hr = hr = XONLINE_E_LOGON_DNS_LOOKUP_FAILED;
            goto Cleanup;
        }
        pDNSLookupTask->hr = XONLINETASK_S_RUNNING;
        hr = S_OK;
        break;        
    default:
        AssertSz(FALSE, "DNSLookupContinue: DNS lookup in bad state!");
    }
    
Cleanup:
    return(hr);
}

//
// Function to retrieve the results of a DNSLookup
//
HRESULT CXo::DNSLookupGetResults(XONLINETASK_HANDLE hTask, XNDNS ** ppDestAddr)
{
    Assert(hTask != NULL);
    Assert(ppDestAddr != NULL);

    PXONLINETASK_DNS_LOOKUP  pDNSLookupTask = (PXONLINETASK_DNS_LOOKUP)hTask;

    if (pDNSLookupTask->hr == XONLINETASK_S_SUCCESS)
    {
        *ppDestAddr = &pDNSLookupTask->pCacheEntry->address;
    }
    else
    {
        *ppDestAddr = NULL;
    }
    return(pDNSLookupTask->hr);
}

//
// Function to retrieve the results of a DNSLookup
//
BOOL CXo::DNSLookupIsValidTask(XONLINETASK_HANDLE hTask)
{
    Assert(hTask != NULL);

    return(((PXONLINETASK_DNS_LOOKUP)hTask)->pCacheEntry != NULL);
}

//
// Define a task context structure for
//
struct XONLINETASK_GET_SINGLE_TICKET
{
    XONLINETASK_CONTEXT     xonTask;
    HRESULT                 hr;
    DWORD                   dwState;
    DWORD                   dwAdjustedTime;
    DWORD                   dwRetryCount;
    DWORD                   dwNextRetryTickCount;
    BYTE                    abEventTimer[CBEVENTTIMER];
    BOOL                    fMachineAccount;
    PXONLINE_USER           pUser;
    XONLINETASK_DNS_LOOKUP  DNSTask;
    XNDNS*                  pDestAddress;
    SOCKET                  socket;
    WSABUF                  WSABuffer;
    XONLINETASK_SOCKIO      SendRecvTask; // No XOnlineCloseTask needed
    BYTE                    recvBuffer[XONLINE_AS_EXCHANGE_BUFFER_SIZE];
    PXKERB_TGT_CONTEXT      pSingleTGTContext;
};

//
// Send AS Request for GetSingleTicket
//
HRESULT CXo::GetSingleTicketSendAsRequest(PXONLINETASK_GET_SINGLE_TICKET pGetSingleTicketTask)
{
    int err;
    HRESULT hr = S_OK;
    WSABUF WSABuffer;
    WSAOVERLAPPED wsaOverlapped;
    struct sockaddr_in ServerAddress;
    BYTE abBuffer[XONLINE_AS_EXCHANGE_BUFFER_SIZE];
    DWORD dwMessageLength = sizeof(abBuffer);

    Assert (pGetSingleTicketTask->pSingleTGTContext != NULL);
    
    hr = XkerbBuildAsRequest(
        pGetSingleTicketTask->fMachineAccount,
        (PXONLINEP_USER)pGetSingleTicketTask->pUser,
        abBuffer,
        &dwMessageLength,
        pGetSingleTicketTask->pSingleTGTContext
        );
    if (FAILED(hr))
    {
        hr = XONLINE_E_OUT_OF_MEMORY;
        goto Cleanup;
    }

    ServerAddress.sin_family = AF_INET;
    ServerAddress.sin_addr = pGetSingleTicketTask->pDestAddress->aina[pGetSingleTicketTask->dwRetryCount % pGetSingleTicketTask->pDestAddress->cina];
    ServerAddress.sin_port = htons(KERB_KDC_PORT);

    WSABuffer.len = dwMessageLength;
    WSABuffer.buf = (char*)abBuffer;
    wsaOverlapped.hEvent = pGetSingleTicketTask->xonTask.hEventWorkAvailable;
    
    TraceSz5( AuthVerbose, "GetSingleTicketSendAsRequest sent %d bytes to: %d.%d.%d.%d",
        dwMessageLength,
        pGetSingleTicketTask->pDestAddress->aina[pGetSingleTicketTask->dwRetryCount % pGetSingleTicketTask->pDestAddress->cina].S_un.S_un_b.s_b1, 
        pGetSingleTicketTask->pDestAddress->aina[pGetSingleTicketTask->dwRetryCount % pGetSingleTicketTask->pDestAddress->cina].S_un.S_un_b.s_b2, 
        pGetSingleTicketTask->pDestAddress->aina[pGetSingleTicketTask->dwRetryCount % pGetSingleTicketTask->pDestAddress->cina].S_un.S_un_b.s_b3, 
        pGetSingleTicketTask->pDestAddress->aina[pGetSingleTicketTask->dwRetryCount % pGetSingleTicketTask->pDestAddress->cina].S_un.S_un_b.s_b4); 

    err = WSASendTo(
            pGetSingleTicketTask->socket,
            &WSABuffer, 1,
            &dwMessageLength, 0,
            (LPSOCKADDR) &ServerAddress, sizeof(ServerAddress),
            &wsaOverlapped, NULL);
    if (err == SOCKET_ERROR)
    {
        TraceSz1( AuthWarn, "GetSingleTicketSendAsRequest: WSASendTo Failed WSAGetLastError: 0x%X", WSAGetLastError() );
        hr = XONLINE_E_LOGON_AUTHENTICATION_FAILED;
        goto Cleanup;
    }

    pGetSingleTicketTask->dwNextRetryTickCount =
        GetTickCount() + g_dwKerbRetryDelayInMilliSeconds[pGetSingleTicketTask->dwRetryCount];

    XnSetEventTimer(
        pGetSingleTicketTask->abEventTimer,
        pGetSingleTicketTask->xonTask.hEventWorkAvailable,
        g_dwKerbRetryDelayInMilliSeconds[pGetSingleTicketTask->dwRetryCount] );
    
Cleanup:
    return hr;
}

//
// Do work function for GetSingleTicket
//
HRESULT CXo::GetSingleTicketContinue(XONLINETASK_HANDLE hTask)
{
    Assert(hTask != NULL);

    HRESULT hr = S_OK;
    DWORD dwMessageLength;
    PXONLINETASK_GET_SINGLE_TICKET pGetSingleTicketTask = (PXONLINETASK_GET_SINGLE_TICKET)hTask;

    switch (pGetSingleTicketTask->dwState)
    {
    case LOGON_DNS_IN_PROGRESS:
        hr = XOnlineTaskContinue( (XONLINETASK_HANDLE)&pGetSingleTicketTask->DNSTask );
        if (hr == XONLINETASK_S_SUCCESS)
        {
            hr = DNSLookupGetResults( (XONLINETASK_HANDLE)&pGetSingleTicketTask->DNSTask, &pGetSingleTicketTask->pDestAddress );
            Assert( hr == XONLINETASK_S_SUCCESS );
            
            pGetSingleTicketTask->socket = socket( AF_INET, SOCK_DGRAM, IPPROTO_IP );
            if (pGetSingleTicketTask->socket == INVALID_SOCKET)
            {
                TraceSz1( AuthWarn, "GetSingleTicketContinue: socket create failed WSAGetLastError:0x%X", WSAGetLastError() );
                pGetSingleTicketTask->hr = XONLINE_E_LOGON_AUTHENTICATION_FAILED;
                goto Cleanup;
            }

            XnSetInsecure(pGetSingleTicketTask->socket);

            pGetSingleTicketTask->WSABuffer.len = sizeof(pGetSingleTicketTask->recvBuffer);
            pGetSingleTicketTask->WSABuffer.buf = (char*)pGetSingleTicketTask->recvBuffer;

            SendRecvInitializeContext(
                    pGetSingleTicketTask->socket,
                    &pGetSingleTicketTask->WSABuffer, 1, 0,
                    pGetSingleTicketTask->xonTask.hEventWorkAvailable,
                    &pGetSingleTicketTask->SendRecvTask );

            hr = GetSingleTicketSendAsRequest( pGetSingleTicketTask );
            if (FAILED(hr))
            {
                pGetSingleTicketTask->hr = hr;
                goto Cleanup;
            }
            
            //
            // Kick off the asynchronous recv operation
            //
            hr = RecvInternal(&pGetSingleTicketTask->SendRecvTask);
            if (FAILED(hr))
            {
                TraceSz1( AuthWarn, "GetSingleTicketContinue: RecvInternal failed hr:0x%X", hr );
                pGetSingleTicketTask->hr = XONLINE_E_LOGON_AUTHENTICATION_FAILED;
                goto Cleanup;
            }

            pGetSingleTicketTask->dwState = LOGON_RECV_IN_PROGRESS;
        }
        else if (FAILED(hr))
        {
            pGetSingleTicketTask->hr = hr;
            goto Cleanup;
        }
        else
        {
            Assert( hr == XONLINETASK_S_RUNNING );
        }
        
        break;

    case LOGON_RECV_IN_PROGRESS:
        hr = XOnlineTaskContinue( (XONLINETASK_HANDLE)&pGetSingleTicketTask->SendRecvTask );
        if (hr == XONLINETASK_S_SUCCESS)
        {
            dwMessageLength = 0;
            hr = GetSendRecvResults( (XONLINETASK_HANDLE)&pGetSingleTicketTask->SendRecvTask, &dwMessageLength, NULL, NULL );
            Assert( hr == XONLINETASK_S_SUCCESS );
            Assert( dwMessageLength > 0 );
            
            TraceSz2( AuthVerbose, "GetSingleTicketContinue received %d bytes for user: %s", dwMessageLength, pGetSingleTicketTask->pUser->name);

            hr = XkerbVerifyAsReply(
                pGetSingleTicketTask->recvBuffer,
                dwMessageLength,
                pGetSingleTicketTask->pSingleTGTContext
                );
            if ( hr == (HRESULT) STATUS_TIME_DIFFERENCE_AT_DC )
            {
                TraceSz( AuthWarn, "GetSingleTicketContinue adjusted Xbox clock according to KDC!");
                if (pGetSingleTicketTask->dwAdjustedTime < MAX_TIME_ADJUSTMENTS)
                {
                    ++pGetSingleTicketTask->dwAdjustedTime;
                  
                    hr = GetSingleTicketSendAsRequest( pGetSingleTicketTask );
                    if (FAILED(hr))
                    {
                        pGetSingleTicketTask->hr = hr;
                        goto Cleanup;
                    }

                    //
                    // Kick off another new asynchronous recv operation
                    //
                    hr = RecvInternal(&pGetSingleTicketTask->SendRecvTask);
                    if (FAILED(hr))
                    {
                        TraceSz1( AuthWarn, "GetSingleTicketContinue: RecvInternal failed hr: 0x%X", hr );
                        pGetSingleTicketTask->hr = XONLINE_E_LOGON_AUTHENTICATION_FAILED;
                        goto Cleanup;
                    }

                    //
                    // State not changed, go back and continue waiting for a response
                    //
                    goto Cleanup;
                }
                else
                {
                    TraceSz1( AuthWarn, "GetSingleTicketContinue: adjusting time too many times: %d", pGetSingleTicketTask->dwAdjustedTime );
                    pGetSingleTicketTask->hr = XONLINE_E_LOGON_AUTHENTICATION_FAILED;
                    goto Cleanup;
                }
            }
            else if (FAILED(hr))
            {
                TraceSz1( AuthWarn, "GetSingleTicketContinue: XkerbVerifyAsReply failed with hr: 0x%X", hr );
                pGetSingleTicketTask->hr = XONLINE_E_LOGON_AUTHENTICATION_FAILED;
                goto Cleanup;
            }

            //
            // We succeeded!
            //
            pGetSingleTicketTask->dwState = LOGON_TASK_COMPLETE;
            pGetSingleTicketTask->hr = XONLINETASK_S_SUCCESS;
            if (pGetSingleTicketTask->pSingleTGTContext->pAccountCreationPreAuth != NULL)
            {
                SysFree( pGetSingleTicketTask->pSingleTGTContext->pAccountCreationPreAuth );            
            }
            break;
        }
        else if (FAILED(hr))
        {
            TraceSz1( AuthWarn, "GetSingleTicketContinue: recv failed with hr: 0x%X", hr );
            pGetSingleTicketTask->hr = XONLINE_E_LOGON_AUTHENTICATION_FAILED;
            goto Cleanup;            
        }

        //
        // Check if we timed out
        //
        Assert( hr == XONLINETASK_S_RUNNING );
        if (GetTickCount() >= pGetSingleTicketTask->dwNextRetryTickCount)
        {
            if ( ++pGetSingleTicketTask->dwRetryCount >= g_dwNumKerbRetry )
            {
                TraceSz1( AuthWarn, "GetSingleTicketContinue: timed out after %d retries", pGetSingleTicketTask->dwRetryCount );
                pGetSingleTicketTask->hr = XONLINE_E_LOGON_AUTHENTICATION_TIMEDOUT;
                goto Cleanup;
            }
            
            //
            // Need to retry with the next IP address
            //
            hr = GetSingleTicketSendAsRequest( pGetSingleTicketTask );
            if (FAILED(hr))
            {
                pGetSingleTicketTask->hr = hr;
                goto Cleanup;
            }
        }
        break;
    
    case LOGON_TASK_COMPLETE:
        break;
        
    default:
        AssertSz(FALSE, "GetSingleTicketContinue: Bad State");
    }

Cleanup:
    if (pGetSingleTicketTask->hr != XONLINETASK_S_RUNNING)
    {
        pGetSingleTicketTask->dwState = LOGON_TASK_COMPLETE;
    }
    
    return(pGetSingleTicketTask->hr);
}

//
// Close function for GetSingleTicket
//
void CXo::GetSingleTicketClose(XONLINETASK_HANDLE hTask)
{
    Assert(hTask != NULL);

    PXONLINETASK_GET_SINGLE_TICKET pGetSingleTicketTask = (PXONLINETASK_GET_SINGLE_TICKET)hTask;
    
    if (DNSLookupIsValidTask( (XONLINETASK_HANDLE)&(pGetSingleTicketTask->DNSTask) ))
    {
        XOnlineTaskClose((XONLINETASK_HANDLE)&(pGetSingleTicketTask->DNSTask));
    }

    if (pGetSingleTicketTask->socket != INVALID_SOCKET)
    {
        WSACancelOverlappedIO( pGetSingleTicketTask->socket );
        closesocket(pGetSingleTicketTask->socket);
    }

    if (pGetSingleTicketTask->pSingleTGTContext != NULL)
    {
        Assert (pGetSingleTicketTask->pSingleTGTContext->pAccountCreationPreAuth == NULL);
        if (pGetSingleTicketTask->pSingleTGTContext->pInputTGTContext != NULL)
        {
            SysFree( pGetSingleTicketTask->pSingleTGTContext->pInputTGTContext );            
        }
        SysFree( pGetSingleTicketTask->pSingleTGTContext );
    }

    XnSetEventTimer(pGetSingleTicketTask->abEventTimer, NULL, 0xFFFFFFFF);

    SysFree(pGetSingleTicketTask);
}

//
// Function to kick off a GetSingleTicket
//
HRESULT CXo::GetSingleTicket(BOOL fMachineAccount, PXKERB_TGT_CONTEXT pInputTGTContext, PXONLINE_USER pUser, HANDLE hWorkEvent, PXONLINETASK_HANDLE phGetSingleTicketTask)
{
    HRESULT hr;
    PXONLINETASK_GET_SINGLE_TICKET pGetSingleTicketTask;
    
    Assert(pUser != NULL);
    Assert(phGetSingleTicketTask != NULL);

    pGetSingleTicketTask = (PXONLINETASK_GET_SINGLE_TICKET)SysAllocZ(sizeof(*pGetSingleTicketTask),
        PTAG_XONLINETASK_GET_SINGLE_TICKET);
    if (pGetSingleTicketTask == NULL)
    {
        hr = XONLINE_E_OUT_OF_MEMORY;
        goto Cleanup;
    }
    
    TaskInitializeContext(&(pGetSingleTicketTask->xonTask));
    pGetSingleTicketTask->xonTask.pfnContinue = GetSingleTicketContinue;
    pGetSingleTicketTask->xonTask.pfnClose = GetSingleTicketClose;
    pGetSingleTicketTask->xonTask.hEventWorkAvailable = hWorkEvent;
    pGetSingleTicketTask->pUser = pUser;
    pGetSingleTicketTask->hr = XONLINETASK_S_RUNNING;
    pGetSingleTicketTask->socket = INVALID_SOCKET;
    pGetSingleTicketTask->fMachineAccount = fMachineAccount;
    
    pGetSingleTicketTask->pSingleTGTContext = (PXKERB_TGT_CONTEXT)SysAllocZ(sizeof(*(pGetSingleTicketTask->pSingleTGTContext)), PTAG_XKERB_TGT_CONTEXT);
    if ( pGetSingleTicketTask->pSingleTGTContext == NULL )
    {
        hr = XONLINE_E_OUT_OF_MEMORY;
        goto Cleanup;
    }
    pGetSingleTicketTask->pSingleTGTContext->pInputTGTContext = pInputTGTContext;
    
    hr = DNSLookup(
            PASSPORT_AS_DNS,
            hWorkEvent,
            &pGetSingleTicketTask->DNSTask
            );
    pGetSingleTicketTask->dwState = LOGON_DNS_IN_PROGRESS;

    //
    // Pump it once to get things going here
    //
    GetSingleTicketContinue( (XONLINETASK_HANDLE) pGetSingleTicketTask );
    
    *phGetSingleTicketTask = (XONLINETASK_HANDLE) pGetSingleTicketTask;

Cleanup:
    if (FAILED(hr))
    {
        *phGetSingleTicketTask = NULL;
        if (pGetSingleTicketTask != NULL)
        {
            if (DNSLookupIsValidTask( (XONLINETASK_HANDLE)&(pGetSingleTicketTask->DNSTask) ))
            {
                XOnlineTaskClose((XONLINETASK_HANDLE)&(pGetSingleTicketTask->DNSTask));
            }

            SysFree(pGetSingleTicketTask);
        }        
    }    
    return(hr);
}

//
// Function to retrieve the results of a GetSingleTicket
//
HRESULT CXo::GetSingleTicketGetResults(XONLINETASK_HANDLE hTask, PXKERB_TGT_CONTEXT * ppSingleTGTContext)
{
    Assert(hTask != NULL);
    Assert(ppSingleTGTContext != NULL);

    PXONLINETASK_GET_SINGLE_TICKET  pGetSingleTicketTask = (PXONLINETASK_GET_SINGLE_TICKET)hTask;

    if (pGetSingleTicketTask->hr == XONLINETASK_S_SUCCESS)
    {
        if (pGetSingleTicketTask->pSingleTGTContext->pInputTGTContext != NULL)
        {
            SysFree( pGetSingleTicketTask->pSingleTGTContext->pInputTGTContext );       
            pGetSingleTicketTask->pSingleTGTContext->pInputTGTContext = NULL;
        }
        *ppSingleTGTContext = pGetSingleTicketTask->pSingleTGTContext;
        pGetSingleTicketTask->pSingleTGTContext = NULL;
    }
    else
    {
        *ppSingleTGTContext = NULL;
    }
    return(pGetSingleTicketTask->hr);
}


//
// Define a task context structure for
//
struct XONLINETASK_GET_MACHINE_ACCOUNT
{
    XONLINETASK_CONTEXT     xonTask;
    HRESULT                 hr;
    DWORD                   dwState;
    DWORD                   dwAdjustedTime;
    DWORD                   dwRetryCount;
    DWORD                   dwNextRetryTickCount;
    BYTE                    abEventTimer[CBEVENTTIMER];
    XONLINEP_USER           machineUser;
    XONLINETASK_DNS_LOOKUP  DNSTask;
    XNDNS*                  pDestAddress;
    SOCKET                  socket;
    WSABUF                  WSABuffer;
    XONLINETASK_SOCKIO      SendRecvTask; // No XOnlineCloseTask needed
    BYTE                    recvBuffer[XONLINE_AS_EXCHANGE_BUFFER_SIZE];
    PXKERB_TGT_CONTEXT      pSingleTGTContext;
};

//
// Send AS Request for GetSingleTicket
//
HRESULT CXo::GetMachineAccountSendAsRequest(PXONLINETASK_GET_MACHINE_ACCOUNT pGetMachineAccountTask)
{
    int err;
    HRESULT hr = S_OK;
    WSABUF WSABuffer;
    WSAOVERLAPPED wsaOverlapped;
    struct sockaddr_in ServerAddress;
    NTSTATUS Status;
    DWORD dwType;
    DWORD cbResultLength;
    XBOX_FACTORY_SETTINGS factorySettings;
    XONLINEP_USER onlineUser;
    BYTE abBuffer[XONLINE_AS_EXCHANGE_BUFFER_SIZE];
    DWORD dwMessageLength = sizeof(abBuffer);

#ifdef TODO_REALLY_READ_ONLINE_KEY_FROM_EEPROM
    //
    // Read Serial Number from the EEPROM
    //
    hr = _XOnlineGetSerialNumber((CHAR*)factorySettings.SerialNumber);
    if (FAILED(hr))
    {
        TraceSz1( AuthWarn, "GetMachineAccountSendAsRequest: _XOnlineGetSerialNumber Failed hr:0x%X", hr );
        hr = XONLINE_E_LOGON_INVALID_XBOX_ONLINE_INFO;
        goto Cleanup;
    }

    //
    // Read OnlineKey from the EEPROM
    //
    Status = ExQueryNonVolatileSetting(XC_FACTORY_ONLINE_KEY, &dwType, factorySettings.OnlineKey, sizeof(factorySettings.OnlineKey), &cbResultLength);
    if (Status != ERROR_SUCCESS)
    {
        TraceSz1( AuthWarn, "GetMachineAccountSendAsRequest: ExQueryNonVolatileSetting Failed Status:0x%X", Status );
        hr = XONLINE_E_LOGON_INVALID_XBOX_ONLINE_INFO;
        goto Cleanup;
    }
    else
    {
        Assert( dwType == REG_BINARY );
        Assert( cbResultLength == sizeof(factorySettings.OnlineKey) );
    }

    //
    // morph it
    //
    MorphKeyByHardDriveKeyEx( GetHdKey(), factorySettings.OnlineKey, sizeof(factorySettings.OnlineKey) );
#else
    RtlCopyMemory( factorySettings.SerialNumber, "999999999999", sizeof(factorySettings.SerialNumber) );
    RtlCopyMemory( factorySettings.OnlineKey, DEVKIT_ONLINE_RAND_KEY, sizeof(factorySettings.OnlineKey) );    
#endif

    //
    // Create machine account from EEPROM info
    //
    RtlZeroMemory( &onlineUser, sizeof(onlineUser) );
    RtlCopyMemory(onlineUser.name, factorySettings.SerialNumber, sizeof(factorySettings.SerialNumber));
    Assert( sizeof(onlineUser.key) == sizeof(factorySettings.OnlineKey) );
    RtlCopyMemory( onlineUser.key, factorySettings.OnlineKey, sizeof(onlineUser.key) );
    RtlCopyMemory( onlineUser.realm, MACS_REALM, sizeof(MACS_REALM) );

    //
    // Allocate memory for pSingleTGTContext
    //
    if (pGetMachineAccountTask->pSingleTGTContext == NULL)
    {
        pGetMachineAccountTask->pSingleTGTContext = (PXKERB_TGT_CONTEXT)SysAllocZ(sizeof(*(pGetMachineAccountTask->pSingleTGTContext)),
            PTAG_XKERB_TGT_CONTEXT);
        if ( pGetMachineAccountTask->pSingleTGTContext == NULL )
        {
            hr = XONLINE_E_OUT_OF_MEMORY;
            goto Cleanup;
        }
    }
    
    hr = XkerbBuildAsRequest(
        FALSE,
        &onlineUser,
        abBuffer,
        &dwMessageLength,
        pGetMachineAccountTask->pSingleTGTContext
        );
    if (FAILED(hr))
    {
        hr = XONLINE_E_OUT_OF_MEMORY;
        goto Cleanup;
    }

    ServerAddress.sin_family = AF_INET;
    ServerAddress.sin_addr = pGetMachineAccountTask->pDestAddress->aina[pGetMachineAccountTask->dwRetryCount % pGetMachineAccountTask->pDestAddress->cina];
    ServerAddress.sin_port = htons(KERB_KDC_PORT);

    WSABuffer.len = dwMessageLength;
    WSABuffer.buf = (char*)abBuffer;
    wsaOverlapped.hEvent = pGetMachineAccountTask->xonTask.hEventWorkAvailable;
    
    TraceSz5( AuthVerbose, "GetMachineAccountSendAsRequest send %d bytes to: %d.%d.%d.%d",
        dwMessageLength,
        pGetMachineAccountTask->pDestAddress->aina[pGetMachineAccountTask->dwRetryCount % pGetMachineAccountTask->pDestAddress->cina].S_un.S_un_b.s_b1, 
        pGetMachineAccountTask->pDestAddress->aina[pGetMachineAccountTask->dwRetryCount % pGetMachineAccountTask->pDestAddress->cina].S_un.S_un_b.s_b2, 
        pGetMachineAccountTask->pDestAddress->aina[pGetMachineAccountTask->dwRetryCount % pGetMachineAccountTask->pDestAddress->cina].S_un.S_un_b.s_b3, 
        pGetMachineAccountTask->pDestAddress->aina[pGetMachineAccountTask->dwRetryCount % pGetMachineAccountTask->pDestAddress->cina].S_un.S_un_b.s_b4); 

    err = WSASendTo(
            pGetMachineAccountTask->socket,
            &WSABuffer, 1,
            &dwMessageLength, 0,
            (LPSOCKADDR) &ServerAddress, sizeof(ServerAddress),
            &wsaOverlapped, NULL);
    if (err == SOCKET_ERROR)
    {
        TraceSz1( AuthWarn, "GetMachineAccountSendAsRequest: WSASendTo Failed WSAGetLastError:0x%X", WSAGetLastError() );
        hr = XONLINE_E_LOGON_MACS_FAILED;
        goto Cleanup;
    }

    pGetMachineAccountTask->dwNextRetryTickCount =
        GetTickCount() + g_dwMACSRetryDelayInMilliSeconds[pGetMachineAccountTask->dwRetryCount];

    XnSetEventTimer(
        pGetMachineAccountTask->abEventTimer,
        pGetMachineAccountTask->xonTask.hEventWorkAvailable,
        g_dwMACSRetryDelayInMilliSeconds[pGetMachineAccountTask->dwRetryCount] );
    
Cleanup:
    return hr;
}

//
// Do work function for GetSingleTicket
//
HRESULT CXo::GetMachineAccountContinue(XONLINETASK_HANDLE hTask)
{
    Assert(hTask != NULL);

    HRESULT hr = S_OK;
    DWORD dwMessageLength;
    PXONLINETASK_GET_MACHINE_ACCOUNT pGetMachineAccountTask = (PXONLINETASK_GET_MACHINE_ACCOUNT)hTask;
    
    switch (pGetMachineAccountTask->dwState)
    {
    case LOGON_DNS_IN_PROGRESS:
        hr = XOnlineTaskContinue( (XONLINETASK_HANDLE)&pGetMachineAccountTask->DNSTask );
        if (hr == XONLINETASK_S_SUCCESS)
        {
            hr = DNSLookupGetResults( (XONLINETASK_HANDLE)&pGetMachineAccountTask->DNSTask, &pGetMachineAccountTask->pDestAddress );
            Assert( hr == XONLINETASK_S_SUCCESS );
            
            pGetMachineAccountTask->socket = socket( AF_INET, SOCK_DGRAM, IPPROTO_IP );
            if (pGetMachineAccountTask->socket == INVALID_SOCKET)
            {
                TraceSz1( AuthWarn, "GetMachineAccountContinue: socket create failed WSAGetLastError:0x%X", WSAGetLastError() );
                pGetMachineAccountTask->hr = XONLINE_E_LOGON_MACS_FAILED;
                goto Cleanup;
            }

            XnSetInsecure(pGetMachineAccountTask->socket);

            pGetMachineAccountTask->WSABuffer.len = sizeof(pGetMachineAccountTask->recvBuffer);
            pGetMachineAccountTask->WSABuffer.buf = (char*)pGetMachineAccountTask->recvBuffer;

            SendRecvInitializeContext(
                    pGetMachineAccountTask->socket,
                    &pGetMachineAccountTask->WSABuffer, 1, 0,
                    pGetMachineAccountTask->xonTask.hEventWorkAvailable,
                    &pGetMachineAccountTask->SendRecvTask );

            hr = GetMachineAccountSendAsRequest( pGetMachineAccountTask );
            if (FAILED(hr))
            {
                pGetMachineAccountTask->hr = hr;
                goto Cleanup;
            }
            
            //
            // Kick off the asynchronous recv operation
            //
            hr = RecvInternal(&pGetMachineAccountTask->SendRecvTask);
            if (FAILED(hr))
            {
                TraceSz1( AuthWarn, "GetMachineAccountContinue: RecvInternal failed hr:0x%X", hr );
                pGetMachineAccountTask->hr = XONLINE_E_LOGON_MACS_FAILED;
                goto Cleanup;
            }

            pGetMachineAccountTask->dwState = LOGON_RECV_IN_PROGRESS;
            break;
        }
        else if (FAILED(hr))
        {
            pGetMachineAccountTask->hr = hr;
            goto Cleanup;
        }
        else
        {
            Assert( hr == XONLINETASK_S_RUNNING );
        }
        break;

    case LOGON_RECV_IN_PROGRESS:
        hr = XOnlineTaskContinue( (XONLINETASK_HANDLE)&pGetMachineAccountTask->SendRecvTask );
        if (hr == XONLINETASK_S_SUCCESS)
        {
            dwMessageLength = 0;
            hr = GetSendRecvResults( (XONLINETASK_HANDLE)&pGetMachineAccountTask->SendRecvTask, &dwMessageLength, NULL, NULL );
            Assert( hr == XONLINETASK_S_SUCCESS );
            Assert( dwMessageLength > 0 );
            
            TraceSz1( AuthVerbose, "GetMachineAccountContinue received %d bytes!", dwMessageLength);

            hr = XkerbVerifyAsReply(
                pGetMachineAccountTask->recvBuffer,
                dwMessageLength,
                pGetMachineAccountTask->pSingleTGTContext
                );
            if ( hr == (HRESULT) STATUS_TIME_DIFFERENCE_AT_DC )
            {
                TraceSz( AuthWarn, "GetMachineAccountContinue adjusted Xbox clock according to KDC!");
                if (pGetMachineAccountTask->dwAdjustedTime < MAX_TIME_ADJUSTMENTS)
                {
                    ++pGetMachineAccountTask->dwAdjustedTime;
                    
                    hr = GetMachineAccountSendAsRequest( pGetMachineAccountTask );
                    if (FAILED(hr))
                    {
                        pGetMachineAccountTask->hr = hr;
                        goto Cleanup;
                    }

                    //
                    // Kick off another new asynchronous recv operation
                    //
                    hr = RecvInternal(&pGetMachineAccountTask->SendRecvTask);
                    if (FAILED(hr))
                    {
                        TraceSz1( AuthWarn, "GetMachineAccountContinue: RecvInternal failed hr:0x%X", hr );
                        pGetMachineAccountTask->hr = XONLINE_E_LOGON_MACS_FAILED;
                        goto Cleanup;
                    }

                    //
                    // State not changed, go back and continue waiting for a response
                    //
                    goto Cleanup;
                }
                else
                {
                    TraceSz1( AuthWarn, "GetMachineAccountContinue: adjusting time too many times: %d", pGetMachineAccountTask->dwAdjustedTime );
                    pGetMachineAccountTask->hr = XONLINE_E_LOGON_MACS_FAILED;
                    goto Cleanup;
                }
            }
            else if (FAILED(hr))
            {
                TraceSz1( AuthWarn, "GetMachineAccountContinue: XkerbVerifyAsReply failed with hr: 0x%X", hr );
                pGetMachineAccountTask->hr = XONLINE_E_LOGON_MACS_FAILED;
                goto Cleanup;
            }

            //
            // Handle account creation preauth returned from MACS
            //
            if ( pGetMachineAccountTask->pSingleTGTContext->pAccountCreationPreAuth == NULL )
            {
                TraceSz( AuthWarn, "GetMachineAccountContinue: Kerb reply contains no pre-auth" );
                pGetMachineAccountTask->hr = XONLINE_E_LOGON_MACS_FAILED;
                goto Cleanup;
            }

            m_qwMachineId = pGetMachineAccountTask->machineUser.xuid.qwUserID = pGetMachineAccountTask->pSingleTGTContext->pAccountCreationPreAuth->qwUserID;
            RtlCopyMemory( pGetMachineAccountTask->machineUser.name, pGetMachineAccountTask->pSingleTGTContext->pAccountCreationPreAuth->name, sizeof(pGetMachineAccountTask->machineUser.name) );
            RtlCopyMemory( pGetMachineAccountTask->machineUser.kingdom, pGetMachineAccountTask->pSingleTGTContext->pAccountCreationPreAuth->kingdom, sizeof(pGetMachineAccountTask->machineUser.kingdom) );
            RtlCopyMemory( pGetMachineAccountTask->machineUser.domain, pGetMachineAccountTask->pSingleTGTContext->pAccountCreationPreAuth->domain, sizeof(pGetMachineAccountTask->machineUser.domain) );
            RtlCopyMemory( pGetMachineAccountTask->machineUser.realm, pGetMachineAccountTask->pSingleTGTContext->pAccountCreationPreAuth->realm, sizeof(pGetMachineAccountTask->machineUser.realm) );
            RtlCopyMemory( pGetMachineAccountTask->machineUser.key, pGetMachineAccountTask->pSingleTGTContext->pAccountCreationPreAuth->key, sizeof(pGetMachineAccountTask->machineUser.key) );

            if (!SetMachineAccount( &(pGetMachineAccountTask->machineUser) ) )
            {
                TraceSz( AuthWarn, "GetMachineAccountContinue: XoSetMachineAccount failed");
                pGetMachineAccountTask->hr = XONLINE_E_IO_ERROR;
                goto Cleanup;
            }

            //
            // We succeeded!
            //
            TraceSz4( AuthVerbose, "GetMachineAccountContinue recieved %d bytes new id:%I64X user:%s kingdom:%s", dwMessageLength, pGetMachineAccountTask->machineUser.xuid.qwUserID, pGetMachineAccountTask->machineUser.name, pGetMachineAccountTask->machineUser.kingdom );
            pGetMachineAccountTask->dwState = LOGON_TASK_COMPLETE;
            pGetMachineAccountTask->hr = XONLINETASK_S_SUCCESS;
            break;
        }
        else if (FAILED(hr))
        {
            TraceSz1( AuthWarn, "GetMachineAccountContinue: recv failed with hr: 0x%X", hr );
            pGetMachineAccountTask->hr = XONLINE_E_LOGON_MACS_FAILED;
            goto Cleanup;            
        }

        //
        // Check if we timed out
        //
        Assert( hr == XONLINETASK_S_RUNNING );
        if (GetTickCount() >= pGetMachineAccountTask->dwNextRetryTickCount)
        {
            if ( ++pGetMachineAccountTask->dwRetryCount >= g_dwNumMACSRetry )
            {
                TraceSz1( AuthWarn, "GetMachineAccountContinue: timed out after %d retries", pGetMachineAccountTask->dwRetryCount );
                pGetMachineAccountTask->hr = XONLINE_E_LOGON_MACS_TIMEDOUT;
                goto Cleanup;
            }
            
            //
            // Need to retry with the next IP address
            //
            hr = GetMachineAccountSendAsRequest( pGetMachineAccountTask );
            if (FAILED(hr))
            {
                pGetMachineAccountTask->hr = hr;
                goto Cleanup;
            }
        }
        break;
    
    case LOGON_TASK_COMPLETE:
        break;
        
    default:
        AssertSz(FALSE, "GetMachineAccountContinue: Bad State");
    }

Cleanup:
    if (pGetMachineAccountTask->hr != XONLINETASK_S_RUNNING)
    {
        pGetMachineAccountTask->dwState = LOGON_TASK_COMPLETE;
    }
    
    return(pGetMachineAccountTask->hr);
}

//
// Close function for GetSingleTicket
//
void CXo::GetMachineAccountClose(XONLINETASK_HANDLE hTask)
{
    Assert(hTask != NULL);

    PXONLINETASK_GET_MACHINE_ACCOUNT pGetMachineAccountTask = (PXONLINETASK_GET_MACHINE_ACCOUNT)hTask;
    
    if (DNSLookupIsValidTask( (XONLINETASK_HANDLE)&(pGetMachineAccountTask->DNSTask) ))
    {
        XOnlineTaskClose((XONLINETASK_HANDLE)&(pGetMachineAccountTask->DNSTask));
    }

    if (pGetMachineAccountTask->socket != INVALID_SOCKET)
    {
        WSACancelOverlappedIO( pGetMachineAccountTask->socket );
        closesocket(pGetMachineAccountTask->socket);
    }

    if (pGetMachineAccountTask->pSingleTGTContext != NULL)
    {
        Assert (pGetMachineAccountTask->pSingleTGTContext->pInputTGTContext == NULL);
        if (pGetMachineAccountTask->pSingleTGTContext->pAccountCreationPreAuth != NULL)
        {
            SysFree( pGetMachineAccountTask->pSingleTGTContext->pAccountCreationPreAuth );            
        }
        SysFree( pGetMachineAccountTask->pSingleTGTContext );
    }

    XnSetEventTimer(pGetMachineAccountTask->abEventTimer, NULL, 0xFFFFFFFF);

    SysFree(pGetMachineAccountTask);
}

//
// Function to kick off a GetSingleTicket
//
HRESULT CXo::GetMachineAccount(HANDLE hWorkEvent, PXONLINETASK_HANDLE phGetMachineAccountTask)
{
    HRESULT hr = S_OK;
    PXONLINETASK_GET_MACHINE_ACCOUNT pGetMachineAccountTask;
    XC_ONLINE_MACHINE_ACCOUNT_STRUCT* pMachineAccount;
    BYTE abConfigData[CONFIG_DATA_LENGTH];
    BOOL fUseExistingAccount = !m_fGetNewMachineAccount;
    
    Assert(phGetMachineAccountTask != NULL);

    m_fGetNewMachineAccount = FALSE;
    *phGetMachineAccountTask = NULL;
    pGetMachineAccountTask = (PXONLINETASK_GET_MACHINE_ACCOUNT)SysAllocZ(sizeof(*pGetMachineAccountTask),
        PTAG_XONLINETASK_GET_MACHINE_ACCOUNT);
    if (pGetMachineAccountTask == NULL)
    {
        hr = XONLINE_E_OUT_OF_MEMORY;
        goto Cleanup;
    }
    
    TaskInitializeContext(&(pGetMachineAccountTask->xonTask));
    pGetMachineAccountTask->xonTask.pfnContinue = GetMachineAccountContinue;
    pGetMachineAccountTask->xonTask.pfnClose = GetMachineAccountClose;
    pGetMachineAccountTask->xonTask.hEventWorkAvailable = hWorkEvent;
    pGetMachineAccountTask->hr = XONLINETASK_S_RUNNING;
    pGetMachineAccountTask->socket = INVALID_SOCKET;
    
#ifdef XONLINE_FEATURE_INSECURE
    if (m_fForceNewMachineAccount)
    {
        fUseExistingAccount = FALSE;
    }
#endif

    //
    // Pull out information about the machine account from config sector
    //
    if (XNetLoadConfigSector(m_hConfigVolume, MACHINE_ACCOUNT_CONFIG_SECTOR, abConfigData, sizeof(abConfigData)))
    {
        if (fUseExistingAccount)
        {
            pMachineAccount = (XC_ONLINE_MACHINE_ACCOUNT_STRUCT*)abConfigData;
            if (VerifyOnlineUserSignature(pMachineAccount))
            {
                DecryptKeyWithHardDriveKeyEx( GetHdKey(), pMachineAccount->key, sizeof(pMachineAccount->key) );

                RtlCopyMemory( &(pGetMachineAccountTask->machineUser), pMachineAccount, sizeof(*pMachineAccount) );
                m_qwMachineId = pMachineAccount->xuid.qwUserID;

                pGetMachineAccountTask->dwState = LOGON_TASK_COMPLETE;
                pGetMachineAccountTask->hr = XONLINETASK_S_SUCCESS;
            }
        }
    }
    
    if ( pGetMachineAccountTask->hr == XONLINETASK_S_RUNNING )
    {
        hr = DNSLookup(
                MACS_KDC_DNS,
                hWorkEvent,
                &pGetMachineAccountTask->DNSTask
                );
        pGetMachineAccountTask->dwState = LOGON_DNS_IN_PROGRESS;
    }
    
    *phGetMachineAccountTask = (XONLINETASK_HANDLE) pGetMachineAccountTask;

Cleanup:
    if (FAILED(hr))
    {
        *phGetMachineAccountTask = NULL;
        if (pGetMachineAccountTask != NULL)
        {
            SysFree(pGetMachineAccountTask);
        }
    }
    return(hr);
}

//
// Function to retrieve the results of a GetSingleTicket
//
HRESULT CXo::GetMachineAccountGetResults(XONLINETASK_HANDLE hTask, PXONLINE_USER pMachineUser)
{
    Assert(hTask != NULL);
    Assert(pMachineUser != NULL);

    PXONLINETASK_GET_MACHINE_ACCOUNT  pGetMachineAccountTask = (PXONLINETASK_GET_MACHINE_ACCOUNT)hTask;

    if (pGetMachineAccountTask->hr == XONLINETASK_S_SUCCESS)
    {
        RtlCopyMemory( pMachineUser, &pGetMachineAccountTask->machineUser, sizeof(*pMachineUser) );
    }

    return(pGetMachineAccountTask->hr);
}

//
// Define a task context structure for
//
struct XONLINETASK_GET_COMBINED_TICKET
{
    XONLINETASK_CONTEXT     xonTask;
    HRESULT                 hr;
    DWORD                   dwState;
    PXONLINE_USER           pMachineUser;
    DWORD                   dwCurrentUniqueUser;
    XONLINETASK_HANDLE      hGetTGTTask;
    XONLC_CONTEXT           cacheContext;
    BOOL                    fTicketFromCache;
    PXKERB_TGT_CONTEXT      pTGTContext;
};

//
// Do work function for GetCombinedTicket
//
HRESULT CXo::GetCombinedTicketContinue(XONLINETASK_HANDLE hTask)
{
    Assert(hTask != NULL);

    DWORD i;
    HRESULT hr = S_OK;
    BOOL fMoreWorkToDo;
    TimeStamp CurrentTime;
    PXONLINETASK_GET_COMBINED_TICKET pGetCombinedTicketTask = (PXONLINETASK_GET_COMBINED_TICKET)hTask;

    do
    {
        fMoreWorkToDo = FALSE;
        
        switch (pGetCombinedTicketTask->dwState)
        {
        case LOGON_START_CACHE_LOOKUP:
            if (m_pLogonTask->dwCombinedTicketCacheState == XON_CACHE_STATE_OPENING)
            {    
                break;
            }

            if (m_pLogonTask->dwCombinedTicketCacheState == XON_CACHE_STATE_OPENED ||
                m_pLogonTask->dwCombinedTicketCacheState == XON_CACHE_STATE_UPDATED)            
            {
                Assert( m_pLogonTask->hCombinedTicketCache != NULL );
                Assert( pGetCombinedTicketTask->pTGTContext != NULL );
                
                RtlZeroMemory(&pGetCombinedTicketTask->cacheContext, sizeof(pGetCombinedTicketTask->cacheContext));
                pGetCombinedTicketTask->cacheContext.dwRecordBufferSize = sizeof(XKERB_TGT_CONTEXT) - FIELD_OFFSET(XKERB_TGT_CONTEXT, ClientName);
                pGetCombinedTicketTask->cacheContext.pbRecordBuffer = (BYTE*)&pGetCombinedTicketTask->pTGTContext->ClientName;
                pGetCombinedTicketTask->cacheContext.pbIndexData = (BYTE*)pGetCombinedTicketTask->pTGTContext;

                hr = CacheLookup(m_pLogonTask->hCombinedTicketCache, &pGetCombinedTicketTask->cacheContext);

                if (FAILED(hr) || !pGetCombinedTicketTask->cacheContext.bValidDataInCache)
                {
                    TraceSz3( AuthVerbose, "GetCombinedTicketContinue cache miss 0x%X %d (%8X)", hr, pGetCombinedTicketTask->cacheContext.bValidDataInCache, XConfigChecksum(pGetCombinedTicketTask->cacheContext.pbIndexData, FIELD_OFFSET(XKERB_TGT_CONTEXT, StartTime)) );
                    pGetCombinedTicketTask->dwState = LOGON_START_CACHE_MISS;
                    fMoreWorkToDo = TRUE;
                    break;
                }

                GetSystemTimeAsFileTime((LPFILETIME)&CurrentTime);
                if (pGetCombinedTicketTask->pTGTContext->ExpirationTime.QuadPart < CurrentTime.QuadPart)
                {
                    //
                    // Ticket has expired, nuke the entry and take cache miss path
                    //
                    TraceSz2( AuthVerbose, "GetCombinedTicketContinue cache miss expired ticket 0x%016I64X < 0x%016I64X", pGetCombinedTicketTask->pTGTContext->ExpirationTime.QuadPart, CurrentTime.QuadPart );
                    CacheDelete( m_pLogonTask->hCombinedTicketCache, &pGetCombinedTicketTask->cacheContext );
                    pGetCombinedTicketTask->dwState = LOGON_START_CACHE_MISS;
                    fMoreWorkToDo = TRUE;
                    break;
                }

                if (pGetCombinedTicketTask->cacheContext.bCallRetrieveNext)
                {
                    hr = CacheRetrieve( m_pLogonTask->hCombinedTicketCache, m_pLogonTask->hCombinedTicketCacheTask, &pGetCombinedTicketTask->cacheContext );
                    if (FAILED(hr))
                    {
                        pGetCombinedTicketTask->dwState = LOGON_START_CACHE_MISS;
                        fMoreWorkToDo = TRUE;
                        break;
                    }
                    TraceSz1( AuthVerbose, "GetCombinedTicketContinue cache hit using retrieve (%8X)", XConfigChecksum(pGetCombinedTicketTask->cacheContext.pbIndexData, FIELD_OFFSET(XKERB_TGT_CONTEXT, StartTime)) );
                    pGetCombinedTicketTask->dwState = LOGON_CACHE_RETRIEVE_IN_PROGRESS;
                    fMoreWorkToDo = TRUE;
                    break;
                }
                else
                {
                    TraceSz1( AuthVerbose, "GetCombinedTicketContinue cache hit from MRU (%8X)", XConfigChecksum(pGetCombinedTicketTask->cacheContext.pbIndexData, FIELD_OFFSET(XKERB_TGT_CONTEXT, StartTime)) );
                    pGetCombinedTicketTask->fTicketFromCache = TRUE;
                    pGetCombinedTicketTask->hr = XONLINETASK_S_SUCCESS;
                    break;
                }
            }
            else
            {
                pGetCombinedTicketTask->dwState = LOGON_START_CACHE_MISS;
                fMoreWorkToDo = TRUE;
                break;
            }
            break;
            
        case LOGON_CACHE_RETRIEVE_IN_PROGRESS:
            hr = XOnlineTaskContinue( m_pLogonTask->hCombinedTicketCacheTask );
            if ( hr == XONLINETASK_S_SUCCESS )
            {
                pGetCombinedTicketTask->fTicketFromCache = TRUE;
                pGetCombinedTicketTask->hr = XONLINETASK_S_SUCCESS;
                m_pLogonTask->fNeedToFlushCombinedTicketCache = TRUE;
                break;
            }
            else if (FAILED(hr))
            {
                pGetCombinedTicketTask->dwState = LOGON_START_CACHE_MISS;
                fMoreWorkToDo = TRUE;
                break;
            }
            break;

        case LOGON_START_CACHE_MISS:
            if (pGetCombinedTicketTask->pTGTContext != NULL)
            {
                SysFree( pGetCombinedTicketTask->pTGTContext );
                pGetCombinedTicketTask->pTGTContext = NULL;
            }

            if (m_dwUniqueLogonUsers > 0)
            {
                hr = GetSingleTicket( FALSE, NULL, m_apUniqueLogonUsers[pGetCombinedTicketTask->dwCurrentUniqueUser], pGetCombinedTicketTask->xonTask.hEventWorkAvailable, &pGetCombinedTicketTask->hGetTGTTask );
                if ( FAILED(hr) )
                {
                    pGetCombinedTicketTask->hr = hr;
                    goto Cleanup;
                }                    
            }
            else
            {
                fMoreWorkToDo = TRUE;
            }
            pGetCombinedTicketTask->dwState = LOGON_MISC_IN_PROGRESS;
            break;

        case LOGON_MISC_IN_PROGRESS:
            if (pGetCombinedTicketTask->hGetTGTTask != NULL)
            {
                hr = XOnlineTaskContinue( (XONLINETASK_HANDLE)pGetCombinedTicketTask->hGetTGTTask );
                if ( hr == XONLINETASK_S_SUCCESS )
                {
                    Assert( pGetCombinedTicketTask->pTGTContext == NULL );
                    hr = GetSingleTicketGetResults( (XONLINETASK_HANDLE)pGetCombinedTicketTask->hGetTGTTask, &pGetCombinedTicketTask->pTGTContext );
                    Assert( hr == XONLINETASK_S_SUCCESS );
                    Assert(pGetCombinedTicketTask->hGetTGTTask != NULL);
                    XOnlineTaskClose(pGetCombinedTicketTask->hGetTGTTask);
                    pGetCombinedTicketTask->hGetTGTTask = NULL;
                    pGetCombinedTicketTask->dwCurrentUniqueUser++;
                    if (pGetCombinedTicketTask->dwCurrentUniqueUser < m_dwUniqueLogonUsers)
                    {
                        Assert(pGetCombinedTicketTask->pTGTContext != NULL);
                        hr = GetSingleTicket( FALSE, pGetCombinedTicketTask->pTGTContext, m_apUniqueLogonUsers[pGetCombinedTicketTask->dwCurrentUniqueUser], pGetCombinedTicketTask->xonTask.hEventWorkAvailable, &pGetCombinedTicketTask->hGetTGTTask );
                        if ( FAILED(hr) )
                        {
                            pGetCombinedTicketTask->hr = hr;
                            goto Cleanup;
                        }                    
                        pGetCombinedTicketTask->pTGTContext = NULL;
                    }
                }
                else if (FAILED(hr))
                {
                    if (pGetCombinedTicketTask->dwCurrentUniqueUser > m_dwUniqueLogonUsers && hr == XONLINE_E_LOGON_AUTHENTICATION_FAILED)
                    {
                        //
                        // Mark it as such so that the logon task knows to retry via creating a new machine account
                        //
                        hr = XONLINE_E_LOGON_MACHINE_AUTHENTICATION_FAILED;
                    }
                    
                    pGetCombinedTicketTask->hr = hr;
                    goto Cleanup;
                }
                else
                {
                    Assert( hr == XONLINETASK_S_RUNNING );
                }
            }

            if (pGetCombinedTicketTask->hGetTGTTask == NULL)
            {
                Assert( pGetCombinedTicketTask->dwCurrentUniqueUser >= m_dwUniqueLogonUsers );
                if (pGetCombinedTicketTask->dwCurrentUniqueUser == m_dwUniqueLogonUsers)
                {
                    //
                    // Got a combined ticket with all users, now make the final machine account cross-realm request
                    //
                    hr = GetSingleTicket( TRUE, pGetCombinedTicketTask->pTGTContext, pGetCombinedTicketTask->pMachineUser, pGetCombinedTicketTask->xonTask.hEventWorkAvailable, &pGetCombinedTicketTask->hGetTGTTask );
                    if ( FAILED(hr) )
                    {
                        pGetCombinedTicketTask->hr = hr;
                        goto Cleanup;
                    }                    
                    pGetCombinedTicketTask->pTGTContext = NULL;
                    pGetCombinedTicketTask->dwCurrentUniqueUser++;
                }
                else
                {
                    //
                    // Got the final combined ticket
                    //
                    Assert(pGetCombinedTicketTask->pTGTContext != NULL);
                    pGetCombinedTicketTask->dwState = LOGON_TASK_COMPLETE;
                    pGetCombinedTicketTask->hr = XONLINETASK_S_SUCCESS;
                }
            }
            break;
        
        case LOGON_TASK_COMPLETE:
            break;
            
        default:
            AssertSz(FALSE, "GetCombinedTicketContinue: Bad State");
        }
    } while (fMoreWorkToDo);
    
Cleanup:
    if (pGetCombinedTicketTask->hr != XONLINETASK_S_RUNNING)
    {
        pGetCombinedTicketTask->dwState = LOGON_TASK_COMPLETE;
    }
    
    return(pGetCombinedTicketTask->hr);
}

//
// Close function for GetCombinedTicket
//
void CXo::GetCombinedTicketClose(XONLINETASK_HANDLE hTask)
{
    Assert(hTask != NULL);

    DWORD i;
    PXONLINETASK_GET_COMBINED_TICKET pGetCombinedTicketTask = (PXONLINETASK_GET_COMBINED_TICKET)hTask;

    if (pGetCombinedTicketTask->hGetTGTTask != NULL)
    {
        XOnlineTaskClose( pGetCombinedTicketTask->hGetTGTTask );
    }
    
    if (pGetCombinedTicketTask->pTGTContext != NULL)
    {
        SysFree( pGetCombinedTicketTask->pTGTContext );
    }

    SysFree(pGetCombinedTicketTask);
}

//
// Function to kick off a GetCombinedTicket
//
HRESULT CXo::GetCombinedTicket(PXONLINE_USER pMachineUser, BOOL fUseCache, HANDLE hWorkEvent, PXONLINETASK_HANDLE phGetCombinedTicketTask)
{
    DWORD i;
    HRESULT hr;
    PXONLINETASK_GET_COMBINED_TICKET pGetCombinedTicketTask;
    PXONLINE_USER pTempUser;
    
    Assert(pMachineUser != NULL);
    Assert(phGetCombinedTicketTask != NULL);

    *phGetCombinedTicketTask = NULL;
    pGetCombinedTicketTask = (PXONLINETASK_GET_COMBINED_TICKET)SysAllocZ(sizeof(*pGetCombinedTicketTask), PTAG_XONLINETASK_GET_COMBINED_TICKET);
    if (pGetCombinedTicketTask == NULL)
    {
        hr = XONLINE_E_OUT_OF_MEMORY;
        goto Cleanup;
    }
    
    TaskInitializeContext(&(pGetCombinedTicketTask->xonTask));
    pGetCombinedTicketTask->xonTask.pfnContinue = GetCombinedTicketContinue;
    pGetCombinedTicketTask->xonTask.pfnClose = GetCombinedTicketClose;
    pGetCombinedTicketTask->xonTask.hEventWorkAvailable = hWorkEvent;
    pGetCombinedTicketTask->hr = XONLINETASK_S_RUNNING;
    pGetCombinedTicketTask->dwState = LOGON_MISC_IN_PROGRESS;
    pGetCombinedTicketTask->pMachineUser = pMachineUser;

    if (fUseCache)
    {
        pGetCombinedTicketTask->pTGTContext = (PXKERB_TGT_CONTEXT)SysAllocZ(sizeof(*(pGetCombinedTicketTask->pTGTContext)), PTAG_XKERB_TGT_CONTEXT);
        if ( pGetCombinedTicketTask->pTGTContext == NULL )
        {
            hr = XONLINE_E_OUT_OF_MEMORY;
            goto Cleanup;
        }

        for (i=0; i<m_dwUniqueLogonUsers; ++i)
        {
            pGetCombinedTicketTask->pTGTContext->UserID[i] = m_apUniqueLogonUsers[i]->xuid.qwUserID;
        }

        pGetCombinedTicketTask->dwState = LOGON_START_CACHE_LOOKUP;
    }
    else
    {
        pGetCombinedTicketTask->dwState = LOGON_START_CACHE_MISS;
    }
    
    GetCombinedTicketContinue( (XONLINETASK_HANDLE)pGetCombinedTicketTask );
    
    *phGetCombinedTicketTask = (XONLINETASK_HANDLE)pGetCombinedTicketTask;

	hr = S_OK;

Cleanup:
    if (FAILED(hr))
    {
        *phGetCombinedTicketTask = NULL;
        if (pGetCombinedTicketTask != NULL)
        {
            if (pGetCombinedTicketTask->hGetTGTTask != NULL)
            {
                XOnlineTaskClose( pGetCombinedTicketTask->hGetTGTTask );
            }

            SysFree(pGetCombinedTicketTask);
        }
    }
    
    return(hr);
}


//
// Function to retrieve the results of a GetCombinedTicket
//
HRESULT CXo::GetCombinedTicketGetResults(XONLINETASK_HANDLE hTask, PXKERB_TGT_CONTEXT * ppCombinedTGTContext, BOOL* pfTicketFromCache)
{
    Assert(hTask != NULL);
    Assert(ppCombinedTGTContext != NULL);
    Assert(pfTicketFromCache != NULL);

    PXONLINETASK_GET_COMBINED_TICKET   pGetCombinedTicketTask = (PXONLINETASK_GET_COMBINED_TICKET)hTask;

    if (pGetCombinedTicketTask->hr == XONLINETASK_S_SUCCESS)
    {
        *pfTicketFromCache = pGetCombinedTicketTask->fTicketFromCache;
        *ppCombinedTGTContext = pGetCombinedTicketTask->pTGTContext;
        pGetCombinedTicketTask->pTGTContext = NULL;
    }
    else
    {
        *ppCombinedTGTContext = NULL;
    }
    return(pGetCombinedTicketTask->hr);
}


//
// Define a task context structure for
//
struct XONLINETASK_GET_SERVICE_TICKET
{
    XONLINETASK_CONTEXT     xonTask;
    HRESULT                 hr;
    DWORD                   dwState;
    DWORD                   dwAdjustedTime;
    DWORD                   dwRetryCount;
    DWORD                   dwNextRetryTickCount;
    BYTE                    abEventTimer[CBEVENTTIMER];
    PXKERB_TGT_CONTEXT      pCombinedTGTContext;
    XONLINETASK_DNS_LOOKUP  DNSTask;
    HRESULT                 hrDNS;
    XNDNS*                  pDestAddress;
    SOCKET                  socket;
    WSABUF                  WSABuffer;
    XONLINETASK_SOCKIO      SendRecvTask; // No XOnlineCloseTask needed
    BYTE                    recvBuffer[XONLINE_TGS_EXCHANGE_BUFFER_SIZE];
    XONLC_CONTEXT           cacheContext;
    BOOL                    fTicketFromCache;
    PXKERB_SERVICE_CONTEXT  pXKerbServiceContext;
};

//
// Send TGS Requests for GetServiceTicket
//
HRESULT CXo::GetServiceTicketSendTgsRequest(PXONLINETASK_GET_SERVICE_TICKET pGetServiceTicketTask)
{
    int err;
    HRESULT hr = S_OK;
    WSABUF WSABuffer;
    WSAOVERLAPPED wsaOverlapped;
    struct sockaddr_in ServerAddress;
    BYTE abBuffer[XONLINE_AS_EXCHANGE_BUFFER_SIZE];
    DWORD dwMessageLength = sizeof(abBuffer);

    Assert(pGetServiceTicketTask->pXKerbServiceContext != NULL);
    
    hr = XkerbBuildTgsRequest(
        pGetServiceTicketTask->pCombinedTGTContext,
        abBuffer,
        &dwMessageLength,
        pGetServiceTicketTask->pXKerbServiceContext
        );
    if (FAILED(hr))
    {
        hr = XONLINE_E_OUT_OF_MEMORY;
        goto Cleanup;
    }

    ServerAddress.sin_family = AF_INET;
    ServerAddress.sin_addr = pGetServiceTicketTask->pDestAddress->aina[pGetServiceTicketTask->dwRetryCount % pGetServiceTicketTask->pDestAddress->cina];
    ServerAddress.sin_port = htons(KERB_KDC_PORT);

    WSABuffer.len = dwMessageLength;
    WSABuffer.buf = (char*)abBuffer;
    wsaOverlapped.hEvent = pGetServiceTicketTask->xonTask.hEventWorkAvailable;
    
    TraceSz5( AuthVerbose, "GetServiceTicketSendTgsRequest send %d bytes to: %d.%d.%d.%d",
        dwMessageLength,
        pGetServiceTicketTask->pDestAddress->aina[pGetServiceTicketTask->dwRetryCount % pGetServiceTicketTask->pDestAddress->cina].S_un.S_un_b.s_b1, 
        pGetServiceTicketTask->pDestAddress->aina[pGetServiceTicketTask->dwRetryCount % pGetServiceTicketTask->pDestAddress->cina].S_un.S_un_b.s_b2, 
        pGetServiceTicketTask->pDestAddress->aina[pGetServiceTicketTask->dwRetryCount % pGetServiceTicketTask->pDestAddress->cina].S_un.S_un_b.s_b3, 
        pGetServiceTicketTask->pDestAddress->aina[pGetServiceTicketTask->dwRetryCount % pGetServiceTicketTask->pDestAddress->cina].S_un.S_un_b.s_b4); 

    err = WSASendTo(
            pGetServiceTicketTask->socket,
            &WSABuffer, 1,
            &dwMessageLength, 0,
            (LPSOCKADDR) &ServerAddress, sizeof(ServerAddress),
            &wsaOverlapped, NULL);
    if (err == SOCKET_ERROR)
    {
        TraceSz1( AuthWarn, "GetServiceTicketSendTgsRequest: WSASendTo Failed WSAGetLastError:0x%X", WSAGetLastError() );
        hr = XONLINE_E_LOGON_AUTHORIZATION_FAILED;
        goto Cleanup;
    }

    pGetServiceTicketTask->dwNextRetryTickCount =
        GetTickCount() + g_dwKerbRetryDelayInMilliSeconds[pGetServiceTicketTask->dwRetryCount];

    XnSetEventTimer(
        pGetServiceTicketTask->abEventTimer,
        pGetServiceTicketTask->xonTask.hEventWorkAvailable,
        g_dwKerbRetryDelayInMilliSeconds[pGetServiceTicketTask->dwRetryCount] );
    
Cleanup:
    return hr;
}


//
// Do work function for GetServiceTicket
//
HRESULT CXo::GetServiceTicketContinue(XONLINETASK_HANDLE hTask)
{
    Assert(hTask != NULL);

    HRESULT hr;
    DWORD dwMessageLength;
    XOKERBINFO* pXoKerbInfo;
    TimeStamp CurrentTime;
    BYTE abUserPerm[XONLINE_MAX_LOGON_USERS];
    PXONLINETASK_GET_SERVICE_TICKET pGetServiceTicketTask = (PXONLINETASK_GET_SERVICE_TICKET)hTask;
    BOOL fMoreWorkToDo;

    if (DNSLookupIsValidTask((XONLINETASK_HANDLE)&pGetServiceTicketTask->DNSTask))
    {
        pGetServiceTicketTask->hrDNS = XOnlineTaskContinue( (XONLINETASK_HANDLE)&pGetServiceTicketTask->DNSTask );
        if ( pGetServiceTicketTask->hrDNS == XONLINETASK_S_SUCCESS )
        {
            hr = DNSLookupGetResults( (XONLINETASK_HANDLE)&pGetServiceTicketTask->DNSTask, &pGetServiceTicketTask->pDestAddress );
            Assert( hr == XONLINETASK_S_SUCCESS );
        }
    }

    do
    {
        fMoreWorkToDo = FALSE;
        
        switch (pGetServiceTicketTask->dwState)
        {
        case LOGON_START_CACHE_LOOKUP:
            if (m_pLogonTask->dwServiceTicketCacheState == XON_CACHE_STATE_OPENING)
            {    
                break;
            }

            if (m_pLogonTask->dwServiceTicketCacheState == XON_CACHE_STATE_OPENED ||
                m_pLogonTask->dwServiceTicketCacheState == XON_CACHE_STATE_UPDATED)
            {
                Assert( m_pLogonTask->hServiceTicketCache != NULL );
                Assert( pGetServiceTicketTask->pXKerbServiceContext != NULL );
                
                RtlZeroMemory(&pGetServiceTicketTask->cacheContext, sizeof(pGetServiceTicketTask->cacheContext));
                pGetServiceTicketTask->cacheContext.dwRecordBufferSize = sizeof(XKERB_SERVICE_CONTEXT) - FIELD_OFFSET(XKERB_SERVICE_CONTEXT, siteIPAddress);
                pGetServiceTicketTask->cacheContext.pbRecordBuffer = (BYTE*)&pGetServiceTicketTask->pXKerbServiceContext->siteIPAddress;
                pGetServiceTicketTask->cacheContext.pbIndexData = (BYTE*)pGetServiceTicketTask->pXKerbServiceContext;

                hr = CacheLookup(m_pLogonTask->hServiceTicketCache, &pGetServiceTicketTask->cacheContext);

                if (FAILED(hr) || !pGetServiceTicketTask->cacheContext.bValidDataInCache)
                {
                    TraceSz3( AuthVerbose, "GetServiceTicketContinue cache miss 0x%X %d (%8X)", hr, pGetServiceTicketTask->cacheContext.bValidDataInCache, XConfigChecksum(pGetServiceTicketTask->cacheContext.pbIndexData, FIELD_OFFSET(XKERB_SERVICE_CONTEXT, StartTime)) );
                    pGetServiceTicketTask->dwState = LOGON_START_CACHE_MISS;
                    fMoreWorkToDo = TRUE;
                    break;
                }

                GetSystemTimeAsFileTime((LPFILETIME)&CurrentTime);
                if (pGetServiceTicketTask->pXKerbServiceContext->ExpirationTime.QuadPart < CurrentTime.QuadPart)
                {
                    //
                    // Ticket has expired, nuke the entry and take cache miss path
                    //
                    TraceSz2( AuthVerbose, "GetServiceTicketContinue cache miss expired ticket 0x%016I64X < 0x%016I64X", pGetServiceTicketTask->pXKerbServiceContext->ExpirationTime.QuadPart, CurrentTime.QuadPart );
                    CacheDelete( m_pLogonTask->hServiceTicketCache, &pGetServiceTicketTask->cacheContext );
                    pGetServiceTicketTask->dwState = LOGON_START_CACHE_MISS;
                    fMoreWorkToDo = TRUE;
                    break;
                }

                if (pGetServiceTicketTask->cacheContext.bCallRetrieveNext)
                {
                    hr = CacheRetrieve( m_pLogonTask->hServiceTicketCache, m_pLogonTask->hServiceTicketCacheTask, &pGetServiceTicketTask->cacheContext );
                    if (FAILED(hr))
                    {
                        pGetServiceTicketTask->dwState = LOGON_START_CACHE_MISS;
                        fMoreWorkToDo = TRUE;
                        break;
                    }
                    TraceSz1( AuthVerbose, "GetServiceTicketContinue cache hit using retrieve (%8X)", XConfigChecksum(pGetServiceTicketTask->cacheContext.pbIndexData, FIELD_OFFSET(XKERB_SERVICE_CONTEXT, StartTime)) );
                    pGetServiceTicketTask->dwState = LOGON_CACHE_RETRIEVE_IN_PROGRESS;
                    fMoreWorkToDo = TRUE;
                    break;
                }
                else
                {
                    TraceSz1( AuthVerbose, "GetServiceTicketContinue cache hit from MRU (%8X)", XConfigChecksum(pGetServiceTicketTask->cacheContext.pbIndexData, FIELD_OFFSET(XKERB_SERVICE_CONTEXT, StartTime)) );
                    pGetServiceTicketTask->fTicketFromCache = TRUE;
                    pGetServiceTicketTask->hr = XONLINETASK_S_SUCCESS;
                    break;
                }
            }
            else
            {
                pGetServiceTicketTask->dwState = LOGON_START_CACHE_MISS;
                fMoreWorkToDo = TRUE;
                break;
            }
            break;
            
        case LOGON_CACHE_RETRIEVE_IN_PROGRESS:
            hr = XOnlineTaskContinue( m_pLogonTask->hServiceTicketCacheTask );
            if ( hr == XONLINETASK_S_SUCCESS )
            {
                pGetServiceTicketTask->fTicketFromCache = TRUE;
                pGetServiceTicketTask->hr = XONLINETASK_S_SUCCESS;
                m_pLogonTask->fNeedToFlushServiceTicketCache = TRUE;
                break;
            }
            else if (FAILED(hr))
            {
                pGetServiceTicketTask->dwState = LOGON_START_CACHE_MISS;
                fMoreWorkToDo = TRUE;
                break;
            }
            break;

        case LOGON_START_CACHE_MISS:
            if (FAILED(pGetServiceTicketTask->hrDNS))
            {
                pGetServiceTicketTask->hr = pGetServiceTicketTask->hrDNS;
                goto Cleanup;
            }
            else if ( pGetServiceTicketTask->hrDNS != XONLINETASK_S_SUCCESS )
            {
                //
                // Still running, need to wait
                //
                break;
            }
            
            Assert( pGetServiceTicketTask->pCombinedTGTContext != NULL );
            
            if (pGetServiceTicketTask->socket == INVALID_SOCKET)
            {
                pGetServiceTicketTask->socket = socket( AF_INET, SOCK_DGRAM, IPPROTO_IP );
                if (pGetServiceTicketTask->socket == INVALID_SOCKET)
                {
                    TraceSz1( AuthWarn, "GetServiceTicketContinue: socket create failed WSAGetLastError:0x%X", WSAGetLastError() );
                    pGetServiceTicketTask->hr = XONLINE_E_LOGON_AUTHORIZATION_FAILED;
                    goto Cleanup;
                }

                XnSetInsecure(pGetServiceTicketTask->socket);

                pGetServiceTicketTask->WSABuffer.len = sizeof(pGetServiceTicketTask->recvBuffer);
                pGetServiceTicketTask->WSABuffer.buf = (char*)pGetServiceTicketTask->recvBuffer;

                SendRecvInitializeContext(
                        pGetServiceTicketTask->socket,
                        &pGetServiceTicketTask->WSABuffer, 1, 0,
                        pGetServiceTicketTask->xonTask.hEventWorkAvailable,
                        &pGetServiceTicketTask->SendRecvTask );
            }
            
            hr = GetServiceTicketSendTgsRequest( pGetServiceTicketTask );
            if (FAILED(hr))
            {
                pGetServiceTicketTask->hr = hr;
                goto Cleanup;
            }
            
            //
            // Kick off the asynchronous recv operation
            //
            hr = RecvInternal(&pGetServiceTicketTask->SendRecvTask);
            if (FAILED(hr))
            {
                TraceSz1( AuthWarn, "GetServiceTicketContinue: RecvInternal failed hr:0x%X", hr );
                pGetServiceTicketTask->hr = XONLINE_E_LOGON_AUTHORIZATION_FAILED;
                goto Cleanup;
            }

            pGetServiceTicketTask->dwState = LOGON_RECV_IN_PROGRESS;
            break;

        case LOGON_RECV_IN_PROGRESS:
            hr = XOnlineTaskContinue( (XONLINETASK_HANDLE)&pGetServiceTicketTask->SendRecvTask );
            if (hr == XONLINETASK_S_SUCCESS)
            {
                dwMessageLength = 0;
                hr = GetSendRecvResults( (XONLINETASK_HANDLE)&pGetServiceTicketTask->SendRecvTask, &dwMessageLength, NULL, NULL );
                Assert( hr == XONLINETASK_S_SUCCESS );
                Assert( dwMessageLength > 0 );
                
                TraceSz1( AuthVerbose, "GetServiceTicketContinue received %d bytes!", dwMessageLength );

                hr = XkerbVerifyTgsReply(
                    (PXONLINEP_USER)m_rgLogonUsers,
                    pGetServiceTicketTask->pCombinedTGTContext,
                    pGetServiceTicketTask->recvBuffer,
                    dwMessageLength,
                    pGetServiceTicketTask->pXKerbServiceContext
                    );
                if ( hr == (HRESULT) STATUS_TIME_DIFFERENCE_AT_DC )
                {
                    TraceSz( AuthWarn, "GetServiceTicketContinue adjusted Xbox clock according to KDC!");
                    if (pGetServiceTicketTask->dwAdjustedTime < MAX_TIME_ADJUSTMENTS)
                    {
                        ++pGetServiceTicketTask->dwAdjustedTime;

                        pGetServiceTicketTask->dwState = LOGON_START_CACHE_MISS;
                        fMoreWorkToDo = TRUE;
                        break;
                    }
                    else
                    {
                        TraceSz1( AuthWarn, "GetServiceTicketContinue: adjusting time too many times: %d", pGetServiceTicketTask->dwAdjustedTime );
                        pGetServiceTicketTask->hr = XONLINE_E_LOGON_AUTHORIZATION_FAILED;
                        goto Cleanup;
                    }
                }
                else if (FAILED(hr))
                {
                    TraceSz1( AuthWarn, "GetServiceTicketContinue: XkerbVerifyTgsReply failed with hr: 0x%X", hr );
                    pGetServiceTicketTask->hr = XONLINE_E_LOGON_AUTHORIZATION_FAILED;
                    goto Cleanup;
                }

    #ifdef XNET_FEATURE_TRACE
                {
                    char buffer1[256],buf[32];
                    DWORD k;
                    buffer1[0] = '\0';
                    for (k=0; k<pGetServiceTicketTask->pXKerbServiceContext->dwNumServices; ++k)
                    {
                        sprintf(buf," %d(%X)", pGetServiceTicketTask->pXKerbServiceContext->dwServiceID[k], pGetServiceTicketTask->pXKerbServiceContext->hrService[k]);
                        strcat(buffer1, buf);
                    }
                    TraceSz2( AuthVerbose, "GetServiceTicketContinue XKDC response hr=0x%X Service: %s", pGetServiceTicketTask->pXKerbServiceContext->hr, buffer1 );
                }
    #endif

                //
                // Check the master hr returned from the server
                //
                if (FAILED(pGetServiceTicketTask->pXKerbServiceContext->hr))
                {
                    pGetServiceTicketTask->hr = pGetServiceTicketTask->pXKerbServiceContext->hr;
                    goto Cleanup;
                }

                pGetServiceTicketTask->hr = XONLINETASK_S_SUCCESS;
                break;                
            }
            else if (FAILED(hr))
            {
                TraceSz1( AuthWarn, "GetServiceTicketContinue: recv failed with hr: 0x%X", hr );
                pGetServiceTicketTask->hr = XONLINE_E_LOGON_AUTHORIZATION_FAILED;
                goto Cleanup;
            }

            Assert( hr == XONLINETASK_S_RUNNING );
            //
            // Check if we timed out
            //
            if (GetTickCount() >= pGetServiceTicketTask->dwNextRetryTickCount)
            {
                if ( ++pGetServiceTicketTask->dwRetryCount >= g_dwNumKerbRetry )
                {
                    TraceSz1( AuthWarn, "GetServiceTicketContinue: timed out after %d retries", pGetServiceTicketTask->dwRetryCount );
                    pGetServiceTicketTask->hr = XONLINE_E_LOGON_AUTHORIZATION_TIMEDOUT;
                    goto Cleanup;
                }
                
                //
                // Need to retry with the next IP address
                //
                hr = GetServiceTicketSendTgsRequest( pGetServiceTicketTask );
                if (FAILED(hr))
                {
                    pGetServiceTicketTask->hr = hr;
                    goto Cleanup;
                }
            }
            break;
            
        case LOGON_TASK_COMPLETE:
            break;
            
        default:
            AssertSz(FALSE, "GetServiceTicketContinue: Bad State");
        }
    } while (fMoreWorkToDo);
    
Cleanup:
    if (pGetServiceTicketTask->hr != XONLINETASK_S_RUNNING)
    {
        pGetServiceTicketTask->dwState = LOGON_TASK_COMPLETE;
    }
    
    return(pGetServiceTicketTask->hr);
}

//
// Close function for GetServiceTicket
//
void CXo::GetServiceTicketClose(XONLINETASK_HANDLE hTask)
{
    Assert(hTask != NULL);

    PXONLINETASK_GET_SERVICE_TICKET pGetServiceTicketTask = (PXONLINETASK_GET_SERVICE_TICKET)hTask;
    
    if (DNSLookupIsValidTask( (XONLINETASK_HANDLE)&(pGetServiceTicketTask->DNSTask) ))
    {
        XOnlineTaskClose((XONLINETASK_HANDLE)&(pGetServiceTicketTask->DNSTask));
    }

    if (pGetServiceTicketTask->socket != INVALID_SOCKET)
    {
        WSACancelOverlappedIO( pGetServiceTicketTask->socket );
        closesocket(pGetServiceTicketTask->socket);
    }

    if (pGetServiceTicketTask->pXKerbServiceContext != NULL)
    {
        SysFree( pGetServiceTicketTask->pXKerbServiceContext );
    }

    XnSetEventTimer(pGetServiceTicketTask->abEventTimer, NULL, 0xFFFFFFFF);

    SysFree(pGetServiceTicketTask);
}

//
// Function to kick off a GetServiceTicket
//
HRESULT CXo::GetServiceTicket(
            PXKERB_TGT_CONTEXT pCombinedTGTContext,
            DWORD* pdwServiceIDs,
            DWORD cServices,
            BOOL fUseCache,
            HANDLE hWorkEvent,
            PXONLINETASK_HANDLE phGetServiceTicketTask
            )
{
    HRESULT hr;
    DWORD i;
    PXONLINETASK_GET_SERVICE_TICKET pGetServiceTicketTask;
    
    Assert(phGetServiceTicketTask != NULL);

    pGetServiceTicketTask = (PXONLINETASK_GET_SERVICE_TICKET)SysAllocZ(sizeof(*pGetServiceTicketTask),
        PTAG_XONLINETASK_GET_SERVICE_TICKET);
    if (pGetServiceTicketTask == NULL)
    {
        hr = XONLINE_E_OUT_OF_MEMORY;
        goto Cleanup;
    }
    
    TaskInitializeContext(&(pGetServiceTicketTask->xonTask));
    pGetServiceTicketTask->xonTask.pfnContinue = GetServiceTicketContinue;
    pGetServiceTicketTask->xonTask.pfnClose = GetServiceTicketClose;
    pGetServiceTicketTask->xonTask.hEventWorkAvailable = hWorkEvent;
    pGetServiceTicketTask->hr = XONLINETASK_S_RUNNING;
    pGetServiceTicketTask->socket = INVALID_SOCKET;
    pGetServiceTicketTask->pCombinedTGTContext = pCombinedTGTContext;
    
    pGetServiceTicketTask->pXKerbServiceContext = (PXKERB_SERVICE_CONTEXT)SysAllocZ(sizeof(*(pGetServiceTicketTask->pXKerbServiceContext)), PTAG_XKERB_SERVICE_CONTEXT);
    if ( pGetServiceTicketTask->pXKerbServiceContext == NULL )
    {
        hr = XONLINE_E_OUT_OF_MEMORY;
        goto Cleanup;
    }

    for (i=0; i<m_dwUniqueLogonUsers; ++i)
    {
        pGetServiceTicketTask->pXKerbServiceContext->UserID[i] = m_apUniqueLogonUsers[i]->xuid.qwUserID;
    }
    pGetServiceTicketTask->pXKerbServiceContext->dwTitleID = m_dwTitleId;
    
    for (i=0; i<cServices; ++i)
    {
        pGetServiceTicketTask->pXKerbServiceContext->dwServiceID[i] = pdwServiceIDs[i];
    }
    pGetServiceTicketTask->pXKerbServiceContext->dwNumServices = cServices;

    hr = S_OK;

    pGetServiceTicketTask->hrDNS = DNSLookup( XBOX_KDC_DNS, hWorkEvent, &pGetServiceTicketTask->DNSTask );

    if (fUseCache)
    {
        pGetServiceTicketTask->dwState = LOGON_START_CACHE_LOOKUP;
    }
    else
    {
        pGetServiceTicketTask->dwState = LOGON_START_CACHE_MISS;
    }
    
    GetServiceTicketContinue( (XONLINETASK_HANDLE) pGetServiceTicketTask );
    
    *phGetServiceTicketTask = (XONLINETASK_HANDLE) pGetServiceTicketTask;

Cleanup:
    if (FAILED(hr))
    {
        *phGetServiceTicketTask = NULL;

        if (pGetServiceTicketTask != NULL)
        {
            if (DNSLookupIsValidTask( (XONLINETASK_HANDLE)&(pGetServiceTicketTask->DNSTask) ))
            {
                XOnlineTaskClose((XONLINETASK_HANDLE)&(pGetServiceTicketTask->DNSTask));
            }

            SysFree(pGetServiceTicketTask);
        }
    }    
    return(hr);
}

//
// Function to retrieve the results of a GetServiceTicket
//
HRESULT CXo::GetServiceTicketGetResults(XONLINETASK_HANDLE hTask, PXKERB_SERVICE_CONTEXT * ppXKerbServiceContext, BOOL* pfTicketFromCache)
{
    Assert(hTask != NULL);
    Assert(ppXKerbServiceContext != NULL);
    Assert(pfTicketFromCache != NULL);

    PXONLINETASK_GET_SERVICE_TICKET  pGetServiceTicketTask = (PXONLINETASK_GET_SERVICE_TICKET)hTask;

    if (pGetServiceTicketTask->hr == XONLINETASK_S_SUCCESS)
    {
        *pfTicketFromCache = pGetServiceTicketTask->fTicketFromCache;
        *ppXKerbServiceContext = pGetServiceTicketTask->pXKerbServiceContext;
        pGetServiceTicketTask->pXKerbServiceContext = NULL;
    }
    else
    {
        *ppXKerbServiceContext = NULL;
    }
    return(pGetServiceTicketTask->hr);
}

//
// Main do work function for Logon
//
HRESULT CXo::LogonTaskContinue(XONLINETASK_HANDLE hTask)
{
    Assert(hTask != NULL);

    HRESULT hr;
    XNADDR xna;
    DWORD dwStatus;
    DWORD i,j;
    XOKERBINFO* pXoKerbInfo;
    BYTE abUserPerm[XONLINE_MAX_LOGON_USERS];
    IN_ADDR serviceAddr;
    XONLINE_SERVICE_INFO serviceInfo;
    XONLINE_RECENT_LOGON_TIME recentLogonTime;
    PXONLINETASK_LOGON pLogonTask = (PXONLINETASK_LOGON)hTask;
    BOOL fTicketFromCache;
    BOOL fSomeServicesFailed;
    BOOL fMoreWorkToDo;

    //
    // Always perform any remaining service ticket cache pumping
    //
    hr = S_OK;
    if (pLogonTask->dwServiceTicketCacheState == XON_CACHE_STATE_OPENING ||
        pLogonTask->dwServiceTicketCacheState == XON_CACHE_STATE_UPDATING ||
        pLogonTask->dwServiceTicketCacheState == XON_CACHE_STATE_FLUSHING )
    {
        hr = XOnlineTaskContinue( pLogonTask->hServiceTicketCacheTask );
        if (hr == XONLINETASK_S_SUCCESS)
        {
            if (pLogonTask->dwServiceTicketCacheState == XON_CACHE_STATE_OPENING)
            {
                pLogonTask->dwServiceTicketCacheState = XON_CACHE_STATE_OPENED;
            }
            else if (pLogonTask->dwServiceTicketCacheState == XON_CACHE_STATE_UPDATING)
            {
                pLogonTask->dwServiceTicketCacheState = XON_CACHE_STATE_UPDATED;
            }
            else if (pLogonTask->dwServiceTicketCacheState == XON_CACHE_STATE_FLUSHING)
            {
                TraceSz( AuthVerbose, "LogonTaskContinue: service ticket cache successfully flushed" );
                pLogonTask->dwServiceTicketCacheState = XON_CACHE_STATE_DONE;
            }
        }
    }
    if (pLogonTask->fNeedToFlushServiceTicketCache &&
        pLogonTask->dwState >= LOGON_CS_IN_PROGRESS &&
        (pLogonTask->dwServiceTicketCacheState == XON_CACHE_STATE_OPENED ||
        pLogonTask->dwServiceTicketCacheState == XON_CACHE_STATE_UPDATED))
    {
        hr = CacheIndexFlush( pLogonTask->hServiceTicketCache, pLogonTask->hServiceTicketCacheTask );
        if (SUCCEEDED(hr))
        {
            pLogonTask->dwServiceTicketCacheState = XON_CACHE_STATE_FLUSHING;            
        }
        pLogonTask->fNeedToFlushServiceTicketCache = FALSE;
    }
    if (FAILED(hr))
    {
        if (pLogonTask->hServiceTicketCacheTask != NULL)
        {
            XOnlineTaskClose(pLogonTask->hServiceTicketCacheTask);
            pLogonTask->hServiceTicketCacheTask = NULL;
        }
        
        if (pLogonTask->hServiceTicketCache != NULL)
        {
            CacheClose(pLogonTask->hServiceTicketCache);
            pLogonTask->hServiceTicketCache = NULL;
        }
        pLogonTask->dwServiceTicketCacheState = XON_CACHE_STATE_ERROR;
    }

    //
    // Always perform any remaining combined ticket cache pumping
    //
    hr = S_OK;
    if (pLogonTask->dwCombinedTicketCacheState == XON_CACHE_STATE_OPENING ||
        pLogonTask->dwCombinedTicketCacheState == XON_CACHE_STATE_UPDATING ||
        pLogonTask->dwCombinedTicketCacheState == XON_CACHE_STATE_FLUSHING )
    {
        hr = XOnlineTaskContinue( pLogonTask->hCombinedTicketCacheTask );
        if (hr == XONLINETASK_S_SUCCESS)
        {
            if (pLogonTask->dwCombinedTicketCacheState == XON_CACHE_STATE_OPENING)
            {
                pLogonTask->dwCombinedTicketCacheState = XON_CACHE_STATE_OPENED;
            }
            else if (pLogonTask->dwCombinedTicketCacheState == XON_CACHE_STATE_UPDATING)
            {
                pLogonTask->dwCombinedTicketCacheState = XON_CACHE_STATE_UPDATED;
            }
            else if (pLogonTask->dwCombinedTicketCacheState == XON_CACHE_STATE_FLUSHING)
            {
                TraceSz( AuthVerbose, "LogonTaskContinue: combined ticket cache successfully flushed" );
                pLogonTask->dwCombinedTicketCacheState = XON_CACHE_STATE_DONE;
            }
        }
    }
    if (pLogonTask->fNeedToFlushCombinedTicketCache &&
        pLogonTask->dwState >= LOGON_CS_IN_PROGRESS &&
        (pLogonTask->dwCombinedTicketCacheState == XON_CACHE_STATE_OPENED ||
        pLogonTask->dwCombinedTicketCacheState == XON_CACHE_STATE_UPDATED))
    {
        hr = CacheIndexFlush( pLogonTask->hCombinedTicketCache, pLogonTask->hCombinedTicketCacheTask );
        if (SUCCEEDED(hr))
        {
            pLogonTask->dwCombinedTicketCacheState = XON_CACHE_STATE_FLUSHING;            
        }
        pLogonTask->fNeedToFlushCombinedTicketCache = FALSE;
    }
    if (FAILED(hr))
    {
        if (pLogonTask->hCombinedTicketCacheTask != NULL)
        {
            XOnlineTaskClose(pLogonTask->hCombinedTicketCacheTask);
            pLogonTask->hCombinedTicketCacheTask = NULL;
        }
        
        if (pLogonTask->hCombinedTicketCache != NULL)
        {
            CacheClose(pLogonTask->hCombinedTicketCache);
            pLogonTask->hCombinedTicketCache = NULL;
        }
        pLogonTask->dwCombinedTicketCacheState = XON_CACHE_STATE_ERROR;
    }

    //
    // Always perform any logon time cache pumping
    //
    if (m_dwLogonTimeCacheState != XON_CACHE_STATE_ERROR)
    {
        //
        // Pump the task if we are still opening or flushing
        //
        if (m_dwLogonTimeCacheState == XON_CACHE_STATE_OPENING ||
            m_dwLogonTimeCacheState == XON_CACHE_STATE_FLUSHING )
        {
            hr = XOnlineTaskContinue( m_hLogonTimeCacheTask );
            if (hr == XONLINETASK_S_SUCCESS)
            {
                if (m_dwLogonTimeCacheState == XON_CACHE_STATE_OPENING)
                {
                    m_dwLogonTimeCacheState = XON_CACHE_STATE_OPENED;
                }
                else if (m_dwLogonTimeCacheState == XON_CACHE_STATE_FLUSHING)
                {
                    m_dwLogonTimeCacheState = XON_CACHE_STATE_DONE;
                }
            }
        }
        
        //
        // Record the logon time for this logon if it hasn't been done yet
        //
        if ( !pLogonTask->fLogonTimeCached &&
            (m_dwLogonTimeCacheState == XON_CACHE_STATE_OPENED ||
            m_dwLogonTimeCacheState == XON_CACHE_STATE_DONE))
        {
            GetSystemTimeAsFileTime(&recentLogonTime.lastLogon);
            for (i=0; i<XONLINE_MAX_LOGON_USERS; ++i)
            {
                if (m_rgLogonUsers[i].xuid.qwUserID != 0 && !XOnlineIsUserGuest(m_rgLogonUsers[i].xuid.dwUserFlags))
                {
                    recentLogonTime.qwUserID = m_rgLogonUsers[i].xuid.qwUserID;
                    hr = CacheUpdate(m_hLogonTimeCache, m_hLogonTimeCacheTask, (BYTE*)&recentLogonTime, NULL, FALSE);
                    if (SUCCEEDED(hr))
                    {
                        //
                        // This update operation should not hit the disk, therefore it is O.K to busy loop for it to complete.
                        //
                        do
                        {
                            hr = XOnlineTaskContinue( m_hLogonTimeCacheTask );
                        } while (hr == XONLINETASK_S_RUNNING);
                    }
                }
            }
            
            hr = CacheIndexFlush(m_hLogonTimeCache, m_hLogonTimeCacheTask);
            if (SUCCEEDED(hr))
            {      
                m_dwLogonTimeCacheState = XON_CACHE_STATE_FLUSHING;
            }
            pLogonTask->fLogonTimeCached = TRUE;
        }

        //
        // If any failures pop up, just forget about this whole cache
        //
        if (FAILED(hr))
        {
            if (m_hLogonTimeCacheTask != NULL)
            {
                XOnlineTaskClose(m_hLogonTimeCacheTask);
                m_hLogonTimeCacheTask = NULL;
            }
            
            if (m_hLogonTimeCache != NULL)
            {
                CacheClose(m_hLogonTimeCache);
                m_hLogonTimeCache = NULL;
            }
            m_dwLogonTimeCacheState = XON_CACHE_STATE_ERROR;
        }
    }

    //
    // Check if we timed out
    //
    if (pLogonTask->dwState > LOGON_XNETWAIT_IN_PROGRESS &&
        pLogonTask->dwState < LOGON_TASK_COMPLETE &&
        GetTickCount() >= pLogonTask->dwMaxEndingTickCount)
    {
        TraceSz( AuthWarn, "LogonTaskContinue: whole logon process timed out" );
        pLogonTask->hr = XONLINE_E_LOGON_SERVICE_UNAVAILABLE;
        goto Cleanup;
    }

    //
    // Now handle the logon state machine
    //
    do
    {
        fMoreWorkToDo = FALSE;        

        switch (pLogonTask->dwState)
        {
        case LOGON_XNETWAIT_IN_PROGRESS:
            dwStatus = XNetGetTitleXnAddr(&xna);
            if (dwStatus != XNET_GET_XNADDR_PENDING)
            {
                if ((dwStatus & XNET_GET_XNADDR_GATEWAY) == 0)
                {
                    TraceSz1( AuthWarn, "LogonTaskContinue: XNetGetTitleXnAddr could not find a gateway, dwStatus:0x%X", dwStatus );
                    pLogonTask->hr = XONLINE_E_LOGON_NO_IP_ADDRESS;
                    goto Cleanup;
                }
                if ((dwStatus & XNET_GET_XNADDR_DNS) == 0)
                {
                    TraceSz1( AuthWarn, "LogonTaskContinue: XNetGetTitleXnAddr could not find a DNS server, dwStatus:0x%X", dwStatus );
                    pLogonTask->hr = XONLINE_E_LOGON_NO_DNS_SERVICE;
                    goto Cleanup;
                }

                //
                // Set max timeout for all of remaining logon work
                //
                pLogonTask->dwMaxEndingTickCount = GetTickCount() + MAX_TOTAL_LOGON_TIME_IN_MS;
                XnSetEventTimer(pLogonTask->abEventTimer, pLogonTask->xonTask.hEventWorkAvailable, MAX_TOTAL_LOGON_TIME_IN_MS );

                //
                // Kick off getting the machine account
                //
                Assert( pLogonTask->hGetMachineAccountTask == NULL );
                hr = GetMachineAccount( pLogonTask->xonTask.hEventWorkAvailable, &pLogonTask->hGetMachineAccountTask );
                if ( FAILED(hr) )
                {
                    pLogonTask->hr = XONLINE_E_LOGON_MACS_FAILED;
                    goto Cleanup;
                }

                pLogonTask->dwState = LOGON_MACS_IN_PROGRESS;
                fMoreWorkToDo = TRUE;
            }
            else
            {
                XnSetEventTimer(
                    pLogonTask->abEventTimer,
                    pLogonTask->xonTask.hEventWorkAvailable,
                    GET_XNADDR_RETRY_PERIOD_IN_MS );

                TraceSz( AuthVerbose, "LogonTaskContinue: Still waiting for XNetGetTitleXnAddr..." );
            }
            break;
            
        case LOGON_MACS_IN_PROGRESS:
            Assert (pLogonTask->hGetMachineAccountTask != NULL);
            hr = XOnlineTaskContinue( (XONLINETASK_HANDLE)pLogonTask->hGetMachineAccountTask );
            if ( hr == XONLINETASK_S_SUCCESS )
            {
                hr = GetMachineAccountGetResults( (XONLINETASK_HANDLE)pLogonTask->hGetMachineAccountTask, &pLogonTask->machineUser );
                Assert( hr == XONLINETASK_S_SUCCESS );
                Assert(pLogonTask->machineUser.xuid.qwUserID != 0);
                XOnlineTaskClose(pLogonTask->hGetMachineAccountTask);
                pLogonTask->hGetMachineAccountTask = NULL;

                //
                // Start combined ticket phase
                //
                Assert( pLogonTask->hGetCombinedTicketTask == NULL );
                hr = GetCombinedTicket( &pLogonTask->machineUser, TRUE, pLogonTask->xonTask.hEventWorkAvailable, &pLogonTask->hGetCombinedTicketTask );
                if ( FAILED(hr) )
                {
                    pLogonTask->hr = hr;
                    goto Cleanup;
                }
                pLogonTask->dwState = LOGON_GET_TGT_IN_PROGRESS;
                fMoreWorkToDo = TRUE;                
            }
            else if FAILED(hr)
            {
                pLogonTask->hr = hr;
                goto Cleanup;
            }
            else
            {
                Assert( hr == XONLINETASK_S_RUNNING );
            }
            break;
                
        case LOGON_GET_TGT_IN_PROGRESS:
            Assert (pLogonTask->hGetCombinedTicketTask != NULL);
            hr = XOnlineTaskContinue( (XONLINETASK_HANDLE)pLogonTask->hGetCombinedTicketTask );
            if ( hr == XONLINETASK_S_SUCCESS )
            {
                hr = GetCombinedTicketGetResults( (XONLINETASK_HANDLE)pLogonTask->hGetCombinedTicketTask, &pLogonTask->pCombinedTGTContext, &fTicketFromCache );
                Assert( hr == XONLINETASK_S_SUCCESS );
                Assert(pLogonTask->pCombinedTGTContext != NULL);
                XOnlineTaskClose(pLogonTask->hGetCombinedTicketTask);
                pLogonTask->hGetCombinedTicketTask = NULL;

                //
                // Store in Cache if we got some good results back. Best effort only.
                //
                if (!fTicketFromCache &&
                    (pLogonTask->dwCombinedTicketCacheState == XON_CACHE_STATE_OPENED ||
                    pLogonTask->dwCombinedTicketCacheState == XON_CACHE_STATE_UPDATED ||
                    pLogonTask->dwCombinedTicketCacheState == XON_CACHE_STATE_DONE))
                {
                    RtlCopyMemory( &pLogonTask->combinedContextToCache, pLogonTask->pCombinedTGTContext, sizeof(pLogonTask->combinedContextToCache) );
                    hr = CacheUpdate(
                        pLogonTask->hCombinedTicketCache,
                        pLogonTask->hCombinedTicketCacheTask,
                        (BYTE*)&pLogonTask->combinedContextToCache,
                        (BYTE*)&pLogonTask->combinedContextToCache.ClientName,
                        TRUE );
                    if (SUCCEEDED(hr))
                    {
                        TraceSz2( AuthVerbose, "LogonTaskContinue updating cache with combined ticket that expires in %d seconds (%8X)",
                            (ULONG)((pLogonTask->pCombinedTGTContext->ExpirationTime.QuadPart -
                            pLogonTask->pCombinedTGTContext->StartTime.QuadPart) / 10000000),
                            XConfigChecksum((BYTE*)pLogonTask->pCombinedTGTContext, FIELD_OFFSET(XKERB_TGT_CONTEXT, StartTime))
                            );
                        pLogonTask->dwCombinedTicketCacheState = XON_CACHE_STATE_UPDATING;
                        pLogonTask->fNeedToFlushCombinedTicketCache = TRUE;
                    }
                }
                
                //
                // Start service ticket phase
                //
                pLogonTask->cServices = 0;
                for ( i=0; i<XONLINE_MAX_SERVICE_REQUEST; ++i )
                {
                    if (m_rgServiceContexts[i].serviceInfo.dwServiceID != XONLINE_INVALID_SERVICE)
                    {
                        pLogonTask->adwServiceIDs[pLogonTask->cServices++] = m_rgServiceContexts[i].serviceInfo.dwServiceID;
                    }
                }        

                Assert( pLogonTask->hGetServiceTicketTask == NULL );
                hr = GetServiceTicket( pLogonTask->pCombinedTGTContext, pLogonTask->adwServiceIDs, pLogonTask->cServices, TRUE, pLogonTask->xonTask.hEventWorkAvailable, &pLogonTask->hGetServiceTicketTask );
                if ( FAILED(hr) )
                {
                    pLogonTask->hr = hr;
                    goto Cleanup;
                }
                pLogonTask->dwState = LOGON_GET_TKT_IN_PROGRESS;
                fMoreWorkToDo = TRUE;                
            }
            else if FAILED(hr)
            {
                if (hr == XONLINE_E_LOGON_MACHINE_AUTHENTICATION_FAILED)
                {
                    //
                    // Machine account does not exists in Passport DB.
                    // Create a fresh new machine account to solve this problem.
                    //
                    TraceSz( AuthVerbose, "LogonTaskContinue: machine account not authenticating, creating new one");
                    
                    XOnlineTaskClose(pLogonTask->hGetCombinedTicketTask);
                    pLogonTask->hGetCombinedTicketTask = NULL;

                    m_fGetNewMachineAccount = TRUE;
                    Assert( pLogonTask->hGetMachineAccountTask == NULL );
                    hr = GetMachineAccount( pLogonTask->xonTask.hEventWorkAvailable, &pLogonTask->hGetMachineAccountTask );
                    if ( FAILED(hr) )
                    {
                        pLogonTask->hr = XONLINE_E_LOGON_MACS_FAILED;
                        goto Cleanup;
                    }
                    pLogonTask->dwState = LOGON_MACS_IN_PROGRESS;
                    fMoreWorkToDo = TRUE;
                    break;
                }
                else
                {
                    //
                    // Propagate error code up
                    //
                    pLogonTask->hr = hr;
                    goto Cleanup;
                }
            }
            else
            {
                Assert( hr == XONLINETASK_S_RUNNING );
            }
            break;

        case LOGON_GET_TKT_IN_PROGRESS:
            Assert (pLogonTask->hGetServiceTicketTask != NULL);
            hr = XOnlineTaskContinue( (XONLINETASK_HANDLE)pLogonTask->hGetServiceTicketTask );
            if (hr == XONLINETASK_S_SUCCESS)
            {
                hr = GetServiceTicketGetResults( (XONLINETASK_HANDLE)pLogonTask->hGetServiceTicketTask, &pLogonTask->pXKerbServiceContext, &fTicketFromCache );
                Assert( hr == XONLINETASK_S_SUCCESS );
                XOnlineTaskClose(pLogonTask->hGetServiceTicketTask);
                pLogonTask->hGetServiceTicketTask = NULL;

                Assert( pLogonTask->pXKerbServiceContext != NULL );

                //
                // Scan results and see what hr we got for each service
                //
                fSomeServicesFailed = FALSE;
                pLogonTask->cServices = 0;
                for (i=0; i<pLogonTask->pXKerbServiceContext->dwNumServices; ++i)
                {
                    Assert( pLogonTask->pXKerbServiceContext->dwServiceID[i] != XONLINE_INVALID_SERVICE );
                    j = GetServiceArrayIndex(pLogonTask->pXKerbServiceContext->dwServiceID[i]);
                    Assert(j != XONLINE_INVALID_SERVICE);
                    Assert(m_rgServiceContexts[j].serviceInfo.dwServiceID == pLogonTask->pXKerbServiceContext->dwServiceID[i]);
                    m_rgServiceContexts[j].hr = pLogonTask->pXKerbServiceContext->hrService[i];

                    if (FAILED(m_rgServiceContexts[j].hr))
                    {
                        fSomeServicesFailed = TRUE;
                    }
                    else if (m_rgServiceContexts[j].hr == S_FALSE)
                    {
                        pLogonTask->adwServiceIDs[pLogonTask->cServices++] = m_rgServiceContexts[i].serviceInfo.dwServiceID;
                    }
                    else
                    {
                        Assert( m_rgServiceContexts[j].hr == S_OK );
                        m_rgServiceContexts[j].serviceInfo.wServicePort = pLogonTask->pXKerbServiceContext->wServicePort[i];
                        m_rgServiceContexts[j].serviceInfo.serviceIP = pLogonTask->pXKerbServiceContext->siteIPAddress;
                        m_rgServiceContexts[j].pXKerbServiceContext = pLogonTask->pXKerbServiceContext;
                    }
                }

                //
                // Store in Cache if we got some good results back. Best effort only.
                //
                if (!fTicketFromCache && !fSomeServicesFailed &&
                    (pLogonTask->dwServiceTicketCacheState == XON_CACHE_STATE_OPENED ||
                    pLogonTask->dwServiceTicketCacheState == XON_CACHE_STATE_UPDATED ||
                    pLogonTask->dwServiceTicketCacheState == XON_CACHE_STATE_DONE))
                {
                    RtlCopyMemory( &pLogonTask->serviceContextToCache, pLogonTask->pXKerbServiceContext, sizeof(pLogonTask->serviceContextToCache) );
                    hr = CacheUpdate(
                        pLogonTask->hServiceTicketCache,
                        pLogonTask->hServiceTicketCacheTask,
                        (BYTE*)&pLogonTask->serviceContextToCache,
                        (BYTE*)&pLogonTask->serviceContextToCache.siteIPAddress,
                        TRUE );
                    if (SUCCEEDED(hr))
                    {
                        TraceSz2( AuthVerbose, "LogonTaskContinue updating cache with service ticket that expires in %d seconds (%8X)",
                            (ULONG)((pLogonTask->pXKerbServiceContext->ExpirationTime.QuadPart -
                            pLogonTask->pXKerbServiceContext->StartTime.QuadPart) / 10000000),
                            XConfigChecksum((BYTE*)pLogonTask->pXKerbServiceContext, FIELD_OFFSET(XKERB_SERVICE_CONTEXT, StartTime))
                            );
                        pLogonTask->dwServiceTicketCacheState = XON_CACHE_STATE_UPDATING;
                        pLogonTask->fNeedToFlushServiceTicketCache = TRUE;
                    }
                }
                
                //
                // Compute g^x and other stuff needed by lower Xnet layer
                //
                pXoKerbInfo = &(pLogonTask->pXKerbServiceContext->xoKerbInfo);
                XNetRandom( pXoKerbInfo->_abDhX, sizeof(pXoKerbInfo->_abDhX) );
                Assert( sizeof(pXoKerbInfo->_abDhGX) == sizeof(g_abOakleyGroup1Base) );
                if (!XcModExp( (DWORD*)pXoKerbInfo->_abDhGX, (DWORD*)g_abOakleyGroup1Base, (DWORD*)pXoKerbInfo->_abDhX, (DWORD*)g_abOakleyGroup1Mod, sizeof(pXoKerbInfo->_abDhGX) / sizeof(DWORD) ) )
                {
                    TraceSz( AuthWarn, "LogonTaskContinue: XcModExp failed" );
                    pLogonTask->hr = XONLINE_E_INTERNAL_ERROR;
                    goto Cleanup;
                }

                RtlCopyMemory( pXoKerbInfo->_abKey, pLogonTask->pXKerbServiceContext->SessionKey, sizeof(pXoKerbInfo->_abKey) );
                pXoKerbInfo->_dwTicketId = m_ctAllocatedServiceContexts;
                pXoKerbInfo->_cbApReqMax = pLogonTask->pXKerbServiceContext->dwTicketLength + AP_REQUEST_OVERHEAD_ABOVE_TICKET;

                //
                // Compute user permutation DWORD
                //
                Assert( XONLINE_MAX_LOGON_USERS == sizeof(DWORD) );
                *((DWORD*)abUserPerm) = 0;
                for (i=0; i<XONLINE_MAX_LOGON_USERS; ++i)
                {
                    if (m_rgLogonUsers[i].xuid.qwUserID != 0)
                    {
                        for (j=0; j<XONLINE_MAX_LOGON_USERS; ++j)
                        {
                            if (m_rgLogonUsers[i].xuid.qwUserID == pLogonTask->pXKerbServiceContext->UserID[j])
                            {
                                abUserPerm[i] = (BYTE)((j << KEYEX_USER_PERMUTATION_SHIFT) | KEYEX_USER_PERMUTE_MASK | (m_rgLogonUsers[i].xuid.dwUserFlags & KEYEX_USER_GUEST_MASK));
                                break;                    
                            }
                        }
                    }
                }
                pXoKerbInfo->_dwUserPerm = *((DWORD*)abUserPerm);
                
                //
                // Record the context into a global
                // Make sure we use a new context next time
                //
                m_pAllocatedServiceContexts[m_ctAllocatedServiceContexts++] = pLogonTask->pXKerbServiceContext;
                pLogonTask->pXKerbServiceContext = NULL;
                
                //
                // If more services left, then start another service ticket request and loop back
                //
                if (pLogonTask->cServices > 0)
                {
                    Assert( pLogonTask->hGetServiceTicketTask == NULL );
                    hr = GetServiceTicket( pLogonTask->pCombinedTGTContext, pLogonTask->adwServiceIDs, pLogonTask->cServices, TRUE, pLogonTask->xonTask.hEventWorkAvailable, &pLogonTask->hGetServiceTicketTask );
                    if ( FAILED(hr) )
                    {
                        pLogonTask->hr = hr;
                        goto Cleanup;
                    }

                    fMoreWorkToDo = TRUE;
                    break;
                }

                //
                // Tickets to all services that we can get have already been obtained. Prepare to move to next state
                //
                
                //
                // Mark unrequested services
                //
                for (i=0; i<XONLINE_MAX_SERVICE_REQUEST; ++i)
                {
                    if (m_rgServiceContexts[i].serviceInfo.dwServiceID == XONLINE_INVALID_SERVICE)
                    {
                        m_rgServiceContexts[i].hr = XONLINE_E_LOGON_SERVICE_NOT_REQUESTED;
                    }
                }
                
                //
                // Convert all IPs into fake IPs the Xnet stack understands
                //
                for (i=0; i<XONLINE_MAX_SERVICE_REQUEST; ++i)
                {
                    if (m_rgServiceContexts[i].hr == S_OK)
                    {
                        Assert( m_rgServiceContexts[i].pXKerbServiceContext != NULL );
                        dwStatus = XNetServerToInAddr(
                            m_rgServiceContexts[i].serviceInfo.serviceIP,
                            m_rgServiceContexts[i].serviceInfo.dwServiceID,
                            &serviceAddr );
                        if(dwStatus != 0)
                        {
                            TraceSz1( AuthWarn, "LogonTaskContinue: XNetServerToInAddr failed, dwStatus: 0x%X", dwStatus );
                            pLogonTask->hr = XONLINE_E_LOGON_SG_SERVICE_FAILED;
                            goto Cleanup;
                        }
                        m_rgServiceContexts[i].serviceInfo.serviceIP.s_addr = serviceAddr.s_addr;
                    }
                }

                ULONGLONG aqwUserId[XONLINE_MAX_LOGON_USERS];
                IN_ADDR inaLogon;

                for (i = 0; i < XONLINE_MAX_LOGON_USERS; ++i)
                {
                    //@@@ drm: Should guests be filtered out here?
                    aqwUserId[i] = m_rgLogonUsers[i].xuid.qwUserID;
                }

                hr = XOnlineGetServiceInfo(XONLINE_PRESENCE_SERVICE, &serviceInfo);
                inaLogon.s_addr = SUCCEEDED(hr) ? serviceInfo.serviceIP.s_addr : 0;

                XnLogon(inaLogon, aqwUserId, pLogonTask->xonTask.hEventWorkAvailable);

                if (inaLogon.s_addr == 0)
                {
                    pLogonTask->hr = XONLINE_S_LOGON_CONNECTION_ESTABLISHED;
                    m_fLogonCompletedSuccessfully = TRUE;
                }
                else
                {
                    pLogonTask->dwState = LOGON_CS_IN_PROGRESS;
                }
                break;
            }
            else if (FAILED(hr))
            {
                if (hr == XONLINE_E_LOGON_XBOX_ACCOUNT_INVALID)
                {
                    //
                    // Machine account exists in Passport, but not in xbox UODB
                    // Create a fresh new machine account to solve this problem
                    //
                    TraceSz( AuthVerbose, "LogonTaskContinue: machine account not in UODB, creating new one");

                    XOnlineTaskClose(pLogonTask->hGetServiceTicketTask);
                    pLogonTask->hGetServiceTicketTask = NULL;

                    m_fGetNewMachineAccount = TRUE;
                    Assert( pLogonTask->hGetMachineAccountTask == NULL );
                    hr = GetMachineAccount( pLogonTask->xonTask.hEventWorkAvailable, &pLogonTask->hGetMachineAccountTask );
                    if ( FAILED(hr) )
                    {
                        pLogonTask->hr = XONLINE_E_LOGON_MACS_FAILED;
                        goto Cleanup;
                    }
                    pLogonTask->dwState = LOGON_MACS_IN_PROGRESS;
                    fMoreWorkToDo = TRUE;
                    break;
                }
                else
                {
                    //
                    // Propagate error code up
                    //
                    pLogonTask->hr = hr;
                    goto Cleanup;
                }
            }
            else
            {
                Assert( hr == XONLINETASK_S_RUNNING );
            }
            break;

        case LOGON_CS_IN_PROGRESS:
            dwStatus = XnLogonGetStatus(NULL);
        
            switch(dwStatus)
            {
            case XN_LOGON_STATE_ONLINE:
            
                if (pLogonTask->fAliveSent == FALSE)
                {
                    Assert( pLogonTask->hPresenceTask == NULL );
                    hr = NotificationSendAlive( m_rgLogonUsers, pLogonTask->xonTask.hEventWorkAvailable, &pLogonTask->hPresenceTask);
                    if (FAILED(hr))
                    {
                        TraceSz1( AuthWarn, "LogonTaskContinue: NotificationSendAlive Failed: hr:0x%X", hr );
                        pLogonTask->hr = XONLINE_E_LOGON_PRESENCE_SERVICE_FAILED;
                        goto Cleanup;
                    }
                    pLogonTask->fAliveSent = TRUE;
                }
                break;

            case XN_LOGON_STATE_OFFLINE:
            
                TraceSz( AuthWarn, "LogonTaskContinue: XnLogonGetStatus returned XN_LOGON_STATE_OFFLINE" );
                pLogonTask->hr = XONLINE_E_LOGON_SG_SERVICE_FAILED;
                goto Cleanup;
            }

            if (pLogonTask->hPresenceTask != NULL)
            {
                hr = XOnlineTaskContinue(pLogonTask->hPresenceTask);
                if (hr != XONLINETASK_S_RUNNING)
                {
                    XOnlineTaskClose(pLogonTask->hPresenceTask);
                    pLogonTask->hPresenceTask = NULL;
                    if (hr == XONLINETASK_S_SUCCESS)
                    {
                        pLogonTask->hr = XONLINE_S_LOGON_CONNECTION_ESTABLISHED;
                        m_fLogonCompletedSuccessfully = TRUE;
                    }
                    else
                    {
                        TraceSz1( AuthWarn, "LogonTaskContinue: presence task returned hr = 0x%X", hr );
                        pLogonTask->hr = XONLINE_E_LOGON_PRESENCE_SERVICE_FAILED;
                    }
                }
            }
            break;
        
        case LOGON_TASK_COMPLETE:
            if (SUCCEEDED(pLogonTask->hr) && pLogonTask->fAliveSent)
            {
                dwStatus = XnLogonGetStatus(NULL);
        
                switch(dwStatus)
                {
                case XN_LOGON_STATE_OFFLINE:
                    TraceSz( AuthWarn, "LogonTaskContinue: XnLogonGetStatus returned XN_LOGON_STATE_OFFLINE in LOGON_TASK_COMPLETE state" );
                    pLogonTask->hr = XONLINE_E_LOGON_CONNECTION_LOST;
                    goto Cleanup;
                }
            }

            break;
            
        default:
            AssertSz(FALSE, "LogonTaskContinue: Bad State");
        }
    } while (fMoreWorkToDo);    
        
Cleanup:
    if (pLogonTask->hr != XONLINETASK_S_RUNNING)
    {
        pLogonTask->dwState = LOGON_TASK_COMPLETE;
    }

    return(pLogonTask->hr);
}

//
// Close function for Logon
//
void CXo::LogonTaskClose(XONLINETASK_HANDLE hTask)
{
    DWORD i;
    Assert(hTask != NULL);

    PXONLINETASK_LOGON pLogonTask = (PXONLINETASK_LOGON)hTask;
    
    TraceSz2( AuthVerbose, "LogonTaskClose: hr:0x%X, dwState:%d", pLogonTask->hr, pLogonTask->dwState );
    
    if ( pLogonTask->hGetMachineAccountTask != NULL )
    {
        XOnlineTaskClose( pLogonTask->hGetMachineAccountTask );
    }
    
    if ( pLogonTask->hGetCombinedTicketTask != NULL )
    {
        XOnlineTaskClose( pLogonTask->hGetCombinedTicketTask );
    }
    
    if ( pLogonTask->hGetServiceTicketTask != NULL )
    {
        XOnlineTaskClose( pLogonTask->hGetServiceTicketTask );
    }
    
    if (pLogonTask->hPresenceTask != NULL)
    {
        XOnlineTaskClose(pLogonTask->hPresenceTask);
    }

    if (pLogonTask->hCombinedTicketCacheTask != NULL)
    {
        XOnlineTaskClose(pLogonTask->hCombinedTicketCacheTask);
    }
    
    if (pLogonTask->hCombinedTicketCache != NULL)
    {
        CacheClose(pLogonTask->hCombinedTicketCache);
    }

    if (pLogonTask->hServiceTicketCacheTask != NULL)
    {
        XOnlineTaskClose(pLogonTask->hServiceTicketCacheTask);
    }
    
    if (pLogonTask->hServiceTicketCache != NULL)
    {
        CacheClose(pLogonTask->hServiceTicketCache);
    }

    if (pLogonTask->hCreatedEvent != NULL)
    {
        CloseHandle(pLogonTask->hCreatedEvent);
    }

    XnSetEventTimer(pLogonTask->abEventTimer, NULL, 0xFFFFFFFF);

    XnLogoff();
    
    m_fGetNewMachineAccount = FALSE;    
    m_fLogonCompletedSuccessfully = FALSE;
    
    for (i=0; i<m_ctAllocatedServiceContexts; ++i)
    {
        SysFree( m_pAllocatedServiceContexts[i] );
        m_pAllocatedServiceContexts[i] = NULL;
    }
    m_ctAllocatedServiceContexts = 0;
    
    if ( pLogonTask->pCombinedTGTContext != NULL )
    {
        SysFree( pLogonTask->pCombinedTGTContext );
    }
    
    if ( pLogonTask->pXKerbServiceContext != NULL )
    {
        SysFree( pLogonTask->pXKerbServiceContext );
    }
    
    RtlZeroMemory( m_rgServiceContexts, sizeof(m_rgServiceContexts) );

    Assert( m_pLogonTask == pLogonTask );
    m_pLogonTask = NULL;

    SysFree(pLogonTask);
}

//
// Main Logon routine
//
HRESULT CXo::XOnlineLogon(
    IN PXONLINE_USER pUsers,
    IN DWORD* pdwServiceIDs,
    IN DWORD cServices,
    IN HANDLE hEvent,
    OUT PXONLINETASK_HANDLE pHandle
    )
{
    XoEnter("XOnlineLogon");
    XoCheck((cServices == 0) == (pdwServiceIDs == NULL));
    XoCheck(pHandle != NULL);

    BOOL fHasUsers = FALSE;
    HRESULT hr;
    LONG i,j;
    DWORD dwServices;
    DWORD dwServiceIndex;
    PXONLINE_USER pTempUser;
    PXONLINETASK_LOGON pLogonTask = NULL;
    PXONLINETASK_LOGON pPrevLogonTask;
    WSADATA WsaData;
    DWORD err;

    //
    // Check if the ethernet is connected
    //
    if ((XNetGetEthernetLinkStatus() & XNET_ETHERNET_LINK_ACTIVE) == 0)
    {
        TraceSz( AuthWarn, "XOnlineLogon: XNetGetEthernetLinkStatus reported no ethernet connection" );
        hr = XONLINE_E_LOGON_NO_NETWORK_CONNECTION;
        goto Cleanup;
    }

    //
    // Allocate the logon task
    //
    pLogonTask = (PXONLINETASK_LOGON)SysAllocZ(sizeof(XONLINETASK_LOGON), PTAG_XONLINETASK_LOGON);
    if (pLogonTask == NULL)
    {
        hr = XONLINE_E_OUT_OF_MEMORY;
        goto Cleanup;
    }

    //
    // Make sure only one logon is happening at a time
    //
    pPrevLogonTask = (PXONLINETASK_LOGON)InterlockedCompareExchangePointer(
                (PVOID*)&m_pLogonTask,
                pLogonTask,
                NULL);

    if (pPrevLogonTask != NULL)
    {
        AssertSz( FALSE, "Previous logon task must be closed before next XOnlineLogon" );
        hr = XONLINE_E_TASK_BUSY;
        goto Cleanup;
    }
    
    if (pUsers != NULL)
    {
        TraceSz8( AuthVerbose, "XOnlineLogon called for users 0x%016I64X(%s) 0x%016I64X(%s) 0x%016I64X(%s) 0x%016I64X(%s)",
            pUsers[0].xuid.qwUserID, pUsers[0].name,
            pUsers[1].xuid.qwUserID, pUsers[1].name,
            pUsers[2].xuid.qwUserID, pUsers[2].name,
            pUsers[3].xuid.qwUserID, pUsers[3].name );
    }

    for (i=0; i<XONLINE_MAX_SERVICE_REQUEST; ++i)
    {
        m_rgServiceContexts[i].serviceInfo.dwServiceID = XONLINE_INVALID_SERVICE;
        m_rgServiceContexts[i].hr = S_FALSE;
    };

    dwServices = 0;
    
    for (i=0; i<(LONG)cServices; ++i)
    {
        XoCheck(pdwServiceIDs[i] != XONLINE_PRESENCE_SERVICE);
        XoCheck(pdwServiceIDs[i] != XONLINE_MESSAGE_SERVICE);
        if (pdwServiceIDs[i] < XONLINE_NUMBER_SEQUENTIAL_SERVICES)
        {
            Assert(m_rgServiceContexts[pdwServiceIDs[i]].serviceInfo.dwServiceID == XONLINE_INVALID_SERVICE);
            m_rgServiceContexts[pdwServiceIDs[i]].serviceInfo.dwServiceID = pdwServiceIDs[i];
        }
        else
        {
            if (m_rgServiceContexts[XONLINE_NUMBER_SEQUENTIAL_SERVICES].serviceInfo.dwServiceID == XONLINE_INVALID_SERVICE)
            {
                m_rgServiceContexts[XONLINE_NUMBER_SEQUENTIAL_SERVICES].serviceInfo.dwServiceID = pdwServiceIDs[i];                
            }
            else if (m_rgServiceContexts[XONLINE_NUMBER_SEQUENTIAL_SERVICES+1].serviceInfo.dwServiceID == XONLINE_INVALID_SERVICE)
            {
                m_rgServiceContexts[XONLINE_NUMBER_SEQUENTIAL_SERVICES+1].serviceInfo.dwServiceID = pdwServiceIDs[i];                
            }
            else
            {
                AssertSz( FALSE, "Requesting too many non built in services" );
            }
        }
        
        dwServices++;
    }

    //
    // Check if there are any users
    //
    if (pUsers != NULL)
    {
        for (i=0; i<XONLINE_MAX_LOGON_USERS; ++i)
        {
            if (pUsers[i].xuid.qwUserID != 0)
            {
                fHasUsers = TRUE;
            }
        }
    }

    //
    // Add hidden services for users if users are present
    //
    if (fHasUsers)
    {
        Assert( m_rgServiceContexts[XONLINE_PRESENCE_SERVICE].serviceInfo.dwServiceID == XONLINE_INVALID_SERVICE );
        m_rgServiceContexts[XONLINE_PRESENCE_SERVICE].serviceInfo.dwServiceID = XONLINE_PRESENCE_SERVICE;
        dwServices++;
    }

    //
    // Message service is always asked for
    //
    m_rgServiceContexts[XONLINE_MESSAGE_SERVICE].serviceInfo.dwServiceID = XONLINE_MESSAGE_SERVICE;
    dwServices++;

    XoCheck(dwServices > 0);
    XoCheck(dwServices <= XONLINE_MAX_NUMBER_SERVICE);

#ifdef XNET_FEATURE_TRACE
    {
        char buffer1[64],buffer2[64],buf[8];
        DWORD k;
        buffer1[0] = buffer2[0] = '\0';
        for (k=0; k<cServices; ++k)
        {
            sprintf(buf," %d", pdwServiceIDs[k]);
            strcat(buffer1, buf);
        }
        for (k=0; k<XONLINE_MAX_SERVICE_REQUEST; ++k)
        {
            if (m_rgServiceContexts[k].serviceInfo.dwServiceID != XONLINE_INVALID_SERVICE)
            {
                sprintf(buf," %d", m_rgServiceContexts[k].serviceInfo.dwServiceID);
                strcat(buffer2, buf);
            }
        }
        TraceSz2( AuthVerbose, "XOnlineLogon asked for services:%s actually getting services:%s", buffer1, buffer2 );
    }
#endif

    //
    // Make copy of logon users
    //
    if (pUsers)
    {
        RtlCopyMemory( m_rgLogonUsers, pUsers, sizeof( m_rgLogonUsers ) );
    }
    else
    {
        RtlZeroMemory( m_rgLogonUsers, sizeof( m_rgLogonUsers ) );
    }

    for (i=0; i<XONLINE_MAX_LOGON_USERS; ++i)
    {
        m_rgLogonUsers[i].index = i;
    }

    //
    // Check that hosts of all guests are present
    //
    for (i=0; i<XONLINE_MAX_LOGON_USERS; ++i)
    {
        if (m_rgLogonUsers[i].xuid.qwUserID != 0 && XOnlineIsUserGuest(m_rgLogonUsers[i].xuid.dwUserFlags))
        {
            for (j=0; j<XONLINE_MAX_LOGON_USERS; ++j)
            {
                if (m_rgLogonUsers[j].xuid.qwUserID == m_rgLogonUsers[i].xuid.qwUserID &&
                    !XOnlineIsUserGuest(m_rgLogonUsers[j].xuid.dwUserFlags))
                {
                    // Found the host
                    break;
                }
            }
            if (j == XONLINE_MAX_LOGON_USERS)
            {
                AssertSz( FALSE, "User logged on as guest does not have host present" );
                hr = XONLINE_E_NO_GUEST_ACCESS;
                goto Cleanup;
            }
        }
    }

    //
    // Find all the unique users
    //
    m_dwUniqueLogonUsers = 0;
    for (i=0; i<XONLINE_MAX_LOGON_USERS; ++i)
    {
        if (m_rgLogonUsers[i].xuid.qwUserID != 0)
        {
            for (j=0; j<(LONG)m_dwUniqueLogonUsers; ++j)
            {
                if (m_apUniqueLogonUsers[j]->xuid.qwUserID == m_rgLogonUsers[i].xuid.qwUserID)
                {
                    break;
                }
            }
            if (j == (LONG)m_dwUniqueLogonUsers)
            {
                m_apUniqueLogonUsers[m_dwUniqueLogonUsers++] = &m_rgLogonUsers[i];
            }
        }
    }

    //
    // Bubble sort the users
    //
    for (i=0; i<(((LONG)m_dwUniqueLogonUsers)-1); ++i)
    {
        for (j=i+1; j<(LONG)m_dwUniqueLogonUsers; ++j)
        {
            if (m_apUniqueLogonUsers[i]->xuid.qwUserID > m_apUniqueLogonUsers[j]->xuid.qwUserID)
            {
                pTempUser = m_apUniqueLogonUsers[i];
                m_apUniqueLogonUsers[i] = m_apUniqueLogonUsers[j];
                m_apUniqueLogonUsers[j] = pTempUser;
            }
        }
    }
    
    TaskInitializeContext(&(pLogonTask->xonTask));
    pLogonTask->xonTask.pfnContinue = LogonTaskContinue;
    pLogonTask->xonTask.pfnClose = LogonTaskClose;
    pLogonTask->hr = XONLINETASK_S_RUNNING;

    //
    // Create an event if one doesn't exist
    //
    if (hEvent == NULL)
    {
        pLogonTask->hCreatedEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
        if (pLogonTask->hCreatedEvent == NULL)
        {
            hr = XONLINE_E_OUT_OF_MEMORY;
            goto Cleanup;
        }
        pLogonTask->xonTask.hEventWorkAvailable = pLogonTask->hCreatedEvent;
    }
    else
    {
        pLogonTask->xonTask.hEventWorkAvailable = hEvent;
    }
    
    pLogonTask->dwState = LOGON_XNETWAIT_IN_PROGRESS;
    
    *pHandle = (XONLINETASK_HANDLE)pLogonTask;

	//
	// Open the combined ticket cache
	//
	if ( pLogonTask->dwCombinedTicketCacheState == XON_CACHE_STATE_INITIAL )
	{
        hr = CacheOpen(XONLC_TYPE_COMBINED_USER_TICKETS, NULL, hEvent, &pLogonTask->hCombinedTicketCache, &pLogonTask->hCombinedTicketCacheTask);
        if (FAILED(hr))
        {
            pLogonTask->hCombinedTicketCache = NULL;
            pLogonTask->hCombinedTicketCacheTask = NULL;
            pLogonTask->dwCombinedTicketCacheState = XON_CACHE_STATE_ERROR;
        }
        else
        {
            pLogonTask->dwCombinedTicketCacheState = XON_CACHE_STATE_OPENING;
        }
    }
    
	//
	// Open the service ticket cache
	//
	if ( pLogonTask->dwServiceTicketCacheState == XON_CACHE_STATE_INITIAL )
	{
        hr = CacheOpen(XONLC_TYPE_SERVICE_TICKETS, NULL, hEvent, &pLogonTask->hServiceTicketCache, &pLogonTask->hServiceTicketCacheTask);
        if (FAILED(hr))
        {
            pLogonTask->hServiceTicketCache = NULL;
            pLogonTask->hServiceTicketCacheTask = NULL;
            pLogonTask->dwServiceTicketCacheState = XON_CACHE_STATE_ERROR;
        }
        else
        {
            pLogonTask->dwServiceTicketCacheState = XON_CACHE_STATE_OPENING;
        }
    }

    //
    // Get things rolling
    //
    LogonTaskContinue( (XONLINETASK_HANDLE)pLogonTask );
    
    hr = S_OK;
    
Cleanup:
    if (FAILED(hr))
    {
        RtlZeroMemory( m_rgServiceContexts, sizeof(m_rgServiceContexts) );

        *pHandle = NULL;
        if (pLogonTask != NULL)
        {
            if (m_pLogonTask == pLogonTask)
            {
                m_pLogonTask = NULL;
            }
            SysFree(pLogonTask);
        }
    }    

    return(XoLeave(hr));
}

//
// Function to retrieve the results of a Logon Task without pumping it.
//
HRESULT CXo::XOnlineLogonTaskGetResults(XONLINETASK_HANDLE hTask)
{
    XoEnter("XOnlineLogonTaskGetResults");
    XoCheck(hTask != NULL);

    PXONLINETASK_LOGON pLogonTask = (PXONLINETASK_LOGON)hTask;

    return(XoLeave(pLogonTask->hr));
}


PXONLINE_USER CXo::XOnlineGetLogonUsers()
{
    XoEnter_("XOnlineGetLogonUsers", NULL);

    if ( m_fLogonCompletedSuccessfully )
    {
        return m_rgLogonUsers;
    }
    else
    {
        return NULL;
    }
}


HRESULT CXo::XOnlineGetServiceInfo(IN DWORD dwServiceID, OUT PXONLINE_SERVICE_INFO pServiceInfo)
{
    XoEnter("XOnlineGetServiceInfo");
    DWORD dwServiceIndex;
    
    if (m_pLogonTask == NULL)
    {
        AssertSz( FALSE, "XOnlineGetServiceInfo cannot be called after logon task is closed" );
        return XONLINE_E_NOT_INITIALIZED;
    }
    
    dwServiceIndex = GetServiceArrayIndex( dwServiceID );

    if (pServiceInfo != NULL)
    {
        RtlCopyMemory( pServiceInfo, &m_rgServiceContexts[dwServiceIndex].serviceInfo, sizeof(XONLINE_SERVICE_INFO) );
    }
    
    return m_rgServiceContexts[dwServiceIndex].hr;
}

XOKERBINFO * CXo::XkerbGetInfo(DWORD dwServiceID)
{
    PXKERB_SERVICE_CONTEXT pXKerbServiceContext;
    DWORD dwServiceIndex = GetServiceArrayIndex( dwServiceID );

    Assert( SUCCEEDED(m_rgServiceContexts[dwServiceIndex].hr) );
    pXKerbServiceContext = m_rgServiceContexts[dwServiceIndex].pXKerbServiceContext;
    Assert( pXKerbServiceContext != NULL );

    return &(pXKerbServiceContext->xoKerbInfo);
}

NTSTATUS CXo::XkerbBuildApReq(DWORD dwServiceID, LARGE_INTEGER * pliTime, BYTE * pbSha, UINT cbSha, BYTE * pbApReq, UINT * pcbApReq)
{
    NTSTATUS Status;
    PXKERB_SERVICE_CONTEXT pXKerbServiceContext;
    DWORD dwServiceIndex = GetServiceArrayIndex( dwServiceID );
    
    Assert( SUCCEEDED(m_rgServiceContexts[dwServiceIndex].hr) );
    pXKerbServiceContext = m_rgServiceContexts[dwServiceIndex].pXKerbServiceContext;
    Assert( pXKerbServiceContext != NULL );

    Status = XkerbBuildApRequest( pXKerbServiceContext, pliTime, pbSha, cbSha, pbApReq, pcbApReq );
    if (!NT_SUCCESS(Status))
    {
        TraceSz1( AuthWarn, "XkerbBuildApReq: XkerbBuildApRequest failed with Status: 0x%X", Status );
    }

    return (Status);
}

NTSTATUS CXo::XkerbCrackApRep(DWORD dwServiceID, LARGE_INTEGER * pliTime, BYTE * pbSha, UINT cbSha, BYTE * pbApRep, UINT cbApRep)
{
    NTSTATUS Status;
    PXKERB_SERVICE_CONTEXT pXKerbServiceContext;
    DWORD dwServiceIndex = GetServiceArrayIndex( dwServiceID );
    
    Assert( SUCCEEDED(m_rgServiceContexts[dwServiceIndex].hr) );
    pXKerbServiceContext = m_rgServiceContexts[dwServiceIndex].pXKerbServiceContext;
    Assert( pXKerbServiceContext != NULL );

    Status = XkerbVerifyApReply( pXKerbServiceContext, pliTime, pbSha, cbSha, pbApRep, cbApRep );
    if (!NT_SUCCESS(Status))
    {
        TraceSz1( AuthWarn, "XkerbCrackApRep: XkerbVerifyApReply failed with Status: 0x%X", Status );
    }

    return (Status);
}

#ifdef XONLINE_FEATURE_INSECURE

void CXo::XkerbGetAuthData(XKERB_AD_XBOX * pAuthData)
{
    DWORD i;
    
    RtlZeroMemory( pAuthData, sizeof(XKERB_AD_XBOX) );

    pAuthData->wAuthDataVersion = XONLINE_AUTHDATA_VERSION;

#ifdef XONLINE_FEATURE_XBOX
    NTSTATUS Status;
    ULONG ulType, ulSize;
    Status = ExQueryNonVolatileSetting(XC_FACTORY_ETHERNET_ADDR, &ulType, pAuthData->abEthernetAddr, sizeof(pAuthData->abEthernetAddr), &ulSize);
    Assert(NT_SUCCESS(Status) && ulSize == sizeof(pAuthData->abEthernetAddr));
#endif

    pAuthData->dwAuthDataSize = sizeof(XKERB_AD_XBOX);
    pAuthData->clientVersion = g_ClientVersion;
    pAuthData->dwTitleID = m_dwTitleId;
    pAuthData->dwTitleVersion = m_dwTitleVersion;
    pAuthData->dwTitleRegion = m_dwTitleGameRegion;

    for (i=0; i<XONLINE_MAX_LOGON_USERS; ++i)
    {
        pAuthData->users[i] = m_rgLogonUsers[i].xuid; 
    }

    for (i=0; i<XONLINE_MAX_SERVICE_REQUEST; ++i)
    {
        if ( m_rgServiceContexts[i].serviceInfo.dwServiceID != XONLINE_INVALID_SERVICE )
        {
            pAuthData->dwServiceID[pAuthData->dwNumServices++] = m_rgServiceContexts[i].serviceInfo.dwServiceID;
        }
    }

    _XOnlineGetMachineID(&pAuthData->qwXboxID);
}

#endif

// ---------------------------------------------------------------------------------------
// CXoBase support routines
// ---------------------------------------------------------------------------------------

XOKERBINFO * CXoBase::XoKerbGetInfo(DWORD dwServiceId)
{
    return(((CXo *)this)->XkerbGetInfo(dwServiceId));
}

BOOL CXoBase::XoKerbBuildApReq(DWORD dwServiceId, LARGE_INTEGER * pliTime, BYTE * pbSha, UINT cbSha, BYTE * pbApReq, UINT * pcbApReq)
{
    return(NT_SUCCESS(((CXo *)this)->XkerbBuildApReq(dwServiceId, pliTime, pbSha, cbSha, pbApReq, pcbApReq)));
}

BOOL CXoBase::XoKerbCrackApRep(DWORD dwServiceId, LARGE_INTEGER * pliTime, BYTE * pbSha, UINT cbSha, BYTE * pbApRep, UINT cbApRep)
{
    return(NT_SUCCESS(((CXo *)this)->XkerbCrackApRep(dwServiceId, pliTime, pbSha, cbSha, pbApRep, cbApRep)));
}

#ifdef XONLINE_FEATURE_INSECURE

void CXoBase::XoKerbGetAuthData(XKERB_AD_XBOX * pAuthData)
{
    ((CXo *)this)->XkerbGetAuthData(pAuthData);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\match.cpp ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved

Description:
    Module implementing Xbox Matchmaking APIs

Module Name:

    match.cpp

--*/

#include "xonp.h"
#include "xonver.h"

//
// Server configuration information for matchmaking POST requests
// to front doors.
//
typedef struct
{
    DWORD dwService;                  // Service ID number
    CHAR * szUrl;                   // relative URL of ISAPI front door
    CHAR * szContentType;           // Service content type
    DWORD dwContentType;              // Size of the service content type
} XPRESENCE_SERVERS, *PXPRESENCE_SERVERS;

const XPRESENCE_SERVERS g_MatchServers[3] =
{
    { XONLINE_MATCHMAKING_SERVICE, "/xmatch/xmatchhost.srf",       "Content-Type: xon/6\r\n", 21 },
    { XONLINE_MATCHMAKING_SERVICE, "/xmatch/xmatchclient.srf",     "Content-Type: xon/6\r\n", 21 },
    { XONLINE_MATCHMAKING_SERVICE, "/xmatch/xmatchhostdelete.srf", "Content-Type: xon/6\r\n", 21 }
};

enum SERVER_TYPE
{
    serverMatchHost = 0,
    serverMatchClient,
    serverMatchHostDelete
};

//
// Timeout for POST requests.  After 30 seconds, requests will timeout with a failure.
//
#define DW_POST_TIMEOUT         30000

//
// Size of the send buffer -- including headers.
//
#define DW_LEN_SENDBUFFER 175

//
// Defines for attribute information.  Makes it easier to incorporate changes to these types.
//
#define ATTRIBUTE_OFFSET_TYPE        DWORD
#define ATTRIBUTE_ID_TYPE            DWORD
#define ATTRIBUTE_STRING_LENGTH_TYPE WORD
#define ATTRIBUTE_BLOB_LENGTH_TYPE   WORD

//
// Type of matchmaking request
//
enum XMATCH_TYPE
{
    xmatchCreate = 0,                           // Session creation/advertisment
    xmatchSearch,                               // Session search
    xmatchDelete                                // Session delete
};

//
// Extended task handle structure
//
struct XMATCH_EXTENDED_HANDLE
{
    XONLINETASK_CONTEXT  XMatchTaskHandle;      // Base task handle
    XONLINETASK_HANDLE   UploadTaskHandle;      // Task handle for XRL Upload
#if DBG
    DWORD                dwSignature;           // Debug signature for verification
#endif
    XMATCH_TYPE          Type;                  // Type of matchmaking request
    XNKID                SessionID;             // Session ID of new session                               
    XNKEY                KeyExchangeKey;        // Key of session
    DWORD                dwResultsLength;       // Length of results returned from search request
    DWORD                dwResponseCode;        // Response from server
    DWORD                dwMaxSearchResults;    // Maximum number of search results
    DWORD                dwActualSearchResults; // Actual search results returned
    PXMATCH_SEARCHRESULT *rgpSearchResults;     // Array of pointers to search results
    BYTE                 *pbResultsBuffer;      // Buffer of search results
    UINT                  cbResultsBufferAlloc; // Allocated size of results buffer
    BYTE                 *pbBuffer;             // Send buffer
};

//
// Write an Attribute Offset and increment the pointer to next Attribute offset
//
#define WriteAndIncAttributeOffset(pdwOffset, pbOffset) *pdwOffset = (DWORD) pbOffset; pdwOffset += 1;

//
// Write an Attribute ID and increment the pointer to next Attribute ID
//
#define WriteAndIncAttributeID(pByte, dwAttributeID)    *((DWORD *)pByte) = dwAttributeID; pByte += sizeof(DWORD);

//
// Write an Integer Attribute and increment the pointer to next Integer Attribute
//
#define WriteAndIncInt(pByte, qwInt)                    *((ULONGLONG *)pByte) = qwInt; pByte += sizeof(ULONGLONG);

//
// Write an Attribute String Length and increment the pointer to next Attribute String Length
//
#define WriteAndIncStringLen(pByte, cLength)            *((ATTRIBUTE_STRING_LENGTH_TYPE *)pByte) = cLength; pByte += sizeof(ATTRIBUTE_STRING_LENGTH_TYPE);

//
// Write an Attribute Blob Length and increment the pointer to next Attribute Blob Length
//
#define WriteAndIncBlobLen(pByte, cLength)              *((ATTRIBUTE_BLOB_LENGTH_TYPE *)pByte) = cLength; pByte += sizeof(ATTRIBUTE_BLOB_LENGTH_TYPE);

//
// Retrieve the Attribute ID
//
#define GetAttributeID(pByte)                           *((DWORD *) pByte)

//
// Retrieve the Attribute String Size
//
#define GetAttributeStringSize(pByte)                   *((ATTRIBUTE_STRING_LENGTH_TYPE *) (pByte+sizeof(DWORD)))

//
// Retrieve the Attribute Blob Size
//
#define GetAttributeBlobSize(pByte)                     *((ATTRIBUTE_BLOB_LENGTH_TYPE *) (pByte+sizeof(DWORD)))

//
// Return TRUE if the SessionID specified is not Zero
//
// Note:  This assumes that XNKID will always be a ULONGLONG type.  If this
// ever changes, we have to modify this.
//
#define IsSessionIDAvailable(SessionID)              (*((ULONGLONG *) &SessionID) != 0)

//
// Debug signature for extra validation
//
#define XMATCH_SIGNATURE                             'XMAT'
#define IsValidXMatchHandle(TaskHandle)             (((PXMATCH_EXTENDED_HANDLE)TaskHandle)->dwSignature == XMATCH_SIGNATURE)              

//---------------------------------------------------------------------------
//
// XOnlineMatchSessionCreate
//
// Public API
//
// Function to create/advertize a session
//
HRESULT
CXo::XOnlineMatchSessionCreate(
    IN DWORD dwPublicCurrent,
    IN DWORD dwPublicAvailable,
    IN DWORD dwPrivateCurrent,
    IN DWORD dwPrivateAvailable,
    IN DWORD dwNumAttributes,
    IN PXONLINE_ATTRIBUTE pAttributes,
    IN HANDLE hWorkEvent,
    OUT PXONLINETASK_HANDLE phTask
    )
{
    XoEnter("XOnlineMatchSessionCreate");
    XoCheck((dwNumAttributes == 0) == (pAttributes == NULL));
    XoCheck(phTask != NULL);

    DWORD i              = 0;
    XNKID SessionIDDummy = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };  // When creating a session, ID must be zero

    FixupAttributeIDs(dwNumAttributes, pAttributes);

    XoCheck(ValidateAttributeIDs(dwNumAttributes, pAttributes, TRUE));

    //
    // Since this is a session CREATE request, the fChanged flag
    // is set for every attribute so that all attributes get sent
    // up with the create request.
    //
    for (i = 0; i < dwNumAttributes; i += 1)
    {
        pAttributes[i].fChanged = TRUE;
    }

    //
    // Call private function that creates and/or updates session
    //

    return(XoLeave(SessionCreate( SessionIDDummy, dwPublicCurrent, dwPublicAvailable, dwPrivateCurrent, dwPrivateAvailable, dwNumAttributes, pAttributes, hWorkEvent, phTask)));
}

//---------------------------------------------------------------------------
//
// XOnlineMatchSessionUpdate
//
// Public API
//
// Function to update a session advertisement
//
HRESULT
CXo::XOnlineMatchSessionUpdate(
    IN XNKID SessionID,
    IN DWORD dwPublicCurrent,
    IN DWORD dwPublicAvailable,
    IN DWORD dwPrivateCurrent,
    IN DWORD dwPrivateAvailable,
    IN DWORD dwNumAttributes,
    IN PXONLINE_ATTRIBUTE pAttributes,
    IN HANDLE hWorkEvent,
    OUT PXONLINETASK_HANDLE phTask
    )
{
    XoEnter("XOnlineMatchSessionUpdate");
    XoCheck((dwNumAttributes == 0) == (pAttributes == NULL));
    XoCheck(IsSessionIDAvailable(SessionID));
    XoCheck(phTask != NULL);

    FixupAttributeIDs(dwNumAttributes, pAttributes);

    XoCheck(ValidateAttributeIDs(dwNumAttributes, pAttributes, TRUE));

    //
    // Call private function that creates and/or updates session
    //

    return(XoLeave(SessionCreate( SessionID, dwPublicCurrent, dwPublicAvailable, dwPrivateCurrent, dwPrivateAvailable, dwNumAttributes, pAttributes, hWorkEvent, phTask )));
}


//---------------------------------------------------------------------------
//
// XOnlineMatchSessionGetInfo 
//
// Public API
//
// Function to retrieve the session ID that was created in the
// create session call.  It will return zero until the session
// creation has been completed.
//
HRESULT
CXo::XOnlineMatchSessionGetInfo(
    IN XONLINETASK_HANDLE hTask,
    OUT XNKID *pSessionID,
    OUT XNKEY *pKeyExchangeKey
    )
{
    XoEnter("XOnlineMatchSessionGetInfo");
    XoCheck(hTask != NULL && IsValidXMatchHandle(hTask));
    XoCheck(pSessionID != NULL);
    XoCheck(pKeyExchangeKey != NULL);

    PXMATCH_EXTENDED_HANDLE pExtendedHandle = (PXMATCH_EXTENDED_HANDLE) hTask;

#if DBG
    if (!IsSessionIDAvailable(pExtendedHandle->SessionID))
    {
        TraceSz(Warning, "XOnlineMatchSessionGetInfo: Send session description has not completed successfully.  No Session ID to return.");
    }
#endif

    //
    // Copy session ID and key exchange key into buffer
    //
    memcpy(pSessionID, &pExtendedHandle->SessionID, sizeof(pExtendedHandle->SessionID));
    memcpy(pKeyExchangeKey, &pExtendedHandle->KeyExchangeKey, sizeof(pExtendedHandle->KeyExchangeKey));

    return(XoLeave(S_OK));
}


//---------------------------------------------------------------------------
//
// XOnlineMatchSessionDelete
//
// Public API
//
// Function to delete session.
//
HRESULT
CXo::XOnlineMatchSessionDelete(
    IN XNKID SessionID,
    IN HANDLE hWorkEvent,
    OUT PXONLINETASK_HANDLE phTask
    )
{
    XoEnter("XOnlineMatchSessionDelete");
    XoCheck(IsSessionIDAvailable(SessionID));
    XoCheck(phTask != NULL);

    HRESULT                 hr              = S_OK;
    PXMATCH_EXTENDED_HANDLE pExtendedHandle = NULL;
    PXMATCH_SESSION_DELETE  pHeader         = NULL;
    DWORD                   dwBufferLen     = DW_LEN_SENDBUFFER;

    //
    // Initialize task handle to NULL in case of error
    //
    *phTask = NULL;

    //
    // Create and fill in the Extended Task Handle structure and allocate any required
    // buffers
    //
    hr = CreateContext( &pExtendedHandle, sizeof(XMATCH_SESSION_DELETE), 0, SessionID, hWorkEvent, 0, xmatchDelete );

    if (SUCCEEDED(hr))
    {
        //
        // Fill in the delete request protocol structure
        //
        pHeader = (PXMATCH_SESSION_DELETE) pExtendedHandle->pbBuffer;
    
        pHeader->dwMessageLength   = sizeof(XMATCH_SESSION_DELETE);
        pHeader->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
        pHeader->dwTitleID         = m_dwTitleId;

        memcpy(&pHeader->SessionID, &SessionID, sizeof(SessionID));

        *phTask = (XONLINETASK_HANDLE) pExtendedHandle;
    }

    //
    // Post delete request to the server.  Timeout after 30 seconds.
    //
    hr = XOnlineUploadFromMemory( g_MatchServers[serverMatchHostDelete].dwService, g_MatchServers[serverMatchHostDelete].szUrl,
                                  NULL, &dwBufferLen,
                                  (PBYTE)g_MatchServers[serverMatchHostDelete].szContentType, g_MatchServers[serverMatchHostDelete].dwContentType,
                                  pExtendedHandle->pbBuffer, pHeader->dwMessageLength,
                                  DW_POST_TIMEOUT,
                                  hWorkEvent, &pExtendedHandle->UploadTaskHandle );

    return(XoLeave(hr));
}


//---------------------------------------------------------------------------
//
// XOnlineMatchSearch
//
// Public API.
//
// Function to search for a session
//
HRESULT
CXo::XOnlineMatchSearch(
    IN DWORD dwProcedureIndex,
    IN DWORD dwNumResults,
    IN DWORD dwNumAttributes,
    IN PXONLINE_ATTRIBUTE pAttributes,
    IN DWORD dwResultsLen,
    IN HANDLE hWorkEvent,
    OUT PXONLINETASK_HANDLE phTask
    )
{
    XoEnter("XOnlineMatchSearch");
    XoCheck(dwProcedureIndex != X_SSINDEX_GET_SESSION);
    XoCheck(dwNumResults > 0);
    XoCheck((dwNumAttributes == 0) == (pAttributes == NULL));
    XoCheck(dwResultsLen > 0);
    XoCheck(phTask != NULL);
    XoCheck(ValidateAttributeIDs(dwNumAttributes, pAttributes, FALSE));

    //
    // Call private search function that is used for both general searches and FindFromID()
    //
    return(XoLeave(MatchSearch(dwProcedureIndex, dwNumResults, dwNumAttributes, pAttributes, dwResultsLen, hWorkEvent, phTask)));
}


//---------------------------------------------------------------------------
//
// XOnlineMatchSessionFindFromID
//
// Public API.
//
// Function to search for a particular session ID.
//
HRESULT
CXo::XOnlineMatchSessionFindFromID(
    IN XNKID SessionID,
    IN HANDLE hWorkEvent,
    OUT PXONLINETASK_HANDLE phTask
    )
{
    XoEnter("XOnlineMatchSessionFindFromID");
    XoCheck(IsSessionIDAvailable(SessionID));
    XoCheck(phTask != NULL);

    XONLINE_ATTRIBUTE Attribute;

    //
    // Create the one parameter we have to pass into the FindFromID stored procedure.
    //
    // Note:  This assumes that XNKID will always be a ULONGLONG type.  If this
    // ever changes, we have to modify this to append a blob instead.
    //
    Attribute.info.integer.qwValue = *((ULONGLONG*) &SessionID);
    Attribute.dwAttributeID = X_ATTRIBUTE_DATATYPE_INTEGER;

    return(XoLeave(MatchSearch( X_SSINDEX_GET_SESSION, 1, 1, &Attribute, DW_LEN_SENDBUFFER, hWorkEvent, phTask )));
}


//---------------------------------------------------------------------------
//
// XOnlineMatchSearchGetResults
//
// Public API.
//
// Function to retrieve the search results from the
// search request.
//
// Note: Callers will NOT have to free rgpSearchResults when
// they are done, but they must call XOnlineTaskFree(hSearch)
// AFTER they are done with prgpSearchResults.
//
// prgpSearchResults returns a pointer to a vector of pointers to 
// PXMATCH_SEARCHRESULT structures (vs. pointer to an array of structs).
// i.e. ((*pprgpSearchResults)[i])->SessionID is the ID of the ith sessions
// returned.
//
HRESULT CXo::XOnlineMatchSearchGetResults(
    IN XONLINETASK_HANDLE hTask,
    OUT PXMATCH_SEARCHRESULT **prgpSearchResults,
    OUT DWORD *pdwReturnedResults
    )
{
    XoEnter("XOnlineMatchSearchGetResults");
    XoCheck(hTask != NULL && IsValidXMatchHandle(hTask));
    XoCheck(prgpSearchResults != NULL);
    XoCheck(pdwReturnedResults != NULL);

    PXMATCH_EXTENDED_HANDLE pExtendedHandle    = (PXMATCH_EXTENDED_HANDLE) hTask;
    DWORD                   i                  = 0;
    PBYTE                   pbSearchResult     = NULL;
    PBYTE                   pbNextSearchResult = NULL;
    PBYTE                   pbEndBuffer        = NULL;
    HRESULT                 hr                 = S_OK;

    //
    // Initialize number of search results to zero in case of error
    //
    *pdwReturnedResults = 0;

    //
    // If a search was not completed successfully, return an error to client
    //
    if (pExtendedHandle->dwResponseCode != 200)
    {
        hr = E_FAIL; // BUGBUG: maybe pick a different error code here.
        goto Cleanup;
    }

    //
    // Parse through search results buffer and collect pointers to beginning
    // of each session.
    //
    pbSearchResult = pExtendedHandle->pbResultsBuffer;
    pbEndBuffer = pExtendedHandle->pbResultsBuffer + pExtendedHandle->dwResultsLength;

    for ( i = 0; i < pExtendedHandle->dwMaxSearchResults; i += 1 )
    {
        //
        // If there is enough room left in the buffer for a full search results structure, we can continue.
        // Otherwise, there is an incomplete search result and we end.
        //
        if ((pbSearchResult + sizeof(XMATCH_SEARCHRESULT)) <= pbEndBuffer)
        {
            //
            // Set pointer to next search result
            //
            pbNextSearchResult = pbSearchResult + ((PXMATCH_SEARCHRESULT) pbSearchResult)->dwResultLength;

            //
            // If the new pointer is beyond the end of our buffer, it means this search result
            // is not complete.  Otherwise, it is complete and we update our array of pointers
            // to include this search result.
            //
            if (pbNextSearchResult <= pbEndBuffer)
            {
                //
                // Add this pointer to the array of search result pointers
                //
                pExtendedHandle->rgpSearchResults[i] = (PXMATCH_SEARCHRESULT) pbSearchResult;

                //
                // Increment the number of search results we have
                //
                (*pdwReturnedResults) += 1;
            }

            //
            // Continue with next search result
            //
            pbSearchResult = pbNextSearchResult;
        }
        else // It's not a complete search result structure
        {
            break;
        }
    }

    //
    // Return the array of search result pointers
    //
    *prgpSearchResults = pExtendedHandle->rgpSearchResults;
    pExtendedHandle->dwActualSearchResults = *pdwReturnedResults;

Cleanup:

    return(XoLeave(hr));
}


//---------------------------------------------------------------------------
//
// XOnlineMatchSearchParse
//
// Public API
//
// Function to parse individual sessions in a set of search results.
//
HRESULT CXo::XOnlineMatchSearchParse(
    IN PXMATCH_SEARCHRESULT pSearchResult,
    IN DWORD dwNumSessionAttributes,
    IN PXONLINE_ATTRIBUTE_SPEC pSessionAttributeSpec,
    OUT PVOID pQuerySession
    )
{
    XoEnter("XOnlineMatchSearchParse");
    XoCheck(pSearchResult != NULL);
    XoCheck(pSearchResult->dwNumAttributes == dwNumSessionAttributes);
    XoCheck(pSessionAttributeSpec != NULL);
    XoCheck(pQuerySession != NULL);

    ATTRIBUTE_OFFSET_TYPE   *pAttributeOffset = NULL;
    PBYTE                   pbAttribute       = NULL;
    HRESULT                 hr                = S_OK;
    DWORD                   i                 = 0;
    DWORD                   dwAttributeID     = 0;
    PBYTE                   pbCopyTo          = (PBYTE) pQuerySession;

    //
    // Loop through all attributes for this particular session
    //
    for (i = 0; i < pSearchResult->dwNumAttributes; i += 1)
    {
        //
        // Set pointers to the offset of the attribute and the attribute itself.
        //
        pAttributeOffset = ((ATTRIBUTE_OFFSET_TYPE *) (((PBYTE) pSearchResult) + sizeof(XMATCH_SEARCHRESULT))) + i;
        pbAttribute = ((PBYTE) pSearchResult) + *pAttributeOffset;

        //
        // Get the ID of the attribute
        //
        dwAttributeID = GetAttributeID(pbAttribute);

        //
        // Retrieve attribute and copy it into the user-supplied buffer
        //
        switch (dwAttributeID)
        {
            case X_ATTRIBUTE_DATATYPE_INTEGER:
            {
                //
                // Verify that the Attribute Spec matches the attribute we're retrieving
                //
                Assert(pSessionAttributeSpec[i].type == X_ATTRIBUTE_DATATYPE_INTEGER);

                //
                // Write the integer attribute to the user-supplied buffer
                //
                WriteAndIncInt(pbCopyTo, *((ULONGLONG *) (pbAttribute + sizeof(DWORD))));
                break;
            }

            case X_ATTRIBUTE_DATATYPE_STRING:
            {
                //
                // Verify that the Attribute Spec matches the attribute we're retrieving
                //
                Assert(pSessionAttributeSpec[i].type == X_ATTRIBUTE_DATATYPE_STRING);

                //
                // Verify that the size of the supplied string attribute buffer is big enough to hold the attribute
                //
                Assert(pSessionAttributeSpec[i].length >= GetAttributeStringSize(pbAttribute));

                //
                // Convert the UTF8 string to Unicode and copy into the user-supplied buffer.
                //
                MultiByteToWideChar( CP_UTF8, 0, (LPSTR) (pbAttribute + sizeof(DWORD) + sizeof(ATTRIBUTE_STRING_LENGTH_TYPE)), GetAttributeStringSize(pbAttribute), (LPWSTR) pbCopyTo, pSessionAttributeSpec[i].length / sizeof(WCHAR) );

                //
                // Move pointer to beginning of next attribute in user-supplied buffer
                //
                pbCopyTo += pSessionAttributeSpec[i].length;
                break;
            }

            case X_ATTRIBUTE_DATATYPE_BLOB:
            {
                //
                // Verify that the Attribute Spec matches the attribute we're retrieving
                //
                Assert(pSessionAttributeSpec[i].type == X_ATTRIBUTE_DATATYPE_BLOB);

                //
                // Verify that the size of the supplied blob attribute buffer is big enough to hold the attribute
                //
                Assert(pSessionAttributeSpec[i].length >= GetAttributeBlobSize(pbAttribute));

                //
                // Copy the blob size into the supplied attribute buffer
                //
                WriteAndIncBlobLen(pbCopyTo, GetAttributeBlobSize(pbAttribute));

                //
                // Copy the blob into the supplied attribute buffer
                //
                memcpy(pbCopyTo, pbAttribute + sizeof(DWORD) + sizeof(ATTRIBUTE_BLOB_LENGTH_TYPE), GetAttributeBlobSize(pbAttribute));

                //
                // Move pointer to beginning of next attribute in user-supplied buffer
                //
                pbCopyTo += pSessionAttributeSpec[i].length;
                break;
            }

            case X_ATTRIBUTE_DATATYPE_NULL:
            {
                //
                // Skip this attribute.  We assume that the developer set this buffer section to a known value, and
                // they should check against this known value to know if it's a NULL attribute or not.
                //

                //
                // For a blob type, write zero to the blob size first
                //
                if (pSessionAttributeSpec[i].type == X_ATTRIBUTE_DATATYPE_BLOB)
                {
                    WriteAndIncBlobLen(pbCopyTo, 0);
                }

                pbCopyTo += pSessionAttributeSpec[i].length;
                break;
            }
        }
    }

    return(XoLeave(hr));
}


//---------------------------------------------------------------------------
//
// SessionCreate
//
// Private API.  Called by MatchSessionCreate() and MatchSessionUpdate().
//
// Function to open a session creation request.
//
HRESULT CXo::SessionCreate(
    IN XNKID SessionID,
    IN DWORD dwPublicCurrent,
    IN DWORD dwPublicAvailable,
    IN DWORD dwPrivateCurrent,
    IN DWORD dwPrivateAvailable,
    IN DWORD dwNumAttributes,
    IN PXONLINE_ATTRIBUTE pAttributes,
    IN HANDLE hWorkEvent,
    OUT PXONLINETASK_HANDLE phTask
    )
{
    HRESULT                 hr                     = S_OK;
    PXMATCH_EXTENDED_HANDLE pExtendedHandle        = NULL;
    PXMATCH_SESSION         pHeader                = NULL;
    DWORD                   dwMessageLength        = 0;
    DWORD                   dwResultsLen           = DW_LEN_SENDBUFFER;
    DWORD                   dwNumUpdatedAttributes = 0;
    DWORD                   i                      = 0;

    //
    // Initialize task handle in case of error
    //
    *phTask = NULL;

#if DBG

    AssertSz(!m_fSessionCreateInProgress, "Can only create one match session at a time");

    //
    // Set global flag to indicate that a SessionCreate is in progress.  Only one SessionCreate
    // can be in progress at a time.
    //

    m_fSessionCreateInProgress = TRUE;

#endif

    //
    // Count the number of attributes with the fChanged flag set to TRUE.
    //
    for (i = 0; i < dwNumAttributes; i += 1)
    {
        if (pAttributes[i].fChanged == TRUE)
        {
            dwNumUpdatedAttributes += 1;
        }
    }

    //
    // Determine how big the message buffer should be to hold complete post
    // request.  Also figure out the number of real attributes, since PRIVATE_AVAILABLE
    // and PUBLIC_AVAILABLE are not really attributes.
    //
    dwMessageLength = sizeof(XMATCH_SESSION) + TotalAttributeSize(dwNumUpdatedAttributes, pAttributes);

    //
    // Create and fill in extended task handle structure and allocate any required buffers
    //
    hr = CreateContext( &pExtendedHandle, dwMessageLength, 0, SessionID, hWorkEvent, 0, xmatchCreate );

    if (SUCCEEDED(hr))
    {
        //
        // Fill in session create protocol structure
        //
        pHeader = (PXMATCH_SESSION) pExtendedHandle->pbBuffer;

        //
        // Retrieve IP address of Xbox
        //
        XNetGetTitleXnAddr(&pHeader->HostAddress);

        pHeader->dwMessageLength    = dwMessageLength;
        pHeader->dwProtocolVersion  = X_MATCH_PROTOCOL_VERSION;
        pHeader->dwTitleID          = m_dwTitleId;

        //
        // Initially set public and private available slots to zero.
        //
        pHeader->dwPublicAvailable  = dwPublicAvailable;
        pHeader->dwPrivateAvailable = dwPrivateAvailable;
        pHeader->dwPublicCurrent    = dwPublicCurrent;
        pHeader->dwPrivateCurrent   = dwPrivateCurrent;
        pHeader->dwNumAttributes    = dwNumUpdatedAttributes;
        memcpy(&pHeader->SessionID, &SessionID, sizeof(SessionID));

        //
        // Call function that will parse session attributes and add them to our POST request buffer
        //
        WriteAttributes(pExtendedHandle->pbBuffer, dwNumAttributes, pAttributes, (DWORD *) (pExtendedHandle->pbBuffer + sizeof(XMATCH_SESSION)), pExtendedHandle->pbBuffer + sizeof(XMATCH_SESSION) + (dwNumAttributes * sizeof(ATTRIBUTE_OFFSET_TYPE)));

        //
        // POST our session creation request.  Timeout after 30 seconds.
        //
        hr = XOnlineUploadFromMemory( g_MatchServers[serverMatchHost].dwService,
                                      g_MatchServers[serverMatchHost].szUrl,
                                      pExtendedHandle->pbResultsBuffer, &dwResultsLen,
                                      (PBYTE)g_MatchServers[serverMatchHost].szContentType, g_MatchServers[serverMatchHost].dwContentType,
                                      pExtendedHandle->pbBuffer, pHeader->dwMessageLength,
                                      DW_POST_TIMEOUT,
                                      hWorkEvent, &pExtendedHandle->UploadTaskHandle );

        //
        // Return the task handle
        //
        *phTask = (XONLINETASK_HANDLE) pExtendedHandle;
    }

    return(hr);
}


//---------------------------------------------------------------------------
//
// MatchSearch
//
// Private API.  Called from MatchSearch() and MatchFindFromID()
//
// Search for a matching session.
//
HRESULT CXo::MatchSearch(
    IN DWORD dwProcedureIndex,
    IN DWORD dwNumResults,
    IN DWORD dwNumAttributes,
    IN PXONLINE_ATTRIBUTE pAttributes,
    IN DWORD dwResultsLen,
    IN HANDLE hWorkEvent,
    OUT PXONLINETASK_HANDLE phTask
    )
{
    HRESULT                 hr                  = S_OK;
    PXMATCH_EXTENDED_HANDLE pExtendedHandle     = NULL;
    PXMATCH_SEARCH          pHeader             = NULL;
    XNKID                   SessionIDDummy      = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
    DWORD                   dwMessageLength     = 0;
    DWORD                   i                   = 0;

    //
    // Initialize task handle to NULL in case of error
    //
    *phTask = NULL;

    //
    // Since this is a session SEARCH request, the fChanged flag
    // is set for every attribute so that all attributes get sent
    // up with the search request.
    //
    for (i = 0; i < dwNumAttributes; i += 1)
    {
        pAttributes[i].fChanged = TRUE;
    }

    //
    // Determine required size of message buffer
    //
    dwMessageLength = sizeof(XMATCH_SEARCH) + TotalAttributeSize(dwNumAttributes, pAttributes);

    //
    // Create and fill in extended task handle structure and allocate any required buffers
    //
    hr = CreateContext( &pExtendedHandle, dwMessageLength, dwResultsLen, SessionIDDummy, hWorkEvent, dwNumResults, xmatchSearch );

    if (SUCCEEDED(hr))
    {
        //
        // Fill in session search protocol structure
        //
        pHeader = (PXMATCH_SEARCH) pExtendedHandle->pbBuffer;
    
        pHeader->dwMessageLength   = dwMessageLength;
        pHeader->dwProtocolVersion = X_MATCH_PROTOCOL_VERSION;
        pHeader->dwTitleID         = m_dwTitleId;
        pHeader->dwProcedureIndex  = dwProcedureIndex;
        pHeader->dwNumParameters   = dwNumAttributes;

        //
        // Call function that will parse session attributes and add them to our POST request buffer
        //
        WriteAttributes(pExtendedHandle->pbBuffer, dwNumAttributes, pAttributes, (DWORD *) (pExtendedHandle->pbBuffer + sizeof(XMATCH_SEARCH)), pExtendedHandle->pbBuffer + sizeof(XMATCH_SEARCH) + (dwNumAttributes * sizeof(ATTRIBUTE_OFFSET_TYPE)));

        //
        // POST our session creation request.  Timeout after 30 seconds.
        //
        hr = XOnlineUploadFromMemory( g_MatchServers[serverMatchClient].dwService,
                                      g_MatchServers[serverMatchClient].szUrl,
                                      pExtendedHandle->pbResultsBuffer, &dwResultsLen,
                                      (PBYTE)g_MatchServers[serverMatchClient].szContentType, g_MatchServers[serverMatchClient].dwContentType,
                                      pExtendedHandle->pbBuffer, pHeader->dwMessageLength,
                                      DW_POST_TIMEOUT,
                                      hWorkEvent, &pExtendedHandle->UploadTaskHandle );

        //
        // Return the task handle
        //
        *phTask = (XONLINETASK_HANDLE) pExtendedHandle;
    }

    return hr;
}


//---------------------------------------------------------------------------
//
// CreateContext
//
// Private API.
//
// Create an extended task handle structure for matchmaking.  Fill in default
// values in this structure.  Allocate any buffers that are required for
// the particular matchmaking request. 
//
HRESULT CXo::CreateContext(
    OUT PXMATCH_EXTENDED_HANDLE *ppExtendedHandle,  // Pointer to extended task handle structure
    IN DWORD dwMsgLen,                              // Length of POST request
    IN DWORD dwResultsLen,                          // Length of expected response
    IN XNKID SessionID,                             // ID of session
    IN HANDLE hWorkEvent,                           // Event to set when work is available
    IN DWORD dwNumResults,                          // Number of results we ask for
    IN XMATCH_TYPE Type                             // Type of request
    )
{
    HRESULT hr = S_OK;
    
    //
    // Allocate mem for the extended handle
    //
    (*ppExtendedHandle) = (PXMATCH_EXTENDED_HANDLE)SysAllocZ(sizeof(XMATCH_EXTENDED_HANDLE), PTAG_XMATCH_EXTENDED_HANDLE);
    if ((*ppExtendedHandle) == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    //
    // Initialize the matchmaking task handle and set the handler functions and event.
    //
    TaskInitializeContext(&((*ppExtendedHandle)->XMatchTaskHandle));
    (*ppExtendedHandle)->XMatchTaskHandle.pfnContinue = MatchContinue;
    (*ppExtendedHandle)->XMatchTaskHandle.pfnClose = MatchClose;
    (*ppExtendedHandle)->XMatchTaskHandle.hEventWorkAvailable = hWorkEvent;

    //
    // Allocate a buffer for the POST request
    //
    (*ppExtendedHandle)->pbBuffer = (BYTE *) SysAllocZ(dwMsgLen, PTAG_XMATCH_POST_BUFFER);
    if ((*ppExtendedHandle)->pbBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    //
    // If we expect a response from the server, allocate memory to hold the response
    //
    if (dwResultsLen != 0)
    {
        (*ppExtendedHandle)->pbResultsBuffer = (BYTE *) SysAlloc(dwResultsLen, PTAG_XMATCH_RESULTS_BUFFER);
        if ((*ppExtendedHandle)->pbResultsBuffer == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Error;
        }
        (*ppExtendedHandle)->cbResultsBufferAlloc = dwResultsLen;
    }
    else
    {
        (*ppExtendedHandle)->pbResultsBuffer = NULL;
        (*ppExtendedHandle)->cbResultsBufferAlloc = 0;
    }

    //
    // If it's a search request, allocate an array of pointers to search results
    //
    if (dwNumResults != 0)
    {
        (*ppExtendedHandle)->rgpSearchResults = (PXMATCH_SEARCHRESULT *) SysAlloc(dwNumResults * sizeof(PXMATCH_SEARCHRESULT),
            PTAG_XMATCH_SEARCHRESULT);
        if ((*ppExtendedHandle)->rgpSearchResults == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Error;
        }
    }
    else
    {
        (*ppExtendedHandle)->rgpSearchResults = NULL;
    }

    //
    // Fill in the remaining fields of the extended task handle
    //
    (*ppExtendedHandle)->Type               = Type;
    (*ppExtendedHandle)->dwResultsLength    = 0;
    (*ppExtendedHandle)->UploadTaskHandle   = NULL;
    (*ppExtendedHandle)->dwResponseCode     = 0;
    (*ppExtendedHandle)->dwMaxSearchResults = dwNumResults;
    memcpy(&(*ppExtendedHandle)->SessionID, &SessionID, sizeof(SessionID));

#if DBG
    //
    // Debug signature to do extra validation
    //
    (*ppExtendedHandle)->dwSignature            = XMATCH_SIGNATURE;
#endif

Cleanup:
    return(hr);

Error:

    if ((*ppExtendedHandle)->pbBuffer != NULL)
    {
        SysFree( (*ppExtendedHandle)->pbBuffer );
    }

    if ((*ppExtendedHandle)->pbResultsBuffer != NULL)
    {
        SysFree( (*ppExtendedHandle)->pbResultsBuffer );
    }

    if ((*ppExtendedHandle)->rgpSearchResults != NULL)
    {
        SysFree( (*ppExtendedHandle)->rgpSearchResults );
    }

    if ((*ppExtendedHandle) != NULL)
    {
        SysFree(*ppExtendedHandle);
    }

    goto Cleanup;
}



//---------------------------------------------------------------------------
//
// FixupAttributeIDs
//
// Private API.
//
// Add Session flag to all attribute IDs.  User attributes are no longer
// supported, so we have to manually add the Session flag to all
// attribute IDs.
//
VOID CXo::FixupAttributeIDs(
    IN  DWORD dwNumAttributes,
    IN  PXONLINE_ATTRIBUTE pAttributes
    )
{
    DWORD i = 0;

    //
    // Loop through all attributes and set SESSION flag.
    //
    for (i = 0; i < dwNumAttributes; i += 1)
    {
        pAttributes[i].dwAttributeID |= X_ATTRIBUTE_TYPE_SESSION;
    }

    return;
}


//---------------------------------------------------------------------------
//
// TotalAttributeSize
//
// Private API.
//
// Calculate size of all attributes, including attribute offsets and
// attribute IDs.
//
DWORD CXo::TotalAttributeSize(
    IN  DWORD dwNumAttributes,
    IN  PXONLINE_ATTRIBUTE pAttributes
    )
{
    DWORD i = 0;
    DWORD dwSize = dwNumAttributes * ( sizeof(ATTRIBUTE_OFFSET_TYPE) + sizeof(ATTRIBUTE_ID_TYPE) );

    //
    // Loop through all attributes and add size of attribute to dwSize.
    //
    for (i = 0; i < dwNumAttributes; i += 1)
    {
        switch (pAttributes[i].dwAttributeID & X_ATTRIBUTE_DATATYPE_MASK)
        {
            case X_ATTRIBUTE_DATATYPE_INTEGER:
            {
                //
                // Integer attributes are just a ULONGLONG
                //
                dwSize += sizeof(ULONGLONG);

                break;
            }

            case X_ATTRIBUTE_DATATYPE_STRING:
            {
                //
                // String attributes are string length + UTF8 string, including NULL.
                //
                dwSize += sizeof(ATTRIBUTE_STRING_LENGTH_TYPE) + WideCharToMultiByte( CP_UTF8, 0, pAttributes[i].info.string.pwszValue, lstrlenW(pAttributes[i].info.string.pwszValue)+1, NULL, 0, NULL, NULL );

                break;
            }

            case X_ATTRIBUTE_DATATYPE_BLOB:
            {
                //
                // Blob attributes are blob length + size of blob
                //
                dwSize += sizeof(ATTRIBUTE_BLOB_LENGTH_TYPE) + pAttributes[i].info.blob.dwLength;

                break;
            }

            default:
            {
                // BUGBUG: Get rid of this case.  Do validation at top of every public function
                Assert(FALSE);
                break;
            }
        }
    }

    return dwSize;
}


//---------------------------------------------------------------------------
//
// WriteAttributes
//
// Private API.
//
// Function to write attributes to message buffer.  It assumes that the
// message buffer is big enough to hold all attributes.  It returns the
// actual number of attributes that had the fChanged flag set to TRUE.
//
VOID CXo::WriteAttributes(
    IN PBYTE pbBufferStart,               // Beginning of buffer, used to calculate offsets
    IN DWORD dwNumAttributes,             // Number of attributes
    IN PXONLINE_ATTRIBUTE pAttributes,    // Array of attribute structures
    IN DWORD *pdwAttributeOffset,         // Pointer to beginning of attribute offsets
    IN PBYTE pbAttribute                  // Pointer to beginning of attributes
    )
{
    DWORD i                      = 0;
    DWORD dwUTF8Length           = 0;

    //
    // Loop through all attributes
    //
    for (i = 0; i < dwNumAttributes; i += 1)
    {
        //
        // Only write an attribute to the buffer if it has changed (fChanged == TRUE).
        // In the case of a session CREATE request, all of the fChanged flags are set to
        // true before calling this function.
        //
        if (pAttributes[i].fChanged == TRUE)
        {
            //
            // Reset the fChanged flag so we know which flags have changed since the last update.
            //
            pAttributes[i].fChanged = FALSE;

            //
            // Write the actual attributes to the buffer
            //
            switch (pAttributes[i].dwAttributeID & X_ATTRIBUTE_DATATYPE_MASK)
            {
                case X_ATTRIBUTE_DATATYPE_INTEGER:
                {
                    //
                    // Write the attribute offset and increment the pointer to the next attribute offset
                    //
                    WriteAndIncAttributeOffset(pdwAttributeOffset, (pbAttribute - pbBufferStart));

                    //
                    // Write the integer attribute ID and the integer.  Increment
                    // the pointer to the next attribute.
                    //
                    WriteAndIncAttributeID(pbAttribute, pAttributes[i].dwAttributeID);
                    WriteAndIncInt(pbAttribute, pAttributes[i].info.integer.qwValue);

                    break;
                }

                case X_ATTRIBUTE_DATATYPE_STRING:
                {
                    Assert(pAttributes[i].info.string.pwszValue != NULL);
                    Assert(lstrlenW(pAttributes[i].info.string.pwszValue) <= X_MAX_STRING_ATTRIBUTE_LEN);

                    //
                    // Write the attribute offset and increment the pointer to the next attribute offset
                    //
                    WriteAndIncAttributeOffset(pdwAttributeOffset, (pbAttribute - pbBufferStart));

                    //
                    // Calculate the length of the UTF8 string.
                    //
                    dwUTF8Length = WideCharToMultiByte( CP_UTF8, 0, pAttributes[i].info.string.pwszValue, lstrlenW(pAttributes[i].info.string.pwszValue)+1, NULL, 0, NULL, NULL );

                    //
                    // Write the string attribute ID
                    //
                    WriteAndIncAttributeID(pbAttribute, pAttributes[i].dwAttributeID);

                    //
                    // Write the string length
                    //
                    WriteAndIncStringLen(pbAttribute, (ATTRIBUTE_STRING_LENGTH_TYPE) (dwUTF8Length));

                    //
                    // Write the UTF8 string
                    //
                    WideCharToMultiByte( CP_UTF8, 0, pAttributes[i].info.string.pwszValue, lstrlenW(pAttributes[i].info.string.pwszValue)+1, (LPSTR)pbAttribute, dwUTF8Length, NULL, NULL );

                    //
                    // Increment the pointer to the next attribute
                    //
                    pbAttribute += dwUTF8Length;

                    break;
                }
                                              
                case X_ATTRIBUTE_DATATYPE_BLOB:
                {
                    Assert(!((pAttributes[i].info.blob.dwLength > 0) && (pAttributes[i].info.blob.pvValue == NULL)));
                    Assert(pAttributes[i].info.blob.dwLength <= X_MAX_BLOB_ATTRIBUTE_LEN);

                    //
                    // Write the attribute offset and increment the pointer to the next attribute offset
                    //
                    WriteAndIncAttributeOffset(pdwAttributeOffset, (pbAttribute - pbBufferStart));

                    //
                    // Write the blob attribute ID
                    //
                    WriteAndIncAttributeID(pbAttribute, pAttributes[i].dwAttributeID);

                    //
                    // Write the blob length
                    //
                    WriteAndIncBlobLen(pbAttribute, (ATTRIBUTE_BLOB_LENGTH_TYPE) pAttributes[i].info.blob.dwLength);

                    //
                    // If the blob specified is not NULL, write the blob and increment the pointer to the next attribute
                    //
                    if (pAttributes[i].info.blob.pvValue != NULL)
                    {
                        memcpy( pbAttribute, pAttributes[i].info.blob.pvValue, pAttributes[i].info.blob.dwLength );
                        pbAttribute += pAttributes[i].info.blob.dwLength;
                    }

                    break;
                }

                default:
                {
                    // BUGBUG: Should never get here since the attribute list has been validated already
                    break;
                }
            }
        }
    }

    return;
}


//---------------------------------------------------------------------------
//
// MatchContinue()
//
// Public API (sort of)
//
// This is called when user calls TaskContinue with any matchmaking task
// handle.
//
HRESULT CXo::MatchContinue(XONLINETASK_HANDLE hTask)
{
    HRESULT                 hr               = XONLINETASK_S_RUNNING;
    PXMATCH_EXTENDED_HANDLE pExtendedHandle  = (PXMATCH_EXTENDED_HANDLE)hTask;
    PXMATCH_SESSION         pHeader          = NULL;
    PBYTE                   pbUpload         = NULL;
    DWORD                   dwStatus         = 0;
    DWORD                   cbUpload         = 0;
    ULARGE_INTEGER          uliContentLength;
    ULARGE_INTEGER          uliTotalReceived;
    BOOL                    fCleanHandle     = FALSE;

    Assert(hTask != NULL);
    Assert(IsValidXMatchHandle(hTask));

    //
    // If there is no XRL Upload task handle, this task must be complete
    //
    if (pExtendedHandle->UploadTaskHandle == NULL)
    {
        hr = XONLINETASK_S_SUCCESS;
        goto Error;
    }

    //
    // Tell the XRL Upload task handle to continue doing work
    //
    hr = XOnlineTaskContinue(pExtendedHandle->UploadTaskHandle);

    //
    // If the task is complete, error or success...
    //
    if (hr != XONLINETASK_S_RUNNING)
    {
        fCleanHandle = TRUE;

        //
        // If the task failed, return the error
        //
        if (FAILED(hr))
        {
            goto Error;
        }

        //
        // If the task is not successful, return the error.  This should never happen though, since we should have
        // caught it in the conditional above.
        //
        if (hr != XONLINETASK_S_SUCCESS)
        {
            // BUGBUG: Should never get here
            Assert(FALSE);
            __asm int 3;
            goto Error;
        }

        //
        // Get the results of the XRL Upload
        //
        hr = XOnlineUploadGetResults(pExtendedHandle->UploadTaskHandle, &pbUpload, &cbUpload, &uliTotalReceived, &uliContentLength, &dwStatus, NULL);

        //
        // Store the response code so the search parse functions know if it was
        // successful or not.
        //
        pExtendedHandle->dwResponseCode = dwStatus;

        //
        // If it wasn't a successful server code, return an error
        //
        if (pbUpload == NULL || dwStatus != 200)
        {
            hr = E_FAIL; // BUGBUG: find a better error code
            goto Error;
        }

        //
        // If it was successful, handle the results
        //
        if (SUCCEEDED(hr))
        {
            //
            // If it was a session create request, copy the new session info into our extended task handle
            //
            if ( pExtendedHandle->Type == xmatchCreate )
            {
                if (cbUpload > 0)
                {
                    pHeader = (PXMATCH_SESSION) pExtendedHandle->pbBuffer;

                    //
                    // Copy the new session ID and key exchange key into our extended task handle
                    //
                    memcpy(&pExtendedHandle->SessionID, &((PXMATCH_SESSION_INFO)pbUpload)->SessionID, sizeof(pExtendedHandle->SessionID));
                    memcpy(&pExtendedHandle->KeyExchangeKey, &((PXMATCH_SESSION_INFO)pbUpload)->KeyExchangeKey, sizeof(pExtendedHandle->KeyExchangeKey));
                }
            }
            else if ( pExtendedHandle->Type == xmatchDelete ) // Delete request
            {
                //
                // Do nothing if it was a session delete request.  No data comes back from these requests.
                //
            }
            else // Search request
            {
                //
                // Store the size of the response in our extended task handle.  This will later
                // be used to parse the search results.
                //
                if (uliContentLength.LowPart < pExtendedHandle->cbResultsBufferAlloc)
                {
                    pExtendedHandle->dwResultsLength = uliContentLength.LowPart;
                }
                else
                {
                    pExtendedHandle->dwResultsLength = pExtendedHandle->cbResultsBufferAlloc;
                }
            }
        }
        else
        {
            goto Error;
        }
    }

  Error:

    if (fCleanHandle == TRUE && pExtendedHandle->UploadTaskHandle != NULL)
    {
        //
        // Close the XRL Upload task handle
        //
        XOnlineTaskClose(pExtendedHandle->UploadTaskHandle);
        pExtendedHandle->UploadTaskHandle = NULL;
    }

    //
    // If the task so far has been successful but not complete (ie.  XONLINETASK_S_SUCCESS), return S_RUNNING.
    // Otherwise, return an error or XONLINE_S_SUCCESS if it's complete and successful.
    //
    if (SUCCEEDED(hr) && hr != XONLINETASK_S_SUCCESS)
    {
        hr = XONLINETASK_S_RUNNING;
    }

    return hr;
}                


//---------------------------------------------------------------------------
//
// MatchClose()
//
// Public API (sort of)
//
// Close the matchmaking task handle.
//
VOID CXo::MatchClose(XONLINETASK_HANDLE hTask)
{
    HRESULT                 hr              = S_OK;
    PXMATCH_EXTENDED_HANDLE pExtendedHandle = (PXMATCH_EXTENDED_HANDLE)hTask;

    Assert(hTask != NULL);
    Assert(IsValidXMatchHandle(hTask));

#if DBG

    //
    // Reset global flag indicating a SessionCreate request is in progress.
    //
    if ( pExtendedHandle->Type == xmatchCreate )
    {
        m_fSessionCreateInProgress = FALSE;
    }

#endif

    //
    // If the XRL Upload handle is still open, close it.
    //
    if (pExtendedHandle->UploadTaskHandle != NULL)
    {
        XOnlineTaskClose(pExtendedHandle->UploadTaskHandle);
        pExtendedHandle->UploadTaskHandle = NULL;
    }

    //
    // Free all buffers that have been allocated
    //
    if (pExtendedHandle->pbBuffer != NULL)
    {
        SysFree(pExtendedHandle->pbBuffer);
    }

    if (pExtendedHandle->pbResultsBuffer != NULL)
    {
        SysFree(pExtendedHandle->pbResultsBuffer);
    }

    if (pExtendedHandle->rgpSearchResults != NULL)
    {
        SysFree(pExtendedHandle->rgpSearchResults);
    }

    //
    // Free the matchmaking task handle
    //
    SysFree(pExtendedHandle);
}


#if DBG

//---------------------------------------------------------------------------
//
// ValidateAttributeIDs
//
// Private API.
//
// Validate that attribute IDs are correct
//
BOOL CXo::ValidateAttributeIDs(
    IN DWORD dwNumAttributes,
    IN PXONLINE_ATTRIBUTE pAttributes,
    IN BOOL fSessionCreate
    )
{
    DWORD i = 0;

    //
    // Loop through all attributes and verify that the attribute ID is correct.
    //
    for (i = 0; i < dwNumAttributes; i += 1)
    {
        if (IsValidAttributeID(pAttributes[i].dwAttributeID, fSessionCreate) == FALSE)
        {
            return FALSE;
        }
    }

    return TRUE;
}


//---------------------------------------------------------------------------
//
// IsValidAttributeID()
//
// Private API
//
// Validate attribute ID.
//
BOOL CXo::IsValidAttributeID(DWORD dwAttributeID, BOOL fSessionCreate)
{
    if (fSessionCreate == TRUE)
    {
        //
        // bit 31     Global or Title Specific.
        // Can be zero or one for session create
        //

        //
        // bit 24-27  Used to be Attribute Type, but now must be 0001 for a session create
        //   0000 = user attribute
        //   0001 = game session attribute
        //   0010-1111 = reserved for future use
        //
        if ((dwAttributeID & X_ATTRIBUTE_RESERVED3_MASK) != X_ATTRIBUTE_TYPE_SESSION)
        {
            return FALSE;
        }

        //
        // bit 0-15  Attribute Index
        // Can be any value for session create
        //
    }
    else
    {
        //
        // bit 31     Global or Title Specific.
        // Must be zero for session search
        //
        if ((dwAttributeID & X_ATTRIBUTE_SCOPE_MASK) != 0)
        {
            return FALSE;
        }

        //
        // bit 24-27  Used to be Attribute Type, but now must be zero for a session search
        //   0000 = user attribute
        //   0001 = game session attribute
        //   0010-1111 = reserved for future use
        //
        if ((dwAttributeID & X_ATTRIBUTE_RESERVED3_MASK) != 0)
        {
            return FALSE;
        }

        //
        // bit 0-15  Attribute Index
        // Must be zero for session search
        //
        if ((dwAttributeID & X_ATTRIBUTE_ID_MASK) != 0)
        {
            return FALSE;
        }
    }

    //
    // bit 28-30  Reserved for future use, must be zero
    //
    if ((dwAttributeID & X_ATTRIBUTE_RESERVED1_MASK) != 0)
    {
        return FALSE;
    }

    //
    // bit 20-23  Attribute Data Type
    //   0000 = integer
    //   0001 = string
    //   0010 = binary blob
    //   0011-1111 = reserved for future use
    //
    if ((dwAttributeID & X_ATTRIBUTE_DATATYPE_MASK) > X_ATTRIBUTE_DATATYPE_BLOB)
    {
        return FALSE;
    }

    //
    // bit 16-19  Reserved for future use, must be zero
    //
    if ((dwAttributeID & X_ATTRIBUTE_RESERVED2_MASK) != 0)
    {
        return FALSE;
    }

    return TRUE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\md4ms.cpp ===
/*

    This second implementation of MD4 entry points is the newer style,
    optimized implementation, compatible with newer code expecting these
    entry point names.

    Modelled after MD5 and SHA-1.

    Scott Field (sfield)    21-Oct-97

*/


#include "xonp.h"
#include "xonver.h"
#include "md4.h"
#include "uint4.h"


#ifndef RSA32API 
#define RSA32API
#endif

/* Compile-time macro declarations for MD4.
*/

/* ROTATE_LEFT rotates x left n bits.
 */
#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))

void MD4Transform (UINT4 state[4], unsigned char block[64]);


#define S11 3
#define S12 7
#define S13 11
#define S14 19
#define S21 3
#define S22 5
#define S23 9
#define S24 13
#define S31 3
#define S32 9
#define S33 11
#define S34 15


static const unsigned char PADDING[64] = {
  0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};


/* F, G and H are basic MD4 functions.
 */

#define F(x, y, z) ((z) ^ ((x) & ((y) ^ (z))))
#define G(x, y, z) (((x) & (y)) | ((z) & ((x) | (y))))
#define H(x, y, z) ((x) ^ (y) ^ (z))


/* FF, GG and HH are MD4 transformations for rounds 1, 2 and 3 */
/* Rotation is separate from addition to prevent recomputation */
#define FF(a, b, c, d, x, s) \
  {(a) += F ((b), (c), (d)) + (x); \
   (a) = ROTATE_LEFT ((a), (s));}
#define GG(a, b, c, d, x, s) \
  {(a) += G ((b), (c), (d)) + (x) + (UINT4)013240474631; \
   (a) = ROTATE_LEFT ((a), (s));}
#define HH(a, b, c, d, x, s) \
  {(a) += H ((b), (c), (d)) + (x) + (UINT4)015666365641; \
   (a) = ROTATE_LEFT ((a), (s));}


#ifdef KMODE_RSA32
#pragma alloc_text(PAGER32C, MD4Init)
#pragma alloc_text(PAGER32C, MD4Update)
#pragma alloc_text(PAGER32C, MD4Transform)
#pragma alloc_text(PAGER32C, MD4Final)
#endif  // KMODE_RSA32

/* MD4 initialization. Begins an MD4 operation, writing a new context.
 */
void
RSA32API
MD4Init (
    MD4_CTX *context                                         /* context */
    )
{
    context->count[0] = 0;
    context->count[1] = 0;

    /* Load magic initialization constants.
     */

    context->state[0] = 0x67452301;
    context->state[1] = 0xefcdab89;
    context->state[2] = 0x98badcfe;
    context->state[3] = 0x10325476;
}

/* MD4 block update operation. Continues an MD4 message-digest
     operation, processing another message block, and updating the
     context.
 */

void
RSA32API
MD4Update (
    MD4_CTX *context,                                        /* context */
    unsigned char *input,                                /* input block */
    unsigned int inputLen                      /* length of input block */
    )
{

  unsigned int bufferLen;

  /* Compute number of bytes mod 64 */
  bufferLen = (unsigned int)((context->count[0] >> 3) & 0x3F);

  /* Update number of bits */
  if ((context->count[0] += ((DWORD)inputLen << 3)) < ((DWORD)inputLen << 3))
    context->count[1]++;

  context->count[1] += ((DWORD)inputLen >> 29);

  /* If previous input in buffer, buffer new input and transform if
       possible.
   */
  if (bufferLen > 0 && bufferLen + inputLen >= 64) {
    memcpy(context->buffer+bufferLen, input, 64-bufferLen);
    input += (64-bufferLen);
    inputLen -= (64-bufferLen);
    MD4Transform (context->state, context->buffer);
    bufferLen = 0;
  }

    if( (DWORD_PTR)input & (sizeof(DWORD_PTR) - 1) ) {
        /* Copy input to aligned temporary buffer
         */
        while (inputLen >= 64) {
            memcpy( context->buffer, input, 64 );
            MD4Transform (context->state, context->buffer);
            input += 64;
            inputLen -= 64;
        }
    } else {
        /* Transform directly from input.
         */
        while (inputLen >= 64) {
            MD4Transform (context->state, input);
            input += 64;
            inputLen -= 64;
        }
    }

  /* Buffer remaining input */
  if (inputLen)
    memcpy(context->buffer+bufferLen, input, inputLen);

}

/* MD4 finalization. Ends an MD4 message-digest operation, writing the
     message digest and zeroizing the context.
 */
void
RSA32API
MD4Final (
    MD4_CTX *context                                         /* context */
    )
{
    unsigned int index, padLen;

    /* Save number of bits */

#if !defined(BIGENDIAN) || !BIGENDIAN
    ((unsigned long *)context->digest)[0] = context->count[0];
    ((unsigned long *)context->digest)[1] = context->count[1];
#else
  DWORDToLittleEndian (context->digest, context->count, 8);
#endif

    /* Pad out to 56 mod 64. */

    index = (unsigned int)((context->count[0] >> 3) & 0x3f);
    padLen = (index < 56) ? (56 - index) : (120 - index);
    MD4Update (context, (unsigned char *)PADDING, padLen);

    /* Append length (before padding) */

    MD4Update (context, context->digest, 8);

    /* Store state in digest */

#if !defined(BIGENDIAN) || !BIGENDIAN
    ((unsigned long *)context->digest)[0] = context->state[0];
    ((unsigned long *)context->digest)[1] = context->state[1];
    ((unsigned long *)context->digest)[2] = context->state[2];
    ((unsigned long *)context->digest)[3] = context->state[3];
#else
  DWORDToLittleEndian (context->digest, context->state, 16);
#endif

}

/* MD4 basic transformation. Transforms state based on block.
 */

//#ifndef _X86_ // use optimized .asm version of MD4Transform on x86

void
MD4Transform (
    UINT4 state[4],
    unsigned char block[64]
    )
{
  UINT4 a = state[0], b = state[1], c = state[2], d = state[3];

#if !defined(BIGENDIAN) || !BIGENDIAN
  unsigned long *x = (unsigned long*)block;
#else
  unsigned long x[16];
  DWORDFromLittleEndian (x, (unsigned char *)block, 64);
#endif

  /* Round 1 */
  FF (a, b, c, d, x[ 0], S11); /* 1 */
  FF (d, a, b, c, x[ 1], S12); /* 2 */
  FF (c, d, a, b, x[ 2], S13); /* 3 */
  FF (b, c, d, a, x[ 3], S14); /* 4 */
  FF (a, b, c, d, x[ 4], S11); /* 5 */
  FF (d, a, b, c, x[ 5], S12); /* 6 */
  FF (c, d, a, b, x[ 6], S13); /* 7 */
  FF (b, c, d, a, x[ 7], S14); /* 8 */
  FF (a, b, c, d, x[ 8], S11); /* 9 */
  FF (d, a, b, c, x[ 9], S12); /* 10 */
  FF (c, d, a, b, x[10], S13); /* 11 */
  FF (b, c, d, a, x[11], S14); /* 12 */
  FF (a, b, c, d, x[12], S11); /* 13 */
  FF (d, a, b, c, x[13], S12); /* 14 */
  FF (c, d, a, b, x[14], S13); /* 15 */
  FF (b, c, d, a, x[15], S14); /* 16 */

  /* Round 2 */
  GG (a, b, c, d, x[ 0], S21); /* 17 */
  GG (d, a, b, c, x[ 4], S22); /* 18 */
  GG (c, d, a, b, x[ 8], S23); /* 19 */
  GG (b, c, d, a, x[12], S24); /* 20 */
  GG (a, b, c, d, x[ 1], S21); /* 21 */
  GG (d, a, b, c, x[ 5], S22); /* 22 */
  GG (c, d, a, b, x[ 9], S23); /* 23 */
  GG (b, c, d, a, x[13], S24); /* 24 */
  GG (a, b, c, d, x[ 2], S21); /* 25 */
  GG (d, a, b, c, x[ 6], S22); /* 26 */
  GG (c, d, a, b, x[10], S23); /* 27 */
  GG (b, c, d, a, x[14], S24); /* 28 */
  GG (a, b, c, d, x[ 3], S21); /* 29 */
  GG (d, a, b, c, x[ 7], S22); /* 30 */
  GG (c, d, a, b, x[11], S23); /* 31 */
  GG (b, c, d, a, x[15], S24); /* 32 */

  /* Round 3 */
  HH (a, b, c, d, x[ 0], S31); /* 33 */
  HH (d, a, b, c, x[ 8], S32); /* 34 */
  HH (c, d, a, b, x[ 4], S33); /* 35 */
  HH (b, c, d, a, x[12], S34); /* 36 */
  HH (a, b, c, d, x[ 2], S31); /* 37 */
  HH (d, a, b, c, x[10], S32); /* 38 */
  HH (c, d, a, b, x[ 6], S33); /* 39 */
  HH (b, c, d, a, x[14], S34); /* 40 */
  HH (a, b, c, d, x[ 1], S31); /* 41 */
  HH (d, a, b, c, x[ 9], S32); /* 42 */
  HH (c, d, a, b, x[ 5], S33); /* 43 */
  HH (b, c, d, a, x[13], S34); /* 44 */
  HH (a, b, c, d, x[ 3], S31); /* 45 */
  HH (d, a, b, c, x[11], S32); /* 46 */
  HH (c, d, a, b, x[ 7], S33); /* 47 */
  HH (b, c, d, a, x[15], S34); /* 48 */

  state[0] += a;
  state[1] += b;
  state[2] += c;
  state[3] += d;
}


//+-------------------------------------------------------------------------

BOOL
KerbPasswordToKey(
    IN LPSTR pszPassword,
    OUT PUCHAR Key
    )
{
    BOOL fSucceed = FALSE;
    MD4_CTX md4Ctx;
    UNICODE_STRING Password;
    DWORD dwPasswordLen;
    DWORD dwResult;
    WCHAR* pwcUnicodePassword;

    dwPasswordLen = strlen(pszPassword);

    pwcUnicodePassword = (WCHAR*)_alloca( (dwPasswordLen + 1) * sizeof(WCHAR) );
    if (pwcUnicodePassword == NULL)
    {
        goto Cleanup;
    }
    
    dwResult = MultiByteToWideChar(
         CP_ACP,
         MB_PRECOMPOSED,
         pszPassword,
         dwPasswordLen,
         pwcUnicodePassword,
         dwPasswordLen * sizeof(WCHAR)
         );

    if (dwResult == 0) {
        goto Cleanup;
    }
    
    MD4Init( &md4Ctx );
    MD4Update( &md4Ctx, (unsigned char *)pwcUnicodePassword, dwPasswordLen * sizeof(WCHAR) );
    MD4Final( &md4Ctx );

    RtlCopyMemory( Key, md4Ctx.digest, MD4_LEN );
    
    fSucceed = TRUE;

Cleanup:
    if (!fSucceed)
    {
        TraceSz( Warning, "KerbPasswordToKey failed" );
    }
    return(fSucceed);
}

//#endif // !_X86_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\msasn1.cpp ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "xonp.h"
#include "xonver.h"

#include <stdlib.h>
#include <stdio.h>

#ifdef ENABLE_DOUBLE
#include <float.h>
#include <math.h>

#if HAS_IEEEFP_H
#include <ieeefp.h>
#elif HAS_FLOAT_H
#include <float.h>
#endif
#endif

#define ASN1LIB
#define MULTI_LEVEL_ZONES

#define ENABLE_BER
#define ENABLE_COMPARE
#define XBOX_SPECIFIC_OPTIMIZATIONS

#include "msasn1.h"

//#include <msper.h>
extern ASN1_PUBLIC void ASN1API ASN1PEREncAlignment(ASN1encoding_t enc);

/* MS-Windows 95/MS-Windows NT */
#define THIRTYTWO_BITS  1
// #define HAS_SIXTYFOUR_BITS 1
#define HAS_FLOAT_H     1
#define HAS_FPCLASS     1
#define fpclass(_d)     _fpclass(_d)
#define finite(_d)      _finite(_d)
#define isnan(_d)       _isnan(_d)
#define FP_PINF         _FPCLASS_PINF
#define FP_NINF         _FPCLASS_NINF
// #define HAS_STRICMP     1
#define DBL_PINF        {0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0x7f}
#define DBL_MINF        {0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0xff}

extern ASN1intx_t ASN1intx_0, ASN1intx_1, ASN1intx_2, ASN1intx_16, ASN1intx_256, ASN1intx_64K, ASN1intx_1G;
extern void ASN1API ASN1intx_addoctet(ASN1intx_t *, ASN1intx_t *, ASN1octet_t);
extern void ASN1API ASN1intx_suboctet(ASN1intx_t *, ASN1intx_t *, ASN1octet_t);
extern void ASN1API ASN1intx_muloctet(ASN1intx_t *, ASN1intx_t *, ASN1octet_t);
extern void ASN1API ASN1intx_inc(ASN1intx_t *);
extern void ASN1API ASN1intx_dec(ASN1intx_t *);
extern void ASN1API ASN1intx_neg(ASN1intx_t *, ASN1intx_t *);
extern ASN1uint32_t ASN1API ASN1intx_log2(ASN1intx_t *);
extern ASN1uint32_t ASN1API ASN1intx_log256(ASN1intx_t *);
extern ASN1int32_t ASN1API ASN1intx_cmp(ASN1intx_t *, ASN1intx_t *);
extern ASN1int32_t ASN1API ASN1intx_dup(ASN1intx_t *, ASN1intx_t *);
// extern void ASN1API ASN1intx_free(ASN1intx_t *);
extern void ASN1API ASN1intx_setuint32(ASN1intx_t *, ASN1uint32_t);
extern void ASN1API ASN1intx_setint32(ASN1intx_t *, ASN1int32_t);
extern int  ASN1API ASN1intxisuint64(ASN1intx_t *);
extern int  ASN1API ASN1intxisint64(ASN1intx_t *);
extern int  ASN1API ASN1intxisuint32(ASN1intx_t *);
extern int  ASN1API ASN1intxisint32(ASN1intx_t *);
extern int  ASN1API ASN1intxisuint16(ASN1intx_t *);
extern int  ASN1API ASN1intxisint16(ASN1intx_t *);
extern int  ASN1API ASN1intxisuint8(ASN1intx_t *);
extern int  ASN1API ASN1intxisint8(ASN1intx_t *);
#ifdef HAS_SIXTYFOUR_BITS
extern ASN1uint64_t ASN1API ASN1intx2uint64(ASN1intx_t *);
extern ASN1int64_t ASN1API ASN1intx2int64(ASN1intx_t *);
#endif
extern ASN1uint32_t ASN1API ASN1intx2uint32(ASN1intx_t *);
extern ASN1int32_t ASN1API ASN1intx2int32(ASN1intx_t *);
extern ASN1uint16_t ASN1API ASN1intx2uint16(ASN1intx_t *);
extern ASN1int16_t ASN1API ASN1intx2int16(ASN1intx_t *);
extern ASN1uint8_t ASN1API ASN1intx2uint8(ASN1intx_t *);
extern ASN1int8_t ASN1API ASN1intx2int8(ASN1intx_t *);
extern ASN1uint32_t ASN1API ASN1intx_octets(ASN1intx_t *);
extern ASN1uint32_t ASN1API ASN1uint32_log2(ASN1uint32_t);
extern ASN1uint32_t ASN1API ASN1uint32_log256(ASN1uint32_t);
extern ASN1uint32_t ASN1API ASN1uint32_octets(ASN1uint32_t);
extern ASN1uint32_t ASN1API ASN1uint32_uoctets(ASN1uint32_t);
extern ASN1uint32_t ASN1API ASN1int32_octets(ASN1int32_t);
extern double ASN1API ASN1intx2double(ASN1intx_t *);
extern double ASN1API ASN1real2double(ASN1real_t *);
extern double ASN1API ASN1double_minf();
extern double ASN1API ASN1double_pinf();
extern int ASN1API ASN1double_isminf(double);
extern int ASN1API ASN1double_ispinf(double);
extern int ASN1API ASN1generalizedtime2string(char *, ASN1generalizedtime_t *);
extern int ASN1API ASN1utctime2string(char *, ASN1utctime_t *);
extern int ASN1API ASN1string2generalizedtime(ASN1generalizedtime_t *, char *);
extern int ASN1API ASN1string2utctime(ASN1utctime_t *, char *);

/* ------ Comparison APIs ------ */

extern int ASN1API ASN1ztchar32string_cmp(ASN1ztchar32string_t, ASN1ztchar32string_t);
extern int ASN1API ASN1double_cmp(double, double);
extern int ASN1API ASN1real_cmp(ASN1real_t *, ASN1real_t *);
extern int ASN1API ASN1external_cmp(ASN1external_t *, ASN1external_t *);
extern int ASN1API ASN1embeddedpdv_cmp(ASN1embeddedpdv_t *, ASN1embeddedpdv_t *);
extern int ASN1API ASN1characterstring_cmp(ASN1characterstring_t *, ASN1characterstring_t *);
extern int ASN1API ASN1sequenceoflengthpointer_cmp(ASN1uint32_t, void *, ASN1uint32_t, void *, ASN1uint32_t, int (*)(void *, void *));
extern int ASN1API ASN1sequenceofsinglylinkedlist_cmp(void *, void *, ASN1uint32_t, int (*)(void *, void *));
extern int ASN1API ASN1sequenceofdoublylinkedlist_cmp(void *, void *, ASN1uint32_t, int (*)(void *, void *));
extern int ASN1API ASN1setoflengthpointer_cmp(ASN1uint32_t, void *, ASN1uint32_t, void *, ASN1uint32_t, int (*)(void *, void *));
extern int ASN1API ASN1setofsinglylinkedlist_cmp(void *, void *, ASN1uint32_t, int (*)(void *, void *));
extern int ASN1API ASN1setofdoublylinkedlist_cmp(void *, void *, ASN1uint32_t, int (*)(void *, void *));


#define ASN1BITSET(_val, _bitnr) \
    ((_val)[(_bitnr) >> 3] |= 0x80 >> ((_bitnr) & 7))
#define ASN1BITCLR(_val, _bitnr) \
    ((_val)[(_bitnr) >> 3] &= ~(0x80 >> ((_bitnr) & 7)))
#define ASN1BITTEST(_val, _bitnr) \
    ((_val)[(_bitnr) >> 3] & (0x80 >> ((_bitnr) & 7)))
    
// internal functions
int _BERDecConstructed(ASN1decoding_t dec, ASN1uint32_t len, ASN1uint32_t infinite, ASN1decoding_t *dd, ASN1octet_t **di);


#if ! defined(_DEBUG) && defined(TEST_CODER)
#undef TEST_CODER
#endif

typedef struct ASN1INTERNencoding_s *ASN1INTERNencoding_t;
typedef struct ASN1INTERNdecoding_s *ASN1INTERNdecoding_t;

// lonchanc: this is really bad to duplicate the definitions of ASN1encoding_s
// and ASN1decoding_s here. We sould simply use them as components in
// the following ASN1INTERNencoding_s and ASN1INTERNdecoding_s.

struct ASN1INTERNencoding_s {

    // public view of encoding structure
    struct ASN1encoding_s       info;

    // private portion of encoding structure
    ASN1INTERNencoding_t        parent;
    ASN1INTERNencoding_t        child;

#ifdef ENABLE_EXTRA_INFO
    ASN1uint32_t				memlength;
    ASN1uint32_t				memsize;
    void**					    mem;
    ASN1uint32_t				epilength;
    ASN1uint32_t				episize;
    ASN1embeddedpdv_identification_t**		epi;
    ASN1uint32_t				csilength;
    ASN1uint32_t				csisize;
    ASN1characterstring_identification_t**	csi;
#endif // ENABLE_EXTRA_INFO
};

struct ASN1INTERNdecoding_s {

    // public view of decoding structure
    struct ASN1decoding_s       info;

    // private portion of decoding structure
    ASN1INTERNdecoding_t        parent;
    ASN1INTERNdecoding_t        child;

#ifdef ENABLE_EXTRA_INFO
    ASN1uint32_t				memlength;
    ASN1uint32_t				memsize;
    void**					    mem;
    ASN1uint32_t				epilength;
    ASN1uint32_t				episize;
    ASN1embeddedpdv_identification_t**		epi;
    ASN1uint32_t				csilength;
    ASN1uint32_t				csisize;
    ASN1characterstring_identification_t**	csi;
#endif // ENABLE_EXTRA_INFO

    // decoded into an external buffer
    ASN1uint32_t                fExtBuf;
    void*                       lpOrigExtBuf;    // original buffer pointer
    ASN1uint32_t                cbOrigExtBufSize;// original buffer size
    ASN1uint8_t*                lpRemExtBuf;     // remaining buffer pointer
    ASN1uint32_t                cbRemExtBufSize; // remaining buffer size
    ASN1uint32_t                cbLinearBufSize; // linear buffer size to hold the data
};

extern ASN1_PUBLIC void ASN1API ASN1DecAbort(ASN1decoding_t dec);
extern ASN1_PUBLIC void ASN1API ASN1DecDone(ASN1decoding_t dec);
extern ASN1_PUBLIC void ASN1API ASN1EncAbort(ASN1encoding_t enc);
extern ASN1_PUBLIC void ASN1API ASN1EncDone(ASN1encoding_t enc);

#ifdef ENABLE_GENERALIZED_CHAR_STR
int ASN1EncSearchCharacterStringIdentification(ASN1INTERNencoding_t e, ASN1characterstring_identification_t *identification, ASN1uint32_t *index, ASN1uint32_t *flag);
int ASN1DecAddCharacterStringIdentification(ASN1INTERNdecoding_t d, ASN1characterstring_identification_t *identification);
ASN1characterstring_identification_t *ASN1DecGetCharacterStringIdentification(ASN1INTERNdecoding_t d, ASN1uint32_t index);
#endif // ENABLE_GENERALIZED_CHAR_STR

#ifdef ENABLE_EMBEDDED_PDV
int ASN1EncSearchEmbeddedPdvIdentification(ASN1INTERNencoding_t e, ASN1embeddedpdv_identification_t *identification, ASN1uint32_t *index, ASN1uint32_t *flag);
int ASN1DecAddEmbeddedPdvIdentification(ASN1INTERNdecoding_t d, ASN1embeddedpdv_identification_t *identification);
ASN1embeddedpdv_identification_t *ASN1DecGetEmbeddedPdvIdentification(ASN1INTERNdecoding_t d, ASN1uint32_t index);
#endif // ENABLE_EMBEDDED_PDV

int ASN1DecDupObjectIdentifier(ASN1decoding_t dec, ASN1objectidentifier_t *dst, ASN1objectidentifier_t *src);

ASN1uint32_t GetObjectIdentifierCount(ASN1objectidentifier_t val);
ASN1uint32_t CopyObjectIdentifier(ASN1objectidentifier_t dst, ASN1objectidentifier_t src);
ASN1objectidentifier_t DecAllocObjectIdentifier(ASN1decoding_t dec, ASN1uint32_t cObjIds);
void DecFreeObjectIdentifier(ASN1decoding_t dec, ASN1objectidentifier_t p);


/* ------ perencod.c ------ */

int ASN1EncCheck(ASN1encoding_t enc, ASN1uint32_t noctets);
__inline int ASN1PEREncCheck(ASN1encoding_t enc, ASN1uint32_t noctets)
{
    return ASN1EncCheck(enc, noctets);
}
__inline int ASN1BEREncCheck(ASN1encoding_t enc, ASN1uint32_t noctets)
{
    return ASN1EncCheck(enc, noctets);
}

/* ------ bit.c ------ */

int ASN1is32space(ASN1char32_t);
int ASN1str32len(ASN1char32_t *);
int ASN1is16space(ASN1char16_t);
int ASN1str16len(ASN1char16_t *);
int My_lstrlenA(char *p);
int My_lstrlenW(WCHAR *p);
void ASN1bitcpy(ASN1octet_t *dst, ASN1uint32_t dstbit, ASN1octet_t *src, ASN1uint32_t srcbit, ASN1uint32_t nbits);
void ASN1bitclr(ASN1octet_t *dst, ASN1uint32_t dstbit, ASN1uint32_t nbits);
void ASN1bitset(ASN1octet_t *dst, ASN1uint32_t dstbit, ASN1uint32_t nbits);
void ASN1bitput(ASN1octet_t *dst, ASN1uint32_t dstbit, ASN1uint32_t val, ASN1uint32_t nbits);
ASN1uint32_t ASN1bitgetu(ASN1octet_t *src, ASN1uint32_t srcbit, ASN1uint32_t nbits);
ASN1int32_t ASN1bitget(ASN1octet_t *src, ASN1uint32_t srcbit, ASN1uint32_t nbits);
ASN1uint32_t ASN1bitcount(ASN1octet_t *src, ASN1uint32_t srcbit, ASN1uint32_t nbits);
void ASN1octetput(ASN1octet_t *dst, ASN1uint32_t val, ASN1uint32_t noctets);
ASN1uint32_t ASN1octetget(ASN1octet_t *src, ASN1uint32_t noctets);

#define ARRAY_SIZE(arr)             (sizeof(arr) / sizeof(arr[0]))
// #define FIELD_OFFSET(type, field)   ((long)&(((type *)0)->field))   // from winnt.h
#define PARAMS_SIZE_N_ARRARY(arr)   ARRAY_SIZE(arr), arr

#define LPVOID_ADD(ptr,inc)  (LPVOID) ((ASN1octet_t *) (ptr) + (ASN1uint32_t) (inc))
#define LPVOID_SUB(ptr,dec)  (LPVOID) ((ASN1octet_t *) (ptr) - (ASN1uint32_t) (inc))

#define LPVOID_NEXT(ptr)     *(LPVOID FAR *) (ptr)

// the following constants is for calculating decoded data structure size
// we are conservative here and try to be 4-byte aligned due to Alpha platform.

#define ASN1_SIZE_ALIGNED(n)    (n) = ((((n) + 3) >> 2) << 2)

#ifdef ENABLE_BER
int My_memcmp(ASN1octet_t *pBuf1, ASN1uint32_t cbBuf1Size, ASN1octet_t *pBuf2, ASN1uint32_t cbBuf2Size);
#endif // ENABLE_BER

#define UNKNOWN_MODULE                  0

#define MemAllocEx(dec,cb,fZero)        (dec)->pScratchMemoryAllocator->Alloc((cb))
#define MemFree(lp)
#define MemReAllocEx(dec,lp,cb,fZero)   ((lp) ? \
            (dec)->pScratchMemoryAllocator->ReAlloc((lp),(cb)) : \
            (dec)->pScratchMemoryAllocator->Alloc((cb)))

#define _ModName(enc_dec)                   

LPVOID DecMemAlloc   ( ASN1decoding_t dec, ASN1uint32_t cbSize );
LPVOID DecMemReAlloc ( ASN1decoding_t dec, LPVOID lpData, ASN1uint32_t cbSize );

#define EncMemAlloc(enc,cb)             (enc)->pScratchMemoryAllocator->Alloc((cb))
#define EncMemReAlloc(enc,lp,cb)        (enc)->pScratchMemoryAllocator->ReAlloc((lp),(cb))
#define EncMemImmediateReAlloc(dec,lp,ocb,cb)   (dec)->pScratchMemoryAllocator->ImmediateReAlloc((lp),(ocb),(cb))

void   DecMemFree    ( ASN1decoding_t dec, LPVOID lpData );

#define EncMemFree(enc,lpData)              MemFree(lpData)

int IsDigit(char p);
unsigned int  DecimalStringToUINT(char * pcszString, ASN1uint32_t cch);
void * ms_bSearch (
        const void *key,
        const void *base,
        size_t num,
        size_t width,
        int (__cdecl *compare)(const void *, const void *)
        );

#define MyAssert(f)         
#ifdef _DEBUG
    void MyDebugBreak(void);
    __inline void EncAssert(ASN1encoding_t enc, int val)
    {
        if ((! (enc->dwFlags & ASN1FLAGS_NOASSERT)) && (! (val)))
        {
            MyDebugBreak();
        }
    }
    __inline void DecAssert(ASN1decoding_t dec, int val)
    {
        if ((! (dec->dwFlags & ASN1FLAGS_NOASSERT)) && (! (val)))
        {
            MyDebugBreak();
        }
    }
#else
    #define EncAssert(enc,f)   
    #define DecAssert(dec,f)   
#endif // _DEBUG

// making a magic number
#define MAKE_STAMP_ID(a,b,c,d)     MAKELONG(MAKEWORD(a,b),MAKEWORD(c,d))

/* magic number for ASN1encoding_t */
#define MAGIC_ENCODER       MAKE_STAMP_ID('E','N','C','D')

/* magic number for ASN1decoding_t */
#define MAGIC_DECODER       MAKE_STAMP_ID('D','E','C','D')


#ifdef TEST_CODER
typedef struct ASN1testcoder_s
{
    struct ASN1INTERNencoding_s     e;
    struct ASN1INTERNdecoding_s     d;
}   *ASN1testcoder_t;
#define ASN1_TEST_CODER_SIZE    (sizeof(struct ASN1testcoder_s))
int TestEnc_InitCoder(ASN1INTERNencoding_t e, ASN1module_t mod);
int TestDec_InitCoder(ASN1INTERNdecoding_t d, ASN1module_t mod);
int TestEnc_Compare(ASN1INTERNencoding_t e, ASN1uint32_t id, ASN1octet_t *pbBuf, ASN1uint32_t cbBufSize);
int TestDec_Compare(ASN1INTERNdecoding_t d, ASN1uint32_t id, void *valref, ASN1octet_t *pbBuf, ASN1uint32_t cbBufSize);
#else
#define ASN1_TEST_CODER_SIZE    0
#endif

#define ENCODE_BUFFER_INCREMENT         128
#define ENCODE_BUFFER_MAX_INCREMENT     256

static const ASN1uint8_t c_aBitMask2[] =
{
    0x00, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0xff
};
// moved from perdecod.c
/* check if sufficient data is in decoding buffer */
int ASN1PERDecCheck(ASN1decoding_t dec, ASN1uint32_t nbits)
{
    if ((dec->pos - dec->buf) * 8 + dec->bit + nbits <= dec->size * 8)
    {
        return 1;
    }
    ASN1DecSetError(dec, ASN1_ERR_EOD);
    return 0;
}
/* skip up to octet boundary */
void ASN1PERDecAlignment(ASN1decoding_t dec)
{
    if (dec->bit)
    {
        dec->bit = 0;
        dec->pos++;
    }
}

// moved from perdecod.c
/* end of decoding */
int ASN1PERDecFlush(ASN1decoding_t dec)
{
    /* complete broken byte */
    ASN1PERDecAlignment(dec);

    /* get zero-octet if encoding is empty bitstring */
    if (dec->buf == dec->pos)
    {
        if (ASN1PERDecCheck(dec, 8))
        {
            if (*dec->pos == 0)
            {
                dec->pos++;
            }
            else
            {
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }

    /* calculate length */
    dec->len = (ASN1uint32_t) (dec->pos - dec->buf);

    /* set WRN_NOEOD if data left */
    if (dec->len >= dec->size)
    {
        return 1;
    }
    ASN1DecSetError(dec, ASN1_WRN_NOEOD);
    return 1;
}
// moved from perencod.c
/* end of encoding */
int ASN1PEREncFlush(ASN1encoding_t enc)
{
    /* complete broken octet */
    ASN1PEREncAlignment(enc);

    /* allocate at least one octet */
    if (enc->buf)
    {
        /* fill in zero-octet if encoding is empty bitstring */
        if (enc->buf == enc->pos)
            *enc->pos++ = 0;

        /* calculate length */
        enc->len = (ASN1uint32_t) (enc->pos - enc->buf);

        return 1;
    }

    return ASN1PEREncCheck(enc, 1);
}

// moved from perencod.c
/* encode an octet alignment */
void ASN1PEREncAlignment(ASN1encoding_t enc)
{
    /* complete broken octet */
    if (enc->bit)
    {
        enc->pos++;
        enc->bit = 0;
    }
}

// moved from perencod.c
/* check for space in buffer for PER and BER. */
int ASN1EncCheck(ASN1encoding_t enc, ASN1uint32_t noctets)
{
    // any additional space required?
    if (noctets)
    {
        // buffer exists?
        if (NULL != enc->buf)
        {
            // buffer large enough?
            if (enc->size - (enc->pos - enc->buf) - ((enc->bit != 0) ? 1 : 0) >= noctets)
            {
                return 1;
            }

            // static buffer overflow?
            if (enc->dwFlags & ASN1ENCODE_SETBUFFER)
            {
                ASN1EncSetError(enc, ASN1_ERR_OVERFLOW);
                return 0;
            }
            else
            {
                // round up to next 256 byte boundary and resize buffer
                ASN1octet_t *oldbuf = enc->buf;
                ASN1uint32_t oldsize = enc->size;
                // enc->size = ((noctets + (enc->pos - oldbuf) + (enc->bit != 0) - 1) | 255) + 1;
                if (ASN1_PER_RULE & enc->eRule)
                {
                    enc->size += max(noctets, ENCODE_BUFFER_INCREMENT);
                }
                else
                {
                    //enc->size += max(noctets, enc->size);
                    enc->size += min(max(noctets, enc->size), ENCODE_BUFFER_MAX_INCREMENT);
                }
                enc->buf = (ASN1octet_t *)EncMemImmediateReAlloc(enc, enc->buf, oldsize, enc->size);
                if (NULL != enc->buf)
                {
                    enc->pos = enc->buf + (enc->pos - oldbuf);
                }
                else
                {
                    ASN1EncSetError(enc, ASN1_ERR_MEMORY);
                    return 0;
                }
            }
        }
        else
        {
            // no buffer exists, allocate new one.
            // round up to next 256 byte boundary and allocate buffer
            // enc->size = ((noctets - 1) | 255) + 1;
            enc->size = max(noctets + enc->cbExtraHeader, ENCODE_BUFFER_INCREMENT);
            enc->buf = (ASN1octet_t*) EncMemAlloc(enc, enc->size);
            if (NULL != enc->buf)
            {
                enc->pos = (ASN1octet_t *) (enc->buf + enc->cbExtraHeader);
            }
            else
            {
                enc->pos = NULL;
                ASN1EncSetError(enc, ASN1_ERR_MEMORY);
                return 0;
            }
        }
    }

    return 1;
}

// moved from perfn.c
int ASN1PEREncRemoveZeroBits(ASN1uint32_t *nbits, ASN1octet_t *val, ASN1uint32_t minlen)
{
    ASN1uint32_t n;
    int i;

    /* get value */
    n = *nbits;

    /* nothing to scan? */
    if (n > minlen)
    {
        /* let val point to last ASN1octet used */
        val += (n - 1) / 8;

        /* check if broken ASN1octet consist out of zero bits */
        if ((n & 7) && !(*val & c_aBitMask2[n & 7])) {
            n &= ~7;
            val--;
        }

        /* scan complete ASN1octets (memrchr missing ...) */
        if (!(n & 7)) {
            while (n > minlen && !*val) {
                n -= 8;
                val--;
            }
        }

        /* scan current octet bit after bit */
        if (n > minlen) {
            for (i = (n - 1) & 7; i >= 0; i--) {
                if (*val & (0x80 >> i))
                    break;
                n--;
            }
        }

        /* return real bitstring len */
        *nbits = n < minlen ? minlen : n;
    }
    return 1;
}

/* init an ASN1encoding_t */
ASN1error_e ASN1_CreateEncoder
(
    CScratchMemoryAllocator* pScratchMemoryAllocator,
    ASN1module_t        mod,
    ASN1encoding_t     *enc,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize,
    ASN1encoding_t      pParent
)
{
    if (NULL != mod && NULL != enc)
    {
        ASN1INTERNencoding_t    e;

        *enc = NULL;

        /* construct ASN1encoding_t */
        e = (ASN1INTERNencoding_t)pScratchMemoryAllocator->Alloc(sizeof(*e) + ASN1_TEST_CODER_SIZE);
        if (NULL != e)
        {
            RtlZeroMemory(e, sizeof(*e) + ASN1_TEST_CODER_SIZE);
            e->info.pScratchMemoryAllocator = pScratchMemoryAllocator;
            e->info.magic = MAGIC_ENCODER;
            e->info.err = ASN1_SUCCESS;
            // e->info.pos = e->info.buf = NULL;
            // e->info.size = e->info.len = e->info.bit = 0;
            e->info.dwFlags = mod->dwFlags;
            e->info.module = mod;
            // e->child = NULL;

            /* set buffer if given */
            if (NULL != pbBuf && cbBufSize)
            {
                e->info.dwFlags |= ASN1ENCODE_SETBUFFER;
                e->info.pos = e->info.buf = pbBuf;
                e->info.size = cbBufSize;
            }

            /* set parent if parented, otherwise, initialized to itself */
            if (NULL != pParent)
            {
                e->parent = (ASN1INTERNencoding_t) pParent;
                e->info.eRule = pParent->eRule;
            }
            else
            {
                e->parent = e;
                e->info.eRule = mod->eRule;
            }

            // e->mem = NULL;
            // e->memlength = 0;
            // e->memsize = 0;
            // e->epi = NULL;
            // e->epilength = 0;
            // e->episize = 0;
            // e->csi = NULL;
            // e->csilength = 0;
            // e->csisize = 0;

            if (! (e->info.dwFlags & ASN1ENCODE_SETBUFFER) && (NULL != pParent))
            {
                // lonchanc: make sure we have a minimum 256 bytes available.
                BOOL fRet = FALSE;
                if (ASN1_PER_RULE & e->info.eRule)
                {
                    // this is required for h245.
                    fRet = ASN1PEREncCheck((ASN1encoding_t) e, 1);
                }
#ifdef ENABLE_BER
                else
                if (ASN1_BER_RULE & e->info.eRule)
                {
                    // this is required for h245.
                    fRet = ASN1BEREncCheck((ASN1encoding_t) e, 1);
                }
#endif // ENABLE_BER
                else
                {
                    EncAssert((ASN1encoding_t) e, 0);
                    MemFree(e);
                    return ASN1_ERR_RULE;
                }
                if (fRet)
                {
                    // lonchanc: make sure the first byte is zeroed out, which
                    // is required for h245.
                    e->info.buf[0] = '\0';
                }
                else
                {
                    MemFree(e);
                    return ASN1_ERR_MEMORY;
                }
            }

#if defined(TEST_CODER) && defined(_DEBUG)
            TestEnc_InitCoder(e, mod);
#endif // defined(TEST_CODER) && defined(_DEBUG)

            if (NULL != pParent)
            {
                EncAssert((ASN1encoding_t) e, NULL == ((ASN1INTERNencoding_t) pParent)->child);
                ((ASN1INTERNencoding_t) pParent)->child = e;
            }

            *enc = (ASN1encoding_t) e;
            return ASN1_SUCCESS;
        }
        else
        {
            return ASN1_ERR_MEMORY;
        }
    }

    return ASN1_ERR_BADARGS;
}

/* encode a value */
ASN1error_e ASN1_Encode
(
    ASN1encoding_t      enc,
    void               *value,
    ASN1uint32_t        id,
    ASN1uint32_t        flags,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize
)
{
    if (NULL != enc)
    {
        ASN1INTERNencoding_t    e = (ASN1INTERNencoding_t)enc;

        /* check magic numbers */
        EncAssert(enc, MAGIC_ENCODER == enc->magic);

        /* clear error */
        ASN1EncSetError(enc, ASN1_SUCCESS);

        /* new buffer given? */
        if (flags & ASN1ENCODE_SETBUFFER)
        {
            e->info.dwFlags |= ASN1ENCODE_SETBUFFER;
            enc->pos = enc->buf = pbBuf;
            enc->size = cbBufSize;
            enc->len = enc->bit = 0;
        }
        /* use a new buffer? */
        else if ((e->info.dwFlags | flags) & ASN1ENCODE_ALLOCATEBUFFER)
        {
            e->info.dwFlags &= ~ASN1ENCODE_SETBUFFER;
            enc->pos = enc->buf = NULL;
            enc->size = enc->len = enc->bit = 0;
        }
        /* reuse buffer? */
        else if ((flags & ASN1ENCODE_REUSEBUFFER) || !((e->info.dwFlags | flags) & ASN1ENCODE_APPEND))
        {
            EncAssert(enc, NULL != enc->buf);
            enc->pos = enc->buf;
            enc->bit = enc->len = 0;
        }
        /* otherwise append to buffer */

        /* check id number */
        if (id < enc->module->cPDUs)
        {
            if (ASN1_PER_RULE & enc->eRule)
            {
                /* encode value */
                ASN1PerEncFun_t pfnPER;
                if (NULL != (pfnPER = enc->module->PER.apfnEncoder[id]))
                {
                    if ((*pfnPER)(enc, value))
                    {
                        ASN1PEREncFlush(enc);
                    }
                    else
                    {
                        // the error code must be an error
                        if (ASN1_SUCCEEDED(e->parent->info.err))
                        {
                            // cannot return here immediately because we need to do cleanup
                            ASN1EncSetError(enc, ASN1_ERR_CORRUPT);
                        }
                    }
                }
                else
                {
                    return ASN1EncSetError(enc, ASN1_ERR_BADPDU);
                }
            }
#ifdef ENABLE_BER
            else
            if (ASN1_BER_RULE & enc->eRule)
            {
                /* encode value */
                ASN1BerEncFun_t pfnBER;
                if (NULL != (pfnBER = enc->module->BER.apfnEncoder[id]))
                {
                    if ((*pfnBER)(enc, 0, value)) // lonchanc: tag is 0 to make it compiled
                    {
                        ASN1BEREncFlush(enc);
                    }
                    else
                    {
                        // the error code must be an error
                        if (ASN1_SUCCEEDED(e->parent->info.err))
                        {
                            // cannot return here immediately because we need to do cleanup
                            ASN1EncSetError(enc, ASN1_ERR_CORRUPT);
                        }
                    }
                }
                else
                {
                    return ASN1EncSetError(enc, ASN1_ERR_BADPDU);
                }
            }
#endif // ENABLE_BER
            else
            {
                return ASN1EncSetError(enc, ASN1_ERR_RULE);
            }

            /* call abort/done function for non-parented encoding stream */
            if (ASN1_SUCCEEDED(e->parent->info.err))
            {
                // not parented
                if (e == e->parent)
                {
#if defined(TEST_CODER) && defined(_DEBUG)
                    if (ASN1_PER_RULE & enc->eRule)
                    {
                        if (! TestEnc_Compare(e, id, enc->buf + enc->cbExtraHeader, enc->len - enc->cbExtraHeader))
                        {
                            MyDebugBreak();
                        }
                    }
#ifdef ENABLE_BER
                    else
                    if (ASN1_BER_RULE & enc->eRule)
                    {
                        if (! TestEnc_Compare(e, id, enc->buf + enc->cbExtraHeader, enc->len - enc->cbExtraHeader))
                        {
                            MyDebugBreak();
                        }
                    }
#endif // ENABLE_BER
#endif
                    ASN1EncDone(enc);
                }
            }
            else
            {
                ASN1INTERNencoding_t child, child2;

                // not parented
                if (e == e->parent)
                {
                    ASN1EncAbort(enc);
                }

                // clean up...
                if ((e->info.dwFlags | flags) & ASN1ENCODE_ALLOCATEBUFFER)
                {
                    ASN1_FreeEncoded(enc, enc->buf);
                    enc->pos = enc->buf = NULL;
                    enc->size = enc->len = enc->bit = 0;
                }
                for (child = e->child; child; child = child2)
                {
                    child2 = child->child;
                    // make sure it does not touch its parent which may already be freed
                    child->parent = child;
                    ASN1_CloseEncoder2((ASN1encoding_t) child);
                }
                e->child = NULL;
            }

            /* return error code */
            return e->parent->info.err;
        }
        else
        {
            return ASN1EncSetError(enc, ASN1_ERR_BADPDU);
        }
    }

    return ASN1_ERR_BADARGS;
}

/* control function for encoding */
ASN1error_e ASN1_SetEncoderOption
(
    ASN1encoding_t      enc,
    ASN1optionparam_t  *pOptParam
)
{
    if (NULL != enc && NULL != pOptParam)
    {
        ASN1INTERNencoding_t e = (ASN1INTERNencoding_t)enc;
        ASN1error_e rc = ASN1_SUCCESS;

        /* check magic number */
        EncAssert(enc, MAGIC_ENCODER == enc->magic);

        switch (pOptParam->eOption)
        {
        case ASN1OPT_CHANGE_RULE:
            enc->eRule = pOptParam->eRule;
            break;

        case ASN1OPT_NOT_REUSE_BUFFER:
            e->info.dwFlags &= ~ASN1ENCODE_SETBUFFER;
            enc->buf = enc->pos = NULL;
            enc->size = enc->bit = enc->len = 0;
            break;

        case ASN1OPT_REWIND_BUFFER:
            enc->pos = enc->buf;
            enc->bit = enc->len = 0;
            break;

        default:
            rc = ASN1_ERR_BADARGS;
            break;
        }

        return ASN1EncSetError(enc, rc);
    }

    return ASN1_ERR_BADARGS;
}

ASN1error_e ASN1_GetEncoderOption
(
    ASN1encoding_t      enc,
    ASN1optionparam_t  *pOptParam
)
{
    if (NULL != enc && NULL != pOptParam)
    {
        ASN1INTERNencoding_t e = (ASN1INTERNencoding_t)enc;
        ASN1error_e rc = ASN1_SUCCESS;

        /* check magic number */
        EncAssert(enc, MAGIC_ENCODER == enc->magic);

        switch (pOptParam->eOption)
        {
        case ASN1OPT_GET_RULE:
            pOptParam->eRule = enc->eRule;
            break;

        default:
            rc = ASN1_ERR_BADARGS;
            break;
        }

        return ASN1EncSetError(enc, rc);
    }

    return ASN1_ERR_BADARGS;
}


/* destroy encoding stream */
void ASN1_CloseEncoder
(
    ASN1encoding_t      enc
)
{
    if (NULL != enc)
    {
        ASN1INTERNencoding_t e = (ASN1INTERNencoding_t)enc;

        /* check magic number */
        EncAssert(enc, MAGIC_ENCODER == enc->magic);

        if (e != e->parent)
        {
            EncAssert(enc, e == e->parent->child);
            e->parent->child = NULL;
        }

        /* free encoding stream */
        MemFree(e);
    }
}

/* destroy encoding stream */
void ASN1_CloseEncoder2
(
    ASN1encoding_t      enc
)
{
    if (NULL != enc)
    {
        /* check magic number */
        EncAssert(enc, MAGIC_ENCODER == enc->magic);

        EncMemFree(enc, enc->buf);

        ASN1_CloseEncoder(enc);
    }
}

/* init an ASN1decoding_t */
ASN1error_e ASN1_CreateDecoder
(
    CScratchMemoryAllocator* pScratchMemoryAllocator,
    ASN1module_t        mod,
    ASN1decoding_t     *dec,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize,
    ASN1decoding_t      pParent
)
{
    if (NULL != mod && NULL != dec)
    {
        ASN1INTERNdecoding_t d;

        *dec = NULL;

        /* construct ASN1decoding_t */
        d = (ASN1INTERNdecoding_t)pScratchMemoryAllocator->Alloc(sizeof(*d) + ASN1_TEST_CODER_SIZE);
        if (NULL != d)
        {
            RtlZeroMemory(d, sizeof(*d) + ASN1_TEST_CODER_SIZE);
            d->info.pScratchMemoryAllocator = pScratchMemoryAllocator;
            d->info.magic = MAGIC_DECODER;
            d->info.err = ASN1_SUCCESS;
            d->info.dwFlags = mod->dwFlags;
            d->info.module = mod;
            // d->child = NULL;

            /* set buffer if given */
            // lonchanc: it is ok to have a zero buffer size here
            if (NULL != pbBuf)
            {
                d->info.dwFlags |= ASN1DECODE_SETBUFFER;
                d->info.buf = d->info.pos = pbBuf;
                d->info.size = cbBufSize;
                // d->info.len = d->info.bit = 0;
            }
            else
            {
                // d->info.buf = d->info.pos = NULL;
                // d->info.size = d->info.len = d->info.bit = 0;
            }

            /* set parent if parented */
            if (NULL != pParent)
            {
                d->parent = (ASN1INTERNdecoding_t) pParent;
                d->info.eRule = pParent->eRule;
            }
            else
            /* initialize otherwise */
            {
                d->parent = d;
                d->info.eRule = mod->eRule;
            }

            // d->mem = NULL;
            // d->memlength = 0;
            // d->memsize = 0;
            // d->epi = NULL;
            // d->epilength = 0;
            // d->episize = 0;
            // d->csi = NULL;
            // d->csilength = 0;
            // d->csisize = 0;

#if defined(TEST_CODER) && defined(_DEBUG)
            TestDec_InitCoder(d, mod);
#endif // defined(TEST_CODER) && defined(_DEBUG)

            if (NULL != pParent)
            {
                DecAssert((ASN1decoding_t) d, NULL == ((ASN1INTERNdecoding_t) pParent)->child);
                ((ASN1INTERNdecoding_t) pParent)->child = d;
            }

            *dec = (ASN1decoding_t) d;
            return ASN1_SUCCESS;
        }
        else
        {
            return ASN1_ERR_MEMORY;
        }
    }

    return ASN1_ERR_BADARGS;
}

/* decode a value */
ASN1error_e ASN1_Decode
(
    ASN1decoding_t      dec,
    void              **valref,
    ASN1uint32_t        id,
    ASN1uint32_t        flags,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize
)
{
    if (NULL != dec && NULL != valref)
    {
        ASN1INTERNdecoding_t    d = (ASN1INTERNdecoding_t)dec;

        /* check magic numbers */
        DecAssert(dec, MAGIC_DECODER == dec->magic);

        /* clear error */
        ASN1DecSetError(dec, ASN1_SUCCESS);

        /* new buffer given? */
        if (flags & ASN1DECODE_SETBUFFER)
        {
            if (NULL != pbBuf && 0 != cbBufSize)
            {
                dec->pos = dec->buf = pbBuf;
                dec->size = cbBufSize;
                dec->bit = dec->len = 0;
            }
            else
            {
                return ASN1DecSetError(dec, ASN1_ERR_BADARGS);
            }
        }
        /* rewind buffer? */
        else if ((flags & ASN1DECODE_REWINDBUFFER) ||
                 !((d->info.dwFlags | flags ) & ASN1DECODE_APPENDED))
        {
            dec->pos = dec->buf;
            dec->bit = dec->len = 0;
        }
        /* otherwise continue reading from last buffer */

        /* check id number */
        if (id < dec->module->cPDUs)
        {
            ASN1uint32_t cbTopLevelStruct;

            /* clear length of linear buffer required */
            d->cbLinearBufSize = 0;

            /* double check for the availability of destination buffer */
            if (d->lpOrigExtBuf == NULL || d->cbOrigExtBufSize == 0)
            {
                d->fExtBuf = FALSE;
            }

            cbTopLevelStruct = dec->module->acbStructSize[id];
            if (NULL != (*valref = DecMemAlloc(dec, cbTopLevelStruct)))
            {
                if (ASN1_PER_RULE & dec->eRule)
                {
                    ASN1PerDecFun_t pfnPER;
                    /* decode value */
                    if (NULL != (pfnPER = dec->module->PER.apfnDecoder[id]))
                    {
                        if ((*pfnPER)(dec, *valref))
                        {
                            ASN1PERDecFlush(dec);
                        }
                        else
                        {
                            // the error code must be an error
                            if (ASN1_SUCCEEDED(d->parent->info.err))
                            {
                                // cannot return here immediately because we need to do cleanup
                                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                            }
                        }
                    }
                    else
                    {
                        return ASN1DecSetError(dec, ASN1_ERR_BADPDU);
                    }
                }
#ifdef ENABLE_BER
                else
                if (ASN1_BER_RULE & dec->eRule)
                {
                    ASN1BerDecFun_t pfnBER;
                    /* decode value */
                    if (NULL != (pfnBER = dec->module->BER.apfnDecoder[id]))
                    {
                        if ((*pfnBER)(dec, 0, *valref)) // lonchanc: tag is 0 to make it compiled
                        {
                            ASN1BERDecFlush(dec);
                        }
                        else
                        {
                            // the error code must be an error
                            if (ASN1_SUCCEEDED(d->parent->info.err))
                            {
                                // cannot return here immediately because we need to do cleanup
                                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                            }
                        }
                    }
                    else
                    {
                        return ASN1DecSetError(dec, ASN1_ERR_BADPDU);
                    }
                }
#endif // ENABLE_BER
                else
                {
                    return ASN1DecSetError(dec, ASN1_ERR_RULE);
                }

                /* call abort/done function for non-parented decoding stream */
                if (ASN1_SUCCEEDED(d->parent->info.err))
                {
                    // not parented
                    if (d == d->parent)
                    {
#if defined(TEST_CODER) && defined(_DEBUG)
                        if (ASN1_PER_RULE & dec->eRule)
                        {
                            if (! TestDec_Compare(d, id, *valref, dec->buf, dec->len))
                            {
                                MyDebugBreak();
                            }
                        }
#ifdef ENABLE_BER
                        else
                        if (ASN1_BER_RULE & dec->eRule)
                        {
                            if (! TestDec_Compare(d, id, *valref, dec->buf, dec->len))
                            {
                                MyDebugBreak();
                            }
                        }
#endif // ENABLE_BER
#endif
                        ASN1DecDone(dec);
                    }
                }
                else
                {
                    ASN1INTERNdecoding_t child, child2;

                    // not parented
                    if (d == d->parent)
                    {
                        ASN1DecAbort(dec);
                    }

                    // clean up...
                    ASN1_FreeDecoded(dec ,*valref, id);
                    *valref = NULL;
                    for (child = d->child; child; child = child2)
                    {
                        child2 = child->child;
                        // make sure it does not touch its parent which may already be freed
                        child->parent = child;
                        ASN1_CloseDecoder((ASN1decoding_t) child);
                    }
                    d->child = NULL;
                }

                /* return error code */
                return d->parent->info.err;
            }
            else
            {
                return ASN1_ERR_MEMORY;
            }
        }
        else
        {
            return ASN1DecSetError(dec, ASN1_ERR_BADPDU);
        }
    }

    return ASN1_ERR_BADARGS;
}

/* control function for decoding */
ASN1error_e ASN1_SetDecoderOption
(
    ASN1decoding_t      dec,
    ASN1optionparam_t  *pOptParam
)
{
    if (NULL != dec)
    {
        ASN1INTERNdecoding_t d = (ASN1INTERNdecoding_t)dec;
        ASN1error_e rc = ASN1_SUCCESS;

        /* check magic number */
        DecAssert(dec, MAGIC_DECODER == dec->magic);

        switch (pOptParam->eOption)
        {
        case ASN1OPT_CHANGE_RULE:
            dec->eRule = pOptParam->eRule;
            break;

        case ASN1OPT_SET_DECODED_BUFFER:
            if (NULL != pOptParam->Buffer.pbBuf && 0 != pOptParam->Buffer.cbBufSize)
            {
                d->fExtBuf = TRUE;
                d->lpOrigExtBuf = pOptParam->Buffer.pbBuf;
                d->cbOrigExtBufSize = pOptParam->Buffer.cbBufSize;
                d->lpRemExtBuf = (ASN1uint8_t*) d->lpOrigExtBuf;
                d->cbRemExtBufSize = d->cbOrigExtBufSize;
            }
            else
            {
                rc = ASN1_ERR_BADARGS;
            }
            break;

        case ASN1OPT_DEL_DECODED_BUFFER:
            d->fExtBuf = FALSE;
            d->lpOrigExtBuf = NULL;
            d->cbOrigExtBufSize = 0;
            d->lpRemExtBuf = NULL;
            d->cbRemExtBufSize = 0;
            break;

        default:
            rc = ASN1_ERR_BADARGS;
            break;
        }

        return ASN1DecSetError(dec, rc);
    }

    return ASN1_ERR_BADARGS;
}


/* control function for decoding */
ASN1error_e ASN1_GetDecoderOption
(
    ASN1decoding_t      dec,
    ASN1optionparam_t  *pOptParam
)
{
    if (NULL != dec)
    {
        ASN1INTERNdecoding_t d = (ASN1INTERNdecoding_t)dec;
        ASN1error_e rc = ASN1_SUCCESS;

        /* check magic number */
        DecAssert(dec, MAGIC_DECODER == dec->magic);

        switch (pOptParam->eOption)
        {
        case ASN1OPT_GET_RULE:
            pOptParam->eRule = dec->eRule;
            break;

        case ASN1OPT_GET_DECODED_BUFFER_SIZE:
            pOptParam->cbRequiredDecodedBufSize = d->cbLinearBufSize;
            break;

        default:
            rc = ASN1_ERR_BADARGS;
            break;
        }

        return ASN1DecSetError(dec, rc);
    }

    return ASN1_ERR_BADARGS;
}


/* destroy decoding stream */
void ASN1_CloseDecoder
(
    ASN1decoding_t      dec
)
{
    if (NULL != dec)
    {
        ASN1INTERNdecoding_t d = (ASN1INTERNdecoding_t)dec;

        /* check magic number */
        DecAssert(dec, MAGIC_DECODER == dec->magic);

        if (d != d->parent)
        {
            DecAssert(dec, d == d->parent->child);
            d->parent->child = NULL;
        }

        /* free decoding stream */
        MemFree(d);
    }
}

/* free an encoded value */
void ASN1_FreeEncoded
(
    ASN1encoding_t      enc,
    void               *val
)
{
    if (NULL != enc)
    {
        /* check magic number */
        EncAssert(enc, MAGIC_ENCODER == enc->magic);

        EncMemFree(enc, val);
    }
}

/* free a unencoded value */
void ASN1_FreeDecoded
(
    ASN1decoding_t      dec,
    void               *val,
    ASN1uint32_t        id
)
{
    if (NULL != dec)
    {
        ASN1INTERNdecoding_t d = (ASN1INTERNdecoding_t)dec;

        /* check magic number */
        DecAssert(dec, MAGIC_DECODER == dec->magic);

        // same behavior of LocalFree
        if (val != NULL)
        {
            if (id != ASN1DECFREE_NON_PDU_ID)
            {
                ASN1FreeFun_t       pfnFreeMemory;

                /* free value */
                if (id < dec->module->cPDUs)
                {
                    if (NULL != (pfnFreeMemory = dec->module->apfnFreeMemory[id]))
                    {
                        (*pfnFreeMemory)(val);
                    }
                }
                else
                {
                    return;
                }
            }

            // free the top-level structure
            MemFree(val);
        }
    }
}

void ASN1_InitModule
(
    ASN1module_t            module,
    ASN1uint32_t            version,
    ASN1encodingrule_e      eEncodingRule,
    ASN1uint32_t            dwFlags,
    ASN1uint32_t            cPDUs,
    const ASN1GenericFun_t  apfnEncoder[],
    const ASN1GenericFun_t  apfnDecoder[],
    const ASN1FreeFun_t     apfnFreeMemory[],
    const ASN1uint32_t      acbStructSize[],
    ASN1magic_t             nModuleName
)
{
    module->nModuleName = nModuleName;
    module->eRule = eEncodingRule;
    module->dwFlags = dwFlags;
    module->cPDUs = cPDUs;

    module->apfnFreeMemory = apfnFreeMemory;
    module->acbStructSize = acbStructSize;

    if (ASN1_PER_RULE & eEncodingRule)
    {
        module->PER.apfnEncoder = (const ASN1PerEncFun_t *) apfnEncoder;
        module->PER.apfnDecoder = (const ASN1PerDecFun_t *) apfnDecoder;
    }
#ifdef ENABLE_BER
    else
    if (ASN1_BER_RULE & eEncodingRule)
    {
        module->BER.apfnEncoder = (const ASN1BerEncFun_t *) apfnEncoder;
        module->BER.apfnDecoder = (const ASN1BerDecFun_t *) apfnDecoder;
    }
#endif // ENABLE_BER
}

#ifdef TEST_CODER

static int MyMemCmp(ASN1octet_t *p1, ASN1octet_t *p2, ASN1uint32_t c)
{
    BYTE diff;
    while (c--)
    {
        if ((diff = *p1++ - *p2++) != 0)
            return (int) diff;
    }
    return 0;
}

__inline ASN1INTERNencoding_t TestEnc_GetEnc(ASN1INTERNencoding_t e)
    { return &(((ASN1testcoder_t) (e+1))->e); }
__inline ASN1INTERNdecoding_t TestEnc_GetDec(ASN1INTERNencoding_t e)
    { return &(((ASN1testcoder_t) (e+1))->d); }
__inline ASN1INTERNencoding_t TestDec_GetEnc(ASN1INTERNdecoding_t d)
    { return &(((ASN1testcoder_t) (d+1))->e); }
__inline ASN1INTERNdecoding_t TestDec_GetDec(ASN1INTERNdecoding_t d)
    { return &(((ASN1testcoder_t) (d+1))->d); }

static void Test_InitEnc(ASN1INTERNencoding_t e, ASN1module_t mod, ASN1encodingrule_e eRule)
{
    RtlZeroMemory(e, sizeof(*e));
    e->info.magic = MAGIC_ENCODER;
    e->info.err = ASN1_SUCCESS;
    e->info.module = mod;
    e->info.eRule = eRule;
    e->parent = e;
    e->child = NULL;
}

static void Test_InitDec(ASN1INTERNdecoding_t d, ASN1module_t mod, ASN1encodingrule_e eRule)
{
    RtlZeroMemory(d, sizeof(*d));
    d->info.magic = MAGIC_DECODER;
    d->info.err = ASN1_SUCCESS;
    d->info.module = mod;
    d->info.eRule = eRule;
    d->parent = d;
    d->child = NULL;
}

static int TestEnc_InitCoder(ASN1INTERNencoding_t e, ASN1module_t mod)
{
    ASN1INTERNencoding_t ee = TestEnc_GetEnc(e);
    ASN1INTERNdecoding_t ed = TestEnc_GetDec(e);
    Test_InitEnc(ee, mod, e->info.eRule);
    Test_InitDec(ed, mod, e->info.eRule);
    return 1;
}

static int TestDec_InitCoder(ASN1INTERNdecoding_t d, ASN1module_t mod)
{
    ASN1INTERNencoding_t de = TestDec_GetEnc(d);
    ASN1INTERNdecoding_t dd = TestDec_GetDec(d);
    Test_InitEnc(de, mod, d->info.eRule);
    Test_InitDec(dd, mod, d->info.eRule);
    return 1;
}

static int Test_Encode(ASN1INTERNencoding_t e, void *value, ASN1uint32_t id)
{
    ASN1encoding_t enc = (ASN1encoding_t) e;

    /* clear error */
    ASN1EncSetError(enc, ASN1_SUCCESS);

    // clean buffer
    enc->pos = enc->buf;
    enc->bit = enc->len = 0;

    if (ASN1_PER_RULE & enc->eRule)
    {
        /* encode value */
        ASN1PerEncFun_t pfnPER;
        if (NULL != (pfnPER = enc->module->PER.apfnEncoder[id]))
        {
            if ((*pfnPER)(enc, value))
            {
                ASN1PEREncFlush(enc);
            }
        }
        else
        {
            return ASN1EncSetError(enc, ASN1_ERR_BADPDU);
        }
    }
#ifdef ENABLE_BER
    else
    if (ASN1_BER_RULE & enc->eRule)
    {
        /* encode value */
        ASN1BerEncFun_t pfnBER;
        if (NULL != (pfnBER = enc->module->BER.apfnEncoder[id]))
        {
            if ((*pfnBER)(enc, 0, value)) // lonchanc: tag is 0 to make it compiled
            {
                ASN1BEREncFlush(enc);
            }
        }
        else
        {
            return ASN1EncSetError(enc, ASN1_ERR_BADPDU);
        }
    }
#endif // ENABLE_BER
    else
    {
        return ASN1EncSetError(enc, ASN1_ERR_RULE);
    }

    /* call abort/done function for non-parented encoding stream */
    if (e->parent->info.err >= 0)
    {
        if (e == e->parent)
        {
            ASN1EncDone(enc);
        }
    }
    else
    {
        ASN1INTERNencoding_t child, child2;

        if (e == e->parent)
        {
            ASN1EncAbort(enc);
        }

        // clean up...
        ASN1_FreeEncoded(enc, enc->buf);
        enc->pos = enc->buf = NULL;
        enc->size = enc->len = enc->bit = 0;
        for (child = e->child; child; child = child2)
        {
            child2 = child->child;
            // make sure it does not touch its parent which may already be freed
            child->parent = child;
            ASN1_CloseEncoder((ASN1encoding_t) child);
        }
        e->child = NULL;
    }

    /* return error code */
    return e->parent->info.err;
}

static int Test_Decode(ASN1INTERNdecoding_t d, void ** valref, ASN1uint32_t id, ASN1octet_t *pbBuf, ASN1uint32_t cbBufSize)
{
    ASN1decoding_t dec = (ASN1decoding_t) d;
    ASN1uint32_t cbTopLevelStruct;

    /* clear error */
    ASN1DecSetError(dec, ASN1_SUCCESS);

    // set up buffer containing encoded data
    dec->pos = dec->buf = pbBuf;
    dec->size = cbBufSize;
    dec->bit = dec->len = 0;

    /* clear length of linear buffer required */
    d->cbLinearBufSize = 0;
    d->fExtBuf = FALSE;

    cbTopLevelStruct = dec->module->acbStructSize[id];
    if (NULL != (*valref = DecMemAlloc(dec, cbTopLevelStruct)))
    {
        if (ASN1_PER_RULE & dec->eRule)
        {
            ASN1PerDecFun_t pfnPER;
            /* decode value */
            if (NULL != (pfnPER = dec->module->PER.apfnDecoder[id]))
            {
                if ((*pfnPER)(dec, *valref))
                {
                    ASN1PERDecFlush(dec);
                }
            }
            else
            {
                return ASN1DecSetError(dec, ASN1_ERR_BADPDU);
            }
        }
#ifdef ENABLE_BER
        else
        if (ASN1_BER_RULE & dec->eRule)
        {
            ASN1BerDecFun_t pfnBER;
            /* decode value */
            if (NULL != (pfnBER = dec->module->BER.apfnDecoder[id]))
            {
                if ((*pfnBER)(dec, 0, *valref))
                {
                    ASN1BERDecFlush(dec);
                }
            }
            else
            {
                return ASN1DecSetError(dec, ASN1_ERR_BADPDU);
            }
        }
#endif // ENABLE_BER
        else
        {
            return ASN1DecSetError(dec, ASN1_ERR_RULE);
        }

        /* call abort/done function for non-parented decoding stream */
        if (d->parent->info.err >= 0)
        {
            // not parented
            if (d == d->parent)
            {
                ASN1DecDone(dec);
            }
        }
        else
        {
            ASN1INTERNdecoding_t child, child2;

            // not parented
            if (d == d->parent)
            {
                ASN1DecAbort(dec);
            }

            // clean up...
            ASN1_FreeDecoded(dec ,*valref, id);
            *valref = NULL;
            for (child = d->child; child; child = child2)
            {
                child2 = child->child;
                // make sure it does not touch its parent which may already be freed
                child->parent = child;
                ASN1_CloseDecoder((ASN1decoding_t) child);
            }
            d->child = NULL;
        }
    }
    else
    {
        return ASN1_ERR_MEMORY;
    }

    /* return error code */
    return d->parent->info.err;
}

static void Test_CleanEnc(ASN1INTERNencoding_t e)
{
    if (e->info.buf)
    {
        EncMemFree((ASN1encoding_t) e, e->info.buf);
    }
    Test_InitEnc(e, e->info.module, e->info.eRule);
}

static void Test_CleanDec(ASN1INTERNdecoding_t d)
{
    Test_InitDec(d, d->info.module, d->info.eRule);
}

static int TestEnc_Compare(ASN1INTERNencoding_t e, ASN1uint32_t id, ASN1octet_t *pbBuf, ASN1uint32_t cbBufSize)
{
    ASN1INTERNencoding_t ee = TestEnc_GetEnc(e);
    ASN1INTERNdecoding_t ed = TestEnc_GetDec(e);
    int ret;
    void *val = NULL;
    int fRet = 0;

    ee->info.eRule = e->info.eRule;
    ed->info.eRule = e->info.eRule;

    ret = Test_Decode(ed, &val, id, pbBuf, cbBufSize);
    if (ret == ASN1_SUCCESS)
    {
        ret = Test_Encode(ee, val, id);
        if (ret == ASN1_SUCCESS)
        {
            if (ee->info.len == cbBufSize)
            {
                fRet = (MyMemCmp(pbBuf, ee->info.buf, cbBufSize) == 0);
            }
        }
    }

    if (val)
    {
        ASN1_FreeDecoded((ASN1decoding_t) ed, val, id);
    }

    Test_CleanEnc(ee);
    Test_CleanDec(ed);

    return fRet;
}

static int TestDec_Compare(ASN1INTERNdecoding_t d, ASN1uint32_t id, void *val, ASN1octet_t *pbBuf, ASN1uint32_t cbBufSize)
{
    ASN1INTERNencoding_t de = TestDec_GetEnc(d);
    int ret;
    int fRet = 0;

    de->info.eRule = d->info.eRule;

    ret = Test_Encode(de, val, id);
    if (ret == ASN1_SUCCESS)
    {
        if (de->info.len == cbBufSize)
        {
            fRet = (MyMemCmp(pbBuf, de->info.buf, cbBufSize) == 0);
        }
    }

    Test_CleanEnc(de);

    return fRet;
}
#endif

#ifdef ENABLE_BER

static const char bitmsk2[] =
{
    (const char) 0x00,
    (const char) 0x80,
    (const char) 0xc0,
    (const char) 0xe0,
    (const char) 0xf0,
    (const char) 0xf8,
    (const char) 0xfc,
    (const char) 0xfe
};


/* decode bit string value */
int _BERDecBitString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1bitstring_t *val, ASN1uint32_t fNoCopy)
{
    ASN1uint32_t constructed, len, infinite;
    ASN1bitstring_t b;
    ASN1decoding_t dd;
    ASN1octet_t *di;

    /* skip tag */
    if (ASN1BERDecTag(dec, tag, &constructed))
    {
        /* get length */
        if (ASN1BERDecLength(dec, &len, &infinite))
        {
            if (constructed)
            {
                /* constructed? then start decoding of constructed value */
                val->length = 0;
                if (_BERDecConstructed(dec, len, infinite, &dd, &di))
                {
                    while (ASN1BERDecNotEndOfContents(dd, di))
                    {
                        if (_BERDecBitString(dd, 0x3, &b, fNoCopy))
                        {
                            if (b.length)
                            {
                                if (fNoCopy)
                                {
                                    *val = b;
                                    break; // break out the loop because nocopy cannot have multiple constructed streams
                                }

                                /* resize value */
                                val->value = (ASN1octet_t *)DecMemReAlloc(dd, val->value,
                                    (val->length + b.length + 7) / 8);
                                if (val->value)
                                {
                                    /* concat bit strings */
                                    ASN1bitcpy(val->value, val->length, b.value, 0, b.length);
                                    val->length += b.length;
                                    if (val->length & 7)
                                        val->value[val->length / 8] &= bitmsk2[val->length & 7];

                                    /* free unused bit string */
                                    DecMemFree(dec, b.value);
                                }
                                else
                                {
                                    return 0;
                                }
                            }
                        }
                    } // while
                    return ASN1BERDecEndOfContents(dec, dd, di);
                }
            }
            else
            {
                /* primitive? then copy value */
                if (!len)
                {
                    val->length = 0;
                    val->value = NULL;
                    return 1;
                }
                else
                {
                    if (*dec->pos < 8)
                    {
                        len--; // skip over the initial octet; len is now the actual length of octets
                        val->length = len * 8 - *dec->pos++;
                        if (fNoCopy)
                        {
                            val->value = dec->pos;
                            dec->pos += len;
                            return 1;
                        }
                        else
                        {
                            if (val->length)
                            {
                                val->value = (ASN1octet_t *)DecMemAlloc(dec, (val->length + 7) / 8);
                                if (val->value)
                                {
                                    RtlCopyMemory(val->value, dec->pos, len);
                                    if (val->length & 7)
                                        val->value[len - 1] &= bitmsk2[val->length & 7];
                                    dec->pos += len;
                                    return 1;
                                }
                            }
                            else
                            {
                                val->value = NULL;
                                return 1;
                            }
                        }
                    }
                    else
                    {
                        ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                    }
                }
            }
        }
    }
    return 0;
}

/* decode bit string value, making copy */
int ASN1BERDecBitString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1bitstring_t *val)
{
    return _BERDecBitString(dec, tag, val, FALSE);
}

/* decode bit string value, no copy */
int ASN1BERDecBitString2(ASN1decoding_t dec, ASN1uint32_t tag, ASN1bitstring_t *val)
{
    return _BERDecBitString(dec, tag, val, TRUE);
}

/* decode string value */
int ASN1BERDecCharString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1charstring_t *val)
{
    ASN1uint32_t constructed, len, infinite;
    ASN1charstring_t c;
    ASN1decoding_t dd;
    ASN1octet_t *di;

    /* skip tag */
    if (ASN1BERDecTag(dec, tag, &constructed))
    {
        /* get length */
        if (ASN1BERDecLength(dec, &len, &infinite))
        {
            if (constructed)
            {
                /* constructed? then start decoding of constructed value */
                val->length = 0;
                if (_BERDecConstructed(dec, len, infinite, &dd, &di))
                {
                    while (ASN1BERDecNotEndOfContents(dd, di))
                    {
                        if (ASN1BERDecCharString(dd, 0x4, &c))
                        {
                            if (c.length)
                            {
                                /* resize value */
                                val->value = (char *)DecMemReAlloc(dd, val->value,
                                    val->length + c.length);
                                if (val->value)
                                {
                                    /* concat strings */
                                    RtlCopyMemory(val->value + val->length, c.value, c.length);
                                    val->length += c.length;

                                    /* free unused string */
                                    DecMemFree(dec, c.value);
                                }
                                else
                                {
                                    return 0;
                                }
                            }
                        }
                        else
                        {
                            return 0;
                        }
                    } // while
                    return ASN1BERDecEndOfContents(dec, dd, di);
                }
            }
            else
            {
                /* primitive? then copy value */
                val->length = len;
                if (len)
                {
                    val->value = (char *)DecMemAlloc(dec, len+1);
                    if (val->value)
                    {
                        RtlCopyMemory(val->value, dec->pos, len);
                        dec->pos += len;
                        val->value[len] = 0;
                        return 1;
                    }
                }
                else
                {
                    val->value = NULL;
                    return 1;
                }
            }
        }
    }
    return 0;
}

/* decode 16 bit string value */
int ASN1BERDecChar16String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1char16string_t *val)
{
    ASN1uint32_t constructed, len, infinite;
    ASN1char16string_t c;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t i;

    /* skip tag */
    if (ASN1BERDecTag(dec, tag, &constructed))
    {
        /* get length */
        if (ASN1BERDecLength(dec, &len, &infinite))
        {
            if (constructed)
            {
                /* constructed? then start decoding of constructed value */
                val->length = 0;
                if (_BERDecConstructed(dec, len, infinite, &dd, &di))
                {
                    while (ASN1BERDecNotEndOfContents(dd, di))
                    {
                        if (ASN1BERDecChar16String(dd, 0x4, &c))
                        {
                            if (c.length)
                            {
                                /* resize value */
                                val->value = (ASN1char16_t *)DecMemReAlloc(dd, val->value,
                                    (val->length + c.length) * sizeof(ASN1char16_t));
                                if (val->value)
                                {
                                    /* concat strings */
                                    RtlCopyMemory(val->value + val->length, c.value,
                                        c.length * sizeof(ASN1char16_t));
                                    val->length += c.length;

                                    /* free unused string */
                                    DecMemFree(dec, c.value);
                                }
                                else
                                {
                                    return 0;
                                }
                            }
                        }
                        else
                        {
                            return 0;
                        }
                    }
                    return ASN1BERDecEndOfContents(dec, dd, di);
                }
            }
            else
            {
                /* primitive? then copy value */
                DecAssert(dec, 2 * sizeof(ASN1octet_t) == sizeof(ASN1char16_t));
                len = len >> 1; // divided by 2
                val->length = len;
                if (len)
                {
                    val->value = (ASN1char16_t *)DecMemAlloc(dec, (len+1) * sizeof(ASN1char16_t));
                    if (val->value)
                    {
                        for (i = 0; i < len; i++)
                        {
                            val->value[i] = (*dec->pos << 8) | dec->pos[1];
                            dec->pos += 2;
                        }
                        val->value[len] = 0;
                        return 1;
                    }
                }
                else
                {
                    val->value = NULL;
                    return 1;
                }
            }
        }
    }
    return 0;
}

/* decode 32 bit string value */
int ASN1BERDecChar32String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1char32string_t *val)
{
    ASN1uint32_t constructed, len, infinite;
    ASN1char32string_t c;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t i;

    /* skip tag */
    if (ASN1BERDecTag(dec, tag, &constructed))
    {
        /* get length */
        if (ASN1BERDecLength(dec, &len, &infinite))
        {
            if (constructed)
            {
                /* constructed? then start decoding of constructed value */
                val->length = 0;
                if (_BERDecConstructed(dec, len, infinite, &dd, &di))
                {
                    while (ASN1BERDecNotEndOfContents(dd, di))
                    {
                        if (ASN1BERDecChar32String(dd, 0x4, &c))
                        {
                            if (c.length)
                            {
                                /* resize value */
                                val->value = (ASN1char32_t *)DecMemReAlloc(dd, val->value,
                                    (val->length + c.length) * sizeof(ASN1char32_t));
                                if (val->value)
                                {
                                    /* concat strings */
                                    RtlCopyMemory(val->value + val->length, c.value,
                                        c.length * sizeof(ASN1char32_t));
                                    val->length += c.length;

                                    /* free unused string */
                                    DecMemFree(dec, c.value);
                                }
                                else
                                {
                                    return 0;
                                }
                            }
                        }
                        else
                        {
                            return 0;
                        }
                    }
                    return ASN1BERDecEndOfContents(dec, dd, di);
                }
            }
            else
            {
                /* primitive? then copy value */
                DecAssert(dec, 4 * sizeof(ASN1octet_t) == sizeof(ASN1char32_t));
                len = len >> 2; // divided by 4
                val->length = len;
                if (len)
                {
                    val->value = (ASN1char32_t *)DecMemAlloc(dec, (len+1) * sizeof(ASN1char32_t));
                    if (val->value)
                    {
                        for (i = 0; i < len; i++)
                        {
                            val->value[i] = (*dec->pos << 24) | (dec->pos[1] << 16) |
                                (dec->pos[2] << 8) | dec->pos[3];;
                            dec->pos += 4;
                        }
                        val->value[len] = 0;
                        return 1;
                    }
                }
                else
                {
                    val->value = NULL;
                    return 1;
                }
            }
        }
    }
    return 0;
}

#ifdef ENABLE_GENERALIZED_CHAR_STR
/* decode character string value */
int ASN1BERDecCharacterString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1characterstring_t *val)
{
    ASN1INTERNdecoding_t d = (ASN1INTERNdecoding_t) dec;
    ASN1uint32_t constructed, len, infinite;
    ASN1uint32_t index;
    ASN1characterstring_identification_t *identification;
    ASN1decoding_t dd, dd2, dd3;
    ASN1octet_t *di, *di2, *di3;

    /* skip tag */
    if (!ASN1BERDecTag(dec, tag, &constructed))
        return 0;

    if (constructed)
    {
        /* constructed? CS-A encoded: */
        /* get length */
        if (!ASN1BERDecLength(dec, &len, &infinite))
            return 0;

        /* start decoding of constructed value */
        if (! _BERDecConstructed(dec, len, infinite, &dd, &di))
            return 0;
        if (!ASN1BERDecU32Val(dd, 0x80000000, &index))
            return 0;
        if (index != d->parent->csilength)
        {
            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            return 0;
        }
        if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd2, &di2))
            return 0;
        if (!ASN1BERDecPeekTag(dd2, &tag))
            return 0;
        switch (tag)
        {
        case 0x80000000:
            val->identification.o =
                ASN1characterstring_identification_syntaxes_o;
            if (!ASN1BERDecExplicitTag(dd2, 0x80000000, &dd3, &di3))
                return 0;
            if (!ASN1BERDecObjectIdentifier(dd3, 0x80000000,
                &val->identification.u.syntaxes.abstract))
                return 0;
            if (!ASN1BERDecObjectIdentifier(dd3, 0x80000001,
                &val->identification.u.syntaxes.transfer))
                return 0;
            if (!ASN1BERDecEndOfContents(dd2, dd3, di3))
                return 0;
            break;
        case 0x80000001:
            val->identification.o = ASN1characterstring_identification_syntax_o;
            if (!ASN1BERDecObjectIdentifier(dd2, 0x80000001,
                &val->identification.u.syntax))
                return 0;
            break;
        case 0x80000002:
            val->identification.o =
                ASN1characterstring_identification_presentation_context_id_o;
            if (!ASN1BERDecU32Val(dd2, 0x80000002,
                &val->identification.u.presentation_context_id))
                return 0;
            break;
        case 0x80000003:
            val->identification.o =
                ASN1characterstring_identification_context_negotiation_o;
            if (!ASN1BERDecExplicitTag(dd2, 0x80000003, &dd3, &di3))
                return 0;
            if (!ASN1BERDecU32Val(dd3, 0x80000000, &val->
                identification.u.context_negotiation.presentation_context_id))
                return 0;
            if (!ASN1BERDecObjectIdentifier(dd3, 0x80000001,
                &val->identification.u.context_negotiation.transfer_syntax))
                return 0;
            if (!ASN1BERDecEndOfContents(dd2, dd3, di3))
                return 0;
            break;
        case 0x80000004:
            val->identification.o =
                ASN1characterstring_identification_transfer_syntax_o;
            if (!ASN1BERDecObjectIdentifier(dd2, 0x80000004,
                &val->identification.u.transfer_syntax))
                return 0;
            break;
        case 0x80000005:
            val->identification.o = ASN1characterstring_identification_fixed_o;
            if (!ASN1BERDecNull(dd2, 0x80000005))
                return 0;
            break;
        default:
            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            return 0;
        }
        if (!ASN1BERDecEndOfContents(dd, dd2, di2))
            return 0;
        if (!ASN1DecAddCharacterStringIdentification(d->parent,
            &val->identification))
            return 0;
        val->data_value.o = ASN1characterstring_data_value_encoded_o;
        if (!ASN1BERDecOctetString(dd, 0x80000003,
            &val->data_value.u.encoded))
            return 0;
        if (!ASN1BERDecEndOfContents(dec, dd, di))
            return 0;
    }
    else
    {
        /* primitive? CS-B encoded */
        /* get length */
        if (!ASN1BERDecLength(dec, &len, NULL))
            return 0;

        /* then copy value */
        if (!len)
        {
            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            return 0;
        }
        val->data_value.o = ASN1characterstring_data_value_encoded_o;
        val->data_value.u.encoded.length = len - 1;
        val->data_value.u.encoded.value = (ASN1octet_t *)DecMemAlloc(dec, len - 1);
        if (!val->data_value.u.encoded.value)
        {
            return 0;
        }
        index = *dec->pos++;
        RtlCopyMemory(val->data_value.u.encoded.value, dec->pos, len - 1);
        identification = ASN1DecGetCharacterStringIdentification(d->parent,
            index);
        if (!identification)
            return 0;
        val->identification.o = identification->o;
        switch (identification->o)
        {
        case ASN1characterstring_identification_syntaxes_o:
            if (!ASN1DecDupObjectIdentifier(dec, 
                &val->identification.u.syntaxes.abstract,
                &identification->u.syntaxes.abstract))
                return 0;
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.syntaxes.transfer,
                &identification->u.syntaxes.transfer))
                return 0;
            break;
        case ASN1characterstring_identification_syntax_o:
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.syntax,
                &identification->u.syntax))
                return 0;
            break;
        case ASN1characterstring_identification_presentation_context_id_o:
            val->identification.u.presentation_context_id =
                identification->u.presentation_context_id;
            break;
        case ASN1characterstring_identification_context_negotiation_o:
            val->identification.u.context_negotiation.presentation_context_id =
                identification->u.context_negotiation.presentation_context_id;
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.context_negotiation.transfer_syntax,
                &identification->u.context_negotiation.transfer_syntax))
                return 0;
            break;
        case ASN1characterstring_identification_transfer_syntax_o:
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.transfer_syntax,
                &identification->u.transfer_syntax))
                return 0;
            break;
        case ASN1characterstring_identification_fixed_o:
            break;
        }
    }
    return 1;
}
#endif // ENABLE_GENERALIZED_CHAR_STR

#ifdef ENABLE_DOUBLE
/* decode real value */
int ASN1BERDecDouble(ASN1decoding_t dec, ASN1uint32_t tag, double *val)
{
    ASN1uint32_t head;
    ASN1int32_t exponent;
    ASN1uint32_t baselog2;
    ASN1uint32_t len;
    ASN1uint32_t i;
    ASN1octet_t *p, *q;
    double v;
    char buf[256], *b;

    /* skip tag */
    if (!ASN1BERDecTag(dec, tag, NULL))
        return 0;

    /* get length */
    if (!ASN1BERDecLength(dec, &len, NULL))
        return 0;

    /* null length is 0.0 */
    if (!len)
    {
        *val = 0.0;
    }
    else
    {
        p = q = dec->pos;
        dec->pos += len;
        head = *p++;

        /* binary encoding? */
        if (head & 0x80)
        {
            /* get base */
            switch (head & 0x30)
            {
            case 0:
                /* base 2 */
                baselog2 = 1;
                break;
            case 0x10:
                /* base 8 */
                baselog2 = 3;
                break;
            case 0x20:
                /* base 16 */
                baselog2 = 4;
                break;
            default:
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                return 0;
            }

            /* get exponent */
            switch (head & 0x03)
            {
            case 0:
                /* 8 bit exponent */
                exponent = (ASN1int8_t)*p++;
                break;
            case 1:
                /* 16 bit exponent */
                exponent = (ASN1int16_t)((*p << 8) | p[1]);
                p += 2;
                break;
            case 2:
                /* 24 bit exponent */
                exponent = ((*p << 16) | (p[1] << 8) | p[2]);
                if (exponent & 0x800000)
                    exponent -= 0x1000000;
                break;
            default:
                /* variable length exponent */
                exponent = (p[1] & 0x80) ? -1 : 0;
                for (i = 1; i <= *p; i++)
                    exponent = (exponent << 8) | p[i];
                p += *p + 1;
                break;
            }

            /* calculate remaining length */
            len -= (ASN1uint32_t) (p - q);

            /* get mantissa */
            v = 0.0;
            for (i = 0; i < len; i++)
                v = v * 256.0 + *p++;

            /* scale mantissa */
            switch (head & 0x0c)
            {
            case 0x04:
                /* scaling factor 1 */
                v *= 2.0;
                break;
            case 0x08:
                /* scaling factor 2 */
                v *= 4.0;
                break;
            case 0x0c:
                /* scaling factor 3 */
                v *= 8.0;
                break;
            }

            /* check sign */
            if (head & 0x40)
                v = -v;

            /* calculate value */
            *val = ldexp(v, exponent * baselog2);
        }
        else
        /* special real values? */
        if (head & 0x40)
        {
            switch (head)
            {
            case 0x40:
                /* PLUS-INFINITY */
                *val = ASN1double_pinf();
                break;
            case 0x41:
                /* MINUS-INFINITY */
                *val = ASN1double_minf();
                break;
            default:
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                return 0;
            }
        }
        /* decimal encoding */
        else
        {
            RtlCopyMemory(buf, p, len - 1);
            buf[len - 1] = 0;
            b = strchr(buf, ',');
            if (b)
                *b = '.';
            *val = strtod((char *)buf, &b);
            if (*b)
            {
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                return 0;
            }
        }
    }
    return 1;
}
#endif // ENABLE_DOUBLE

#ifdef ENABLE_REAL
int ASN1BERDecReal(ASN1decoding_t dec, ASN1uint32_t tag, ASN1real_t *val)
{
    ASN1uint32_t head;
    ASN1int32_t ex;
    // ASN1intx_t exponent;
    ASN1uint32_t baselog2;
    ASN1uint32_t len;
    ASN1uint32_t i;
    ASN1octet_t *p, *q;
    double v;
    ASN1intx_t help;

    if (!ASN1BERDecTag(dec, tag, NULL))
        return 0;
    if (!ASN1BERDecLength(dec, &len, NULL))
        return 0;

    // *val = 0.0;
    DecAssert(dec, 0 == (int) eReal_Normal);
    RtlZeroMemory(val, sizeof(*val));
    if (len)
    {
        p = q = dec->pos;
        dec->pos += len;
        head = *p++;

        /* binary encoding? */
        if (head & 0x80)
        {
            val->type = eReal_Normal;

            /* get base */
            switch (head & 0x30)
            {
            case 0:
                /* base 2 */
                baselog2 = 1;
                break;
            case 0x10:
                /* base 8 */
                baselog2 = 3;
                break;
            case 0x20:
                /* base 16 */
                baselog2 = 4;
                break;
            default:
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                return 0;
            }

            /* get exponent */
            switch (head & 0x03)
            {
            case 0:
                /* 8 bit exponent */
                ex = (ASN1int8_t)*p++;
                ASN1intx_setint32(&val->exponent, ex);
                break;
            case 1:
                /* 16 bit exponent */
                ex = (ASN1int16_t)((*p << 8) | p[1]);
                p += 2;
                // ASN1intx_setint32_t(&exponent, ex);
                ASN1intx_setint32(&val->exponent, ex);
                break;
            case 2:
                /* 24 bit exponent */
                ex = ((*p << 16) | (p[1] << 8) | p[2]);
                if (ex & 0x800000)
                    ex -= 0x1000000;
                // ASN1intx_setint32_t(&exponent, ex);
                ASN1intx_setint32(&val->exponent, ex);
                break;
            default:
                /* variable length exponent */
                val->exponent.length = *p;
                val->exponent.value = (ASN1octet_t *)DecMemAlloc(dec, *p);
                if (!val->exponent.value)
                {
                    return 0;
                }
                RtlCopyMemory(val->exponent.value, p + 1, *p);
                p += *p + 1;
                break;
            }

            /* calculate remaining length */
            len -= (p - q);
            if (!len)
            {
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                return 0;
            }

            /* get mantissa */
            val->mantissa.length = (*p & 0x80) ? len + 1 : len;
            val->mantissa.value = (ASN1octet_t *)DecMemAlloc(dec, val->mantissa.length);
            if (!val->mantissa.value)
            {
                return 0;
            }
            val->mantissa.value[0] = 0;
            RtlCopyMemory(val->mantissa.value + val->mantissa.length - len, p, len);

            /* scale mantissa */
            switch (head & 0x0c)
            {
            case 0x04:
                /* scaling factor 1 */
                ASN1intx_muloctet(&help, &val->mantissa, 2);
                ASN1intx_free(&val->mantissa);
                val->mantissa = help;
                break;
            case 0x08:
                /* scaling factor 2 */
                ASN1intx_muloctet(&help, &val->mantissa, 4);
                ASN1intx_free(&val->mantissa);
                val->mantissa = help;
                break;
            case 0x0c:
                /* scaling factor 3 */
                ASN1intx_muloctet(&help, &val->mantissa, 8);
                ASN1intx_free(&val->mantissa);
                val->mantissa = help;
                break;
            }

            /* check sign */
            if (head & 0x40)
            {
                ASN1intx_neg(&help, &val->mantissa);
                ASN1intx_free(&val->mantissa);
                val->mantissa = help;
            }
        }
        else
        /* special real values? */
        if (head & 0x40)
        {
            switch (head)
            {
            case 0x40:
                /* PLUS-INFINITY */
                val->type = eReal_PlusInfinity;
                break;
            case 0x41:
                /* MINUS-INFINITY */
                val->type = eReal_MinusInfinity;
                break;
            default:
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                return 0;
            }
        }
        /* decimal encoding */
        else
        {
            char *b;
            char buf[256];

            DecAssert(dec, (head & 0xc0) == 0xc0); 
            RtlCopyMemory(buf, p, len - 1);
            buf[len - 1] = 0;
            ex = 0;
            b = strchr(buf, ',');
            if (b)
            {
                // move the decimal point to the right
                ex -= My_lstrlenA(b+1);
                lstrcpyA(b, b+1);
            }
            // skip leading zeros
            for (b = &buf[0]; '0' == *b; b++)
                ;
            val->type = eReal_Normal;
            val->base = 10;
            ASN1intx_setint32(&val->exponent, ex);
            /*XXX*/
            // missing code here!!!
            // need to set val->mantissa through the decimal digits string
            DecAssert(dec, 0);
            return 0;
        }
    }
    return 1;
}
#endif // ENABLE_REAL

#ifdef ENABLE_EMBEDDED_PDV
/* decode embedded pdv value */
int ASN1BERDecEmbeddedPdv(ASN1decoding_t dec, ASN1uint32_t tag, ASN1embeddedpdv_t *val)
{
    ASN1INTERNdecoding_t d = (ASN1INTERNdecoding_t) dec;
    ASN1uint32_t constructed, len, infinite;
    ASN1uint32_t index;
    ASN1embeddedpdv_identification_t *identification;
    ASN1decoding_t dd, dd2, dd3;
    ASN1octet_t *di, *di2, *di3;

    /* skip tag */
    if (!ASN1BERDecTag(dec, tag, &constructed))
        return 0;

    if (constructed)
    {
        /* constructed? EP-A encoded: */
        /* get length */
        if (!ASN1BERDecLength(dec, &len, &infinite))
            return 0;

        /* then start decoding of constructed value */
        if (! _BERDecConstructed(dec, len, infinite, &dd, &di))
            return 0;
        if (!ASN1BERDecU32Val(dd, 0x80000000, &index))
            return 0;
        if (index != d->parent->epilength)
        {
            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            return 0;
        }
        if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd2, &di2))
            return 0;
        if (!ASN1BERDecPeekTag(dd2, &tag))
            return 0;
        switch (tag)
        {
        case 0x80000000:
            val->identification.o = ASN1embeddedpdv_identification_syntaxes_o;
            if (!ASN1BERDecExplicitTag(dd2, 0x80000000, &dd3, &di3))
                return 0;
            if (!ASN1BERDecObjectIdentifier(dd3, 0x80000000,
                &val->identification.u.syntaxes.abstract))
                return 0;
            if (!ASN1BERDecObjectIdentifier(dd3, 0x80000001,
                &val->identification.u.syntaxes.transfer))
                return 0;
            if (!ASN1BERDecEndOfContents(dd2, dd3, di3))
                return 0;
            break;
        case 0x80000001:
            val->identification.o = ASN1embeddedpdv_identification_syntax_o;
            if (!ASN1BERDecObjectIdentifier(dd2, 0x80000001,
                &val->identification.u.syntax))
                return 0;
            break;
        case 0x80000002:
            val->identification.o =
                ASN1embeddedpdv_identification_presentation_context_id_o;
            if (!ASN1BERDecU32Val(dd2, 0x80000002,
                &val->identification.u.presentation_context_id))
                return 0;
            break;
        case 0x80000003:
            val->identification.o =
                ASN1embeddedpdv_identification_context_negotiation_o;
            if (!ASN1BERDecExplicitTag(dd2, 0x80000003, &dd3, &di3))
                return 0;
            if (!ASN1BERDecU32Val(dd3, 0x80000000, &val->
                identification.u.context_negotiation.presentation_context_id))
                return 0;
            if (!ASN1BERDecObjectIdentifier(dd3, 0x80000001,
                &val->identification.u.context_negotiation.transfer_syntax))
                return 0;
            if (!ASN1BERDecEndOfContents(dd2, dd3, di3))
                return 0;
            break;
        case 0x80000004:
            val->identification.o =
                ASN1embeddedpdv_identification_transfer_syntax_o;
            if (!ASN1BERDecObjectIdentifier(dd2, 0x80000004,
                &val->identification.u.transfer_syntax))
                return 0;
            break;
        case 0x80000005:
            val->identification.o = ASN1embeddedpdv_identification_fixed_o;
            if (!ASN1BERDecNull(dd2, 0x80000005))
                return 0;
            break;
        default:
            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            return 0;
        }
        if (!ASN1BERDecEndOfContents(dd, dd2, di2))
            return 0;
        if (!ASN1DecAddEmbeddedPdvIdentification(d->parent,
            &val->identification))
            return 0;
        val->data_value.o = ASN1embeddedpdv_data_value_encoded_o;
        if (!ASN1BERDecBitString(dd, 0x80000003,
            &val->data_value.u.encoded))
            return 0;
        if (!ASN1BERDecEndOfContents(dec, dd, di))
            return 0;
    }
    else
    {
        /* primitive? EP-B encoded: */
        if (!ASN1BERDecLength(dec, &len, NULL))
            return 0;

        /* then copy value */
        if (!len)
        {
            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            return 0;
        }
        val->data_value.o = ASN1embeddedpdv_data_value_encoded_o;
        val->data_value.u.encoded.length = 8 * (len - 1);
        val->data_value.u.encoded.value = (ASN1octet_t *)DecMemAlloc(dec, len - 1);
        if (!val->data_value.u.encoded.value)
        {
            return 0;
        }
        index = *dec->pos++;
        RtlCopyMemory(val->data_value.u.encoded.value, dec->pos, len - 1);
        identification = ASN1DecGetEmbeddedPdvIdentification(d->parent, index);
        if (!identification)
            return 0;
        val->identification.o = identification->o;
        switch (identification->o)
        {
        case ASN1embeddedpdv_identification_syntaxes_o:
            if (!ASN1DecDupObjectIdentifier(dec, 
                &val->identification.u.syntaxes.abstract,
                &identification->u.syntaxes.abstract))
                return 0;
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.syntaxes.transfer,
                &identification->u.syntaxes.transfer))
                return 0;
            break;
        case ASN1embeddedpdv_identification_syntax_o:
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.syntax,
                &identification->u.syntax))
                return 0;
            break;
        case ASN1embeddedpdv_identification_presentation_context_id_o:
            val->identification.u.presentation_context_id =
                identification->u.presentation_context_id;
            break;
        case ASN1embeddedpdv_identification_context_negotiation_o:
            val->identification.u.context_negotiation.presentation_context_id =
                identification->u.context_negotiation.presentation_context_id;
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.context_negotiation.transfer_syntax,
                &identification->u.context_negotiation.transfer_syntax))
                return 0;
            break;
        case ASN1embeddedpdv_identification_transfer_syntax_o:
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.transfer_syntax,
                &identification->u.transfer_syntax))
                return 0;
            break;
        case ASN1embeddedpdv_identification_fixed_o:
            break;
        }
    }
    return 1;
}
#endif // ENABLE_EMBEDDED_PDV

#ifdef ENABLE_EXTERNAL
/* decode external value */
int ASN1BERDecExternal(ASN1decoding_t dec, ASN1uint32_t tag, ASN1external_t *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1objectidentifier_t id;
    ASN1octetstring_t os;

    /* decode explicit tag */
    if (!ASN1BERDecExplicitTag(dec, tag | 0x20000000, &dd, &di))
        return 0;

    /* peek tag of choice alternative */
    if (!ASN1BERDecPeekTag(dd, &tag))
        return 0;

    /* decode alternative */
    if (tag == 0x6)
    {
        if (!ASN1BERDecObjectIdentifier(dd, 0x6, &id))
            return 0;
        if (!ASN1BERDecPeekTag(dd, &tag))
            return 0;
        if (tag == 0x2)
        {
            val->identification.o =
                ASN1external_identification_context_negotiation_o;
            val->identification.u.context_negotiation.transfer_syntax = id;
            if (!ASN1BERDecU32Val(dd, 0x2, &val->
                identification.u.context_negotiation.presentation_context_id))
                return 0;
            if (!ASN1BERDecPeekTag(dd, &tag))
                return 0;
        }
        else
        {
            val->identification.o = ASN1external_identification_syntax_o;
            val->identification.u.syntax = id;
        }
    }
    else
    if (tag == 0x2)
    {
        val->identification.o =
            ASN1external_identification_presentation_context_id_o;
        if (!ASN1BERDecU32Val(dd, 0x2,
            &val->identification.u.presentation_context_id))
            return 0;
        if (!ASN1BERDecPeekTag(dd, &tag))
            return 0;
    }
    else
    {
        ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
        return 0;
    }

    /* decode optional data value descriptor if present */
    if (tag == 0x7)
    {
        if (!ASN1BERDecZeroCharString(dd, 0x7, &val->data_value_descriptor))
            return 0;
        if (!ASN1BERDecPeekTag(dd, &tag))
            return 0;
    }
    else
    {
        val->data_value_descriptor = NULL;
    }

    /* decode data value alternative */
    switch (tag)
    {
    case 0:
        val->data_value.o = ASN1external_data_value_notation_o;
        if (!ASN1BERDecOpenType(dd, &val->data_value.u.notation))
            return 0;
        break;
    case 1:
        val->data_value.o = ASN1external_data_value_encoded_o;
        if (!ASN1BERDecOctetString(dd, 0x4, &os))
            return 0;
        val->data_value.u.encoded.value = os.value;
        val->data_value.u.encoded.length = os.length * 8;
        break;
    case 2:
        val->data_value.o = ASN1external_data_value_encoded_o;
        if (!ASN1BERDecBitString(dd, 0x3, &val->data_value.u.encoded))
            return 0;
        break;
    default:
        ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
        return 0;
    }

    /* end of constructed (explicit tagged) value */
    if (!ASN1BERDecEndOfContents(dec, dd, di))
        return 0;

    return 1;
}
#endif // ENABLE_EXTERNAL

/* decode generalized time value */
int ASN1BERDecGeneralizedTime(ASN1decoding_t dec, ASN1uint32_t tag, ASN1generalizedtime_t *val)
{
    ASN1ztcharstring_t time;
    if (ASN1BERDecZeroCharString(dec, tag, &time))
    {
        int rc = ASN1string2generalizedtime(val, time);
        DecMemFree(dec, time);
        if (rc)
        {
            return 1;
        }
        ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
    }
    return 0;
}

/* decode multibyte string value */
int ASN1BERDecZeroMultibyteString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1ztcharstring_t *val)
{
    return ASN1BERDecZeroCharString(dec, tag, val);
}

int ASN1BERDecMultibyteString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1charstring_t *val)
{
    return ASN1BERDecCharString(dec, tag, val);
}

/* decode null value */
int ASN1BERDecNull(ASN1decoding_t dec, ASN1uint32_t tag)
{
    ASN1uint32_t len;
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        if (ASN1BERDecLength(dec, &len, NULL))
        {
            if (! len)
            {
                return 1;
            }
            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
        }
    }
    return 0;
}

/* decode object identifier value */
int ASN1BERDecObjectIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, ASN1objectidentifier_t *val)
{
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        ASN1uint32_t len, i, v;
        ASN1octet_t *data, *p;
        ASN1uint32_t nelem;
        ASN1objectidentifier_t q;

        if (ASN1BERDecLength(dec, &len, NULL))
        {
            data = dec->pos;
            dec->pos += len;
            nelem = 1;
            for (i = 0, p = data; i < len; i++, p++)
            {
                if (!(*p & 0x80))
                    nelem++;
            }
            *val = q = DecAllocObjectIdentifier(dec, nelem);
            if (q)
            {
                v = 0;
                for (i = 0, p = data; i < len; i++, p++)
                {
                    v = (v << 7) | (*p & 0x7f);
                    if (!(*p & 0x80))
                    {
                        if (q == *val)
                        { // first id
                            q->value = v / 40;
                            if (q->value > 2)
                                q->value = 2;
                            q->next->value = v - 40 * q->value;
                            q = q->next->next;
                        }
                        else
                        {
                            q->value = v;
                            q = q->next;
                        }
                        v = 0;
                    }
                }
                return 1;
            }
        }
    }
    return 0;
}

/* decode object identifier value */
int ASN1BERDecObjectIdentifier2(ASN1decoding_t dec, ASN1uint32_t tag, ASN1objectidentifier2_t *val)
{
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        ASN1uint32_t len, i, v;
        ASN1octet_t *data, *p;
        //ASN1objectidentifier_t q;

        if (ASN1BERDecLength(dec, &len, NULL))
        {
            if (len <= 16) // lonchanc: hard-coded value 16 to be consistent with ASN1objectidentifier2_t
            {
                data = dec->pos;
                dec->pos += len;
                val->count = 0;
                v = 0;
                for (i = 0, p = data; i < len; i++, p++)
                {
                    v = (v << 7) | (*p & 0x7f);
                    if (!(*p & 0x80))
                    {
                        if (! val->count)
                        { // first id
                            val->value[0] = v / 40;
                            if (val->value[0] > 2)
                                val->value[0] = 2;
                            val->value[1] = v - 40 * val->value[0];
                            val->count = 2;
                        }
                        else
                        {
                            val->value[val->count++] = v;
                        }
                        v = 0;
                    }
                }
                return 1;
            }
            else
            {
                ASN1DecSetError(dec, ASN1_ERR_LARGE);
            }
        }
    }
    return 0;
}

/* decode integer into signed 8 bit value */
int ASN1BERDecS8Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1int8_t *val)
{
    /* skip tag */
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        ASN1uint32_t len;
        /* get length */
        if (ASN1BERDecLength(dec, &len, NULL))
        {
            /* get value */
            if (1 == len)
            {
                *val = *dec->pos++;
                return 1;
            }
            ASN1DecSetError(dec, (len < 1) ? ASN1_ERR_CORRUPT : ASN1_ERR_LARGE);
        }
    }
    return 0;
}

/* decode integer into signed 16 bit value */
int ASN1BERDecS16Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1int16_t *val)
{
    /* skip tag */
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        ASN1uint32_t len;
        /* get length */
        if (ASN1BERDecLength(dec, &len, NULL))
        {
            /* get value */
            switch (len)
            {
            case 1:
                *val = *dec->pos++;
                break;
            case 2:
                *val = (*dec->pos << 8) | dec->pos[1];
                dec->pos += 2;
                break;
            default:
                ASN1DecSetError(dec, (len < 1) ? ASN1_ERR_CORRUPT : ASN1_ERR_LARGE);
                return 0;
            }
            return 1;
        }
    }
    return 0;
}

const ASN1int32_t c_nSignMask[] = { 0xFFFFFF00, 0xFFFF0000, 0xFF000000, 0 };

/* decode integer into signed 32 bit value */
int ASN1BERDecS32Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1int32_t *val)
{
    /* skip tag */
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        ASN1uint32_t len;
        /* get length */
        if (ASN1BERDecLength(dec, &len, NULL))
        {
            int fSigned = 0x80 & *dec->pos;

            /* get value */
            switch (len)
            {
            case 1:
                *val = *dec->pos++;
                break;
            case 2:
                *val = (*dec->pos << 8) | dec->pos[1];
                dec->pos += 2;
                break;
            case 3:
                *val = (*dec->pos << 16) | (dec->pos[1] << 8) | dec->pos[2];
                dec->pos += 3;
                break;
            case 4:
                *val = (*dec->pos << 24) | (dec->pos[1] << 16) |
                    (dec->pos[2] << 8) | dec->pos[3];
                dec->pos += 4;
                break;
            default:
                ASN1DecSetError(dec, (len < 1) ? ASN1_ERR_CORRUPT : ASN1_ERR_LARGE);
                return 0;
            }
            if (fSigned)
            {
                *val |= c_nSignMask[len-1];
            }
            return 1;
        }
    }
    return 0;
}

/* decode integer into intx value */
int ASN1BERDecSXVal(ASN1decoding_t dec, ASN1uint32_t tag, ASN1intx_t *val)
{
    /* skip tag */
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        ASN1uint32_t len;
        /* get length */
        if (ASN1BERDecLength(dec, &len, NULL))
        {
            /* get value */
            if (len >= 1)
            {
                val->length = len;
                val->value = (ASN1octet_t *)DecMemAlloc(dec, len);
                if (val->value)
                {
                    RtlCopyMemory(val->value, dec->pos, len);
                    dec->pos += len;
                    return 1;
                }
            }
            else
            {
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            }
        }
    }
    return 0;
}

/* decode integer into unsigned 8 bit value */
int ASN1BERDecU8Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint8_t *val)
{
    /* skip tag */
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        ASN1uint32_t len;
        /* get length */
        if (ASN1BERDecLength(dec, &len, NULL))
        {
            /* get value */
            switch (len)
            {
            case 1:
                *val = *dec->pos++;
                return 1;
            case 2:
                if (0 == *dec->pos)
                {
                    *val = dec->pos[1];
                    dec->pos += 2;
                    return 1;
                }
                // intentionally fall through
            default:
                ASN1DecSetError(dec, (len < 1) ? ASN1_ERR_CORRUPT : ASN1_ERR_LARGE);
                break;
            }
        }
    }
    return 0;
}

/* decode integer into unsigned 16 bit value */
int ASN1BERDecU16Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint16_t *val)
{
    /* skip tag */
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        ASN1uint32_t len;
        /* get length */
        if (ASN1BERDecLength(dec, &len, NULL))
        {
            /* get value */
            switch (len)
            {
            case 1:
                *val = *dec->pos++;
                return 1;
            case 2:
                *val = (*dec->pos << 8) | dec->pos[1];
                dec->pos += 2;
                return 1;
            case 3:
                if (0 == *dec->pos)
                {
                    *val = (dec->pos[1] << 8) | dec->pos[2];
                    dec->pos += 3;
                    return 1;
                }
                // intentionally fall through
            default:
                ASN1DecSetError(dec, (len < 1) ? ASN1_ERR_CORRUPT : ASN1_ERR_LARGE);
                break;
            }
        }
    }
    return 0;
}

/* decode utc time value */
int ASN1BERDecUTCTime(ASN1decoding_t dec, ASN1uint32_t tag, ASN1utctime_t *val)
{
    ASN1ztcharstring_t time;
    if (ASN1BERDecZeroCharString(dec, tag, &time))
    {
        int rc = ASN1string2utctime(val, time);
        DecMemFree(dec, time);
        if (rc)
        {
            return 1;
        }
        ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
    }
    return 0;
}

/* decode zero terminated string value */
int ASN1BERDecZeroCharString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1ztcharstring_t *val)
{
    ASN1uint32_t constructed, len, infinite;
    ASN1ztcharstring_t c;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t lv, lc;

    /* skip tag */
    if (ASN1BERDecTag(dec, tag, &constructed))
    {
        /* get length */
        if (ASN1BERDecLength(dec, &len, &infinite))
        {
            if (constructed)
            {
                /* constructed? then start decoding of constructed value */
                *val = NULL;
                if (_BERDecConstructed(dec, len, infinite, &dd, &di))
                {
                    while (ASN1BERDecNotEndOfContents(dd, di))
                    {
                        if (ASN1BERDecZeroCharString(dd, 0x4, &c))
                        {
                            lv = My_lstrlenA(*val);
                            lc = My_lstrlenA(c);
                            if (lc)
                            {
                                /* resize value */
                                *val = (char *)DecMemReAlloc(dd, *val, lv + lc + 1);
                                if (*val)
                                {
                                    /* concat strings */
                                    RtlCopyMemory(*val + lv, c, lc + 1);

                                    /* free unused string */
                                    DecMemFree(dec, c);
                                }
                                else
                                {
                                    return 0;
                                }
                            }
                        }
                        else
                        {
                            return 0;
                        }
                    } // while
                    return ASN1BERDecEndOfContents(dec, dd, di);
                }
            }
            else
            {
                /* primitive? then copy value */
                *val = (char *)DecMemAlloc(dec, len + 1);
                if (*val)
                {
                    RtlCopyMemory(*val, dec->pos, len);
                    (*val)[len] = 0;
                    dec->pos += len;
                    return 1;
                }
            }
        }
    }
    return 0;
}

/* decode zero terminated 16 bit string value */
int ASN1BERDecZeroChar16String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1ztchar16string_t *val)
{
    ASN1uint32_t constructed, len, infinite;
    ASN1ztchar16string_t c;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t i;
    ASN1uint32_t lv, lc;

    /* skip tag */
    if (ASN1BERDecTag(dec, tag, &constructed))
    {
        /* get length */
        if (ASN1BERDecLength(dec, &len, &infinite))
        {
            if (constructed)
            {
                /* constructed? then start decoding of constructed value */
                *val = NULL;
                if (_BERDecConstructed(dec, len, infinite, &dd, &di))
                {
                    while (ASN1BERDecNotEndOfContents(dd, di))
                    {
                        if (ASN1BERDecZeroChar16String(dd, 0x4, &c))
                        {
                            lv = ASN1str16len(*val);
                            lc = ASN1str16len(c);
                            if (lc)
                            {
                                /* resize value */
                                *val = (ASN1char16_t *)DecMemReAlloc(dd, *val, (lv + lc + 1) * sizeof(ASN1char16_t));
                                if (*val)
                                {
                                    /* concat strings */
                                    RtlCopyMemory(*val + lv, c, (lc + 1) * sizeof(ASN1char16_t));

                                    /* free unused string */
                                    DecMemFree(dec, c);
                                }
                                else
                                {
                                    return 0;
                                }
                            }
                        }
                        else
                        {
                            return 0;
                        }
                    } // while
                    return ASN1BERDecEndOfContents(dec, dd, di);
                }
            }
            else
            {
                /* primitive? then copy value */
                *val = (ASN1char16_t *)DecMemAlloc(dec, (len + 1) * sizeof(ASN1char16_t));
                if (*val)
                {
                    for (i = 0; i < len; i++)
                    {
                        (*val)[i] = (*dec->pos << 8) | dec->pos[1];
                        dec->pos += 2;
                    }
                    (*val)[len] = 0;
                    return 1;
                }
            }
        }
    }
    return 0;
}

/* decode zero terminated 32 bit string value */
int ASN1BERDecZeroChar32String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1ztchar32string_t *val)
{
    ASN1uint32_t constructed, len, infinite;
    ASN1ztchar32string_t c;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t i;
    ASN1uint32_t lv, lc;

    /* skip tag */
    if (ASN1BERDecTag(dec, tag, &constructed))
    {
        /* get length */
        if (ASN1BERDecLength(dec, &len, &infinite))
        {
            if (constructed)
            {
                /* constructed? then start decoding of constructed value */
                *val = (ASN1char32_t *)DecMemAlloc(dec, sizeof(ASN1char32_t));
                if (*val)
                {
                    **val = 0;
                    if (_BERDecConstructed(dec, len, infinite, &dd, &di))
                    {
                        while (ASN1BERDecNotEndOfContents(dd, di))
                        {
                            if (ASN1BERDecZeroChar32String(dd, 0x4, &c))
                            {
                                lv = ASN1str32len(*val);
                                lc = ASN1str32len(c);
                                if (lc)
                                {
                                    /* resize value */
                                    *val = (ASN1char32_t *)DecMemReAlloc(dd, *val, (lv + lc + 1) * sizeof(ASN1char32_t));
                                    if (*val)
                                    {
                                        /* concat strings */
                                        RtlCopyMemory(*val + lv, c, (lc + 1) * sizeof(ASN1char32_t));

                                        /* free unused string */
                                        DecMemFree(dec, c);
                                    }
                                }
                            }
                            else
                            {
                                return 0;
                            }
                        }
                        return ASN1BERDecEndOfContents(dec, dd, di);
                    }
                }
            }
            else
            {
                /* primitive? then copy value */
                *val = (ASN1char32_t *)DecMemAlloc(dec, (len + 1) * sizeof(ASN1char32_t));
                if (*val)
                {
                    for (i = 0; i < len; i++)
                    {
                        (*val)[i] = (*dec->pos << 24) | (dec->pos[1] << 16) |
                                    (dec->pos[2] << 8) | dec->pos[3];;
                        dec->pos += 4;
                    }
                    (*val)[len] = 0;
                    return 1;
                }
            }
        }
    }
    return 0;
}

/* skip a value */
int ASN1BERDecSkip(ASN1decoding_t dec)
{
    ASN1uint32_t tag;
    ASN1uint32_t constructed, len, infinite;
    ASN1decoding_t dd;
    ASN1octet_t *di;

    /* set warning flag */
    ASN1DecSetError(dec, ASN1_WRN_EXTENDED);

    /* read tag */
    if (ASN1BERDecPeekTag(dec, &tag))
    {
        if (ASN1BERDecTag(dec, tag, &constructed))
        {
            if (constructed)
            {
                /* constructed? then get length */
                if (ASN1BERDecLength(dec, &len, &infinite))
                {
                    if (!infinite)
                    {
                        /* skip value */
                        dec->pos += len;
                        // remove the above warning set previously
                        ASN1DecSetError(dec, ASN1_SUCCESS);
                        return 1;
                    } 

                    /* start skipping of constructed value */
                    if (_BERDecConstructed(dec, len, infinite, &dd, &di))
                    {
                        while (ASN1BERDecNotEndOfContents(dd, di))
                        {
                            if (ASN1BERDecSkip(dd))
                            {
                                continue;
                            }
                            return 0;
                        }
                        if (ASN1BERDecEndOfContents(dec, dd, di))
                        {
                            // remove the above warning set previously
                            ASN1DecSetError(dec, ASN1_SUCCESS);
                            return 1;
                        }
                        return 0;
                    }
                }
            }
            else
            {
                /* primitive? then get length */
                if (ASN1BERDecLength(dec, &len, NULL))
                {
                    /* skip value */
                    dec->pos += len;
                    // remove the above warning set previously
                    ASN1DecSetError(dec, ASN1_SUCCESS);
                    return 1;
                }
            }
        }
    }
    return 0;
}

/* decode an open type value */
int _BERDecOpenType(ASN1decoding_t dec, ASN1open_t *val, ASN1uint32_t fNoCopy)
{
    ASN1uint32_t tag;
    ASN1uint32_t constructed, len, infinite;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1octet_t *p;

    p = dec->pos;

    /* skip tag */
    if (ASN1BERDecPeekTag(dec, &tag))
    {
        if (ASN1BERDecTag(dec, tag, &constructed))
        {
            if (constructed)
            {
                /* constructed? then get length */
                if (ASN1BERDecLength(dec, &len, &infinite))
                {
                    if (!infinite)
                    {
                        /* skip value */
                        dec->pos += len;
                        goto MakeCopy;
                    } 

                    /* start decoding of constructed value */
                    if (_BERDecConstructed(dec, len, infinite, &dd, &di))
                    {
                        while (ASN1BERDecNotEndOfContents(dd, di))
                        {
                            if (ASN1BERDecSkip(dd))
                            {
                                continue;
                            }
                            return 0;
                        }
                        if (ASN1BERDecEndOfContents(dec, dd, di))
                        {
                            goto MakeCopy;
                        }
                    }
                }
                return 0;
            }
            else
            {
                /* primitive? then get length */
                if (ASN1BERDecLength(dec, &len, NULL))
                {
                    /* skip value */
                    dec->pos += len;
                }
                else
                {
                    return 0;
                }
            }

        MakeCopy:

            // clean up unused fields
            // val->decoded = NULL;
            // val->userdata = NULL;

            /* copy skipped value */
            val->length = (ASN1uint32_t) (dec->pos - p);
            if (fNoCopy)
            {
                val->encoded = p;
                return 1;
            }
            else
            {
                val->encoded = (ASN1octet_t *)DecMemAlloc(dec, val->length);
                if (val->encoded)
                {
                    RtlCopyMemory(val->encoded, p, val->length);
                    return 1;
                }
            }
        }
    }
    return 0;
}

/* decode an open type value, making a copy */
int ASN1BERDecOpenType(ASN1decoding_t dec, ASN1open_t *val)
{
    return _BERDecOpenType(dec, val, FALSE);
}

/* decode an open type value, no copy */
int ASN1BERDecOpenType2(ASN1decoding_t dec, ASN1open_t *val)
{
    return _BERDecOpenType(dec, val, TRUE);
}

/* finish decoding */
int ASN1BERDecFlush(ASN1decoding_t dec)
{
    /* calculate length */
    dec->len = (ASN1uint32_t) (dec->pos - dec->buf);

    /* set WRN_NOEOD if data left */
    if (dec->len >= dec->size)
    {
        DecAssert(dec, dec->len == dec->size);
        return 1;
    }
    ASN1DecSetError(dec, ASN1_WRN_NOEOD);
    return 1;
}

#endif // ENABLE_BER


#ifdef ENABLE_BER

/* encode a string value */
int ASN1BEREncCharString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1char_t *val)
{
    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        /* encode length */
        if (ASN1BEREncLength(enc, len))
        {
            RtlCopyMemory(enc->pos, val, len);
            enc->pos += len;
            return 1;
        }
    }
    return 0;
}

/* encode a string value (CER) */
int ASN1CEREncCharString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1char_t *val)
{
    ASN1uint32_t n;

    if (len <= 1000)
    {
        /* encode tag */
        if (ASN1BEREncTag(enc, tag))
        {
            /* encode length */
            if (ASN1BEREncLength(enc, len))
            {
                RtlCopyMemory(enc->pos, val, len);
                enc->pos += len;
                return 1;
            }
        }
    }
    else
    {
        ASN1uint32_t nLenOff;
        /* encode value as constructed, using segments of 1000 octets */
        if (ASN1BEREncExplicitTag(enc, tag, &nLenOff))
        {
            while (len)
            {
                n = len > 1000 ? 1000 : len;
                if (ASN1BEREncTag(enc, 0x4))
                {
                    if (ASN1BEREncLength(enc, n))
                    {
                        RtlCopyMemory(enc->pos, val, n);
                        enc->pos += n;
                        val += n;
                        len -= n;
                    }
                    else
                    {
                        return 0;
                    }
                }
                else
                {
                    return 0;
                }
            }
            return ASN1BEREncEndOfContents(enc, nLenOff);
        }
    }
    return 0;
}

/* encode a 16 bit string value */
int ASN1BEREncChar16String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1char16_t *val)
{
    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        /* encode length */
        if (ASN1BEREncLength(enc, len * sizeof(ASN1char16_t)))
        {
            while (len--)
            {
                *enc->pos++ = (ASN1octet_t)(*val >> 8);
                *enc->pos++ = (ASN1octet_t)(*val);
                val++;
            }
        }
        return 1;
    }
    return 0;
}

/* encode a 16 bit string value (CER) */
int ASN1CEREncChar16String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1char16_t *val)
{
    ASN1uint32_t n;

    if (len <= 1000 / sizeof(ASN1char16_t))
    {
        /* encode tag */
        if (ASN1BEREncTag(enc, tag))
        {
            /* encode length */
            if (ASN1BEREncLength(enc, len * sizeof(ASN1char16_t)))
            {
                while (len--)
                {
                    *enc->pos++ = (ASN1octet_t)(*val >> 8);
                    *enc->pos++ = (ASN1octet_t)(*val);
                    val++;
                }
                return 1;
            }
        }
    }
    else
    {
        ASN1uint32_t nLenOff;
        /* encode value as constructed, using segments of 1000 octets */
        if (ASN1BEREncExplicitTag(enc, tag, &nLenOff))
        {
            while (len)
            {
                n = len > 1000 / sizeof(ASN1char16_t) ?
                    1000 / sizeof(ASN1char16_t) : len;
                if (ASN1BEREncTag(enc, 0x4))
                {
                    if (ASN1BEREncLength(enc, n))
                    {
                        while (len--)
                        {
                            *enc->pos++ = (ASN1octet_t)(*val >> 8);
                            *enc->pos++ = (ASN1octet_t)(*val);
                            val++;
                        }
                        len -= n;
                    }
                    else
                    {
                        return 0;
                    }
                }
                else
                {
                    return 0;
                }
            }
            return ASN1BEREncEndOfContents(enc, nLenOff);
        }
    }
    return 0;
}

/* encode a 32 bit string value */
int ASN1BEREncChar32String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1char32_t *val)
{
    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        /* encode length */
        if (ASN1BEREncLength(enc, len * sizeof(ASN1char32_t)))
        {
            while (len--)
            {
                *enc->pos++ = (ASN1octet_t)(*val >> 24);
                *enc->pos++ = (ASN1octet_t)(*val >> 16);
                *enc->pos++ = (ASN1octet_t)(*val >> 8);
                *enc->pos++ = (ASN1octet_t)(*val);
                val++;
            }
            return 1;
        }
    }
    return 0;
}

/* encode a 32 bit string value (CER) */
int ASN1CEREncChar32String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1char32_t *val)
{
    ASN1uint32_t n;

    if (len <= 1000 / sizeof(ASN1char32_t))
    {
        /* encode tag */
        if (ASN1BEREncTag(enc, tag))
        {
            /* encode length */
            if (ASN1BEREncLength(enc, len * sizeof(ASN1char32_t)))
            {
                while (len--)
                {
                    *enc->pos++ = (ASN1octet_t)(*val >> 24);
                    *enc->pos++ = (ASN1octet_t)(*val >> 16);
                    *enc->pos++ = (ASN1octet_t)(*val >> 8);
                    *enc->pos++ = (ASN1octet_t)(*val);
                    val++;
                }
                return 1;
            }
        }
    }
    else
    {
        ASN1uint32_t nLenOff;
        /* encode value as constructed, using segments of 1000 octets */
        if (ASN1BEREncExplicitTag(enc, tag, &nLenOff))
        {
            while (len)
            {
                n = len > 1000 / sizeof(ASN1char32_t) ?
                    1000 / sizeof(ASN1char32_t) : len;
                if (ASN1BEREncTag(enc, 0x4))
                {
                    if (ASN1BEREncLength(enc, n))
                    {
                        while (len--)
                        {
                            *enc->pos++ = (ASN1octet_t)(*val >> 24);
                            *enc->pos++ = (ASN1octet_t)(*val >> 16);
                            *enc->pos++ = (ASN1octet_t)(*val >> 8);
                            *enc->pos++ = (ASN1octet_t)(*val);
                            val++;
                        }
                        len -= n;
                    }
                    else
                    {
                        return 0;
                    }
                }
                else
                {
                    return 0;
                }
            } // while
            return ASN1BEREncEndOfContents(enc, nLenOff);
        }
    }
    return 0;
}

/* encode a bit string value */
int ASN1BEREncBitString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1octet_t *val)
{
    ASN1uint32_t noctets = (len + 7) / 8;

    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        /* encode length */
        if (ASN1BEREncLength(enc, noctets + 1))
        {
            ASN1uint32_t cUnusedBits = (7 - ((len + 7) & 7));
            *enc->pos++ = (ASN1octet_t) cUnusedBits;
            RtlCopyMemory(enc->pos, val, noctets);
            enc->pos += noctets;
            EncAssert(enc, noctets >= 1);
            if (cUnusedBits)
            {
                EncAssert(enc, 8 >= cUnusedBits);
                *(enc->pos - 1) &= bitmsk2[8 - cUnusedBits];
            }
            return 1;
        }
    }
    return 0;
}

/* encode a bit string value (CER) */
int ASN1CEREncBitString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1octet_t *val)
{
    ASN1uint32_t noctets;
    ASN1uint32_t n;

    noctets = (len + 7) / 8;
    if (noctets + 1 <= 1000)
    {
        /* encode tag */
        if (ASN1BEREncTag(enc, tag))
        {
            /* encode length */
            if (ASN1BEREncLength(enc, noctets + 1))
            {
                *enc->pos++ = (ASN1octet_t) (7 - ((len + 7) & 7));
                RtlCopyMemory(enc->pos, val, noctets);
                enc->pos += noctets;
                return 1;
            }
        }
    }
    else
    {
        ASN1uint32_t nLenOff;
        /* encode value as constructed, using segments of 1000 octets */
        if (ASN1BEREncExplicitTag(enc, tag, &nLenOff))
        {
            while (noctets)
            {
                n = len > 999 ? 999 : len;
                if (ASN1BEREncTag(enc, 0x3))
                {
                    if (ASN1BEREncLength(enc, n + 1))
                    {
                        *enc->pos++ = (ASN1octet_t) (n < len ? 0 : 7 - ((len + 7) & 7));
                        RtlCopyMemory(enc->pos, val, n);
                        enc->pos += n;
                        val += n;
                        noctets -= n;
                    }
                    else
                    {
                        return 0;
                    }
                }
                else
                {
                    return 0;
                }
            } // while
            return ASN1BEREncEndOfContents(enc, nLenOff);
        }
    }
    return 0;
}

#ifdef ENABLE_GENERALIZED_CHAR_STR
/* encode a character string value */
int ASN1BEREncCharacterString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1characterstring_t *val)
{
    ASN1uint32_t index;
    ASN1uint32_t flag;

    /* search identification */
    if (!ASN1EncSearchCharacterStringIdentification(((ASN1INTERNencoding_t) enc)->parent,
        &val->identification, &index, &flag))
        return 0;
    if (index > 255)
        flag = 1;

    if (flag)
    {
        ASN1uint32_t nLenOff_, nLenOff0, nLenOff1;

        /* CS-A encoding: */
        /* encode as constructed value */
        if (!ASN1BEREncExplicitTag(enc, tag, &nLenOff_))
            return 0;

        /* encode index */
        if (!ASN1BEREncU32(enc, 0x80000000, index))
            return 0;

        /* encode tag of identification */
        if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
            return 0;

        /* encode identification */
        switch (val->identification.o)
        {
        case ASN1characterstring_identification_syntaxes_o:
            if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff1))
                return 0;
            if (!ASN1BEREncObjectIdentifier(enc, 0x80000000,
                &val->identification.u.syntaxes.abstract))
                return 0;
            if (!ASN1BEREncObjectIdentifier(enc, 0x80000001,
                &val->identification.u.syntaxes.transfer))
                return 0;
            if (!ASN1BEREncEndOfContents(enc, nLenOff1))
                return 0;
            break;
        case ASN1characterstring_identification_syntax_o:
            if (!ASN1BEREncObjectIdentifier(enc, 0x80000001,
                &val->identification.u.syntax))
                return 0;
            break;
        case ASN1characterstring_identification_presentation_context_id_o:
            if (!ASN1BEREncU32(enc, 0x80000002,
                val->identification.u.presentation_context_id))
                return 0;
            break;
        case ASN1characterstring_identification_context_negotiation_o:
            if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff1))
                return 0;
            if (!ASN1BEREncU32(enc, 0x80000000, val->
                identification.u.context_negotiation.presentation_context_id))
                return 0;
            if (!ASN1BEREncObjectIdentifier(enc, 0x80000001,
                &val->identification.u.context_negotiation.transfer_syntax))
                return 0;
            if (!ASN1BEREncEndOfContents(enc, nLenOff1))
                return 0;
            break;
        case ASN1characterstring_identification_transfer_syntax_o:
            if (!ASN1BEREncObjectIdentifier(enc, 0x80000004,
                &val->identification.u.transfer_syntax))
                return 0;
            break;
        case ASN1characterstring_identification_fixed_o:
            if (!ASN1BEREncNull(enc, 0x80000005))
                return 0;
            break;
        default:
            ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
            return 0;
        }

        /* end of identification */
        if (!ASN1BEREncEndOfContents(enc, nLenOff0))
            return 0;

        /* encode data value */
        switch (val->data_value.o)
        {
        case ASN1characterstring_data_value_notation_o:
            if (!ASN1BEREncOctetString(enc, 0x80000002,
                val->data_value.u.notation.length,
                val->data_value.u.notation.encoded))
                return 0;
            break;
        case ASN1characterstring_data_value_encoded_o:
            if (!ASN1BEREncOctetString(enc, 0x80000002,
                val->data_value.u.encoded.length,
                val->data_value.u.encoded.value))
                return 0;
            break;
        default:
            ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
            return 0;
        }

        /* end of character string */
        if (!ASN1BEREncEndOfContents(enc, nLenOff_))
            return 0;
    }
    else
    {
        /* CS-B encoding: */
        /* encode tag */
        if (!ASN1BEREncTag(enc, tag))
            return 0;

        /* encode data value */
        switch (val->data_value.o)
        {
        case ASN1characterstring_data_value_notation_o:
            if (!ASN1BEREncLength(enc,
                val->data_value.u.notation.length + 1))
                return 0;
            *enc->pos++ = (ASN1octet_t) index;
            RtlCopyMemory(enc->pos, val->data_value.u.notation.encoded,
                val->data_value.u.notation.length);
            enc->pos += val->data_value.u.notation.length;
            break;
        case ASN1characterstring_data_value_encoded_o:
            if (!ASN1BEREncLength(enc,
                val->data_value.u.encoded.length + 1))
                return 0;
            *enc->pos++ = (ASN1octet_t) index;
            RtlCopyMemory(enc->pos, val->data_value.u.encoded.value,
                val->data_value.u.encoded.length);
            enc->pos += val->data_value.u.encoded.length;
            break;
        default:
            ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
            return 0;
        }
    }
    return 1;
}
#endif // ENABLE_GENERALIZED_CHAR_STR

#ifdef ENABLE_DOUBLE
/* encode a real value */
int ASN1BEREncDouble(ASN1encoding_t enc, ASN1uint32_t tag, double d)
{
    double mantissa;
    int exponent;
    ASN1uint32_t nmoctets;
    ASN1uint32_t neoctets;
    ASN1octet_t head;
    ASN1uint32_t sign;
    ASN1uint32_t len;
    ASN1octet_t mASN1octets[16]; /* should be enough */
    ASN1octet_t eASN1octets[16]; /* should be enough */

    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        /* check for PLUS_INFINITY */
        if (ASN1double_ispinf(d))
        {
            /* encode length */
            if (ASN1BEREncLength(enc, 1))
            {
                /* encode value */
                *enc->pos++ = 0x40;
                return 1;
            }
        }
        else
        /* check for MINUS_INFINITY */
        if (ASN1double_isminf(d))
        {
            /* encode length */
            if (ASN1BEREncLength(enc, 1))
            {
                /* encode value */
                *enc->pos++ = 0x41;
                return 1;
            }
        }
        else
        /* check for bad real value */
        if (finite(d))
        {
            /* encode normal real value */

            /* split into mantissa and exponent */
            mantissa = frexp(d, &exponent);

            /* check for zero value */
            if (mantissa == 0.0 && exponent == 0)
            {
                /* encode zero length */
                return ASN1BEREncLength(enc, 0);
            }

            /* get sign bit */
            if (mantissa < 0.0)
            {
                sign = 1;
                mantissa = -mantissa;
            }
            else
            {
                sign = 0;
            }

            /* encode mantissa */
            nmoctets = 0;
            while (mantissa != 0.0 && nmoctets < sizeof(mASN1octets))
            {
                mantissa *= 256.0;
                exponent -= 8;
                mASN1octets[nmoctets++] = (int)mantissa;
                mantissa -= (double)(int)mantissa;
            }

            /* encode exponent and create head octet of encoded value */
            head = (ASN1octet_t) (0x80 | (sign << 6));
            if (exponent <= 0x7f && exponent >= -0x80)
            {
                eASN1octets[0] = (ASN1octet_t)(exponent);
                neoctets = 1;
            }
            else
            if (exponent <= 0x7fff && exponent >= -0x8000)
            {
                eASN1octets[0] = (ASN1octet_t)(exponent >> 8);
                eASN1octets[1] = (ASN1octet_t)(exponent);
                neoctets = 2;
                head |= 0x01;
            }
            else
            if (exponent <= 0x7fffff && exponent >= -0x800000)
            {
                eASN1octets[0] = (ASN1octet_t)(exponent >> 16);
                eASN1octets[1] = (ASN1octet_t)(exponent >> 8);
                eASN1octets[2] = (ASN1octet_t)(exponent);
                neoctets = 3;
                head |= 0x02;
            }
            else
            {
                eASN1octets[0] = 4; /* XXX does not work if ASN1int32_t != int */
                eASN1octets[1] = (ASN1octet_t)(exponent >> 24);
                eASN1octets[2] = (ASN1octet_t)(exponent >> 16);
                eASN1octets[3] = (ASN1octet_t)(exponent >> 8);
                eASN1octets[4] = (ASN1octet_t)(exponent);
                neoctets = 5;
                head |= 0x03;
            }

            /* encode length into first octet */
            len = 1 + neoctets + nmoctets;
            if (ASN1BEREncLength(enc, len))
            {
                /* put head octet, mantissa and exponent */
                *enc->pos++ = head;
                RtlCopyMemory(enc->pos, eASN1octets, neoctets);
                enc->pos += neoctets;
                RtlCopyMemory(enc->pos, mASN1octets, nmoctets);
                enc->pos += nmoctets;
                return 1;
            }
        }
        else
        {
            ASN1EncSetError(enc, ASN1_ERR_BADREAL);
        }
    }
    /* finished */
    return 0;
}
#endif // ENABLE_DOUBLE

#ifdef ENABLE_REAL
/* encode a real value */
int ASN1BEREncReal(ASN1encoding_t enc, ASN1uint32_t tag, ASN1real_t *val)
{
    ASN1intx_t mantissa;
    ASN1intx_t exponent;
    ASN1intx_t help;
    ASN1uint32_t nmoctets;
    ASN1uint32_t neoctets;
    ASN1octet_t head;
    ASN1uint32_t sign;
    ASN1uint32_t len;
    ASN1octet_t mASN1octets[256]; /* should be enough */
    ASN1octet_t eASN1octets[256]; /* should be enough */

    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        /* check for PLUS_INFINITY */
        if (val->type == eReal_PlusInfinity)
        {
            /* encode length */
            if (ASN1BEREncLength(enc, 1))
            {
                /* encode value */
                *enc->pos++ = 0x40;
                return 1;
            }
        }
        else
        /* check for MINUS_INFINITY */
        if (val->type == eReal_MinusInfinity)
        {
            /* encode length */
            if (ASN1BEREncLength(enc, 1))
            {
                /* encode value */
                *enc->pos++ = 0x41;
                return 1;
            }
        }
        /* encode normal real value */
        else
        {
            /* check for zero value */
            if (!ASN1intx_cmp(&val->mantissa, &ASN1intx_0))
            {
                /* encode zero length */
                return ASN1BEREncLength(enc, 0);
            }

            /* get sign bit */
            if (val->mantissa.value[0] > 0x7f)
            {
                sign = 1;
                ASN1intx_neg(&mantissa, &val->mantissa);
            }
            else
            {
                sign = 0;
                if (! ASN1intx_dup(&mantissa, &val->mantissa))
                {
                    return 0;
                }
            }
            if (! ASN1intx_dup(&exponent, &val->exponent))
            {
                return 0;
            }

            /* encode mantissa */
            nmoctets = ASN1intx_uoctets(&mantissa);
            if (nmoctets < 256)
            {
                RtlCopyMemory(mASN1octets,
                    mantissa.value + mantissa.length - nmoctets,
                    nmoctets);
                ASN1intx_setuint32(&help, 8 * nmoctets);
                ASN1intx_sub(&exponent, &exponent, &help);
                ASN1intx_free(&mantissa);
                ASN1intx_free(&help);

                /* encode exponent and create head octet of encoded value */
                neoctets = ASN1intx_octets(&exponent);
                if (neoctets < 256)
                {
                    RtlCopyMemory(mASN1octets,
                        val->exponent.value + val->exponent.length - neoctets,
                        neoctets);
                    ASN1intx_free(&exponent);
                    head = (ASN1octet_t) (0x80 | (sign << 6) | (neoctets - 1));

                    /* encode length into first octet */
                    len = 1 + neoctets + nmoctets;
                    if (ASN1BEREncLength(enc, len))
                    {
                        /* put head octet, mantissa and exponent */
                        *enc->pos++ = head;
                        RtlCopyMemory(enc->pos, eASN1octets, neoctets);
                        enc->pos += neoctets;
                        RtlCopyMemory(enc->pos, mASN1octets, nmoctets);
                        enc->pos += nmoctets;
                        return 1;
                    }
                }
                else
                {
                    ASN1intx_free(&exponent);
                    ASN1EncSetError(enc, ASN1_ERR_LARGE);
                }
            }
            else
            {
                ASN1intx_free(&mantissa);
                ASN1intx_free(&help);
                ASN1EncSetError(enc, ASN1_ERR_LARGE);
            }
        }
    }
    /* finished */
    return 0;
}
#endif // ENABLE_REAL

#ifdef ENABLE_EMBEDDED_PDV
/* encode an embedded pdv value */
int ASN1BEREncEmbeddedPdv(ASN1encoding_t enc, ASN1uint32_t tag, ASN1embeddedpdv_t *val)
{
    ASN1uint32_t index;
    ASN1uint32_t flag;

    /* search identification */
    if (!ASN1EncSearchEmbeddedPdvIdentification(((ASN1INTERNencoding_t) enc)->parent,
        &val->identification, &index, &flag))
        return 0;
    if (index > 255 ||
            (val->data_value.o == ASN1embeddedpdv_data_value_encoded_o &&
        (val->data_value.u.encoded.length & 7))) {
        flag = 1;
    }
        
    if (flag)
    {
        ASN1uint32_t nLenOff_, nLenOff0, nLenOff1;

        /* EP-A encoding: */
        /* encode as construct value */
        if (!ASN1BEREncExplicitTag(enc, tag, &nLenOff_))
            return 0;

        /* encode index */
        if (!ASN1BEREncU32(enc, 0x80000000, index))
            return 0;

        /* encode tag of identification */
        if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
            return 0;

        /* encode identification */
        switch (val->identification.o)
        {
        case ASN1embeddedpdv_identification_syntaxes_o:
            if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff1))
                return 0;
            if (!ASN1BEREncObjectIdentifier(enc, 0x80000000,
                &val->identification.u.syntaxes.abstract))
                return 0;
            if (!ASN1BEREncObjectIdentifier(enc, 0x80000001,
                &val->identification.u.syntaxes.transfer))
                return 0;
            if (!ASN1BEREncEndOfContents(enc, nLenOff1))
                return 0;
            break;
        case ASN1embeddedpdv_identification_syntax_o:
            if (!ASN1BEREncObjectIdentifier(enc, 0x80000001,
                &val->identification.u.syntax))
                return 0;
            break;
        case ASN1embeddedpdv_identification_presentation_context_id_o:
            if (!ASN1BEREncU32(enc, 0x80000002,
                val->identification.u.presentation_context_id))
                return 0;
            break;
        case ASN1embeddedpdv_identification_context_negotiation_o:
            if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff1))
                return 0;
            if (!ASN1BEREncU32(enc, 0x80000000, val->
                identification.u.context_negotiation.presentation_context_id))
                return 0;
            if (!ASN1BEREncObjectIdentifier(enc, 0x80000001,
                &val->identification.u.context_negotiation.transfer_syntax))
                return 0;
            if (!ASN1BEREncEndOfContents(enc, nLenOff1))
                return 0;
            break;
        case ASN1embeddedpdv_identification_transfer_syntax_o:
            if (!ASN1BEREncObjectIdentifier(enc, 0x80000004,
                &val->identification.u.transfer_syntax))
                return 0;
            break;
        case ASN1embeddedpdv_identification_fixed_o:
            if (!ASN1BEREncNull(enc, 0x80000005))
                return 0;
            break;
        default:
            ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
            return 0;
        }

        /* end of identification */
        if (!ASN1BEREncEndOfContents(enc, nLenOff0))
            return 0;

        /* encode data value */
        switch (val->data_value.o)
        {
        case ASN1embeddedpdv_data_value_notation_o:
            if (!ASN1BEREncBitString(enc, 0x80000002,
                val->data_value.u.notation.length * 8,
                val->data_value.u.notation.encoded))
                return 0;
            break;
        case ASN1embeddedpdv_data_value_encoded_o:
            if (!ASN1BEREncBitString(enc, 0x80000002,
                val->data_value.u.encoded.length,
                val->data_value.u.encoded.value))
                return 0;
            break;
        default:
            ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
            return 0;
        }

        /* end of embedded pdv */
        if (!ASN1BEREncEndOfContents(enc, nLenOff_))
            return 0;
    }
    else
    {
        /* EP-B encoding: */
        /* encode tag */
        if (!ASN1BEREncTag(enc, tag))
            return 0;

        /* encode data value */
        switch (val->data_value.o)
        {
        case ASN1embeddedpdv_data_value_notation_o:
            if (!ASN1BEREncLength(enc,
                val->data_value.u.notation.length + 1))
                return 0;
            *enc->pos++ = (ASN1octet_t) index;
            RtlCopyMemory(enc->pos, val->data_value.u.notation.encoded,
                val->data_value.u.notation.length);
            enc->pos += val->data_value.u.notation.length;
            break;
        case ASN1embeddedpdv_data_value_encoded_o:
            if (!ASN1BEREncLength(enc,
                val->data_value.u.encoded.length / 8 + 1))
                return 0;
            *enc->pos++ = (ASN1octet_t) index;
            RtlCopyMemory(enc->pos, val->data_value.u.encoded.value,
                val->data_value.u.encoded.length / 8);
            enc->pos += val->data_value.u.encoded.length / 8;
            break;
        default:
            ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
            return 0;
        }
    }
    return 1;
}
#endif // ENABLE_EMBEDDED_PDV


#ifdef ENABLE_EXTERNAL
/* encode an external value */
int ASN1BEREncExternal(ASN1encoding_t enc, ASN1uint32_t tag, ASN1external_t *val)
{
    ASN1uint32_t t;
    ASN1uint32_t nLenOff_, nLenOff0;

    if (!val->data_value_descriptor)
        val->o[0] &= ~0x80;

    /* encode tag */
    if (!ASN1BEREncExplicitTag(enc, tag, &nLenOff_))
        return 0;

    /* encode identification */
    switch (val->identification.o) {
    case ASN1external_identification_syntax_o:
        if (!ASN1BEREncObjectIdentifier(enc, 0x6,
            &val->identification.u.syntax))
            return 0;
        break;
    case ASN1external_identification_presentation_context_id_o:
        if (!ASN1BEREncU32(enc, 0x2,
            val->identification.u.presentation_context_id))
            return 0;
        break;
    case ASN1external_identification_context_negotiation_o:
        if (!ASN1BEREncObjectIdentifier(enc, 0x6,
            &val->identification.u.context_negotiation.transfer_syntax))
            return 0;
        if (!ASN1BEREncU32(enc, 0x2,
            val->identification.u.context_negotiation.presentation_context_id))
            return 0;
        break;
    default:
        ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
        return 0;
    }

    /* encode data value descriptor if present */
    if (val->o[0] & 0x80) {
        t = My_lstrlenA(val->data_value_descriptor);
        if (!ASN1BEREncCharString(enc, 0x7, t, val->data_value_descriptor))
            return 0;
    }

    /* encode data value */
    switch (val->data_value.o)
    {
    case ASN1external_data_value_notation_o:
        if (!ASN1BEREncExplicitTag(enc, 0, &nLenOff0))
            return 0;
        if (!ASN1BEREncOpenType(enc, &val->data_value.u.notation))
            return 0;
        if (!ASN1BEREncEndOfContents(enc, nLenOff0))
            return 0;
        break;
    case ASN1external_data_value_encoded_o:
        if (!(val->data_value.u.encoded.length & 7))
        {
            if (!ASN1BEREncExplicitTag(enc, 1, &nLenOff0))
                return 0;
            if (!ASN1BEREncOctetString(enc, 0x4,
                val->data_value.u.encoded.length / 8,
                val->data_value.u.encoded.value))
                return 0;
            if (!ASN1BEREncEndOfContents(enc, nLenOff0))
                return 0;
        }
        else
        {
            if (!ASN1BEREncExplicitTag(enc, 2, &nLenOff0))
                return 0;
            if (!ASN1BEREncBitString(enc, 0x3,
                val->data_value.u.encoded.length,
                val->data_value.u.encoded.value))
                return 0;
            if (!ASN1BEREncEndOfContents(enc, nLenOff0))
                return 0;
        }
        break;
    default:
        ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
        return 0;
    }

    /* end of external value */
    return ASN1BEREncEndOfContents(enc, nLenOff_);
}
#endif // ENABLE_EXTERNAL

/* encode a generalized time value */
int ASN1BEREncGeneralizedTime(ASN1encoding_t enc, ASN1uint32_t tag, ASN1generalizedtime_t *val)
{
    char time[32];
    time[0] = '\0';
    ASN1generalizedtime2string(time, val);
    return ASN1BEREncCharString(enc, tag, My_lstrlenA(time), time);
}

/* encode a generalized time value (CER) */
int ASN1CEREncGeneralizedTime(ASN1encoding_t enc, ASN1uint32_t tag, ASN1generalizedtime_t *val)
{
    char time[32];
    time[0] = '\0';
    ASN1generalizedtime2string(time, val);
    return ASN1CEREncCharString(enc, tag, My_lstrlenA(time), time);
}

/* encode a signed integer value */
int ASN1BEREncS32(ASN1encoding_t enc, ASN1uint32_t tag, ASN1int32_t val)
{
    if (ASN1BEREncTag(enc, tag))
    {
        if (val >= -0x8000 && val < 0x8000)
        {
            if (val >= -0x80 && val < 0x80)
            {
                if (ASN1BEREncLength(enc, 1))
                {
                    *enc->pos++ = (ASN1octet_t)(val);
                    return 1;
                }
            }
            else
            {
                if (ASN1BEREncLength(enc, 2))
                {
                    *enc->pos++ = (ASN1octet_t)(val >> 8);
                    *enc->pos++ = (ASN1octet_t)(val);
                    return 1;
                }
            }
        }
        else
        {
            if (val >= -0x800000 && val < 0x800000)
            {
                if (ASN1BEREncLength(enc, 3))
                {
                    *enc->pos++ = (ASN1octet_t)(val >> 16);
                    *enc->pos++ = (ASN1octet_t)(val >> 8);
                    *enc->pos++ = (ASN1octet_t)(val);
                    return 1;
                }
            }
            else
            {
                if (ASN1BEREncLength(enc, 4))
                {
                    *enc->pos++ = (ASN1octet_t)(val >> 24);
                    *enc->pos++ = (ASN1octet_t)(val >> 16);
                    *enc->pos++ = (ASN1octet_t)(val >> 8);
                    *enc->pos++ = (ASN1octet_t)(val);
                    return 1;
                }
            }
        }
    }
    return 0;
}

/* encode a intx_t integer value */
int ASN1BEREncSX(ASN1encoding_t enc, ASN1uint32_t tag, ASN1intx_t *val)
{
    ASN1uint32_t cb;
    ASN1octet_t *p;

    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        // strip out leading 0 and ff.
        for (cb = val->length, p = val->value; cb > 1; cb--, p++)
        {
			// break if not 00 nor FF
            if (*p && *p != 0xFF)
            {
                break;
            }
			// break if 00 FF
			if ((! *p) && (*(p+1) & 0x80))
			{
				break;
			}
			// break if FF 7F
			if (*p == 0xFF && (!(*(p+1) & 0x80)))
			{
				break;
			}
        }

        /* encode length */
        if (ASN1BEREncLength(enc, cb))
        {
            /* copy value */
            RtlCopyMemory(enc->pos, p, cb);
            enc->pos += cb;
            return 1;
        }
    }
    return 0;
}

/* encode a multibyte string value */
int ASN1BEREncZeroMultibyteString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1ztcharstring_t val)
{
    return ASN1BEREncCharString(enc, tag, My_lstrlenA(val), val);
}

int ASN1BEREncMultibyteString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1charstring_t *val)
{
    return ASN1BEREncCharString(enc, tag, val->length, val->value);
}

/* encode a multibyte string value (CER) */
int ASN1CEREncZeroMultibyteString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1ztcharstring_t val)
{
    return ASN1CEREncCharString(enc, tag, My_lstrlenA(val), val);
}

int ASN1CEREncMultibyteString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1charstring_t *val)
{
    return ASN1CEREncCharString(enc, tag, val->length, val->value);
}

/* encode a null value */
int ASN1BEREncNull(ASN1encoding_t enc, ASN1uint32_t tag)
{
    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        /* encode zero length */
        return ASN1BEREncLength(enc, 0);
    }
    return 0;
}

// encode an oid node s to buffer pointed by p
ASN1octet_t *_BEREncOidNode(ASN1octet_t *p, ASN1uint32_t s)
{
    if (s < 0x80)
    {
        *p++ = (ASN1octet_t)(s);
    }
    else
    if (s < 0x4000)
    {
        *p++ = (ASN1octet_t)((s >> 7) | 0x80);
        *p++ = (ASN1octet_t)(s & 0x7f);
    }
    else
    if (s < 0x200000)
    {
        *p++ = (ASN1octet_t)((s >> 14) | 0x80);
        *p++ = (ASN1octet_t)((s >> 7) | 0x80);
        *p++ = (ASN1octet_t)(s & 0x7f);
    }
    else
    if (s < 0x10000000)
    {
        *p++ = (ASN1octet_t)((s >> 21) | 0x80);
        *p++ = (ASN1octet_t)((s >> 14) | 0x80);
        *p++ = (ASN1octet_t)((s >> 7) | 0x80);
        *p++ = (ASN1octet_t)(s & 0x7f);
    }
    else
    {
        *p++ = (ASN1octet_t)((s >> 28) | 0x80);
        *p++ = (ASN1octet_t)((s >> 21) | 0x80);
        *p++ = (ASN1octet_t)((s >> 14) | 0x80);
        *p++ = (ASN1octet_t)((s >> 7) | 0x80);
        *p++ = (ASN1octet_t)(s & 0x7f);
    }
    return p;
}

/* encode an object identifier value */
int ASN1BEREncObjectIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, ASN1objectidentifier_t *val)
{
    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        ASN1objectidentifier_t obj = *val;
        ASN1uint32_t i, s, l;
        ASN1octet_t *data, *p;

        l = GetObjectIdentifierCount(obj);
        if (l)
        {
            /* convert object identifier to octets */
            p = data = (ASN1octet_t *)EncMemAlloc(enc, l * 5); /* max. 5 octets/subelement */
            if (p)
            {
                int rc;
                for (i = 0; i < l; i++)
                {
                    s = obj->value;
                    obj = obj->next;
                    if (!i && l > 1)
                    {
                        s = s * 40 + obj->value;
                        obj = obj->next;
                        i++;
                    }
                    p = _BEREncOidNode(p, s);
                } // for

                /* encode length */
                rc = ASN1BEREncLength(enc, (ASN1uint32_t) (p - data));
                if (rc)
                {
                    /* copy value */
                    RtlCopyMemory(enc->pos, data, p - data);
                    enc->pos += p - data;
                }
                MemFree(data);
                return rc;
            }
            ASN1EncSetError(enc, ASN1_ERR_MEMORY);
            return 0;
        } // if (l)
        /* encode zero length */
        return ASN1BEREncLength(enc, 0);
    }
    return 0;
}

/* encode an object identifier value */
int ASN1BEREncObjectIdentifier2(ASN1encoding_t enc, ASN1uint32_t tag, ASN1objectidentifier2_t *val)
{
    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        ASN1uint32_t i, s;
        ASN1octet_t *data, *p;

        if (val->count)
        {
            /* convert object identifier to octets */
            p = data = (ASN1octet_t *)EncMemAlloc(enc, val->count * 5); /* max. 5 octets/subelement */
            if (p)
            {
                int rc;
                for (i = 0; i < val->count; i++)
                {
                    s = val->value[i];
                    if (!i && val->count > 1)
                    {
                        i++;
                        s = s * 40 + val->value[i];
                    }
                    p = _BEREncOidNode(p, s);
                } // for

                /* encode length */
                rc = ASN1BEREncLength(enc, (ASN1uint32_t) (p - data));
                if (rc)
                {
                    /* copy value */
                    RtlCopyMemory(enc->pos, data, p - data);
                    enc->pos += p - data;
                }
                MemFree(data);
                return rc;
            }
            ASN1EncSetError(enc, ASN1_ERR_MEMORY);
            return 0;
        } // if (l)
        /* encode zero length */
        return ASN1BEREncLength(enc, 0);
    }
    return 0;
}

/* encode an octet string value (CER) */
int ASN1CEREncOctetString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1octet_t *val)
{
    ASN1uint32_t n;

    if (len <= 1000)
    {
        /* encode tag */
        if (ASN1BEREncTag(enc, tag))
        {
            /* encode length */
            if (ASN1BEREncLength(enc, len))
            {
                /* copy value */
                RtlCopyMemory(enc->pos, val, len);
                enc->pos += len;
                return 1;
            }
        }
    }
    else
    {
        ASN1uint32_t nLenOff;
        /* encode value as constructed, using segments of 1000 octets */
        if (ASN1BEREncExplicitTag(enc, tag, &nLenOff))
        {
            while (len)
            {
                n = len > 1000 ? 1000 : len;
                if (ASN1BEREncTag(enc, 0x4))
                {
                    if (ASN1BEREncLength(enc, n))
                    {
                        RtlCopyMemory(enc->pos, val, n);
                        enc->pos += n;
                        val += n;
                        len -= n;
                    }
                    else
                    {
                        return 0;
                    }
                }
                else
                {
                    return 0;
                }
            }
            return ASN1BEREncEndOfContents(enc, nLenOff);
        }
    }
    return 0;
}

/* encode an open type value */
int ASN1BEREncOpenType(ASN1encoding_t enc, ASN1open_t *val)
{
    if (ASN1BEREncCheck(enc, val->length))
    {
        /* copy value */
        RtlCopyMemory(enc->pos, val->encoded, val->length);
        enc->pos += val->length;
        return 1;
    }
    return 0;
}

/* remove trailing zero bits from bit string */
int ASN1BEREncRemoveZeroBits(ASN1uint32_t *nbits, ASN1octet_t *val)
{
    ASN1uint32_t n;
    int i;

    /* get value */
    n = *nbits;

    /* let val point to last ASN1octet used */
    val += (n - 1) / 8;

    /* check if broken ASN1octet consist out of zero bits */
    if ((n & 7) && !(*val & bitmsk2[n & 7]))
    {
        n &= ~7;
        val--;
    }

    /* scan complete ASN1octets (memcchr missing ...) */
    if (!(n & 7))
    {
        while (n && !*val)
        {
            n -= 8;
            val--;
        }
    }

    /* scan current ASN1octet bit after bit */
    if (n)
    {
        for (i = (n - 1) & 7; i >= 0; i--)
        {
            if (*val & (0x80 >> i))
                break;
            n--;
        }
    }

    /* return real bitstring len */
    *nbits = n;
    return 1;
}

/* encode an utc time value */
int ASN1BEREncUTCTime(ASN1encoding_t enc, ASN1uint32_t tag, ASN1utctime_t *val)
{
    char time[32];
    time[0] = '\0';
    ASN1utctime2string(time, val);
    return ASN1BEREncCharString(enc, tag, My_lstrlenA(time), time);
}

/* encode an utc time value (CER) */
int ASN1CEREncUTCTime(ASN1encoding_t enc, ASN1uint32_t tag, ASN1utctime_t *val)
{
    char time[32];
    time[0] = '\0';
    ASN1utctime2string(time, val);
    return ASN1CEREncCharString(enc, tag, My_lstrlenA(time), time);
}

/* end of encoding */
int ASN1BEREncFlush(ASN1encoding_t enc)
{
    /* allocate at least one octet */
    if (enc->buf)
    {
        /* fill in zero-octet if encoding is empty bitstring */
        if (enc->buf == enc->pos)
            *enc->pos++ = 0;

        /* calculate length */
        enc->len = (ASN1uint32_t) (enc->pos - enc->buf);
        return 1;
    }
    return ASN1BEREncCheck(enc, 1);
}

#endif // ENABLE_BER

/* get the expected length based on the table */
ASN1uint32_t _BERGetLength(ASN1uint32_t val, const ASN1uint32_t Tbl[], ASN1uint32_t cItems)
{
    ASN1uint32_t i;
    for (i = 0; i < cItems; i++)
    {
        if (val < Tbl[i])
            return i+1;
    }
    return cItems+1;
}

static const ASN1uint32_t c_TagTable[] = { 31, 0x80, 0x4000, 0x200000, 0x10000000 };

/* encode a tag */
int ASN1BEREncTag(ASN1encoding_t enc, ASN1uint32_t tag)
{
    ASN1uint32_t tagclass, tagvalue, cbTagLength;

    tagclass = (tag >> 24) & 0xe0;
    tagvalue = tag & 0x1fffffff;

    cbTagLength = _BERGetLength(tagvalue, c_TagTable, ARRAY_SIZE(c_TagTable));
    if (ASN1BEREncCheck(enc, cbTagLength))
    {
        if (cbTagLength == 1)
        {
            *enc->pos++ = (ASN1octet_t)(tagclass | tagvalue);
        }
        else
        {
            *enc->pos++ = (ASN1octet_t)(tagclass | 0x1f);
            switch (cbTagLength)
            {
            case 6:
                *enc->pos++ = (ASN1octet_t)((tagvalue >> 28) | 0x80);
                // lonchanc: intentionally fall through
            case 5:
                *enc->pos++ = (ASN1octet_t)((tagvalue >> 21) | 0x80);
                // lonchanc: intentionally fall through
            case 4:
                *enc->pos++ = (ASN1octet_t)((tagvalue >> 14) | 0x80);
                // lonchanc: intentionally fall through
            case 3:
                *enc->pos++ = (ASN1octet_t)((tagvalue >> 7) | 0x80);
                // lonchanc: intentionally fall through
            case 2:
                *enc->pos++ = (ASN1octet_t)(tagvalue & 0x7f);
                break;
            }
        }
        return 1;
    }
    return 0;
}

/* put the length value */
void _BERPutLength(ASN1encoding_t enc, ASN1uint32_t len, ASN1uint32_t cbLength)
{
    if (cbLength > 1)
    {
        *enc->pos++ = (ASN1octet_t) (0x7f + cbLength); // 0x80 + cbLength - 1;
    }

    switch (cbLength)
    {
    case 5:
        *enc->pos++ = (ASN1octet_t)(len >> 24);
        // lonchanc: intentionally fall through
    case 4:
        *enc->pos++ = (ASN1octet_t)(len >> 16);
        // lonchanc: intentionally fall through
    case 3:
        *enc->pos++ = (ASN1octet_t)(len >> 8);
        // lonchanc: intentionally fall through
    default: // case 2: case 1:
        *enc->pos++ = (ASN1octet_t)len;
        break;
    }
}

static const ASN1uint32_t c_LengthTable[] = { 0x80, 0x100, 0x10000, 0x1000000 };

/* encode length */
int ASN1BEREncLength(ASN1encoding_t enc, ASN1uint32_t len)
{
    ASN1uint32_t cbLength = _BERGetLength(len, c_LengthTable, ARRAY_SIZE(c_LengthTable));

    if (ASN1BEREncCheck(enc, cbLength + len))
    {
        _BERPutLength(enc, len, cbLength);
        return 1;
    }
    return 0;
}

/* encode an octet string value */
int ASN1BEREncOctetString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1octet_t *val)
{
    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        /* encode length */
        if (ASN1BEREncLength(enc, len))
        {
            /* copy value */
            RtlCopyMemory(enc->pos, val, len);
            enc->pos += len;
            return 1;
        }
    }
    return 0;
}

/* encode a boolean value */
int ASN1BEREncBool(ASN1encoding_t enc, ASN1uint32_t tag, ASN1bool_t val)
{
    if (ASN1BEREncTag(enc, tag))
    {
        if (ASN1BEREncLength(enc, 1))
        {
            *enc->pos++ = val ? 0xFF : 0;
            return 1;
        }
    }
    return 0;
}

static const ASN1uint32_t c_U32LengthTable[] = { 0x80, 0x8000, 0x800000, 0x80000000 };

/* encode a unsigned integer value */
int ASN1BEREncU32(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t val)
{
    EncAssert(enc, tag != 0x01);
    if (ASN1BEREncTag(enc, tag))
    {
        ASN1uint32_t cbLength;
        cbLength = _BERGetLength(val, c_U32LengthTable, ARRAY_SIZE(c_U32LengthTable));
        if (ASN1BEREncLength(enc, cbLength))
        {
            switch (cbLength)
            {
            case 5:
                *enc->pos++ = 0;
                // lonchanc: intentionally fall through
            case 4:
                *enc->pos++ = (ASN1octet_t)(val >> 24);
                // lonchanc: intentionally fall through
            case 3:
                *enc->pos++ = (ASN1octet_t)(val >> 16);
                // lonchanc: intentionally fall through
            case 2:
                *enc->pos++ = (ASN1octet_t)(val >> 8);
                // lonchanc: intentionally fall through
            case 1:
                *enc->pos++ = (ASN1octet_t)(val);
                break;
            }
            return 1;
        }
    }
    return 0;
}


// THE FOLLOWING IS FROM BERDECOD.C


/* check if len octets are left in decoding stream */
int ASN1BERDecCheck(ASN1decoding_t dec, ASN1uint32_t len)
{
    if (dec->pos + len <= dec->buf + dec->size)
    {
        return 1;
    }

    ASN1DecSetError(dec, ASN1_ERR_EOD);
    return 0;
}

int _BERDecPeekCheck(ASN1decoding_t dec, ASN1uint32_t len)
{
    return ((dec->pos + len <= dec->buf + dec->size) ? 1 : 0);
}

/* start decoding of a constructed value */
int _BERDecConstructed(ASN1decoding_t dec, ASN1uint32_t len, ASN1uint32_t infinite, ASN1decoding_t *dd, ASN1octet_t **ppBufEnd)
{
    // safety net
    DecAssert(dec, NULL != dd);
    if (dd != NULL)
    {
        *dd = dec;
    }

#ifdef XBOX_SPECIFIC_OPTIMIZATIONS
    // lonchanc: this does not work because open type can be the last component and
    // the open type decoder needs to peek a tag. as a result, we may peek the tag
    // outside the buffer boundary.
    if (ppBufEnd && (! infinite))
    {
        *ppBufEnd = dec->pos + len;
        return 1;
    }
#endif

    /* initialize a new decoding stream as child of running decoding stream */
    if (ASN1_CreateDecoder(dec->pScratchMemoryAllocator, dec->module, dd,
        dec->pos, infinite ? dec->size - (ASN1uint32_t) (dec->pos - dec->buf) : len, dec) >= 0)
    {
        /* set pointer to end of decoding stream if definite length case selected */
        *ppBufEnd = infinite ? NULL : (*dd)->buf + (*dd)->size;
        return 1;
    }

    return 0;
}

/* decode a tag value; return constructed bit if desired */
int ASN1BERDecTag(ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint32_t *constructed)
{
    ASN1uint32_t tagvalue, tagclass, c;

    /* get tag class and value */
    if (ASN1BERDecCheck(dec, 1))
    {
        tagclass = *dec->pos & 0xe0;
        tagvalue = *dec->pos++ & 0x1f;
        if (tagvalue == 0x1f)
        {
            tagvalue = 0;
            do {
                if (ASN1BERDecCheck(dec, 1))
                {
                    c = *dec->pos++;
                    if (! (tagvalue & 0xe0000000))
                    {
                        tagvalue = (tagvalue << 7) | (c & 0x7f);
                    }
                    else
                    {
                        ASN1DecSetError(dec, ASN1_ERR_BADTAG);
                        return 0;
                    }
                }
                else
                {
                    return 0;
                }
            } while (c & 0x80);
        }

        /* extract constructed bit if wanted */
        if (constructed)
        {
            *constructed = tagclass & 0x20;
            tagclass &= ~0x20;
        }

        /* check if tag equals desires */
        if (tag == ((tagclass << 24) | tagvalue))
        {
            return 1;
        }

        ASN1DecSetError(dec, ASN1_ERR_BADTAG);
    }
    return 0;
}

/* decode length */
int ASN1BERDecLength(ASN1decoding_t dec, ASN1uint32_t *len, ASN1uint32_t *infinite)
{
    // default is definite length
    if (infinite)
    {
        *infinite = 0;
    }

    /* get length and infinite flag */
    if (ASN1BERDecCheck(dec, 1))
    {
        ASN1uint32_t l = *dec->pos++;
        if (l < 0x80)
        {
            *len = l;
        }
        else
        if (l == 0x80)
        {
            *len = 0;
            if (infinite)
            {
                *infinite = 1;
            }
            else
            {
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                return 0;
            }
        }
        else
        if (l <= 0x84)
        {
            ASN1uint32_t i = l - 0x80;
            if (ASN1BERDecCheck(dec, i))
            {
                l = 0;
                switch (i)
                {
                case 4:
                    l = *dec->pos++ << 24;
                    /*FALLTHROUGH*/
                case 3:
                    l |= *dec->pos++ << 16;
                    /*FALLTHROUGH*/
                case 2:
                    l |= *dec->pos++ << 8;
                    /*FALLTHROUGH*/
                case 1:
                    l |= *dec->pos++;
                    break;
                }
                *len = l;
            }
            else
            {
                return 0;
            }
        }
        else
        {
            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            return 0;
        }

        /* check if enough octets left if length is known */
        if (!infinite || !*infinite)
        {
            return ASN1BERDecCheck(dec, *len);
        }
        return 1;
    }

    return 0;
}

/* decode an explicit tag */
int ASN1BERDecExplicitTag(ASN1decoding_t dec, ASN1uint32_t tag, ASN1decoding_t *dd, ASN1octet_t **ppBufEnd)
{
    ASN1uint32_t len, infinite;

    // safety net
    if (dd)
    {
        *dd = dec;
    }

    /* skip the constructed tag */
    if (ASN1BERDecTag(dec, tag | 0x20000000, NULL))
    {
        /* get the length */
        if (ASN1BERDecLength(dec, &len, &infinite))
        {
            /* start decoding of constructed value */
            if (! dd)
            {
                *ppBufEnd = infinite ? NULL : dec->pos + len;
                return 1;
            }
            return _BERDecConstructed(dec, len, infinite, dd, ppBufEnd);
        }
    }
    return 0;
}

/* decode octet string value */
int _BERDecOctetString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1octetstring_t *val, ASN1uint32_t fNoCopy)
{
    ASN1INTERNdecoding_t d = (ASN1INTERNdecoding_t)dec;
    ASN1uint32_t constructed, len, infinite;
    ASN1decoding_t dd;
    ASN1octet_t *di;

    if (ASN1BERDecTag(dec, tag, &constructed))
    {
        if (ASN1BERDecLength(dec, &len, &infinite))
        {
            if (! constructed)
            {
                val->length = len;
                if (fNoCopy)
                {
                    val->value = dec->pos;
                    dec->pos += len;
                    return 1;
                }
                else
                {
                    if (len)
                    {
#ifdef XBOX_SPECIFIC_OPTIMIZATIONS
                        val->value = dec->pos;
                        dec->pos += len;
                        return 1;
#else
                        val->value = (ASN1octet_t *)DecMemAlloc(dec, len);
                        if (val->value)
                        {
                            RtlCopyMemory(val->value, dec->pos, len);
                            dec->pos += len;
                            return 1;
                        }
#endif
                    }
                    else
                    {
                        val->value = NULL;
                        return 1;
                    }
                }
            }
            else
            {
                ASN1octetstring_t o;
                val->length = 0;
                val->value = NULL;
                if (_BERDecConstructed(dec, len, infinite, &dd, &di))
                {
                    while (ASN1BERDecNotEndOfContents(dd, di))
                    {
                        o.length = 0;
                        o.value = NULL;
                        if (_BERDecOctetString(dd, 0x4, &o, fNoCopy))
                        {
                            if (o.length)
                            {
                                if (fNoCopy)
                                {
                                    *val = o;
                                    break; // break out the loop because nocopy cannot have multiple constructed streams
                                }

                                /* resize value */
                                val->value = (ASN1octet_t *)DecMemReAlloc(dd, val->value,
                                                                val->length + o.length);
                                if (val->value)
                                {
                                    /* concat octet strings */
                                    RtlCopyMemory(val->value + val->length, o.value, o.length);
                                    val->length += o.length;

                                    /* free unused octet string */
                                    DecMemFree(dec, o.value);
                                }
                                else
                                {
                                    return 0;
                                }
                            }
                        }
                    }
                    return ASN1BERDecEndOfContents(dec, dd, di);
                }
            }
        }
    }
    return 0;
}

/* decode octet string value, making copy */
int ASN1BERDecOctetString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1octetstring_t *val)
{
    return _BERDecOctetString(dec, tag, val, FALSE);
}

/* decode octet string value, no copy */
int ASN1BERDecOctetString2(ASN1decoding_t dec, ASN1uint32_t tag, ASN1octetstring_t *val)
{
    return _BERDecOctetString(dec, tag, val, TRUE);
}

/* peek the following tag without advancing the read position */
int ASN1BERDecPeekTag(ASN1decoding_t dec, ASN1uint32_t *tag)
{
    ASN1uint32_t tagvalue, tagclass, c;
    ASN1octet_t *p;

    *tag = 0; // invalid tag
    if (_BERDecPeekCheck(dec, 1))
    {
        p = dec->pos;

        /* get tagclass without primitive/constructed bit */
        tagclass = *dec->pos & 0xc0;

        /* get tag value */
        tagvalue = *dec->pos++ & 0x1f;
        if (tagvalue == 0x1f)
        {
            tagvalue = 0;
            do {
                if (_BERDecPeekCheck(dec, 1))
                {
                    c = *dec->pos++;
                    if (! (tagvalue & 0xe0000000))
                    {
                        tagvalue = (tagvalue << 7) | (c & 0x7f);
                    }
                    else
                    {
                        ASN1DecSetError(dec, ASN1_ERR_BADTAG);
                        return 0;
                    }
                }
                else
                {
                    return 0;
                }
            } while (c & 0x80);
        }

        /* return tag */
        *tag = ((tagclass << 24) | tagvalue);

        /* reset decoding position */
        dec->pos = p;
        return 1;
    }
    return 0;
}

/* decode boolean into ASN1boot_t */
int ASN1BERDecBool(ASN1decoding_t dec, ASN1uint32_t tag, ASN1bool_t *val)
{
    /* skip tag */
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        /* get length */
        ASN1uint32_t len;
        if (ASN1BERDecLength(dec, &len, NULL))
        {
            if (len >= 1)
            {
                DecAssert(dec, len == 1);
                *val = *dec->pos ? 1 : 0;
                dec->pos += len; // self defensive
                return 1;
            }
        }
    }
    return 0;
}

/* decode integer into unsigned 32 bit value */
int ASN1BERDecU32Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint32_t *val)
{
    ASN1uint32_t len;

    /* skip tag */
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        /* get length */
        if (ASN1BERDecLength(dec, &len, NULL))
        {
            /* get value */
            if (len >= 1)
            {
                switch (len)
                {
                case 1:
                    *val = *dec->pos++;
                    break;
                case 2:
                    *val = (*dec->pos << 8) | dec->pos[1];
                    dec->pos += 2;
                    break;
                case 3:
                    *val = (*dec->pos << 16) | (dec->pos[1] << 8) | dec->pos[2];
                    dec->pos += 3;
                    break;
                case 4:
                    *val = (*dec->pos << 24) | (dec->pos[1] << 16) |
                        (dec->pos[2] << 8) | dec->pos[3];
                    dec->pos += 4;
                    break;
                case 5:
                    if (! *dec->pos)
                    {
                        *val = (dec->pos[1] << 24) | (dec->pos[2] << 16) |
                            (dec->pos[3] << 8) | dec->pos[4];
                        dec->pos += 5;
                        break;
                    }
                    // intentionally fall through
                default:
                    ASN1DecSetError(dec, ASN1_ERR_LARGE);
                    return 0;
                }
                return 1;
            }
            else
            {
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                return 0;
            }
        }
    }
    return 0;
}

int ASN1BERDecEndOfContents(ASN1decoding_t dec, ASN1decoding_t dd, ASN1octet_t *pBufEnd)
{
    ASN1error_e err = ASN1_ERR_CORRUPT;

    if (! dd)
    {
        dd = dec;
    }

    DecAssert(dec, NULL != dd);

    if (pBufEnd)
    {
        /* end of definite length case: */
        /* check if decoded up to end of contents */
        if (dd->pos == pBufEnd)
        {
            dec->pos = pBufEnd;
            err = ASN1_SUCCESS;
        }
    }
    else
    {
        /* end of infinite length case: */
        /* expect end-of-contents octets */
        if (ASN1BERDecCheck(dd, 2))
        {
            if (0 == dd->pos[0] && 0 == dd->pos[1])
            {
                dd->pos += 2;
                if (dd != dec)
                {
                    /* finit child decoding stream and update parent decoding stream */
                    dec->pos = dd->pos;
                }
                err = ASN1_SUCCESS;
            }
        }
        else
        {
            err = ASN1_ERR_EOD;
        }
    }

    if (dd && dd != dec)
    {
        ASN1_CloseDecoder(dd);
    }

    if (ASN1_SUCCESS == err)
    {
        return 1;
    }

    ASN1DecSetError(dec, err);
    return 0;
}

/* check if end of contents (of a constructed value) has been reached */
int ASN1BERDecNotEndOfContents(ASN1decoding_t dec, ASN1octet_t *pBufEnd)
{
    return (pBufEnd ?
                (dec->pos < pBufEnd) :
                (ASN1BERDecCheck(dec, 2) && (dec->pos[0] || dec->pos[1])));
}


#ifdef ENABLE_BER

typedef struct
{
    ASN1octet_t        *pBuf;
    ASN1uint32_t        cbBufSize;
}
    CER_BLK_BUF;

typedef struct
{
    ASN1blocktype_e     eBlkType;
    ASN1encoding_t      encPrimary;
    ASN1encoding_t      encSecondary;
    ASN1uint32_t        nMaxBlkSize;
    ASN1uint32_t        nCurrBlkSize;
    CER_BLK_BUF        *aBlkBuf;
}
    CER_BLOCK;

#define MAX_INIT_BLK_SIZE   16

int ASN1CEREncBeginBlk(ASN1encoding_t enc, ASN1blocktype_e eBlkType, void **ppBlk_)
{
    CER_BLOCK *pBlk = (CER_BLOCK *) EncMemAlloc(enc, sizeof(CER_BLOCK));
    if (NULL != pBlk)
    {
        EncAssert(enc, ASN1_DER_SET_OF_BLOCK == eBlkType);
        pBlk->eBlkType = eBlkType;
        pBlk->encPrimary = enc;
        pBlk->encSecondary = NULL;
        pBlk->nMaxBlkSize = MAX_INIT_BLK_SIZE;
        pBlk->nCurrBlkSize = 0;
        pBlk->aBlkBuf = (CER_BLK_BUF *)EncMemAlloc(enc, MAX_INIT_BLK_SIZE * sizeof(CER_BLK_BUF));
        if (NULL != pBlk->aBlkBuf)
        {
            *ppBlk_ = (void *) pBlk;
            return 1;
        }
        EncMemFree(enc, pBlk);
    }
    return 0;
}

int ASN1CEREncNewBlkElement(void *pBlk_, ASN1encoding_t *enc2)
{
    CER_BLOCK *pBlk = (CER_BLOCK *) pBlk_;
    if (NULL == pBlk->encSecondary)
    {
        if (ASN1_SUCCESS == ASN1_CreateEncoder(pBlk->encPrimary->pScratchMemoryAllocator, pBlk->encPrimary->module,
                                               &(pBlk->encSecondary),
                                               NULL, 0, pBlk->encPrimary))
        {
            pBlk->encSecondary->eRule = pBlk->encPrimary->eRule;
            *enc2 = pBlk->encSecondary;
            return 1;
        }
    }
    else
    {
        ASN1INTERNencoding_t e = (ASN1INTERNencoding_t) (*enc2 = pBlk->encSecondary);

        RtlZeroMemory(e, sizeof(*e));
        e->info.magic = MAGIC_ENCODER;
        // e->info.err = ASN1_SUCCESS;
        // e->info.pos = e->info.buf = NULL;
        // e->info.size = e->info.len = e->info.bit = 0;
        // e->info.dwFlags = 0;
        e->info.module = pBlk->encPrimary->module;
        e->info.eRule = pBlk->encPrimary->eRule;

        ((ASN1INTERNencoding_t) pBlk->encPrimary)->child = e;
        e->parent = (ASN1INTERNencoding_t) pBlk->encPrimary;
        // e->child = NULL;

        // e->mem = NULL;
        // e->memlength = 0;
        // e->memsize = 0;
        // e->epi = NULL;
        // e->epilength = 0;
        // e->episize = 0;
        // e->csi = NULL;
        // e->csilength = 0;
        // e->csisize = 0;

        if (ASN1BEREncCheck((ASN1encoding_t) e, 1))
        {
            // lonchanc: make sure the first byte is zeroed out, which
            // is required for h245.
            e->info.buf[0] = '\0';
            return 1;
        }
    }

    *enc2 =  NULL;
    return 0;
}

int ASN1CEREncFlushBlkElement(void *pBlk_)
{
    CER_BLOCK *pBlk = (CER_BLOCK *) pBlk_;
    ASN1encoding_t enc = pBlk->encSecondary;
    ASN1uint32_t i;

    if (ASN1BEREncFlush(enc))
    {
        // make sure we have enough space...
        if (pBlk->nCurrBlkSize >= pBlk->nMaxBlkSize)
        {
            CER_BLK_BUF *aBlkBuf = (CER_BLK_BUF *)EncMemAlloc(pBlk->encPrimary, (pBlk->nMaxBlkSize << 1) * sizeof(CER_BLK_BUF));
            if (NULL != aBlkBuf)
            {
                RtlCopyMemory(aBlkBuf, pBlk->aBlkBuf, pBlk->nMaxBlkSize * sizeof(CER_BLK_BUF));
                EncMemFree(pBlk->encPrimary, pBlk->aBlkBuf);
                pBlk->aBlkBuf = aBlkBuf;
                pBlk->nMaxBlkSize <<= 1;
            }
            else
            {
                return 0;
            }
        }

        if (pBlk->encPrimary->eRule & (ASN1_BER_RULE_DER | ASN1_BER_RULE_CER))
        {
            // we need to sort these octet strings
            for (i = 0; i < pBlk->nCurrBlkSize; i++)
            {
                if (0 >= My_memcmp(enc->buf, enc->len, pBlk->aBlkBuf[i].pBuf, pBlk->aBlkBuf[i].cbBufSize))
                {
                    ASN1uint32_t cnt = pBlk->nCurrBlkSize - i;
                    ASN1uint32_t j;
                    for (j = pBlk->nCurrBlkSize; cnt--; j--)
                    {
                        pBlk->aBlkBuf[j] = pBlk->aBlkBuf[j-1];
                    }
                    // i is the place to hold the new one
                    break;
                }
            }
        }
        else
        {
            EncAssert(enc, ASN1_BER_RULE_BER == pBlk->encPrimary->eRule);
            i = pBlk->nCurrBlkSize;
        }

        // remeber the new one.
        pBlk->aBlkBuf[i].pBuf = enc->buf;
        pBlk->aBlkBuf[i].cbBufSize = enc->len;
        pBlk->nCurrBlkSize++;
        
        // clean up the encoder structure
        enc->buf = enc->pos = NULL;
        enc->size = enc->len = 0;
        return 1;
    }
    return 0;
}

int ASN1CEREncEndBlk(void *pBlk_)
{
    CER_BLOCK *pBlk = (CER_BLOCK *) pBlk_;
    ASN1encoding_t enc = pBlk->encPrimary;
    ASN1uint32_t cbTotalSize = 0;
    ASN1uint32_t i;
    int fRet = 0;

    // calculate the total size for all the buffers.
    for (i = 0; i < pBlk->nCurrBlkSize; i++)
    {
        cbTotalSize += pBlk->aBlkBuf[i].cbBufSize;
    }

    if (ASN1BEREncCheck(enc, cbTotalSize))
    {
        for (i = 0; i < pBlk->nCurrBlkSize; i++)
        {
            ASN1uint32_t cbBufSize = pBlk->aBlkBuf[i].cbBufSize;
            RtlCopyMemory(enc->pos, pBlk->aBlkBuf[i].pBuf, cbBufSize);
            enc->pos += cbBufSize;
        }
        fRet = 1;
    }

    // free these block buffers.
    for (i = 0; i < pBlk->nCurrBlkSize; i++)
    {
        EncMemFree(enc, pBlk->aBlkBuf[i].pBuf);
    }

    // free the block buffer array
    EncMemFree(enc, pBlk->aBlkBuf);

	// free the secondary encoder structure
	ASN1_CloseEncoder(pBlk->encSecondary);

    // free the block structure itself.
    EncMemFree(enc, pBlk);

    return fRet;
}

#endif // ENABLE_BER

/* encode explicit tag */
int ASN1BEREncExplicitTag(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t *pnLenOff)
{
    /* encode tag */
    if (ASN1BEREncTag(enc, tag | 0x20000000))
    {
        /* encode infinite length */
        if (ASN1BEREncCheck(enc, 1))
        {
            if (ASN1_BER_RULE_CER != enc->eRule)
            {
                // BER and DER always use definite length form.
                /* return the place to hold the length */
                *pnLenOff = (ASN1uint32_t) (enc->pos++ - enc->buf);
            }
            else
            {
                // CER sub-rule always use indefinite length form.
                *enc->pos++ = 0x80;
                *pnLenOff = 0;
            }
            return 1;
        }
    }
    return 0;
}

/* encode definite length */
int ASN1BEREncEndOfContents(ASN1encoding_t enc, ASN1uint32_t nLenOff)
{
    if (ASN1_BER_RULE_CER != enc->eRule)
    {
        ASN1octet_t *pbLen = enc->buf + nLenOff;
        ASN1uint32_t len = (ASN1uint32_t) (enc->pos - pbLen - 1);
        ASN1uint32_t cbLength = _BERGetLength(len, c_LengthTable, ARRAY_SIZE(c_LengthTable));

        //ASN1uint32_t i;

        if (cbLength == 1)
        {
            *pbLen = (ASN1octet_t) len;
            return 1;
        }

        // we have to move the octets upward by cbLength-1
        // --cbLength;
        if (ASN1BEREncCheck(enc, cbLength-1))
        {
            // update pbLen because enc->buf may change due to realloc.
            pbLen = enc->buf + nLenOff;

            // move memory
            RtlMoveMemory(pbLen + cbLength, pbLen + 1, len);

            // put the length
            enc->pos = pbLen;
            _BERPutLength(enc, len, cbLength);
            EncAssert(enc, enc->pos == pbLen + cbLength);

            // set up new position pointer.
            // now enc->pos is at the beginning of contents.
            enc->pos += len;
            return 1;
        }
    }
    else
    {
        EncAssert(enc, 0 == nLenOff);
        if (ASN1BEREncCheck(enc, 2))
        {
            *enc->pos++ = 0;
            *enc->pos++ = 0;
            return 1;
        }
    }
    return 0;
}


// The following is for CryptoAPI

#ifdef ENABLE_BER

 // max num of octets, ceiling of 64 / 7, is 10
#define MAX_BYTES_PER_NODE      10

ASN1uint32_t _BEREncOidNode64(ASN1encoding_t enc, unsigned __int64 n64, ASN1octet_t *pOut)
{
    ASN1uint32_t Low32, i, cb;
    ASN1octet_t aLittleEndian[MAX_BYTES_PER_NODE];

    RtlZeroMemory(aLittleEndian, sizeof(aLittleEndian));
    for (i = 0; n64 != 0; i++)
    {
        Low32 = *(ASN1uint32_t *) &n64;
        aLittleEndian[i] = (ASN1octet_t) (Low32 & 0x7f);
        n64 = Int64ShrlMod32(n64, 7);
    }
    cb = i ? i : 1; // at least one byte for zero value
    EncAssert(enc, cb <= MAX_BYTES_PER_NODE);
    if (cb > MAX_BYTES_PER_NODE)
    {
        cb = MAX_BYTES_PER_NODE;
    }
    for (i = 0; i < cb; i++)
    {
        EncAssert(enc, 0 == (0x80 & aLittleEndian[cb - i - 1]));
        *pOut++ = (ASN1octet_t) (0x80 | aLittleEndian[cb - i - 1]);
    }
    *(pOut-1) &= 0x7f;
    return cb;
}


ASN1uint32_t _BERDecOidNode64(unsigned __int64 *pn64, ASN1octet_t *pIn)
{
    ASN1uint32_t c;
    *pn64 = 0;
    for (c = 1; TRUE; c++)
    {
        *pn64 = Int64ShllMod32(*pn64, 7) + (unsigned __int64) (*pIn & 0x7f);
        if (!(*pIn++ & 0x80))
        {
            return c;
        }
    }
    return 0;
}


/* encode an object identifier value */
int ASN1BEREncEoid(ASN1encoding_t enc, ASN1uint32_t tag, ASN1encodedOID_t *val)
{
    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        /* encode length */
        int rc = ASN1BEREncLength(enc, val->length);
        if (rc)
        {
            /* copy value */
            RtlCopyMemory(enc->pos, val->value, val->length);
            enc->pos += val->length;
        }
        return rc;
    }
    return 0;
}

/* decode object identifier value */
int ASN1BERDecEoid(ASN1decoding_t dec, ASN1uint32_t tag, ASN1encodedOID_t *val)
{
    val->length = 0; // safety net
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        ASN1uint32_t len;
        if (ASN1BERDecLength(dec, &len, NULL))
        {
            val->length = (ASN1uint16_t) len;
            if (len)
            {
                val->value = (ASN1octet_t *) DecMemAlloc(dec, len);
                if (val->value)
                {
                    RtlCopyMemory(val->value, dec->pos, len);
                    dec->pos += len;
                    return 1;
                }
            }
            else
            {
                val->value = NULL;
                return 1;
            }
        }
    }
    return 0;
}


void ASN1BEREoid_free(ASN1encodedOID_t *val)
{
    if (val)
    {
        MemFree(val->value);
    }
}

#endif // ENABLE_BER

static const ASN1uint8_t
c_aBitMask[] = {
    0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff
};

static const ASN1uint8_t
c_aBitMask4[] = {
    0xff, 0x7f, 0x3f, 0x1f, 0x0f, 0x07, 0x03, 0x01, 0x00
};

static const ASN1int32_t
c_aBitMask5[] = {
    (ASN1int32_t)0xffffffff, (ASN1int32_t)0xfffffffe,
    (ASN1int32_t)0xfffffffc, (ASN1int32_t)0xfffffff8,
    (ASN1int32_t)0xfffffff0, (ASN1int32_t)0xffffffe0,
    (ASN1int32_t)0xffffffc0, (ASN1int32_t)0xffffff80,
    (ASN1int32_t)0xffffff00, (ASN1int32_t)0xfffffe00,
    (ASN1int32_t)0xfffffc00, (ASN1int32_t)0xfffff800,
    (ASN1int32_t)0xfffff000, (ASN1int32_t)0xffffe000,
    (ASN1int32_t)0xffffc000, (ASN1int32_t)0xffff8000,
    (ASN1int32_t)0xffff0000, (ASN1int32_t)0xfffe0000,
    (ASN1int32_t)0xfffc0000, (ASN1int32_t)0xfff80000,
    (ASN1int32_t)0xfff00000, (ASN1int32_t)0xffe00000,
    (ASN1int32_t)0xffc00000, (ASN1int32_t)0xff800000,
    (ASN1int32_t)0xff000000, (ASN1int32_t)0xfe000000,
    (ASN1int32_t)0xfc000000, (ASN1int32_t)0xf8000000,
    (ASN1int32_t)0xf0000000, (ASN1int32_t)0xe0000000,
    (ASN1int32_t)0xc0000000, (ASN1int32_t)0x80000000,
    (ASN1int32_t)0x00000000
};

static const ASN1uint8_t
c_aBitCount[] = {
    0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
    4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8
};

/* copy nbits bits from src/srcbit into dst/dstbit;
   src points to first octet containing bits to be copied
   srcbit names the first bit within the first octet to be copied (0=msb, 7=lsb)
   dst points to first octet to copy into
   dstbit names the first bit within the first octet to copy into (0=msb, 7=lsb)
   nbits is the number of bits to copy;
   assumes that bits of broken octet at dst/dstbit are cleared;
   bits of last octet behind dst/dstbit+nbits-1 will be cleared
*/
void ASN1bitcpy(ASN1octet_t *dst, ASN1uint32_t dstbit, ASN1octet_t *src, ASN1uint32_t srcbit, ASN1uint32_t nbits)
{
    ASN1uint32_t xsrcbit, xdstbit;

    if (!nbits)
        return;

    if (dstbit >= 8) {
        dst += dstbit / 8;
        dstbit &= 7;
    }
    if (srcbit >= 8) {
        src += srcbit / 8;
        srcbit &= 7;
    }

    /* check if we have to fill broken first octet */
    if (dstbit) {
        xdstbit = 8 - dstbit;

        /* enough bits to fill up broken octet? */
        if (nbits >= xdstbit) {
            if (srcbit < dstbit) {
                *dst++ |= (*src >> (dstbit - srcbit)) & c_aBitMask[xdstbit];
                nbits -= xdstbit;
                srcbit += xdstbit;
                dstbit = 0;
            } else if (srcbit == dstbit) {
                *dst++ |= *src++ & c_aBitMask[xdstbit];
                nbits -= xdstbit;
                srcbit = 0;
                dstbit = 0;
            } else {
                *dst++ |= ((*src & c_aBitMask[8 - srcbit]) << (srcbit - dstbit)) |
                    (src[1] >> (8 - (srcbit - dstbit)));
                nbits -= xdstbit;
                src++;
                srcbit -= dstbit;
                dstbit = 0;
            }

        /* less bits to fill than needed to fill up the broken octet */
        } else {
            if (srcbit <= dstbit) {
                *dst |= ((*src >> (8 - srcbit - nbits)) & c_aBitMask[nbits]) <<
                    (xdstbit - nbits);
            } else {
                *dst++ |= ((*src & c_aBitMask[8 - srcbit]) << (srcbit - dstbit)) |
                    ((src[1] >> (16 - srcbit - nbits)) << (xdstbit - nbits));
            }
            return;
        }
    }

    /* fill up complete octets */
    if (nbits >= 8) {
        if (!srcbit) {
            RtlCopyMemory(dst, src, nbits / 8);
            dst += nbits / 8;
            src += nbits / 8;
            nbits &= 7;
        } else {
            xsrcbit = 8 - srcbit;
            do {
                *dst++ = (*src << srcbit) | (src[1] >> (xsrcbit));
                src++;
                nbits -= 8;
            } while (nbits >= 8);
        }
    }

    /* fill bits into last octet */
    if (nbits)
        {
                *dst = (*src << srcbit) & c_aBitMask2[nbits];
                // lonchanc: made the following fix for the case that
                // src bits across byte boundary.
                if (srcbit + nbits > 8)
                {
                        xsrcbit = nbits - (8 - srcbit);
                        src++;
                        *dst |= ((*src & c_aBitMask2[xsrcbit]) >> (8 - srcbit));
                }
        }
}

/* clear nbits bits at dst/dstbit;
   bits of last octet behind dst/dstbit+nbits-1 will be cleared
*/
void ASN1bitclr(ASN1octet_t *dst, ASN1uint32_t dstbit, ASN1uint32_t nbits)
{
    ASN1uint32_t xdstbit;

    if (!nbits)
        return;

    if (dstbit >= 8) {
        dst += dstbit / 8;
        dstbit &= 7;
    }

    /* clear broken ASN1octet first */
    if (dstbit) {
        xdstbit = 8 - dstbit;
        *dst &= c_aBitMask2[xdstbit];
        if (xdstbit < nbits) {
            dst++;
            nbits -= xdstbit;
        } else {
            return;
        }
    }

    /* clear remaining bits */
    RtlZeroMemory(dst, (nbits + 7) / 8);
}

/* clear nbits bits at dst/dstbit;
   bits of last octet behind dst/dstbit+nbits-1 will be cleared
*/
void ASN1bitset(ASN1octet_t *dst, ASN1uint32_t dstbit, ASN1uint32_t nbits)
{
    ASN1uint32_t xdstbit;

    if (!nbits)
        return;

    if (dstbit >= 8) {
        dst += dstbit / 8;
        dstbit &= 7;
    }

    /* set broken ASN1octet first */
    if (dstbit) {
        xdstbit = 8 - dstbit;
        if (xdstbit < nbits) {
            *dst |= c_aBitMask4[xdstbit];
            dst++;
            nbits -= xdstbit;
        } else {
            *dst |= c_aBitMask4[nbits] << (xdstbit - nbits);
            return;
        }
    }

    /* set complete octets */
    if (nbits >= 8) {
        memset(dst, 0xff, nbits / 8);
        dst += nbits / 8;
        nbits &= 7;
    }

    /* set remaining bits */
    if (nbits)
        *dst |= c_aBitMask4[nbits] << (8 - nbits);
}

/* write nbits bits of val at dst/dstbit;
   assumes that bits of broken octet at dst/dstbit are cleared;
   bits of last octet behind dst/dstbit+nbits-1 will be cleared
*/
void ASN1bitput(ASN1octet_t *dst, ASN1uint32_t dstbit, ASN1uint32_t val, ASN1uint32_t nbits)
{
    ASN1uint32_t xdstbit;

    if (!nbits)
        return;

    if (dstbit >= 8) {
        dst += dstbit / 8;
        dstbit &= 7;
    }
    xdstbit = 8 - dstbit;

    /* fill up broken octet first */
    if (dstbit) {
        if (xdstbit <= nbits) {
            *dst++ |= val >> (nbits -= xdstbit);
        } else {
            *dst |= (val & c_aBitMask[nbits]) << (xdstbit - nbits);
            return;
        }
    }

    /* copy complete octets */
    while (nbits >= 8)
        *dst++ = (ASN1octet_t) (val >> (nbits -= 8));

    /* copy left bits */
    if (nbits)
        *dst = (ASN1octet_t) ((val & c_aBitMask[nbits]) << (8 - nbits));
}

/* read nbits bits of val at src/srcbit */
// lonchanc: the return value is independent of big or little endian
// because we use shift left within a long integer.
ASN1uint32_t ASN1bitgetu(ASN1octet_t *src, ASN1uint32_t srcbit, ASN1uint32_t nbits)
{
    ASN1uint32_t xsrcbit;
    ASN1uint32_t ret;

    if (!nbits)
        return 0;

    if (srcbit >= 8) {
        src += srcbit / 8;
        srcbit &= 7;
    }
    xsrcbit = 8 - srcbit;
    ret = 0;

    /* get bits from broken octet first */
    if (srcbit) {
        if (xsrcbit <= nbits) {
            ret = (*src++ & c_aBitMask[xsrcbit]) << (nbits -= xsrcbit);
        } else {
            return (*src >> (xsrcbit - nbits)) & c_aBitMask[nbits];
        }
    }

    /* get complete octets */
    while (nbits >= 8)
        ret |= *src++ << (nbits -= 8);

    /* get left bits */
    if (nbits)
        ret |= ((*src) >> (8 - nbits)) & c_aBitMask[nbits];
    return ret;
}

/* read nbits bits of val at src/srcbit */
ASN1int32_t ASN1bitget(ASN1octet_t *src, ASN1uint32_t srcbit, ASN1uint32_t nbits)
{
    ASN1uint32_t xsrcbit;
    ASN1int32_t ret;

    if (!nbits)
        return 0;

    if (srcbit >= 8) {
        src += srcbit / 8;
        srcbit &= 7;
    }
    xsrcbit = 8 - srcbit;
    if (*src & (0x80 >> srcbit))
        ret = c_aBitMask5[nbits];
    else
        ret = 0;

    /* get bits from broken octet first */
    if (srcbit) {
        if (xsrcbit <= nbits) {
            ret = *src++ << (nbits -= xsrcbit);
        } else {
            return (*src >> (xsrcbit - nbits)) & c_aBitMask[nbits];
        }
    }

    /* get complete octets */
    while (nbits >= 8)
        ret |= *src++ << (nbits -= 8);

    /* get left bits */
    if (nbits)
        ret |= ((*src) >> (8 - nbits)) & c_aBitMask[nbits];
    return ret;
}

/* get number of set bits in nbits bits at src/srcbit */
ASN1uint32_t ASN1bitcount(ASN1octet_t *src, ASN1uint32_t srcbit, ASN1uint32_t nbits)
{
    ASN1uint32_t xsrcbit;
    ASN1uint32_t ret;

    if (!nbits)
        return 0;

    if (srcbit >= 8) {
        src += srcbit / 8;
        srcbit &= 7;
    }
    xsrcbit = 8 - srcbit;

    /* count bits from broken octet first */
    if (srcbit) {
        if (xsrcbit <= nbits) {
            ret = c_aBitCount[*src++ & c_aBitMask4[srcbit]];
            nbits -= xsrcbit;
        } else {
            return c_aBitCount[(*src >> (xsrcbit - nbits)) & c_aBitMask[nbits]];
        }
    } else {
        ret = 0;
    }

    /* count bits in complete octets */
    while (nbits >= 8)
	{
        ret += c_aBitCount[*src++];
		nbits -= 8;
	}

    /* count left bits */
    if (nbits)
        ret += c_aBitCount[(*src) & c_aBitMask2[nbits]];
    return ret;
}

/* write noctets of val at dst */
void ASN1octetput(ASN1octet_t *dst, ASN1uint32_t val, ASN1uint32_t noctets)
{
    switch (noctets) {
    case 4:
        *dst++ = (ASN1octet_t)(val >> 24);
        /*FALLTHROUGH*/
    case 3:
        *dst++ = (ASN1octet_t)(val >> 16);
        /*FALLTHROUGH*/
    case 2:
        *dst++ = (ASN1octet_t)(val >> 8);
        /*FALLTHROUGH*/
    case 1:
        *dst++ = (ASN1octet_t)(val);
        break;
    default:
    break;
        MyAssert(0);
        /*NOTREACHED*/
    }
}

/* read noctets of val at dst */
ASN1uint32_t ASN1octetget(ASN1octet_t *src, ASN1uint32_t noctets)
{
    switch (noctets) {
    case 4:
        return (*src << 24) | (src[1] << 16) | (src[2] << 8) | src[3];
    case 3:
        return (*src << 16) | (src[1] << 8) | src[2];
    case 2:
        return (*src << 8) | src[1];
    case 1:
        return *src;
    default:
        MyAssert(0);
        return(0);
        /*NOTREACHED*/
    }
}

/* check if a 16 bit character is a space */
int ASN1is16space(ASN1char16_t c)
{
    return c == ' ' || c == '\t' || c == '\b' || c == '\f' || c == '\r' ||
	c == '\n' || c == '\v';
}

/* get length of a 16 bit string */
// lonchanc: lstrlenW()
int ASN1str16len(ASN1char16_t *p)
{
    
    int len;

    for (len = 0; *p; p++)
        len++;
    return len;
}

#ifdef USE_lstrlen
int My_lstrlenA(char *p)
{
    return (NULL != p) ? lstrlenA(p) : 0;
}

int My_lstrlenW(WCHAR *p)
{
    return (NULL != p) ? lstrlenW(p) : 0;
}
#else
int My_lstrlenA( char* lpString )
{
    if (lpString == NULL)
        return 0;
#ifdef EXCEPTIONS_ALLOWED
    __try
    {
        return strlen(lpString);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        return 0;
    }
#else
    return strlen(lpString);
#endif
}

int My_lstrlenW( WCHAR* lpString )
{
    if (lpString == NULL)
        return 0;
#ifdef EXCEPTIONS_ALLOWED
    __try
    {
        return wcslen(lpString);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        return 0;
    }
#else
    return wcslen(lpString);
#endif
}
#endif

/* check if a 32 bit character is a space */
int ASN1is32space(ASN1char32_t c)
{
    return c == ' ' || c == '\t' || c == '\b' || c == '\f' || c == '\r' ||
            c == '\n' || c == '\v';
}

/* get length of a 32 bit string */
int ASN1str32len(ASN1char32_t *p)
{
    int len;

    for (len = 0; *p; p++)
        len++;
    return len;
}

/* external use only, allocate memory for decoding */
LPVOID ASN1DecAlloc(ASN1decoding_t dec, ASN1uint32_t size)
{
    return DecMemAlloc(dec, size);
}

/* external use only, reallocate memory for decoding */
LPVOID ASN1DecRealloc(ASN1decoding_t dec, LPVOID ptr, ASN1uint32_t size)
{
    return DecMemReAlloc(dec, ptr, size);
}

/* external use only, free a memory block */
void ASN1Free(LPVOID ptr)
{
    MemFree(ptr);
}

// lonchanc: we need to re-visit this approach of aborting a decoding
/* abort decoding, free any memory allocated for decoding */
void ASN1DecAbort(ASN1decoding_t dec)
{
    ASN1INTERNdecoding_t d = ((ASN1INTERNdecoding_t)dec)->parent;

#ifdef ENABLE_EXTRA_INFO
    /* clear the lists */
    d->memlength = d->epilength = d->csilength = 0;
    d->memsize = d->episize = d->csisize = 0;
    MemFree(d->mem);
    MemFree(d->epi);
    MemFree(d->csi);
    d->mem = NULL;
    d->epi = NULL;
    d->csi = NULL;
#endif // ENABLE_EXTRA_INFO
}

// lonchanc: we need to re-visit this approach of aborting a decoding
/* finish decoding */
void ASN1DecDone(ASN1decoding_t dec)
{
    ASN1INTERNdecoding_t d = ((ASN1INTERNdecoding_t)dec)->parent;

#ifdef ENABLE_EXTRA_INFO
    /* clear the lists */
    d->memlength = d->epilength = d->csilength = 0;
    d->memsize = d->episize = d->csisize = 0;
    MemFree(d->mem);
    MemFree(d->epi);
    MemFree(d->csi);
    d->mem = NULL;
    d->epi = NULL;
    d->csi = NULL;
#endif // ENABLE_EXTRA_INFO
}

// lonchanc: we need to re-visit this approach of aborting a decoding
/* abort encoding, free any memory allocated for encoding */
void ASN1EncAbort(ASN1encoding_t enc)
{
    ASN1INTERNencoding_t e = ((ASN1INTERNencoding_t)enc)->parent;

#ifdef ENABLE_EXTRA_INFO
    /* clear the lists */
    e->memlength = e->epilength = e->csilength = 0;
    e->memsize = e->episize = e->csisize = 0;
    MemFree(e->mem);
    MemFree(e->epi);
    MemFree(e->csi);
    e->mem = NULL;
    e->epi = NULL;
    e->csi = NULL;
#endif // ENABLE_EXTRA_INFO
}

// lonchanc: we need to re-visit this approach of aborting a decoding
/* finish encoding */
void ASN1EncDone(ASN1encoding_t enc)
{
    ASN1INTERNencoding_t e = ((ASN1INTERNencoding_t)enc)->parent;

#ifdef ENABLE_EXTRA_INFO
    /* clear the lists */
    e->memlength = e->epilength = e->csilength = 0;
    e->memsize = e->episize = e->csisize = 0;
    MemFree(e->mem);
    MemFree(e->epi);
    MemFree(e->csi);
    e->mem = NULL;
    e->epi = NULL;
    e->csi = NULL;
#endif // ENABLE_EXTRA_INFO
}


/* search the identification of an embedded pdv */
#ifdef ENABLE_EMBEDDED_PDV
int ASN1EncSearchEmbeddedPdvIdentification(ASN1INTERNencoding_t e, ASN1embeddedpdv_identification_t *identification, ASN1uint32_t *index, ASN1uint32_t *flag)
{
    ASN1embeddedpdv_identification_t **id;

    /* search identification in indentification list */
    /* if found then reset flag (to indicate EP-B encoding) and return */
    for (*index = 0, id = e->epi; *index < e->epilength; (*index)++, id++) {
        if ((*id)->o == identification->o) {
            switch ((*id)->o) {
            case ASN1embeddedpdv_identification_syntaxes_o:
                if (!ASN1objectidentifier_cmp(&(*id)->u.syntaxes.abstract,
                    &identification->u.syntaxes.abstract) &&
                    !ASN1objectidentifier_cmp(&(*id)->u.syntaxes.transfer,
                    &identification->u.syntaxes.transfer)) {
                    *flag = 0;
                    return 1;
                }
                break;
            case ASN1embeddedpdv_identification_syntax_o:
                if (!ASN1objectidentifier_cmp(&(*id)->u.syntax,
                    &identification->u.syntax)) {
                    *flag = 0;
                    return 1;
                }
                break;
            case ASN1embeddedpdv_identification_presentation_context_id_o:
                if ((*id)->u.presentation_context_id ==
                    identification->u.presentation_context_id) {
                    *flag = 0;
                    return 1;
                }
                break;
            case ASN1embeddedpdv_identification_context_negotiation_o:
                if ((*id)->u.context_negotiation.presentation_context_id ==
                    identification->u.context_negotiation.
                    presentation_context_id &&
                    !ASN1objectidentifier_cmp(
                    &(*id)->u.context_negotiation.transfer_syntax,
                    &identification->u.context_negotiation.transfer_syntax)) {
                    *flag = 0;
                    return 1;
                }
                break;
            case ASN1embeddedpdv_identification_transfer_syntax_o:
                if (!ASN1objectidentifier_cmp(&(*id)->u.transfer_syntax,
                    &identification->u.transfer_syntax)) {
                    *flag = 0;
                    return 1;
                }
                break;
            case ASN1embeddedpdv_identification_fixed_o:
                *flag = 0;
                return 1;
            default:
                e->parent->info.err = ASN1_ERR_CORRUPT;
                return 0;
            }
        }
    }
    /* identification not found */

    /* add it into indentification array */
    if (e->epilength >= e->episize) {
        e->episize = e->episize ? 4 * e->episize : 16;
        e->epi = (ASN1embeddedpdv_identification_t **)MemReAlloc(e->epi,
            e->episize * sizeof(ASN1embeddedpdv_identification_t *), _ModName((ASN1encoding_t) e));
        if (!e->epi)
        {
            ASN1EncSetError((ASN1encoding_t) e, ASN1_ERR_MEMORY);
            return 0;
        }
    }
    e->epi[e->epilength++] = identification;

    /* return flag for EP-A encoding */
    *flag = 1;
    return 1;
}
#endif // ENABLE_EMBEDDED_PDV

/* search the identification of an character string */
#ifdef ENABLE_GENERALIZED_CHAR_STR
int ASN1EncSearchCharacterStringIdentification(ASN1INTERNencoding_t e, ASN1characterstring_identification_t *identification, ASN1uint32_t *index, ASN1uint32_t *flag)
{
    ASN1characterstring_identification_t **id;

    /* search identification in indentification list */
    /* if found then reset flag (to indicate CS-B encoding) and return */
    for (*index = 0, id = e->csi; *index < e->csilength; (*index)++, id++) {
        if ((*id)->o == identification->o) {
            switch ((*id)->o) {
            case ASN1characterstring_identification_syntaxes_o:
                if (!ASN1objectidentifier_cmp(&(*id)->u.syntaxes.abstract,
                    &identification->u.syntaxes.abstract) &&
                    !ASN1objectidentifier_cmp(&(*id)->u.syntaxes.transfer,
                    &identification->u.syntaxes.transfer)) {
                    *flag = 0;
                    return 1;
                }
                break;
            case ASN1characterstring_identification_syntax_o:
                if (!ASN1objectidentifier_cmp(&(*id)->u.syntax,
                    &identification->u.syntax)) {
                    *flag = 0;
                    return 1;
                }
                break;
            case ASN1characterstring_identification_presentation_context_id_o:
                if ((*id)->u.presentation_context_id ==
                    identification->u.presentation_context_id) {
                    *flag = 0;
                    return 1;
                }
                break;
            case ASN1characterstring_identification_context_negotiation_o:
                if ((*id)->u.context_negotiation.presentation_context_id ==
                    identification->u.context_negotiation.
                    presentation_context_id &&
                    !ASN1objectidentifier_cmp(
                    &(*id)->u.context_negotiation.transfer_syntax,
                    &identification->u.context_negotiation.transfer_syntax)) {
                    *flag = 0;
                    return 1;
                }
                break;
            case ASN1characterstring_identification_transfer_syntax_o:
                if (!ASN1objectidentifier_cmp(&(*id)->u.transfer_syntax,
                    &identification->u.transfer_syntax)) {
                    *flag = 0;
                    return 1;
                }
                break;
            case ASN1characterstring_identification_fixed_o:
                *flag = 0;
                return 1;
            default:
                e->parent->info.err = ASN1_ERR_CORRUPT;
                return 0;
            }
        }
    }
    /* identification not found */

    /* add it into indentification array */
    if (e->csilength >= e->csisize) {
        e->csisize = e->csisize ? 4 * e->csisize : 16;
        e->csi = (ASN1characterstring_identification_t **)MemReAlloc(e->csi,
            e->csisize * sizeof(ASN1characterstring_identification_t *), _ModName((ASN1encoding_t) e));
        if (!e->csi)
        {
            ASN1EncSetError((ASN1encoding_t) e, ASN1_ERR_MEMORY);
            return 0;
        }
    }
    e->csi[e->csilength++] = identification;

    /* return flag for CS-A encoding */
    *flag = 1;
    return 1;
}
#endif // ENABLE_GENERALIZED_CHAR_STR

/* allocate and copy an object identifier */
#if defined(ENABLE_GENERALIZED_CHAR_STR) || defined(ENABLE_EMBEDDED_PDV)
int ASN1DecDupObjectIdentifier(ASN1decoding_t dec, ASN1objectidentifier_t *dst, ASN1objectidentifier_t *src)
{
    ASN1INTERNdecoding_t d = ((ASN1INTERNdecoding_t)dec)->parent;
    ASN1uint32_t l = GetObjectIdentifierCount(*src);
    *dst = DecAllocObjectIdentifier(dec, l);
    if (! *dst)
    {
        ASN1DecSetError((ASN1decoding_t) d, ASN1_ERR_MEMORY);
        return 0;
    }
    CopyObjectIdentifier(*dst, *src);
    return 1;
}
#endif // defined(ENABLE_GENERALIZED_CHAR_STR) || defined(ENABLE_EMBEDDED_PDV)

/* add an embedded pdv identification to the list of identifications */
#ifdef ENABLE_EMBEDDED_PDV
int ASN1DecAddEmbeddedPdvIdentification(ASN1INTERNdecoding_t d, ASN1embeddedpdv_identification_t *identification)
{
    if (d->epilength >= d->episize) {
        d->episize = d->episize ? 4 * d->episize : 16;
        d->epi = (ASN1embeddedpdv_identification_t **)MemReAlloc(d->epi,
            d->episize * sizeof(ASN1embeddedpdv_identification_t *), _ModName((ASN1decoding_t) d));
        if (!d->epi)
        {
            ASN1DecSetError((ASN1decoding_t) d, ASN1_ERR_MEMORY);
            return 0;
        }
    }
    d->epi[d->epilength++] = identification;
    return 1;
}
#endif // ENABLE_EMBEDDED_PDV

/* get an embedded pdv identification from the list of identifications */
#ifdef ENABLE_EMBEDDED_PDV
ASN1embeddedpdv_identification_t *ASN1DecGetEmbeddedPdvIdentification(ASN1INTERNdecoding_t d, ASN1uint32_t index)
{
    if (index >= d->epilength)
    {
        ASN1DecSetError((ASN1decoding_t) d, ASN1_ERR_CORRUPT);
        return NULL;
    }
    return d->epi[index];
}
#endif // ENABLE_EMBEDDED_PDV

/* add a character string identification to the list of identifications */
#ifdef ENABLE_GENERALIZED_CHAR_STR
int ASN1DecAddCharacterStringIdentification(ASN1INTERNdecoding_t d, ASN1characterstring_identification_t *identification)
{
    if (d->csilength >= d->csisize) {
        d->csisize = d->csisize ? 4 * d->csisize : 16;
        d->csi = (ASN1characterstring_identification_t **)MemReAlloc(d->csi,
            d->csisize * sizeof(ASN1characterstring_identification_t *), _ModName((ASN1decoding_t) d));
        if (!d->csi)
        {
            ASN1DecSetError((ASN1decoding_t) d, ASN1_ERR_MEMORY);
            return 0;
        }
    }
    d->csi[d->csilength++] = identification;
    return 1;
}
#endif // ENABLE_GENERALIZED_CHAR_STR

/* get a character string identification from the list of identifications */
#ifdef ENABLE_GENERALIZED_CHAR_STR
ASN1characterstring_identification_t *ASN1DecGetCharacterStringIdentification(ASN1INTERNdecoding_t d, ASN1uint32_t index)
{
    if (index >= d->csilength)
    {
        ASN1DecSetError((ASN1decoding_t) d, ASN1_ERR_CORRUPT);
        return NULL;
    }
    return d->csi[index];
}
#endif // ENABLE_GENERALIZED_CHAR_STR

ASN1error_e ASN1EncSetError(ASN1encoding_t enc, ASN1error_e err)
{
    ASN1INTERNencoding_t e = (ASN1INTERNencoding_t) enc;
    EncAssert(enc, ASN1_SUCCESS <= err);
    while (e)
    {
        e->info.err = err;
        if (e == e->parent)
        {
            break;
        }
        e = e->parent;
    }
    return err;
}

ASN1error_e ASN1DecSetError(ASN1decoding_t dec, ASN1error_e err)
{
    ASN1INTERNdecoding_t d = (ASN1INTERNdecoding_t) dec;
    DecAssert(dec, ASN1_SUCCESS <= err);
    while (d)
    {
        d->info.err = err;
        if (d == d->parent)
        {
            break;
        }
        d = d->parent;
    }
    return err;
}

#ifdef _DEBUG
void MyDebugBreak(void)
{
    DebugBreak();
}
#endif // _DEBUG

// Memory manager for decoder
LPVOID DecMemAlloc ( ASN1decoding_t dec, ASN1uint32_t cbSize )
{
    LPVOID lp = NULL;
    ASN1INTERNdecoding_t lpInfo = (ASN1INTERNdecoding_t) dec;
    // make sure the size is 4-byte aligned
    ASN1_SIZE_ALIGNED(cbSize);
    // accumulate the total size
    lpInfo->cbLinearBufSize += cbSize;
    // allocate the buffer
    if (lpInfo->fExtBuf)
    {
        if (lpInfo->cbRemExtBufSize >= cbSize)
        {
            lp = lpInfo->lpRemExtBuf;
            lpInfo->lpRemExtBuf += cbSize;
            lpInfo->cbRemExtBufSize -= cbSize;
        }
        else
        {
            DecAssert(dec, FALSE);
        }
    }
    else
    {
        lp = MemAllocEx(dec, cbSize, TRUE); // zero memory
    }
    // make sure to propagate error
    if (lp == NULL)
    {
        ASN1DecSetError(dec, ASN1_ERR_MEMORY);
    }
    return lp;
}

void DecMemFree ( ASN1decoding_t dec, LPVOID lpData )
{
    if (! ((ASN1INTERNdecoding_t) dec)->fExtBuf)
    {
        MemFree(lpData);
    }
}

LPVOID DecMemReAlloc ( ASN1decoding_t dec, LPVOID lpData, ASN1uint32_t cbSize )
{
    LPVOID lp = NULL;
    // make sure the size is 4-byte aligned
    ASN1_SIZE_ALIGNED(cbSize);
    // accumulate the total size
    ((ASN1INTERNdecoding_t) dec)->cbLinearBufSize += cbSize;
    // allocate the buffer
    if (((ASN1INTERNdecoding_t) dec)->fExtBuf)
    {
        if (lpData == NULL)
        {
            lp = DecMemAlloc(dec, cbSize);
        }
        else
        {
            DecAssert(dec, FALSE);
        }
    }
    else
    {
        lp = MemReAllocEx(dec, lpData, cbSize, TRUE); // zero memory
    }
    // make sure to propagate error
    if (lp == NULL)
    {
        ASN1DecSetError(dec, ASN1_ERR_MEMORY);
    }
    return lp;
}



/***
*char *ms_bSearch() - do a binary search on an array
*
*Purpose:
*       Does a binary search of a sorted array for a key.
*
*Entry:
*       const char *key    - key to search for
*       const char *base   - base of sorted array to search
*       unsigned int num   - number of elements in array
*       unsigned int width - number of bytes per element
*       int (*compare)()   - pointer to function that compares two array
*               elements, returning neg when #1 < #2, pos when #1 > #2, and
*               0 when they are equal. Function is passed pointers to two
*               array elements.
*
*Exit:
*       if key is found:
*               returns pointer to occurrence of key in array
*       if key is not found:
*               returns NULL
*
*Exceptions:
*
*******************************************************************************/

void * ms_bSearch (
        const void *key,
        const void *base,
        size_t num,
        size_t width,
        int (__cdecl *compare)(const void *, const void *)
        )
{
        char *lo = (char *)base;
        char *hi = (char *)base + (num - 1) * width;
        char *mid;
        unsigned int half;
        int result;

        while (lo <= hi)
                if (half = num / 2)
                {
                        mid = lo + (num & 1 ? half : (half - 1)) * width;
                        if (!(result = (*compare)(key,mid)))
                                return(mid);
                        else if (result < 0)
                        {
                                hi = mid - width;
                                num = num & 1 ? half : half-1;
                        }
                        else    {
                                lo = mid + width;
                                num = half;
                        }
                }
                else if (num)
                        return((*compare)(key,lo) ? NULL : lo);
                else
                        break;

        return(NULL);
}


int IsDigit(char p)
{
      return ((p >= ('0')) && (p <=('9'))) ? 1 : 0 ;
}



// BUGBUG - This is a copy of the same routine in nmutil
// BUGBUG - Remove this when we convert our files to CPP and use nmutil
/*  D E C I M A L  S T R I N G  T O  U  I  N  T  */
/*-------------------------------------------------------------------------
    %%Function: DecimalStringToUINT
    
-------------------------------------------------------------------------*/
unsigned int  DecimalStringToUINT(char * pcszString, ASN1uint32_t cch)
{
	unsigned int uRet = 0;
	char * pszStr =  pcszString;
	while (cch-- && ('\0') != pszStr[0])
	{
		uRet = (10 * uRet) + (int) (pszStr[0] - ('0'));
		pszStr++; // NOTE: DBCS characters are not allowed!
	}
	return uRet;
}


#ifdef ENABLE_BER
int My_memcmp(ASN1octet_t *pBuf1, ASN1uint32_t cbBuf1Size, ASN1octet_t *pBuf2, ASN1uint32_t cbBuf2Size)
{
    int diff;
    ASN1uint32_t cbMinBufSize = (cbBuf1Size < cbBuf2Size) ? cbBuf1Size : cbBuf2Size;
    while (cbMinBufSize--)
    {
        diff = (int) (ASN1uint32_t) *pBuf1++ - (int) (ASN1uint32_t) *pBuf2++;
        if (0 != diff)
        {
            return diff;
        }
    }
    return ((int) cbBuf1Size - (int) cbBuf2Size);
}
#endif // ENABLE_BER

#ifdef ENABLE_DOUBLE

const ASN1octet_t ASN1double_pinf_octets[] = DBL_PINF;
const ASN1octet_t ASN1double_minf_octets[] = DBL_MINF;

/* get a positive infinite double value */
double ASN1double_pinf()
{
    double val;
    MyAssert(sizeof(val) == sizeof(ASN1double_pinf_octets));
    RtlCopyMemory(&val, ASN1double_pinf_octets, sizeof(ASN1double_pinf_octets));
    return val;
}

/* get a negative infinite double value */
double ASN1double_minf()
{
    double val;
    MyAssert(sizeof(val) == sizeof(ASN1double_minf_octets));
    RtlCopyMemory(&val, ASN1double_minf_octets, sizeof(ASN1double_minf_octets));
    return val;
}

/* check if double is plus infinity */
int ASN1double_ispinf(double d)
{
#if HAS_FPCLASS
    return !finite(d) && fpclass(d) == FP_PINF;
#elif HAS_ISINF
    return !finite(d) && isinf(d) && copysign(1.0, d) > 0.0;
#else
#error "cannot encode NaN fp values"
#endif
}

/* check if double is minus infinity */
int ASN1double_isminf(double d)
{
#if HAS_FPCLASS
    return !finite(d) && fpclass(d) == FP_NINF;
#elif HAS_ISINF
    return !finite(d) && isinf(d) && copysign(1.0, d) < 0.0;
#else
#error "cannot encode NaN fp values"
#endif
}

#endif

/* convert a real value into a double */
#ifdef ENABLE_REAL
double ASN1real2double(ASN1real_t *val)
{
    ASN1intx_t exp;
    ASN1int32_t e;
    double m;

    switch (val->type) {
    case eReal_Normal:
        m = ASN1intx2double(&val->mantissa);
        if (val->base == 10) {
            return m * pow(10.0, (double)ASN1intx2int32(&val->exponent));
        } else {
            if (val->base == 2) {
                if (! ASN1intx_dup(&exp, &val->exponent))
                {
                    return 0.0;
                }
            } else if (val->base == 8) {
                ASN1intx_muloctet(&exp, &val->exponent, 3);
            } else if (val->base == 16) {
                ASN1intx_muloctet(&exp, &val->exponent, 4);
            } else {
                return 0.0;
            }
            e = ASN1intx2int32(&exp);
            ASN1intx_free(&exp);
            return ldexp(m, e);
        }
    case eReal_PlusInfinity:
        return ASN1double_pinf();
    case eReal_MinusInfinity:
        return ASN1double_minf();
    default:
        return 0.0;
    }
}
#endif // ENABLE_REAL

/* free a real value */
#ifdef ENABLE_REAL
void ASN1real_free(ASN1real_t *val)
{
    ASN1intx_free(&val->mantissa);
    ASN1intx_free(&val->exponent);
}
#endif // ENABLE_REAL

/* free a bitstring value */
void ASN1bitstring_free(ASN1bitstring_t *val)
{
    if (val)
    {
        // lonchanc: no need to check length because zeroed decoded buffers.
        MemFree(val->value);
    }
}

/* free an octet string value */
void ASN1octetstring_free(ASN1octetstring_t *val)
{
    if (val)
    {
        // lonchanc: no need to check length because zeroed decoded buffers.
        MemFree(val->value);
    }
}

/* free an object identifier value */
void ASN1objectidentifier_free(ASN1objectidentifier_t *val)
{
    if (val)
    {
        // lonchanc: we allocate the entire object identifer as a chunk.
        // as a result, we free it only once as a chunk.
        MemFree(*val);
    }
}

/* free a string value */
#ifdef ENABLE_BER
void ASN1charstring_free(ASN1charstring_t *val)
{
    if (val)
    {
        // lonchanc: no need to check length because zeroed decoded buffers.
        MemFree(val->value);
    }
}
#endif // ENABLE_BER

/* free a 16 bit string value */
void ASN1char16string_free(ASN1char16string_t *val)
{
    if (val)
    {
        // lonchanc: no need to check length because zeroed decoded buffers.
        MemFree(val->value);
    }
}

/* free a 32 bit string value */
#ifdef ENABLE_BER
void ASN1char32string_free(ASN1char32string_t *val)
{
    if (val)
    {
        // lonchanc: no need to check length because zeroed decoded buffers.
        MemFree(val->value);
    }
}
#endif // ENABLE_BER

/* free a zero-terminated string value */
void ASN1ztcharstring_free(ASN1ztcharstring_t val)
{
    MemFree(val);
}

/* free a zero-terminated 16 bit string value */
#ifdef ENABLE_BER
void ASN1ztchar16string_free(ASN1ztchar16string_t val)
{
    MemFree(val);
}
#endif // ENABLE_BER

/* free a zero-terminated 32 bit string value */
#ifdef ENABLE_BER
void ASN1ztchar32string_free(ASN1ztchar32string_t val)
{
    MemFree(val);
}
#endif // ENABLE_BER

/* free an external value */
#ifdef ENABLE_EXTERNAL
void ASN1external_free(ASN1external_t *val)
{
    if (val)
    {
        switch (val->identification.o)
        {
        case ASN1external_identification_syntax_o:
            ASN1objectidentifier_free(&val->identification.u.syntax);
            break;
        case ASN1external_identification_presentation_context_id_o:
            break;
        case ASN1external_identification_context_negotiation_o:
            ASN1objectidentifier_free(
                &val->identification.u.context_negotiation.transfer_syntax);
            break;
        }
        ASN1ztcharstring_free(val->data_value_descriptor);
        switch (val->data_value.o)
        {
        case ASN1external_data_value_notation_o:
            ASN1open_free(&val->data_value.u.notation);
            break;
        case ASN1external_data_value_encoded_o:
            ASN1bitstring_free(&val->data_value.u.encoded);
            break;
        }
    }
}
#endif // ENABLE_EXTERNAL

/* free an embedded pdv value */
#ifdef ENABLE_EMBEDDED_PDV
void ASN1embeddedpdv_free(ASN1embeddedpdv_t *val)
{
    if (val)
    {
        switch (val->identification.o)
        {
        case ASN1embeddedpdv_identification_syntaxes_o:
            ASN1objectidentifier_free(&val->identification.u.syntaxes.abstract);
            ASN1objectidentifier_free(&val->identification.u.syntaxes.transfer);
            break;
        case ASN1embeddedpdv_identification_syntax_o:
            ASN1objectidentifier_free(&val->identification.u.syntax);
            break;
        case ASN1embeddedpdv_identification_presentation_context_id_o:
            break;
        case ASN1embeddedpdv_identification_context_negotiation_o:
            ASN1objectidentifier_free(
                &val->identification.u.context_negotiation.transfer_syntax);
            break;
        case ASN1embeddedpdv_identification_transfer_syntax_o:
            ASN1objectidentifier_free(&val->identification.u.transfer_syntax);
            break;
        case ASN1embeddedpdv_identification_fixed_o:
            break;
        }
        switch (val->data_value.o)
        {
        case ASN1embeddedpdv_data_value_notation_o:
            ASN1open_free(&val->data_value.u.notation);
            break;
        case ASN1embeddedpdv_data_value_encoded_o:
            ASN1bitstring_free(&val->data_value.u.encoded);
            break;
        }
    }
}
#endif // ENABLE_EMBEDDED_PDV

/* free a character string value */
#ifdef ENABLE_GENERALIZED_CHAR_STR
void ASN1characterstring_free(ASN1characterstring_t *val)
{
    if (val)
    {
        switch (val->identification.o)
        {
        case ASN1characterstring_identification_syntaxes_o:
            ASN1objectidentifier_free(&val->identification.u.syntaxes.abstract);
            ASN1objectidentifier_free(&val->identification.u.syntaxes.transfer);
            break;
        case ASN1characterstring_identification_syntax_o:
            ASN1objectidentifier_free(&val->identification.u.syntax);
            break;
        case ASN1characterstring_identification_presentation_context_id_o:
            break;
        case ASN1characterstring_identification_context_negotiation_o:
            ASN1objectidentifier_free(
                &val->identification.u.context_negotiation.transfer_syntax);
            break;
        case ASN1characterstring_identification_transfer_syntax_o:
            ASN1objectidentifier_free(&val->identification.u.transfer_syntax);
            break;
        case ASN1characterstring_identification_fixed_o:
            break;
        }
        switch (val->data_value.o)
        {
        case ASN1characterstring_data_value_notation_o:
            ASN1open_free(&val->data_value.u.notation);
            break;
        case ASN1characterstring_data_value_encoded_o:
            ASN1octetstring_free(&val->data_value.u.encoded);
            break;
        }
    }
}
#endif // ENABLE_GENERALIZED_CHAR_STR

/* free an open type value */
#ifdef ENABLE_BER
void ASN1open_free(ASN1open_t *val)
{
    if (val)
    {
        // lonchanc: no need to check length because zeroed decoded buffers.
        MemFree(val->encoded);
    }
}
#endif // ENABLE_BER

#ifdef ENABLE_BER
void ASN1utf8string_free(ASN1wstring_t *val)
{
    if (val)
    {
        // lonchanc: no need to check length because zeroed decoded buffers.
        MemFree(val->value);
    }
}
#endif // ENABLE_BER

/* convert a generalized time value into a string */
int ASN1generalizedtime2string(char *dst, ASN1generalizedtime_t *val)
{
    if (dst && val)
    {
        sprintf(dst, "%04d%02d%02d%02d%02d%02d",
            val->year, val->month, val->day,
            val->hour, val->minute, val->second);
        if (val->millisecond) {
            if (!(val->millisecond % 100))
                sprintf(dst + 14, ".%01d", val->millisecond / 100);
            else if (!(val->millisecond % 10))
                sprintf(dst + 14, ".%02d", val->millisecond / 10);
            else
                sprintf(dst + 14, ".%03d", val->millisecond);
        }
        if (val->universal)
            strcpy(dst + My_lstrlenA(dst), "Z");
        else if (val->diff > 0) {
            if (val->diff % 60) {
                sprintf(dst + My_lstrlenA(dst), "+%04d",
                    100 * (val->diff / 60) + (val->diff % 60));
            } else {
                sprintf(dst + My_lstrlenA(dst), "+%02d",
                    val->diff / 60);
            }
        } else if (val->diff < 0) {
            if (val->diff % 60) {
                sprintf(dst + My_lstrlenA(dst), "-%04d",
                    -100 * (val->diff / 60) - (val->diff % 60));
            } else {
                sprintf(dst + My_lstrlenA(dst), "-%02d",
                    -val->diff / 60);
            }
        }
        return 1;
    }
    return 0;
}

/* convert a utc time value into a string */
#ifdef ENABLE_BER
int ASN1utctime2string(char *dst, ASN1utctime_t *val)
{
    if (dst && val)
    {
        sprintf(dst, "%02d%02d%02d%02d%02d%02d",
            val->year, val->month, val->day,
            val->hour, val->minute, val->second);
        if (val->universal)
            strcpy(dst + My_lstrlenA(dst), "Z");
        else if (val->diff > 0) {
            if (val->diff % 60) {
                sprintf(dst + My_lstrlenA(dst), "+%04d",
                    100 * (val->diff / 60) + (val->diff % 60));
            } else {
                sprintf(dst + My_lstrlenA(dst), "+%02d",
                    val->diff / 60);
            }
        } else if (val->diff < 0) {
            if (val->diff % 60) {
                sprintf(dst + My_lstrlenA(dst), "-%04d",
                    -100 * (val->diff / 60) - (val->diff % 60));
            } else {
                sprintf(dst + My_lstrlenA(dst), "-%02d",
                    -val->diff / 60);
            }
        }
        return 1;
    }
    return 0;
}
#endif // ENABLE_BER

//
// scan the decimal fraction of a number based on the base
// base must be a power of 10
//
static DWORD scanfrac(char *p, char **e, DWORD base)
{
    DWORD ret = 0;

    while (IsDigit(*p)) {
        if (base != 1)
        {
            base /= 10;
            ret = (ret * 10) + (*p++ - '0');
        }
        else
        {
            p++;
        }
    }
    *e = p;
    return ret * base;
}

/* convert a string into a generalized time value */
int ASN1string2generalizedtime(ASN1generalizedtime_t *dst, char *val)
{
    if (dst && val)
    {
        int year, month, day, hour, minute, second, millisecond, diff, universal;
        char *p;
        DWORD frac;
        DWORD temp;

        millisecond = second = minute = universal = diff = 0;
        if (My_lstrlenA(val) < 10)
        {
            return 0;
        }
        year = DecimalStringToUINT(val, 4);
        month = DecimalStringToUINT((val+4), 2);
        day = DecimalStringToUINT((val+6), 2);
        hour = DecimalStringToUINT((val+8), 2);
        p = val + 10;
        if (*p == '.' || *p == ',')
        {
            const DWORD base = 10000000;
            frac = scanfrac(p+1, &p, base);
            temp = frac * 60;
            minute = (temp / base);
            frac = temp % base;
            temp = frac * 60;
            second = (temp / base);
            frac = temp % base;
            millisecond = (frac / (base / 1000) );
        }
        else if (IsDigit(*p))
        {
            minute = DecimalStringToUINT(p, 2);
            p += 2;
            if (*p == '.' || *p == ',')
            {
                const DWORD base = 100000;
                frac = scanfrac(p+1, &p, base);
                temp = frac * 60;
                second = (temp / base);
                frac = temp % base;
                millisecond = (frac / (base / 1000) );
            } else if (IsDigit(*p))
            {
                second = DecimalStringToUINT(p, 2);
                p += 2;
                if (*p == '.' || *p == ',')
                {
                    const DWORD base = 1000;
                    frac = scanfrac(p+1, &p, base);
                    millisecond = frac;
                }
            }
        }
        if (*p == 'Z')
        {
            universal = 1;
            p++;
        }
        else if (*p == '+')
        {
            const DWORD base = 10000;
            frac = scanfrac(p + 1, &p, base);
            diff = frac / (base/100) * 60 + frac % 100;
        }
        else if (*p == '-')
        {
            const DWORD base = 10000;
            frac = scanfrac(p + 1, &p, base);
            diff = -((int)(frac / (base/100) * 60 + frac % 100));
        }
        if (*p)
        {
            return 0;
        }
        dst->year = (ASN1uint16_t)year;
        dst->month = (ASN1uint8_t)month;
        dst->day = (ASN1uint8_t)day;
        dst->hour = (ASN1uint8_t)hour;
        dst->minute = (ASN1uint8_t)minute;
        dst->second = (ASN1uint8_t)second;
        dst->millisecond = (ASN1uint16_t)millisecond;
        dst->universal = (ASN1bool_t)universal;
        dst->diff = (ASN1uint16_t)diff;
        return 1;
    }
    return 0;
}

/* convert a string into a utc time value */
#ifdef ENABLE_BER
int ASN1string2utctime(ASN1utctime_t *dst, char *val)
{
    if (dst && val)
    {
        char *p;
        DWORD frac;

        if (My_lstrlenA(val) < 10)
            return 0;

        p = val;
        dst->year = (ASN1uint8_t) DecimalStringToUINT(p, 2);
        p += 2;
        dst->month = (ASN1uint8_t) DecimalStringToUINT(p, 2);
        p += 2;
        dst->day = (ASN1uint8_t) DecimalStringToUINT(p, 2);
        p += 2;
        dst->hour = (ASN1uint8_t) DecimalStringToUINT(p, 2);
        p += 2;
        dst->minute = (ASN1uint8_t) DecimalStringToUINT(p, 2);
        p += 2;

        if (IsDigit(*p))
        {
            dst->second = (ASN1uint8_t) DecimalStringToUINT(p, 2);
            p += 2;
        }
        else
        {
            dst->second = 0;
        }

        dst->universal = 0;
        dst->diff = 0;

        if (*p == 'Z')
        {
            dst->universal = 1;
            p++;
        }
        else if (*p == '+')
        {
            const DWORD base = 10000;
            frac = scanfrac(p + 1, &p, base);
            dst->diff = (int)(frac / (base/100) * 60 + frac % 100);
        }
        else if (*p == '-')
        {
            const DWORD base = 10000;
            frac = scanfrac(p + 1, &p, base);
            dst->diff = -((int)(frac / (base/100) * 60 + frac % 100));
        }
        return ((*p) ? 0 : 1);
    }
    return 0;
}
#endif // ENABLE_BER


ASN1uint32_t GetObjectIdentifierCount(ASN1objectidentifier_t val)
{
    ASN1uint32_t cObjIds = 0;
    while (val)
    {
        cObjIds++;
        val = val->next;
    }
    return cObjIds;
}

ASN1uint32_t CopyObjectIdentifier(ASN1objectidentifier_t dst, ASN1objectidentifier_t src)
{
    while (dst && src)
    {
        dst->value = src->value;
        dst = dst->next;
        src = src->next;
    }
    return ((! dst) && (! src));
}

ASN1objectidentifier_t DecAllocObjectIdentifier(ASN1decoding_t dec, ASN1uint32_t cObjIds)
{
    ASN1objectidentifier_t p, q;
    ASN1uint32_t i;
    p = (ASN1objectidentifier_t) DecMemAlloc(dec, cObjIds * sizeof(struct ASN1objectidentifier_s));
    if (p)
    {
        for (q = p, i = 0; i < cObjIds-1; i++)
        {
            q->value = 0;
            q->next = (ASN1objectidentifier_t) ((char *) q + sizeof(struct ASN1objectidentifier_s));
            q = q->next;
        }
        q->next = NULL;
    }
    return p;
}

void DecFreeObjectIdentifier(ASN1decoding_t dec, ASN1objectidentifier_t p)
{
    DecMemFree(dec, p);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\msgclient.cpp ===
//-----------------------------------------------------------------------------
// File: MsgClient.cpp
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "xonp.h"
#include "xonver.h"

typedef DWORD   XONMSGCLIENT_MSGID;
typedef USHORT  XONMSGCLIENT_LOCALE;

#define     XONMSGCLIENT_SERVER_XRL        "/MsgServer/MsgServer.ashx"
#define     XONMSGCLIENT_TIMEOUT           60000

#define     XONMSGCLIENT_WORKBUFFER_SIZE   200

#define     DEFAULT_STRING                 "NO TITLE NAME!"
#define     DEFAULT_STRING_SIZE            14

//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
// InitializeMsgClientContext - initializes the custom task handle
//
//----------------------------------------------------------------------------
VOID CXo::InitializeMsgClientContext( 
            IN XONLINETASK_MSGCLIENT   hMsgTask,
            IN HANDLE                  hWorkEvent
        )
{
    // Fill in the blanks
    ZeroMemory(hMsgTask, sizeof(XONLINECTXT_MSGCLIENT));
    
    TaskInitializeContext(&(hMsgTask->xonTask));
    (hMsgTask->xonTask).pfnContinue = CXo::DoMsgClientContinue;
    (hMsgTask->xonTask).pfnClose  = CXo::DoMsgClientTaskClose;
    (hMsgTask->xonTask).hEventWorkAvailable = hWorkEvent;

    hMsgTask->hrFinal = XONLINETASK_S_RUNNING;
}

//----------------------------------------------------------------------------
//
// MsgClientInternal -  assumes that the request comes into one big buffer that 
// starts with a XONMSGCLIENT_HEADER structure and then has the records alligned
//
//----------------------------------------------------------------------------
HRESULT CXo::MsgClientInternal(
             IN XONLINETASK_MSGCLIENT              hMsgTask,
             IN PXONMSGCLIENT_REQUEST              pRequest,
             IN PXONMSGCLIENT_RESPONSE             pResponse
             )
{
    HRESULT                     hr = S_OK;
    PXONMSGCLIENT_HEADER        pReqHeader = (PXONMSGCLIENT_HEADER)(pRequest);

    Assert(NULL != hMsgTask);
    Assert(NULL != pRequest);
    Assert(NULL != pResponse);

    Assert(0 != (pRequest->Header).wRecordsCount);
    Assert(NULL != pResponse->pbBuffer);

    DWORD dwRequestSize = sizeof(XONMSGCLIENT_HEADER) + 
                          pReqHeader->wRecordsCount * sizeof(XONMSGCLIENT_REQUEST_RECORD);

    /*
	XONLINE_SERVICE_INFO       msgServiceInfo;
    msgServiceInfo.dwServiceID = XONLINE_MESSAGE_SERVICE;
    msgServiceInfo.serviceIP.s_addr = inet_addr("157.56.13.213");
    msgServiceInfo.wServicePort = 80;
	*/

    //
    // Start async work 
    //
    hMsgTask->hrFinal = XONLINETASK_S_RUNNING;
    return ( UploadFromMemoryInternal( 
                    XONLINE_MESSAGE_SERVICE,                            // service ID
                    XONMSGCLIENT_SERVER_XRL,                            // xrl
                    pResponse->pbBuffer,                                // response buffer
                    pResponse->cbBuffer,                                // size of response buffer
                    NULL,                                               // extra headers buffer
                    0,                                                  // .. and count for it.
                    (PBYTE)(pRequest),                                  // request buffer
                    dwRequestSize,                                      // size of request buffer
                    XONMSGCLIENT_TIMEOUT,                               // timeout (?)
                    (hMsgTask->xonTask).hEventWorkAvailable,            // event handle.
                    &(hMsgTask->xonTaskUpload)                          // task handle
                    ));
}


//----------------------------------------------------------------------------
//
// Do work function for msg client operations
//
//----------------------------------------------------------------------------
HRESULT CXo::DoMsgClientContinue(XONLINETASK_HANDLE hTask)
{
    HRESULT                     hr = S_OK;
    PXRL_ASYNC                  pXrlAsync;
        
    Assert(hTask != NULL);

    XONLINETASK_MSGCLIENT       hMsgTask = (XONLINETASK_MSGCLIENT)hTask;

	if( XONLINETASK_S_RUNNING != hMsgTask->hrFinal )
    {
        // One more loop in dowork ... nothing to be done anymore
        return (hMsgTask->hrFinal);
    }

    // We will pump until the task returns
    hr = XOnlineTaskContinue((XONLINETASK_HANDLE)(&(hMsgTask->xonTaskUpload)));

    if(XONLINETASK_S_RUNNING != hr)
    {

        pXrlAsync = &(hMsgTask->xonTaskUpload.xrlasync);
        
        // Just skip this if the HTTP response is a failure
        if (XONLINEUPLOAD_EXSTATUS_ANYERROR(pXrlAsync->dwExtendedStatus))
        {
            hMsgTask->hrFinal = pXrlAsync->hrXErr;
        }
        else
        {
            // Parse and validate the msg server data here; this 
			// handles the case where there are no results.
			hr = ParseMsgServerResults(pXrlAsync);

			if (FAILED(hr))
			{
				hMsgTask->hrFinal = hr;
			}
			else
			{
				hMsgTask->hrFinal = pXrlAsync->hrFinal;
			}
        }
    }

    return (hMsgTask->hrFinal);
}

//----------------------------------------------------------------------------
//
// Function to parse server results
//
//----------------------------------------------------------------------------
HRESULT CXo::ParseMsgServerResults(
			PXRL_ASYNC	pXrlAsync
			)
{
	HRESULT						    hr = S_OK;
	PBYTE						    pbBuffer;
	DWORD						    cbReceived;
	DWORD						    cbCurrent = 0;
	
	PXONMSGCLIENT_HEADER	        pRespHeader;
	PXONMSGCLIENT_RESPONSE_RECORD	pRespRecord;
	DWORD                           cbCurrentRecordSize = 0;
	ULONGLONG                       cbContentLength = 0;

	Assert(pXrlAsync != NULL);

	pbBuffer = pXrlAsync->pBuffer;
	cbReceived = pXrlAsync->dwCurrent;

	//
    // Get content length
    //
	cbContentLength = pXrlAsync->uliContentLength.QuadPart;

	// If content length is zero, then there are zero results
	if (!cbReceived)
	{
		if (cbContentLength == 0)
			goto Cleanup;
		else
			goto InvalidData;
	}

	// Sanity check
	if ((cbReceived < sizeof(XONMSGCLIENT_HEADER)) ||
		(cbReceived > pXrlAsync->cbBuffer))
		goto InvalidData;

	// Initialize our pointers
	pRespRecord = (PXONMSGCLIENT_RESPONSE_RECORD)pbBuffer;

	// Verify information
	if (cbReceived != cbContentLength)
		goto InvalidData;
	
	//
	// Process records
	//
	while (cbCurrent < cbContentLength)
	{

		cbCurrentRecordSize = pRespRecord->cbBuffer + sizeof(pRespRecord->cbBuffer);

		if (cbContentLength < (cbCurrent + cbCurrentRecordSize))
			goto InvalidData;

		cbCurrent += cbCurrentRecordSize;
		if (cbContentLength < cbCurrent)
			goto InvalidData;

		pbBuffer += cbCurrentRecordSize;
		pRespRecord = (PXONMSGCLIENT_RESPONSE_RECORD)pbBuffer;
	}

Cleanup:
	return(hr);

InvalidData:
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	goto Cleanup;
}

//----------------------------------------------------------------------------
//
// Close function for MsgClient
//
//----------------------------------------------------------------------------
VOID CXo::DoMsgClientTaskClose(XONLINETASK_HANDLE hTask)
{
    Assert(hTask != NULL);
    SysFree(hTask);
}


//////////////////////////////////////////////////////////////////////////////
//
// Title Cache Implementation
//
//////////////////////////////////////////////////////////////////////////////

//
// Define the title data task states
//
enum XONTITLECACHE_STATE
{
    XONTITLECACHE_STATE_INITIALIZE = 0,
    XONTITLECACHE_STATE_DONE,
    XONTITLECACHE_STATE_OPEN,
    XONTITLECACHE_STATE_RETRIEVE,
	XONTITLECACHE_STATE_START_SERVER,
    XONTITLECACHE_STATE_SERVER,
    XONTITLECACHE_STATE_UPDATE,
    XONTITLECACHE_STATE_CLOSE
};

//----------------------------------------------------------------------------
//
// TitleCacheInit - API to initialize the title cache and return a task handle
//
//----------------------------------------------------------------------------
HRESULT CXo::TitleCacheInit(
				IN  HANDLE              hWorkEvent,
                OUT PXONLINETASK_HANDLE phTask
                )
{
    HRESULT hr = S_OK;

    Assert(NULL != phTask);
    
    XONLINETASK_TITLECACHE hTitleCacheTask = NULL;
        
    do
    {
		*phTask = NULL;

        // Allocate the task context
        hTitleCacheTask = (XONLINETASK_TITLECACHE)SysAlloc(sizeof(XONLINECTXT_TITLECACHE), PTAG_XONLINECTXT_TITLECACHE);
        if (!hTitleCacheTask)
        {
            hr  = E_OUTOFMEMORY;
            break;
        }

		
        // Initialize the context
        InitializeTitleCacheContext(hTitleCacheTask, hWorkEvent);

		//
        // Allocate work buffers
        //
		DWORD dwRequestSize = sizeof(XONMSGCLIENT_HEADER) + sizeof(XONMSGCLIENT_REQUEST_RECORD);
		hTitleCacheTask->pMsgServerReq = (PXONMSGCLIENT_REQUEST)SysAlloc(dwRequestSize, PTAG_XONMSGCLIENT_REQUEST);

		if( NULL ==  hTitleCacheTask->pMsgServerReq )
        {
			hr  = E_OUTOFMEMORY;
			break;
        }

		hTitleCacheTask->cbMsgServerResp = XONMSGCLIENT_WORKBUFFER_SIZE;
		hTitleCacheTask->pbMsgServerResp = (BYTE *)SysAlloc(XONMSGCLIENT_WORKBUFFER_SIZE, PTAG_XONMSGCLIENT_WORKBUFFER);

		if( NULL ==  hTitleCacheTask->pbMsgServerResp )
        {
			hr  = E_OUTOFMEMORY;
			break;
        }

	    //
        // Open the cache
        //
		hr = CacheOpen(XONLC_TYPE_TITLEDATA,
			                  NULL,
							  hWorkEvent,
							  &(hTitleCacheTask->hCache),
							  &(hTitleCacheTask->hTaskLocalCache));

		if( FAILED( hr ) )
        {
			break;
        }

		hTitleCacheTask->hSubtask = hTitleCacheTask->hTaskLocalCache;
		hTitleCacheTask->state = XONTITLECACHE_STATE_OPEN;

		// Return the opaque handle
        *phTask = (XONLINETASK_HANDLE)hTitleCacheTask;
    }
    while( FALSE );

	if( FAILED( hr ) )
    {
		//
        // Free allocated memory
        //
		if( NULL !=  hTitleCacheTask->pMsgServerReq )
        {
			SysFree(hTitleCacheTask->pMsgServerReq);
			hTitleCacheTask->pMsgServerReq = NULL;

        }

		if( NULL !=  hTitleCacheTask->pbMsgServerResp )
        {
			SysFree(hTitleCacheTask->pbMsgServerResp);
			hTitleCacheTask->pbMsgServerResp = NULL;
        }

		//
        // Deallocate task handle
        //
		SysFree(hTitleCacheTask);
		hTitleCacheTask = NULL;

    }
    
    return( hr );

}

//----------------------------------------------------------------------------
//
// Function to initialize the context
//
//----------------------------------------------------------------------------
VOID CXo::InitializeTitleCacheContext( 
            IN XONLINETASK_TITLECACHE  hTitleCacheTask, 
            IN HANDLE                  hWorkEvent
        )
{
    // Fill in the blanks
    ZeroMemory(hTitleCacheTask, sizeof(XONLINECTXT_TITLECACHE));
    
    TaskInitializeContext(&(hTitleCacheTask->xonTask));
    hTitleCacheTask->xonTask.pfnContinue = CXo::DoTitleCacheContinue;
    hTitleCacheTask->xonTask.pfnClose  = CXo::DoTitleCacheTaskClose;
	hTitleCacheTask->xonTask.hEventWorkAvailable = hWorkEvent;

	hTitleCacheTask->hrFinal = XONLINETASK_S_RUNNING;

	InitializeMsgClientContext(&(hTitleCacheTask->xonTaskMsgClient) , hWorkEvent);
}

//----------------------------------------------------------------------------
//
// TitleCacheRetrieve - API to retrieve the Title Name (either from
//                             local cache or from from the server)
//                           - If none succeeds, returns DEFAULT_STRING.
//
//----------------------------------------------------------------------------
BOOL CXo::TitleCacheRetrieve(
				IN XONLINETASK_HANDLE    hTask,
                IN DWORD                 dwTitleID,
                OUT PXONLINE_TITLEDATA   pTitleData
)
{
    Assert(NULL != hTask);
	Assert(NULL != pTitleData);

	XONLINETASK_TITLECACHE hTitleCacheTask = (XONLINETASK_TITLECACHE)hTask;
	

	//
    // Memorize the input data
    //
	hTitleCacheTask->dwTitleID = dwTitleID;
	hTitleCacheTask->pTitleData = pTitleData;


	if( XONTITLECACHE_STATE_OPEN == hTitleCacheTask->state )
    {
		//
        // Tells the client to pump the task
        //
		return FALSE;
    }

	Assert(NULL != hTitleCacheTask->hCache);
	Assert(NULL != hTitleCacheTask->hTaskLocalCache);

	return (DoTitleCacheRetrieveBegin(hTitleCacheTask));

}

//----------------------------------------------------------------------------
//
// DoTitleCacheRetrieveBegin - work function for TitleCacheRetrieve
//
//----------------------------------------------------------------------------
BOOL CXo::DoTitleCacheRetrieveBegin(
		  IN XONLINETASK_TITLECACHE   hTitleCacheTask
		  )
{
	HRESULT               hr = S_OK;

	//
    // First tries to retrieve data from the local cache
    //
	hr = StartLocalCacheRetrieve(hTitleCacheTask);

	if( SUCCEEDED( hr ) && (XONTITLECACHE_STATE_DONE == hTitleCacheTask->state))
    {
		//
        // Finished retrieving the title name - it was in MRU list
        //
		return (TRUE);

    }

	//
    // The data is not in the cache
    //
	if( FAILED( hr ) || (XONTITLECACHE_STATE_START_SERVER == hTitleCacheTask->state))
    {
		//
        // Try on the server
        //
		hr = StartMsgServerRetrieve(hTitleCacheTask);

		if( FAILED( hr ) )
        {
			//
            // Default string 
            //
			memcpy(hTitleCacheTask->pTitleData , DEFAULT_STRING , DEFAULT_STRING_SIZE );
			return TRUE;
        }
    }
	
	//
    // The client has to pump the task handle
    //
	return FALSE;


}

//----------------------------------------------------------------------------
//
// StartLocalCacheRetrieve - starts retrieving the title name from the local cache
//
//----------------------------------------------------------------------------
HRESULT CXo::StartLocalCacheRetrieve(
		  IN XONLINETASK_TITLECACHE   hTitleCacheTask
		  )
{
	HRESULT               hr = S_OK;

	PXONLC_CONTEXT        pContext = &(hTitleCacheTask->context);

	memset(pContext , 0 , sizeof(XONLC_CONTEXT));

	pContext->pbIndexData = (LPBYTE)(&(hTitleCacheTask->dwTitleID));
	pContext->pbRecordBuffer = (LPBYTE)(hTitleCacheTask->pTitleData);

	memset(hTitleCacheTask->pTitleData , 0 , sizeof(XONLINE_TITLEDATA));
	pContext->dwRecordBufferSize = sizeof(XONLINE_TITLEDATA);

	do
	{
		// 
		// Lookup the key in the local cache
		//
		hr = CacheLookup(hTitleCacheTask->hCache , pContext);

		if( FAILED( hr ) )
        {
			TraceSz2(Warning, "Lookup FAILED on key = %x, hr = %x\n" , hTitleCacheTask->dwTitleID , hr);
			break;
        }

		//
        // If data is in the local cache
        //
		if( pContext->bValidDataInCache )
		{
			if( pContext->bCallRetrieveNext )
			{
				//
                // It has to be retrieved asynchronously from the cache
                //
				hr = CacheRetrieve( hTitleCacheTask->hCache, hTitleCacheTask->hTaskLocalCache, pContext);

				if(FAILED(hr))
				{
					TraceSz2(Warning, "Retrieve FAILED on key = %x, hr = %x\n" , hTitleCacheTask->dwTitleID , hr);
					break;
				}

				hTitleCacheTask->hSubtask = hTitleCacheTask->hTaskLocalCache;
				hTitleCacheTask->state = XONTITLECACHE_STATE_RETRIEVE;
				hTitleCacheTask->hrFinal = XONLINETASK_S_RUNNING;
			}
			else
			{
				//
				// Data already in pTitleData
				//
				hTitleCacheTask->hSubtask = NULL;
				hTitleCacheTask->state = XONTITLECACHE_STATE_DONE;
				hTitleCacheTask->hrFinal = XONLINETASK_S_SUCCESS;
			}
		}
		else
		{
			//
            // Try next step: retrieving from the server
            //
			hTitleCacheTask->state = XONTITLECACHE_STATE_START_SERVER;
		}
			
		
	}
	while(FALSE);

	if( FAILED( hr ) )
    {
		hTitleCacheTask->hSubtask = NULL;
		hTitleCacheTask->state = XONTITLECACHE_STATE_DONE;
		hTitleCacheTask->hrFinal = hr;
    }

	return (hr);

}

//----------------------------------------------------------------------------
//
// StartMsgServerRetrieve - starts retrieving the title name from the server
//
//----------------------------------------------------------------------------
HRESULT CXo::StartMsgServerRetrieve(
		  IN XONLINETASK_TITLECACHE   hTitleCacheTask
		  )
{
	HRESULT               hr = S_OK;

	XONMSGCLIENT_RESPONSE   msgServerResp;

	//
    // If the cache path didn't lead anywhere, start a request to a server
    //
	hTitleCacheTask->pMsgServerReq->Header.wRecordsCount = 1;
	
	//
    // Create input data fro the server
    //
	PXONMSGCLIENT_REQUEST_RECORD pReqRecords = (PXONMSGCLIENT_REQUEST_RECORD)((PBYTE)(hTitleCacheTask->pMsgServerReq) + sizeof(XONMSGCLIENT_HEADER));

	pReqRecords[0].wType = XONMSGCLIENT_TYPE_TITLEID;
	pReqRecords[0].dwID = hTitleCacheTask->dwTitleID;
	pReqRecords[0].wLocale = 0;

	//
    // Create output data for the server
    //
	XONMSGCLIENT_RESPONSE   resp;

	resp.cbBuffer = hTitleCacheTask->cbMsgServerResp;
	resp.pbBuffer = hTitleCacheTask->pbMsgServerResp;

	memset(resp.pbBuffer , 0 , resp.cbBuffer);

	XONLINETASK_MSGCLIENT hSubtask = &(hTitleCacheTask->xonTaskMsgClient);

	//
    // Call the internal API for the message server
    //
	hr = MsgClientInternal(hSubtask, hTitleCacheTask->pMsgServerReq, &resp);
                          
	if(FAILED(hr))
	{
		TraceSz1(Warning, "MsgClientInternal FAILED hr = %x \n" , hr);

		hTitleCacheTask->hSubtask = NULL;
		hTitleCacheTask->state = XONTITLECACHE_STATE_DONE;
		hTitleCacheTask->hrFinal = hr;
	}
	else
	{
		hTitleCacheTask->hSubtask = (XONLINETASK_HANDLE)hSubtask;
		hTitleCacheTask->state = XONTITLECACHE_STATE_SERVER;
		hTitleCacheTask->hrFinal = XONLINETASK_S_RUNNING;
	}

	return (hr);
}

//----------------------------------------------------------------------------
//
// StartLocalCacheUpdate - starts updating the local cache with the data from the server
//
//----------------------------------------------------------------------------
HRESULT CXo::StartLocalCacheUpdate(
		  IN XONLINETASK_TITLECACHE   hTitleCacheTask
		  )
{
	HRESULT               hr = S_OK;


	//
    // Start async update of the local cache
    //
	hr = CacheUpdate(hTitleCacheTask->hCache , 
		                    hTitleCacheTask->hTaskLocalCache,
							(PBYTE)(&(hTitleCacheTask->dwTitleID)),
							(PBYTE)(hTitleCacheTask->pTitleData)
							);

	if( FAILED( hr ) )
    {
		hTitleCacheTask->hSubtask = NULL;
		hTitleCacheTask->state = XONTITLECACHE_STATE_DONE;
		hTitleCacheTask->hrFinal = hr;
    }
	else
	{
		hTitleCacheTask->hSubtask = hTitleCacheTask->hTaskLocalCache;
		hTitleCacheTask->state = XONTITLECACHE_STATE_UPDATE;
		hTitleCacheTask->hrFinal = XONLINETASK_S_RUNNING;
	}

	return (hr);
}

//----------------------------------------------------------------------------
//
// Do work function for title data operations
//
//----------------------------------------------------------------------------
HRESULT CXo::DoTitleCacheContinue(XONLINETASK_HANDLE hTask)
{
    HRESULT hr = S_OK;
            
    Assert(hTask != NULL);

    XONLINETASK_TITLECACHE       hTitleCacheTask = (XONLINETASK_TITLECACHE)hTask;

	if( XONTITLECACHE_STATE_DONE == hTitleCacheTask->state )
    {
        // One more loop in dowork ... nothing to be done anymore
		Assert(NULL == hTitleCacheTask->hSubtask);
        return (hTitleCacheTask->hrFinal);
    }

	Assert(NULL != hTitleCacheTask->hSubtask);

	do
	{
		// We will pump until the task returns
		hTitleCacheTask->hrFinal = XOnlineTaskContinue(hTitleCacheTask->hSubtask);

		if(XONLINETASK_S_RUNNING != hTitleCacheTask->hrFinal)
		{
			if( FAILED( hTitleCacheTask->hrFinal ) )
            {
				break;
            }

			//
            // Reuse task handle
            //
            hTitleCacheTask->hSubtask = NULL;

			if( XONTITLECACHE_STATE_OPEN == hTitleCacheTask->state )
			{
				//
				// Finished opening cache - start retrieve operation
				//
				if( DoTitleCacheRetrieveBegin(hTitleCacheTask) )
                {
					//
                    // Found key in cache
                    //
					hTitleCacheTask->state = XONTITLECACHE_STATE_DONE;
		
                }

				break;
			}

			if( XONTITLECACHE_STATE_RETRIEVE == hTitleCacheTask->state )
            {
				//
                // Key found in the local cache
                //

				hTitleCacheTask->state = XONTITLECACHE_STATE_DONE;

				break;
            }

			if( XONTITLECACHE_STATE_SERVER ==  hTitleCacheTask->state )
            {
				//
                // We got the answer from the server
                //
				DWORD dwRespSize = *(DWORD*)(hTitleCacheTask->pbMsgServerResp);

				memset(hTitleCacheTask->pTitleData , 0 , XONLINE_TITLEDATA_SIZE);

				if( (0 < dwRespSize ) && (dwRespSize < XONLINE_TITLEDATA_SIZE) )
                {
					//
                    // Copy the contents from the work buffer; skip size of buffer
                    //
					memcpy(hTitleCacheTask->pTitleData , hTitleCacheTask->pbMsgServerResp + sizeof(DWORD) , dwRespSize );

                    //
                    // Write data into the local cache
                    //
					StartLocalCacheUpdate(hTitleCacheTask);
                }
				else
				{
					//
                    // Default string 
                    //
					memcpy(hTitleCacheTask->pTitleData , DEFAULT_STRING , DEFAULT_STRING_SIZE );
				}

            }
			else //UPDATE
			{
				hTitleCacheTask->state = XONTITLECACHE_STATE_DONE;
			}
		}
       
    }
	while(FALSE);

	if( FAILED( hr ) )
    {
		hTitleCacheTask->hrFinal = hr;
        hTitleCacheTask->state = XONTITLECACHE_STATE_DONE;
    }

	if(XONTITLECACHE_STATE_DONE == hTitleCacheTask->state)
    {
        hTitleCacheTask->hSubtask = NULL;
    }

    return (hTitleCacheTask->hrFinal);
}

//----------------------------------------------------------------------------
//
// Close function for TitleCache
//
//----------------------------------------------------------------------------
VOID CXo::DoTitleCacheTaskClose(XONLINETASK_HANDLE hTask)
{
    Assert(hTask != NULL);

	XONLINETASK_TITLECACHE       hTitleCacheTask = (XONLINETASK_TITLECACHE)hTask;

	HRESULT hr = S_OK;

	//
    // Try to close the cache, if failed, pump the task until it's finished
    //
	hr = CacheClose(hTitleCacheTask->hCache);

	if( FAILED( hr ) )
    {
		//
        // Some subtask inlolving the cache is in progress
        //
		hr = XONLINETASK_S_RUNNING;
		while(XONLINETASK_S_RUNNING == hr)
		{
			hr = XOnlineTaskContinue(hTitleCacheTask->hSubtask);
		};

		hr = CacheClose(hTitleCacheTask->hCache);

		Assert(SUCCEEDED(hr));
    }

	//
    // Free allocated memory
    //
	if( NULL !=  hTitleCacheTask->pMsgServerReq )
    {
		SysFree(hTitleCacheTask->pMsgServerReq);
		hTitleCacheTask->pMsgServerReq = NULL;
    }

	if( NULL !=  hTitleCacheTask->pbMsgServerResp )
    {
		SysFree(hTitleCacheTask->pbMsgServerResp);
		hTitleCacheTask->pbMsgServerResp = NULL;
    }

	//
    // Deallocate task handle
    //
	SysFree(hTitleCacheTask);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\msasn1.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation 1997-1998, All rights reserved. */

#ifndef __MS_ASN1_H__
#define __MS_ASN1_H__

#include <pshpack8.h> /* Assume 8 byte packing throughout */

/* ------ Basic integer types ------ */

typedef unsigned char   ASN1uint8_t;
typedef signed char     ASN1int8_t;

typedef unsigned short  ASN1uint16_t;
typedef signed short    ASN1int16_t;

typedef unsigned long   ASN1uint32_t;
typedef signed long     ASN1int32_t;


/* ------ Function modifiers ------ */

#define ASN1_PUBLIC
#define ASN1API         __stdcall
#define ASN1CALL        __stdcall


/* ------ Basic ASN.1 types ------ */

typedef ASN1uint8_t ASN1octet_t;

typedef ASN1uint8_t ASN1bool_t;

typedef struct tagASN1intx_t
{
    ASN1uint32_t length;
    ASN1octet_t *value;
}
    ASN1intx_t;

typedef struct tagASN1octetstring_t
{
    ASN1uint32_t length;
    ASN1octet_t *value;
}
    ASN1octetstring_t;

typedef struct tagASN1octetstring2_t
{
    ASN1uint32_t length;
    ASN1octet_t value[1];
}
    ASN1octetstring2_t;

typedef struct ASN1iterator_s
{
    struct ASN1iterator_s *next;
    void *value;
}
    ASN1iterator_t;

typedef struct tagASN1bitstring_t
{
    ASN1uint32_t length;
    ASN1octet_t *value;
}
    ASN1bitstring_t;

typedef char ASN1char_t;

typedef struct tagASN1charstring_t
{
    ASN1uint32_t length;
    ASN1char_t *value;
}
    ASN1charstring_t;

typedef ASN1uint16_t ASN1char16_t;

typedef struct tagASN1char16string_t
{
    ASN1uint32_t length;
    ASN1char16_t *value;
}
    ASN1char16string_t;

typedef ASN1uint32_t ASN1char32_t;

typedef struct tagASN1char32string_t
{
    ASN1uint32_t length;
    ASN1char32_t *value;
}
    ASN1char32string_t;

typedef ASN1char_t *ASN1ztcharstring_t;
typedef ASN1char16_t *ASN1ztchar16string_t;
typedef ASN1char32_t *ASN1ztchar32string_t;

typedef struct tagASN1wstring_t
{
    ASN1uint32_t length;
    WCHAR *value;
}
    ASN1wstring_t;

typedef struct ASN1objectidentifier_s
{
    struct ASN1objectidentifier_s *next;
    ASN1uint32_t value;
}
    *ASN1objectidentifier_t;

typedef struct tagASN1objectidentifier2_t
{
    ASN1uint16_t count;
    ASN1uint32_t value[16];
}
    ASN1objectidentifier2_t;

typedef struct tagASN1encodedOID_t
{
    ASN1uint16_t length;
    ASN1octet_t  *value;
}
    ASN1encodedOID_t;

typedef struct tagASN1stringtableentry_t
{
    ASN1char32_t lower;
    ASN1char32_t upper;
    ASN1uint32_t value;
}
    ASN1stringtableentry_t;

typedef struct tagASN1stringtable_t
{
    ASN1uint32_t length;
    ASN1stringtableentry_t *values;
}
    ASN1stringtable_t;

typedef ASN1ztcharstring_t ASN1objectdescriptor_t;

typedef struct tagASN1generalizedtime_t
{
    ASN1uint16_t year;
    ASN1uint8_t month;
    ASN1uint8_t day;
    ASN1uint8_t hour;
    ASN1uint8_t minute;
    ASN1uint8_t second;
    ASN1uint16_t millisecond;
    ASN1bool_t universal;
    ASN1int16_t diff;
}
    ASN1generalizedtime_t;

typedef struct tagASN1utctime_t
{
    ASN1uint8_t year;
    ASN1uint8_t month;
    ASN1uint8_t day;
    ASN1uint8_t hour;
    ASN1uint8_t minute;
    ASN1uint8_t second;
    ASN1bool_t universal;
    ASN1int16_t diff;
}
    ASN1utctime_t;

typedef struct tagASN1open_t
{
    // encoded
    ASN1uint32_t    length;
    union
    {
        void           *encoded;
        void           *value;
    };
}
    ASN1open_t;

typedef enum tagASN1blocktype_e
{
    ASN1_DER_SET_OF_BLOCK,
}
    ASN1blocktype_e;

typedef ASN1int32_t     ASN1enum_t;     // enumerated type

typedef ASN1uint16_t    ASN1choice_t;   // choice

typedef ASN1uint32_t    ASN1magic_t;

/* ------ Current version of this ASN.1 software ------ */

#define ASN1_MAKE_VERSION(major,minor)  (((major) << 16) | (minor))
#define ASN1_THIS_VERSION               ASN1_MAKE_VERSION(1,0)

enum
{
    ASN1_CHOICE_BASE      = 1,
    ASN1_CHOICE_INVALID   = -1,     // invalid choice
    ASN1_CHOICE_EXTENSION = 0,      // extension choice
};



/*
   Error codes for decoding functions:
   - err == 0:    data has been successfully decoded
   - err <  0:    fatal error has occured, no data has been generated
                  err contains the error number
   - err >  0:    non-fatal event has occured, data has been generated
                  err is a bit set of occured events
 */

typedef enum tagASN1error_e
{
    ASN1_SUCCESS        = 0,            /* success */

    // Teles specific error codes
    ASN1_ERR_INTERNAL   = (-1001),      /* internal error */
    ASN1_ERR_EOD        = (-1002),      /* unexpected end of data */
    ASN1_ERR_CORRUPT    = (-1003),      /* corrupted data */
    ASN1_ERR_LARGE      = (-1004),      /* value too large */
    ASN1_ERR_CONSTRAINT = (-1005),      /* constraint violated */
    ASN1_ERR_MEMORY     = (-1006),      /* out of memory */
    ASN1_ERR_OVERFLOW   = (-1007),      /* buffer overflow */
    ASN1_ERR_BADPDU     = (-1008),      /* function not supported for this pdu*/
    ASN1_ERR_BADARGS    = (-1009),      /* bad arguments to function call */
    ASN1_ERR_BADREAL    = (-1010),      /* bad real value */
    ASN1_ERR_BADTAG     = (-1011),      /* bad tag value met */
    ASN1_ERR_CHOICE     = (-1012),      /* bad choice value */
    ASN1_ERR_RULE       = (-1013),      /* bad encoding rule */
    ASN1_ERR_UTF8       = (-1014),      /* bad unicode (utf8) */

    // New error codes
    ASN1_ERR_PDU_TYPE   = (-1051),      /* bad pdu type */
    ASN1_ERR_NYI        = (-1052),      /* not yet implemented */

    // Teles specific warning codes
    ASN1_WRN_EXTENDED   = 1001,         /* skipped unknown extension(s) */
    ASN1_WRN_NOEOD      = 1002,         /* end of data expected */
}
    ASN1error_e;

#define ASN1_SUCCEEDED(ret)     (((int) (ret)) >= 0)
#define ASN1_FAILED(ret)        (((int) (ret)) < 0)


/* ------ Encoding rules ------ */

typedef enum
{
    ASN1_PER_RULE_ALIGNED       = 0x0001,
    ASN1_PER_RULE_UNALIGNED     = 0x0002, // not supported
    ASN1_PER_RULE               = ASN1_PER_RULE_ALIGNED | ASN1_PER_RULE_UNALIGNED,

    ASN1_BER_RULE_BER           = 0x0100,
    ASN1_BER_RULE_CER           = 0x0200,
    ASN1_BER_RULE_DER           = 0x0400,
    ASN1_BER_RULE               = ASN1_BER_RULE_BER | ASN1_BER_RULE_CER | ASN1_BER_RULE_DER,
}
    ASN1encodingrule_e;

/* ------ public structures ------ */

typedef struct ASN1encoding_s   *ASN1encoding_t;
typedef struct ASN1decoding_s   *ASN1decoding_t;

typedef ASN1int32_t (ASN1CALL *ASN1PerEncFun_t)(ASN1encoding_t enc, void *data);
typedef ASN1int32_t (ASN1CALL *ASN1PerDecFun_t)(ASN1decoding_t enc, void *data);
typedef struct tagASN1PerFunArr_t
{
    const ASN1PerEncFun_t *apfnEncoder;
    const ASN1PerDecFun_t *apfnDecoder;
}
    ASN1PerFunArr_t;

typedef ASN1int32_t (ASN1CALL *ASN1BerEncFun_t)(ASN1encoding_t enc, ASN1uint32_t tag, void *data);
typedef ASN1int32_t (ASN1CALL *ASN1BerDecFun_t)(ASN1decoding_t enc, ASN1uint32_t tag, void *data);
typedef struct tagASN1BerFunArr_t
{
    const ASN1BerEncFun_t *apfnEncoder;
    const ASN1BerDecFun_t *apfnDecoder;
}
    ASN1BerFunArr_t;

typedef void (ASN1CALL *ASN1GenericFun_t)(void);
typedef void (ASN1CALL *ASN1FreeFun_t)(void *data);

typedef struct tagASN1module_t
{
    ASN1magic_t             nModuleName;
    ASN1encodingrule_e      eRule;
    ASN1uint32_t            dwFlags;
    ASN1uint32_t            cPDUs;

    const ASN1FreeFun_t    *apfnFreeMemory;
    const ASN1uint32_t     *acbStructSize;
    union
    {
        ASN1PerFunArr_t     PER;
        ASN1BerFunArr_t     BER;
    };
}
    *ASN1module_t;


struct ASN1encoding_s
{
    class CScratchMemoryAllocator* pScratchMemoryAllocator;
    ASN1magic_t         magic;  /* magic for this structure */
    ASN1uint32_t        version;/* version number of this library */
    ASN1module_t        module; /* module this encoding_t depends to */
    ASN1octet_t        *buf;    /* buffer to encode into */
    ASN1uint32_t        size;   /* current size of buffer */
    ASN1uint32_t        len;    /* len of encoded data in buffer */
    ASN1error_e         err;    /* error code for last encoding */
    ASN1uint32_t        bit;
    ASN1octet_t        *pos;
    ASN1uint32_t        cbExtraHeader;
    ASN1encodingrule_e  eRule;
    ASN1uint32_t        dwFlags;
};

struct ASN1decoding_s
{
    class CScratchMemoryAllocator* pScratchMemoryAllocator;
    ASN1magic_t         magic;  /* magic for this structure */
    ASN1uint32_t        version;/* version number of this library */
    ASN1module_t        module; /* module this decoding_t depends to */
    ASN1octet_t        *buf;    /* buffer to decode from */
    ASN1uint32_t        size;   /* size of buffer */
    ASN1uint32_t        len;    /* len of decoded data in buffer */
    ASN1error_e         err;    /* error code for last decoding */
    ASN1uint32_t        bit;
    ASN1octet_t        *pos;
    ASN1encodingrule_e  eRule;
    ASN1uint32_t        dwFlags;
};


/* --- flags for functions --- */

#define ASN1DECFREE_NON_PDU_ID    ((ASN1uint32_t) -1)

enum
{
    ASN1FLAGS_NONE              = 0x00000000L, /* no flags */
    ASN1FLAGS_NOASSERT          = 0x00001000L, /* no asertion */
};

enum
{
    ASN1ENCODE_APPEND           = 0x00000001L, /* append to current buffer*/
    ASN1ENCODE_REUSEBUFFER      = 0x00000004L, /* empty destination buffer */
    ASN1ENCODE_SETBUFFER        = 0x00000008L, /* use a user-given destination buffer */
    ASN1ENCODE_ALLOCATEBUFFER   = 0x00000010L, /* do not free/reuse buffer */
    ASN1ENCODE_NOASSERT         = ASN1FLAGS_NOASSERT, /* no asertion */
};

enum
{
    ASN1DECODE_APPENDED         = 0x00000001L, /* continue behind last pdu*/
    ASN1DECODE_REWINDBUFFER     = 0x00000004L, /* rescan from buffer start*/
    ASN1DECODE_SETBUFFER        = 0x00000008L, /* use a user-given src buffer */
    ASN1DECODE_NOASSERT         = ASN1FLAGS_NOASSERT, /* no asertion */
};

/* ------ public basic ASN.1 API ------ */

extern ASN1_PUBLIC void ASN1API ASN1_InitModule
(
    ASN1module_t            module,
    ASN1uint32_t            version,
    ASN1encodingrule_e      eEncodingRule,
    ASN1uint32_t            dwFlags,
    ASN1uint32_t            cPDUs,
    const ASN1GenericFun_t  apfnEncoder[],
    const ASN1GenericFun_t  apfnDecoder[],
    const ASN1FreeFun_t     apfnFreeMemory[],
    const ASN1uint32_t      acbStructSize[],
    ASN1magic_t             nModuleName
);

extern ASN1_PUBLIC ASN1module_t ASN1API ASN1_CreateModule
(
    ASN1uint32_t            nVersion,
    ASN1encodingrule_e      eRule,
    ASN1uint32_t            dwFlags, /* ASN1FLAGS_NONE or ASN1FLAGS_NOASSERT */
    ASN1uint32_t            cPDU,
    const ASN1GenericFun_t  apfnEncoder[],
    const ASN1GenericFun_t  apfnDecoder[],
    const ASN1FreeFun_t     apfnFreeMemory[],
    const ASN1uint32_t      acbStructSize[],
    ASN1magic_t             nModuleName
);

extern ASN1_PUBLIC void ASN1API ASN1_CloseModule
(
    ASN1module_t        pModule
);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_CreateEncoder
(
    CScratchMemoryAllocator* pScratchMemoryAllocator,
    ASN1module_t        pModule,
    ASN1encoding_t     *ppEncoderInfo,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize,
    ASN1encoding_t      pParent
);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_Encode
(
    ASN1encoding_t      pEncoderInfo,
    void               *pDataStruct,
    ASN1uint32_t        nPduNum,
    ASN1uint32_t        dwFlags,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize
);

extern ASN1_PUBLIC void ASN1API ASN1_CloseEncoder
(
    ASN1encoding_t      pEncoderInfo
);

extern ASN1_PUBLIC void ASN1API ASN1_CloseEncoder2
(
    ASN1encoding_t      pEncoderInfo
);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_CreateDecoder
(
    CScratchMemoryAllocator* pScratchMemoryAllocator,
    ASN1module_t        pModule,
    ASN1decoding_t     *ppDecoderInfo,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize,
    ASN1decoding_t      pParent
);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_Decode
(
    ASN1decoding_t      pDecoderInfo,
    void              **ppDataStruct,
    ASN1uint32_t        nPduNum,
    ASN1uint32_t        dwFlags,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize
);

extern ASN1_PUBLIC void ASN1API ASN1_CloseDecoder
(
    ASN1decoding_t      pDecoderInfo
);


extern ASN1_PUBLIC void ASN1API ASN1_FreeEncoded
(
    ASN1encoding_t      pEncoderInfo,
    void               *pBuf
);

extern ASN1_PUBLIC void ASN1API ASN1_FreeDecoded
(
    ASN1decoding_t      pDecoderInfo,
    void               *pDataStruct,
    ASN1uint32_t        nPduNum
);


/* ------ public advanced ASN.1 API ------ */

typedef enum
{
    // common set option
    ASN1OPT_CHANGE_RULE                 = 0x101,

    // common get option
    ASN1OPT_GET_RULE                    = 0x201,

    // set encoder option
    ASN1OPT_NOT_REUSE_BUFFER            = 0x301,
    ASN1OPT_REWIND_BUFFER               = 0x302,

    // get encoder option

    // set decoder option
    ASN1OPT_SET_DECODED_BUFFER          = 0x501,
    ASN1OPT_DEL_DECODED_BUFFER          = 0x502,

    // get decoder option
    ASN1OPT_GET_DECODED_BUFFER_SIZE     = 0x601,
}
    ASN1option_e;

typedef struct tagASN1optionparam_t
{
    ASN1option_e    eOption;
    union
    {
        ASN1encodingrule_e              eRule;
        ASN1uint32_t                    cbRequiredDecodedBufSize;
        struct
        {
            ASN1octet_t    *pbBuf;
            ASN1uint32_t    cbBufSize;
        }                               Buffer;
    };
}
    ASN1optionparam_t, ASN1optionparam_s;


extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_SetEncoderOption
(
    ASN1encoding_t      pEncoderInfo,
    ASN1optionparam_t  *pOptParam
);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_GetEncoderOption
(
    ASN1encoding_t      pEncoderInfo,
    ASN1optionparam_t  *pOptParam
);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_SetDecoderOption
(
    ASN1decoding_t      pDecoderInfo,
    ASN1optionparam_t  *pOptParam
);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_GetDecoderOption
(
    ASN1decoding_t      pDecoderInfo,
    ASN1optionparam_t  *pOptParam
);


/* ------ internal ASN.1 API ------ */

extern ASN1_PUBLIC void ASN1API ASN1bitstring_free(ASN1bitstring_t *);
extern ASN1_PUBLIC void ASN1API ASN1octetstring_free(ASN1octetstring_t *);
extern ASN1_PUBLIC void ASN1API ASN1objectidentifier_free(ASN1objectidentifier_t *);
extern ASN1_PUBLIC void ASN1API ASN1charstring_free(ASN1charstring_t *);
extern ASN1_PUBLIC void ASN1API ASN1char16string_free(ASN1char16string_t *);
extern ASN1_PUBLIC void ASN1API ASN1char32string_free(ASN1char32string_t *);
extern ASN1_PUBLIC void ASN1API ASN1ztcharstring_free(ASN1ztcharstring_t);
extern ASN1_PUBLIC void ASN1API ASN1ztchar16string_free(ASN1ztchar16string_t);
extern ASN1_PUBLIC void ASN1API ASN1ztchar32string_free(ASN1ztchar32string_t);
extern ASN1_PUBLIC void ASN1API ASN1open_free(ASN1open_t *);
extern ASN1_PUBLIC void ASN1API ASN1utf8string_free(ASN1wstring_t *);

extern ASN1_PUBLIC void * ASN1API ASN1DecAlloc(ASN1decoding_t dec, ASN1uint32_t size);
extern ASN1_PUBLIC void * ASN1API ASN1DecRealloc(ASN1decoding_t dec, void *ptr, ASN1uint32_t size);
extern ASN1_PUBLIC void   ASN1API ASN1Free(void *ptr);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1EncSetError(ASN1encoding_t enc, ASN1error_e err);
extern ASN1_PUBLIC ASN1error_e ASN1API ASN1DecSetError(ASN1decoding_t dec, ASN1error_e err);

extern ASN1_PUBLIC void ASN1API ASN1intx_sub(ASN1intx_t *, ASN1intx_t *, ASN1intx_t *);
extern ASN1_PUBLIC ASN1uint32_t ASN1API ASN1intx_uoctets(ASN1intx_t *);
extern ASN1_PUBLIC void ASN1API ASN1intx_free(ASN1intx_t *);
extern ASN1_PUBLIC void ASN1API ASN1intx_add(ASN1intx_t *, ASN1intx_t *, ASN1intx_t *);

extern ASN1_PUBLIC void ASN1API ASN1DbgMemTrackDumpCurrent ( ASN1uint32_t nModuleName );

extern ASN1_PUBLIC ASN1uint32_t ASN1API ASN1uint32_uoctets(ASN1uint32_t);

extern ASN1_PUBLIC int ASN1API ASN1objectidentifier_cmp(ASN1objectidentifier_t *v1, ASN1objectidentifier_t *v2);
extern ASN1_PUBLIC int ASN1API ASN1objectidentifier2_cmp(ASN1objectidentifier2_t *v1, ASN1objectidentifier2_t *v2);
extern ASN1_PUBLIC int ASN1API ASN1bitstring_cmp(ASN1bitstring_t *, ASN1bitstring_t *, int);
extern ASN1_PUBLIC int ASN1API ASN1octetstring_cmp(ASN1octetstring_t *, ASN1octetstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1objectidentifier_cmp(ASN1objectidentifier_t *, ASN1objectidentifier_t *);
extern ASN1_PUBLIC int ASN1API ASN1charstring_cmp(ASN1charstring_t *, ASN1charstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1char16string_cmp(ASN1char16string_t *, ASN1char16string_t *);
extern ASN1_PUBLIC int ASN1API ASN1char32string_cmp(ASN1char32string_t *, ASN1char32string_t *);
extern ASN1_PUBLIC int ASN1API ASN1ztcharstring_cmp(ASN1ztcharstring_t, ASN1ztcharstring_t);
extern ASN1_PUBLIC int ASN1API ASN1ztchar16string_cmp(ASN1ztchar16string_t, ASN1ztchar16string_t);
extern ASN1_PUBLIC int ASN1API ASN1open_cmp(ASN1open_t *, ASN1open_t *);
extern ASN1_PUBLIC int ASN1API ASN1generalizedtime_cmp(ASN1generalizedtime_t *, ASN1generalizedtime_t *);
extern ASN1_PUBLIC int ASN1API ASN1utctime_cmp(ASN1utctime_t *, ASN1utctime_t *);


/* --------------------------------------------------------- */
/* The following is not supported.                           */
/* --------------------------------------------------------- */

typedef enum tagASN1real_e
{
    eReal_Normal,
    eReal_PlusInfinity,
    eReal_MinusInfinity
}
    ASN1real_e;

typedef struct tagASN1real_t
{
    ASN1real_e type;
    ASN1intx_t mantissa;
    ASN1uint32_t base;
    ASN1intx_t exponent;
}
    ASN1real_t;

typedef struct tagASN1external_t
{
#   define ASN1external_data_value_descriptor_o 0
    ASN1octet_t o[1];
    struct ASN1external_identification_s
    {
        ASN1uint8_t o;
        union
        {
#            define ASN1external_identification_syntax_o 1
            ASN1objectidentifier_t syntax;
#            define ASN1external_identification_presentation_context_id_o 2
            ASN1uint32_t presentation_context_id;
#            define ASN1external_identification_context_negotiation_o 3
            struct ASN1external_identification_context_negotiation_s
            {
                ASN1uint32_t presentation_context_id;
                ASN1objectidentifier_t transfer_syntax;
            } context_negotiation;
        } u;
    } identification;
    ASN1objectdescriptor_t data_value_descriptor;
    struct ASN1external_data_value_s
    {
        ASN1uint8_t o;
        union
        {
#            define ASN1external_data_value_notation_o 0
            ASN1open_t notation;
#            define ASN1external_data_value_encoded_o 1
            ASN1bitstring_t encoded;
        } u;
    } data_value;
}
    ASN1external_t;

typedef struct ASN1external_identification_s ASN1external_identification_t;
typedef struct ASN1external_identification_context_negotiation_s ASN1external_identification_context_negotiation_t;
typedef struct ASN1external_data_value_s ASN1external_data_value_t;

typedef struct tagASN1embeddedpdv_t
{
    struct ASN1embeddedpdv_identification_s
    {
        ASN1uint8_t o;
        union
        {
#            define ASN1embeddedpdv_identification_syntaxes_o 0
            struct ASN1embeddedpdv_identification_syntaxes_s
            {
                ASN1objectidentifier_t abstract;
                ASN1objectidentifier_t transfer;
            } syntaxes;
#            define ASN1embeddedpdv_identification_syntax_o 1
            ASN1objectidentifier_t syntax;
#            define ASN1embeddedpdv_identification_presentation_context_id_o 2
            ASN1uint32_t presentation_context_id;
#            define ASN1embeddedpdv_identification_context_negotiation_o 3
            struct ASN1embeddedpdv_identification_context_negotiation_s
            {
                ASN1uint32_t presentation_context_id;
                ASN1objectidentifier_t transfer_syntax;
            } context_negotiation;
#            define ASN1embeddedpdv_identification_transfer_syntax_o 4
            ASN1objectidentifier_t transfer_syntax;
#            define ASN1embeddedpdv_identification_fixed_o 5
        } u;
    } identification;
    struct ASN1embeddedpdv_data_value_s
    {
        ASN1uint8_t o;
        union
        {
#            define ASN1embeddedpdv_data_value_notation_o 0
            ASN1open_t notation;
#            define ASN1embeddedpdv_data_value_encoded_o 1
            ASN1bitstring_t encoded;
        } u;
    } data_value;
}
    ASN1embeddedpdv_t;

typedef struct ASN1embeddedpdv_identification_s ASN1embeddedpdv_identification_t;
typedef struct ASN1embeddedpdv_identification_syntaxes_s ASN1embeddedpdv_identification_syntaxes_t;
typedef struct ASN1embeddedpdv_identification_context_negotiation_s ASN1embeddedpdv_identification_context_negotiation_t;
typedef struct ASN1embeddedpdv_data_value_s ASN1embeddedpdv_data_value_t;

typedef struct tagASN1characterstring_t
{
    struct ASN1characterstring_identification_s
    {
        ASN1uint8_t o;
        union
        {
#            define ASN1characterstring_identification_syntaxes_o 0
            struct ASN1characterstring_identification_syntaxes_s
            {
                ASN1objectidentifier_t abstract;
                ASN1objectidentifier_t transfer;
            } syntaxes;
#            define ASN1characterstring_identification_syntax_o 1
            ASN1objectidentifier_t syntax;
#            define ASN1characterstring_identification_presentation_context_id_o 2
            ASN1uint32_t presentation_context_id;
#            define ASN1characterstring_identification_context_negotiation_o 3
            struct ASN1characterstring_identification_context_negotiation_s
            {
                ASN1uint32_t presentation_context_id;
                ASN1objectidentifier_t transfer_syntax;
            } context_negotiation;
#            define ASN1characterstring_identification_transfer_syntax_o 4
            ASN1objectidentifier_t transfer_syntax;
#            define ASN1characterstring_identification_fixed_o 5
        } u;
    } identification;
    struct ASN1characterstring_data_value_s
    {
        ASN1uint8_t o;
        union
        {
#            define ASN1characterstring_data_value_notation_o 0
            ASN1open_t notation;
#            define ASN1characterstring_data_value_encoded_o 1
            ASN1octetstring_t encoded;
        } u;
    } data_value;
} ASN1characterstring_t;

typedef struct ASN1characterstring_identification_s ASN1characterstring_identification_t;
typedef struct ASN1characterstring_identification_syntaxes_s ASN1characterstring_identification_syntaxes_t;
typedef struct ASN1characterstring_identification_context_negotiation_s ASN1characterstring_identification_context_negotiation_t;
typedef struct ASN1characterstring_data_value_s ASN1characterstring_data_value_t;


extern ASN1_PUBLIC void ASN1API ASN1real_free(ASN1real_t *);
extern ASN1_PUBLIC void ASN1API ASN1external_free(ASN1external_t *);
extern ASN1_PUBLIC void ASN1API ASN1embeddedpdv_free(ASN1embeddedpdv_t *);
extern ASN1_PUBLIC void ASN1API ASN1characterstring_free(ASN1characterstring_t *);

#include <poppack.h> /* End 8-byte packing */

//
// msber.h
//

#include <pshpack8.h> /* Assume 8 byte packing throughout */

extern ASN1_PUBLIC int ASN1API ASN1BEREncCharString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t, ASN1char_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncChar16String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t, ASN1char16_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncChar32String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t, ASN1char32_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncOctetString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1octet_t *val);
extern ASN1_PUBLIC int ASN1API ASN1BEREncBitString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t, ASN1octet_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncDouble(ASN1encoding_t enc, ASN1uint32_t tag, double);
extern ASN1_PUBLIC int ASN1API ASN1BEREncGeneralizedTime(ASN1encoding_t enc, ASN1uint32_t tag, ASN1generalizedtime_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncS32(ASN1encoding_t enc, ASN1uint32_t tag, ASN1int32_t);
extern ASN1_PUBLIC int ASN1API ASN1BEREncSX(ASN1encoding_t enc, ASN1uint32_t tag, ASN1intx_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncZeroMultibyteString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1ztcharstring_t);
extern ASN1_PUBLIC int ASN1API ASN1BEREncMultibyteString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1charstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncNull(ASN1encoding_t enc, ASN1uint32_t tag);
extern ASN1_PUBLIC int ASN1API ASN1BEREncObjectIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, ASN1objectidentifier_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncObjectIdentifier2(ASN1encoding_t enc, ASN1uint32_t tag, ASN1objectidentifier2_t *val);
extern ASN1_PUBLIC int ASN1API ASN1BEREncRemoveZeroBits(ASN1uint32_t *, ASN1octet_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncUTCTime(ASN1encoding_t enc, ASN1uint32_t tag, ASN1utctime_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncFlush(ASN1encoding_t enc);
extern ASN1_PUBLIC int ASN1API ASN1BEREncOpenType(ASN1encoding_t enc, ASN1open_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecExplicitTag(ASN1decoding_t dec, ASN1uint32_t tag, ASN1decoding_t *dd, ASN1octet_t **di);
extern ASN1_PUBLIC int ASN1API ASN1BERDecEndOfContents(ASN1decoding_t dec, ASN1decoding_t dd, ASN1octet_t *di);
extern ASN1_PUBLIC int ASN1API ASN1BERDecOctetString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1octetstring_t *val);
extern ASN1_PUBLIC int ASN1API ASN1BERDecOctetString2(ASN1decoding_t dec, ASN1uint32_t tag, ASN1octetstring_t *val);
extern ASN1_PUBLIC int ASN1API ASN1BERDecBitString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1bitstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecBitString2(ASN1decoding_t dec, ASN1uint32_t tag, ASN1bitstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecChar16String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1char16string_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecChar32String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1char32string_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecCharString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1charstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecDouble(ASN1decoding_t dec, ASN1uint32_t tag, double *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecGeneralizedTime(ASN1decoding_t dec, ASN1uint32_t tag, ASN1generalizedtime_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecZeroMultibyteString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1ztcharstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecMultibyteString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1charstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecNull(ASN1decoding_t dec, ASN1uint32_t tag);
extern ASN1_PUBLIC int ASN1API ASN1BERDecObjectIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, ASN1objectidentifier_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecObjectIdentifier2(ASN1decoding_t dec, ASN1uint32_t tag, ASN1objectidentifier2_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecS8Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1int8_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecS16Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1int16_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecS32Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1int32_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecSXVal(ASN1decoding_t dec, ASN1uint32_t tag, ASN1intx_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecU8Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint8_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecU16Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint16_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecUTCTime(ASN1decoding_t dec, ASN1uint32_t tag, ASN1utctime_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecZeroChar16String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1ztchar16string_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecZeroChar32String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1ztchar32string_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecZeroCharString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1ztcharstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecSkip(ASN1decoding_t dec);
extern ASN1_PUBLIC int ASN1API ASN1BERDecFlush(ASN1decoding_t dec);
extern ASN1_PUBLIC int ASN1API ASN1BERDecOpenType(ASN1decoding_t dec, ASN1open_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecOpenType2(ASN1decoding_t dec, ASN1open_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncCheck(ASN1encoding_t enc, ASN1uint32_t noctets);
extern ASN1_PUBLIC int ASN1API ASN1BEREncTag(ASN1encoding_t enc, ASN1uint32_t tag);
extern ASN1_PUBLIC int ASN1API ASN1BEREncExplicitTag(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t *pLengthOffset);
extern ASN1_PUBLIC int ASN1API ASN1BEREncEndOfContents(ASN1encoding_t enc, ASN1uint32_t LengthOffset);
extern ASN1_PUBLIC int ASN1API ASN1BEREncLength(ASN1encoding_t enc, ASN1uint32_t len);
extern ASN1_PUBLIC int ASN1API ASN1BERDecCheck(ASN1decoding_t dec, ASN1uint32_t len);
extern ASN1_PUBLIC int ASN1API ASN1BERDecTag(ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint32_t *constructed);
extern ASN1_PUBLIC int ASN1API ASN1BERDecLength(ASN1decoding_t dec, ASN1uint32_t *len, ASN1uint32_t *infinite);
extern ASN1_PUBLIC int ASN1API ASN1BERDecNotEndOfContents(ASN1decoding_t dec, ASN1octet_t *di);
extern ASN1_PUBLIC int ASN1API ASN1BERDecPeekTag(ASN1decoding_t dec, ASN1uint32_t *tag);
extern ASN1_PUBLIC int ASN1API ASN1BEREncU32(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t);
extern ASN1_PUBLIC int ASN1API ASN1BERDecU32Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint32_t *val);
extern ASN1_PUBLIC int ASN1API ASN1BEREncBool(ASN1encoding_t enc, ASN1uint32_t tag, ASN1bool_t);
extern ASN1_PUBLIC int ASN1API ASN1BERDecBool(ASN1decoding_t dec, ASN1uint32_t tag, ASN1bool_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncEoid(ASN1encoding_t enc, ASN1uint32_t tag, ASN1encodedOID_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecEoid(ASN1decoding_t dec, ASN1uint32_t tag, ASN1encodedOID_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDotVal2Eoid(ASN1encoding_t enc, char *pszDotVal, ASN1encodedOID_t *pOut);
extern ASN1_PUBLIC int ASN1API ASN1BEREoid2DotVal(ASN1decoding_t dec, ASN1encodedOID_t *pIn, char **ppszDotVal);
extern ASN1_PUBLIC void ASN1API ASN1BEREoid_free(ASN1encodedOID_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncUTF8String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t length, WCHAR *value);
extern ASN1_PUBLIC int ASN1API ASN1BERDecUTF8String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1wstring_t *val);

/* CER variant of BER */

extern ASN1_PUBLIC int ASN1API ASN1CEREncCharString(ASN1encoding_t enc, ASN1uint32_t, ASN1uint32_t, ASN1char_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncChar16String(ASN1encoding_t enc, ASN1uint32_t, ASN1uint32_t, ASN1char16_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncChar32String(ASN1encoding_t enc, ASN1uint32_t, ASN1uint32_t, ASN1char32_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncBitString(ASN1encoding_t enc, ASN1uint32_t, ASN1uint32_t, ASN1octet_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncGeneralizedTime(ASN1encoding_t enc, ASN1uint32_t, ASN1generalizedtime_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncZeroMultibyteString(ASN1encoding_t enc, ASN1uint32_t, ASN1ztcharstring_t);
extern ASN1_PUBLIC int ASN1API ASN1CEREncMultibyteString(ASN1encoding_t enc, ASN1uint32_t, ASN1charstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncOctetString(ASN1encoding_t enc, ASN1uint32_t, ASN1uint32_t, ASN1octet_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncUTCTime(ASN1encoding_t enc, ASN1uint32_t, ASN1utctime_t *);

extern ASN1_PUBLIC int ASN1API ASN1CEREncBeginBlk(ASN1encoding_t enc, ASN1blocktype_e eBlkType, void **ppBlk);
extern ASN1_PUBLIC int ASN1API ASN1CEREncNewBlkElement(void *pBlk, ASN1encoding_t *enc2);
extern ASN1_PUBLIC int ASN1API ASN1CEREncFlushBlkElement(void *pBlk);
extern ASN1_PUBLIC int ASN1API ASN1CEREncEndBlk(void *pBlk);

/* DER variant of BER */

__inline int ASN1API ASN1DEREncGeneralizedTime(ASN1encoding_t enc, ASN1uint32_t tag, ASN1generalizedtime_t *val)
{
    return ASN1CEREncGeneralizedTime(enc, tag, val);
}
__inline int ASN1API ASN1DEREncUTCTime(ASN1encoding_t enc, ASN1uint32_t tag, ASN1utctime_t *val)
{
    return ASN1CEREncUTCTime(enc, tag, val);
}

__inline int ASN1API ASN1DEREncBeginBlk(ASN1encoding_t enc, ASN1blocktype_e eBlkType, void **ppBlk)
{
    return ASN1CEREncBeginBlk(enc, eBlkType, ppBlk);
}
__inline int ASN1API ASN1DEREncNewBlkElement(void *pBlk, ASN1encoding_t *enc2)
{
    return ASN1CEREncNewBlkElement(pBlk, enc2);
}
__inline int ASN1API ASN1DEREncFlushBlkElement(void *pBlk)
{
    return ASN1CEREncFlushBlkElement(pBlk);
}
__inline int ASN1API ASN1DEREncEndBlk(void *pBlk)
{
    return ASN1CEREncEndBlk(pBlk);
}

__inline int ASN1API ASN1DEREncCharString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1char_t *val)
{
    return ASN1BEREncCharString(enc, tag, len, val);
}
__inline int ASN1API ASN1DEREncChar16String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1char16_t *val)
{
    return ASN1BEREncChar16String(enc, tag, len, val);
}
__inline int ASN1API ASN1DEREncChar32String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1char32_t *val)
{
    return ASN1BEREncChar32String(enc, tag, len, val);
}
__inline int ASN1API ASN1DEREncBitString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1octet_t *val)
{
    return ASN1BEREncBitString(enc, tag, len, val);
}
__inline int ASN1API ASN1DEREncZeroMultibyteString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1ztcharstring_t val)
{
    return ASN1BEREncZeroMultibyteString(enc, tag, val);
}
__inline int ASN1API ASN1DEREncMultibyteString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1charstring_t *val)
{
    return ASN1BEREncMultibyteString(enc, tag, val);
}
__inline int ASN1API ASN1DEREncOctetString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1octet_t *val)
{
    return ASN1BEREncOctetString(enc, tag, len, val);
}

__inline int ASN1API ASN1DEREncUTF8String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t length, WCHAR *value)
{
    return ASN1BEREncUTF8String(enc, tag, length, value);
}
__inline int ASN1API ASN1CEREncUTF8String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t length, WCHAR *value)
{
    return ASN1BEREncUTF8String(enc, tag, length, value);
}


/* --------------------------------------------------------- */
/* The following is not supported.                           */
/* --------------------------------------------------------- */

extern ASN1_PUBLIC int ASN1API ASN1BEREncEmbeddedPdv(ASN1encoding_t enc, ASN1uint32_t tag, ASN1embeddedpdv_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncExternal(ASN1encoding_t enc, ASN1uint32_t tag, ASN1external_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncCharacterString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1characterstring_t *);

extern ASN1_PUBLIC int ASN1API ASN1BERDecEmbeddedPdv(ASN1decoding_t dec, ASN1uint32_t tag, ASN1embeddedpdv_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecExternal(ASN1decoding_t dec, ASN1uint32_t tag, ASN1external_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecCharacterString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1characterstring_t *);

#include <poppack.h> /* End 8-byte packing */

#endif // __MS_ASN1_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\msr_md5.cpp ===
/*
       File md5.c.    Version 03 August 2000.
                   
                     
          Peter L. Montgomery
          Microsoft Research
          petmon@microsoft.com

      This implements the MD5 hash function.  
      For algorithmic background see (for example)

           Bruce Schneier
           Applied Cryptography
           Protocols, Algorithms, and Source Code in C
           Second Edition
           Wiley, 1996
           ISBN 0-471-12845-7
           QA76.9 A25S35

           Alfred J. Menezes et al
           Handbook of Applied Cryptography
           The CRC Press Series on Discrete Mathematics
                   and its Applications
           CRC Press LLC, 1997
           ISBN 0-8495-8523-7
           QA76.9A25M643

       Also see RFC (Request For Comments) 1321 from April, 1992.
       A July 2000 search for "rfc md5" or "rfc 1321"
       at www.yahoo.com found the document at

           http://www.cis.ohio-state.edu/htbin/rfc/rfc1321.html

       and other sites.
*/

#include "xonp.h"
#include "xonver.h"

#pragma intrinsic(_rotl)
#define ROTATE32L(x, amt) ((tUint32)_rotl((x), (amt)))
#define SHAVE32(x) (x)

#define MIN(x,y) (((x) < (y)) ? (x) : (y))
#define FALSE   0
#define TRUE    1

#pragma warning(disable: 4146)

static const tUint32 msr_MD5_cons[64] =
// Round 1
 {0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee,
  0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,
  0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,
  0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,

// Round 2
  0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa,
  0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8, 
  0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed,
  0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,

// Round 3
  0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c,
  0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,
  0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05,
  0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,

// Round 4
  0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039,
  0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,
  0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,
  0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391};

static const tUint32 msr_magic_md5 = 0x2035444DUL;
                          // "MD5 " in ASCII

static tBool msr_MD5_block(msr_MD5_CTX *ctx)
/*
     Update the MD5 hash from a fresh 64 bytes of data.
*/
{
    tUint32 a = ctx->partial_hash[0], b = ctx->partial_hash[1]; 
    tUint32 c = ctx->partial_hash[2], d = ctx->partial_hash[3];
    tUint32  msg16[32];   /// Two copies of message
    const tUint32*cons = msr_MD5_cons;
    int i;
    tBool OK = TRUE;

    for (i = 0; i != 16; i++) {   // Copy to local array, zero original
                                  // Make two copies, to simplify indexing
        const tUint32 datval = ctx->awaiting_data[i];
        ctx->awaiting_data[i] = 0;
        msg16[i] = msg16[i+16] = datval;
    }


// Round 1
    for (i = -16; i != 0; i += 4) { 
      
            // Rewrite (X & Y) | (~X & Z)  as  Z ^ (X & (Y ^ Z))
            // [Easily validated by checking X = 0 and X = 1 cases.]
            // This avoids ANDNOT (which X86 lacks) and needs only 
            // one temporary register.
            // On register-rich architectures, the Y ^ Z computation
            // can start early, before X is computed.

        a += msg16[i+16] + cons[0] + (d ^ (b & (c ^ d)));
        a = b + ROTATE32L(a, 7);

        d += msg16[i+17] + cons[1] + (c ^ (a & (b ^ c)));
        d = a + ROTATE32L(d, 12);

        c += msg16[i+18] + cons[2] + (b ^ (d & (a ^ b)));
        c = d + ROTATE32L(c, 17);

        b += msg16[i+19] + cons[3] + (a ^ (c & (d ^ a)));
        b = c + ROTATE32L(b, 22);

        cons += 4;
    }

// Round 2
    for (i = -16; i != 0; i += 4) {
            // Rewrite (Z & X) | (~Z & Y)  as  Y ^ (Z & (X ^ Y))
        a += msg16[i+17] + cons[0] + (c ^ (d & (b ^ c)));
        a = b + ROTATE32L(a, 5);

        d += msg16[i+22] + cons[1] + (b ^ (c & (a ^ b)));
        d = a + ROTATE32L(d, 9);

        c += msg16[i+27] + cons[2] + (a ^ (b & (d ^ a))); 
        c = d + ROTATE32L(c, 14);

        b += msg16[i+16] + cons[3] + (d ^ (a & (c ^ d)));
        b = c + ROTATE32L(b, 20);

        cons += 4;
    }

// Round 3
    for (i = 16; i != 0; i -= 4) { 
        a += msg16[i+5]  + cons[0] + ((b ^ c) ^ d);
        a = b + ROTATE32L(a, 4);
        
        d += msg16[i+8]  + cons[1] + (a ^ (b ^ c));
        d = a + ROTATE32L(d, 11);
        
        c += msg16[i+11] + cons[2] + ((d ^ a) ^ b);
        c = d + ROTATE32L(c, 16);

        b += msg16[i+14] + cons[3] + (c ^ (d ^ a));
        b = c + ROTATE32L(b, 23);

        cons += 4;
    }

// Round 4
    for (i = 16; i != 0; i -= 4) {
        a += msg16[i  ]  + cons[0] + (c ^ (~d | b));
        a = b + ROTATE32L(a, 6);

        d += msg16[i+7]  + cons[1] + (b ^ (~c | a));
        d = a + ROTATE32L(d, 10);

        c += msg16[i+14] + cons[2] + (a ^ (~b | d));
        c = d + ROTATE32L(c, 15);

        b += msg16[i+5]  + cons[3] + (d ^ (~a | c));
        b = c + ROTATE32L(b, 21);

        cons += 4;
    }
#if PRINT_ERROR_MESSAGES
    assert (cons == msr_MD5_cons + 64);
#endif

    ctx->partial_hash[0] += a;
    ctx->partial_hash[1] += b;
    ctx->partial_hash[2] += c;
    ctx->partial_hash[3] += d;
#if 0
    for (i = 0; i != 16; i++) {
        printf("%8lx ", msg16[i]);
        if ((i & 7) == 7) printf("\n");
    }
    printf("a, b, c, d = %08lx %08lx %08lx %08lx\n", a, b, c, d);
    printf("Partial hash = %08lx %08lx %08lx %08lx\n",
        (long)ctx->partial_hash[0], (long)ctx->partial_hash[1],
        (long)ctx->partial_hash[2], (long)ctx->partial_hash[3]);
#endif 
    return OK;
} // end MD5_block


tBool ECAPI msr_MD5Init(msr_MD5_CTX *ctx)
{
    tBool OK = TRUE;
    tUint32 i;
    ctx->nbit_total[0] = ctx->nbit_total[1] = 0;
    for (i = 0; i != 16; i++) {
        ctx->awaiting_data[i] = 0;
    }
   
     /* 
         Initialize hash variables.
         
         N.B.  The initial values in RFC 1321 appear
         in byte-reversed order.  Bruce Schneier's 
         2nd edition neglects to rearrange them.
     */

    ctx->partial_hash[0] = 0x67452301;
    ctx->partial_hash[1] = 0xefcdab89;
    ctx->partial_hash[2] = ~ctx->partial_hash[0];
    ctx->partial_hash[3] = ~ctx->partial_hash[1];
   
    ctx->magic_md5 = msr_magic_md5;
    return OK;
} // end MD5Init


tBool ECAPI msr_MD5Update(
        msr_MD5_CTX    *ctx,    // IN/OUT
        const tUint8 msg[],   // IN
        const tUint32    nbyte)   // IN
/*
    Append data to a partially hashed MD5 message.
*/
{
    const tUint8 *fresh_data = msg;
    tUint32 nbyte_left = nbyte;
    tUint32 nbit_occupied = ctx->nbit_total[0] & 511;
    tUint32 *awaiting_data;
    tBool OK = TRUE;
    const tUint32 nbitnew_low = SHAVE32(8*nbyte);

    if (ctx->magic_md5 != msr_magic_md5) {
#if PRINT_ERROR_MESSAGES
        fprintf(mp_errfil, "Bad first argument to MD5Update\n");
#endif
        return FALSE;
    }
        

#if PRINT_ERROR_MESSAGES
    assert((nbit_occupied & 7) == 0);   // Partial bytes not implemented
#endif   
    ctx->nbit_total[0] += nbitnew_low;
    ctx->nbit_total[1] += (nbyte >> 29) 
           + (SHAVE32(ctx->nbit_total[0]) < nbitnew_low);

        /* Advance to word boundary in waiting_data */
    
    if ((nbit_occupied & 31) != 0) {
        awaiting_data = ctx->awaiting_data + nbit_occupied/32;

        while ((nbit_occupied & 31) != 0 && nbyte_left != 0) {
            *awaiting_data |= (tUint32)*fresh_data++ 
                     << (nbit_occupied & 31);
            nbyte_left--;
            nbit_occupied += 8;
        }
    } // if nbit_occupied

             /* Transfer 4 bytes at a time */

    do {
        const tUint32 nword_occupied = nbit_occupied/32;
        tUint32 nwcopy = MIN(nbyte_left/4, 16 - nword_occupied);
#if PRINT_ERROR_MESSAGES 
        assert (nbit_occupied <= 512);
        assert ((nbit_occupied & 31) == 0 || nbyte_left == 0);
#endif
        awaiting_data = ctx->awaiting_data + nword_occupied;
        nbyte_left -= 4*nwcopy;
        nbit_occupied += 32*nwcopy;

        while (nwcopy != 0) {
            const tUint32 byte0 = (tUint32)fresh_data[0];
            const tUint32 byte1 = (tUint32)fresh_data[1];
            const tUint32 byte2 = (tUint32)fresh_data[2];
            const tUint32 byte3 = (tUint32)fresh_data[3];
            *awaiting_data++ = byte0 | (byte1 << 8)
                        | (byte2 << 16) | (byte3 << 24);
                             /* Little endian */
            fresh_data += 4;
            nwcopy--;
        } 

        if (nbit_occupied == 512) {
            OK = OK && msr_MD5_block(ctx);
            nbit_occupied = 0;
            awaiting_data -= 16;
#if PRINT_ERROR_MESSAGES
            assert(awaiting_data == ctx->awaiting_data);
#endif
        }
    } while (nbyte_left >= 4); 

#if PRINT_ERROR_MESSAGES
    assert (ctx->awaiting_data + nbit_occupied/32
                       == awaiting_data);
#endif

    while (nbyte_left != 0) {
        const tUint32 new_byte = (tUint32)*fresh_data++;

#if PRINT_ERROR_MESSAGES
        assert((nbit_occupied & 31) <= 16);
#endif
        *awaiting_data |= new_byte << (nbit_occupied & 31);
        nbit_occupied += 8;
        nbyte_left--;
    }
#if PRINT_ERROR_MESSAGES
    assert (nbit_occupied == (ctx->nbit_total[0] & 511));
#endif
    return OK;
} // end MD5Update


tBool ECAPI msr_MD5Final(msr_MD5_CTX *ctx)          // IN/OUT
/*
        Finish an MD5 hash.
*/
{
    tBool OK = TRUE;
    const tUint32 nbit0 = ctx->nbit_total[0];
    const tUint32 nbit1 = ctx->nbit_total[1];
    tUint32  nbit_occupied = nbit0 & 511;
    tUint32 i;

    OK = OK && ctx->magic_md5 == msr_magic_md5;
#if PRINT_ERROR_MESSAGES
    assert((nbit_occupied & 7) == 0);
#endif

    ctx->awaiting_data[nbit_occupied/32] 
         |= (tUint32)0x80 << (nbit_occupied & 31);
                          // Append a 1 bit
    nbit_occupied += 8;

// TBD -- Above seems wierd -- why number bytes from the
//        least significant end but number bits the other way?

    // Append zero bits until length (in bits) is 448 mod 512.
    // Then append the length, in bits.
    // Here we assume the buffer was zeroed earlier.

    if (nbit_occupied > 448) {   // If fewer than 64 bits left
        OK = OK && msr_MD5_block(ctx);
        nbit_occupied = 0;
    }
    ctx->awaiting_data[14] = nbit0;
    ctx->awaiting_data[15] = nbit1;
    OK = OK && msr_MD5_block(ctx);

         /* Copy final digest to byte array */

    for (i = 0; i != 4; i++) {
        const tUint32 dwi = ctx->partial_hash[i];
        ctx->digest[4*i    ] = (tUint8)(dwi         & 255);  // Little-endian
        ctx->digest[4*i + 1] = (tUint8)((dwi >>  8) & 255);
        ctx->digest[4*i + 2] = (tUint8)((dwi >> 16) & 255);
        ctx->digest[4*i + 3] = (tUint8)((dwi >> 24) & 255);
    }
    ctx->magic_md5 = 0;    // Invalidate block for future calls
    return OK;
} // end MD5Final
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\olddash.cpp ===
/*++

Copyright (c) Microsoft Corporation

Author:
    Keith Lau (keithlau)

Description:
	Module implementing cleanup code for old dash files

Module Name:

    olddash.cpp

--*/

#include "xonp.h"
#include "xonver.h"

#ifdef XONLINE_FEATURE_XBOX

//
// To simpify things, have a list of old dash files
//
// Files first, followed by directories
// Directories must be in post-order, otherwise, they will not 
// be deleted properly
//
const PSTR g_rgszOldFiles[] =
{
	"y:\\default.xip",
	"y:\\dvd.xip",
	"y:\\dvdkeyd.bin",
	"y:\\jkeyboard.xip",
	"y:\\Keyboard.xip",
	"y:\\mainmenu5.xip",
	"y:\\Memory2.xip",
	"y:\\memory_files2.xip",
	"y:\\Message.xip",
	"y:\\music2.xip",
	"y:\\music_copy3.xip",
	"y:\\Music_PlayEdit2.xip",
	"y:\\settings3.xip",
	"y:\\Settings_Clock.xip",
	"y:\\settings_language.xip",
	"y:\\settings_list.xip",
	"y:\\settings_panel.xip",
	"y:\\settings_parental.xip",
	"y:\\settings_timezone.xip",
	"y:\\settings_video.xip",
	"y:\\XBox Book.xtf",
	"y:\\Xbox.xtf",
	"y:\\3dinfo\\cameramainTV.cam",
	"y:\\3dinfo\\cellwall.bmp",
	"y:\\3dinfo\\matobj0.mdl",
	"y:\\3dinfo\\matobj1.mdl",
	"y:\\3dinfo\\matobj10.mdl",
	"y:\\3dinfo\\matobj11.mdl",
	"y:\\3dinfo\\matobj12.mdl",
	"y:\\3dinfo\\matobj2.mdl",
	"y:\\3dinfo\\matobj3.mdl",
	"y:\\3dinfo\\matobj4.mdl",
	"y:\\3dinfo\\matobj5.mdl",
	"y:\\3dinfo\\matobj6.mdl",
	"y:\\3dinfo\\matobj7.mdl",
	"y:\\3dinfo\\matobj8.mdl",
	"y:\\3dinfo\\matobj9.mdl",
	"y:\\Audio\\AmbientAudio\\AMB_05_ENGINEROOM_LR.wav",
	"y:\\Audio\\AmbientAudio\\AMB_06_COMMUNICATION_LR.wav",
	"y:\\Audio\\AmbientAudio\\AMB_12_HYDROTHUNDER_LR.wav",
	"y:\\Audio\\AmbientAudio\\AMB_EC_Pinger1.wav",
	"y:\\Audio\\AmbientAudio\\AMB_EC_Steam1.wav",
	"y:\\Audio\\AmbientAudio\\AMB_EC_Steam2.wav",
	"y:\\Audio\\AmbientAudio\\AMB_EC_Steam3.wav",
	"y:\\Audio\\AmbientAudio\\AMB_EC_Steam4.wav",
	"y:\\Audio\\AmbientAudio\\AMB_EC_Steam5.wav",
	"y:\\Audio\\AmbientAudio\\AMB_EC_Steam6.wav",
	"y:\\Audio\\AmbientAudio\\AMB_EC_Steam7.wav",
	"y:\\Audio\\AmbientAudio\\AMB_EC_Voices1.wav",
	"y:\\Audio\\AmbientAudio\\AMB_EC_Voices10.wav",
	"y:\\Audio\\AmbientAudio\\AMB_EC_Voices11.wav",
	"y:\\Audio\\AmbientAudio\\AMB_EC_Voices12.wav",
	"y:\\Audio\\AmbientAudio\\AMB_EC_Voices13.wav",
	"y:\\Audio\\AmbientAudio\\AMB_EC_Voices2.wav",
	"y:\\Audio\\AmbientAudio\\AMB_EC_Voices3.wav",
	"y:\\Audio\\AmbientAudio\\AMB_EC_Voices4.wav",
	"y:\\Audio\\AmbientAudio\\AMB_EC_Voices5.wav",
	"y:\\Audio\\AmbientAudio\\AMB_EC_Voices6.wav",
	"y:\\Audio\\AmbientAudio\\AMB_EC_Voices7.wav",
	"y:\\Audio\\AmbientAudio\\AMB_EC_Voices8.wav",
	"y:\\Audio\\AmbientAudio\\AMB_EC_Voices9.wav",
	"y:\\Audio\\AmbientAudio\\comm static 1.wav",
	"y:\\Audio\\AmbientAudio\\comm static 2.wav",
	"y:\\Audio\\AmbientAudio\\comm static 3.wav",
	"y:\\Audio\\AmbientAudio\\comm static 4.wav",
	"y:\\Audio\\AmbientAudio\\comm voice 1.wav",
	"y:\\Audio\\AmbientAudio\\comm voice 2.wav",
	"y:\\Audio\\AmbientAudio\\comm voice 3.wav",
	"y:\\Audio\\AmbientAudio\\comm voice 4.wav",
	"y:\\Audio\\AmbientAudio\\comm voice 5.wav",
	"y:\\Audio\\AmbientAudio\\comm voice 6.wav",
	"y:\\Audio\\AmbientAudio\\comm voice 7.wav",
	"y:\\Audio\\AmbientAudio\\comm voice 8.wav",
	"y:\\Audio\\AmbientAudio\\comm voice 9.wav",
	"y:\\Audio\\AmbientAudio\\Control Room Loop ver2.wav",
	"y:\\Audio\\AmbientAudio\\Control Room Loop.wav",
	"y:\\Audio\\MainAudio\\Global A Button Select.wav",
	"y:\\Audio\\MainAudio\\Global B Button Back.wav",
	"y:\\Audio\\MainAudio\\Global Completion Beep.wav",
	"y:\\Audio\\MainAudio\\Global Delete_Destroy.wav",
	"y:\\Audio\\MainAudio\\Global Error Message B.wav",
	"y:\\Audio\\MainAudio\\Global Keyboard Stroke 1.wav",
	"y:\\Audio\\MainAudio\\Global Keyboard Stroke 2.wav",
	"y:\\Audio\\MainAudio\\Global Main MenuBack3ver2.wav",
	"y:\\Audio\\MainAudio\\Global Main MenuFwd3ver2.wav",
	"y:\\Audio\\MainAudio\\Global Progress Bar.wav",
	"y:\\Audio\\MainAudio\\Global Scroll Beep.wav",
	"y:\\Audio\\MemoryAudio\\Memory Controller Select.wav",
	"y:\\Audio\\MemoryAudio\\Memory Games Select.wav",
	"y:\\Audio\\MemoryAudio\\Memory Memory Slot Select.wav",
	"y:\\Audio\\MusicAudio\\Games Info Screen In MSurr.wav",
	"y:\\Audio\\MusicAudio\\Games Info Screen In.wav",
	"y:\\Audio\\MusicAudio\\Games Info Screen Out MSurr.wav",
	"y:\\Audio\\MusicAudio\\Games Info Screen Out.wav",
	"y:\\Audio\\MusicAudio\\Music CD Select.wav",
	"y:\\Audio\\SettingsAudio\\Settings Lang SubMenu Sel.wav",
	"y:\\Audio\\SettingsAudio\\Settings Parent SubMenu Sel.wav",
	"y:\\Audio\\TransitionAudio\\Games Main Menu In_LR.wav",
	"y:\\Audio\\TransitionAudio\\Games Main Menu Out_LR.wav",
	"y:\\Audio\\TransitionAudio\\Games Sub Menu In_LR.wav",
	"y:\\Audio\\TransitionAudio\\Games Sub Menu Out_LR.wav",
	"y:\\Audio\\TransitionAudio\\Music Main Menu In_LR.wav",
	"y:\\Audio\\TransitionAudio\\Music Main Menu Out_LR.wav",
	"y:\\Audio\\TransitionAudio\\Music Select Track In_LR.wav",
	"y:\\Audio\\TransitionAudio\\Music Select Track Out_LR.wav",
	"y:\\Audio\\TransitionAudio\\Settings Main Menu In_LR.wav",
	"y:\\Audio\\TransitionAudio\\Settings Main Menu Out_LR.wav",
	"y:\\Audio\\TransitionAudio\\Settings Sub Menu In_LR.wav",
	"y:\\Audio\\TransitionAudio\\Settings Sub Menu Out_LR.wav",
	"y:\\data\\saveimage.xbx",
	"y:\\data\\titleimage.xbx",
	"y:\\images\\logo.bmp",
	"y:\\images\\logow.bmp",
	"y:\\media\\tahoma.ttf",
	"y:\\menus\\avreg.mnu",
	"y:\\menus\\cert.mnu",
	"y:\\menus\\dispset.mnu",
	"y:\\menus\\dns.mnu",
	"y:\\menus\\dumpcache.mnu",
	"y:\\menus\\eeprom.mnu",
	"y:\\menus\\errormsg.mnu",
	"y:\\menus\\gamereg.mnu",
	"y:\\menus\\gateway.mnu",
	"y:\\menus\\ip.mnu",
	"y:\\menus\\language.mnu",
	"y:\\menus\\machine.mnu",
	"y:\\menus\\madisplay.mnu",
	"y:\\menus\\memopts.mnu",
	"y:\\menus\\memory.mnu",
	"y:\\menus\\muformat.mnu",
	"y:\\menus\\muname.mnu",
	"y:\\menus\\muunformat.mnu",
	"y:\\menus\\network.mnu",
	"y:\\menus\\options.mnu",
	"y:\\menus\\root.mnu",
	"y:\\menus\\settings.mnu",
	"y:\\menus\\subnet.mnu",
	"y:\\menus\\sysinfo.mnu",
	"y:\\menus\\timezone.mnu",
	"y:\\menus\\videores.mnu",
	"y:\\sounds\\back_button.wav",
	"y:\\sounds\\keyboard_stroke.wav",
	"y:\\sounds\\menu_item_select.wav",
	"y:\\sounds\\select_button.wav",
	"y:\\Audio\\AmbientAudio",
	"y:\\Audio\\MainAudio",
	"y:\\Audio\\MemoryAudio",
	"y:\\Audio\\MusicAudio",
	"y:\\Audio\\SettingsAudio",
	"y:\\Audio\\TransitionAudio",
	"y:\\Audio",
	"y:\\3dinfo",
	"y:\\data",
	"y:\\images",
	"y:\\media",
	"y:\\menus",
	"y:\\sounds",
//	"y:\\xboxdash.xbe",
//	"y:\\XShell.xbe"
};

const DWORD g_cszOldFiles = sizeof(g_rgszOldFiles) / sizeof(PSTR);

//
// Define one global instance
//

#define READ_ONLY_ATTRIBUTES \
						(FILE_ATTRIBUTE_HIDDEN |\
						 FILE_ATTRIBUTE_SYSTEM |\
						 FILE_ATTRIBUTE_READONLY)
//
// Task do work function
//
HRESULT CXo::xododContinue(
			XONLINETASK_HANDLE	hTask
			)
{
	PXONLINETASK_DEL_OLD_DASH 	pxodod = (PXONLINETASK_DEL_OLD_DASH)hTask;
	WIN32_FILE_ATTRIBUTE_DATA 	fad;
	DWORD						iCurrent;

	Assert(pxodod);

	iCurrent = (pxodod->iCurrent)++;
	if (iCurrent >= g_cszOldFiles)
		return(XONLINETASK_S_SUCCESS);

	if (!GetFileAttributesEx(
				g_rgszOldFiles[iCurrent], GetFileExInfoStandard, &fad))
		goto Exit;

	// Turn off any hidden, system, or read-only bits
	if (fad.dwFileAttributes & READ_ONLY_ATTRIBUTES)
	{
		fad.dwFileAttributes &= ~(READ_ONLY_ATTRIBUTES);
		SetFileAttributes(g_rgszOldFiles[iCurrent], fad.dwFileAttributes);
	}

	if (fad.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
		RemoveDirectory(g_rgszOldFiles[iCurrent]);
	else
		DeleteFile(g_rgszOldFiles[iCurrent]);

Exit:
	return(S_OK);
}

//
// Task close function
//
VOID CXo::xododClose(
			XONLINETASK_HANDLE	hTask
			)
{
	SysFree(hTask);
}

//
// Function to kick off an offline dash claenup.
//
// Clearly this task is not thread-safe so there
// must be only on eo these tasks running
//
// Note: the dash must already have been mounted as
// the y: drive before calling this function
//
HRESULT CXo::XOnlineUpdateDeleteOfflineDash(
			HANDLE						hWorkEvent,
			PXONLINETASK_DEL_OLD_DASH	pxodod
			)
{
	// Set up the autoupdate context
	TaskInitializeContext(&pxodod->xontask);
	pxodod->xontask.pfnContinue = xododContinue;
	pxodod->xontask.pfnClose = xododClose;
	pxodod->xontask.hEventWorkAvailable = hWorkEvent;
	pxodod->iCurrent = 0;

	return(S_OK);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\service.cpp ===
/*++

Copyright (c) Microsoft Corporation

Author:
    Keith Lau (keithlau)

Description:
    Temporary module implementing some logon and service stuff

Module Name:

    service.cpp

--*/

#include "xonp.h"
#include "xonver.h"

#define XONLINE_SERVICE_OVERRIDE_FILE "\\Device\\harddisk0\\Partition1\\devkit\\xonline.ini"

#define MAX_CONFIG_SIZE        4096

HRESULT CXo::_XOnlineOverrideInfo(LPSTR pszXOnlineIniFile)
{
#ifdef XONLINE_FEATURE_INSECURE
    return InitOverrideInfo( pszXOnlineIniFile );
#else
    return E_NOTIMPL;
#endif
}

#ifdef XONLINE_FEATURE_INSECURE

HRESULT CXo::InitOverrideInfo(LPSTR pszXOnlineIniFile)
{
    #define NOT_KDC 0
    #define IS_PKDC 1
    #define IS_XKDC 2
    #define IS_MKDC 3
    
    HRESULT          hr;
    NTSTATUS         Status;
    OBJECT_ATTRIBUTES Obja;
    OBJECT_STRING    FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE           hFile = INVALID_HANDLE_VALUE;
    PBYTE            pbAlloc = NULL;
    PCHAR            pcBuffer;
    PCHAR            pcBufferEnd;
    DWORD            dwSize;
    DWORD            dwWhichKDC;
    PCHAR            pcFirstString;
    PCHAR            pcIP;
    PCHAR            pcPort;
    PCHAR            pcCR;
    DWORD            dwServiceID;
    DWORD            len;
    DWORD            i;

    m_ctServiceInfoOverride = 0;
    
    //
    // Open the configuration ini file
    //
    RtlInitObjectString( &FileName, (pszXOnlineIniFile == NULL ? XONLINE_SERVICE_OVERRIDE_FILE : pszXOnlineIniFile));

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtCreateFile(
                &hFile,
                GENERIC_READ | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                NULL,
                0,
                0,
                FILE_OPEN,
                FILE_SYNCHRONOUS_IO_NONALERT
                );

    if (!NT_SUCCESS(Status)) 
    {
        hr = HRESULT_FROM_WIN32(RtlNtStatusToDosError(Status));
        goto Cleanup;
    }
    
    if (hFile == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    pbAlloc = (PBYTE)_alloca(MAX_CONFIG_SIZE);
    if (pbAlloc == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    
    pcBuffer = (PCHAR)pbAlloc;

    if (!ReadFile(hFile, pbAlloc, MAX_CONFIG_SIZE, &dwSize, NULL))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    Assert( dwSize <= MAX_CONFIG_SIZE - 1 );
    // Parse the configuration file
    pcBufferEnd = pcBuffer + dwSize;
    *pcBufferEnd++ = '\r';
    pcFirstString = pcBuffer;
    pcIP = NULL;
    pcPort = NULL;
    pcCR = NULL;
    
    while (pcBuffer < pcBufferEnd)
    {
        if (*pcBuffer == ':')
        {
            if (pcIP)
            {
                pcPort = pcBuffer+1;
                *pcBuffer = '\0';
            }
            else
            {
                pcIP = pcBuffer+1;
                *pcBuffer = '\0';
            }
        }
        else if (*pcBuffer == '\r')
        {
            pcCR = pcBuffer;
            *pcBuffer = '\0';
            pcBuffer++;
        }
        
        pcBuffer++;

        if (pcCR)
        {
            dwWhichKDC = NOT_KDC;
            
            if (*pcFirstString == 'S' && pcIP && pcPort)
            {
                dwServiceID = atol(pcFirstString+1);

                Assert( m_ctServiceInfoOverride < XONLINE_MAX_SERVICE_REQUEST );
                m_rgServiceInfoOverride[m_ctServiceInfoOverride].dwServiceID = dwServiceID;
                m_rgServiceInfoOverride[m_ctServiceInfoOverride].serviceIP.s_addr = inet_addr(pcIP);
                m_rgServiceInfoOverride[m_ctServiceInfoOverride].wServicePort = (WORD)atoi(pcPort);
                m_ctServiceInfoOverride++;
                TraceSz4(Verbose, "Overriding slot %d Service %d to IP %s Port %s", m_ctServiceInfoOverride, dwServiceID, pcIP, pcPort);
            }
            else if (_stricmp(pcFirstString,"FORCEMKDC") == 0)
            {
                m_fForceNewMachineAccount = TRUE;
            }
            else if (_stricmp(pcFirstString,"NUM_KERB_RETRY") == 0)
            {
                g_dwNumKerbRetry = atol(pcIP);
            }
            else if (_stricmp(pcFirstString,"NUM_MACS_RETRY") == 0)
            {
                g_dwNumMACSRetry = atol(pcIP);
            }
            else if (_stricmp(pcFirstString,"KERB_RETRY1_MS") == 0)
            {
                g_dwKerbRetryDelayInMilliSeconds[0] = atol(pcIP);
            }
            else if (_stricmp(pcFirstString,"KERB_RETRY2_MS") == 0)
            {
                g_dwKerbRetryDelayInMilliSeconds[1] = atol(pcIP);
            }
            else if (_stricmp(pcFirstString,"KERB_RETRY3_MS") == 0)
            {
                g_dwKerbRetryDelayInMilliSeconds[2] = atol(pcIP);
            }
            else if (_stricmp(pcFirstString,"KERB_RETRY4_MS") == 0)
            {
                g_dwKerbRetryDelayInMilliSeconds[3] = atol(pcIP);
            }
            else if (_stricmp(pcFirstString,"MACS_RETRY1_MS") == 0)
            {
                g_dwMACSRetryDelayInMilliSeconds[0] = atol(pcIP);
            }
            else if (_stricmp(pcFirstString,"MACS_RETRY2_MS") == 0)
            {
                g_dwMACSRetryDelayInMilliSeconds[1] = atol(pcIP);
            }
            else if (_stricmp(pcFirstString,"MACS_RETRY3_MS") == 0)
            {
                g_dwMACSRetryDelayInMilliSeconds[2] = atol(pcIP);
            }
            else if (_stricmp(pcFirstString,"MACS_RETRY4_MS") == 0)
            {
                g_dwMACSRetryDelayInMilliSeconds[3] = atol(pcIP);
            }
            else if (_stricmp(pcFirstString,"MKDC") == 0)
            {
                dwWhichKDC = IS_MKDC;
            }
            else if (_stricmp(pcFirstString,"XKDC") == 0)
            {
                dwWhichKDC = IS_XKDC;
            }
            else if (_stricmp(pcFirstString,"SG") == 0)
            {
                len = 0;
                if (pcIP)
                {
                    len = strlen(pcIP);
                }
                if (len != 0)
                {
                    m_sgAddr.s_addr = inet_addr( pcIP );
                }
                else
                {
                    m_fBypassSG = TRUE;
                }
            }

            if (dwWhichKDC != NOT_KDC)
            {
                len = 0;
                if (pcIP)
                {
                    len = strlen(pcIP);
                }
                if (len == 0)
                {
                       TraceSz1(Verbose, "Disabling %s to No Operation", pcFirstString);
                    m_fBypassAuth = TRUE;
                }
                else
                {
                       TraceSz2(Verbose, "Overriding %s to %s", pcFirstString, pcIP);
                       if (dwWhichKDC == IS_MKDC)
                       {
                           m_DNSCache[4].dwState = DNS_LOOKUP_COMPLETE;
                           m_DNSCache[4].address.cina = 1;
                           m_DNSCache[4].address.aina[0].s_addr = inet_addr( pcIP );
                       }
                       else if (dwWhichKDC == IS_XKDC)
                       {
                           m_DNSCache[0].dwState = DNS_LOOKUP_COMPLETE;
                           m_DNSCache[0].address.cina = 1;
                           m_DNSCache[0].address.aina[0].s_addr = inet_addr( pcIP );
                           m_DNSCache[1].dwState = DNS_LOOKUP_COMPLETE;
                           m_DNSCache[1].address.cina = 1;
                           m_DNSCache[1].address.aina[0].s_addr = inet_addr( pcIP );
                           m_DNSCache[2].dwState = DNS_LOOKUP_COMPLETE;
                           m_DNSCache[2].address.cina = 1;
                           m_DNSCache[2].address.aina[0].s_addr = inet_addr( pcIP );
                           m_DNSCache[3].dwState = DNS_LOOKUP_COMPLETE;
                           m_DNSCache[3].address.cina = 1;
                           m_DNSCache[3].address.aina[0].s_addr = inet_addr( pcIP );
                       }
                       else
                       {
                           AssertSz( FALSE, "dwWhichKDC has an invalid value" );
                       }
                }
            }
            
            pcFirstString = pcBuffer;
            pcIP = NULL;
            pcPort = NULL;
            pcCR = NULL;
        }            
    }

Cleanup:
        
    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
    }
    
    return hr;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\presence.cpp ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved

Description:
    Module implementing Xbox Presence APIs

Module Name:

    presence.cpp

--*/

#include "xonp.h"
#include "xonver.h"

// BUGBUG: Need to lock friend list during certain operations

//
// Server configuration information for presence and notification POST requests
// to front doors.
//
typedef struct
{
    DWORD dwService;                  // Service ID number
    CHAR * szUrl;                     // relative URL of ISAPI front door
    CHAR * szContentType;             // Service content type
    DWORD dwContentType;              // Size of the service content type
} XPRESENCE_SERVERS, *PXPRESENCE_SERVERS;

const XPRESENCE_SERVERS g_PresenceServers[2] =
{
    { XONLINE_PRESENCE_SERVICE, "/xpnfront/xpresence.srf",     "Content-Type: xon/1\r\n", 21 },
    { XONLINE_PRESENCE_SERVICE, "/xpnfront/xnotification.srf",  "Content-Type: xon/1\r\n", 21 }
};

enum SERVER_TYPE
{
    serverPresence = 0,
    serverNotification
};

//
// Description tag appended to HELLO message.  Used by operations to track
// version numbers of requests.
//
// BUGBUG: Should consider building this dynamically with version number
//
#define SZ_HELLO_DESCRIPTION "XONM4"

//
// POST response buffer sizes.  Small size is used for simple (like friend request) POSTs.
// Large size is used for complex (like ALIVE and SYNC) POSTs.
//
#define DW_SMALL_RECEIVE_BUFFER 256
#define DW_LARGE_RECEIVE_BUFFER 2048

//
// Timeout for POST requests.  After 30 seconds, requests will timeout with a failure.
//
#define DW_POST_TIMEOUT         30000

//
// Timeout for game invite retrieval from hard drive.
// Number of minutes * Number of seconds per minute * number of 100-nanoseconds per second (10000000)
//
#define DW_GAMEINVITE_TIMEOUT   9000000000
//
// Enumeration of all types of requests.  Helps in Continue() function to determine how to handle
// responses.
//
enum XPRESENCE_REQUESTTYPE
{
    NotificationEnumerate = 0,             // Enumeration of notifications
    NotificationSetUserData,               // Set UserData
    PresenceAlive,                         // Alive request
    FriendsGeneral,                        // General type for all other friend requests
    FriendsSync,                           // Sync request
    FriendsPresenceUpdate,                 // Friends LIST request from Presence queue
    FriendsListUpdate,                     // Friends LIST request from List Change queue
    FriendsGameInviteUpdate,               // Friends LIST request from Game Invite queue
    FriendsGameInviteAnswerUpdate,         // Friends LIST request from Game Invite Answer queue
    FriendsEnumerateNop,                   // Friends enumeration with no notifications currently pending
    LockoutlistGeneral                     // General type for all lockoutlist requests
};

enum XPRESENCE_CACHESTATE
{
    CacheDone = 0,
    CacheOpening,
    CacheWriting,
    CacheClosing,
    CacheDeleting,
    CacheReading
};

struct XPRESENCE_GAMEINVITE_RECORD
{
    BYTE           index;
    ULONGLONG      qwUserID;
    XONLINE_FRIEND InvitingFriend;
    FILETIME       FileTime;
};

//
// Double Linked List of XRL Upload handles and response buffers.  Every presence and friend list task handle
// has one of these lists.  During a work pump, one entry in this handle list is pumped and the pointer is set
// to the next one in the list.  The only task handle that will ever have more than one entry in this handle
// list is the general friend operation handle (from FriendsStartup()).
//
typedef struct _XPRESENCE_HANDLE_LIST
{
    XONLINETASK_HANDLE hTask;
    PBYTE pBuffer;
    _XPRESENCE_HANDLE_LIST *pPrev;
    _XPRESENCE_HANDLE_LIST *pNext;
} XPRESENCE_HANDLE_LIST, *PXPRESENCE_HANDLE_LIST;

//
// Linked list of friend request errors.  Friend errors are returned as notifications.  We store them in
// this linked list until the client can retrieve them with the FriendsGetResults() function.
//
typedef struct _XPRESENCE_FRIENDS_ERROR_LIST
{
    DWORD                         dwUserIndex;
    XUID                          xuid;
    HRESULT                       hr;
    _XPRESENCE_FRIENDS_ERROR_LIST *pNext;
} XPRESENCE_FRIENDS_ERROR_LIST, *PXPRESENCE_FRIENDS_ERROR_LIST;

//
// Extended Task Handle structure for friends and presence services.  It stores extra context about the tasks
// as they pertain to friends and presence.
//
struct XPRESENCE_EXTENDED_HANDLE
{
    XONLINETASK_CONTEXT           XPresenceTaskHandle;  // Generic task handle context
    XPRESENCE_REQUESTTYPE         Type;                 // The type of task handle
    BOOL                          fPresenceIndicated;   // TRUE if XONLINE_S_NOTIFICATION_UPTODATE has been returned, FALSE otherwise
#if DBG
    DWORD                         dwSignature;          // Debug only:  signature used for error checking
#endif
    DWORD                         dwUserIndex;          // Index of user associated with this task
    SGADDR                        sgaddr;               // SGADDR of Xbox
    PXPRESENCE_FRIENDS_ERROR_LIST pFriendsErrorList;    // Errors returned from friend requests
    PXPRESENCE_HANDLE_LIST        pHandleList;          // List of XRL Upload task handles
};

//
// Extended Task Handle structure for caching.  It stores extra context about the tasks
// as it pertains to caching.
//
struct XPRESENCE_CACHEEXTENDED_HANDLE
{
    XONLINETASK_CONTEXT  XPresenceTaskHandle;  // Generic task handle context
    HANDLE               hCache;
    XONLINETASK_HANDLE   hTask;
    XPRESENCE_CACHESTATE cachestate;
    XONLC_CONTEXT        context;
    XPRESENCE_GAMEINVITE_RECORD  indexData;
#if DBG
    DWORD                dwSignature;          // Debug only:  signature used for error checking
#endif
};

//
// Debug signature and validation macro for task handle
//
#define XPRESENCE_SIGNATURE                         'XPRE'
#define IsValidXPresenceHandle(TaskHandle)          (((PXPRESENCE_EXTENDED_HANDLE)TaskHandle)->dwSignature == XPRESENCE_SIGNATURE)
#define IsValidXCachePresenceHandle(TaskHandle)     (((PXPRESENCE_CACHEEXTENDED_HANDLE)TaskHandle)->dwSignature == XPRESENCE_SIGNATURE)

HRESULT
CXo::XOnlineFeedbackSend(
            IN DWORD dwUserIndex,
            IN XUID xTargetUser,
            IN XONLINE_FEEDBACK_TYPE FeedbackType,
            IN LPCWSTR lpszNickname,
            IN HANDLE hWorkEvent,
            OUT PXONLINETASK_HANDLE phTask
            )
{
    return XONLINETASK_S_SUCCESS;
}

//---------------------------------------------------------------------------
//
// XOnlineNotificationSetState
//
// Public API.
//
// Set the state of the user.  Calls into CS client code which will send
// the new state information up to the CS during the next heartbeat.
//
BOOL
CXo::XOnlineNotificationSetState(
    IN DWORD dwUserIndex,
    IN DWORD dwStateFlags,
    IN XNKID sessionID,
    IN DWORD cbStateData,
    IN PBYTE pStateData
    )
{
    XoEnter_("XOnlineNotificationSetState", FALSE);
    XoCheck_((dwUserIndex < XONLINE_MAX_LOGON_USERS), FALSE);
    XoCheck_(IsValidStateFlags(dwStateFlags), FALSE);
    XoCheck_(cbStateData <= MAX_STATEDATA_SIZE && ((cbStateData == 0) == (pStateData == NULL)), FALSE);
    XoCheck_(!XOnlineIsUserGuest(m_rgLogonUsers[dwUserIndex].xuid.dwUserFlags), FALSE);

    //
    // Add number of guest users to state flags
    //
    dwStateFlags &= ~P_STATE_MASK_GUESTS;
    dwStateFlags |= (NumGuests(m_rgLogonUsers[dwUserIndex].xuid.qwUserID) << 5);

    //
    // Set the state.  Currently always returns S_OK
    //
    return(XnLogonSetPState(dwUserIndex, dwStateFlags, &sessionID, cbStateData, pStateData));
}

//---------------------------------------------------------------------------
//
// XOnlineNotificationSetUserData
//
// Public API.
//
// Set the userdata of the user.  This is posted to the presence front door
// directly.
//
HRESULT
CXo::XOnlineNotificationSetUserData(
    IN DWORD dwUserIndex,
    IN DWORD cbUserData,
    IN PBYTE pUserData,
    IN HANDLE hEvent,
    OUT PXONLINETASK_HANDLE phTask
    )
{
    XoEnter("XOnlineNotificationSetUserData");
    XoCheck(dwUserIndex < XONLINE_MAX_LOGON_USERS);
    XoCheck(cbUserData <= MAX_USERDATA_SIZE && ((cbUserData == 0) == (pUserData == NULL)));

    HRESULT                    hr              = S_OK;
    P_NICKNAME_MSG             *pMsg           = NULL;
    PBYTE                      pbMsgBuffer     = NULL;
    UINT                       cbMsgBuffer     = 0;
    PXPRESENCE_EXTENDED_HANDLE pExtendedHandle = (PXPRESENCE_EXTENDED_HANDLE) phTask;

    //
    // If the ALIVE message has not been sent (ie. XOnlineLogon has not been called yet), then we
    // store the userdata in a global and send it up with the ALIVE message.  Otherwise (the ALIVE
    // has already been sent), we send the userdata directly to the presence front door.
    //
    if (m_fAliveDone == FALSE)
    {
        XoCheck(phTask == NULL);
        XoCheck(hEvent == NULL);

        //
        // If they specified a UserData, create the buffer and copy the userdata
        // into it.
        //
        if (cbUserData != 0)
        {
            m_Users[dwUserIndex].pbUserData = (PBYTE) SysAlloc(cbUserData, PTAG_XONLINE_USERDATA);

            if (m_Users[dwUserIndex].pbUserData == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Error;
            }

            m_Users[dwUserIndex].cbUserData = (WORD) cbUserData;
            memcpy(m_Users[dwUserIndex].pbUserData, pUserData, cbUserData);
        }
    }
    else // The ALIVE message has already been sent
    {
        XoCheck(phTask != NULL);
        XoCheck(!XOnlineIsUserGuest(m_rgLogonUsers[dwUserIndex].xuid.dwUserFlags));

        //
        // Create a task handle to return to the client
        //
        *phTask = NULL;

        hr = CreateContext( &pExtendedHandle, hEvent, NotificationSetUserData, dwUserIndex );

        if (SUCCEEDED(hr))
        {
            //
            // Create and send the UserData message
            //
            hr = CreateMsg(PMSG_NICKNAME, sizeof(P_NICKNAME_MSG) + cbUserData, pExtendedHandle, serverPresence, &pbMsgBuffer, &cbMsgBuffer, (PBYTE *) &pMsg, NULL);

            if (FAILED(hr))
            {
                goto Error;
            }

            pMsg->qwUserID  = m_Users[dwUserIndex].qwUserID;
            pMsg->cbNickname = (WORD) cbUserData;
            memcpy(((PBYTE)pMsg)+sizeof(P_NICKNAME_MSG), pUserData, cbUserData);

            hr = SendMsg(pbMsgBuffer, cbMsgBuffer, DW_SMALL_RECEIVE_BUFFER, pExtendedHandle, serverPresence);

            *phTask = (XONLINETASK_HANDLE) pExtendedHandle;
        }
    }

  Error:

    return(XoLeave(hr));
}


//---------------------------------------------------------------------------
//
// XOnlineNotificationIsPending
//
// Public API.
//
// Check if a notification queue has pending notifications.
//
BOOL
CXo::XOnlineNotificationIsPending(
    IN DWORD dwUserIndex,
    IN DWORD dwType
    )
{
    XoEnter_("XOnlineNotificationIsPending", FALSE);
    XoCheck_(dwUserIndex < XONLINE_MAX_LOGON_USERS, FALSE);
    XoCheck_(IsValidNotificationType(dwType), FALSE);
    XoCheck(!XOnlineIsUserGuest(m_rgLogonUsers[dwUserIndex].xuid.dwUserFlags));

    HRESULT   hr        = S_OK;
    DWORD     dwNQFlags = 0;
    ULONGLONG qwUser    = 0;
    DWORD     dwSeqNum;

    //
    // Call into client CS code to check if a tickle has been received
    //
    if (!XnLogonGetQFlags(dwUserIndex, &qwUser, &dwNQFlags, &dwSeqNum))
    {
        return(FALSE);
    }
    else
    {
        return (!!(dwType & dwNQFlags));
    }
}

//---------------------------------------------------------------------------
//
// XOnlineNotificationEnumerate
//
// 
//
HRESULT
CXo::XOnlineNotificationEnumerate(
    IN DWORD dwUserIndex,
    IN PXONLINE_NOTIFICATION_MSG pbBuffer,
    IN WORD wBufferCount,
    IN DWORD dwNotificationTypes,
    IN HANDLE hEvent,
    OUT PXONLINETASK_HANDLE phTask
    )
{
    XoEnter("XOnlineNotificationEnumerate");
    XoCheck(dwUserIndex < XONLINE_MAX_LOGON_USERS);
    XoCheck(pbBuffer != NULL);
    XoCheck(wBufferCount != 0);
    XoCheck(IsValidNotificationType(dwNotificationTypes));
    XoCheck(phTask != NULL);
    XoCheck(!XOnlineIsUserGuest(m_rgLogonUsers[dwUserIndex].xuid.dwUserFlags));

    HRESULT                    hr              = S_OK;
    PXPRESENCE_EXTENDED_HANDLE pExtendedHandle = (PXPRESENCE_EXTENDED_HANDLE) phTask;

    *phTask = NULL;

    /*
    hr = CreateContext( &pExtendedHandle, hEvent, NotificationEnumerate, dwUserIndex );
    if (FAILED(hr))
    {
        goto Error;
    }

    hr = XOnlineNotificationEnumeratePriv(dwUserIndex, pbBuffer, wBufferCount, dwNotificationTypes, pExtendedHandle);

    *phTask = (XONLINETASK_HANDLE) pExtendedHandle;

  Error:

    return hr;
    */

    return(XoLeave(E_NOTIMPL));
}


//---------------------------------------------------------------------------
//
// NotificationEnumeratePriv
//
// 
//
HRESULT
CXo::NotificationEnumeratePriv(
    IN DWORD dwUserIndex,
    IN PXONLINE_NOTIFICATION_MSG pbBuffer,
    IN WORD wBufferCount,
    IN DWORD dwNotificationTypes,
    IN PXPRESENCE_EXTENDED_HANDLE pExtendedHandle
    )
{
    HRESULT       hr          = S_OK;
    Q_DEQUEUE_MSG *pMsg       = NULL;
    PBYTE         pbMsgBuffer = NULL;
    UINT          cbMsgBuffer = 0;

    hr = CreateMsg(QMSG_DEQUEUE, sizeof(Q_DEQUEUE_MSG), pExtendedHandle, serverNotification, &pbMsgBuffer, &cbMsgBuffer, (PBYTE *) &pMsg, NULL);

    if (FAILED(hr))
    {
        goto Error;
    }

    switch (dwNotificationTypes)
    {
    case XONLINE_NOTIFICATION_TYPE_FRIENDREQUEST:
        pMsg->wQType = PQUEUE_LIST_CHANGE;
        break;
        
    case XONLINE_NOTIFICATION_TYPE_FRIENDSTATUS:
        pMsg->wQType = PQUEUE_PRESENCE;
        break;

    case XONLINE_NOTIFICATION_TYPE_GAMEINVITE:
        pMsg->wQType = PQUEUE_INVITE;
        break;

    case XONLINE_NOTIFICATION_TYPE_GAMEINVITEANSWER:
        pMsg->wQType = PQUEUE_INVITE_ANSWER;
        break;
    }

    pMsg->qwUserID = m_Users[dwUserIndex].qwUserID;
    pMsg->dwStartItemID = 0;
    pMsg->wMaxItems = wBufferCount;
    pMsg->dwMaxTotalItemDataSize = DW_LARGE_RECEIVE_BUFFER;

//@@@ [drm] This needs to be reworked.  Can't change dwQFlags without dwSeqQFlags 
//@@@    XnLogonSetQFlags(dwUserIndex, 0, dwNotificationTypes);

    hr = SendMsg(pbMsgBuffer, cbMsgBuffer, DW_LARGE_RECEIVE_BUFFER, pExtendedHandle, serverNotification);

  Error:

    return hr;
}


//---------------------------------------------------------------------------
//
// NotificationSendAlive
//
// Private API
//
HRESULT
CXo::NotificationSendAlive(
    IN PXONLINE_USER pUsers,
    IN HANDLE hEvent,
    OUT PXONLINETASK_HANDLE phTask
    )
{
    HRESULT                    hr              = S_OK;
    PXPRESENCE_EXTENDED_HANDLE pExtendedHandle = (PXPRESENCE_EXTENDED_HANDLE) phTask;
    P_ALIVE_MSG                *pMsg           = NULL;
    PBYTE                      pbMsgBuffer     = NULL;
    UINT                       cbMsgBuffer     = 0;
    DWORD                      dwSeqNum        = 0;
    DWORD                      i               = 0;

    Assert(pUsers != NULL);
    Assert(phTask != NULL);

    *phTask = NULL;

    m_fAliveDone = TRUE;

    hr = CreateContext( &pExtendedHandle, hEvent, PresenceAlive, 0 );

    if (SUCCEEDED(hr))
    {
        for (i = 0; i < XONLINE_MAX_LOGON_USERS; i += 1)
        {
            if (pUsers[i].xuid.qwUserID != 0 && !XOnlineIsUserGuest(pUsers[i].xuid.dwUserFlags))
            {
                m_Users[i].qwUserID = pUsers[i].xuid.qwUserID;
                RtlZeroMemory(m_Users[i].szUserName, XONLINE_USERNAME_SIZE);
                sprintf(m_Users[i].szUserName, "%s%c%s", pUsers[i].name, KINGDOM_SEPERATOR_CHAR, pUsers[i].kingdom);

                hr = CreateMsg(PMSG_ALIVE, sizeof(P_ALIVE_MSG) + strlen(m_Users[i].szUserName) + 1 + m_Users[i].cbUserData, pExtendedHandle, serverPresence, &pbMsgBuffer, &cbMsgBuffer, (PBYTE *) &pMsg, &dwSeqNum);

                m_Users[i].dwSeqNum = dwSeqNum;

                if (FAILED(hr))
                {
                    goto Error;
                }

                pMsg->qwUserID = m_Users[i].qwUserID;
                pMsg->sgaddr = pExtendedHandle->sgaddr;
                pMsg->dwTitleID = m_dwTitleId;
                pMsg->cbAcctName = strlen(m_Users[i].szUserName) + 1;
                pMsg->dwBuddyListVersion = 0;
                pMsg->dwBlockListVersion = 0;
                pMsg->dwState = P_STATE_MASK_CLOAKED | P_STATE_MASK_ONLINE;
                pMsg->qwMatchSessionID = 0;
                pMsg->cbNickname = m_Users[i].cbUserData;
                pMsg->cbTitleStuff = 0;
                memcpy(((PBYTE)pMsg)+sizeof(P_ALIVE_MSG), m_Users[i].szUserName, strlen(m_Users[i].szUserName) + 1);
                memcpy(((PBYTE)pMsg)+sizeof(P_ALIVE_MSG)+strlen(m_Users[i].szUserName)+1, m_Users[i].pbUserData, m_Users[i].cbUserData);

                hr = SendMsg(pbMsgBuffer, cbMsgBuffer, DW_LARGE_RECEIVE_BUFFER, pExtendedHandle, serverPresence);
            }
        }

        *phTask = (XONLINETASK_HANDLE) pExtendedHandle;
    }

  Error:

    return hr;
}


//---------------------------------------------------------------------------
//
// XOnlineFriendsStartup
//
// 
//
HRESULT
CXo::XOnlineFriendsStartup(
    IN HANDLE hEvent,
    OUT PXONLINETASK_HANDLE phTask
    )
{
    XoEnter("XOnlineFriendsStartup");
    XoCheck(phTask != NULL);

    HRESULT hr = S_OK;

    m_precordGameInvite = (PXPRESENCE_GAMEINVITE_RECORD) SysAllocZ(sizeof(XPRESENCE_GAMEINVITE_RECORD), PTAG_XPRESENCE_GAMEINVITE_RECORD);
    if (m_precordGameInvite == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    m_hCacheGameInvite     = NULL;
    m_hTaskGameInvite      = NULL;
    m_cachestateGameInvite = CacheDone;
    m_fGameInvite          = FALSE;

    *phTask = NULL;

    hr = CreateContext( &m_pFriendsHandle, hEvent, FriendsGeneral, 0 );

    if (SUCCEEDED(hr))
    {
        *phTask = (XONLINETASK_HANDLE) m_pFriendsHandle;
    }

  Error:

    return(XoLeave(hr));
}


//---------------------------------------------------------------------------
//
// FriendsGetResults
//
// 
//
HRESULT
CXo::XOnlineFriendsGetResults(
    OUT DWORD *pdwUserIndex,
    OUT XUID *pxuidTargetUser
    )
{
    XoEnter("XOnlineFriendsGetResults");
    XoCheck(pdwUserIndex != NULL);
    XoCheck(pxuidTargetUser != NULL);

    HRESULT                       hr     = S_OK;
    PXPRESENCE_FRIENDS_ERROR_LIST pError = NULL;

    if (m_pFriendsHandle->pFriendsErrorList != NULL)
    {
        hr = m_pFriendsHandle->pFriendsErrorList->hr;
        *pdwUserIndex = m_pFriendsHandle->pFriendsErrorList->dwUserIndex;
        *pxuidTargetUser = m_pFriendsHandle->pFriendsErrorList->xuid;

        pError = m_pFriendsHandle->pFriendsErrorList;
        m_pFriendsHandle->pFriendsErrorList = m_pFriendsHandle->pFriendsErrorList->pNext;
        SysFree(pError);
    }

    return(XoLeave(hr));
}


//---------------------------------------------------------------------------
//
// XOnlineFriendsEnumerate
//
// 
//
HRESULT
CXo::XOnlineFriendsEnumerate(
    IN DWORD dwUserIndex,
    IN HANDLE hEvent,
    OUT PXONLINETASK_HANDLE phTask
    )
{
    XoEnter("XOnlineFriendsEnumerate");
    XoCheck(dwUserIndex < XONLINE_MAX_LOGON_USERS);
    XoCheck(phTask != NULL);
    XoCheck(!XOnlineIsUserGuest(m_rgLogonUsers[dwUserIndex].xuid.dwUserFlags));

    HRESULT                    hr              = S_OK;
    PXPRESENCE_EXTENDED_HANDLE pExtendedHandle = (PXPRESENCE_EXTENDED_HANDLE) phTask;

    *phTask = NULL;

    hr = CreateContext( &pExtendedHandle, hEvent, FriendsSync, dwUserIndex );

    if (SUCCEEDED(hr))
    {
        pExtendedHandle->fPresenceIndicated = FALSE;

        *phTask = (XONLINETASK_HANDLE) pExtendedHandle;
    }

    return(XoLeave(hr));
}


//---------------------------------------------------------------------------
//
// XOnlineFriendsGetLatest
//
// 
//
DWORD
CXo::XOnlineFriendsGetLatest(
    IN DWORD dwUserIndex,
    IN DWORD dwFriendBufferCount,
    OUT PXONLINE_FRIEND pFriendBuffer
    )
{
    XoEnter_("XOnlineFriendsGetLatest", 0);
    XoCheck_(dwUserIndex < XONLINE_MAX_LOGON_USERS, 0);
    XoCheck_(dwFriendBufferCount == MAX_FRIENDS, 0);
    XoCheck_(pFriendBuffer != NULL, 0);
    XoCheck(!XOnlineIsUserGuest(m_rgLogonUsers[dwUserIndex].xuid.dwUserFlags));

    memcpy( pFriendBuffer, m_Users[dwUserIndex].FriendList, dwFriendBufferCount * sizeof(XONLINE_FRIEND));

    return(m_Users[dwUserIndex].cNumFriends);
}


//---------------------------------------------------------------------------
//
// XOnlineFriendsRemove
//
// 
//
HRESULT
CXo::XOnlineFriendsRemove(
    IN DWORD dwUserIndex,
    IN PXONLINE_FRIEND pFriend
    )
{
    XoEnter("XOnlineFriendsRemove");
    XoCheck(dwUserIndex < XONLINE_MAX_LOGON_USERS);
    XoCheck(pFriend != NULL);
    XoCheck(pFriend->xuid.qwUserID != 0);
    XoCheck(!XOnlineIsUserGuest(m_rgLogonUsers[dwUserIndex].xuid.dwUserFlags));

    HRESULT      hr          = S_OK;
    P_DELETE_MSG *pMsg       = NULL;
    PBYTE        pbMsgBuffer = NULL;
    UINT         cbMsgBuffer = 0;

    hr = CreateMsg(PMSG_DELETE, sizeof(P_DELETE_MSG), m_pFriendsHandle, serverPresence, &pbMsgBuffer, &cbMsgBuffer, (PBYTE *) &pMsg, NULL);

    if (FAILED(hr))
    {
        goto Error;
    }

    pMsg->qwUserID  = m_Users[dwUserIndex].qwUserID;
    pMsg->qwBuddyID = pFriend->xuid.qwUserID;

    hr = SendMsg(pbMsgBuffer, cbMsgBuffer, DW_SMALL_RECEIVE_BUFFER, m_pFriendsHandle, serverPresence);

  Error:

    return(XoLeave(hr));
}


//---------------------------------------------------------------------------
//
// XOnlineFriendsRequest
//
// 
//
HRESULT
CXo::XOnlineFriendsRequest(
    IN DWORD dwUserIndex,
    IN XUID xuidToUser
    )
{
    XoEnter("XOnlineFriendsRequest");
    XoCheck(dwUserIndex < XONLINE_MAX_LOGON_USERS);
    XoCheck(xuidToUser.qwUserID != 0);
    XoCheck(!XOnlineIsUserGuest(m_rgLogonUsers[dwUserIndex].xuid.dwUserFlags));

    HRESULT   hr          = S_OK;
    P_ADD_MSG *pMsg       = NULL;
    PBYTE     pbMsgBuffer = NULL;
    UINT      cbMsgBuffer = 0;

    hr = CreateMsg(PMSG_ADD, sizeof(P_ADD_MSG), m_pFriendsHandle, serverPresence, &pbMsgBuffer, &cbMsgBuffer, (PBYTE *) &pMsg, NULL);

    if (FAILED(hr))
    {
        goto Error;
    }

    pMsg->qwSenderID = m_Users[dwUserIndex].qwUserID;
    pMsg->qwBuddyID = xuidToUser.qwUserID;
    pMsg->cbBuddyAcctname = 0;

    hr = SendMsg(pbMsgBuffer, cbMsgBuffer, DW_SMALL_RECEIVE_BUFFER, m_pFriendsHandle, serverPresence);

  Error:

    return(XoLeave(hr));
}


//---------------------------------------------------------------------------
//
// XOnlineFriendsRequestByName
//
// 
//
HRESULT
CXo::XOnlineFriendsRequestByName(
    IN DWORD dwUserIndex,
    IN PSTR pszUserName
    )
{
    XoEnter("XOnlineFriendsRequestByName");
    XoCheck(dwUserIndex < XONLINE_MAX_LOGON_USERS);
    XoCheck(pszUserName != NULL);
    XoCheck(!XOnlineIsUserGuest(m_rgLogonUsers[dwUserIndex].xuid.dwUserFlags));

    HRESULT   hr          = S_OK;
    P_ADD_MSG *pMsg       = NULL;
    PBYTE     pbMsgBuffer = NULL;
    UINT      cbMsgBuffer = 0;

    hr = CreateMsg(PMSG_ADD, sizeof(P_ADD_MSG) + strlen(pszUserName), m_pFriendsHandle, serverPresence, &pbMsgBuffer, &cbMsgBuffer, (PBYTE *) &pMsg, NULL);

    if (FAILED(hr))
    {
        goto Error;
    }

    pMsg->qwSenderID = m_Users[dwUserIndex].qwUserID;
    pMsg->qwBuddyID = 0;
    pMsg->cbBuddyAcctname = (WORD) strlen(pszUserName);
    memcpy(((PBYTE)pMsg)+sizeof(P_ADD_MSG), pszUserName, strlen(pszUserName));

    hr = SendMsg(pbMsgBuffer, cbMsgBuffer, DW_SMALL_RECEIVE_BUFFER, m_pFriendsHandle, serverPresence);

  Error:

    return(XoLeave(hr));
}


//---------------------------------------------------------------------------
//
// XOnlineFriendsGameInvite
//
// 
//
HRESULT
CXo::XOnlineFriendsGameInvite(
    IN DWORD dwUserIndex,
    IN XNKID SessionID,
    IN DWORD dwFriendListCount,
    IN PXONLINE_FRIEND pToFriendList
    )
{
    XoEnter("XOnlineFriendsGameInvite");
    XoCheck(dwUserIndex < XONLINE_MAX_LOGON_USERS);
    XoCheck(dwFriendListCount > 0);
    XoCheck(pToFriendList != NULL);
    XoCheck(!XOnlineIsUserGuest(m_rgLogonUsers[dwUserIndex].xuid.dwUserFlags));

    HRESULT      hr          = S_OK;
    P_INVITE_MSG *pMsg       = NULL;
    PBYTE        pbMsgBuffer = NULL;
    UINT         cbMsgBuffer = 0;
    DWORD        i           = 0;
    ULONGLONG    *pqwUserID  = NULL;

    hr = CreateMsg(PMSG_INVITE, sizeof(P_INVITE_MSG) + (dwFriendListCount * sizeof(ULONGLONG)), m_pFriendsHandle, serverPresence, &pbMsgBuffer, &cbMsgBuffer, (PBYTE *) &pMsg, NULL);

    if (FAILED(hr))
    {
        goto Error;
    }

    pMsg->qwUserID = m_Users[dwUserIndex].qwUserID;
    pMsg->dwTitleID = m_dwTitleId;
    pMsg->qwMatchSessionID = *((ULONGLONG *)(&SessionID));
    pMsg->cInvitees = (WORD) dwFriendListCount;

    pqwUserID = (ULONGLONG *) (((PBYTE)pMsg)+sizeof(P_INVITE_MSG));

    for (i = 0; i < dwFriendListCount; i += 1)
    {
        pqwUserID[i] = pToFriendList[i].xuid.qwUserID;
    }

    hr = SendMsg(pbMsgBuffer, cbMsgBuffer, DW_SMALL_RECEIVE_BUFFER, m_pFriendsHandle, serverPresence);

    if (SUCCEEDED(hr))
    {
        for (i = 0; i < dwFriendListCount; i += 1)
        {
            SetUserFlags(&m_Users[dwUserIndex], pToFriendList[i].xuid.qwUserID, XONLINE_FRIENDSTATE_FLAG_INVITEACCEPTED | XONLINE_FRIENDSTATE_FLAG_INVITEREJECTED, FALSE);
            SetUserFlags(&m_Users[dwUserIndex], pToFriendList[i].xuid.qwUserID, XONLINE_FRIENDSTATE_FLAG_SENTINVITE, TRUE);
        }
    }

  Error:

    return(XoLeave(hr));
}


//---------------------------------------------------------------------------
//
// XOnlineFriendsRevokeGameInvite
//
// 
//
HRESULT
CXo::XOnlineFriendsRevokeGameInvite(
    IN DWORD dwUserIndex,
    IN XNKID SessionID,
    IN DWORD dwFriendListCount,
    IN PXONLINE_FRIEND pToFriendList
    )
{
    XoEnter("XOnlineFriendsRevokeGameInvite");
    XoCheck(dwUserIndex < XONLINE_MAX_LOGON_USERS);
    XoCheck((dwFriendListCount == 0) == (pToFriendList == NULL));
    XoCheck(!XOnlineIsUserGuest(m_rgLogonUsers[dwUserIndex].xuid.dwUserFlags));

    HRESULT      hr          = S_OK;
    P_CANCEL_MSG *pMsg       = NULL;
    PBYTE        pbMsgBuffer = NULL;
    UINT         cbMsgBuffer = 0;
    DWORD        i           = 0;
    ULONGLONG    *pqwUserID  = NULL;

    hr = CreateMsg(PMSG_CANCEL, sizeof(P_CANCEL_MSG) + (dwFriendListCount * sizeof(ULONGLONG)), m_pFriendsHandle, serverPresence, &pbMsgBuffer, &cbMsgBuffer, (PBYTE *) &pMsg, NULL);

    if (FAILED(hr))
    {
        goto Error;
    }

    pMsg->qwUserID = m_Users[dwUserIndex].qwUserID;
    pMsg->qwMatchSessionID = *((ULONGLONG *)(&SessionID));
    pMsg->cInvitees = (WORD) dwFriendListCount;

    pqwUserID = (ULONGLONG *) (((PBYTE)pMsg)+sizeof(P_CANCEL_MSG));

    for (i = 0; i < dwFriendListCount; i += 1)
    {
        pqwUserID[i] = pToFriendList[i].xuid.qwUserID;
    }

    hr = SendMsg(pbMsgBuffer, cbMsgBuffer, DW_SMALL_RECEIVE_BUFFER, m_pFriendsHandle, serverPresence);

    if (SUCCEEDED(hr))
    {
        for (i = 0; i < dwFriendListCount; i += 1)
        {
            SetUserFlags(&m_Users[dwUserIndex], pToFriendList[i].xuid.qwUserID, XONLINE_FRIENDSTATE_FLAG_SENTINVITE | XONLINE_FRIENDSTATE_FLAG_INVITEACCEPTED | XONLINE_FRIENDSTATE_FLAG_INVITEREJECTED, FALSE);
        }
    }

  Error:

    return(XoLeave(hr));
}


//---------------------------------------------------------------------------
//
// XOnlineFriendsAnswerRequest
//
// 
//
HRESULT
CXo::XOnlineFriendsAnswerRequest(
    IN DWORD dwUserIndex,
    IN PXONLINE_FRIEND pToFriend,
    IN XONLINE_REQUEST_ANSWER_TYPE Answer
    )
{
    XoEnter("XOnlineFriendsAnswerRequest");
    XoCheck(dwUserIndex < XONLINE_MAX_LOGON_USERS);
    XoCheck(pToFriend != NULL);
    XoCheck(Answer == XONLINE_REQUEST_YES || Answer == XONLINE_REQUEST_NO || Answer == XONLINE_REQUEST_BLOCK);
    XoCheck(!XOnlineIsUserGuest(m_rgLogonUsers[dwUserIndex].xuid.dwUserFlags));

    HRESULT      hr          = S_OK;
    P_ACCEPT_MSG *pAcceptMsg = NULL;
    P_REJECT_MSG *pRejectMsg = NULL;
    PBYTE        pbMsgBuffer = NULL;
    UINT         cbMsgBuffer = 0;

    switch (Answer)
    {
    case XONLINE_REQUEST_YES:
    {
        hr = CreateMsg(PMSG_ACCEPT, sizeof(P_ACCEPT_MSG), m_pFriendsHandle, serverPresence, &pbMsgBuffer, &cbMsgBuffer, (PBYTE *) &pAcceptMsg, NULL);

        if (FAILED(hr))
        {
            goto Error;
        }

        pAcceptMsg->qwUserID  = m_Users[dwUserIndex].qwUserID;
        pAcceptMsg->qwBuddyID = pToFriend->xuid.qwUserID;

        break;
    }
    case XONLINE_REQUEST_NO:
    case XONLINE_REQUEST_BLOCK:
    {
        hr = CreateMsg(PMSG_REJECT, sizeof(P_REJECT_MSG), m_pFriendsHandle, serverPresence, &pbMsgBuffer, &cbMsgBuffer, (PBYTE *) &pRejectMsg, NULL);

        if (FAILED(hr))
        {
            goto Error;
        }

        pRejectMsg->qwUserID  = m_Users[dwUserIndex].qwUserID;
        pRejectMsg->qwBuddyID = pToFriend->xuid.qwUserID;
        pRejectMsg->fNever = FALSE;

        break;
    }
    }
    
    if (Answer == XONLINE_REQUEST_BLOCK)
    {
        pRejectMsg->fNever = TRUE;
    }

    hr = SendMsg(pbMsgBuffer, cbMsgBuffer, DW_SMALL_RECEIVE_BUFFER, m_pFriendsHandle, serverPresence);

  Error:

    return(XoLeave(hr));
}


//---------------------------------------------------------------------------
//
// XOnlineFriendsAnswerGameInvite
//
// 
//
HRESULT
CXo::XOnlineFriendsAnswerGameInvite(
    IN DWORD dwUserIndex,
    IN PXONLINE_FRIEND pToFriend,
    IN XONLINE_GAMEINVITE_ANSWER_TYPE Answer
    )
{
    XoEnter("XOnlineFriendsAnswerGameInvite");
    XoCheck(dwUserIndex < XONLINE_MAX_LOGON_USERS);
    XoCheck(pToFriend != NULL);
    XoCheck(Answer == XONLINE_GAMEINVITE_NO || Answer == XONLINE_GAMEINVITE_YES || Answer == XONLINE_GAMEINVITE_REMOVE);
    XoCheck(!XOnlineIsUserGuest(m_rgLogonUsers[dwUserIndex].xuid.dwUserFlags));

    HRESULT             hr          = S_OK;
    P_INVITE_ANSWER_MSG *pMsg       = NULL;
    P_DELETE_MSG        *pMsgDel    = NULL;
    PBYTE               pbMsgBuffer = NULL;
    UINT                cbMsgBuffer = 0;

    if (Answer == XONLINE_GAMEINVITE_REMOVE)
    {
        hr = CreateMsg(PMSG_DELETE, sizeof(P_DELETE_MSG), m_pFriendsHandle, serverPresence, &pbMsgBuffer, &cbMsgBuffer, (PBYTE *) &pMsgDel, NULL);

        if (FAILED(hr))
        {
            goto Error;
        }

        pMsgDel->qwUserID  = m_Users[dwUserIndex].qwUserID;
        pMsgDel->qwBuddyID = pToFriend->xuid.qwUserID;

        hr = SendMsg(pbMsgBuffer, cbMsgBuffer, DW_SMALL_RECEIVE_BUFFER, m_pFriendsHandle, serverPresence);
    }
    else
    {
        hr = CreateMsg(PMSG_INVITE_ANSWER, sizeof(P_INVITE_ANSWER_MSG), m_pFriendsHandle, serverPresence, &pbMsgBuffer, &cbMsgBuffer, (PBYTE *) &pMsg, NULL);

        if (FAILED(hr))
        {
            goto Error;
        }

        pMsg->qwUserID = m_Users[dwUserIndex].qwUserID;
        pMsg->qwHostID = pToFriend->xuid.qwUserID;
        pMsg->qwMatchSessionID = *((ULONGLONG *)&(pToFriend->sessionID));

        if (Answer == XONLINE_GAMEINVITE_NO)
        {
            pMsg->wAnswer = PINVITE_REPLY_NO;
            SetUserFlags(&m_Users[dwUserIndex], pToFriend->xuid.qwUserID, XONLINE_FRIENDSTATE_FLAG_RECEIVEDINVITE, FALSE);
        }
        else if (Answer == XONLINE_GAMEINVITE_YES)
        {
            pMsg->wAnswer = PINVITE_REPLY_YES;

            if ( pToFriend->titleID != m_dwTitleId )
            {
                m_precordGameInvite->index = 1;
                m_precordGameInvite->qwUserID = m_Users[dwUserIndex].qwUserID;
                memcpy(&(m_precordGameInvite->InvitingFriend), pToFriend, sizeof(XONLINE_FRIEND));
                GetSystemTimeAsFileTime( &(m_precordGameInvite->FileTime));
                m_fGameInvite = TRUE;
            }

            SetUserFlags(&m_Users[dwUserIndex], pToFriend->xuid.qwUserID, XONLINE_FRIENDSTATE_FLAG_SENTINVITE | XONLINE_FRIENDSTATE_FLAG_INVITEACCEPTED | XONLINE_FRIENDSTATE_FLAG_INVITEREJECTED | XONLINE_FRIENDSTATE_FLAG_RECEIVEDINVITE, FALSE);
        }

        hr = SendMsg(pbMsgBuffer, cbMsgBuffer, DW_SMALL_RECEIVE_BUFFER, m_pFriendsHandle, serverPresence);
    }

  Error:

    return(XoLeave(hr));
}


//---------------------------------------------------------------------------
//
// XOnlineFriendsGetAcceptedGameInvite()
//
HRESULT
CXo::XOnlineFriendsGetAcceptedGameInvite(
    IN HANDLE hEvent,
    OUT PXONLINETASK_HANDLE phTask
    )
{
    XoEnter("XOnlineFriendsGetAcceptedGameInvite");
    XoCheck(phTask != NULL);

    HRESULT                         hr              = S_OK;
    PXPRESENCE_CACHEEXTENDED_HANDLE pExtendedHandle = NULL;

    //
    // Create a task handle to return to the client
    //
    *phTask = NULL;

    pExtendedHandle = (PXPRESENCE_CACHEEXTENDED_HANDLE) SysAllocZ(sizeof(XPRESENCE_CACHEEXTENDED_HANDLE), PTAG_XPRESENCE_EXTENDED_HANDLE);
    if (pExtendedHandle == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    TaskInitializeContext(&(pExtendedHandle->XPresenceTaskHandle));
    pExtendedHandle->XPresenceTaskHandle.pfnContinue = GameInviteContinue;
    pExtendedHandle->XPresenceTaskHandle.pfnClose = GameInviteClose;
    pExtendedHandle->XPresenceTaskHandle.hEventWorkAvailable = hEvent;

#if DBG
    pExtendedHandle->dwSignature = XPRESENCE_SIGNATURE;
#endif

    pExtendedHandle->cachestate = CacheOpening;
    pExtendedHandle->indexData.index = 1;

    hr = CacheOpen(XONLC_TYPE_GAMEINVITE, NULL, hEvent, &(pExtendedHandle->hCache), &(pExtendedHandle->hTask));
    if(FAILED(hr))
    {
        goto Error;
    }

    *phTask = (XONLINETASK_HANDLE) pExtendedHandle;

Cleanup:
    return(XoLeave(hr));

Error:

    if (pExtendedHandle != NULL)
    {
        SysFree(pExtendedHandle);
    }

    goto Cleanup;
}


//---------------------------------------------------------------------------
//
// XOnlineFriendsGetAcceptedGameInviteResult()
//
HRESULT
CXo::XOnlineFriendsGetAcceptedGameInviteResult(
    IN XONLINETASK_HANDLE hTask,
    OUT PXONLINE_ACCEPTED_GAMEINVITE pAcceptedGameInvite
    )
{
    XoEnter("XOnlineFriendsGetAcceptedGameInviteResult");
    XoCheck(pAcceptedGameInvite != NULL);
    XoCheck(IsValidXCachePresenceHandle(hTask));

    HRESULT                         hr              = S_OK;
    PXPRESENCE_CACHEEXTENDED_HANDLE pExtendedHandle = (PXPRESENCE_CACHEEXTENDED_HANDLE) hTask;
    PXPRESENCE_GAMEINVITE_RECORD    pGameInvite = NULL;
    FILETIME                        CurrentTime;

    if (pExtendedHandle->context.bValidDataInCache)
    {
        pGameInvite = (PXPRESENCE_GAMEINVITE_RECORD)(pExtendedHandle->context.pbIndexData);

        GetSystemTimeAsFileTime(&CurrentTime);

        if ((CurrentTime.dwLowDateTime - pGameInvite->FileTime.dwLowDateTime) < DW_GAMEINVITE_TIMEOUT && pGameInvite->InvitingFriend.titleID == m_dwTitleId)
        {
            memcpy( &pAcceptedGameInvite->InvitingFriend, &pGameInvite->InvitingFriend, sizeof(XONLINE_FRIEND));
            pAcceptedGameInvite->xuidAcceptedFriend.qwUserID = pGameInvite->qwUserID;
            memcpy( &pAcceptedGameInvite->InviteAcceptTime, &pGameInvite->FileTime, sizeof(FILETIME));
        }
        else
        {
            hr = S_FALSE;
        }
    }
    else
    {
        hr = S_FALSE;
    }

    return(XoLeave(hr));
}

//---------------------------------------------------------------------------
//
// XOnlineLockoutlistGet
//
// 
//
DWORD
CXo::XOnlineLockoutlistGet(
    IN DWORD dwUserIndex,
    IN DWORD dwLockoutUserBufferCount,
    OUT PXONLINE_LOCKOUTUSER pLockoutUserBuffer
    )
{
    XoEnter_("XOnlineLockoutlistGet", 0);
    XoCheck_(dwUserIndex < XONLINE_MAX_LOGON_USERS, 0);
    XoCheck_(dwLockoutUserBufferCount == MAX_LOCKOUTUSERS, 0);
    XoCheck_(pLockoutUserBuffer != NULL, 0);
    XoCheck(!XOnlineIsUserGuest(m_rgLogonUsers[dwUserIndex].xuid.dwUserFlags));

    memcpy( pLockoutUserBuffer, m_Users[dwUserIndex].LockoutList, dwLockoutUserBufferCount * sizeof(XONLINE_LOCKOUTUSER));

    return(m_Users[dwUserIndex].cNumLockoutUsers);
}


//---------------------------------------------------------------------------
//
// XOnlineLockoutlistStartup
//
// 
//
HRESULT
CXo::XOnlineLockoutlistStartup(
    IN HANDLE hEvent,
    OUT PXONLINETASK_HANDLE phTask
    )
{
    XoEnter("XOnlineLockoutlistStartup");
    XoCheck(phTask != NULL);

    HRESULT hr = S_OK;

    *phTask = NULL;

    hr = CreateContext( &m_pLockoutlistHandle, hEvent, LockoutlistGeneral, 0 );

    if (SUCCEEDED(hr))
    {
        *phTask = (XONLINETASK_HANDLE) m_pLockoutlistHandle;
    }

    return(XoLeave(hr));
}


//---------------------------------------------------------------------------
//
// XOnlineLockoutlistAdd
//
// 
//
HRESULT
CXo::XOnlineLockoutlistAdd(
    IN DWORD dwUserIndex,
    IN XUID xUserID,
    IN CHAR *pszUsername
    )
{
    XoEnter("XOnlineLockoutlistAdd");
    XoCheck(dwUserIndex < XONLINE_MAX_LOGON_USERS);
    XoCheck(xUserID.qwUserID != 0);
    XoCheck(pszUsername != NULL);
    XoCheck(!XOnlineIsUserGuest(m_rgLogonUsers[dwUserIndex].xuid.dwUserFlags));

    HRESULT     hr          = S_OK;
    P_BLOCK_MSG *pMsg       = NULL;
    PBYTE       pbMsgBuffer = NULL;
    UINT        cbMsgBuffer = 0;

    hr = CreateMsg(PMSG_BLOCK, sizeof(P_BLOCK_MSG), m_pLockoutlistHandle, serverPresence, &pbMsgBuffer, &cbMsgBuffer, (PBYTE *) &pMsg, NULL);

    if (FAILED(hr))
    {
        goto Error;
    }

    pMsg->qwUserID  = m_Users[dwUserIndex].qwUserID;
    pMsg->qwBlockID = xUserID.qwUserID;

    AddLockoutUser(&m_Users[dwUserIndex], xUserID.qwUserID, pszUsername);

    hr = SendMsg(pbMsgBuffer, cbMsgBuffer, DW_SMALL_RECEIVE_BUFFER, m_pLockoutlistHandle, serverPresence);

  Error:

    return(XoLeave(hr));
}


//---------------------------------------------------------------------------
//
// XOnlineLockoutlistRemove
//
// 
//
HRESULT
CXo::XOnlineLockoutlistRemove(
    IN DWORD dwUserIndex,
    IN XUID xUserID
    )
{
    XoEnter("XOnlineLockoutlistRemove");
    XoCheck(dwUserIndex < XONLINE_MAX_LOGON_USERS);
    XoCheck(xUserID.qwUserID != 0);
    XoCheck(!XOnlineIsUserGuest(m_rgLogonUsers[dwUserIndex].xuid.dwUserFlags));

    HRESULT       hr          = S_OK;
    P_UNBLOCK_MSG *pMsg       = NULL;
    PBYTE         pbMsgBuffer = NULL;
    UINT        cbMsgBuffer = 0;

    hr = CreateMsg(PMSG_UNBLOCK, sizeof(P_UNBLOCK_MSG), m_pLockoutlistHandle, serverPresence, &pbMsgBuffer, &cbMsgBuffer, (PBYTE *) &pMsg, NULL);

    if (FAILED(hr))
    {
        goto Error;
    }

    pMsg->qwUserID  = m_Users[dwUserIndex].qwUserID;
    pMsg->qwBlockID = xUserID.qwUserID;

    RemoveLockoutUser(&m_Users[dwUserIndex], xUserID.qwUserID);

    hr = SendMsg(pbMsgBuffer, cbMsgBuffer, DW_SMALL_RECEIVE_BUFFER, m_pLockoutlistHandle, serverPresence);

  Error:

    return(XoLeave(hr));
}


//---------------------------------------------------------------------------
//
// CreateContext
//
HRESULT
CXo::CreateContext(
    OUT PXPRESENCE_EXTENDED_HANDLE *ppExtendedHandle,
    IN  HANDLE                  hEvent,
    IN  XPRESENCE_REQUESTTYPE   Type,
    IN  DWORD                   dwUserIndex
    )
{
    HRESULT hr = S_OK;
    
    (*ppExtendedHandle) = (PXPRESENCE_EXTENDED_HANDLE) SysAllocZ(sizeof(XPRESENCE_EXTENDED_HANDLE),
        PTAG_XPRESENCE_EXTENDED_HANDLE);
    if ((*ppExtendedHandle) == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    TaskInitializeContext(&((*ppExtendedHandle)->XPresenceTaskHandle));
    (*ppExtendedHandle)->XPresenceTaskHandle.pfnClose = PresenceClose;
    (*ppExtendedHandle)->XPresenceTaskHandle.hEventWorkAvailable = hEvent;

    switch (Type)
    {
        case NotificationEnumerate:
        case NotificationSetUserData:
        case PresenceAlive:
            (*ppExtendedHandle)->XPresenceTaskHandle.pfnContinue = NotificationContinue;
            break;

        case FriendsGeneral:
        case LockoutlistGeneral:
            (*ppExtendedHandle)->XPresenceTaskHandle.pfnContinue = FriendsContinue;
            break;

        case FriendsSync:
        case FriendsPresenceUpdate:
        case FriendsListUpdate:
        case FriendsGameInviteUpdate:
        case FriendsGameInviteAnswerUpdate:
        case FriendsEnumerateNop:
            (*ppExtendedHandle)->XPresenceTaskHandle.pfnContinue = FriendsEnumerateContinue;
            break;
    }

    XnLogonGetStatus(&(*ppExtendedHandle)->sgaddr);

    (*ppExtendedHandle)->Type              = Type;
    (*ppExtendedHandle)->dwUserIndex       = dwUserIndex;
    (*ppExtendedHandle)->pFriendsErrorList = NULL;
    (*ppExtendedHandle)->pHandleList       = NULL;
#if DBG
    (*ppExtendedHandle)->dwSignature       = XPRESENCE_SIGNATURE;
#endif

Cleanup:
    return hr;

Error:

    if ((*ppExtendedHandle) != NULL)
    {
        SysFree(*ppExtendedHandle);
    }

    goto Cleanup;
}


//---------------------------------------------------------------------------
//
// CreateMsg
//
// 
//
HRESULT
CXo::CreateMsg(
    IN DWORD dwMsgType,
    IN DWORD dwMsgLen,
    IN PXPRESENCE_EXTENDED_HANDLE pExtendedHandle,
    IN SERVER_TYPE Server,
    OUT PBYTE *ppbMsgBuffer,
    OUT UINT  *pcbMsgBuffer,
    OUT PBYTE *ppbMsg,
    OUT DWORD *pdwSeqNum
    )
{
    HRESULT         hr          = S_OK;
    PBYTE           pbMsg       = NULL;
    PBYTE           pbReturnMsg = NULL;
    P_HELLO_MSG     *pPHelloMsg = NULL;
    Q_HELLO_MSG     *pQHelloMsg = NULL;
    BASE_MSG_HEADER *pBaseMsg   = NULL;
    DWORD           dwBufferLen = 0;

    if (Server == serverNotification)
    {
        dwBufferLen = dwMsgLen + sizeof(Q_HELLO_MSG) + strlen(SZ_HELLO_DESCRIPTION) + 1;
    }
    else
    {
        dwBufferLen = dwMsgLen + sizeof(P_HELLO_MSG) + strlen(SZ_HELLO_DESCRIPTION) + 1;
    }

    pbMsg = (PBYTE) SysAlloc(dwBufferLen, PTAG_XPRESENCE_MESSAGE_BUFFER);
    if (pbMsg == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    *ppbMsgBuffer = pbMsg;
    *pcbMsgBuffer = dwBufferLen;

    if (Server == serverNotification)
    {
        pQHelloMsg = (Q_HELLO_MSG *) pbMsg;
        pQHelloMsg->dwMsgType = QMSG_HELLO;
        pQHelloMsg->dwMsgLen = sizeof(Q_HELLO_MSG) - sizeof(BASE_MSG_HEADER) + strlen(SZ_HELLO_DESCRIPTION) + 1;
        pQHelloMsg->dwSeqNum = m_dwSeqNum++;
        pQHelloMsg->sgaddr = pExtendedHandle->sgaddr;
        pQHelloMsg->dwProtocolVersion = CURRENT_XPPROTOCOL_VER;
        pbMsg += sizeof(Q_HELLO_MSG);
    }
    else
    {
        pPHelloMsg = (P_HELLO_MSG *) pbMsg;
        pPHelloMsg->dwMsgType = PMSG_HELLO;
        pPHelloMsg->dwMsgLen = sizeof(P_HELLO_MSG) - sizeof(BASE_MSG_HEADER) + strlen(SZ_HELLO_DESCRIPTION) + 1;
        pPHelloMsg->dwSeqNum = m_dwSeqNum++;
        pPHelloMsg->sgaddr = pExtendedHandle->sgaddr;
        pPHelloMsg->dwProtocolVersion = CURRENT_XPPROTOCOL_VER;
        pbMsg += sizeof(P_HELLO_MSG);
    }

    strcpy((PSTR)pbMsg, SZ_HELLO_DESCRIPTION); pbMsg += strlen(SZ_HELLO_DESCRIPTION) + 1;

    *ppbMsg = pbMsg;

    pBaseMsg = (BASE_MSG_HEADER *) pbMsg;
    pBaseMsg->dwMsgType = dwMsgType;
    pBaseMsg->dwMsgLen = dwMsgLen - sizeof(BASE_MSG_HEADER);
    pBaseMsg->dwSeqNum = m_dwSeqNum++;
    pBaseMsg->sgaddr = pExtendedHandle->sgaddr;

    if (pdwSeqNum != NULL)
    {
        *pdwSeqNum = pBaseMsg->dwSeqNum;
    }

  Error:

    return hr;
}


//---------------------------------------------------------------------------
//
// SendMsg
//
// 
//
HRESULT
CXo::SendMsg(
    IN PBYTE pbMsgBuffer,
    IN UINT cbMsgBuffer,
    IN DWORD dwBufferSize,
    IN PXPRESENCE_EXTENDED_HANDLE pExtendedHandle,
    IN SERVER_TYPE Server
    )
{
    DWORD                  dwSendBufferLen = dwBufferSize;
    HRESULT                hr              = S_OK;
    PXPRESENCE_HANDLE_LIST pNewHandle      = NULL;
    PXPRESENCE_HANDLE_LIST pNextHandle     = NULL;

    pNewHandle = (PXPRESENCE_HANDLE_LIST) SysAlloc(sizeof(XPRESENCE_HANDLE_LIST), PTAG_XPRESENCE_HANDLE_LIST);
    if (pNewHandle == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    pNewHandle->pBuffer = pbMsgBuffer;

    if (pExtendedHandle->pHandleList == NULL)
    {
        pExtendedHandle->pHandleList = pNewHandle;
        pNewHandle->pPrev = pNewHandle;
        pNewHandle->pNext = pNewHandle;
    }
    else
    {
        pNextHandle = pExtendedHandle->pHandleList;
        pExtendedHandle->pHandleList = pNewHandle;
        pNewHandle->pPrev = pNextHandle->pPrev;
        pNewHandle->pNext = pNextHandle;
        pNextHandle->pPrev = pNewHandle;
        pNewHandle->pPrev->pNext = pNewHandle;
    }
 
    hr = XOnlineUploadFromMemory( g_PresenceServers[Server].dwService, g_PresenceServers[Server].szUrl, NULL, 
                                  &dwSendBufferLen, (PBYTE)g_PresenceServers[Server].szContentType, g_PresenceServers[Server].dwContentType,
                                  pbMsgBuffer, cbMsgBuffer,
                                  DW_POST_TIMEOUT,
                                  pExtendedHandle->XPresenceTaskHandle.hEventWorkAvailable, 
                                  &(pExtendedHandle->pHandleList->hTask) );

  Error:

    return hr;
}


//---------------------------------------------------------------------------
//
// NotificationContinue()
//
HRESULT
CXo::NotificationContinue(
    XONLINETASK_HANDLE hTask
    )
{
    HRESULT                    hr               = XONLINETASK_S_RUNNING;
    PXPRESENCE_EXTENDED_HANDLE pExtendedHandle  = (PXPRESENCE_EXTENDED_HANDLE)hTask;
    PBYTE                      pbUpload         = NULL;
    DWORD                      dwStatus         = 0;
    DWORD                      cbUpload         = 0;
    PXPRESENCE_HANDLE_LIST     pHandle          = NULL;
    ULARGE_INTEGER             uliContentLength;
    ULARGE_INTEGER             uliTotalReceived;

    Assert(hTask != NULL);
    Assert(IsValidXPresenceHandle(hTask));

    if (pExtendedHandle->pHandleList == NULL)
    {
        hr = XONLINETASK_S_SUCCESS;
        goto Error;
    }
    else
    {
        pHandle = pExtendedHandle->pHandleList;
        pExtendedHandle->pHandleList = pExtendedHandle->pHandleList->pNext;

        hr = XOnlineTaskContinue(pHandle->hTask);

        if (hr != XONLINETASK_S_RUNNING)
        {
            if (FAILED(hr))
            {
                pHandle = NULL;
                goto Error;
            }

            if (hr != XONLINETASK_S_SUCCESS)
            {
                // BUGBUG: Should never get here
                pHandle = NULL;
                Assert(FALSE);
                __asm int 3;
                goto Error;
            }

            hr = XOnlineUploadGetResults(pHandle->hTask, &pbUpload, &cbUpload, &uliTotalReceived, &uliContentLength, &dwStatus, NULL);

            SysFree(pHandle->pBuffer);
            pHandle->pBuffer = NULL;

            if (pHandle->pNext == pHandle)
            {
                pExtendedHandle->pHandleList = NULL;
            }
            else
            {
                pHandle->pNext->pPrev = pHandle->pPrev;
                pHandle->pPrev->pNext = pHandle->pNext;
            }

            if (pbUpload == NULL || dwStatus != 200)
            {
                hr = E_FAIL; // BUGBUG: find a better error code
                goto Error;
            }

            if (SUCCEEDED(hr))
            {
                if (pExtendedHandle->Type == PresenceAlive)
                {
                    P_ALIVE_REPLY_MSG *pAliveReplyMsg = (P_ALIVE_REPLY_MSG *) pbUpload;
                    P_REPLY_BUDDY *pFriend = (P_REPLY_BUDDY *) (((PBYTE)pbUpload) + sizeof(P_ALIVE_REPLY_MSG));
                    P_REPLY_BLOCK *pLockoutUser = (P_REPLY_BLOCK *) (((PBYTE)pbUpload) + sizeof(P_ALIVE_REPLY_MSG));
                    DWORD i = 0;

                    if (FAILED(pAliveReplyMsg->hr))
                    {
                        hr = pAliveReplyMsg->hr;
                        goto Error;
                    }
                    else
                    {
                        ResetFriendList(pAliveReplyMsg->dwSeqNum, pAliveReplyMsg->dwBuddyListVersion, pAliveReplyMsg->cBuddiesSent, pFriend);

                        for (i = 0; i < pAliveReplyMsg->cBuddiesSent; i += 1)
                        {
                            pFriend = (P_REPLY_BUDDY *) (((PBYTE)pFriend) + sizeof(P_REPLY_BUDDY) + pFriend->cbAcctName);
                        }

                        ResetLockoutList(pAliveReplyMsg->dwSeqNum, pAliveReplyMsg->dwBlockListVersion, pAliveReplyMsg->cBlocksSent, (P_REPLY_BLOCK *) pFriend);
                    }
                }

                if (pExtendedHandle->pHandleList == NULL)
                {
                    hr = XONLINETASK_S_SUCCESS;
                }
                else
                {
                    hr = XONLINETASK_S_RUNNING;
                }
            }
            else
            {
                goto Error;
            }

            XOnlineTaskClose(pHandle->hTask);
            SysFree(pHandle);
            pHandle = NULL;
        }

        pHandle = NULL;
    }

    pHandle = NULL;

  Error:

    if (pHandle != NULL)
    {
        XOnlineTaskClose(pHandle->hTask);
        SysFree(pHandle);
        pHandle = NULL;
    }

    if (SUCCEEDED(hr) && hr != XONLINETASK_S_SUCCESS)
    {
        hr = XONLINETASK_S_RUNNING;
    }

    return hr;
}


//---------------------------------------------------------------------------
//
// FriendsEnumerateContinue()
//
HRESULT
CXo::FriendsEnumerateContinue(
    XONLINETASK_HANDLE hTask
    )
{
    HRESULT                    hr               = XONLINETASK_S_RUNNING;
    PXPRESENCE_EXTENDED_HANDLE pExtendedHandle  = (PXPRESENCE_EXTENDED_HANDLE)hTask;
    PBYTE                      pbUpload         = NULL;
    DWORD                      dwStatus         = 0;
    DWORD                      cbUpload         = 0;
    PXPRESENCE_HANDLE_LIST     pHandle          = NULL;
    ULARGE_INTEGER             uliContentLength;
    ULARGE_INTEGER             uliTotalReceived;

    Assert(hTask != NULL);
    Assert(IsValidXPresenceHandle(hTask));

    if (!pExtendedHandle->fPresenceIndicated)
    {
        if (XOnlineNotificationIsPending(pExtendedHandle->dwUserIndex, XONLINE_NOTIFICATION_TYPE_FRIENDREQUEST) != TRUE)
        {
            pExtendedHandle->fPresenceIndicated = TRUE;
            hr = XONLINE_S_NOTIFICATION_UPTODATE;
            goto Error;
        }
    }

    if (pExtendedHandle->pHandleList == NULL)
    {
        hr = FriendListRefresh(pExtendedHandle);
        if (FAILED(hr))
        {
            hr = hr;
            goto Error;
        }
    }
    else
    {
        pHandle = pExtendedHandle->pHandleList;
        pExtendedHandle->pHandleList = pExtendedHandle->pHandleList->pNext;

        hr = XOnlineTaskContinue(pHandle->hTask);

        if (hr != XONLINETASK_S_RUNNING)
        {
            if (FAILED(hr))
            {
                pHandle = NULL;
                goto Error;
            }

            if (hr != XONLINETASK_S_SUCCESS)
            {
                // BUGBUG: Should never get here
                pHandle = NULL;
                Assert(FALSE);
                __asm int 3;
                goto Error;
            }

            hr = XOnlineUploadGetResults(pHandle->hTask, &pbUpload, &cbUpload, &uliTotalReceived, &uliContentLength, &dwStatus, NULL);

            SysFree(pHandle->pBuffer);
            pHandle->pBuffer = NULL;

            if (pHandle->pNext == pHandle)
            {
                pExtendedHandle->pHandleList = NULL;
            }
            else
            {
                pHandle->pNext->pPrev = pHandle->pPrev;
                pHandle->pPrev->pNext = pHandle->pNext;
            }

            if (pbUpload == NULL || dwStatus != 200)
            {
                hr = E_FAIL; // BUGBUG: find a better error code
                goto Error;
            }

            if (SUCCEEDED(hr))
            {
                if (pExtendedHandle->Type == FriendsSync)
                {
                    P_SYNC_REPLY_MSG *pSyncReplyMsg = (P_SYNC_REPLY_MSG *) pbUpload;
                    P_REPLY_BUDDY *pFriend = (P_REPLY_BUDDY *) (((PBYTE)pbUpload) + sizeof(P_SYNC_REPLY_MSG));

                    ResetFriendList(pSyncReplyMsg->dwSeqNum, pSyncReplyMsg->dwBuddyListVersion, pSyncReplyMsg->cBuddiesSent, pFriend);
                }
                else
                {
                    DWORD dwLastItemID = 0;
                    Q_LIST_REPLY_MSG *pQListReply = (Q_LIST_REPLY_MSG *) pbUpload;
                    dwLastItemID = PreprocessNotifications(pQListReply);

                    if (pQListReply->wQLeft > 0)
                    {
                        DWORD dwQType = 0;

                        if (pExtendedHandle->Type == FriendsPresenceUpdate)
                            dwQType = XONLINE_NOTIFICATION_TYPE_FRIENDSTATUS;
                        else if (pExtendedHandle->Type == FriendsListUpdate)
                            dwQType = XONLINE_NOTIFICATION_TYPE_FRIENDREQUEST;
                        else if (pExtendedHandle->Type == FriendsGameInviteUpdate)
                            dwQType = XONLINE_NOTIFICATION_TYPE_GAMEINVITE;
                        else if (pExtendedHandle->Type == FriendsGameInviteAnswerUpdate)
                            dwQType = XONLINE_NOTIFICATION_TYPE_GAMEINVITEANSWER;

//@@@ [drm] This needs to be reworked.  Can't change dwQFlags without dwSeqQFlags 
//@@@                        XnLogonSetQFlags(pExtendedHandle->dwUserIndex, dwQType, 0);
                    }
                }

                hr = FriendListRefresh(pExtendedHandle);
                if (FAILED(hr))
                {
                    goto Error;
                }
            }
            else
            {
                goto Error;
            }

            XOnlineTaskClose(pHandle->hTask);
            SysFree(pHandle);
            pHandle = NULL;
        }
    }

    pHandle = NULL;

  Error:

    if (pHandle != NULL)
    {
        XOnlineTaskClose(pHandle->hTask);
        SysFree(pHandle);
        pHandle = NULL;
    }

    if (SUCCEEDED(hr) && hr != XONLINE_S_NOTIFICATION_UPTODATE)
    {
        hr = XONLINETASK_S_RUNNING;
    }

    return hr;
}


//---------------------------------------------------------------------------
//
// FriendsContinue()
//
HRESULT
CXo::FriendsContinue(
    XONLINETASK_HANDLE hTask
    )
{
    HRESULT                    hr               = XONLINETASK_S_RUNNING;
    PXPRESENCE_EXTENDED_HANDLE pExtendedHandle  = (PXPRESENCE_EXTENDED_HANDLE)hTask;
    PBYTE                      pbUpload         = NULL;
    DWORD                      dwStatus         = 0;
    DWORD                      cbUpload         = 0;
    PXPRESENCE_HANDLE_LIST     pHandle          = NULL;
    ULARGE_INTEGER             uliContentLength;
    ULARGE_INTEGER             uliTotalReceived;

    Assert(hTask != NULL);
    Assert(IsValidXPresenceHandle(hTask));

    hr = HandleGameInvite(hTask);
    if (FAILED(hr))
    {
        goto Error;
    }

    if (pExtendedHandle->pFriendsErrorList != NULL)
    {
        hr = XONLINE_S_NOTIFICATION_FRIEND_RESULT;
        goto Error;
    }

    if (pExtendedHandle->pHandleList != NULL)
    {
        pHandle = pExtendedHandle->pHandleList;
        pExtendedHandle->pHandleList = pExtendedHandle->pHandleList->pNext;

        hr = XOnlineTaskContinue(pHandle->hTask);

        if (hr != XONLINETASK_S_RUNNING)
        {
            if (FAILED(hr))
            {
                pHandle = NULL;
                goto Error;
            }

            if (hr != XONLINETASK_S_SUCCESS)
            {
                // BUGBUG: Should never get here
                pHandle = NULL;
                Assert(FALSE);
                __asm int 3;
                goto Error;
            }

            hr = XOnlineUploadGetResults(pHandle->hTask, &pbUpload, &cbUpload, &uliTotalReceived, &uliContentLength, &dwStatus, NULL);

            SysFree(pHandle->pBuffer);
            pHandle->pBuffer = NULL;

            if (pHandle->pNext == pHandle)
            {
                pExtendedHandle->pHandleList = NULL;
            }
            else
            {
                pHandle->pNext->pPrev = pHandle->pPrev;
                pHandle->pPrev->pNext = pHandle->pNext;
            }

            if (pbUpload == NULL || dwStatus != 200)
            {
                hr = E_FAIL; // BUGBUG: find a better error code
                goto Error;
            }

            if (FAILED(hr))
            {
                goto Error;
            }

            XOnlineTaskClose(pHandle->hTask);
            SysFree(pHandle);
            pHandle = NULL;
        }
    }

    pHandle = NULL;

  Error:

    if (pHandle != NULL)
    {
        XOnlineTaskClose(pHandle->hTask);
        SysFree(pHandle);
        pHandle = NULL;
    }

    if (SUCCEEDED(hr) && hr != XONLINE_S_NOTIFICATION_FRIEND_RESULT)
    {
        hr = XONLINETASK_S_RUNNING;
    }

    return hr;
}


//---------------------------------------------------------------------------
//
// HandleGameInvite()
//
HRESULT
CXo::HandleGameInvite(
    XONLINETASK_HANDLE hTask
    )
{
    HRESULT                    hr               = XONLINETASK_S_RUNNING;
    PXPRESENCE_EXTENDED_HANDLE pExtendedHandle  = (PXPRESENCE_EXTENDED_HANDLE)hTask;

    //
    // Pump the cache task handle, if there is one
    //
    if (m_hTaskGameInvite != NULL)
    {
        hr = XOnlineTaskContinue(m_hTaskGameInvite);

        if (FAILED(hr))
        {
            goto Error;
        }
    }

    //
    // Depending on the current state of the cache, either open the cache, write to it
    // or close it.
    //
    switch (m_cachestateGameInvite)
    {
        //
        // If there's nothing going on with the Cache at the moment...
        //
        case CacheDone:
        {
            //
            // If there's an accepted game invitation that hasn't been written yet, start the cache process.
            // Otherwise, break out of this loop -- there's nothing to do.
            //
            if (m_fGameInvite)
            {
                //
                // Change state to CacheOpening and start the open process
                //
                m_cachestateGameInvite = CacheOpening;

                hr = CacheOpen(XONLC_TYPE_GAMEINVITE, NULL, pExtendedHandle->XPresenceTaskHandle.hEventWorkAvailable, &m_hCacheGameInvite, &m_hTaskGameInvite);
                if(FAILED(hr))
                {
                    goto Error;
                }
            }
            else
            {
                //
                // There's nothing to do... break out of the loop
                //
                goto Error;
            }

            break;
        }

        //
        // The cache is currently being opened
        //
        case CacheOpening:
        {
            //
            // If opening the cache is completed...
            //
            if (hr != XONLINETASK_S_RUNNING)
            {
                //
                // Change to the next state: writing to the cache
                //
                m_cachestateGameInvite = CacheWriting;
                m_fGameInvite = FALSE;

                hr = CacheUpdate( m_hCacheGameInvite, m_hTaskGameInvite, (PBYTE)m_precordGameInvite, NULL);
                if(FAILED(hr))
                {
                    goto Error;
                }
            }

            break;
        }

        //
        // The cache is currently being written to
        //
        case CacheWriting:
        {
            //
            // If writing to the cache is completed
            //
            if (hr != XONLINETASK_S_RUNNING)
            {
                //
                // Change to next state: close the cache
                //
                m_cachestateGameInvite = CacheClosing;

                hr = CacheClose( m_hCacheGameInvite, m_hTaskGameInvite );
                if(FAILED(hr))
                {
                    goto Error;
                }
            }

            break;
        }

        //
        // The cache is currently being closed
        //
        case CacheClosing:
        {
            //
            // If closing the cache is complete
            //
            if(hr != XONLINETASK_S_RUNNING)
            {
                //
                // Change to next state: all done -- nothing to do
                //
                m_cachestateGameInvite = CacheDone;

                XOnlineTaskClose(m_hTaskGameInvite);

                m_hCacheGameInvite = NULL;
                m_hTaskGameInvite = NULL;
            }

            break;
        }

    }

  Error:

    return hr;
}


//---------------------------------------------------------------------------
//
// GameInviteContinue()
//
HRESULT
CXo::GameInviteContinue(
    XONLINETASK_HANDLE hTask
    )
{
    HRESULT                         hr               = XONLINETASK_S_RUNNING;
    PXPRESENCE_CACHEEXTENDED_HANDLE pExtendedHandle  = (PXPRESENCE_CACHEEXTENDED_HANDLE) hTask;

    Assert(hTask != NULL);
    Assert(IsValidXCachePresenceHandle(hTask));

    //
    // Pump the cache task handle, if there is one
    //
    if (pExtendedHandle->hTask != NULL)
    {
        hr = XOnlineTaskContinue(pExtendedHandle->hTask);

        if (FAILED(hr))
        {
            goto Error;
        }
    }

    //
    // Depending on the current state of the cache, either open the cache, read from it
    // or close it.
    //
    switch (pExtendedHandle->cachestate)
    {
        //
        // The cache is currently being opened
        //
        case CacheOpening:
        {
            //
            // If opening the cache is completed...
            //
            if (hr != XONLINETASK_S_RUNNING)
            {
                //
                // Lookup & Retrieve
                //
                memset(&(pExtendedHandle->context), 0, sizeof(XONLC_CONTEXT));

                pExtendedHandle->context.pbIndexData = (PBYTE)(&(pExtendedHandle->indexData));
                pExtendedHandle->context.pbRecordBuffer = NULL;
                pExtendedHandle->context.dwRecordBufferSize = 0;

                hr = CacheLookup(pExtendedHandle->hCache, &(pExtendedHandle->context));
                if(FAILED(hr))
                {
                    goto Error;
                }

                //
                // Retrieved game invite successfully.
                //

                //
                // If the game invite is for this title, then delete it from the cache.
                //
                if (((PXPRESENCE_GAMEINVITE_RECORD)(pExtendedHandle->context.pbIndexData))->InvitingFriend.titleID == m_dwTitleId)
                {
                    //
                    // Delete from cache
                    //
                    hr = CacheDelete(pExtendedHandle->hCache, &(pExtendedHandle->context));
                    if(FAILED(hr))
                    {
                        goto Error;
                    }
                }

                //
                // Change to the next state: closing the cache
                //
                pExtendedHandle->cachestate = CacheClosing;

                hr = CacheClose( pExtendedHandle->hCache, pExtendedHandle->hTask );
                if(FAILED(hr))
                {
                    goto Error;
                }
            }

            break;
        }

        //
        // The cache is currently being closed
        //
        case CacheClosing:
        {
            //
            // If closing the cache is complete
            //
            if(hr != XONLINETASK_S_RUNNING)
            {
                //
                // Change to next state: all done -- nothing to do
                //
                pExtendedHandle->cachestate = CacheDone;

                XOnlineTaskClose(pExtendedHandle->hTask);

                pExtendedHandle->hCache = NULL;
                pExtendedHandle->hTask = NULL;

                return XONLINETASK_S_SUCCESS;
            }

            break;
        }

        //
        // If Cache is done, return XONLINETASK_S_SUCCESS
        //
        case CacheDone:
        {
            return XONLINETASK_S_SUCCESS;
        }

    }

  Error:

    if (SUCCEEDED(hr))
    {
        hr = XONLINETASK_S_RUNNING;
    }

    return hr;
}


//---------------------------------------------------------------------------
//
// GameInviteClose()
//
VOID
CXo::GameInviteClose(
    XONLINETASK_HANDLE hTask
    )
{
    HRESULT                    hr               = S_OK;
    PXPRESENCE_CACHEEXTENDED_HANDLE pExtendedHandle  = (PXPRESENCE_CACHEEXTENDED_HANDLE)hTask;

    Assert(hTask != NULL);
    Assert(IsValidXCachePresenceHandle(hTask));

    if (pExtendedHandle->hTask != NULL)
    {
        XOnlineTaskClose(pExtendedHandle->hTask);
    }

    SysFree(pExtendedHandle);
}


//---------------------------------------------------------------------------
//
// PresenceClose()
//
VOID
CXo::PresenceClose(
    XONLINETASK_HANDLE hTask
    )
{
    HRESULT                    hr               = S_OK;
    PXPRESENCE_EXTENDED_HANDLE pExtendedHandle  = (PXPRESENCE_EXTENDED_HANDLE)hTask;
    PXPRESENCE_HANDLE_LIST     pHandle          = NULL;

    Assert(hTask != NULL);
    Assert(IsValidXPresenceHandle(hTask));

    if (m_pFriendsHandle == pExtendedHandle)
    {
        SysFree(m_precordGameInvite);
    }

    if (pExtendedHandle->pHandleList != NULL)
    {
        pExtendedHandle->pHandleList->pPrev->pNext = NULL;

        while (pExtendedHandle->pHandleList != NULL)
        {
            XOnlineTaskClose(pExtendedHandle->pHandleList->hTask);
            pHandle = pExtendedHandle->pHandleList;
            pExtendedHandle->pHandleList = pExtendedHandle->pHandleList->pNext;
            SysFree(pHandle);
        }
    }

    SysFree(pExtendedHandle);
}


//---------------------------------------------------------------------------
//
// GetUserFromID
//
// 
//
PXPRESENCE_USER
CXo::GetUserFromID(
    IN ULONGLONG qwUserID
    )
{
    DWORD i = 0;

    for (i = 0; i < XONLINE_MAX_LOGON_USERS; i += 1)
    {
        if (m_Users[i].qwUserID == qwUserID)
        {
            break;
        }
    }

    return &m_Users[i];
}


//---------------------------------------------------------------------------
//
// GetUserIndexFromID
//
// 
//
DWORD
CXo::GetUserIndexFromID(
    IN ULONGLONG qwUserID
    )
{
    DWORD i = 0;

    for (i = 0; i < XONLINE_MAX_LOGON_USERS; i += 1)
    {
        if (m_Users[i].qwUserID == qwUserID)
        {
            break;
        }
    }

    return i;
}


//---------------------------------------------------------------------------
//
// GetUserFromSeqNum
//
// 
//
PXPRESENCE_USER
CXo::GetUserFromSeqNum(
    IN DWORD dwSeqNum
    )
{
    DWORD i = 0;

    for (i = 0; i < XONLINE_MAX_LOGON_USERS; i += 1)
    {
        if (m_Users[i].dwSeqNum == dwSeqNum)
        {
            break;
        }
    }

    return &m_Users[i];
}


//---------------------------------------------------------------------------
//
// FriendListRefresh
//
// 
//
HRESULT
CXo::FriendListRefresh(
    IN PXPRESENCE_EXTENDED_HANDLE pExtendedHandle
    )
{
    HRESULT    hr          = S_OK;
    P_SYNC_MSG *pMsg       = NULL;
    PBYTE      pbMsgBuffer = NULL;
    UINT       cbMsgBuffer = 0;
    DWORD      dwSeqNum    = 0;

    if (m_Users[pExtendedHandle->dwUserIndex].fFriendListSynced == FALSE)
    {
        pExtendedHandle->Type = FriendsSync;

        hr = CreateMsg(PMSG_SYNC, sizeof(P_SYNC_MSG), pExtendedHandle, serverPresence, &pbMsgBuffer, &cbMsgBuffer, (PBYTE *) &pMsg, &dwSeqNum);

        if (FAILED(hr))
        {
            goto Error;
        }

        m_Users[pExtendedHandle->dwUserIndex].dwSeqNum = dwSeqNum;
        pMsg->qwUserID = m_Users[pExtendedHandle->dwUserIndex].qwUserID;
        pMsg->dwBuddyListVersion = m_Users[pExtendedHandle->dwUserIndex].dwFriendListVersion;
        pMsg->dwBlockListVersion = 0;  // BUGBUG: When we support block lists, be sure to set this to correct block list version

        hr = SendMsg(pbMsgBuffer, cbMsgBuffer, DW_LARGE_RECEIVE_BUFFER, pExtendedHandle, serverPresence);

        if (FAILED(hr))
        {
            goto Error;
        }
    }
    else
    {
        XONLINE_NOTIFICATION_MSG Buffer[20]; // BUGBUG: Arbitrary sized buffer

        if (XOnlineNotificationIsPending(pExtendedHandle->dwUserIndex, XONLINE_NOTIFICATION_TYPE_FRIENDREQUEST) == TRUE)
        {
            pExtendedHandle->Type = FriendsListUpdate;
            hr = NotificationEnumeratePriv(pExtendedHandle->dwUserIndex, Buffer, 20, XONLINE_NOTIFICATION_TYPE_FRIENDREQUEST, pExtendedHandle);
        }
        else if (XOnlineNotificationIsPending(pExtendedHandle->dwUserIndex, XONLINE_NOTIFICATION_TYPE_FRIENDSTATUS) == TRUE)
        {
            pExtendedHandle->Type = FriendsPresenceUpdate;
            hr = NotificationEnumeratePriv(pExtendedHandle->dwUserIndex, Buffer, 20, XONLINE_NOTIFICATION_TYPE_FRIENDSTATUS, pExtendedHandle);
        }
        else if (XOnlineNotificationIsPending(pExtendedHandle->dwUserIndex, XONLINE_NOTIFICATION_TYPE_GAMEINVITE) == TRUE)
        {
            pExtendedHandle->Type = FriendsGameInviteUpdate;
            hr = NotificationEnumeratePriv(pExtendedHandle->dwUserIndex, Buffer, 20, XONLINE_NOTIFICATION_TYPE_GAMEINVITE, pExtendedHandle);
        }
        else if (XOnlineNotificationIsPending(pExtendedHandle->dwUserIndex, XONLINE_NOTIFICATION_TYPE_GAMEINVITEANSWER) == TRUE)
        {
            pExtendedHandle->Type = FriendsGameInviteAnswerUpdate;
            hr = NotificationEnumeratePriv(pExtendedHandle->dwUserIndex, Buffer, 20, XONLINE_NOTIFICATION_TYPE_GAMEINVITEANSWER, pExtendedHandle);
        }
        else
        {
            pExtendedHandle->Type = FriendsEnumerateNop;
            hr = S_OK;
        }

        if (FAILED(hr))
        {
            goto Error;
        }
    }

  Error:

    return hr;
}


//---------------------------------------------------------------------------
//
// ResetFriendList()
//
VOID
CXo::ResetFriendList(
    DWORD dwSeqNum,
    DWORD dwFriendListVersion,
    WORD cFriends,
    P_REPLY_BUDDY *pFriend
    )
{
    WORD            wFriendIndex = 0;
    PXPRESENCE_USER pUser       = NULL;

    pUser = GetUserFromSeqNum(dwSeqNum);

    pUser->fFriendListSynced = TRUE;

    if (pUser->dwFriendListVersion != dwFriendListVersion)
    {
        pUser->dwFriendListVersion = dwFriendListVersion;
        pUser->cNumFriends = cFriends;

        for (wFriendIndex = 0; wFriendIndex < cFriends; wFriendIndex += 1)
        {
            pUser->FriendList[wFriendIndex].xuid.qwUserID = pFriend->qwBuddyID;
            memcpy( pUser->FriendList[wFriendIndex].username, ((PBYTE)pFriend) + sizeof(P_REPLY_BUDDY), pFriend->cbAcctName );

            pUser->FriendList[wFriendIndex].friendState = 0;

            if (pFriend->bStatus & P_BUDDY_STATUS_PENDING)
            {
                pUser->FriendList[wFriendIndex].friendState |= XONLINE_FRIENDSTATE_FLAG_PENDING;
            }
            else if (pFriend->bStatus & P_BUDDY_STATUS_REQUEST)
            {
                pUser->FriendList[wFriendIndex].friendState |= XONLINE_FRIENDSTATE_FLAG_REQUEST;
            }

            pFriend = (P_REPLY_BUDDY *) (((PBYTE)pFriend) + sizeof(P_REPLY_BUDDY) + pFriend->cbAcctName);
        }

        for (; wFriendIndex < MAX_FRIENDS; wFriendIndex += 1)
        {
            pUser->FriendList[wFriendIndex].xuid.qwUserID = 0;
        }
    }
}


//---------------------------------------------------------------------------
//
// ResetLockoutList()
//
VOID
CXo::ResetLockoutList(
    DWORD dwSeqNum,
    DWORD dwLockoutListVersion,
    WORD cLockouts,
    P_REPLY_BLOCK *pLockout
    )
{
    WORD            wLockoutIndex = 0;
    PXPRESENCE_USER pUser       = NULL;

    pUser = GetUserFromSeqNum(dwSeqNum);

    pUser->cNumLockoutUsers = cLockouts;

    for (wLockoutIndex = 0; wLockoutIndex < cLockouts; wLockoutIndex += 1)
    {
        pUser->LockoutList[wLockoutIndex].xuid.qwUserID = pLockout->qwBlockID;
        memcpy( pUser->LockoutList[wLockoutIndex].username, ((PBYTE)pLockout) + sizeof(P_REPLY_BLOCK), pLockout->cbAcctName );

        pLockout = (P_REPLY_BLOCK *) (((PBYTE)pLockout) + sizeof(P_REPLY_BLOCK) + pLockout->cbAcctName);
    }

    for (; wLockoutIndex < MAX_LOCKOUTUSERS; wLockoutIndex += 1)
    {
        pUser->LockoutList[wLockoutIndex].xuid.qwUserID = 0;
    }
}


//---------------------------------------------------------------------------
//
// PreprocessNotifications()
//
DWORD
CXo::PreprocessNotifications(
    Q_LIST_REPLY_MSG *pQListReply
    )
{
    HRESULT                       hr            = S_OK;
    Q_LIST_ITEM                   *pQListItem   = NULL;
    DWORD                         dwItemID      = 0;
    PXPRESENCE_USER               pUser         = NULL;
    WORD                          i             = 0;
    PXPRESENCE_FRIENDS_ERROR_LIST pFriendsError = NULL;

    pUser = GetUserFromID(pQListReply->qwUserID);

    pQListItem = (Q_LIST_ITEM *) (((PBYTE)pQListReply) + sizeof(Q_LIST_REPLY_MSG));

    for (i = 0; i < pQListReply->wNumItems; i += 1)
    {
        switch (pQListReply->wQType)
        {
        case PQUEUE_LIST_CHANGE:
        {
            P_LIST_CHANGE_ITEM *pItem = NULL;
            pItem = (P_LIST_CHANGE_ITEM *) (((PBYTE)pQListItem) + sizeof(Q_LIST_ITEM));

            if (pItem->hr != S_OK)
            {
                //
                // Create a new friend error structure and store the error in the linked list.
                // This error can then be retrieved later while pumping the FriendsStartup() task
                // handle.
                //
                pFriendsError = (PXPRESENCE_FRIENDS_ERROR_LIST) SysAlloc(sizeof(XPRESENCE_FRIENDS_ERROR_LIST), PTAG_XPRESENCE_EXTENDED_HANDLE);
                pFriendsError->pNext = m_pFriendsHandle->pFriendsErrorList;
                m_pFriendsHandle->pFriendsErrorList = pFriendsError;

                pFriendsError->hr          = pItem->hr;
                pFriendsError->xuid        = *((XUID *) &pItem->qwTargetID);
                pFriendsError->dwUserIndex = GetUserIndexFromID(pQListReply->qwUserID);

                //
                // Set the TaskContinue event so this error is picked up on the next TaskContinue
                // call.
                //
                SetEvent(m_pFriendsHandle->XPresenceTaskHandle.hEventWorkAvailable);

                break;
            }

            if ((pItem->dwListVersion - pUser->dwFriendListVersion) > 1)
            {
                pUser->fFriendListSynced = FALSE;
            }

            switch (pItem->wOperationID)
            {
            case PLIST_BUDDY_NOP:
            {
                break;
            }

            case PLIST_BUDDY_ADD:
            {
                UpdateUser(pUser, pItem->qwTargetID, ((PBYTE)pItem)+sizeof(P_LIST_CHANGE_ITEM), pItem->cbTargetAcctName, 0, 0, XONLINE_FRIENDSTATE_FLAG_PENDING, 0, 0, NULL, 0, NULL, pItem->dwListVersion);

                break;
            }
            case PLIST_BUDDY_ADDED:
            {
                UpdateUser(pUser, pItem->qwTargetID, ((PBYTE)pItem)+sizeof(P_LIST_CHANGE_ITEM), pItem->cbTargetAcctName, 0, 0, XONLINE_FRIENDSTATE_FLAG_REQUEST, 0, 0, NULL, 0, NULL, pItem->dwListVersion);

                break;
            }

            case PLIST_BUDDY_ACCEPT:
            {
                UpdateUser(pUser, pItem->qwTargetID, ((PBYTE)pItem)+sizeof(P_LIST_CHANGE_ITEM), pItem->cbTargetAcctName, 0, 0, 0, 0, 0, NULL, 0, NULL, pItem->dwListVersion);

                break;
            }

            case PLIST_BUDDY_REJECT:
            {
                RemoveUser(pUser, pItem->qwTargetID, pItem->dwListVersion);
    
                break;
            }

            case PLIST_BUDDY_DELETE:
            {
                RemoveUser(pUser, pItem->qwTargetID, pItem->dwListVersion);

                break;
            }
            }
            
            break;
        }

        case PQUEUE_PRESENCE:
        {
            PBYTE pTitleStuff = NULL;
            PBYTE pUserData = NULL;
            P_PRESENCE_ITEM *pItem = NULL;
            pItem = (P_PRESENCE_ITEM *) (((PBYTE)pQListItem) + sizeof(Q_LIST_ITEM));
            pUserData = ((PBYTE) pItem) + sizeof(P_PRESENCE_ITEM);
            pTitleStuff = ((PBYTE) pItem) + sizeof(P_PRESENCE_ITEM) + pItem->cbNickname;
            UpdateUser(pUser, pItem->qwBuddyID, NULL, 0, pItem->dwTitleID, pItem->dwState, 0, pItem->qwMatchSessionID, pItem->cbTitleStuff, pTitleStuff, pItem->cbNickname, pUserData, 0);

            break;
        }

        case PQUEUE_INVITE:
        {
            // possible BUGBUG:  Ignoring qwMatchSessionID and dwTitleID for now.  This should already be taken care of by presence updates

            P_INVITATION_ITEM *pItem = NULL;
            pItem = (P_INVITATION_ITEM *) (((PBYTE)pQListItem) + sizeof(Q_LIST_ITEM));
            SetUserFlags(pUser, pItem->qwHostID, XONLINE_FRIENDSTATE_FLAG_RECEIVEDINVITE, TRUE);

            break;
        }

        case PQUEUE_INVITE_ANSWER:
        {
            P_INVITATION_ANSWER_ITEM *pItem = NULL;
            pItem = (P_INVITATION_ANSWER_ITEM *) (((PBYTE)pQListItem) + sizeof(Q_LIST_ITEM));

            if (pItem->wAnswer == PINVITE_REPLY_NO)
            {
                SetUserFlags(pUser, pItem->qwInviteeID, XONLINE_FRIENDSTATE_FLAG_INVITEREJECTED, TRUE);
            }
            else
            {
                SetUserFlags(pUser, pItem->qwInviteeID, XONLINE_FRIENDSTATE_FLAG_INVITEACCEPTED, TRUE);
            }

            break;
        }

        }

        if (dwItemID < pQListItem->dwItemID)
        {
            dwItemID = pQListItem->dwItemID;
        }

        pQListItem = (Q_LIST_ITEM *) (((PBYTE) pQListItem) + pQListItem->wItemLen + sizeof(Q_LIST_ITEM));
    }

    return dwItemID;
}


//---------------------------------------------------------------------------
//
// UpdateUser()
//
HRESULT
CXo::UpdateUser(
    PXPRESENCE_USER pUser,
    ULONGLONG qwFriendID,
    PBYTE pUserName,
    DWORD cbUserName,
    DWORD dwTitleID,
    DWORD dwState,
    DWORD dwFriendFlags,
    ULONGLONG qwMatchSessionID,
    WORD cbStateData,
    PBYTE pStateData,
    WORD cbUserData,
    PBYTE pUserData,
    DWORD dwVersion
    )
{
    HRESULT hr = S_OK;
    DWORD   i  = 0;

    for (i = 0; i < pUser->cNumFriends; i += 1)
    {
        if (pUser->FriendList[i].xuid.qwUserID == qwFriendID)
        {
            break;
        }
    }

    pUser->FriendList[i].xuid.qwUserID = qwFriendID;
    pUser->FriendList[i].titleID = dwTitleID;
    pUser->FriendList[i].friendState = dwState;
    pUser->FriendList[i].friendState |= dwFriendFlags;
    pUser->FriendList[i].sessionID = *((XNKID *)&qwMatchSessionID);
    pUser->FriendList[i].StateDataSize = (BYTE) cbStateData;
    pUser->FriendList[i].UserDataSize = (BYTE) cbUserData;

    if (cbUserName != 0 && pUserName != NULL)
    {
        memcpy(pUser->FriendList[i].username, pUserName, cbUserName);
    }

    if (cbStateData != 0 && pStateData != NULL)
    {
        memcpy( pUser->FriendList[i].StateData, pStateData, cbStateData );
    }

    if (cbUserData != 0 && pUserData != NULL)
    {
        memcpy( pUser->FriendList[i].UserData, pUserData, cbUserData );
    }

    if (dwVersion != 0)
    {
        pUser->dwFriendListVersion = dwVersion;
    }

    if (i == pUser->cNumFriends)
    {
        pUser->cNumFriends = (WORD) (i + 1);
    }

    return hr;
}


//---------------------------------------------------------------------------
//
// SetUserFlags()
//
VOID
CXo::SetUserFlags(
    PXPRESENCE_USER pUser,
    ULONGLONG qwFriendID,
    DWORD dwFlags,
    BOOL fSet
    )
{
    DWORD   i  = 0;

    for (i = 0; i < pUser->cNumFriends; i += 1)
    {
        if (pUser->FriendList[i].xuid.qwUserID == qwFriendID)
        {
            if (fSet)
            {
                pUser->FriendList[i].friendState |= dwFlags;
            }                                           
            else
            {
                pUser->FriendList[i].friendState &= ~dwFlags;
            }
            break;
        }
    }
}


//---------------------------------------------------------------------------
//
// RemoveUser()
//
HRESULT
CXo::RemoveUser(
    IN PXPRESENCE_USER pUser,
    IN ULONGLONG qwFriendID,
    DWORD dwVersion
    )
{
    DWORD i = 0;
    BOOL fMatch = FALSE;

    for (i = 0; i < pUser->cNumFriends; i += 1)
    {
        if (pUser->FriendList[i].xuid.qwUserID == qwFriendID)
        {
            i += 1;
            fMatch = TRUE;
            break;
        }
    }

    for (; i < pUser->cNumFriends; i += 1)
    {
        pUser->FriendList[i-1].xuid.qwUserID = pUser->FriendList[i].xuid.qwUserID;
        memcpy(pUser->FriendList[i-1].username, pUser->FriendList[i].username, XONLINE_USERNAME_SIZE);
        pUser->FriendList[i-1].friendState = pUser->FriendList[i].friendState;
        pUser->FriendList[i-1].titleID = pUser->FriendList[i].titleID;
        pUser->FriendList[i-1].StateDataSize = pUser->FriendList[i].StateDataSize;
        pUser->FriendList[i-1].UserDataSize = pUser->FriendList[i].UserDataSize;
        pUser->FriendList[i-1].sessionID = pUser->FriendList[i].sessionID;
        memcpy(pUser->FriendList[i-1].StateData, pUser->FriendList[i].StateData, pUser->FriendList[i].StateDataSize);
        memcpy(pUser->FriendList[i-1].UserData, pUser->FriendList[i].UserData, pUser->FriendList[i].UserDataSize);
    }

    if (dwVersion != 0)
    {
        pUser->dwFriendListVersion = dwVersion;
    }

    if (fMatch == TRUE)
    {
        pUser->cNumFriends -= 1;
    }

    return S_OK;
}


//---------------------------------------------------------------------------
//
// AddLockoutUser()
//
HRESULT
CXo::AddLockoutUser(
    PXPRESENCE_USER pUser,
    ULONGLONG qwLockoutID,
    LPSTR pszUserName
    )
{
    HRESULT hr = S_OK;
    DWORD   i  = 0;

    for (i = 0; i < pUser->cNumLockoutUsers; i += 1)
    {
        if (pUser->LockoutList[i].xuid.qwUserID == qwLockoutID)
        {
            break;
        }
    }

    pUser->LockoutList[i].xuid.qwUserID = qwLockoutID;

    if (pszUserName != NULL)
    {
        memcpy(pUser->LockoutList[i].username, pszUserName, strlen(pszUserName)+1);
    }

    if (i == pUser->cNumLockoutUsers)
    {
        pUser->cNumLockoutUsers = (WORD) (i + 1);
    }

    return hr;
}


//---------------------------------------------------------------------------
//
// RemoveLockoutUser()
//
HRESULT
CXo::RemoveLockoutUser(
    IN PXPRESENCE_USER pUser,
    IN ULONGLONG qwLockoutID
    )
{
    DWORD i = 0;
    BOOL fMatch = FALSE;

    for (i = 0; i < pUser->cNumLockoutUsers; i += 1)
    {
        if (pUser->LockoutList[i].xuid.qwUserID == qwLockoutID)
        {
            i += 1;
            fMatch = TRUE;
            break;
        }
    }

    for (; i < pUser->cNumLockoutUsers; i += 1)
    {
        pUser->LockoutList[i-1].xuid.qwUserID = pUser->LockoutList[i].xuid.qwUserID;
        memcpy(pUser->LockoutList[i-1].username, pUser->LockoutList[i].username, XONLINE_USERNAME_SIZE);
    }

    if (fMatch == TRUE)
    {
        pUser->cNumLockoutUsers -= 1;
    }

    return S_OK;
}


//---------------------------------------------------------------------------
//
// IsValidStateFlags()
//
BOOL
CXo::IsValidStateFlags(
    DWORD dwStateFlags
    )
{
    if (dwStateFlags == (dwStateFlags & (XONLINE_FRIENDSTATE_FLAG_ONLINE | XONLINE_FRIENDSTATE_FLAG_PLAYING | XONLINE_FRIENDSTATE_FLAG_CLOAKED | XONLINE_FRIENDSTATE_FLAG_VOICE | XONLINE_FRIENDSTATE_FLAG_JOINABLE)))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


//---------------------------------------------------------------------------
//
// IsValidNotificationType()
//
BOOL
CXo::IsValidNotificationType(DWORD dwType)
{
    if (dwType == XONLINE_NOTIFICATION_TYPE_ALL || (dwType == (dwType & (XONLINE_NOTIFICATION_TYPE_FRIENDREQUEST | XONLINE_NOTIFICATION_TYPE_FRIENDSTATUS | XONLINE_NOTIFICATION_TYPE_GAMEINVITE | XONLINE_NOTIFICATION_TYPE_GAMEINVITEANSWER))))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


//---------------------------------------------------------------------------
//
// NumGuests()
//
WORD
CXo::NumGuests(ULONGLONG qwUserID)
{
    DWORD i          = 0;
    WORD  wNumGuests = 0;

    for (i = 0; i < XONLINE_MAX_LOGON_USERS; i += 1)
    {
        if (m_rgLogonUsers[i].xuid.qwUserID == qwUserID && XOnlineIsUserGuest(m_rgLogonUsers[i].xuid.dwUserFlags))
        {
            wNumGuests += 1;
        }
    }

    return wNumGuests;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\sources.inc ===
C_DEFINES=$(C_DEFINES) -DNT -DXONLINE_BUILD_LIB$(LIBTAG)

#
# IMPORTANT: This is required for early online titles that includes the updated dash.
# This enables to code to detect the current dash version and allow autoupdate of the
# dash through the title. In the future, if we no longer ship the dash update with 
# online titles, we should remove this define tag.
#

C_DEFINES=$(C_DEFINES) -DDASH_UPDATE_IN_TITLE

INCLUDES=\
    $(BASEDIR)\public\sdk\inc;\
    $(BASEDIR)\private\inc\crypto;\
    $(BASEDIR)\private\ntos\inc;\
    $(BASEDIR)\private\ntos\fatx;\
    $(BASEDIR)\private\ntos\xapi\inc;\
    $(BASEDIR)\private\ntos\xapi\k32;\
    $(BASEDIR)\private\ntos\net;\
    $(BASEDIR)\private\online;

!if "$(LIBTAG)"=="W"
INCLUDES=$(BASEDIR)\public\wsdk\inc;$(INCLUDES)
UMTYPE=windows
!endif

TARGETPATH=$(BASEDIR)\public\sdk\lib
TARGETTYPE=LIBRARY

!if "$(LIBTAG)"=="X"
TARGETNAME=xonline$(D)
!endif

!if "$(LIBTAG)"=="S"
TARGETNAME=xonlines$(D)
SECTAG=s
!endif

!if "$(LIBTAG)"=="W"
TARGETNAME=xonlinew$(D)
SECTAG=w
!endif

MSC_WARNING_LEVEL=/W3 /WX /Ob1

!if defined(GENASM)
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /Fa
!endif

!if $(FREEBUILD) == 0
MSC_OPTIMIZATION=/Odi /Ob1
!endif

PRECOMPILED_INCLUDE=..\xonp.h
PRECOMPILED_PCH=xonp.pch
PRECOMPILED_OBJ=xonp.obj
PRECOMPILED_CXX=1

SOURCES=\
    stats.cpp \
    xonline.cpp \
    kerberos.cpp \
    krb5.cpp \
    msr_md5.cpp \
    md4ms.cpp \
    msasn1.cpp \
    autoupd.cpp \
    baseio.cpp \
    cfcache.cpp \
    contutil.cpp \
    contdl.cpp \
    contrm.cpp \
    contver.cpp \
    contenum.cpp \
    dirops.cpp \
    download.cpp \
    symmdec.cpp \
    upload.cpp \
    xontask.cpp \
    xrlutil.cpp \
    decalign.cpp \
    decblk.cpp \
    decin.cpp \
    decout.cpp \
    dectree.cpp \
    decuncmp.cpp \
    decverb.cpp \
    decxlat.cpp \
    maketbl.cpp \
    xonlzx.cpp \
    logon.cpp \
    match.cpp \
    service.cpp \
    users.cpp \
    presence.cpp \
    billing.cpp \
    xbosutil.cpp \
    localcache.cpp \
    msgclient.cpp \
    accounts.cpp \
    difpatch.cpp \
    patchutl.cpp \
    dvdload.cpp \
    olddash.cpp \

OBJLIBFILES=\
    $(BASEDIR)\private\ntos\net\libo$(SECTAG)\obj\*\xneto$(SECTAG)$(D).lib
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\patchutl.cpp ===
/*++

Copyright (c) Microsoft Corporation

Author:
    Keith Lau (keithlau)

Description:
	Module implementing patching utility functions

Module Name:

    patchutl.cpp

--*/

#include "xonp.h"
#include "xonver.h"

//
// Function to decode a compressed 32-bit unsigned quantity
//
PUCHAR
__fastcall
VariableLengthUnsignedDecode(
			IN  PUCHAR Buffer,
			IN	DWORD  *pcbBuffer,
			OUT PULONG ReturnValue
			)
{
	PUCHAR p = Buffer;
	ULONG Value = 0;
	ULONG Shift = 0;

	do
	{
		if (!*pcbBuffer)
			return(NULL);
		(*pcbBuffer)--;
		
		Value |= (( *p & 0x7F ) << Shift );
		Shift += 7;

	} while (( ! ( *p++ & 0x80 )) && ( Shift < 32 ));

	*ReturnValue = Value;

	return(p);
}

//
// Function to decode a compressed 32-bit signed quantity
//
PUCHAR
__fastcall
VariableLengthSignedDecode(
			IN  PUCHAR Buffer,
			IN	DWORD  *pcbBuffer,
			OUT PLONG  ReturnValue
			)
{
	PUCHAR p = Buffer;
	ULONG Shift;
	LONG  Value;

	Value = *p & 0x3F;
	Shift = 6;

	if ( ! ( *p++ & 0x80 )) 
	{
		do
		{
			if (!*pcbBuffer)
				return(NULL);
			(*pcbBuffer)--;
			
			Value |= (( *p & 0x7F ) << Shift );
			Shift += 7;
			
		} while (( ! ( *p++ & 0x80 )) && ( Shift < 32 ));
	}

	if ( *Buffer & 0x40 ) 
	{
		Value = -Value;
	}

	*ReturnValue = Value;

	return(p);
}

//
// Function to parse patch file information into our own structures
//
// Note: this function is kind of complicated because of the file
// format chosen by the MSR people. They really tried to squeeze out 
// every single extraneous byte out of the header. This is most
// prominently demonstrated by the optional fields and compressed
// 32-bit numbers. This makes it impossible for us to just overlay a
// fixed structure to access its constituent fields.
//
// There is no documentation on the format and I spent quite a while
// figuring this out, so I am documenting this so that we will not
// have to go back to the patching source code over and over to 
// get this info.
//
// The patch file header is described here. Fields are prefixed with
// the corresponding datatype. Of note, the vs and vu prefixes stand
// for variable-length signed and unsigned 32-bit values, respectively.
// see the decoding functions at the top of this file for details.
// A 'u' among fields indicate a union switched by the condidion 
// on the right. Fields marked with an 'x' indicates those that we
// will not support and thus will not be present in Xbox patch files.
//
// Main Header:
//
//	dwSignature
//	dwOptionFlags
//		|
//		+-	dwExtendedOptionFlags	(PATCH_OPTION_EXTENDED_OPTIONS) ----+
//x		+-	dwNewFileTime			(~PATCH_OPTION_NO_TIMESTAMP)		|
//x		+-	wNewFileCoffBase		(~PATCH_OPTION_NO_REBASE)			|
//x		|		+u	vsDelta				(dwNewFileTime != 0)			|
//x		|		+u	dwNewFileCoffTime	(dwNewFileTime == 0)			|
//x		+-							(~PATCH_OPTION_NO_RESTIMEFIX)		|
//x				+u	vsDelta				(NewFileCoffTime != 0)			|
//x				+u	dwNewFileResTime	(NewFileCoffTime == 0)			|
//																		|
//	vuNewFileSize														|
//	dwNewFileCRC														|
//			bWindowSizeBits -----( PATCH_OPTION_SPECIFIED_WINDOW )------+
//	bOldFileCount
//
// The main header is followed by bOldFileCount records, each indicating
// an old file version from which we know how to patch up to the current
// version. For Xbox patch files, bOldFileCount will always be 1, this is
// because the autoupdate front doors will always choose the right update
// package for us so we will not need multiple updateversions in a package.
//
// Subfields with a '*' next to is means the parent value indicates how 
// many sets of values there are (see bIgnoreRangeCount). Similarly, 
// fields with a 'x' to the left are not supported and thus omitted in
// Xbox patch files.
//
// Old File Record:
//
//	vsSizeDelta
//	dwOldFileCRC
//	bIgnoreRangeCount	(=0)
//x		+*	vsDelta
//x		+*	vuLength 	(bIgnoreRangeCount sets of {Delta, Length} pairs)
//	bRetainRangeCount	(=0)
//x		+*	vsDelta
//x		+*	vsDeltaNew
//x		+*	vuLength
//	vuRiftEntryCount	(=0)
//x		+*	vuDeltaPos
//x		+*	vsDeltaNew
//	vuCountInterleaveRanges	(dwOptionFlags & PATCH_OPTION_INTERLEAVE_FILES)
//		+*	vsDeltaOldOffset
//		+*	vsDeltaOldLength
//		+*	vsDeltaNewLength
//	vuPatchDataSize
//
// The following are more details about which flags are used in the Xbox
// patch file format:
//
// We use the following fixed values for dwOptionFlags:
// PATCH_OPTION_EXTENDED_OPTIONS |
// PATCH_OPTION_NO_TIMESTAMP |
// PATCH_OPTION_NO_REBASE |
// PATCH_OPTION_NO_RESTIMEFIX |
// PATCH_OPTION_INTERLEAVE_FILES
// 
// And the following fixed values for dwExtendedOptionFlags:
// PATCH_OPTION_SPECIFIED_WINDOW
//

//
// Define patch signature
//
#define PATCH_SIGNATURE				'91AP'

#define PATCH_OPTION_SPECIFIED_WINDOW   0x00010000  // lzx window size encoded
#define PATCH_OPTION_USE_LZX_A          0x00000001  // normal
#define PATCH_OPTION_USE_LZX_B          0x00000002  // better on some x86 binaries
#define PATCH_OPTION_USE_LZX_LARGE      0x00000004  // better support for large files (version 1.97 and higher)
#define PATCH_OPTION_NO_REBASE          0x00040000  // PE rebased image
#define PATCH_OPTION_NO_RESTIMEFIX      0x00400000  // PE resource timestamps
#define PATCH_OPTION_NO_TIMESTAMP       0x00800000  // don't store new file timestamp in patch
#define PATCH_OPTION_INTERLEAVE_FILES   0x40000000  // better support for large files (version 1.99 and higher)
#define PATCH_OPTION_RESERVED1          0x80000000  // (used internally)
#define PATCH_OPTION_EXTENDED_OPTIONS   PATCH_OPTION_RESERVED1

//
// Define the required set of options flags
//
#define	PATCH_REQUIRED_FLAGS	\
		(PATCH_OPTION_NO_REBASE |\
		 PATCH_OPTION_NO_RESTIMEFIX |\
		 PATCH_OPTION_USE_LZX_A)

//
// Define the optional flags
//
#define PATCH_OPTIONAL_FLAGS	\
		(PATCH_OPTION_EXTENDED_OPTIONS |\
		 PATCH_OPTION_NO_TIMESTAMP |\
		 PATCH_OPTION_INTERLEAVE_FILES |\
		 PATCH_OPTION_USE_LZX_LARGE)

//
// Define the set of invalid flags
//
#define PATCH_INVALID_FLAGS		\
		(~(PATCH_REQUIRED_FLAGS | PATCH_OPTIONAL_FLAGS))

//
// Define the smallest possible valid header size
//
#define PATCH_MIN_HEADER_SIZE		(28)

HRESULT ParsePatchHeader(
			PBYTE	pbData,
			DWORD	*pcbData,
			PBYTE	pbParsedData,
			DWORD	*pcbParsedData
			)
{
	HRESULT			hr = S_OK;
	PBYTE			pbCur = pbData;
	DWORD			cbData;
	DWORD			dwOutSize;
	DWORD			dwValue;
	DWORD			i;
	LONG			lValue;
	DWORD			RemainingNew;
	DWORD			LastOldOffset = 0;
	DWORD			LastOldLength = 0;
	DWORD			LastNewLength = 0;
	LONG			DeltaDeltaOldOffset;
	LONG			DeltaDeltaOldLength;
	LONG			DeltaNewLength;
	LONG			LastDeltaOldOffset = 0;
	LONG			LastDeltaOldLength = 0;
	PAUTOUPD_PATCH_FILE_INFO	pInfo;
	PAUTOUPD_INTERLEAVE_ENTRY	pEntry;

	BOOL			fWindowSpecified = FALSE;
	BOOL			fTimeStamp = FALSE;
	BOOL			fInterleaveMap = FALSE;
		
	Assert(pbData);
	Assert(pcbData);
	Assert(pbParsedData);
	Assert(pcbParsedData);

	cbData = *pcbData;
	if (cbData < PATCH_MIN_HEADER_SIZE)
		goto InvalidData;			
		
	dwOutSize = sizeof(AUTOUPD_PATCH_FILE_INFO);		
	if (*pcbParsedData < dwOutSize)
		goto InsufficientBuffer;

	// Overlay the info struct
	pInfo = (PAUTOUPD_PATCH_FILE_INFO)pbParsedData;
	pInfo->dwDataSize = 0;
	pInfo->dwCurrent = 0;
	pInfo->dwTargetWritten = 0;
	pInfo->dwInterleaveCurrent = 0;

	// Verify signature		
	if (PATCH_SIGNATURE != *(DWORD *)pbCur)
		goto InvalidData;
	pbCur += sizeof(DWORD);
	cbData -= sizeof(DWORD);

	// Get and verify options
	dwValue = *(DWORD *)pbCur;
	pbCur += sizeof(DWORD);
	cbData -= sizeof(DWORD);
	if (((dwValue & PATCH_REQUIRED_FLAGS) != PATCH_REQUIRED_FLAGS) ||
		((dwValue & PATCH_INVALID_FLAGS) != 0))
		goto InvalidData;

	// Timestamp is stored reversed 
	dwValue ^= PATCH_OPTION_NO_TIMESTAMP;

	// Check for explicit Interleave map 
	fInterleaveMap = ((dwValue & PATCH_OPTION_INTERLEAVE_FILES) != 0);
	fTimeStamp = ((dwValue & PATCH_OPTION_NO_TIMESTAMP) == 0);

	// Check for extended options
	if (dwValue & PATCH_OPTION_EXTENDED_OPTIONS)
	{
		// Get and verify extended options
		dwValue = *(DWORD *)pbCur;
		pbCur += sizeof(DWORD);
		cbData -= sizeof(DWORD);

		// Currently we only support window size specification
		if (dwValue & PATCH_OPTION_SPECIFIED_WINDOW)
			fWindowSpecified = TRUE;
	}

	// Skip over timestamp
	if (fTimeStamp)
	{
		pbCur += sizeof(DWORD);
		cbData -= sizeof(DWORD);
	}

	// Get new file size
	pbCur = VariableLengthUnsignedDecode(
				pbCur, &cbData, &(pInfo->dwNewFileSize));
	if (!pbCur)
		goto InvalidData;

	// Skip CRC 
	if (cbData < sizeof(DWORD))
		goto InvalidData;
	pbCur += sizeof(DWORD);
	cbData -= sizeof(DWORD);

	if (fWindowSpecified)
	{
		// Get window size
		if (cbData < sizeof(BYTE))
			goto InvalidData;
		pInfo->dwWindowSizeBits = *pbCur;
		pbCur += sizeof(BYTE);
		cbData -= sizeof(BYTE);
	}

	// Get old file count
	if (cbData < sizeof(BYTE))
		goto InvalidData;
	Assert(*pbCur == 1);
	if (*pbCur != 1)
		goto InvalidData;
	pbCur += sizeof(BYTE);
	cbData -= sizeof(BYTE);

	// Get the file size delta
	pbCur = VariableLengthSignedDecode(pbCur, &cbData, &lValue);
	if (!pbCur)
		goto InvalidData;

	if ((lValue + pInfo->dwNewFileSize) < (LONG)0)
		goto InvalidData;
	pInfo->dwOldFileSize = lValue + pInfo->dwNewFileSize;

	// Skip CRC 
	if (cbData < sizeof(DWORD))
		goto InvalidData;
	pbCur += sizeof(DWORD);
	cbData -= sizeof(DWORD);

	// Ignore and retain ranges should be 0
	if (cbData < sizeof(WORD))
		goto InvalidData;
	if (*(WORD *)pbCur != 0)
		goto InvalidData;
	pbCur += sizeof(WORD);
	cbData -= sizeof(WORD);

	// Get Rift entry count, should be zero
	pbCur = VariableLengthUnsignedDecode(
				pbCur, &cbData, &dwValue);
	if (!pbCur)
		goto InvalidData;
	Assert(dwValue == 0);
	if (dwValue != 0)
		goto InvalidData;

	// Set up for interleave map
	RemainingNew = pInfo->dwNewFileSize;
	LastOldOffset = 0;
	LastOldLength = 0;
	LastNewLength = 0;
	LastDeltaOldOffset = 0;
	LastDeltaOldLength = 0;

	if (fInterleaveMap)
	{
		// Get the interleave map entry count
		pbCur = VariableLengthUnsignedDecode(
					pbCur, &cbData, &(pInfo->dwInterleaveEntries));
		if (!pbCur)
			goto InvalidData;

		// Make sure the output buffer is big enough
		Assert(pInfo->dwInterleaveEntries > 0);
		if (!pInfo->dwInterleaveEntries)
			goto InvalidData;
			
		dwOutSize += ((pInfo->dwInterleaveEntries - 1) * 
					sizeof(AUTOUPD_INTERLEAVE_ENTRY));
		if (*pcbParsedData < dwOutSize)				
			goto InsufficientBuffer;

		// Load the interleave map entries
		for (i = 0; i < pInfo->dwInterleaveEntries; i++)
		{
			pEntry = &(pInfo->rgInterleaveInfo[i]);

			pbCur = VariableLengthSignedDecode(
						pbCur, &cbData, &DeltaDeltaOldOffset);
			if (!pbCur)
				goto InvalidData;
			pbCur = VariableLengthSignedDecode(
						pbCur, &cbData, &DeltaDeltaOldLength);
			if (!pbCur)
				goto InvalidData;

			LastDeltaOldOffset += DeltaDeltaOldOffset;
			LastDeltaOldLength += DeltaDeltaOldLength;

			LastOldLength  += LastDeltaOldLength;
			LastOldOffset  += LastDeltaOldOffset;

			pEntry->dwOldOffset = LastOldOffset;
			pEntry->dwOldLength = LastOldLength;

			if ((LastOldOffset + LastOldLength) > pInfo->dwOldFileSize)
				goto InvalidData;

			if (i < (pInfo->dwInterleaveEntries - 1)) 
			{
				pbCur = VariableLengthSignedDecode(
							pbCur, &cbData, &DeltaNewLength);
				if (!pbCur)
					goto InvalidData;

				DeltaNewLength *= CHUNK_SIZE;	// LZX specific
				LastNewLength  += DeltaNewLength;

				pEntry->dwNewLength = LastNewLength;

				if (RemainingNew < LastNewLength)
					goto InvalidData;

				RemainingNew -= LastNewLength;
			}
			else 
			{
			    pEntry->dwNewLength = RemainingNew;
			}
		}
	}
	else
	{
		// There is only one interleaved section, mark the section
		// as the entire file (size will be validated later)
		pInfo->dwInterleaveEntries = 1;
		
		pEntry = &(pInfo->rgInterleaveInfo[0]);
		pEntry->dwOldOffset = 0;
		pEntry->dwOldLength = pInfo->dwOldFileSize;
	    pEntry->dwNewLength = RemainingNew;
	}

	// Finally, get the patch data size
	pbCur = VariableLengthUnsignedDecode(
				pbCur, &cbData, &(pInfo->dwPatchDataSize));
	if (!pbCur)
		goto InvalidData;

	// Return the actual header data size
	*pcbData = pbCur - pbData;

	// Return the parsed data size
	*pcbParsedData = dwOutSize;

Exit:
	return(hr);

InsufficientBuffer:
	hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
	goto Error;

InvalidData:
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);

Error:
	goto Exit;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\symmdec.cpp ===
/*++

Copyright (c) Microsoft Corporation

Author:
    Keith Lau   (keithlau)

Description:
	Implementation of piecemeal decryption routines using a
	symmetric key and the RC4-SHA1 Hmac algorithm.

Module Name:

	symmdec.c

--*/

#include "xonp.h"
#include "xonver.h"
#include <shahmac.h>

//
// API to initialize decryption context
//
HRESULT CXo::SymmdecInitialize(
			PBYTE					pbKey,
			DWORD					cbKey,
			DWORD					cbLength,
			PRC4_SHA_HEADER			pHeader,
			PXONLINESYMMDEC_CONTEXT	psymmdec
			)
{
	BYTE		rgbLocalKey[XC_DIGEST_LEN];
	BYTE		rgbConfounder[RC4_CONFOUNDER_LEN];

	Assert(pbKey != NULL);
	Assert(cbKey >= sizeof(DWORD));
	Assert(cbLength > 0);
	Assert(pHeader != NULL);
	Assert(psymmdec != NULL);

	// Set up the members of psymmdec
	psymmdec->cbLength = cbLength;
	psymmdec->dwCurrent = 0;
	psymmdec->pbKey = pbKey;
	psymmdec->cbKey = cbKey;
	memcpy(psymmdec->rgbChecksum, pHeader->Checksum, XC_DIGEST_LEN);

	// First, figure out our local key
	XShaHmacInitialize(pbKey, cbKey, psymmdec->shactx);
	XShaHmacUpdate(psymmdec->shactx, 
				pHeader->Checksum, XC_DIGEST_LEN);
	XShaHmacComputeFinal(psymmdec->shactx, 
				pbKey, cbKey, rgbLocalKey);

	// Establish our local key in the RC4 context
    XcRC4Key(psymmdec->rc4ctx, XC_DIGEST_LEN, rgbLocalKey);

	// Now, figure out the original confounder
	memcpy(rgbConfounder, pHeader->Confounder, RC4_CONFOUNDER_LEN);
	XcRC4Crypt(psymmdec->rc4ctx, RC4_CONFOUNDER_LEN, rgbConfounder);

	// Now, restart the SHA1-Hmac to compute the checksum of the
	// original confounder and the decrypted data
	XShaHmacInitialize(pbKey, cbKey, psymmdec->shactx);
	XShaHmacUpdate(psymmdec->shactx, 
				rgbConfounder, RC4_CONFOUNDER_LEN);
	
    return(S_OK);
}

//
// API to decrypt a buffer one piece at a time, decryption
// happens in-place.
//
HRESULT CXo::SymmdecDecrypt(
			PXONLINESYMMDEC_CONTEXT	psymmdec,
			PBYTE					pbData,
			DWORD					cbData
			)
{
	Assert(pbData != NULL);
	Assert(cbData >= 0);
	Assert(psymmdec != NULL);

	// Too much data is bad
	if ((psymmdec->cbLength != XONLINESYMMDEC_UNKNOWN_LENGTH) && 
		((psymmdec->dwCurrent + cbData) > psymmdec->cbLength))
		return(HRESULT_FROM_WIN32(ERROR_BAD_LENGTH));

	// Decrypt the data ...
	XcRC4Crypt(psymmdec->rc4ctx, cbData, pbData);

	// Update the Hmac with the decrypted data
	XShaHmacUpdate(psymmdec->shactx, pbData, cbData);

	// Track how much data we've processed
	psymmdec->dwCurrent += cbData;

	return(S_OK);
}

//
// API to terminate a decryption session. This makes sure
// the data processed equals the expected length of the encrypted
// block. The SHA1-Hmac checksum is also compared agains the 
// original checksum.
//
HRESULT CXo::SymmdecVerify(
			PXONLINESYMMDEC_CONTEXT	psymmdec
			)
{
	BYTE		rgbChecksum[XC_DIGEST_LEN];

	Assert(psymmdec != NULL);

	// Too much or too little data is bad
	if ((psymmdec->cbLength != XONLINESYMMDEC_UNKNOWN_LENGTH) && 
		(psymmdec->dwCurrent != psymmdec->cbLength))
		return(HRESULT_FROM_WIN32(ERROR_BAD_LENGTH));

	// Compute the final Hmac checksum, and make sure it matches
	// with the original checksum.
	XShaHmacComputeFinal(psymmdec->shactx, 
				psymmdec->pbKey, psymmdec->cbKey, rgbChecksum);	
	if (memcmp(psymmdec->rgbChecksum, rgbChecksum, XC_DIGEST_LEN) != 0)
		return(HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
		
	return(S_OK);
}

//
// API to return the number of bytes still expected by the decoder
//
HRESULT CXo::SymmdecGetRemainingCount(
			PXONLINESYMMDEC_CONTEXT	psymmdec,
			PDWORD					pdwBytesRemaining
			)
{
	Assert(psymmdec != NULL);
	Assert(pdwBytesRemaining != NULL);

	if (psymmdec->cbLength == XONLINESYMMDEC_UNKNOWN_LENGTH)
		*pdwBytesRemaining = XONLINESYMMDEC_UNKNOWN_LENGTH;
	else if (psymmdec->dwCurrent > psymmdec->cbLength)
		*pdwBytesRemaining = 0;
	else 
		*pdwBytesRemaining = psymmdec->cbLength - psymmdec->dwCurrent;

	return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\stats.cpp ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved

Description:
    Module implementing Xbox Statistics APIs

Module Name:

    stats.cpp

--*/

#include "xonp.h"
#include "xonver.h"

HRESULT
CXo::XOnlineStatSet(
    IN DWORD dwNumStatsSpecs,
    IN PXONLINE_STAT_SPEC pStatSpecs,
    IN HANDLE hWorkEvent,
    OUT PXONLINETASK_HANDLE phTask
)
{
    return E_NOTIMPL;
}

HRESULT 
CXo::XOnlineStatGet(
    IN DWORD dwNumStatSpecs,
    IN OUT PXONLINE_STAT_SPEC pStatSpecs,
    IN HANDLE hWorkEvent,
    OUT PXONLINETASK_HANDLE phTask
)
{
    return E_NOTIMPL;
}

HRESULT 
CXo::XOnlineStatLeaderEnumerate(
	IN XUID* pxuidPagePivot,                           
	IN DWORD dwPageStart,                                              
	IN DWORD dwPageSize,
	IN DWORD dwLeaderboardID,
	IN DWORD dwNumStatsPerUser,
	IN DWORD *pStatsPerUser,
	OUT PXONLINE_STAT_USER pUsers,
	OUT PXONLINE_STAT pStats,
	IN HANDLE hWorkEvent,
	OUT PXONLINETASK_HANDLE phTask
)
{
    return E_NOTIMPL;
}

HRESULT
CXo::XOnlineStatLeaderEnumerateGetResults(
    IN XONLINETASK_HANDLE hTask,
    OUT DWORD *pdwReturnedResults
)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\upload.cpp ===
/*++

Copyright (c) Microsoft Corporation

Author:
    Keith Lau (keithlau)

Description:
	Module implementing XRL upload APIs:
		XOnlineUploadFromMemory
		XOnlineUploadFile

Module Name:

    upload.c

--*/

#include "xonp.h"
#include "xonver.h"

//
// Define enumerated types that describe the states for each operation
//
typedef enum
{
	xrlulPreConnect = 0,
	xrlulConnect,
	xrlulReadData,
	xrlulSendData,
	xrlulReceiveStatus,
	xrlulPostUpload,
	xrlulCleanup,
	xrlulDone

} XON_UPLOAD_STATES;

typedef enum
{
	xrlufmDone = 0,

} XON_UPLOAD_FROM_MEMORY_STATES;

typedef enum
{
	xrlufReadData = 0,
	xrlufDone

} XON_UPLOAD_FILE_STATES;

//
// ==============================================================
//   S T A T E   M A C H I N E   D E F I N I T I O N S
// ==============================================================
//

// Define the state machines for XOnlineUpload

//
// State 0: Pre-connect extension state
//
HRESULT CXo::xrlulPreConnectHandler(
			PXRL_ASYNC	pxrlasync
			)
{
	HRESULT					hr = S_OK;
	PXRL_UPLOAD_EXTENSION	pxrlulext = &(pxrlasync->xrlext.ul);

    Assert(pxrlulext->hTaskPreConnect != NULL);

	// Simple logic: keep pumping the handle until we are told to 
	// stop, then move on to the connect phase
	hr = XOnlineTaskContinue(
				pxrlulext->hTaskPreConnect
				);
	if (XONLINETASK_STATUS_AVAILABLE(hr))
	{
		// The task had returned results, see if it succeeded
		if (FAILED(hr))
			goto Error;

		// See if the pre-connect task actually tells us to skip
		// the wire talk and skip right to the post-process
		if (hr == XONLINE_S_XRL_EXTENSION_SKIP_TO_POST)
		{
			hr = S_OK;
			
			// see if there is any post-upload work
			if (pxrlulext->hTaskPostUpload)
			{
				// Make sure we initialize the task using the supplied callback
				if (pxrlulext->pfnInitializeTask)
				{
					hr = (this->*(pxrlulext->pfnInitializeTask))(
								xrlulextPostUpload, pxrlasync, 
								pxrlulext->hTaskPostUpload);
					if (FAILED(hr))
						goto Error;
				}

				// Got post download work, do that
				pxrlasync->dwCurrentState = xrlulPostUpload;
				goto Cleanup;
			}
			else
			{
				// Nope, jump right to cleanup
				pxrlasync->dwCurrentState = xrlulCleanup;
			}

			goto Cleanup;
		}
		
	    // Connect to the service asynchronously
	    hr = XRL_AsyncConnect(pxrlasync);
	    if (FAILED(hr))
    	    goto Error;

		// Set the next state
		pxrlasync->dwCurrentState = xrlulConnect;
	}

Cleanup:
	return(S_OK);

Error:
	// We encountered a hard error. Set next state to done.
	pxrlasync->hrFinal = hr;
	pxrlasync->dwCurrentState = xrlulCleanup;
	goto Cleanup;
}

//
// State 1: wait for connect loop
//
HRESULT CXo::xrlulConnectHandler(
			PXRL_ASYNC	pxrlasync
			)
{
	HRESULT					hr = S_OK;
	XONLINETASK_HANDLE		hsockio = (XONLINETASK_HANDLE)&(pxrlasync->sockio);
	PXRL_UPLOAD_EXTENSION	pxrlulext = &(pxrlasync->xrlext.ul);

	// Continue until the connect completes asynchronously
	hr = XOnlineTaskContinue(hsockio);
	if (XONLINETASK_STATUS_AVAILABLE(hr))
	{
		// Connect had returned results, see if it succeeded
		if (FAILED(hr))
			goto Error;

		// Reset the read and send counters
		pxrlasync->uliTotalReceived.QuadPart = 0;
		pxrlasync->uliTotalWritten.QuadPart = 0;
		pxrlasync->dwCurrent = 0;

		// Mark the fact that this is the first packet being sent
		// and save the header size in dwTemp. 
		//
		// NOTE: This means that the headers must not change from
		// this point on.
		pxrlasync->dwFlags |= XRL_SEND_DATA_CONTAINS_HEADERS;
		pxrlasync->dwTemp = pxrlasync->wsabuf.len;

		// Move on the the read data phase. This is mandatory for uploads
		// Make sure we initialize the task using the supplied callback
		if (pxrlulext->pfnInitializeTask)
		{
			hr = (this->*(pxrlulext->pfnInitializeTask))(xrlulextReadData, pxrlasync, pxrlulext->hTaskReadData);
			if (FAILED(hr))
				goto Error;
		}

		// Jump to the process data state
		pxrlasync->dwCurrentState = xrlulReadData;
	}

Cleanup:
	return(S_OK);

Error:
	// We encountered a hard error. Set next state to done.
	pxrlasync->hrFinal = hr;
	pxrlasync->dwCurrentState = xrlulCleanup;
	goto Cleanup;
}

//
// State 2: Read Data extension state
//
// Note: upon completing this state, the subtask must have read in the
// data to send to the server and set pxrlasync->wsabuf.buf to point to
// the first byte to send, and pxrlasync->wsabuf.len to the size of
// the send buffer. Upload will loop through ReadData-SendData until the
// number of bytes specified in uliContentLength
//
HRESULT CXo::xrlulReadDataHandler(
			PXRL_ASYNC	pxrlasync
			)
{
	HRESULT					hr = S_OK;
	PXRL_UPLOAD_EXTENSION	pxrlulext = &(pxrlasync->xrlext.ul);

    Assert(pxrlulext->hTaskReadData != NULL);

	// Simple logic: keep pumping the handle until we are told to 
	// stop, then move on to the connect phase
	hr = XOnlineTaskContinue(
				pxrlulext->hTaskReadData);
	if (XONLINETASK_STATUS_AVAILABLE(hr))
	{
		// The task had returned results, see if it succeeded
		if (FAILED(hr))
			goto Error;

		// We expect the data to be sent out to be in pxrlasync->wsabuf
		// so we just kick off the send now
		SendRecvInitializeContext(pxrlasync->sockio.socket,
					&pxrlasync->wsabuf, 1, 0, 
					pxrlasync->xontask.hEventWorkAvailable, &pxrlasync->sockio);

		hr = SendInternal(&pxrlasync->sockio);
		if (FAILED(hr))
			goto Error;

		// Go to send data state
		pxrlasync->dwCurrentState = xrlulSendData;
	}

Cleanup:
	return(S_OK);

Error:
	// We encountered a hard error. Set next state to done.
	pxrlasync->hrFinal = hr;
	pxrlasync->dwCurrentState = xrlulCleanup;
	goto Cleanup;
}

//
// State 3: send data loop
//
HRESULT CXo::xrlulSendDataHandler(PXRL_ASYNC pxrlasync)
{
	HRESULT					hr = S_OK;
	DWORD					dwBytesSent;
	DWORD					dwContentBytesSent;
	XONLINETASK_HANDLE		hsockio = (XONLINETASK_HANDLE)&(pxrlasync->sockio);
	PXRL_UPLOAD_EXTENSION	pxrlulext = &(pxrlasync->xrlext.ul);

	// Continue until the send completes asynchronously
	hr = XOnlineTaskContinue(hsockio);
	if (XONLINETASK_STATUS_AVAILABLE(hr))
	{
		// Send had returned results, see if it succeeded
		if (FAILED(hr))
			goto Error;

		// Succeeded, now get the results and analyze the data
		hr = GetSendRecvResults(hsockio, &dwBytesSent, NULL, NULL);
		if (FAILED(hr))
			goto Error;

		// We make a distinction between how many bytes sent, and how
		// many content bytes (i.e. excluding headers) sent.
		dwContentBytesSent = dwBytesSent;

		// If the sent packet contains headers, we will subtract the
		// header size because what we are really tracking is content
		if (pxrlasync->dwFlags & XRL_SEND_DATA_CONTAINS_HEADERS)
		{
            Assert(dwContentBytesSent >= pxrlasync->dwTemp);
			dwContentBytesSent -= pxrlasync->dwTemp;
			pxrlasync->dwTemp = 0;
			pxrlasync->dwFlags &= (~XRL_SEND_DATA_CONTAINS_HEADERS);
		}

		// Track how much we've sent
		pxrlasync->uliTotalWritten.QuadPart += dwContentBytesSent;

		// See if we're done completely
		hr = (this->*(pxrlulext->pfnCompleted))((PVOID)pxrlasync);
		if (FAILED(hr))
			goto Error;
		
		if (hr == S_OK)
		{
			// Yup, we've uploaded everything. Now kick off a receive to
			// get the final server response
			pxrlasync->wsabuf.buf = (char *)pxrlasync->pBuffer;
			pxrlasync->wsabuf.len = pxrlasync->cbBuffer;
			
			SendRecvInitializeContext(pxrlasync->sockio.socket,
						&pxrlasync->wsabuf, 1, 0, 
						pxrlasync->xontask.hEventWorkAvailable, &pxrlasync->sockio);

			hr = RecvInternal(&pxrlasync->sockio);
			if (FAILED(hr))
				goto Error;

			// Reset the receive counter
			pxrlasync->uliTotalReceived.QuadPart = 0;
			pxrlasync->uliContentLength.QuadPart = 0;
			pxrlasync->dwCurrent = 0;
			pxrlasync->dwTemp = XRL_FLAG_HEADER_MODE;

			// Set next state	
			pxrlasync->dwCurrentState = xrlulReceiveStatus;
			goto Cleanup;
		}

		// Not done yet, see if we sent everything already
		if (dwBytesSent < pxrlasync->wsabuf.len)
		{
			// The whole buffer was not sent out yet, adjust the buffer and 
			// do another send.
			pxrlasync->wsabuf.buf += dwBytesSent;
			pxrlasync->wsabuf.len -= dwBytesSent;
			
			SendRecvInitializeContext(pxrlasync->sockio.socket,
						&pxrlasync->wsabuf, 1, 0, 
						pxrlasync->xontask.hEventWorkAvailable, &pxrlasync->sockio);

			hr = SendInternal(&pxrlasync->sockio);
			if (FAILED(hr))
				goto Error;
		}
		else
		{
			// We're done sneding the entire buffer. Now since we still have
			// more data to upload, we will jump back to the Read data state
			pxrlasync->wsabuf.buf = (char *)pxrlasync->pBuffer;
			pxrlasync->wsabuf.len = 0;
			
			if (pxrlulext->pfnInitializeTask)
			{
				hr = (this->*(pxrlulext->pfnInitializeTask))(xrlulextReadData, pxrlasync, pxrlulext->hTaskReadData);
				if (FAILED(hr))
					goto Error;
			}

			pxrlasync->dwCurrentState = xrlulReadData;
		}
	}

Cleanup:
	return(S_OK);

Error:
	// We encountered a hard error. Set next state to done.
	pxrlasync->hrFinal = hr;
	pxrlasync->dwCurrentState = xrlulCleanup;
	goto Cleanup;
}

//
// State 4: Receive final HTTP response loop
//
HRESULT CXo::xrlulReceiveStatusHandler(PXRL_ASYNC pxrlasync)
{
	HRESULT					hr = S_OK;
	DWORD					dwBytesRead;
	BOOL					fDoneHeaders;
	XONLINETASK_HANDLE		hsockio = (XONLINETASK_HANDLE)&(pxrlasync->sockio);
	PXRL_UPLOAD_EXTENSION	pxrlulext = &(pxrlasync->xrlext.ul);

	// Continue until the receive completes asynchronously
	hr = XOnlineTaskContinue(hsockio);
	if (XONLINETASK_STATUS_AVAILABLE(hr))
	{
		// Receive had returned results, see if it succeeded
		if (FAILED(hr))
			goto Error;

		// Succeeded, now get the results and analyze the data
		hr = GetSendRecvResults(hsockio, &dwBytesRead, NULL, NULL);
		if (FAILED(hr))
			goto Error;

		// If zero bytes were read, then the server has closed connection
		if (dwBytesRead)
		{
			// We read something, analyze the data
			hr = XRL_ProcessHttp(pxrlasync, dwBytesRead, &fDoneHeaders);
			if (SUCCEEDED(hr))
			{
				if (fDoneHeaders)
				{
					// Call extension to process the header information
					hr = (this->*(pxrlulext->pfnResponseHeaders))(pxrlasync);
					if (FAILED(hr))
						goto Error;

				    // Adjust response size to exclude header stuff
					pxrlasync->uliTotalReceived.QuadPart += pxrlasync->dwCurrent;
				}
				else if (!IS_HEADER_MODE(pxrlasync))
				{
					// Track how much response data we received
					pxrlasync->uliTotalReceived.QuadPart += dwBytesRead;
					pxrlasync->dwCurrent = dwBytesRead;
				}
			}
		}
		else
		{
			// Zero bytes read, this means that the server has closed connection.
			// this cannot be a graceful case, because if we already got all the 
			// data we expected, will will not be here asking for more data. We
			// treat this as an error case.
			hr = HRESULT_FROM_WIN32(WSAECONNRESET);
		}

		if (FAILED(hr))
			goto Error;

		// We will proceed to read data from disk if the following two conditions
		// are true:
		// 1) No longer parsing headers AND
		// 2a) The expected content has been read OR
		// 2b) We already filled up the receive buffer
		if (!IS_HEADER_MODE(pxrlasync) &&
			((pxrlasync->uliTotalReceived.QuadPart >= pxrlasync->uliContentLength.QuadPart) ||
			 (pxrlasync->uliTotalReceived.u.LowPart >= pxrlasync->cbBuffer)))
		{
			// The upload actually finished. Gracefully close the connection
			shutdown(pxrlasync->sockio.socket, SD_BOTH);
		
			// see if there is any post-upload work
			if (pxrlulext->hTaskPostUpload)
			{
				// Make sure we initialize the task using the supplied callback
				if (pxrlulext->pfnInitializeTask)
				{
					hr = (this->*(pxrlulext->pfnInitializeTask))(xrlulextPostUpload, pxrlasync, pxrlulext->hTaskPostUpload);
					if (FAILED(hr))
						goto Error;
				}

				// Got post download work, do that
				pxrlasync->dwCurrentState = xrlulPostUpload;
				goto Cleanup;
			}
			else
			{
				// Nope, jump right to cleanup
				pxrlasync->dwCurrentState = xrlulCleanup;
			}
		}
		else
		{
			// We need more data, adjust the read buffer position and post 
			// another receive
			pxrlasync->wsabuf.buf = (char *)(pxrlasync->pBuffer + pxrlasync->dwCurrent);
			pxrlasync->wsabuf.len = pxrlasync->cbBuffer - pxrlasync->dwCurrent;
			
			SendRecvInitializeContext(pxrlasync->sockio.socket,
						&pxrlasync->wsabuf, 1, 0, 
						pxrlasync->xontask.hEventWorkAvailable, &pxrlasync->sockio);

			hr = RecvInternal(&pxrlasync->sockio);
			if (FAILED(hr))
				goto Error;
		}
	}

Cleanup:
	return(S_OK);

Error:
	// We encountered a hard error. Set next state to cleanup.
	pxrlasync->hrFinal = hr;
	pxrlasync->dwCurrentState = xrlulCleanup;
	goto Cleanup;
}

//
// State 5: Post-upload extension state
//
HRESULT CXo::xrlulPostUploadHandler(
			PXRL_ASYNC	pxrlasync
			)
{
	HRESULT					hr = S_OK;
	PXRL_UPLOAD_EXTENSION	pxrlulext = &(pxrlasync->xrlext.ul);

    Assert(pxrlulext->hTaskPostUpload != NULL);

	// Simple logic: keep pumping the handle until we are told to 
	// stop, then move on to the connect phase
	hr = XOnlineTaskContinue(pxrlulext->hTaskPostUpload);
	if (XONLINETASK_STATUS_AVAILABLE(hr))
	{
		// The task had returned results, see if it succeeded
		if (FAILED(hr))
			goto Error;

		// Alright, we're all done, jump right to cleanup
		pxrlasync->dwCurrentState = xrlulCleanup;
	}

Cleanup:
	return(S_OK);

Error:
	// We encountered a hard error. Set next state to done.
	pxrlasync->hrFinal = hr;
	pxrlasync->dwCurrentState = xrlulCleanup;
	goto Cleanup;
}

//
// State 6: cleanup
//
HRESULT CXo::xrlulCleanupHandler(PXRL_ASYNC pxrlasync)
{
	// Call the generic handler
	XRL_CleanupHandler(pxrlasync);
	
	// We are done
	pxrlasync->dwCurrentState = xrlulDone;

	return(S_OK);
}

//
// Array
// of handlers for XOnlineUploadFromMemory
//
const PFNXRL_HANDLER CXo::s_rgpfnxrlulHandlers[] =
{
    CXo::xrlulPreConnectHandler,
    CXo::xrlulConnectHandler,
    CXo::xrlulReadDataHandler,
    CXo::xrlulSendDataHandler,
    CXo::xrlulReceiveStatusHandler,
    CXo::xrlulPostUploadHandler,
    CXo::xrlulCleanupHandler
};

//
// Implement the top-level do work function
//
HRESULT CXo::xrlulContinue(XONLINETASK_HANDLE hTask)
{
	return(XRL_MainContinue(hTask, s_rgpfnxrlulHandlers, xrlulDone));
}				

// Function to kick off uploading a memory buffer to the server
HRESULT CXo::Upload(
			LPCSTR			szTargetPath, 
			PBYTE			pbExtraHeaders,
			DWORD			cbExtraHeaders,
			PXRL_ASYNC		pxrlasync
			)
{
	HRESULT					hr = S_OK;
	PXRL_UPLOAD_EXTENSION	pxrlulext = &(pxrlasync->xrlext.ul);

    Assert(NULL != szTargetPath);
    Assert(NULL != pxrlasync);
    Assert(!cbExtraHeaders || pbExtraHeaders);
    Assert(!cbExtraHeaders || cbExtraHeaders < XRL_MAX_EXTRA_HEADER_SIZE);

    // Make sure the required callbacks are supplied
    Assert(NULL != pxrlasync->xrlext.ul.pfnCompleted);
    Assert(NULL != pxrlasync->xrlext.ul.pfnResponseHeaders);
    Assert(NULL != pxrlasync->xrlext.ul.hTaskReadData);

	// Modify nothing except fill in our work function
	pxrlasync->xontask.pfnContinue = xrlulContinue;
	pxrlasync->xontask.pfnClose = XRL_MainClose;

	// The socket API requires that we have an event handle in order
	// for the async I/O to happen. If the caller has not provided us
	// with an event, we have to create it here
	hr = XRL_CreateWorkEventIfNecessary(pxrlasync, NULL);
	if (FAILED(hr))
		goto Error;

	// Make sure the event is set
	SetEvent(pxrlasync->xontask.hEventWorkAvailable);

	// Mark as upload
	pxrlasync->fDownload = FALSE;

	// Determine the next state depending on whether we have
	// any pre-connect work to do ...
	if (pxrlulext->hTaskPreConnect)
	{
		// Make sure we initialize the task using the supplied callback
		if (pxrlulext->pfnInitializeTask)
		{
			hr = (this->*(pxrlulext->pfnInitializeTask))(xrlulextPreConnect, pxrlasync, pxrlulext->hTaskPreConnect);
			if (FAILED(hr))
				goto Error;
		}

    	// Next state is the pre-connect handler
		pxrlasync->dwCurrentState = xrlulPreConnect;
	}
	else
	{
	    // We have no pre-connect work, so just connect to the
	    // service asynchronously
	    hr = XRL_AsyncConnect(pxrlasync);
	    if (FAILED(hr))
    	    goto Error;

    	// Next state is the connect handler
		pxrlasync->dwCurrentState = xrlulConnect;
	}

    // Build the request headers, save the request size (i.e. send
    // buffer size) in pxrlasync->wsabuf for transmission later
	pxrlasync->wsabuf.len = pxrlasync->cbBuffer;
	pxrlasync->wsabuf.buf = (char *)pxrlasync->pBuffer;

    // Build the request headers, we pull most of the data from 
    // pxrlasync.
    //
    // There are cases where the IP address is not known until 
    // after the PreConnect phase. We will allow that. 
    if (pxrlasync->serviceInfo.dwServiceID != XONLINE_INVALID_SERVICE)
    {
	    hr = XRL_BuildPostRequest(
	   				pxrlasync->serviceInfo.dwServiceID,
	    			szTargetPath,
	   				pxrlasync->serviceInfo.serviceIP.s_addr,
	    			(char *)pxrlasync->pBuffer, 
	    			&(pxrlasync->wsabuf.len), 
	    			pbExtraHeaders,
	    			cbExtraHeaders,
	    			pxrlasync->uliFileSize);
	}
	else if (pxrlulext->hTaskPreConnect == NULL)
	{
		AssertSz(FALSE, "Uninitialized Service");
		hr = E_INVALIDARG;
	}
    if (FAILED(hr))
        goto Error;
	
    // Initialize the last state change
    pxrlasync->dwLastStateChange = GetTickCount();

Cleanup:	
	return(hr);

Error:
	XRL_CleanupHandler(pxrlasync);
	goto Cleanup;
}

//
// Define the extension functions for XOnlineUploadFromMemory
//

//
// This determines if the entire upload is complete
//
// Note: this is shared between XOnlineUploadFile and 
// XOnlineUploadFromMemory
//
HRESULT CXo::xrlulsCompleted(PVOID pvxrlasync)
{
	PXRL_ASYNC	pxrlasync = (PXRL_ASYNC)pvxrlasync;

	if (pxrlasync->uliTotalWritten.QuadPart >= pxrlasync->uliFileSize.QuadPart)
		return(S_OK);
	return(S_FALSE);
}

//
// This function is called after all headers are received from
// the server final response
//
// Note: this is shared between XOnlineUploadFile and 
// XOnlineUploadFromMemory
//
HRESULT CXo::xrlulsResponseHeaders(PVOID pvxrlasync)
{
#if 0
	PXRL_ASYNC	pxrlasync = (PXRL_ASYNC)pvxrlasync;

	if (pfAbortWithSuccess)
		*pfAbortWithSuccess = FALSE;

	// Hint an abort with success on 400 or 500 level HTTP server error
	if (XONLINEUPLOAD_EXSTATUS_ANYERROR(pxrlasync->dwExtendedStatus) &&
		pfAbortWithSuccess)
		*pfAbortWithSuccess = TRUE;
#endif	
    return(S_OK);
}

HRESULT CXo::xrlufmInitializeTask(XRLUPLOAD_EXTTYPE xrlulext, PVOID pvxrlasync, XONLINETASK_HANDLE hTask)
{
	HRESULT				hr = S_OK;
	PXRL_ASYNC			pxrlasync = (PXRL_ASYNC)pvxrlasync;
	PXRL_ASYNC_EXTENDED	pxrlasyncext = NULL;
	DWORD				dwAvailable;
	DWORD				dwLeft;
	PBYTE				pbSource;
	PBYTE				pbTarget;

	Assert(pxrlasync != NULL);
	Assert(hTask != NULL);

	// XOnlineUploadFromMemory services xrlulReadData
	if (xrlulext == xrlulextReadData)
	{
		// Figure out how much data we can put into the send buffer
		dwAvailable = pxrlasync->cbBuffer - pxrlasync->wsabuf.len;

		// Copy over the data into our send buffer
		pbSource = pxrlasync->fileio.pbBuffer + pxrlasync->dwCurrent;
		pbTarget = (BYTE *)(pxrlasync->wsabuf.buf + pxrlasync->wsabuf.len);
		dwLeft = pxrlasync->fileio.cbBuffer - pxrlasync->dwCurrent;
		
		if (dwLeft < dwAvailable)
			dwAvailable = dwLeft;
		memcpy(pbTarget, pbSource, dwAvailable);

		// Adjust our pointers
		pxrlasync->dwCurrent += dwAvailable;
		pxrlasync->wsabuf.len += dwAvailable;

		// Find the outer containing XRL_ASYNC_EXTENDED
		pxrlasyncext = CONTAINING_RECORD(pxrlasync, XRL_ASYNC_EXTENDED, xrlasync);
		
		// Set next subtask state to complete immediately
		pxrlasyncext->dwCurrentState = xrlufmDone;
	}

	return(hr);
}

//
// Implement the do work function for XOnlineUploadFromMemory subtask
//
HRESULT CXo::xrlufmContinue(XONLINETASK_HANDLE hTask)
{
	PXRL_ASYNC_EXTENDED	pxrlasyncext = NULL;

	// We can make very tight assumptions and validate here
	Assert(hTask != NULL);

	// hTask points to the xontask field of XRL_ASYNC_EXTENDED,
	// find the containing pxrlasyncext structure
	pxrlasyncext = CONTAINING_RECORD(hTask, XRL_ASYNC_EXTENDED, xontask);
	Assert(pxrlasyncext->dwCurrentState == xrlufmDone);

	return(XONLINETASK_S_SUCCESS);
}				

// Function to kick off uploading a memory buffer to the server.
// This is an internal version that takes a context structure 
// instead of allocating a context.
HRESULT CXo::UploadFromMemoryInternal(
			DWORD	                dwServiceID,
			LPCSTR					szTargetPath, 
			PBYTE					pbBuffer,
			DWORD					cbBuffer,
			PBYTE					pbExtraHeaders,
			DWORD					cbExtraHeaders,
			PBYTE					pbDataToUpload,
			DWORD					cbDataToUpload,
			DWORD					dwTimeout,
			HANDLE					hWorkEvent,
			PXRL_ASYNC_EXTENDED		pxrlasyncext
			)
{
	HRESULT					hr = S_OK;
	PXRL_ASYNC				pxrlasync = NULL;
	PXRL_UPLOAD_EXTENSION	pxrlulext = NULL;

    Assert(NULL != szTargetPath);
    Assert(!cbDataToUpload || pbDataToUpload);
    Assert(NULL != pxrlasyncext);
    
	// Initialize our ReadData subtask
	TaskInitializeContext(&pxrlasyncext->xontask);
	pxrlasyncext->xontask.hEventWorkAvailable = hWorkEvent;
	pxrlasyncext->xontask.pfnContinue = xrlufmContinue;
	pxrlasyncext->dwCurrentState = xrlufmDone;

	pxrlasync = &pxrlasyncext->xrlasync;
	pxrlulext = &(pxrlasync->xrlext.ul);

	// Set up the extension block
	pxrlulext->pfnCompleted = xrlulsCompleted;
	pxrlulext->pfnResponseHeaders = xrlulsResponseHeaders;
	pxrlulext->pfnInitializeTask = xrlufmInitializeTask;
	pxrlulext->pfnCleanup = NULL;
	pxrlulext->hTaskPreConnect = NULL;
	pxrlulext->hTaskReadData = 
					(XONLINETASK_HANDLE)&(pxrlasyncext->xontask);;
	pxrlulext->hTaskPostUpload = NULL;

	// Fill in the blanks
	TaskInitializeContext(&pxrlasync->xontask);
	pxrlasync->xontask.hEventWorkAvailable = hWorkEvent;
	pxrlasync->hrFinal = S_OK;
	pxrlasync->hrXErr = S_OK;
	hr = XOnlineGetServiceInfo(dwServiceID, &pxrlasync->serviceInfo);
	Assert(SUCCEEDED(hr));
	pxrlasync->uliTotalWritten.QuadPart = 0;
	pxrlasync->pBuffer = pbBuffer;
	pxrlasync->cbBuffer = cbBuffer;
	pxrlasync->dwCurrent = 0;
	pxrlasync->dwTimeoutMs = dwTimeout;
    
    XoOverrideServiceIP(pxrlasync);

	// We will use fileio to store the data pointers
	pxrlasync->fileio.pbBuffer = pbDataToUpload;
	pxrlasync->fileio.cbBuffer = cbDataToUpload;

	// Set file length for future reference
	pxrlasync->uliFileSize.QuadPart = cbDataToUpload;

	// Just call Upload
	hr = Upload(szTargetPath, 
				pbExtraHeaders, cbExtraHeaders,
				pxrlasync);
	return(hr);				
}

// Function to kick off uploading a memory buffer to the server
HRESULT 
CXo::XOnlineUploadFromMemory(
			DWORD		        dwServiceID,
			LPCSTR				szTargetPath, 
			PBYTE				pbBuffer,
			DWORD				*pcbBuffer, 
			PBYTE				pbExtraHeaders,
			DWORD				cbExtraHeaders,
			PBYTE				pbDataToUpload,
			DWORD				cbDataToUpload,
			DWORD				dwTimeout,
			HANDLE				hWorkEvent,
			XONLINETASK_HANDLE	*phTask
			)
{
    XoEnter("XOnlineUploadFromMemory");
    XoCheck(szTargetPath != NULL);
    XoCheck(pcbBuffer != NULL);
    XoCheck(!cbDataToUpload || pbDataToUpload);
    XoCheck(phTask != NULL);

	HRESULT					hr = S_OK;
	PXRL_ASYNC_EXTENDED		pxrlasyncext = NULL;
	PXRL_ASYNC				pxrlasync = NULL;
	PXRL_UPLOAD_EXTENSION	pxrlulext = NULL;
	DWORD					cbBuffer = *pcbBuffer;

	// We are responsible for allocating the context and the work buffer
	// The work buffer are the specified bytes immediately following the
	// context structure.	
	pxrlasyncext = (PXRL_ASYNC_EXTENDED)SysAlloc(sizeof(XRL_ASYNC_EXTENDED) + (pbBuffer?0:cbBuffer),
        PTAG_XONLINETASK_UPLOAD_MEMORY);
	if (!pxrlasyncext)
	{
		hr = E_OUTOFMEMORY;
		goto Error;
	}
	ZeroMemory(pxrlasyncext, sizeof(XRL_ASYNC_EXTENDED));
	
	hr = UploadFromMemoryInternal(
				dwServiceID,
				szTargetPath,
				pbBuffer?pbBuffer:(PBYTE)(pxrlasyncext + 1),
				cbBuffer,
				pbExtraHeaders,
				cbExtraHeaders,
				pbDataToUpload,
				cbDataToUpload,
				dwTimeout,
				hWorkEvent,
				pxrlasyncext);
	if (FAILED(hr))
    {
    	if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
    		*pcbBuffer = pxrlasyncext->xrlasync.wsabuf.len;
		goto Error;
	}

	// Return the context as an opaque handle
	*phTask = (XONLINETASK_HANDLE)pxrlasyncext;

Cleanup:	
	return(XoLeave(hr));

Error:

	// Failed setup, make sure we clean up everything
	if (pxrlasyncext)
		SysFree(pxrlasyncext);
	goto Cleanup;
}

//
// Define the extension functions for XOnlineUploadFile
//

HRESULT CXo::xrlufInitializeTask(
			XRLUPLOAD_EXTTYPE	xrlulext,
			PVOID				pvxrlasync,
			XONLINETASK_HANDLE	hTask
			)
{
	HRESULT				hr = S_OK;
	PXRL_ASYNC			pxrlasync = (PXRL_ASYNC)pvxrlasync;
	PXRL_ASYNC_EXTENDED	pxrlasyncext = NULL;
	DWORD				dwAvailable;
	DWORD				dwStart;

	Assert(pxrlasync != NULL);
	Assert(hTask != NULL);

	// XOnlineUploadFile services xrlulextReadData
	if (xrlulext == xrlulextReadData)
	{
		// Find the starting position for the file read. It's not as simple
		// as pxrlasync->wsabuf.len because the buffer for file read must be 
		// DWORD aligned. So we round it up to the next DWORD boundary.
		//
		// Note: this might leave a gap between the end of the HTTP headers and
		// the actual data. We will fix this up in xrlufReadDataHandler().
		dwStart = (pxrlasync->wsabuf.len + (sizeof(DWORD) - 1)) & ~(sizeof(DWORD) - 1);

		// Figure out how much data we can put into the send buffer
		dwAvailable = pxrlasync->cbBuffer - dwStart;

		// Round that down to an integer multiple of the sector size
		dwAvailable = SECTOR_ALIGNMENT_ROUND_DOWN(dwAvailable);

		// Find the outer containing XRL_ASYNC_EXTENDED
		pxrlasyncext = CONTAINING_RECORD(pxrlasync, XRL_ASYNC_EXTENDED, xrlasync);

		// Read data
		ReadWriteFileInitializeContext(pxrlasync->fileio.hFile,
					pxrlasync->pBuffer + dwStart, dwAvailable, 
					pxrlasync->uliTotalReceived, 
					pxrlasync->xontask.hEventWorkAvailable, &pxrlasync->fileio);

		hr = ReadFileInternal(&pxrlasync->fileio);
		if (FAILED(hr))
			goto Error;

		// Set next subtask state to read data
		pxrlasyncext->dwCurrentState = xrlufReadData;
	}

Error:
	return(hr);
}

//
// State xrlufReadData: Read file loop
//
HRESULT CXo::xrlufReadDataHandler(
			PXRL_ASYNC_EXTENDED	pxrlasyncext
			)
{
	HRESULT				hr = S_OK;
	DWORD				dwBytesRead;
	DWORD				dwShift;
	PBYTE				pbMove;
	PXRL_ASYNC			pxrlasync = &pxrlasyncext->xrlasync;
	XONLINETASK_HANDLE	hfileio = (XONLINETASK_HANDLE)&(pxrlasync->fileio);

	// Continue until the receive completes asynchronously
	hr = XOnlineTaskContinue(hfileio);
	if (XONLINETASK_STATUS_AVAILABLE(hr))
	{
		// Receive had returned results, see if it succeeded
		if (FAILED(hr))
			goto Error;

		// Succeeded, now get the results and analyze the data
		hr = GetReadWriteFileResults(hfileio, &dwBytesRead, NULL);
		if (FAILED(hr))
			goto Error;

		// Track how much we have read so far
		pxrlasync->uliTotalReceived.QuadPart += dwBytesRead;

		// Fix up any gaps in the data
		dwShift = (pxrlasync->wsabuf.len + (sizeof(DWORD) - 1)) & ~(sizeof(DWORD) - 1);
		if (dwShift != pxrlasync->wsabuf.len)
		{
			// We need to shift the data up a few bytes to cover up the gap
			dwShift -= pxrlasync->wsabuf.len;
			pbMove = (BYTE *)(pxrlasync->wsabuf.buf + pxrlasync->wsabuf.len);

			// Make sure we use MoveMemory here because the move regions 
			// are almost certain to be overlapping
			MoveMemory(pbMove, pbMove + dwShift, dwBytesRead);
		}

		// Send out whatever we read
		pxrlasync->wsabuf.buf = (char *)pxrlasync->pBuffer;
		pxrlasync->wsabuf.len += dwBytesRead;

		// End this subtask
		pxrlasyncext->dwCurrentState = xrlufDone;
	}

Cleanup:
	return(S_OK);

Error:
	// We encountered a hard error. Set next state to cleanup.
	pxrlasync->hrFinal = hr;
	pxrlasyncext->dwCurrentState = xrlufDone;
	goto Cleanup;
}

//
// Implement the do work function for XOnlineUploadFile subtask
//
HRESULT CXo::xrlufContinue(
			XONLINETASK_HANDLE	hTask
			)
{
	HRESULT				hr = S_OK;
	PXRL_ASYNC_EXTENDED	pxrlasyncext = NULL;
	PXRL_ASYNC			pxrlasync = NULL;

	// We can make very tight assumptions and validate here
	Assert(hTask != NULL);

	// hTask points to the xontask field of XRL_ASYNC_EXTENDED,
	// find the containing pxrlasyncext structure
	pxrlasyncext = CONTAINING_RECORD(hTask, XRL_ASYNC_EXTENDED, xontask);
	pxrlasync = &pxrlasyncext->xrlasync;

	// Only one possible state ...
	Assert(pxrlasyncext->dwCurrentState == xrlufReadData);

	if (pxrlasyncext->dwCurrentState == xrlufReadData)
		hr = xrlufReadDataHandler(pxrlasyncext);
	else
	{
		// This is a bad state. We force it to end so we don't get stuck
		// here forever.
		AssertSz(FALSE, "xrlufContinue: invalid current state!");
		pxrlasyncext->dwCurrentState = xrlufDone;
		pxrlasync->hrFinal = E_FAIL;
	}

	// When the next state is the final state, we set the flag so we don't
	// continue.
	if (pxrlasyncext->dwCurrentState == xrlufDone)
	{
		// Indicate that we are done and return the final code
		hr = pxrlasync->hrFinal;
		XONLINETASK_SET_COMPLETION_STATUS(hr);
	}
	
	return(hr);
}				

// Function to kick off uploading a file to the server
HRESULT 
CXo::XOnlineUploadFile(
			DWORD		    dwServiceID,
			LPCSTR			szTargetPath, 
			PBYTE			pbBuffer,
			DWORD			*pcbBuffer, 
			PBYTE			pbExtraHeaders,
			DWORD			cbExtraHeaders,
			LPCSTR			szLocalPath, 
			DWORD			dwTimeout,
			HANDLE			hWorkEvent,
			XONLINETASK_HANDLE	*phTask
			)
{
    XoEnter("XOnlineUploadFile");
    XoCheck(szTargetPath != NULL);
    XoCheck(pcbBuffer != NULL);
    XoCheck(*pcbBuffer >= XBOX_HD_SECTOR_SIZE);
    XoCheck(szLocalPath != NULL);
    XoCheck(phTask != NULL);

	HRESULT					hr = S_OK;
	PXRL_ASYNC_EXTENDED		pxrlasyncext = NULL;
	PXRL_ASYNC				pxrlasync = NULL;
	PXRL_UPLOAD_EXTENSION	pxrlulext = NULL;
	LARGE_INTEGER			liFileSize;
	PXONLINETASK_FILEIO		pfileio = NULL;
	DWORD					cbBuffer = *pcbBuffer;

	// The buffer size needs more validation:
	// 1) Sector size must be power of 2
	// 2) The size will be rounded down to multiples of Xbox HD sector size
    Assert((XBOX_HD_SECTOR_SIZE & (XBOX_HD_SECTOR_SIZE - 1)) == 0);
    cbBuffer &= ~(XBOX_HD_SECTOR_SIZE - 1);

	// We are responsible for allocating the context and the work buffer
	// The work buffer are the specified bytes immediately following the
	// context structure.	
	pxrlasyncext = (PXRL_ASYNC_EXTENDED)SysAlloc(sizeof(XRL_ASYNC_EXTENDED) + (pbBuffer?0:cbBuffer),
        PTAG_XONLINETASK_UPLOAD_FILE);
	if (!pxrlasyncext)
	{
		hr = E_OUTOFMEMORY;
		goto Error;
	}
	
	ZeroMemory(pxrlasyncext, sizeof(XRL_ASYNC_EXTENDED));
	pxrlasync = &pxrlasyncext->xrlasync;
	pxrlasync->pBuffer = pbBuffer?pbBuffer:(PBYTE)(pxrlasyncext + 1);
	pxrlasync->cbBuffer = cbBuffer;

	// Fill in the blanks
	TaskInitializeContext(&pxrlasync->xontask);
	pxrlasync->xontask.hEventWorkAvailable = hWorkEvent;
	pxrlasync->hrFinal = S_OK;
	pxrlasync->hrXErr = S_OK;
	hr = XOnlineGetServiceInfo(dwServiceID, &pxrlasync->serviceInfo);
	Assert(SUCCEEDED(hr));
	pxrlasync->uliTotalWritten.QuadPart = 0;
	pxrlasync->dwTimeoutMs = dwTimeout;
	
	pfileio = &pxrlasync->fileio;

	// Initialize our ProcessData subtask
	TaskInitializeContext(&pxrlasyncext->xontask);
	pxrlasyncext->xontask.pfnContinue = xrlufContinue;
	pxrlasyncext->xontask.hEventWorkAvailable = hWorkEvent;
	pxrlasyncext->dwCurrentState = xrlufDone;

	// Set up the extension block
	pxrlulext = &(pxrlasync->xrlext.ul);
	pxrlulext->pfnCompleted = xrlulsCompleted;
	pxrlulext->pfnResponseHeaders = xrlulsResponseHeaders;
	pxrlulext->pfnInitializeTask = xrlufInitializeTask;
	pxrlulext->pfnCleanup = NULL;
	pxrlulext->hTaskPreConnect = NULL;
	pxrlulext->hTaskReadData = 
					(XONLINETASK_HANDLE)&(pxrlasyncext->xontask);;
	pxrlulext->hTaskPostUpload = NULL;

	// Open the source file with overlapped access and no buffering
	pfileio->hFile = CreateFile(
				szLocalPath, 
				GENERIC_READ, 
				FILE_SHARE_READ, 
				NULL, 
				OPEN_EXISTING, 
				FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN |
				FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING, 
				NULL);
	if (pfileio->hFile == INVALID_HANDLE_VALUE)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Error;
	}

	// Get the size of the file
	if (!GetFileSizeEx(pfileio->hFile, &liFileSize))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Error;
	}

	// Save the file size
	pxrlasync->uliFileSize.QuadPart = liFileSize.QuadPart;

	// Just call Upload
	hr = Upload(szTargetPath, 
				pbExtraHeaders, cbExtraHeaders,
				pxrlasync);
	if (FAILED(hr))
    {
    	if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
    		*pcbBuffer = pxrlasync->wsabuf.len;
		goto Error;
	}

	// Return the context as an opaque handle
	*phTask = (XONLINETASK_HANDLE)pxrlasync;

Cleanup:	
	return(XoLeave(hr));

Error:

	// Failed setup, make sure we clean up everything
	if (pxrlasyncext)
		SysFree(pxrlasyncext);
	if (pfileio->hFile && (pfileio->hFile != INVALID_HANDLE_VALUE))
		CloseHandle(pfileio->hFile);
	goto Cleanup;
}

// Function to get the download progress
HRESULT
CXo::XOnlineUploadGetProgress(
			XONLINETASK_HANDLE	hTask,
			DWORD				*pdwPercentDone,
			ULARGE_INTEGER		*puliNumerator,
			ULARGE_INTEGER		*puliDenominator
			)
{
    XoEnter("XOnlineUploadGetProgress");
    XoCheck(hTask != NULL);

	PXRL_ASYNC	pxrlasync = (PXRL_ASYNC)hTask;

	if (puliNumerator)
		puliNumerator->QuadPart = pxrlasync->uliTotalWritten.QuadPart;
	if (puliDenominator)
		puliDenominator->QuadPart = pxrlasync->uliFileSize.QuadPart;
	if (pdwPercentDone)
	{
		if (pxrlasync->uliFileSize.QuadPart != 0)
		{
			*pdwPercentDone = 
				(DWORD)((pxrlasync->uliTotalWritten.QuadPart * 100)/
					pxrlasync->uliFileSize.QuadPart);
			if (*pdwPercentDone > 100)
				*pdwPercentDone = 100;
		}
		else
			*pdwPercentDone = 0;
	}

	return(XoLeave(S_OK));
}

// Helper function to return the results of an upload
HRESULT 
CXo::XOnlineUploadGetResults(
			XONLINETASK_HANDLE	hTask,
			LPBYTE				*ppbBuffer,
			DWORD				*pcbBuffer,
			ULARGE_INTEGER		*puliTotalReceived,
			ULARGE_INTEGER		*puliContentLength,
			DWORD				*pdwExtendedStatus,
			FILETIME			*pftTimestamp
			)
{
    XoEnter("XOnlineUploadGetResults");
    XoCheck(hTask != NULL);

	PXRL_ASYNC pxrlasync = (PXRL_ASYNC)hTask;

	TaskVerifyContext(&(pxrlasync->xontask));

	// Fill in all the values the caller is interested in
	if (ppbBuffer)
		*ppbBuffer = pxrlasync->pBuffer;
	if (pcbBuffer)
		*pcbBuffer = pxrlasync->dwCurrent;
	if (puliTotalReceived)
		puliTotalReceived->QuadPart = pxrlasync->uliTotalReceived.QuadPart;
	if (puliContentLength)
		puliContentLength->QuadPart = pxrlasync->uliContentLength.QuadPart;
	if (pdwExtendedStatus)
		*pdwExtendedStatus = pxrlasync->dwExtendedStatus;
	if (pftTimestamp)
		memcpy(pftTimestamp, &(pxrlasync->ftResponse), sizeof(FILETIME));

	return(XoLeave(pxrlasync->hrFinal));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xbosutil.cpp ===
/*
 *  xbosutil.cpp
 *
 *  XBOS Utility APIs.  Copyright (c) Microsoft Corporation.
 *  
 *  Author: Ben Zotto (benzotto)
 *  Created: 12/10/01
 *
 *  Implements the APIs:   XOnlineOfferingPriceFormat()
 */		
#include "xonp.h"
#include "xonver.h"


// XONLINE_PRICE
//  This represents the price of an offer on the online service.  Within this struct
//  is enough information to format the price precisely.  That information is provided
//  by the server, taking into account both language and billing country.  Its members
//  are:
//              dwWholePart :       a DWORD giving the part of the price left of the
//                                  decimal point.
//              dwFractionalPart :  DWORD giving the decimal part, if applicable (see below)
//              bCurrencyFormat  :  a packed byte containing the following fields:
//                                      bits 4-7: currency (as in XONLINE_CURRENCY)            
//                                      bit    3: true if curr. marker precedes price
//                                      bit    2: true if there should be a space
//                                                between the marker and price
//                                      bit    1: true if there is a decimal (frac.) part
//                                      bit    0: true if decimal separator is a comma,
//                                                false if a period.
//              rgchISOCurrencyCode: the 3-character ISO code corresponding to this
//                                   currency.  should be used as the currency symbol
//                                   if the 4-bit currency from above is unrecognized.
//
/*
typedef struct {                    // DECLARED IN XONLINE.X.  REPRODUCED FOR REFERENCE.
    DWORD dwWholePart;
    DWORD dwFractionalPart;
    BYTE  bCurrencyFormat;
    WCHAR rgchISOCurrencyCode[3];
} XONLINE_PRICE;
*/

// XONLINE_CURRENCY
//  This enumeration represents the currencies that (this version of!) the client
//  knows about and can handle directly.  Enumeration should only handle 0-15
//  because it's stored in 4 bits.  This enumeration uses 0-13, leaving only two
//  "unknown" spots for future expansion...
//
typedef enum {
    AUD = 0,
    CAD, 
    CHF,
    DKK,
    EUR,
    GBP,
    JPY,
    KRW,
    NOK,
    NZD,
    SEK,
    USD,
    ZAR,
    USD_US,
    UNKNOWN_CURRENCY
} XONLINE_CURRENCY;

// XO_CURRENCY_*
//  These are bitflags to indicate availability of unicode extended currency
//  characters:
//      EUR = Euro
//      GBP = Pound sign
//      JPY = Yen
//      KRW = Korean Won
//
/* SHOWN HERE FOR REFERENCE.  DEFINED FOR REAL IN XONLINE.X
#define XO_CURRENCY_EUR     1
#define XO_CURRENCY_GBP     2
#define XO_CURRENCY_JPY     4
#define XO_CURRENCY_KRW     8
*/

// Internal manipulation macros for the currency formatting byte.  These
// macros, like the details of the byte's contents, are not explicitly
// exposed to title devs.
//
#define XONLINE_PRICE_FORMAT_MARKER_PRECEDES( x )      ( (x >> 3) & 1 )
#define XONLINE_PRICE_FORMAT_SPACE_PADDING( x )        ( (x >> 2) & 1 )
#define XONLINE_PRICE_FORMAT_DECIMAL_PART( x )         ( (x >> 1) & 1 )
#define XONLINE_PRICE_FORMAT_DECIMAL_SEPARATOR( x )    ( (x & 1) ? ',' : '.' )
#define XONLINE_PRICE_UNKNOWN_CURRENCY( x )            ( ((x >> 4) & 0x0F) >= UNKNOWN_CURRENCY ) 


// helper function prototype.
LPWSTR XOCopyCurrencyMarker(XONLINE_PRICE *Price, LPWSTR lpwstrMarker, DWORD *cbLength, DWORD dwExtendedCharsFilter);


// XOnlineOfferingPriceFormat
//
//  This synchronous API call will take an XONLINE_PRICE struture (freshly returned
//  from an OfferingGetDetails call) and produce a properly-formatted (unicode) 
//  currency string.  You will need to provide it with a pointer some pre-allocated 
//  space, and a pointer to the DWORD saying how big that space is.  
//  Finally, dwExtendedCharsFilter is a set of flags indicating which extended (unicode)
//  currency characters your font set includes/allows.  Set this by ORing in the
//  XO_CURRENCY_* flags. 
//
//  The function returns S_OK on success, and E_FAIL when confronted with too small a 
//  buffer.  If your call fails, simply recall with a big enough buffer-- the size
//  required will be placed into *cbLength.
//
HRESULT
CXo::XOnlineOfferingPriceFormat( XONLINE_PRICE *Price,
                            LPWSTR        lpwszFormattedPrice,
                            DWORD         *cbLength,
                            DWORD         dwExtendedCharsFilter
                          )
{
    XoEnter("XOnlineOfferingPriceFormat");
    XoCheck(cbLength != NULL);

    HRESULT hr;
    LPWSTR  lpwszPriceStart = lpwszFormattedPrice;
    DWORD   reqLen          = 0;
    
    DWORD   digits          = 0;
    DWORD   num;

    // calculate the required string size for the currency
    // need the symbol...
    XOCopyCurrencyMarker(Price, NULL, &reqLen, dwExtendedCharsFilter);
    // may need a space pad
    if( XONLINE_PRICE_UNKNOWN_CURRENCY(Price->bCurrencyFormat)  || 
        XONLINE_PRICE_FORMAT_SPACE_PADDING(Price->bCurrencyFormat) ) {        
        reqLen += 2;  // 1 space in unicode
    }
    // may need a 3-unicharacter decimal part... (eg: ".00")
    if( XONLINE_PRICE_FORMAT_DECIMAL_PART(Price->bCurrencyFormat) ) {
        reqLen += 6;   
    }
    // now... how many whole-part digits is this?
    num = Price->dwWholePart;
    if( num > 0 ) {
        for( digits = 1; ((num /= 10) > 0); digits++ );
    }
    reqLen += (2*digits);           // add in the digits (x2 for unicode)
    reqLen += 2;                    // ...and a null.

    // do we have enough string space for this?
    if( *cbLength < reqLen ) {
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto Exit;
    }

    Assert(lpwszFormattedPrice);
    
    // insert the currency symbol up front if we can
    if( XONLINE_PRICE_FORMAT_MARKER_PRECEDES(Price->bCurrencyFormat) ) {
        lpwszFormattedPrice = XOCopyCurrencyMarker( Price, 
                              lpwszFormattedPrice,                   
                              cbLength,
                              dwExtendedCharsFilter);
        
        // force an inserted space if we only know the ISO code, otherwise check
        if( XONLINE_PRICE_UNKNOWN_CURRENCY(Price->bCurrencyFormat)  || 
            XONLINE_PRICE_FORMAT_SPACE_PADDING(Price->bCurrencyFormat) ) {        
                *(lpwszFormattedPrice++) = L' ';
        }
    }

    // go ahead and splice in the actual prices 
    if( XONLINE_PRICE_FORMAT_DECIMAL_PART(Price->bCurrencyFormat) ) {
        swprintf( lpwszFormattedPrice, 
                  L"%d%c%.2d", 
                  Price->dwWholePart,
                  XONLINE_PRICE_FORMAT_DECIMAL_SEPARATOR(Price->bCurrencyFormat),
                  Price->dwFractionalPart
                  );
    } else {
        swprintf( lpwszFormattedPrice, 
                  L"%d", 
                  Price->dwWholePart 
                  );
    }
    lpwszFormattedPrice += wcslen(lpwszFormattedPrice);

    // insert the currency symbol now, if still necessary
    if( !XONLINE_PRICE_FORMAT_MARKER_PRECEDES(Price->bCurrencyFormat) ) {
        if( XONLINE_PRICE_UNKNOWN_CURRENCY(Price->bCurrencyFormat)  || 
            XONLINE_PRICE_FORMAT_SPACE_PADDING(Price->bCurrencyFormat) ) {        
                *(lpwszFormattedPrice++) = L' ';
        }
        
        lpwszFormattedPrice = XOCopyCurrencyMarker( Price,                             
                              lpwszFormattedPrice, 
                              cbLength,                        // this value will be incorrect, but OK
                              dwExtendedCharsFilter);
    
        // replace the NUL character
        *lpwszFormattedPrice = L'\0';
    }
        
    hr = S_OK;          // if we're here, we're fine.

Exit:
    *cbLength = reqLen;
    return(XoLeave(hr));
       
}
    
// XOCopyCurrencyMarker
//      an internal helper function to copy an appropriate currency symbol/marker into 
//      the provided string, which has length==*cbLength.  if cbLength is too small,
//      the required length will be written into the Length.
//
//
LPWSTR XOCopyCurrencyMarker(XONLINE_PRICE *Price, LPWSTR lpwstrMarker, DWORD *cbLength, DWORD dwExtendedCharsFilter)
{
    HRESULT hr              = E_FAIL;
    DWORD   reqLen          = 0;
    WCHAR   *marker			= NULL;
    BYTE    bCurrencyFormat = Price->bCurrencyFormat;
	DWORD   dwUnicodeChar   = 0;

    switch( (bCurrencyFormat >> 4) & 0x0F ) {
        case AUD:
            marker = L"A$";
            break;
        case CAD:
            marker = L"Can$";
            break;
        case CHF:
            marker = L"SFr";
            break;
        case DKK:
            marker = L"Dkr";
            break;
        case EUR:   
            if( dwExtendedCharsFilter & XO_CURRENCY_EUR ) {
				dwUnicodeChar = 0x20AC; // euro symbol
            } else {
                marker = L"EUR";
                Price->bCurrencyFormat |= 0x04;     // force a padding space
            }
            break;
        case GBP:
            if( dwExtendedCharsFilter & XO_CURRENCY_GBP ) {
                dwUnicodeChar = 0x00A3; // UK Pound symbol
            } else {
                marker = L"GBP";
                Price->bCurrencyFormat |= 0x04;     // force a padding space
            }
            break;
        case JPY:
            if( dwExtendedCharsFilter & XO_CURRENCY_JPY ) {
                dwUnicodeChar = 0x00A5; // Japansese Yen symbol
            } else {
                marker = L"JPY";
                Price->bCurrencyFormat |= 0x04;     // force a padding space
            }
            break;
        case KRW:
            if( dwExtendedCharsFilter & XO_CURRENCY_KRW ) {
                dwUnicodeChar = 0x20A9; // South Korean Won symbol
            } else {
                marker = L"KRW";
                Price->bCurrencyFormat |= 0x04;     // force a padding space
            }
            break;
        case NOK:
            marker = L"Nkr";
            break;
        case NZD:
            marker = L"NZ$";
            break;
        case SEK:
            marker = L"Skr";
            break;
        case USD:
            marker = L"US$";
            break;
        case ZAR:
            marker = L"R";
            break;
        case USD_US:
            marker = L"$";
            break;

        default:        /* not a recognized currency. */
            marker = NULL;
            break;
    }


    // did they supply enough space to copy in the marker plus a null?
    if( marker != NULL ) {
		reqLen = 2 * (wcslen(marker) + 1);  // don't forget unicode!
	} else {
		if( dwUnicodeChar != 0 ) {			// special unicode char?
			reqLen = 2;
		} else {							// just the ISO code.
			reqLen = 6;
		}
	}

    if( *cbLength >= reqLen ) {      
		Assert(lpwstrMarker != NULL);
        if( marker != NULL ) {
            wcscpy(lpwstrMarker, marker); 
            lpwstrMarker += wcslen(marker);
        } else {
			if( dwUnicodeChar != 0 ) {		// unicode char
				*(lpwstrMarker++) = (WCHAR)dwUnicodeChar;
			} else {
				memcpy(lpwstrMarker, Price->rgchISOCurrencyCode, (3*sizeof(WCHAR)) );
				lpwstrMarker += 3;
			}
        }
    }
    
	*cbLength = reqLen;
    return lpwstrMarker;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\users.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:        xonline.cpp
 *  Content:    Implementation of Xbox online API
 *
 *  History:
 *   Date        By            Reason
 *   ====        ==            ======
 * 10/20/00      tonychen     Created
 *  7/25/01      t-ankurm     MU support added
 ========================================================================== */

#include "xonp.h"
#include "xonver.h"
#include <cryptkeys.h>
#include <fat.h>
#include <xboxp.h>

VOID CXo::CompleteRecentLogonTimeCacheOpenTask()
{
    HRESULT hr;

    if (m_dwLogonTimeCacheState == XON_CACHE_STATE_OPENING)
    {    
        //
        // busy loop until the task is done
        //
        do
        {
            hr = XOnlineTaskContinue( m_hLogonTimeCacheTask );
        } while (hr == XONLINETASK_S_RUNNING);

        if (FAILED(hr))
        {
            if (m_hLogonTimeCacheTask != NULL)
            {
                XOnlineTaskClose(m_hLogonTimeCacheTask);
                m_hLogonTimeCacheTask = NULL;
            }
            
            if (m_hLogonTimeCache != NULL)
            {
                CacheClose(m_hLogonTimeCache);
                m_hLogonTimeCache = NULL;
            }
            m_dwLogonTimeCacheState = XON_CACHE_STATE_ERROR;
        }
        else
        {
            m_dwLogonTimeCacheState = XON_CACHE_STATE_OPENED;
        }
    }
}

//
// Copy user into destination and fix things up
//
VOID CXo::CopyAndAdjustUser(
    IN PXC_ONLINE_USER_ACCOUNT_STRUCT pUserAccount,
    IN DWORD dwMUOptions,
    IN OUT PXONLINEP_USER pUser
    )
{
    RtlCopyMemory( pUser, pUserAccount, sizeof(XC_ONLINE_USER_ACCOUNT_STRUCT) );
    pUser->xuid.dwUserFlags = 0;
    pUser->hr = 0;
    pUser->index = 0;
    if (dwMUOptions & XONLINE_USER_OPTION_CAME_FROM_MU)
    {
        DecryptKeyWithMUKey( pUser->key, sizeof(pUser->key) );
        pUser->dwUserOptions |= dwMUOptions;
    }
    else
    {
        DecryptKeyWithHardDriveKeyEx( GetHdKey(), pUser->key, sizeof(pUser->key) );
    }
}

VOID CXo::CollectValidUser(
    IN PXC_ONLINE_USER_ACCOUNT_STRUCT pUserAccount,
    IN DWORD dwMUOptions,
    IN OUT FILETIME* pLastLogon,
    IN OUT PXONLINEP_USER pUsers,
    IN OUT DWORD *pcUsers
    )
{
    HRESULT hr;
    XONLINE_RECENT_LOGON_TIME recentLogonTime;
    XONLC_CONTEXT cacheContext;
    DWORD i,j;

    //
    // Check if user valid
    //
    if (!VerifyOnlineUserSignature(pUserAccount))
    {
        return;
    }
    
    //
    // Lookup recent logon time
    //
    RtlZeroMemory(&recentLogonTime, sizeof(recentLogonTime));
    if (m_hLogonTimeCache != NULL)
    {
        RtlZeroMemory(&cacheContext, sizeof(cacheContext));
        recentLogonTime.qwUserID = pUserAccount->xuid.qwUserID;
        cacheContext.pbIndexData = (BYTE*)&recentLogonTime;
        hr = CacheLookup(m_hLogonTimeCache, &cacheContext);
        Assert (FAILED(hr) || !cacheContext.bValidDataInCache || !cacheContext.bCallRetrieveNext);
    }
    
    //
    // See if user already present in array
    //
    for (i=0; i<*pcUsers; ++i)
    {
        if (pUsers[i].xuid.qwUserID == pUserAccount->xuid.qwUserID)
        {
            if (pUsers[i].dwSignatureTime < pUserAccount->dwSignatureTime)
            {
                //
                // Overwrite Old User
                //
                CopyAndAdjustUser(pUserAccount, dwMUOptions, &pUsers[i]);
                TraceSz1( AuthVerbose, "XOnlineGetUsers: newer MU user overwrote HD user %s", pUserAccount->name );
            }
            else
            {
                TraceSz1( AuthVerbose, "XOnlineGetUsers: duplicate (or older) MU user thrown away, using HD user %s", pUserAccount->name );
            }
            return;
        }
    }
    
    //
    // Use insertion sort to return user in order of recent logon
    //
    for (i=0; i<*pcUsers; ++i)
    {
        if (*((ULONGLONG*)&(pLastLogon[i])) < *((ULONGLONG*)&(recentLogonTime.lastLogon)))
        {
            break;
        }
    }
    
    for (j = *pcUsers; j > i; --j)
    {
        RtlCopyMemory( &pUsers[j], &pUsers[j-1], sizeof(XONLINE_USER) );
    }

    CopyAndAdjustUser(pUserAccount, dwMUOptions, &pUsers[i]);
    
    pLastLogon[i] = recentLogonTime.lastLogon;
    
    ++(*pcUsers);
}

HRESULT CXo::XOnlineGetUsers(
    OUT PXONLINE_USER pUsers,
    OUT DWORD *pcUsers
    )
{
    XoEnter("XOnlineGetUsers");
    XoCheck(pUsers != NULL);
    XoCheck(pcUsers != NULL);

#if DBG
    DWORD dwStartTickCount = GetTickCount();
#endif
    HRESULT hr = S_OK;
    NTSTATUS Status;
    DWORD dwMUOptions;
    BYTE abConfigData[CONFIG_DATA_LENGTH];
    FILETIME lastLogon[XONLINE_MAX_STORED_ONLINE_USERS];
    PXC_ONLINE_USER_ACCOUNT_STRUCT userAccounts;
    DWORD dwCurrentDevices;
    DWORD i,j;

    Assert( sizeof(XONLINE_USER) == sizeof(XONLINEP_USER) );
    Assert( sizeof(XONLINE_USER) == sizeof(XC_ONLINE_USER_ACCOUNT_STRUCT) + sizeof(HRESULT) + sizeof(DWORD) );

    RtlZeroMemory( pUsers, sizeof(XONLINE_USER) * XONLINE_MAX_STORED_ONLINE_USERS );
    *pcUsers = 0;
    
    userAccounts = (PXC_ONLINE_USER_ACCOUNT_STRUCT)abConfigData;

    CompleteRecentLogonTimeCacheOpenTask();

    for (i=0; i<XONLINE_MAX_HD_ONLINE_USERS/XONLINE_MAX_ONLINE_USERS_PER_SECTOR; ++i)
    {
        if (!XNetLoadConfigSector(m_hConfigVolume, BASE_USER_ACCOUNT_CONFIG_SECTOR + i, abConfigData, CONFIG_DATA_LENGTH))
        {
            RtlZeroMemory( abConfigData, CONFIG_DATA_LENGTH );
        }

        for (j=0; j<XONLINE_MAX_ONLINE_USERS_PER_SECTOR; ++j)
        {
            CollectValidUser(&userAccounts[j], 0, lastLogon, (PXONLINEP_USER)pUsers, pcUsers);
        }
    }

#ifdef XONLINE_FEATURE_XBOX
    dwCurrentDevices = XPeekDevices( XDEVICE_TYPE_MEMORY_UNIT, NULL, NULL);

    for (i=0; i<XGetPortCount(); ++i)
    {
        for (j=0; j<2; ++j)
        {
            if (dwCurrentDevices & (1 << (i + j*16)))
            {
                Status = XReadMUMetaData( i, j, &userAccounts[0], FIELD_OFFSET(FAT_VOLUME_METADATA, OnlineData), sizeof(XC_ONLINE_USER_ACCOUNT_STRUCT) );
                if (NT_SUCCESS(Status))
                {
                    dwMUOptions = XONLINE_USER_OPTION_CAME_FROM_MU | (i << XONLINE_USER_OPTION_MU_PORT_SHIFT) | (j << XONLINE_USER_OPTION_MU_SLOT_SHIFT);
                    CollectValidUser(&userAccounts[0], dwMUOptions, lastLogon, (PXONLINEP_USER)pUsers, pcUsers);
                }
            }
        }
    }
#endif

#if DBG
    TraceSz2(AuthVerbose,"XOnlineGetUsers: took %d ms to return %d users", GetTickCount() - dwStartTickCount, *pcUsers);
#endif

    return(XoLeave(hr));
}

HRESULT CXo::_XOnlineGetUsersFromHD(
    OUT PXONLINE_USER pUsers,
    OUT DWORD *pcUsers
    )
{
    XoEnter("_XOnlineGetUsersFromHD");
    XoCheck(pUsers != NULL);
    XoCheck(pcUsers != NULL);

    BYTE abConfigData[CONFIG_DATA_LENGTH];
    PXC_ONLINE_USER_ACCOUNT_STRUCT userAccounts;
    DWORD i,j;

    RtlZeroMemory( pUsers, sizeof(XONLINE_USER) * XONLINE_MAX_HD_ONLINE_USERS );
    *pcUsers = 0;
    
    userAccounts = (PXC_ONLINE_USER_ACCOUNT_STRUCT)abConfigData;

    for (i=0; i<XONLINE_MAX_HD_ONLINE_USERS/XONLINE_MAX_ONLINE_USERS_PER_SECTOR; ++i)
    {
        if (!XNetLoadConfigSector(m_hConfigVolume, BASE_USER_ACCOUNT_CONFIG_SECTOR + i, abConfigData, CONFIG_DATA_LENGTH))
        {
            RtlZeroMemory( abConfigData, CONFIG_DATA_LENGTH );
        }

        for (j=0; j<XONLINE_MAX_ONLINE_USERS_PER_SECTOR; ++j)
        {
            if (VerifyOnlineUserSignature(&userAccounts[j]))
            {
                CopyAndAdjustUser(&userAccounts[j], 0, (PXONLINEP_USER)&pUsers[*pcUsers]);
                ++(*pcUsers);
            }
        }
    }

    return(XoLeave(S_OK));
}

HRESULT CXo::_XOnlineGetUserFromMU (
    IN DWORD dwPort,
    IN DWORD dwSlot,
    OUT PXONLINE_USER pUser
    )
{
    XoEnter("_XOnlineGetUserFromMU");
    XoCheck((dwPort < XGetPortCount()) && (dwSlot < 2));
    XoCheck(pUser != NULL);

#ifdef XONLINE_FEATURE_XBOX

    HRESULT hr = XONLINE_E_NO_USER;
    NTSTATUS Status;
    DWORD dwMUOptions;
    XC_ONLINE_USER_ACCOUNT_STRUCT userAccount;

    RtlZeroMemory( pUser, sizeof(XONLINE_USER) );

    Status = XReadMUMetaData( dwPort, dwSlot, &userAccount, FIELD_OFFSET(FAT_VOLUME_METADATA, OnlineData), sizeof(XC_ONLINE_USER_ACCOUNT_STRUCT) );
    if (NT_SUCCESS(Status))
    {
        if (VerifyOnlineUserSignature(&userAccount))
        {
            dwMUOptions = XONLINE_USER_OPTION_CAME_FROM_MU | (dwPort << XONLINE_USER_OPTION_MU_PORT_SHIFT) | (dwSlot << XONLINE_USER_OPTION_MU_SLOT_SHIFT);
            CopyAndAdjustUser(&userAccount, dwMUOptions, (PXONLINEP_USER)pUser);
            hr = S_OK;
        }
    }

    return(XoLeave(hr));
#else
    return(XoLeave(E_NOTIMPL));
#endif
}

BOOL CXo::_XOnlineIsUserCredentialPresent(
    IN PXONLINE_USER pUser
    )
{
#ifdef XONLINE_FEATURE_XBOX
    NTSTATUS Status;
    XC_ONLINE_USER_ACCOUNT_STRUCT userAccount;
    DWORD dwCurrentDevices;
    DWORD i,j;

    //
    // All user from HD are present
    //
    if ((pUser->dwUserOptions & XONLINE_USER_OPTION_CAME_FROM_MU) == 0)
    {
        return TRUE;
    }

    dwCurrentDevices = XPeekDevices( XDEVICE_TYPE_MEMORY_UNIT, NULL, NULL);

    for (i=0; i<XGetPortCount(); ++i)
    {
        for (j=0; j<2; ++j)
        {
            if (dwCurrentDevices & (1 << (i + j*16)))
            {
                Status = XReadMUMetaData( i, j, &userAccount, FIELD_OFFSET(FAT_VOLUME_METADATA, OnlineData), sizeof(XC_ONLINE_USER_ACCOUNT_STRUCT) );
                if (NT_SUCCESS(Status))
                {
                    if (VerifyOnlineUserSignature(&userAccount))
                    {
                        if (RtlEqualMemory(userAccount.signature, ((PXONLINEP_USER)pUser)->signature, sizeof(userAccount.signature)))
                        {
                            return TRUE;
                        }
                    }
                }
            }
        }
    }
    return FALSE;
#else
    return TRUE;
#endif
}

BOOL CXo::SetMachineAccount(
    IN PXONLINEP_USER pUser
    )
{
    HRESULT hr = S_OK;
    XC_ONLINE_MACHINE_ACCOUNT_STRUCT* pMachineAccount;
    BYTE abConfigData[CONFIG_DATA_LENGTH];
    
    //
    // Pull out information about the machine account from config sector
    //
    if (!XNetLoadConfigSector(m_hConfigVolume, MACHINE_ACCOUNT_CONFIG_SECTOR, abConfigData, sizeof(abConfigData)))
    {
        RtlZeroMemory( abConfigData, sizeof(abConfigData) );
    }

    pMachineAccount = (XC_ONLINE_MACHINE_ACCOUNT_STRUCT*)abConfigData;
    
    RtlCopyMemory( pMachineAccount, pUser, sizeof(*pMachineAccount) );

    //
    // Encrypt Key and save to Config Sector on HD
    //
    EncryptKeyWithHardDriveKeyEx( GetHdKey(), pMachineAccount->key, sizeof(pMachineAccount->key) );

    //
    // Sign the struct signature
    //
    SignOnlineUserStruct( pMachineAccount );

    //
    // Store it back to the config sector
    //
    if (!XNetSaveConfigSector(m_hConfigVolume, MACHINE_ACCOUNT_CONFIG_SECTOR, abConfigData, sizeof(abConfigData)))
    {
        return FALSE;
    }
    
    return TRUE;
}



HRESULT CXo::_XOnlineAddUserToHD(
    IN PXONLINE_USER pUser
    )
{
    XoEnter("_XOnlineAddUserToHD");
    XoCheck(pUser != NULL && pUser->xuid.qwUserID != 0);

    HRESULT hr = S_OK;
    BYTE abConfigData[XONLINE_MAX_HD_ONLINE_USERS/XONLINE_MAX_ONLINE_USERS_PER_SECTOR][CONFIG_DATA_LENGTH];
    PXC_ONLINE_USER_ACCOUNT_STRUCT userAccounts;
    #define NO_EMPTY_SLOT_FOUND 0xFFFFFFFF
    DWORD dwEmptySector;
    DWORD dwEmptySlot = NO_EMPTY_SLOT_FOUND;
    DWORD i,j;

    for (i=0; i<XONLINE_MAX_HD_ONLINE_USERS/XONLINE_MAX_ONLINE_USERS_PER_SECTOR; ++i)
    {
        if (!XNetLoadConfigSector(m_hConfigVolume, BASE_USER_ACCOUNT_CONFIG_SECTOR + i, abConfigData[i], CONFIG_DATA_LENGTH))
        {
            RtlZeroMemory( abConfigData[i] , CONFIG_DATA_LENGTH );
        }
        userAccounts = (PXC_ONLINE_USER_ACCOUNT_STRUCT)abConfigData[i];

        for (j=0; j<XONLINE_MAX_ONLINE_USERS_PER_SECTOR; ++j)
        {
            if (!VerifyOnlineUserSignature(&userAccounts[j]))
            {
                if (dwEmptySlot == NO_EMPTY_SLOT_FOUND)
                {
                    dwEmptySector = i;
                    dwEmptySlot = j;
                }
            }
            else if (userAccounts[j].xuid.qwUserID == pUser->xuid.qwUserID)
            {
                //
                // Overwrite if account already exists
                //
                dwEmptySector = i;
                dwEmptySlot = j;
            }
        }
    }

    if (dwEmptySlot != NO_EMPTY_SLOT_FOUND)
    {
        userAccounts = (PXC_ONLINE_USER_ACCOUNT_STRUCT)abConfigData[dwEmptySector];

        RtlCopyMemory( &userAccounts[dwEmptySlot], pUser, sizeof(XC_ONLINE_USER_ACCOUNT_STRUCT) );

        EncryptKeyWithHardDriveKeyEx( GetHdKey(), userAccounts[dwEmptySlot].key, sizeof(userAccounts[dwEmptySlot].key) );
        SignOnlineUserStruct(&userAccounts[dwEmptySlot]);

#if DBG
        FILETIME CurrentTime;
    	GetSystemTimeAsFileTime(&CurrentTime);
        Assert( *((ULONGLONG*)&CurrentTime) > BASE_SIGNATURE_TIME );
        Assert( ((*((ULONGLONG*)&CurrentTime) - BASE_SIGNATURE_TIME) / SIGNATURE_TIME_INCREMENT) <= ((ULONGLONG)0xFFFFFFFF) );
#endif

        if (!XNetSaveConfigSector(m_hConfigVolume, BASE_USER_ACCOUNT_CONFIG_SECTOR + dwEmptySector, abConfigData[dwEmptySector], CONFIG_DATA_LENGTH))
        {
            Assert(!"XNetSaveConfigSector failed");
            hr = E_FAIL;
        }
    }
    else
    {
        //
        // No more space left to add new user
        //
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

Cleanup:

    return(XoLeave(hr));
}

HRESULT CXo::_XOnlineSetUserInMU(
    IN CHAR chDrive,
    IN PXONLINE_USER pUser
    )
{
    XoEnter("_XOnlineSetUserInMU");
    XoCheck(('F' <= chDrive && chDrive <= 'M') || ('f' <= chDrive && chDrive <= 'm'));
    XoCheck(pUser != NULL);

#ifdef XONLINE_FEATURE_XBOX
    NTSTATUS Status;
    OCHAR szDosDevice[8];
    OBJECT_STRING DosDevice;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    HRESULT hr = S_OK;
    IO_STATUS_BLOCK IoStatusBlock;
    FSCTL_VOLUME_METADATA VolumeMetadata;
    XC_ONLINE_USER_ACCOUNT_STRUCT userAccount;
    FAT_VOLUME_METADATA MUMetaData;
    BOOL fSetMUVolumeName;
    XC_ONLINE_USER_ACCOUNT_STRUCT* pOrigMUUser;
    DWORD i;
    
    //
    // Open a handle to the volume or directory of the drive.
    //
    soprintf(szDosDevice, OTEXT("\\??\\%c:"), chDrive);
    RtlInitObjectString(&DosDevice, szDosDevice);

    InitializeObjectAttributes(
        &Obja,
        (POBJECT_STRING) &DosDevice,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenFile(&Handle,
                        SYNCHRONIZE | GENERIC_WRITE,
                        &Obja,
                        &IoStatusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        FILE_SYNCHRONOUS_IO_ALERT);

    if (!NT_SUCCESS(Status))
    {
        TraceSz( AuthWarn, "MU: error -- NtOpenFile");
        return HRESULT_FROM_WIN32(RtlNtStatusToDosError(Status));
    }

    Assert(sizeof(XC_ONLINE_USER_ACCOUNT_STRUCT) <= FAT_ONLINE_DATA_LENGTH);

    VolumeMetadata.ByteOffset = FIELD_OFFSET(FAT_VOLUME_METADATA, VolumeName);
    VolumeMetadata.TransferLength = sizeof(MUMetaData.VolumeName) + sizeof(XC_ONLINE_USER_ACCOUNT_STRUCT);
    VolumeMetadata.TransferBuffer = MUMetaData.VolumeName;

    Status = NtFsControlFile(Handle,
                             NULL,
                             NULL,
                             NULL,
                             &IoStatusBlock,
                             FSCTL_READ_VOLUME_METADATA,
                             &VolumeMetadata,
                             sizeof(VolumeMetadata),
                             NULL,
                             0);
    if (!NT_SUCCESS(Status))
    {
        hr = HRESULT_FROM_WIN32(RtlNtStatusToDosError(Status));
        goto Cleanup;
    }

    RtlCopyMemory( &userAccount, pUser, sizeof(XC_ONLINE_USER_ACCOUNT_STRUCT) );

    pOrigMUUser = (XC_ONLINE_USER_ACCOUNT_STRUCT*)MUMetaData.OnlineData;
    
    fSetMUVolumeName = (MUMetaData.VolumeName[0] == 0);

    if ( !fSetMUVolumeName )
    {
        for (i=0; i<XONLINE_NAME_SIZE; ++i)
        {
            if (MUMetaData.VolumeName[i] != (WCHAR)pOrigMUUser->name[i])
            {
                break;
            }
            if (pOrigMUUser->name[i] == 0)
            {
                //
                // The names match, overwrite it with new name
                //
                fSetMUVolumeName = TRUE;
                break;
            }
        }
    }

    if (fSetMUVolumeName)
    {
        //
        // Set the MU Name with the user name
        //
        for (i=0; i<XONLINE_NAME_SIZE; ++i)
        {
            MUMetaData.VolumeName[i] = (WCHAR)userAccount.name[i];
        }
    }
    
    if( userAccount.xuid.qwUserID != 0 )
    {
        EncryptKeyWithMUKey( userAccount.key, sizeof(userAccount.key) );
        SignOnlineUserStruct(&userAccount);
    }
    
    RtlCopyMemory( MUMetaData.OnlineData, &userAccount, sizeof(XC_ONLINE_USER_ACCOUNT_STRUCT) );

    VolumeMetadata.ByteOffset = FIELD_OFFSET(FAT_VOLUME_METADATA, VolumeName);
    VolumeMetadata.TransferLength = sizeof(MUMetaData.VolumeName) + sizeof(XC_ONLINE_USER_ACCOUNT_STRUCT);
    VolumeMetadata.TransferBuffer = MUMetaData.VolumeName;

    Status = NtFsControlFile(Handle,
                             NULL,
                             NULL,
                             NULL,
                             &IoStatusBlock,
                             FSCTL_WRITE_VOLUME_METADATA,
                             &VolumeMetadata,
                             sizeof(VolumeMetadata),
                             NULL,
                             0);
    hr = HRESULT_FROM_WIN32(RtlNtStatusToDosError(Status));
    
Cleanup:
    NtClose(Handle);        

    return(XoLeave(hr));
#else
    return(XoLeave(E_NOTIMPL));
#endif
}

HRESULT CXo::_XOnlineRemoveUserFromHD(
    IN PXONLINE_USER pUser
    )
{
    XoEnter("_XOnlineRemoveUserFromHD");
    XoCheck(pUser != NULL && pUser->xuid.qwUserID != 0);

    HRESULT hr;
    BYTE abConfigData[CONFIG_DATA_LENGTH];
    PXC_ONLINE_USER_ACCOUNT_STRUCT userAccounts;
    XC_ONLINE_USER_ACCOUNT_STRUCT* pUserAccount;
    DWORD i,j;
    
    pUserAccount = (XC_ONLINE_USER_ACCOUNT_STRUCT*) pUser;
    
    for (i=0; i<XONLINE_MAX_HD_ONLINE_USERS/XONLINE_MAX_ONLINE_USERS_PER_SECTOR; ++i)
    {
        if (!XNetLoadConfigSector(m_hConfigVolume, BASE_USER_ACCOUNT_CONFIG_SECTOR + i, abConfigData, CONFIG_DATA_LENGTH))
        {
            RtlZeroMemory( abConfigData , CONFIG_DATA_LENGTH );
        }
        userAccounts = (PXC_ONLINE_USER_ACCOUNT_STRUCT)abConfigData;

        for (j=0; j<XONLINE_MAX_ONLINE_USERS_PER_SECTOR; ++j)
        {
            if ( userAccounts[j].xuid.qwUserID == pUserAccount->xuid.qwUserID && VerifyOnlineUserSignature(&userAccounts[j]) )
            {
                userAccounts[j].xuid.qwUserID = 0;

                if (!XNetSaveConfigSector(m_hConfigVolume, BASE_USER_ACCOUNT_CONFIG_SECTOR + i, abConfigData, CONFIG_DATA_LENGTH))
                {
                    Assert(!"XNetSaveConfigSector failed");
                    hr = E_FAIL;
                    goto Cleanup;
                }
                
                hr = S_OK;
                goto Cleanup;
            }
        }
    }

    //
    // The user entry was not found
    //
    hr = XONLINE_E_NO_USER;

Cleanup:
    return(XoLeave(hr));
}

typedef struct _XONLINE_PIN_INPUT_STATE
{
    XINPUT_STATE previousState;
} XONLINE_PIN_INPUT_STATE, *PXONLINE_PIN_INPUT_STATE;

XPININPUTHANDLE
CXo::XOnlinePINStartInput(
    IN PXINPUT_STATE pInputState
    )
{
    XoEnter_("XOnlinePINStartInput", NULL);
    XoCheck_(pInputState != NULL, NULL);

    PXONLINE_PIN_INPUT_STATE pPinInputState;
    pPinInputState = (PXONLINE_PIN_INPUT_STATE)SysAlloc(sizeof(XONLINE_PIN_INPUT_STATE), PTAG_XONLINE_PIN_INPUT_STATE);
    if ( pPinInputState == NULL )
    {
        goto error;
    }
    pPinInputState->previousState = *pInputState;
    
error:
    return (XPININPUTHANDLE)pPinInputState;
}

#define BUTTON_LEN  FIELD_OFFSET( XINPUT_GAMEPAD, sThumbLX )

HRESULT
CXo::XOnlinePINDecodeInput(
    IN XPININPUTHANDLE handle,
    IN PXINPUT_STATE pInputState,
    IN PBYTE pPINByte
    )
{
    XoEnter("XOnlinePINDecodeInput");
    XoCheck(handle != NULL);
    XoCheck(pInputState != NULL);
    XoCheck(pPINByte != NULL);

    static XINPUT_GAMEPAD unpressedGamepad = { 0,{0,0,0,0,0,0,0,0},0,0,0,0 };
    
    PXONLINE_PIN_INPUT_STATE pPinInputState = (PXONLINE_PIN_INPUT_STATE) handle;
    HRESULT hr;
    DWORD dwButtonPress;

    if ( pPinInputState->previousState.dwPacketNumber != pInputState->dwPacketNumber )
    {
        TraceSz11( AuthVerbose, "Packet %d -> %d : %.4X %.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X",
            pPinInputState->previousState.dwPacketNumber,
            pInputState->dwPacketNumber,
            pInputState->Gamepad.wButtons,
            pInputState->Gamepad.bAnalogButtons[XINPUT_GAMEPAD_A],
            pInputState->Gamepad.bAnalogButtons[XINPUT_GAMEPAD_B],
            pInputState->Gamepad.bAnalogButtons[XINPUT_GAMEPAD_X],
            pInputState->Gamepad.bAnalogButtons[XINPUT_GAMEPAD_Y],
            pInputState->Gamepad.bAnalogButtons[XINPUT_GAMEPAD_BLACK],
            pInputState->Gamepad.bAnalogButtons[XINPUT_GAMEPAD_WHITE],
            pInputState->Gamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER],
            pInputState->Gamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] );
    }

    if ( RtlEqualMemory( &(pPinInputState->previousState.Gamepad), &unpressedGamepad, BUTTON_LEN ) )
    {
        if ( RtlEqualMemory( &(pInputState->Gamepad), &unpressedGamepad, BUTTON_LEN ) )
        {
            // Nothing new pressed
            hr = S_FALSE;
        }
        else
        {
            // New button is pressed, assume a new byte will be output.
            hr = S_OK;
            
            // Check if it is a DPAD button
            dwButtonPress = pInputState->Gamepad.wButtons & 0xf;
            if (dwButtonPress != 0)
            {
                // DPAD button is pressed.
                if (dwButtonPress == XINPUT_GAMEPAD_DPAD_UP)
                {
                    *pPINByte = 1;
                }
                else if (dwButtonPress == XINPUT_GAMEPAD_DPAD_DOWN)
                {
                    *pPINByte = 2;
                }
                else if (dwButtonPress == XINPUT_GAMEPAD_DPAD_LEFT)
                {
                    *pPINByte = 3;
                }
                else if (dwButtonPress == XINPUT_GAMEPAD_DPAD_RIGHT)
                {
                    *pPINByte = 4;
                }
                else
                {
                    // Multiple directions pressed, counts as nothing.
                    hr = S_FALSE;
                }
            }
            else
            {
                // Some analog button is pressed, find first one.
                if (pInputState->Gamepad.bAnalogButtons[XINPUT_GAMEPAD_X] > 0)
                {
                    *pPINByte = 5;
                }
                else if (pInputState->Gamepad.bAnalogButtons[XINPUT_GAMEPAD_Y] > 0)
                {
                    *pPINByte = 6;
                }
                else if (pInputState->Gamepad.bAnalogButtons[XINPUT_GAMEPAD_BLACK] > 0)
                {
                    *pPINByte = 7;
                }
                else if (pInputState->Gamepad.bAnalogButtons[XINPUT_GAMEPAD_WHITE] > 0)
                {
                    *pPINByte = 8;
                }
                else if (pInputState->Gamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] > 0)
                {
                    *pPINByte = 9;
                }
                else if (pInputState->Gamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] > 0)
                {
                    *pPINByte = 10;
                }
                else
                {
                    // no analog button pressed, counts as nothing.
                    hr = S_FALSE;
                }
            }
        }
    }
    else
    {
        // Still releasing previous button, no new input byte;
        hr = S_FALSE;
    }

    if ( hr == S_OK )
    {
        TraceSz1( AuthVerbose, "XOnlinePINDecodeInput output %d", *pPINByte );
    }

    pPinInputState->previousState = *pInputState;    

    return(XoLeave(hr));
}

HRESULT
CXo::XOnlinePINEndInput (
    IN XPININPUTHANDLE handle
    )
{
    XoEnter("XOnlinePINEndInput");
    XoCheck(handle != NULL);

    PXONLINE_PIN_INPUT_STATE pPinInputState = (PXONLINE_PIN_INPUT_STATE) handle;

    SysFree(pPinInputState);

    return(XoLeave(S_OK));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\lib\makefile.inc ===
$(XDK_LIB_PATH)\$(TARGETNAME).lib: $(SDK_LIB_PATH)\$(TARGETNAME).lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xonline.cpp ===
// ---------------------------------------------------------------------------------------
// xonline.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "xonp.h"
#include "xboxp.h"
#include "xonver.h"

// ---------------------------------------------------------------------------------------
// Main entrypoints for XOnline API
// ---------------------------------------------------------------------------------------

#ifdef XONLINE_FEATURE_XBOX
CXo * g_pXo = NULL;
#endif

#undef  XONAPI
#define XONAPI(ret, fname, arglist, paramlist) ret _XONAPI_ fname arglist { return(GetXo()->fname paramlist); }
#undef  XONAPI_
#define XONAPI_(ret, fname, arglist, paramlist)

XONLINEAPILIST()

// ---------------------------------------------------------------------------------------
// Globals
// ---------------------------------------------------------------------------------------

LONG g_lXoLock = 0;

//@@@ drm: Not used anymore.  Switch to flag in XOnlineStartup.
BOOL g_ParamCheckReturnsError = FALSE;

// ---------------------------------------------------------------------------------------
// Memory Allocation
// ---------------------------------------------------------------------------------------

const char * XoLeakTagToString(ULONG tag)
{
    switch (tag)
    {
        #undef  XONPTAG
        #define XONPTAG(_name, _tag) case PTAG_##_name: return(#_name); break;
        XONPTAGLIST()
    }

    return("?");
}

// ---------------------------------------------------------------------------------------
// XOnlineStartup & XOnlineCleanup
// ---------------------------------------------------------------------------------------

HRESULT _XONAPI_ XOnlineStartup(PXONLINE_STARTUP_PARAMS pxosp)
{
    while (InterlockedCompareExchange(&g_lXoLock, 1, 0))
    {
        Sleep(0);
    }

    HRESULT hr = S_OK;

    WSADATA WSAData;
    INT err = WSAStartup(0x0200, &WSAData);

    if (err != 0)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        if (!FAILED(hr))
        {
            hr = E_FAIL;
        }
    }

    if (hr == S_OK)
    {
        CXo ** ppXo = GetXoRef();
        CXo *  pXo  = *ppXo;

        if (pXo == NULL)
        {
            pXo = (CXo *)XoSysAlloc(sizeof(CXo), PTAG_CXo);

            if (pXo == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                memset(pXo, 0, sizeof(CXo));

                #ifdef XONLINE_FEATURE_WINDOWS
                pXo->SetXn(GetXn());
                pXo->SetAchXbox(GetAchXbox());
                #endif

                hr = pXo->Init(pxosp);

                if (FAILED(hr))
                {
                    pXo->Term();
                    XoSysFree(pXo);
                    pXo = NULL;
                }
                else
                {
                    *ppXo = pXo;
                }
            }
        }
        else
        {
            pXo->AddRef();
        }

        if (FAILED(hr))
        {
            WSACleanup();
        }
    }

    g_lXoLock = 0;

    if (FAILED(hr))
    {
        TraceSz1(Warning, "XOnlineStartup failed: %08lX", hr);
    }

    return(hr);
}

HRESULT _XONAPI_ XOnlineCleanup()
{
    HRESULT hr = S_OK;

    while (InterlockedCompareExchange(&g_lXoLock, 1, 0))
    {
        Sleep(0);
    }

    CXo ** ppXo = GetXoRef();
    CXo *  pXo  = *ppXo;

    if (pXo == NULL)
    {
        hr = XONLINE_E_NOT_INITIALIZED;
    }
    else
    {
        if (pXo->Release() == 0)
        {
            pXo->Term();
            XoSysFree(pXo);
            *ppXo = NULL;
        }

        WSACleanup();
    }

    g_lXoLock = 0;

    if (FAILED(hr))
    {
        TraceSz1(Warning, "XOnlineCleanup failed: %08lX", hr);
    }

    return(hr);
}

// ---------------------------------------------------------------------------------------
// CXo::Init
// ---------------------------------------------------------------------------------------

HRESULT CXo::Init(PXONLINE_STARTUP_PARAMS pxosp)
{
    HRESULT hr;
    
#ifdef XNET_FEATURE_ASSERT
    m_LeakInfo._pfnLeakTag = XoLeakTagToString;
#endif

#ifdef XONLINE_FEATURE_XBOX
    PXBEIMAGE_CERTIFICATE pCert = XeImageHeader()->Certificate;
    m_dwTitleId         = pCert->TitleID;
    m_dwTitleVersion    = pCert->Version;
    m_dwTitleGameRegion = pCert->GameRegion;
    AssertSz( m_dwTitleId != 0, "The TitleID cannot be zero because the presence system will fail" );
#else
    m_dwTitleId         = 1234;
    m_dwTitleVersion    = 1;
    m_dwTitleGameRegion = 0xFFFFFFFF;
#endif

    XONLINE_DNS_CACHE_ENTRY * pdce = m_DNSCache;
    (pdce++)->name = PASSPORT_AS_DNS;
    (pdce++)->name = PASSPORT_WEB_DNS;
    (pdce++)->name = PASSPORT_TGS_DNS;
    (pdce++)->name = XBOX_KDC_DNS;
    (pdce++)->name = MACS_KDC_DNS;

    m_hConfigVolume = XNetOpenConfigVolume();

    if (m_hConfigVolume == INVALID_HANDLE_VALUE)
    {
        hr = E_FAIL; // TODO something better
        goto Cleanup;
    }

	//
	// Open the recent logon time cache
	//
    hr = CacheOpen(XONLC_TYPE_RECENT_LOGON_TIME, NULL, NULL, &m_hLogonTimeCache, &m_hLogonTimeCacheTask);
    if (FAILED(hr))
    {
        m_hLogonTimeCache = NULL;
        m_hLogonTimeCacheTask = NULL;
        m_dwLogonTimeCacheState = XON_CACHE_STATE_ERROR;
    }
    else
    {
        m_dwLogonTimeCacheState = XON_CACHE_STATE_OPENING;
    }
    
    m_qwMachineId = -1;
    
    KRB5_Module_Startup(&m_KRB5_Module);

#ifdef XONLINE_FEATURE_INSECURE
    InitOverrideInfo();
#endif

    XnSetXoBase(this);

    m_cRefs = 1;

    hr = S_OK;
    
Cleanup:
    return(hr);
}

void CXo::Term()
{
    DWORD i;
    Assert(m_cRefs == 0);

    for (i=0; i<m_ctAllocatedServiceContexts; ++i)
    {
        SysFree( m_pAllocatedServiceContexts[i] );
    }

    if (m_hConfigVolume != INVALID_HANDLE_VALUE)
    {
        XNetCloseConfigVolume(m_hConfigVolume);
    }

    if (m_hLogonTimeCacheTask != NULL)
    {
        XOnlineTaskClose(m_hLogonTimeCacheTask);
    }
    
    if (m_hLogonTimeCache != NULL)
    {
        CacheClose(m_hLogonTimeCache);
    }

#ifdef XNET_FEATURE_ASSERT
    if (m_LeakInfo._cLeak > 0)
    {
        XnLeakTerm(&m_LeakInfo);
    }
#endif

    XnSetXoBase(NULL);
}


DWORD CXo::_XOnlineSetTitleId(DWORD dwTitleId)
{
    AssertSz( dwTitleId != 0, "The TitleID cannot be set to zero because the presence system will fail" );
#ifdef XONLINE_FEATURE_INSECURE
    return m_dwTitleId = dwTitleId;
#else
    return m_dwTitleId;
#endif
}


DWORD CXo::_XOnlineSetTitleVersion(DWORD dwTitleVersion)
{
#ifdef XONLINE_FEATURE_INSECURE
    return m_dwTitleVersion = dwTitleVersion;
#else
    return m_dwTitleVersion;
#endif
}


DWORD CXo::_XOnlineSetTitleGameRegion(DWORD dwTitleGameRegion)
{
#ifdef XONLINE_FEATURE_INSECURE
    return m_dwTitleGameRegion = dwTitleGameRegion;
#else
    return m_dwTitleGameRegion;
#endif
}


HRESULT CXo::_XOnlineGetMachineID(ULONGLONG* pqwMachineID)
{
    XoEnter("_XOnlineGetMachineID");
    XoCheck(pqwMachineID != NULL);

    BYTE abConfigData[CONFIG_DATA_LENGTH];

    if (m_qwMachineId == -1)
    {
        m_qwMachineId = 0;
        if (XNetLoadConfigSector(m_hConfigVolume, MACHINE_ACCOUNT_CONFIG_SECTOR, abConfigData, CONFIG_DATA_LENGTH))
        {
            m_qwMachineId = ((XC_ONLINE_MACHINE_ACCOUNT_STRUCT*)abConfigData)->xuid.qwUserID;
        }
    }
    *pqwMachineID = m_qwMachineId;

    return(XoLeave(S_OK));
}

HRESULT CXo::_XOnlineGetSerialNumber(CHAR abSerialNumber[12])
{
    XoEnter("_XOnlineGetSerialNumber");

    HRESULT hr = S_OK;
    NTSTATUS Status;
    DWORD dwType;
    DWORD cbResultLength;

    //
    // Read Serial Number from the EEPROM
    //
    Status = ExQueryNonVolatileSetting(XC_FACTORY_SERIAL_NUMBER, &dwType, abSerialNumber, 12, &cbResultLength);
    if (Status != ERROR_SUCCESS)
    {
        hr = Status;
    }
    else
    {
        Assert( dwType == REG_BINARY );
        Assert( cbResultLength == 12 );
    }

    return(XoLeave(hr));
}

// ---------------------------------------------------------------------------------------
// Windows support
// ---------------------------------------------------------------------------------------
    
#ifdef XONLINE_FEATURE_WINDOWS

#include <xboxp.h>

DWORD CXo::XGetParentalControlSetting()
{
    ULONG ulType;
    DWORD dwValue;
    return(NT_SUCCESS(ExQueryNonVolatileSetting(XC_PARENTAL_CONTROL_GAMES, &ulType, &dwValue, sizeof(dwValue), NULL)) ? dwValue : 0);
}

DWORD CXo::XGetLanguage()
{
    ULONG ulType;
    DWORD dwValue;
    return NT_SUCCESS(ExQueryNonVolatileSetting(XC_LANGUAGE, &ulType, &dwValue, sizeof(dwValue), NULL)) ? dwValue : XC_LANGUAGE_UNKNOWN;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\libs\makefile.inc ===
$(XDK_LIB_PATH)\$(TARGETNAME).lib: $(SDK_LIB_PATH)\$(TARGETNAME).lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\libw\makefile.inc ===
$(XDK_LIB_PATH)\$(TARGETNAME).lib: $(SDK_LIB_PATH)\$(TARGETNAME).lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\libwt\makefile.inc ===
$(XDK_LIB_PATH)\$(TARGETNAME).lib: $(SDK_LIB_PATH)\$(TARGETNAME).lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xonlzx.cpp ===
/*
 * decapi.c
 *
 * API entry points.
 */

#include "xonp.h"
#include "xonver.h"

const byte NEAR dec_extra_bits[] =
{
	0,0,0,0,1,1,2,2,
	3,3,4,4,5,5,6,6,
	7,7,8,8,9,9,10,10,
	11,11,12,12,13,13,14,14,
	15,15,16,16,17,17,17,17,
	17,17,17,17,17,17,17,17,
	17,17,17,17,17,17,17,17,
	17,17,17,17,17,17,17,17,
	17,17,17,17,17,17,17,17,
	17,17,17,17,17,17,17,17,
	17,17,17,17,17,17,17,17,
	17,17,17,17,17,17,17,17,
	17,17,17,17,17,17,17,17,
	17,17,17,17,17,17,17,17,
	17,17,17,17,17,17,17,17,
	17,17,17,17,17,17,17,17,
	17,17,17,17,17,17,17,17,
	17,17,17,17,17,17,17,17,
	17,17,17,17,17,17,17,17,
	17,17,17,17,17,17,17,17,
	17,17,17,17,17,17,17,17,
	17,17,17,17,17,17,17,17,
	17,17,17,17,17,17,17,17,
	17,17,17,17,17,17,17,17,
	17,17,17,17,17,17,17,17,
	17,17,17,17,17,17,17,17,
	17,17,17,17,17,17,17,17,
	17,17,17,17,17,17,17,17,
	17,17,17,17,17,17,17,17,
	17,17,17,17,17,17,17,17,
	17,17,17,17,17,17,17,17,
	17,17,17,17,17,17,17,17,
	17,17,17,17,17,17,17,17,
	17,17,17,17,17,17,17,17,
	17,17,17,17,17,17,17,17,
	17,17,17,17,17,17,17,17,
	17,17,17
};

/*
 * first (base) position covered by each slot
 * 2 subtracted for optimisation purposes (see decverb.c/decalign.c comments)
 */
const long NEAR MP_POS_minus2[sizeof(dec_extra_bits)] =
{
	0-2,        1-2,        2-2,        3-2,        4-2,        6-2,        8-2,        12-2,
	16-2,       24-2,       32-2,       48-2,       64-2,       96-2,       128-2,      192-2,
	256-2,      384-2,      512-2,      768-2,      1024-2,     1536-2,     2048-2,     3072-2,
	4096-2,     6144-2,     8192-2,     12288-2,    16384-2,    24576-2,    32768-2,    49152-2,
	65536-2,    98304-2,    131072-2,   196608-2,   262144-2,   393216-2,   524288-2,   655360-2,
	786432-2,   917504-2,   1048576-2,  1179648-2,  1310720-2,  1441792-2,  1572864-2,  1703936-2,
	1835008-2,  1966080-2,  2097152-2,  2228224-2,  2359296-2,  2490368-2,  2621440-2,  2752512-2,
	2883584-2,  3014656-2,  3145728-2,  3276800-2,  3407872-2,  3538944-2,  3670016-2,  3801088-2,
	3932160-2,  4063232-2,  4194304-2,  4325376-2,  4456448-2,  4587520-2,  4718592-2,  4849664-2,
	4980736-2,  5111808-2,  5242880-2,  5373952-2,  5505024-2,  5636096-2,  5767168-2,  5898240-2,
	6029312-2,  6160384-2,  6291456-2,  6422528-2,  6553600-2,  6684672-2,  6815744-2,  6946816-2,
	7077888-2,  7208960-2,  7340032-2,  7471104-2,  7602176-2,  7733248-2,  7864320-2,  7995392-2,
	8126464-2,  8257536-2,  8388608-2,  8519680-2,  8650752-2,  8781824-2,  8912896-2,  9043968-2,
	9175040-2,  9306112-2,  9437184-2,  9568256-2,  9699328-2,  9830400-2,  9961472-2,  10092544-2,
	10223616-2, 10354688-2, 10485760-2, 10616832-2, 10747904-2, 10878976-2, 11010048-2, 11141120-2,
	11272192-2, 11403264-2, 11534336-2, 11665408-2, 11796480-2, 11927552-2, 12058624-2, 12189696-2,
	12320768-2, 12451840-2, 12582912-2, 12713984-2, 12845056-2, 12976128-2, 13107200-2, 13238272-2,
	13369344-2, 13500416-2, 13631488-2, 13762560-2, 13893632-2, 14024704-2, 14155776-2, 14286848-2,
	14417920-2, 14548992-2, 14680064-2, 14811136-2, 14942208-2, 15073280-2, 15204352-2, 15335424-2,
	15466496-2, 15597568-2, 15728640-2, 15859712-2, 15990784-2, 16121856-2, 16252928-2, 16384000-2,
	16515072-2, 16646144-2, 16777216-2, 16908288-2, 17039360-2, 17170432-2, 17301504-2, 17432576-2,
	17563648-2, 17694720-2, 17825792-2, 17956864-2, 18087936-2, 18219008-2, 18350080-2, 18481152-2,
	18612224-2, 18743296-2, 18874368-2, 19005440-2, 19136512-2, 19267584-2, 19398656-2, 19529728-2,
	19660800-2, 19791872-2, 19922944-2, 20054016-2, 20185088-2, 20316160-2, 20447232-2, 20578304-2,
	20709376-2, 20840448-2, 20971520-2, 21102592-2, 21233664-2, 21364736-2, 21495808-2, 21626880-2,
	21757952-2, 21889024-2, 22020096-2, 22151168-2, 22282240-2, 22413312-2, 22544384-2, 22675456-2,
	22806528-2, 22937600-2, 23068672-2, 23199744-2, 23330816-2, 23461888-2, 23592960-2, 23724032-2,
	23855104-2, 23986176-2, 24117248-2, 24248320-2, 24379392-2, 24510464-2, 24641536-2, 24772608-2,
	24903680-2, 25034752-2, 25165824-2, 25296896-2, 25427968-2, 25559040-2, 25690112-2, 25821184-2,
	25952256-2, 26083328-2, 26214400-2, 26345472-2, 26476544-2, 26607616-2, 26738688-2, 26869760-2,
	27000832-2, 27131904-2, 27262976-2, 27394048-2, 27525120-2, 27656192-2, 27787264-2, 27918336-2,
	28049408-2, 28180480-2, 28311552-2, 28442624-2, 28573696-2, 28704768-2, 28835840-2, 28966912-2,
	29097984-2, 29229056-2, 29360128-2, 29491200-2, 29622272-2, 29753344-2, 29884416-2, 30015488-2,
	30146560-2, 30277632-2, 30408704-2, 30539776-2, 30670848-2, 30801920-2, 30932992-2, 31064064-2,
	31195136-2, 31326208-2, 31457280-2, 31588352-2, 31719424-2, 31850496-2, 31981568-2, 32112640-2,
	32243712-2, 32374784-2, 32505856-2, 32636928-2, 32768000-2, 32899072-2, 33030144-2, 33161216-2,
	33292288-2, 33423360-2, 33554432-2
};

/*
 * Set/reset decoder trees to initial state
 */
void NEAR reset_decoder_trees(t_decoder_context *context)
{
	memset(context->dec_main_tree_len, 0, MAIN_TREE_ELEMENTS);
	memset(context->dec_main_tree_prev_len, 0, MAIN_TREE_ELEMENTS);

	memset(context->dec_secondary_length_tree_len, 0, NUM_SECONDARY_LENGTHS);
	memset(context->dec_secondary_length_tree_prev_len, 0, NUM_SECONDARY_LENGTHS);
}


/*
 * Miscellaneous state initialisations
 */
void NEAR decoder_misc_init(t_decoder_context *context)
{
	context->dec_last_matchpos_offset[0] = 1;
	context->dec_last_matchpos_offset[1] = 1;
	context->dec_last_matchpos_offset[2] = 1;

	context->dec_bufpos = 0;
    context->dec_position_at_start = 0;

	context->dec_decoder_state	= DEC_STATE_START_NEW_BLOCK;
	context->dec_block_size		= 0;

    /* so that initialise_decoder_bitbuf() will succeed */
    context->dec_block_type     = BLOCKTYPE_INVALID;

	context->dec_first_time_this_group	= true;
	context->dec_current_file_size		= 0;

    context->dec_error_condition = false;
}


void CXo::LzxResetDecoder(PXONLINE_LZXDECODER_CONTEXT pContext)
{
	reset_decoder_trees(pContext);
	decoder_misc_init(pContext);
	init_decoder_translation(pContext);
    pContext->dec_num_cfdata_frames = 0;
}

bool CXo::LzxDecodeInit(byte * pbWindowBuffer, ulong ulWindowSize, PXONLINE_LZXDECODER_CONTEXT pContext)
{
	ulong	pos_start;

//	Assert(pbWindowBuffer != NULL);
//	Assert(pContext != NULL);

	// Decompression window size must be a power of two
//  Assert((dwWindowSize & (dwWindowSize - 1)) == 0);
		
	pContext->dec_window_size = ulWindowSize;
	pContext->dec_mem_window = pbWindowBuffer;
	pContext->dec_window_mask = pContext->dec_window_size - 1;

	// Extra long matches not supported by default
	pContext->dec_extra_long_matches = FALSE;

	// Figure out how many slots given the window size
	pContext->dec_num_position_slots = 4;
	pos_start = 4;

	while (1)
	{
        pos_start += 1L << dec_extra_bits[pContext->dec_num_position_slots];

		pContext->dec_num_position_slots++;

		if (pos_start >= pContext->dec_window_size)
			break;
	}

	// Initialize the decoder context
	LzxResetDecoder(pContext);

	return(true);
}

void CXo::LzxEnableExtraLongMatches(PXONLINE_LZXDECODER_CONTEXT pContext)
{
	pContext->dec_extra_long_matches = TRUE;
}

bool CXo::LzxDecode(
			PXONLINE_LZXDECODER_CONTEXT	pContext,
			ulong						cbDecodedSize,
			byte						*pbInput,
			ulong						cbInput,
			byte						*pbOutput,
			ulong						*pcbBytesDecoded
			)
{
	bool	fResult = true;
	long	lDecoded;

//	Assert(pContext != NULL);
//	Assert(pbInput != NULL);
//	Assert(cbInput != 0);
//	Assert(pbOutput != NULL);
//	Assert(cbDecodedSize >= cbInput);

   	if (pcbBytesDecoded)
		*pcbBytesDecoded = 0;

    pContext->dec_input_curpos   = pbInput;
    pContext->dec_end_input_pos  = (pbInput + cbInput + 4);

    pContext->dec_output_buffer  = pbOutput;

	init_decoder_input(pContext);

	// Call the decode function
	lDecoded = decode_data(pContext, cbDecodedSize);
    if (lDecoded < 0)
    {
    	// Failure
    	fResult = false;
    }
    else
    {
	    // Update next starting position
        pContext->dec_position_at_start += lDecoded;

    	if (pcbBytesDecoded)
	        *pcbBytesDecoded = lDecoded;
	}

    pContext->dec_num_cfdata_frames++;

    return(fResult);
}

bool CXo::LzxPopulateDictionary(
			PXONLINE_LZXDECODER_CONTEXT pContext, 
			byte *pbData, 
			ulong cbData)
{
    if (cbData > pContext->dec_window_size)
        return(false);

    memcpy(&(pContext->dec_mem_window[pContext->dec_window_size - cbData]), pbData, cbData);

    return(true);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xontask.cpp ===
/*++

Copyright (c) Microsoft Corporation

Description:
    Module implementing Xbox Online Task pump APIs

Module Name:

    xontask.c

--*/

#include "xonp.h"
#include "xonver.h"

//
// DEBUG ONLY: Define the valid signature XONT
//
#if DBG
#define XONLINETASK_SIGNATURE   ((DWORD)('TNOX'))
#endif

//
// Helper function to initialize the task context
//
VOID CXo::TaskInitializeContext(PXONLINETASK_CONTEXT pContext)
{
	Assert(pContext != NULL);

	// Clear eveyrhting
	ZeroMemory(pContext, sizeof(XONLINETASK_CONTEXT));

#if DBG 
	pContext->dwSignature = XONLINETASK_SIGNATURE;
	pContext->dwThreadId = 0;
#endif
}

//
// Helper function to verify a task context
//
void CXo::TaskVerifyContext(PXONLINETASK_CONTEXT pContext)
{
    Assert(pContext != NULL);
    Assert(pContext->dwSignature == XONLINETASK_SIGNATURE);
}

//
// Continuation function to execute the task associated with the handle
//
HRESULT CXo::XOnlineTaskContinue(XONLINETASK_HANDLE hTask)
{
    XoEnter("XOnlineTaskContinue");
    XoCheck(hTask != NULL);

	HRESULT hr;
	PXONLINETASK_CONTEXT pContext = (PXONLINETASK_CONTEXT)hTask;

#if DBG 
	TaskVerifyContext(pContext);

    DWORD dwThreadID = GetCurrentThreadId();
    DWORD dwPrevThreadID;
    dwPrevThreadID = InterlockedCompareExchange(
                (PLONG)&pContext->dwThreadId,
                dwThreadID,
                0);

    AssertSz(dwPrevThreadID != dwThreadID, "Recursively calling the same task");
    AssertSz(dwPrevThreadID == 0, "Another thread is working on this task");
#endif

    hr = (this->*(pContext->pfnContinue))(hTask);

#if DBG
    pContext->dwThreadId = 0;
#endif

    return(XoLeave(hr));
}

//
// Function to release a task handle, and all its task-allocated resources
//
HRESULT CXo::XOnlineTaskClose(XONLINETASK_HANDLE hTask)
{
    XoEnter("XOnlineTaskClose");
    XoCheck(hTask != NULL);

	PXONLINETASK_CONTEXT pContext = (PXONLINETASK_CONTEXT)hTask;

#if DBG 
	TaskVerifyContext(pContext);

    AssertSz(pContext->dwThreadId == 0, "Trying to close a task that another thread is still working on");
#endif

    (this->*(pContext->pfnClose))(hTask);

    return(XoLeave(S_OK));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xonver.h ===
// ---------------------------------------------------------------------------------------
// xonver.h
//
// Include file for stamping source files with the appropriate version structure
// ---------------------------------------------------------------------------------------

#ifdef  __XONVER_H__
#error "xonver.h should not be included more than once"
#endif
#define __XONVER_H__

#ifdef __cplusplus
extern "C" {
#endif

#include <xboxverp.h>

#ifdef XONLINE_FEATURE_XBOX
#pragma data_seg(push)
#pragma data_seg(".XBLD$V")
#endif

#if defined(XONLINE_BUILD_LIBX) && DBG==0
    #define VERXON()    VERGEN(XOnlineBuildNumber,  'X','O','N','L','I','N','E',0)
#elif defined(XONLINE_BUILD_LIBX) 
    #define VERXON()    VERGEN(XOnlineBuildNumberD, 'X','O','N','L','I','N','E','D')
#elif defined(XONLINE_BUILD_LIBS) && DBG==0
    #define VERXON()    VERGEN(XOnlineBuildNumberS, 'X','O','N','L','I','N','E','S')
#elif defined(XONLINE_BUILD_LIBS)
    #define VERXON()    VERGEN(XOnlineBuildNumberSD,'X','O','N','L','I','N','S','D')
#elif defined(XONLINE_BUILD_LIBW) && DBG==0
    #define VERXON()    VERGEN(XOnlineBuildNumberW, 'X','O','N','L','I','N','E','W')
#elif defined(XONLINE_BUILD_LIBW)
    #define VERXON()    VERGEN(XOnlineBuildNumberWD,'X','O','N','L','I','N','W','D')
#else
    #error "Don't know how to make VERXON"
#endif

#if DBG
#define VERDBG  0x8000
#else
#define VERDBG  0x0000
#endif

#if DBG==0 && defined(XONLINE_BUILD_LIBS)
#define VERSEC  0x0000
#else
#define VERSEC  0x0000
#endif

#define VERGEN(var,a1,a2,a3,a4,a5,a6,a7,a8) comment(linker, "/include:_" # var)
#pragma VERXON()
#undef  VERGEN
#define VERGEN(var,a1,a2,a3,a4,a5,a6,a7,a8) var[8] = { (a1) | ((a2) << 8), (a3) | ((a4) << 8), (a5) | ((a6) << 8), (a7) | ((a8) << 8), VER_PRODUCTVERSION | VERDBG | VERSEC }
__declspec(selectany) unsigned short VERXON();
#undef  VERGEN
#undef  VERDBG
#undef  VERSEC
#undef  VERXON

#ifdef XONLINE_FEATURE_XBOX
#pragma data_seg(pop)
#endif

#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xonp.h ===
// ---------------------------------------------------------------------------------------
// xonp.h
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#ifndef __XONP_H__
#define __XONP_H__

// ---------------------------------------------------------------------------------------
// To Do List
//
// @@@ [tonychen] Add pool allocator (startup params, private heap)
// @@@ [tonychen] Call XnRaiseToDpc when modifying shared data (XOKERBINFO)
// ---------------------------------------------------------------------------------------

#pragma code_seg("XONLINE")
#pragma const_seg("XON_RD")

// ---------------------------------------------------------------------------------------
// Configuration
// ---------------------------------------------------------------------------------------

#ifndef DBG
#define DBG 0
#endif

#define XNET_FEATURE_ONLINE

#if DBG
    #define XNET_FEATURE_ASSERT
    #define XNET_FEATURE_TRACE
#endif

#if defined(XONLINE_BUILD_LIBS)
    #define XONLINE_FEATURE_XBOX
    #if DBG
        #pragma message("Building xonlinesd.lib")
    #else
        #pragma message("Building xonlines.lib")
    #endif
#elif defined(XONLINE_BUILD_LIBX)
    #define XONLINE_FEATURE_XBOX
    #define XONLINE_FEATURE_INSECURE
    #if DBG
        #pragma message("Building xonlined.lib")
    #else
        #pragma message("Building xonline.lib")
    #endif
#elif defined(XONLINE_BUILD_LIBW)
    #define XNET_FEATURE_WINDOWS
    #define XONLINE_FEATURE_WINDOWS
    #define XONLINE_FEATURE_INSECURE
    #if DBG
        #pragma message("Building xonlinewd.lib")
        #define XNET_FEATURE_VMEM
    #else
        #pragma message("Building xonlinew.lib")
    #endif
#else
    #error "Don't know which xonline library to build"
#endif

#ifdef XONLINE_FEATURE_INSECURE
#pragma message("  XONLINE_FEATURE_INSECURE")
#endif

#ifdef XONLINE_FEATURE_WINDOWS
#pragma message("  XONLINE_FEATURE_WINDOWS")
#endif

#ifdef XONLINE_FEATURE_XBOX
#pragma message("  XONLINE_FEATURE_XBOX")
#endif

// ---------------------------------------------------------------------------------------
// Includes
// ---------------------------------------------------------------------------------------

#ifdef XONLINE_FEATURE_XBOX
    #include <xapip.h>
    #include <xtl.h>
#endif

#ifdef XONLINE_FEATURE_WINDOWS
    #include <nt.h>
    #include <ntrtl.h>
    #include <nturtl.h>
    #include <windows.h>
    struct cab_file_list_header;
#endif

#include <winsockx.h>
#include <winsockp.h>
#include <xbox.h>
#include <xn.h>
#include <rsa.h>
#include <xcrypt.h>
#include <cabinet.h>
#include <xcabinet.h>
#include <dgstfile.h>
#include <krb5.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <winnls.h>

#ifndef FIELD_OFFSET
#define FIELD_OFFSET(type, field)    ((LONG)&(((type *)0)->field))
#endif

// ---------------------------------------------------------------------------------------
// Parameter Checking
// ---------------------------------------------------------------------------------------

#undef RIP_ON_NOT_TRUE
#undef RIP_ON_NOT_TRUE_WITH_MESSAGE

extern BOOL g_ParamCheckReturnsError;

#ifdef XNET_FEATURE_ASSERT
    #define XoEnter_(_fname, _ret) \
        const char * __pszFName__ = _fname; \
        do { if (this == NULL) { \
                 TraceSz1(Warning, "%s: You must call XOnlineStartup before calling this function.", _fname); \
                 return(_ret); } } while (0)
    #define XoCheck_(_pcheck, _ret) \
        do { if (!(_pcheck)) { \
            TraceSz2(Warning, "%s: Expression '%s' failed", __pszFName__, #_pcheck); \
            if (!g_ParamCheckReturnsError) { Rip("bad XOnline parameters\n"); } \
            return(_ret); } \
        } while (0)
    INLINE HRESULT XoLeave_(HRESULT hr, const char * pszFName) { \
        if (FAILED(hr)) { TraceSz2(Warning, "%s failed: %08lX", pszFName, hr); } \
        return(hr); }
    #define XoLeave(_hr)     XoLeave_(_hr, __pszFName__)
#else
    #define XoEnter_(_fname, _ret) do { if (this == NULL) return(_ret); } while (0)
    #define XoCheck_(_pcheck, _ret)
    #define XoLeave(_hr) _hr
#endif

#define XoEnter(_fname)  XoEnter_(_fname, XONLINE_E_NOT_INITIALIZED)
#define XoCheck(_pcheck) XoCheck_(_pcheck, E_INVALIDARG)

// ---------------------------------------------------------------------------------------
// Memory Tags
// ---------------------------------------------------------------------------------------

#define XONPTAGLIST() \
    XONPTAG(CXo,                                'XON_') \
    XONPTAG(XONLINETASK_AUTOUPD_DVD,            'XON0') \
    XONPTAG(XONLINETASK_FILEIO,                 'XON1') \
    XONPTAG(XONLINETASK_SOCKIO,                 'XON2') \
    XONPTAG(XO_PURCHASE_TASK,                   'XON3') \
    XONPTAG(XO_CANCEL_TASK,                     'XON4') \
    XONPTAG(XO_DETAILS_TASK,                    'XON5') \
    XONPTAG(XO_OFFERING_VERIFY_LICENSE_TASK,    'XON6') \
    XONPTAG(XONLINETASK_CONTENT_DOWNLOAD,       'XON7') \
    XONPTAG(XONLINETASK_OFFERING_ENUM,          'XON8') \
    XONPTAG(XONLINECONTENT_ENUM_TITLES,         'XON9') \
    XONPTAG(XONLINETASK_CONTENT_REMOVE,         'XONa') \
    XONPTAG(XONLINETASK_CONTENT_VERIFY,         'XONb') \
    XONPTAG(XONLINETASK_DIROPS,                 'XONd') \
    XONPTAG(XONLINETASK_DOWNLOAD_MEMORY,        'XONe') \
    XONPTAG(XONLINETASK_DOWNLOAD_FILE,          'XONf') \
    XONPTAG(XKERB_PA_XBOX_ACCOUNT_CREATION,     'XONg') \
    XONPTAG(XONLINETASK_CACHE,                  'XONh') \
    XONPTAG(CLocalCache,                        'XONi') \
    XONPTAG(CSector,                            'XONj') \
    XONPTAG(XKERB_TGT_CONTEXT,                  'XONk') \
    XONPTAG(XONLINETASK_GET_SINGLE_TICKET,      'XONl') \
    XONPTAG(XONLINETASK_GET_MACHINE_ACCOUNT,    'XONm') \
    XONPTAG(XONLINE_TGS_COMBINE_REQUEST_BUFFER, 'XONn') \
    XONPTAG(XKERB_COMBINED_TGT_CONTEXT,         'XONo') \
    XONPTAG(XONLINETASK_GET_COMBINED_TICKET,    'XONp') \
    XONPTAG(XKERB_SERVICE_CONTEXT,              'XONq') \
    XONPTAG(XONLINETASK_GET_SERVICE_TICKET,     'XONr') \
    XONPTAG(XONLINETASK_LOGON,                  'XONs') \
    XONPTAG(XMATCH_EXTENDED_HANDLE,             'XONt') \
    XONPTAG(XMATCH_POST_BUFFER,                 'XONu') \
    XONPTAG(XMATCH_RESULTS_BUFFER,              'XONv') \
    XONPTAG(XMATCH_SEARCHRESULT,                'XONw') \
    XONPTAG(XONLINECTXT_TITLECACHE,             'XONx') \
    XONPTAG(XONLINE_USERDATA,                   'XONy') \
    XONPTAG(XPRESENCE_EXTENDED_HANDLE,          'XONz') \
    XONPTAG(XPRESENCE_MESSAGE_BUFFER,           'XONA') \
    XONPTAG(XPRESENCE_HANDLE_LIST,              'XONB') \
    XONPTAG(OVERRIDE_INFO,                      'XONC') \
    XONPTAG(XONLINETASK_UPLOAD_MEMORY,          'XOND') \
    XONPTAG(XONLINETASK_UPLOAD_FILE,            'XONE') \
    XONPTAG(XONLINE_PIN_INPUT_STATE,            'XONF') \
    XONPTAG(XO_CREATE_ACCT_TASK,                'XONG') \
    XONPTAG(GET_TAGS_TASK,                      'XONH') \
    XONPTAG(GET_TAGS_REQUEST,                   'XONI') \
    XONPTAG(GET_TAGS_RESPONSE,                  'XONJ') \
    XONPTAG(GET_TAGS_RESULTS,                   'XONK') \
    XONPTAG(XONLINETASK_AUTOUPD_ONLINE,         'XONL') \
    XONPTAG(XPRESENCE_GAMEINVITE_RECORD,        'XONM') \
    XONPTAG(RESERVE_NAME_TASK,                  'XONN') \
    XONPTAG(RESERVE_NAME_REQUEST,               'XONO') \
    XONPTAG(RESERVE_NAME_RESPONSE,              'XONP') \
    XONPTAG(RESERVE_NAME_RESULTS,               'XONQ') \
    XONPTAG(XONMSGCLIENT_REQUEST,               'XONR') \
    XONPTAG(XONMSGCLIENT_WORKBUFFER,            'XONS') \
    XONPTAG(CREATE_ACCT_TASK,                   'XONT') \
    XONPTAG(CREATE_ACCT_REQUEST,                'XONU') \
    XONPTAG(CREATE_ACCT_RESPONSE,               'XONV') \

#undef  XONPTAG
#define XONPTAG(_name, _tag) PTAG_##_name = NTOHL_(_tag),

enum { XONPTAGLIST() };

// ---------------------------------------------------------------------------------------
// Scratch memory management routines
// ---------------------------------------------------------------------------------------

extern const XBOX_LIBRARY_VERSION g_ClientVersion;

//
// If Count is not already aligned, then
// round Count up to an even multiple of "Pow2".  "Pow2" must be a power of 2.
//
#define ROUND_UP_COUNT(Count,Pow2) \
        ( ((Count)+(Pow2)-1) & (~(((LONG)(Pow2))-1)) )

#define SCRATCH_MEMORY_ALIGNMENT 4

ExternTag(ScratchMemoryVerbose);
ExternTag(ScratchMemoryAlloc);

#define SCRATCH_MEMORY_STACK_SIZE 8

//@@@ drm: take some of these inlines away and make normal functions

class CScratchMemoryAllocator
{
private:
    PBYTE m_pbStart;
    PBYTE m_pbEnd;
    PBYTE m_pbCurrent;
    PBYTE m_pbTempBuffer;
    DWORD m_dwTempBufferSize;
    DWORD m_dwStackPointer;
    PBYTE m_Stack[SCRATCH_MEMORY_STACK_SIZE];
    #ifdef XNET_FEATURE_TRACE
    PBYTE m_pbPeakUsage;
    #endif    
    CXo * m_pXo;

public:
    INLINE CScratchMemoryAllocator()
    {
        m_pbStart = NULL;
    }
    
    //
    // This must be a macro or else _alloca won't work
    //
    #define ScratchMemoryInitialize( size, tempBuf, tempBufSize, pXo ) ScratchMemoryInitializeHelper(_alloca( (size) ), (size), (tempBuf), (tempBufSize), (pXo))

    INLINE PVOID ScratchMemoryInitializeHelper( IN PVOID ptr, IN size_t size, IN PVOID tempBuffer, IN size_t tempBufferSize , IN CXo * pXo)
    {
        AssertSz(m_pbStart == NULL,"Scratch Memory already in use");
        m_pbStart = (PBYTE)ptr;
        m_dwTempBufferSize = 0;
        AssertSz(m_pbStart != NULL,"Scratch Memory Initialize _alloca failed");
        if (m_pbStart != NULL)
        {
            m_pbCurrent = m_pbStart;
            m_pbEnd = m_pbStart + size;
            m_dwStackPointer = 0;
            RtlZeroMemory( m_pbStart, size );
            m_pbTempBuffer = (PBYTE)tempBuffer;
            if (m_pbTempBuffer != NULL)
            {
                Assert( tempBufferSize > 0 );
                m_dwTempBufferSize = tempBufferSize;
            }
            else
            {
                Assert( tempBufferSize == 0 );
            }
            #ifdef XNET_FEATURE_TRACE
            m_pbPeakUsage = m_pbStart;
            #endif    
            m_pXo = pXo;
        }
        return m_pbStart;
    }

    INLINE ~CScratchMemoryAllocator()
    {
        TraceSz2(ScratchMemoryVerbose, "Destructing, peak %d out of %d used",
                m_pbPeakUsage - m_pbStart,
                m_pbEnd - m_pbStart);
    }

    INLINE CXo * GetXoPtr()
    {
        return(m_pXo);
    }

    INLINE PVOID TempBuffer()
    {
        return m_pbTempBuffer;
    }
        
    INLINE DWORD TempBufferSize()
    {
        return m_dwTempBufferSize;
    }
        
    INLINE PVOID Alloc( IN size_t BufferSize )
    {
        PBYTE CurrentPosition;
        Assert(m_pbStart != NULL);
        CurrentPosition = m_pbCurrent;
        BufferSize = ROUND_UP_COUNT(BufferSize,SCRATCH_MEMORY_ALIGNMENT);
        m_pbCurrent += BufferSize;
        TraceSz3(ScratchMemoryAlloc, "Alloc %d, now used %d out of %d", BufferSize,
                m_pbCurrent - m_pbStart,
                m_pbEnd - m_pbStart);
        AssertSz(m_pbCurrent <= m_pbEnd,"Out of Scratch Memory");
        if (m_pbCurrent > m_pbEnd)
        {
            m_pbCurrent = CurrentPosition;
            CurrentPosition = NULL;
        }
        #ifdef XNET_FEATURE_TRACE
        if (m_pbPeakUsage < m_pbCurrent)
        {
            m_pbPeakUsage = m_pbCurrent;
        }
        #endif    
        return CurrentPosition;
    }

    INLINE PVOID ReAlloc( IN PVOID Buffer, IN size_t BufferSize )
    {
        PBYTE CurrentPosition;
        Assert(m_pbStart != NULL);
        CurrentPosition = m_pbCurrent;
        BufferSize = ROUND_UP_COUNT(BufferSize,SCRATCH_MEMORY_ALIGNMENT);
        m_pbCurrent += BufferSize;
        TraceSz3(ScratchMemoryAlloc, "ReAlloc %d, now used %d out of %d", BufferSize,
                m_pbCurrent - m_pbStart,
                m_pbEnd - m_pbStart);
        AssertSz(m_pbCurrent <= m_pbEnd,"Out of Scratch Memory");
        if (m_pbCurrent > m_pbEnd)
        {
            m_pbCurrent = CurrentPosition;
            CurrentPosition = NULL;
        }
        else
        {
            RtlCopyMemory( CurrentPosition, Buffer, BufferSize );
        }
        #ifdef XNET_FEATURE_TRACE
        if (m_pbPeakUsage < m_pbCurrent)
        {
            m_pbPeakUsage = m_pbCurrent;
        }
        #endif    
        return CurrentPosition;
    }

    INLINE PVOID ImmediateReAlloc( IN PVOID Buffer, IN size_t OldBufferSize, IN size_t NewBufferSize )
    {
        Assert(m_pbStart != NULL);
        OldBufferSize = ROUND_UP_COUNT(OldBufferSize,SCRATCH_MEMORY_ALIGNMENT);
        if ( m_pbCurrent == (PBYTE)Buffer + OldBufferSize )
        {
            //
            // Nothing else was allocated in between, we can do things better.
            //
            PBYTE CurrentPosition;
            CurrentPosition = m_pbCurrent;
            NewBufferSize = ROUND_UP_COUNT(NewBufferSize,SCRATCH_MEMORY_ALIGNMENT);
            m_pbCurrent += (NewBufferSize - OldBufferSize);
            TraceSz3(ScratchMemoryAlloc, "ImmediateReAlloc %d, now used %d out of %d", NewBufferSize,
                    m_pbCurrent - m_pbStart,
                    m_pbEnd - m_pbStart);
            AssertSz(m_pbCurrent <= m_pbEnd,"Out of Scratch Memory");
            if (m_pbCurrent > m_pbEnd)
            {
                m_pbCurrent = CurrentPosition;
                return NULL;
            }
            else
            {
                #ifdef XNET_FEATURE_TRACE
                if (m_pbPeakUsage < m_pbCurrent)
                {
                    m_pbPeakUsage = m_pbCurrent;
                }
                #endif    
                return Buffer;
            }
        }
        else
        {
            return ReAlloc( Buffer, NewBufferSize );
        }
    }

    INLINE VOID Free( IN PVOID Buffer )
    {
        Assert(m_pbStart != NULL);
    }

    INLINE VOID Push()
    {
        Assert(m_pbStart != NULL);
        AssertSz(m_dwStackPointer < SCRATCH_MEMORY_STACK_SIZE,"Scratch Memory Stack Overflow");
        m_Stack[m_dwStackPointer++] = m_pbCurrent;
    }

    INLINE VOID Pop()
    {
        PVOID pTemp;
        Assert(m_pbStart != NULL);
        AssertSz(m_dwStackPointer != 0,"Scratch Memory Stack Underflow");
        pTemp = m_pbCurrent;
        m_pbCurrent = m_Stack[--m_dwStackPointer];
        Assert( m_pbCurrent <= pTemp);
        RtlZeroMemory( m_pbCurrent, (PBYTE)pTemp - m_pbCurrent );
    }
};

class CReleaseAllScratchMemoryUponDestruction
{
public:

    INLINE CReleaseAllScratchMemoryUponDestruction( CScratchMemoryAllocator* pScratchMemoryAllocator )
    {
        m_pScratchMemoryAllocator = pScratchMemoryAllocator;
        m_pbPreservedMemory = NULL;
        //
        // Anything allocated after the constructed will be released later
        //
        m_pScratchMemoryAllocator->Push();
    }

    INLINE CScratchMemoryAllocator* ScratchMemoryAllocator()
    {
        return m_pScratchMemoryAllocator;
    }
        
    //
    // Need to use #define or _alloca scope will be incorrect
    //
    #define PreserveThisMemory( pObject, ppMemoryPointer, dwPreservedMemoryLength ) \
        (pObject)->PreserveThisMemoryHelper( (void**)ppMemoryPointer, (pObject)->ScratchMemoryAllocator()->TempBufferSize() >= dwPreservedMemoryLength ? NULL : _alloca( dwPreservedMemoryLength ), dwPreservedMemoryLength )
    
    INLINE PVOID PreserveThisMemoryHelper( void** ppMemoryPointer, void* pbAllocatedMemory, DWORD dwPreservedMemoryLength )
    {
        Assert( dwPreservedMemoryLength != 0 );
        Assert( ppMemoryPointer != NULL );
        Assert( *ppMemoryPointer != NULL );
        if (pbAllocatedMemory == NULL && m_pScratchMemoryAllocator->TempBufferSize() >= dwPreservedMemoryLength)
        {
            pbAllocatedMemory = m_pScratchMemoryAllocator->TempBuffer();
        }
        else
        {
            AssertSz(m_pScratchMemoryAllocator->TempBuffer() == NULL,"Had Temp Buffer, but not big enough");
        }
        if (pbAllocatedMemory != NULL)
        {
            RtlCopyMemory(pbAllocatedMemory, *ppMemoryPointer, dwPreservedMemoryLength);
            m_ppMemoryPointer = ppMemoryPointer;
            m_dwPreservedMemoryLength = dwPreservedMemoryLength;
            m_pbPreservedMemory = pbAllocatedMemory;
        }
        return pbAllocatedMemory;
    }

    INLINE PVOID PreserveThisMemoryToTempBuffer( PBYTE* ppMemoryPointer, DWORD dwPreservedMemoryLength )
    {
        PVOID pbDestinationMemory = NULL;
        
        Assert( dwPreservedMemoryLength != 0 );
        Assert( ppMemoryPointer != NULL );
        Assert( *ppMemoryPointer != NULL );
        if (m_pScratchMemoryAllocator->TempBuffer() != NULL &&
            m_pScratchMemoryAllocator->TempBufferSize() >= dwPreservedMemoryLength )
        {
            pbDestinationMemory = m_pScratchMemoryAllocator->TempBuffer();
            RtlCopyMemory(pbDestinationMemory, *ppMemoryPointer, dwPreservedMemoryLength);
            *ppMemoryPointer = (PBYTE)pbDestinationMemory;
        }
        else
        {
            AssertSz(FALSE, "Temp Buffer can't fit PreserveThisMemoryToTempBuffer");
        }
        return pbDestinationMemory;
    }

    INLINE ~CReleaseAllScratchMemoryUponDestruction()
    {
        m_pScratchMemoryAllocator->Pop();
        
        if (m_pbPreservedMemory != NULL)
        {
            Assert( m_dwPreservedMemoryLength != 0 );
            *m_ppMemoryPointer = m_pScratchMemoryAllocator->Alloc(m_dwPreservedMemoryLength);
            RtlCopyMemory(*m_ppMemoryPointer, m_pbPreservedMemory, m_dwPreservedMemoryLength);
        }
    }
    
private:

    CScratchMemoryAllocator* m_pScratchMemoryAllocator;
    PVOID m_pbPreservedMemory;
    PVOID* m_ppMemoryPointer;
    DWORD m_dwPreservedMemoryLength;
};

//
// From msr_md5.h
//

#define MD5Init msr_MD5Init
#define MD5Update msr_MD5Update
#define MD5Final msr_MD5Final
#define MD5_CTX msr_MD5_CTX

#define ECAPI // __stdcall

typedef int tBool;
typedef unsigned char tUint8;
typedef unsigned short tUint16;
typedef unsigned long tUint32;

//  -------------- MD5 message digest --------------------

/* Two names for number of bytes output by MD5 */
#define MD5DIGESTLEN 16
#define MD5_LEN MD5DIGESTLEN

typedef struct {
        tUint32 magic_md5;     // Magic value for MD5_CTX
        tUint32 awaiting_data[16];
                             // Data awaiting full 512-bit block.
                             // Length (nbit_total[0] % 512) bits.
                             // Unused part of buffer (at end) is zero.
        tUint32 partial_hash[4];
                             // Hash through last full block
        tUint32 nbit_total[2];       
                             // Total length of message so far
                             // (bits, mod 2^64)
        tUint8 digest[MD5DIGESTLEN];
                             // Actual digest after MD5Final completes
        tBool FinishFlag;
} msr_MD5_CTX;

typedef const msr_MD5_CTX msr_MD5_CTXc;

extern tBool ECAPI msr_MD5Init(msr_MD5_CTX*);
extern tBool ECAPI msr_MD5Update(msr_MD5_CTX*, const tUint8*, const tUint32);
extern tBool ECAPI msr_MD5Final(msr_MD5_CTX*);

// ====================================================================
// header for logon.cpp
// ====================================================================

#define XBOX_REALM      "xbox.com"
#define MACS_REALM      "macs.xbox.com"

typedef LARGE_INTEGER TimeStamp, *PTimeStamp;

#define MAX_KERB_RETRIES 4
#define MAX_TIME_ADJUSTMENTS MAX_KERB_RETRIES

extern DWORD g_dwNumKerbRetry;
extern DWORD g_dwNumMACSRetry;
extern DWORD g_dwKerbRetryDelayInMilliSeconds[MAX_KERB_RETRIES];
extern DWORD g_dwMACSRetryDelayInMilliSeconds[MAX_KERB_RETRIES];

//
// At most 2 service requests at the end of the array that is not linear
//
#define XONLINE_MAX_SERVICE_REQUEST 9
#define XONLINE_NUMBER_SEQUENTIAL_SERVICES 7

#pragma pack(push, 4)

typedef struct XONLINE_RECENT_LOGON_TIME {
    ULONGLONG qwUserID;
    FILETIME lastLogon;
} *PXONLINE_RECENT_LOGON_TIME;

typedef struct XKERB_TGT_CONTEXT
{
    // The following fields are used to index this entry in the cache
    ULONGLONG UserID[XONLINE_MAX_LOGON_USERS];
    TimeStamp StartTime;
    TimeStamp ExpirationTime;

    // The following fields are in memory only and not stored in the cache
    DWORD ctNumNonces;
    DWORD Nonce[MAX_KERB_RETRIES + MAX_TIME_ADJUSTMENTS];
    BYTE ClientKey[XONLINE_KEY_LENGTH];
    BYTE CompoundKey[XONLINE_KEY_LENGTH];
    OPTIONAL IN XKERB_TGT_CONTEXT* pInputTGTContext;
    OPTIONAL OUT PXKERB_PA_XBOX_ACCOUNT_CREATION pAccountCreationPreAuth;

    // The following fields are cached to disk
    CHAR ClientName[XONLINE_KERBEROS_PRINCIPLE_NAME_SIZE];
    CHAR ClientRealm[XONLINE_REALM_NAME_SIZE];
    CHAR TargetRealm[XONLINE_REALM_NAME_SIZE];
    BYTE SessionKey[XONLINE_KEY_LENGTH];
    DWORD dwTicketLength;
    BYTE Ticket[XONLINE_MAX_TICKET_LENGTH];
} *PXKERB_TGT_CONTEXT;

typedef struct XKERB_SERVICE_CONTEXT
{
    // The following fields are used to index this entry in the cache
    ULONGLONG UserID[XONLINE_MAX_LOGON_USERS];
    DWORD dwTitleID;
    DWORD dwNumServices;
    DWORD dwServiceID[XONLINE_MAX_NUMBER_SERVICE];
    TimeStamp StartTime;
    TimeStamp ExpirationTime;

    // The following fields are in memory only and not stored in the cache
    DWORD ctNumNonces;
    DWORD Nonce[MAX_KERB_RETRIES + MAX_TIME_ADJUSTMENTS];
    TimeStamp AuthenticatorTime[MAX_KERB_RETRIES + MAX_TIME_ADJUSTMENTS];
    HRESULT hr;
    XOKERBINFO xoKerbInfo;

    // The following fields are cached to disk
    IN_ADDR siteIPAddress;
    DWORD dwSiteID;
    HRESULT hrService[XONLINE_MAX_NUMBER_SERVICE];
    WORD wServicePort[XONLINE_MAX_NUMBER_SERVICE];
    CHAR ClientName[XONLINE_KERBEROS_PRINCIPLE_NAME_SIZE];
    CHAR ClientRealm[XONLINE_REALM_NAME_SIZE];
    CHAR ServiceRealm[XONLINE_REALM_NAME_SIZE];
    BYTE SessionKey[XONLINE_KEY_LENGTH];
    DWORD dwTicketLength;
    BYTE Ticket[XONLINE_MAX_TICKET_LENGTH];
} *PXKERB_SERVICE_CONTEXT;

typedef struct SERVICE_CONTEXT
{
    XONLINE_SERVICE_INFO serviceInfo;
    HRESULT hr;
    XKERB_SERVICE_CONTEXT* pXKerbServiceContext;
} *PSERVICE_CONTEXT;

#pragma pack(pop)

/* going away */
BOOL
KerbPasswordToKey(
    IN LPSTR pszPassword,
    OUT BYTE* Key
    );

typedef struct _KERB_MESSAGE_BUFFER {
    DWORD BufferSize;
    BYTE* Buffer;
} KERB_MESSAGE_BUFFER, *PKERB_MESSAGE_BUFFER;

// ====================================================================
// User signature related stuff
//

//
// @@@ TODO: This string needs to be reved every release
// until we feel the XC_ONLINE_USER_ACCOUNT_STRUCT is stable
//
#define ONLINE_USER_SIGNATURE_KEY "Mar/2002 SDK"

#if 0
#define XCHMAC_DIGEST_SIZE 20

void XcHMAC(
    IN PBYTE pbKeyMaterial,
    IN ULONG cbKeyMaterial,
    IN PBYTE pbData,
    IN ULONG cbData,
    IN PBYTE pbData2,
    IN ULONG cbData2,
    OUT PBYTE pbDigest
    );
#endif

//
// Some time on January/2000, The Xbox time cannot be adjusted to earlier than this
//
#define BASE_SIGNATURE_TIME ((ULONGLONG)0x01BF5C72FEFB6A60)

//
// Granularity of measurement (2 seconds)
//
#define SIGNATURE_TIME_INCREMENT ((ULONGLONG)20000000)

INLINE VOID TimeStampOnlineUserStruct( XC_ONLINE_USER_ACCOUNT_STRUCT* pOnlineUser )
{
    FILETIME CurrentTime;
    
    GetSystemTimeAsFileTime(&CurrentTime);
    pOnlineUser->dwSignatureTime = (DWORD)((*((ULONGLONG*)&CurrentTime) - BASE_SIGNATURE_TIME) / SIGNATURE_TIME_INCREMENT);
    Assert( *((ULONGLONG*)&CurrentTime) > BASE_SIGNATURE_TIME );
    Assert( ((*((ULONGLONG*)&CurrentTime) - BASE_SIGNATURE_TIME) / SIGNATURE_TIME_INCREMENT) <= ((ULONGLONG)0xFFFFFFFF) );
}

INLINE VOID SignOnlineUserStruct( XC_ONLINE_USER_ACCOUNT_STRUCT* pOnlineUser )
{
    BYTE digest[XC_SERVICE_DIGEST_SIZE];

    XcHMAC( (BYTE*)ONLINE_USER_SIGNATURE_KEY, sizeof(ONLINE_USER_SIGNATURE_KEY),
        (BYTE*)pOnlineUser, sizeof(XC_ONLINE_USER_ACCOUNT_STRUCT) - sizeof(pOnlineUser->signature), NULL, 0, digest );

    RtlCopyMemory( pOnlineUser->signature, digest, sizeof(pOnlineUser->signature) );
}

INLINE BOOL VerifyOnlineUserSignature( XC_ONLINE_USER_ACCOUNT_STRUCT* pOnlineUser )
{
    BYTE digest[XC_SERVICE_DIGEST_SIZE];

    XcHMAC( (BYTE*)ONLINE_USER_SIGNATURE_KEY, sizeof(ONLINE_USER_SIGNATURE_KEY),
        (BYTE*)pOnlineUser, sizeof(XC_ONLINE_USER_ACCOUNT_STRUCT) - sizeof(pOnlineUser->signature), NULL, 0, digest );

    return RtlEqualMemory( pOnlineUser->signature, digest, sizeof(pOnlineUser->signature) );
}

// ====================================================================
// XOnline Work Pump
//

typedef HRESULT (CXo::*PFNXONLINE_TASK_CONTINUE)(
    IN XONLINETASK_HANDLE hTask
    );

typedef XBOXAPI void (CXo::*PFNXONLINE_TASK_CLOSE)(
    IN XONLINETASK_HANDLE hTask
    );

typedef struct {
#if DBG
    DWORD                   dwSignature;        // DEBUG ONLY: Signature
    DWORD                   dwThreadId;         // DEBUG_ONLY: ThreadId of creator thread
#endif  
    PFNXONLINE_TASK_CONTINUE pfnContinue;
    PFNXONLINE_TASK_CLOSE   pfnClose;
    HANDLE                  hEventWorkAvailable;
} XONLINETASK_CONTEXT, *PXONLINETASK_CONTEXT;

// ---------------------------------------------------------------------------------------
// Definitions
// ---------------------------------------------------------------------------------------

#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif

#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif

// BASEIO --------------------------------------------------------------------------------

//
// =============================================================
// Basic async file/socket I/O primitives
//
// These versions of the primitives allocate and return a task
// handle to the caller. Title developers may use these primitives
// to perform basic async file and socket I/O
//

//
// Define context structure shared by file I/O primitives
//
typedef struct
{
    XONLINETASK_CONTEXT       xontask;    // Task context

    HRESULT                   hr;            // Status code
    LPBYTE                    pbBuffer;    // R/W buffer
    DWORD                     cbBuffer;    // Buffer size
    DWORD                     cbDone;        // Bytes completed 
    HANDLE                    hFile;        // File handle
    OVERLAPPED                overlapped;    // OVERLAPPED struct

} XONLINETASK_FILEIO, *PXONLINETASK_FILEIO;

//
// Define context structure shared by socket I/O primitives
//
typedef struct
{
    XONLINETASK_CONTEXT      xontask;    // Task context
    
    HRESULT                  hr;            // Status code
    SOCKET                   socket;        // socket
    LPWSABUF                 pBuffers;    // WSA buffers
    DWORD                    dwBuffers;    // Number of buffers
    DWORD                    cbDone;        // Bytes completed
    DWORD                    dwFlags;    // Flags
    WSAOVERLAPPED            wsaoverlapped;    // OVERLAPPED struct

} XONLINETASK_SOCKIO, *PXONLINETASK_SOCKIO;

//
// =============================================================
// Basic async file/socket I/O primitives
//
// These versions of the primitives take in a context object that
// is assumed to be initialized. These versions of the primitives
// are for task implementors, and are not generally available to
// title developers.
//

// ---------------------------------------------------------------------------------------

//
// Define macros to round up and down for sector alignment
//
#define SECTOR_ALIGNMENT_ROUND_UP(x)    \
        (((x) + (XBOX_HD_SECTOR_SIZE - 1)) & (~(XBOX_HD_SECTOR_SIZE - 1)))

#define SECTOR_ALIGNMENT_ROUND_DOWN(x)    \
        ((x) & (~(XBOX_HD_SECTOR_SIZE - 1)))

#define IS_HD_SECTOR_ALIGNED(x)            \
        ((((x) & (XBOX_HD_SECTOR_SIZE - 1)) == 0)?TRUE:FALSE)

// ===========================================================
// Download and upload extensions
//
// These extensions are specifically designed to maximize
// code sharing and to aviod redundancy as much as possible.
// The basic idea is that we only need one instance of the code
// that downloads and uploads data. 
//
// By decoupling the code that strictly talks to the server and
// the code that processes the actual data, we create an extensible
// framework that allows arbitrary implementations on top of the
// download and uplaod framework. 
//
// The main challenge here is that these extensions themselves must
// also be asynchronous tasks that use XOnlineTaskContinue to make
// progress. This allows the underlying implementation to be 
// completely oblivious to what the subtasks do - all it needs to
// do is to keep calling XOnlineTaskContinue on the subtask until
// the subtask is done, and then it moves on with its own next
// state of processing. The subtask may also contain other smaller
// subtasks, creating the possibility of dependent cascading tasks, 
// each waiting for its child to complete before moving on, and
// all work is achieved through a unified work API -
// XOnlineTaskContinue, which also supports timing control through
// the use of dwMaxExecutionTimeSlice.
//
// The implementation of XOnlineDownloadFile, XOnlineDownloadToMemory,
// XOnlineUploadFile and XOnlineUploadFromMemory are all implemented
// as extensions to illustrate how this is done.
//
// New extensions can be built by wrapping similar funcitonality 
// around the core XOnlineDownload and XOnlineUpload APIs.
//

//
// Define the set of download extension types
//
typedef enum
{
    xrldlextPreConnect = 0,
    xrldlextProcessData,
    xrldlextPostDownload

} XRLDOWNLOAD_EXTTYPE;

//
// Function prototypes for the donwload extension callbacks
//
// Note: the PVOIDs are actually PXRL_ASYNC pointers,
// but I couldn't get the circular reference
// to compile properly in C.
//
typedef HRESULT (CXo::*PFNXRLDOWNLOAD_DONEHEADERS)(
            PVOID                pvxrlasync
            );

typedef BOOL (CXo::*PFNXRLDOWNLOAD_PROCESSDATA)(
            PVOID                pvxrlasync
            );

typedef HRESULT (CXo::*PFNXRLDOWNLOAD_COMPLETED)(
            PVOID                pvxrlasync
            );

typedef VOID (CXo::*PFNXRLDOWNLOAD_CLEANUP)(
            PVOID                pvxrlasync
            );

typedef HRESULT (CXo::*PFNXRLDOWNLOAD_INITTASK)(
            XRLDOWNLOAD_EXTTYPE    xrldlext,
            PVOID                pvxrlasync,
            XONLINETASK_HANDLE    hTask
            );

//
// Structure representing extensions to the bare-bones download
// framework. Both XOnlineDownloadToMemory and XOnlineDownloadFile
// are implemented as extensions. This maximizes code sharing and
// creates a lot of flexibility
//
typedef struct
{
    PFNXRLDOWNLOAD_DONEHEADERS    pfnDoneHeaders;
    PFNXRLDOWNLOAD_PROCESSDATA    pfnProcessData;
    PFNXRLDOWNLOAD_COMPLETED    pfnCompleted;
    PFNXRLDOWNLOAD_INITTASK        pfnInitializeTask;
    PFNXRLDOWNLOAD_CLEANUP        pfnCleanup;

    XONLINETASK_HANDLE            hTaskPreConnect;
    XONLINETASK_HANDLE            hTaskProcessData;
    XONLINETASK_HANDLE            hTaskPostDownload;

} XRL_DOWNLOAD_EXTENSION, *PXRL_DOWNLOAD_EXTENSION;

//
// Define the set of upload extension types
//
typedef enum
{
    xrlulextPreConnect = 0,
    xrlulextReadData,
    xrlulextPostUpload

} XRLUPLOAD_EXTTYPE;

//
// Function prototypes for the upload extension callbacks
//
// Note: the PVOIDs are actually PXRL_ASYNC pointers,
// but I couldn't get the circular reference
// to compile properly in C.
//
typedef HRESULT (CXo::*PFNXRLUPLOAD_COMPLETED)(
            PVOID                pvxrlasync
            );

typedef HRESULT (CXo::*PFNXRLUPLOAD_RESPONSEHEADERS)(
            PVOID                pvxrlasync
            );

typedef VOID (CXo::*PFNXRLUPLOAD_CLEANUP)(
            PVOID                pvxrlasync
            );
            
typedef HRESULT (CXo::*PFNXRLUPLOAD_INITTASK)(
            XRLUPLOAD_EXTTYPE    xrlulext,
            PVOID                pvxrlasync,
            XONLINETASK_HANDLE    hTask
            );

//
// Structure representing extensions to the bare-bones upload
// framework. Both XOnlineUploadToMemory and XOnlineUploadFile
// are implemented as extensions. This maximizes code sharing and
// creates a lot of flexibility
//
typedef struct
{
    PFNXRLUPLOAD_COMPLETED            pfnCompleted;
    PFNXRLUPLOAD_RESPONSEHEADERS    pfnResponseHeaders;
    PFNXRLUPLOAD_INITTASK            pfnInitializeTask;
    PFNXRLUPLOAD_CLEANUP            pfnCleanup;

    XONLINETASK_HANDLE                hTaskPreConnect;
    XONLINETASK_HANDLE                hTaskReadData;
    XONLINETASK_HANDLE                hTaskPostUpload;

} XRL_UPLOAD_EXTENSION, *PXRL_UPLOAD_EXTENSION;

//
// Define a union between the download and upload extensions
// and call it a generice XRL_EXTENSION
//
typedef union
{
    XRL_DOWNLOAD_EXTENSION    dl;
    XRL_UPLOAD_EXTENSION    ul;

} XRL_EXTENSION, *PXRL_EXTENSION;

//
// The following success code is used when a pre-up/download extension
// wants to skip the actual up/download and jump right to the 
// post-up/download phase. This is typically used when the pre-task
// determines that the desired data is already there and there is no need
// to actually send/get it over the wire.
//
#define XONLINE_S_XRL_EXTENSION_SKIP_TO_POST	(MAKE_HRESULT(0, FACILITY_XONLINE, 0xffff))

//
// Context structure for resource access operations. This is allocated by 
// a call to download/upload a resource (either into memory or to a file).
// This is returned to the caller as an opaque handle. 
//
typedef struct
{
    // "Inherit from" the main context.
    XONLINETASK_CONTEXT    xontask;            // XON task context

    // Context information specific to download operations
    HRESULT                hrFinal;            // Final HRESULT
    HRESULT                hrXErr;                // Optional X-Err code
    DWORD                dwCurrentState;        // Current state of execution
    DWORD                dwFlags;            // Any special flags
    DWORD                dwTimeoutMs;        // Timeout value in milliseconds
    DWORD                dwLastStateChange;    // Tick on last state change
    XONLINE_SERVICE_INFO serviceInfo;            // Pointer to service information

    XONLINETASK_FILEIO    fileio;                // Async File I/O context
    XONLINETASK_SOCKIO    sockio;                // Async Socket I/O context
    WSABUF                wsabuf;                // WSA buffer structure

    PBYTE                pBuffer;            // Beginning of buffer
    DWORD                cbBuffer;            // Size of buffer specified
    DWORD                dwExtendedStatus;    // Extended status code
    FILETIME            ftLastModified;        // Last modified time
    FILETIME            ftResponse;            // Server response timestamp
    ULARGE_INTEGER        uliContentLength;    // Content length
    ULARGE_INTEGER        uliTotalReceived;    // Total received
    ULARGE_INTEGER        uliTotalWritten;    // Total written
    ULARGE_INTEGER        uliFileSize;        // Current file size
    DWORD                dwCurrent;            // Currency marker
    DWORD                dwTemp;                // Generic storage

    XRL_EXTENSION        xrlext;                // Extension descriptor
    BOOL                fDownload;            // Whether this is a download

} XRL_ASYNC, *PXRL_ASYNC;

//
// Special flag to indicate that the hEventWorkAvailable is created
// by the call to XOnlineDownload or XOnlineUpload
//
#define XRL_HEVENT_CREATED_BY_API            ((DWORD)0x00000001)
#define XRL_SEND_DATA_CONTAINS_HEADERS        ((DWORD)0x00000002)
#define XRL_CONNECTION_INSECURE               ((DWORD)0x40000000)
#define XRL_OP_IS_DOWNLOAD                    ((DWORD)0x80000000)

//
// Define a context structure for extensions, which 
// contains an XRL_ASYNC structure, and an extra task
// context for the 'subtask'. This is specific to the 
// XRL upload and download extension implementations. 
// Extension writers should define their own context.
//
// The general idea is that &xontask is actually a valid
// task handle and can be used with XOnlineTaskContinue,
// provided that the task context is filled in properly.
//
// The subtask gains access to the outside xrlasync struct
// by using the CONTAINING_RECORD(p, XRL_ASYNC_EXTENDED, xontask)
// macro, which returns a pointer to PXRL_ASYNC_EXTENDED.
//
typedef struct
{
    XRL_ASYNC                xrlasync;        // Main context

    XONLINETASK_CONTEXT        xontask;        // subtask handle
    DWORD                    dwCurrentState;    // State variable
    
} XRL_ASYNC_EXTENDED, *PXRL_ASYNC_EXTENDED;

//
// A particular characteristic of Xbox asynchronous WriteFile calls is
// that the call is asynchronous so long as the file size is not exceeded.
// To keep the writes asynchronous, SetEndOfFile is used to grow the file
// in chunks. The following is the increment size used to grow files.
//
// BUGBUG: Need to find an optimal value
//
#define XRL_INCREMENTAL_GROW_FILE_SIZE        ((XBOX_HD_SECTOR_SIZE) << 12)    // 2MBytes

//
// Define an upper bound for the size of any set of extra headers passed
// into any of the up/download functions.
//
// The value is limited to 128k bytes, which is consistent with the maximum
// size of all headers allowed in IIS.
//
#define XRL_MAX_EXTRA_HEADER_SIZE            ((DWORD)(1 << 17))    // 128KBytes   


//
// This provides the ability to specify an alternate IP address for 
// a given service, and to talk to that service via an insecure channel.
//
// To use, compile with the following contants defined:
//      XRL_SERVICE_OVERRIDE_ID=<service id you wish to override>
//      XRL_SERVICE_OVERRIDE_IP=binary form of ip address (i.e. inet_addr("a.b.c.d"))
//
// currently this only affects UploadFromMemoryInternal(), but is easily added
// to any of the other xrl apis. 
//

#if defined(XONLINE_FEATURE_INSECURE) && \
    defined(XRL_SERVICE_OVERRIDE_ID) && \
    defined(XRL_SERVICE_OVERRIDE_IP)
    INLINE VOID XoOverrideServiceIP_(PXRL_ASYNC pXrlAsync) { \
        if (pXrlAsync->serviceInfo.dwServiceID == XRL_SERVICE_OVERRIDE_ID) { \
            TraceSz6(Warning, "Overriding Service ID %d: Using IP address %d.%d.%d.%d:%d", \
                     XRL_SERVICE_OVERRIDE_ID,\
                     XRL_SERVICE_OVERRIDE_IP >> 24, \
                     (XRL_SERVICE_OVERRIDE_IP & 0xff0000) >> 16, \
                     (XRL_SERVICE_OVERRIDE_IP & 0x00ff00) >> 8, \
                     (XRL_SERVICE_OVERRIDE_IP & 0x0000ff), \
                     80); \
            pXrlAsync->dwFlags |= XRL_CONNECTION_INSECURE; \
            pXrlAsync->serviceInfo.serviceIP.S_un.S_addr = XRL_SERVICE_OVERRIDE_IP; \
            pXrlAsync->serviceInfo.wServicePort = 80; \
        } \
     } 
    #define XoOverrideServiceIP(_pxrl) XoOverrideServiceIP_(_pxrl)
#else
    #define XoOverrideServiceIP(_pxrl) 
#endif




// SYMMDEC.H -----------------------------------------------------------------------------

//
// Define a context that allows piecemeal decryption and
// SHA1-Hmac calculation
//
typedef struct
{
    DWORD        cbLength;        // Total length of encrypted block
                                    // This includes the confounder (CF)
    DWORD        dwCurrent;        // Bytes decrypted, incl. CF
    
    PBYTE        pbKey;            // Symmetric key
    DWORD        cbKey;            // Key length
    BYTE         rgbChecksum[XC_DIGEST_LEN];
                                // Original checksum
    BYTE        shactx[XC_SERVICE_SHA_CONTEXT_SIZE];
                                // SHA1 context for Hmac
    BYTE        rc4ctx[XC_SERVICE_RC4_KEYSTRUCT_SIZE];
                                // RC4 decryption context
} XONLINESYMMDEC_CONTEXT, *PXONLINESYMMDEC_CONTEXT;

//
// If the length of the data is unknown to begin with, specify
// this length to skip the length check during SymmdecVerify
//
#define XONLINESYMMDEC_UNKNOWN_LENGTH    ((DWORD)0xffffffff)

// XRLUTIL.H -----------------------------------------------------------------------------

//
// Define the valid values for dwFlags in XRL_ASYNC
//
#define XRL_FLAG_HEADER_MODE            ((DWORD)0x00000001)

#define IS_HEADER_MODE(pxrlasync)        \
        (((pxrlasync)->dwTemp & XRL_FLAG_HEADER_MODE) != 0)

//
// Define a type for our own work handlers
//
typedef HRESULT (CXo::*PFNXRL_HANDLER)(PXRL_ASYNC);

// LZX -----------------------------------------------------------------------------------
//
// IMPORTANT PLEASE READ:
//
// This is NOT the stock LZX decompressor code that is used in the ROM! This is a special
// version designed for the Online team. This code has been stripped down and the
// underlying data structure has been changed. Please do not use this code if you intend
// to use LDI. Instead, please refer to \private\lzx for the stock LZX/LDI sources.
//
// If you decide to use this code instead, please take the time to read and understand
// the code. That is, use at your own risk.
// ---------------------------------------------------------------------------------------

/*
 * Definitions for LZX
 */
typedef unsigned char    byte;
typedef unsigned short    ushort;
typedef unsigned long    ulong;
typedef unsigned int    uint;

#ifndef __cplusplus
typedef enum
{
    false = 0,
    true = 1
} bool;
#endif

#ifndef HUGE
#    define HUGE
#endif

#ifndef FAR
#    define FAR
#endif

#ifndef NEAR
#   define NEAR
#endif

/*
 * Smallest allowable match length 
 */
#define MIN_MATCH 2

/* 
 * Maximum match length 
 */
#define MAX_MATCH (MIN_MATCH+255)

/*
 * Number of uncompressed symbols 
 */
#define NUM_CHARS 256

/*
 * Number of match lengths which are correlated with match positions 
 */
#define NUM_PRIMARY_LENGTHS     7

/*
 * Primary lengths plus the extension code
 */
#define NUM_LENGTHS             (NUM_PRIMARY_LENGTHS+1)

/*
 * Equals number of different possible match lengths minus primary lengths 
 */
#define NUM_SECONDARY_LENGTHS   ((MAX_MATCH-MIN_MATCH+1)-NUM_PRIMARY_LENGTHS)

/* NL_SHIFT = log2(NUM_LENGTHS) */
#define NL_SHIFT                3

/*
 * Number of repeated offsets 
 */
#define NUM_REPEATED_OFFSETS    3

/*
 * Number of elements in the aligned offset tree
 */
#define ALIGNED_NUM_ELEMENTS 8


/*
 * Repeat codes for outputting trees
 */

/* Minimum number of repetitions of anything we're interested in */
#define TREE_ENC_REP_MIN                4

/* Maximum repetitions for "type A" repetition of zeroes */
/* (min...min+REP_ZERO_FIRST) */
#define TREE_ENC_REP_ZERO_FIRST        16

/* Maximum repetitions for "type B" repetition of zeroes */
/* (min+REP_ZERO_FIRST...min+REP_ZERO_FIRST+REP_ZERO_SECOND) */
#define TREE_ENC_REP_ZERO_SECOND       32

/* Maximum repetitions for "type C" repetition of anything */
/* (min...min_REP_SAME_FIRST) */
#define TREE_ENC_REP_SAME_FIRST         2

/* Bits required to output the above numbers */
#define TREE_ENC_REPZ_FIRST_EXTRA_BITS  4
#define TREE_ENC_REPZ_SECOND_EXTRA_BITS 5
#define TREE_ENC_REP_SAME_EXTRA_BITS    1

/* Number of cfdata frames before E8's are turned off automatically */
#define E8_CFDATA_FRAME_THRESHOLD       32768


/*
 * Block types 
 */
typedef enum
{
        BLOCKTYPE_INVALID       = 0,
        BLOCKTYPE_VERBATIM      = 1, /* normal block */
        BLOCKTYPE_ALIGNED       = 2, /* aligned offset block */
        BLOCKTYPE_UNCOMPRESSED  = 3  /* uncompressed block */
} lzx_block_type;

typedef enum
{
    DEC_STATE_UNKNOWN,
    DEC_STATE_START_NEW_BLOCK,
    DEC_STATE_DECODING_DATA
} decoder_state;

/*
 * Size of uncompressed data chunks
 */
#define CHUNK_SIZE  32768

/*
 * Main tree decoding table parameters 
 */

/* # elements in main tree */
#define MAIN_TREE_ELEMENTS            (NUM_CHARS+(context->dec_num_position_slots<<NL_SHIFT))

/*
 * Decoding table size allows a direct lookup on the first 
 * MAIN_TREE_TABLE_BITS bits of the code (max len 16).
 * Any potential remaining bits are decoded using left/right.
 */
#define MAIN_TREE_TABLE_BITS        10 

/*
 * Secondary length tree decoding table parameters
 * Decoding table size allows a direct lookup on the first
 * SECONDARY_LEN_TREE_TABLE_BITS of the code (max len 16).
 * Any potential remaining bits are decoded using left/right.
 */
#define SECONDARY_LEN_TREE_TABLE_BITS    8 

/* 
 * Aligned offset tree decoding table parameters 
 */
#define ALIGNED_NUM_ELEMENTS    8

/*
 * Must be 7, since we do not use left/right for this tree;
 * everything is decoded in one lookup.
 */
#define ALIGNED_TABLE_BITS        7

/* Declare some external references */
extern const byte dec_extra_bits[];
extern const long MP_POS_minus2[];

/*
 * MAX_MAIN_TREE_ELEMENTS should be >= 256 + 8*num_position_slots
 * (that comes out to 256 + 8*51 right now, for a 2 MB window).
 *
 * Make divisible by 4 so things are longword aligned.
 */
#define MAX_MAIN_TREE_ELEMENTS (256 + (8 * 291))   // 32MB
//#define MAX_MAIN_TREE_ELEMENTS 672

typedef struct
{
    /* pointer to beginning of window buffer */
    byte                *dec_mem_window;

    /* window/decoding buffer parameters */
    ulong               dec_window_size;
    ulong                dec_window_mask;

    /* previous match offsets */
    ulong               dec_last_matchpos_offset[NUM_REPEATED_OFFSETS];

    /* main tree table */
    short                dec_main_tree_table[1 << MAIN_TREE_TABLE_BITS];

    /* secondary length tree table */
    short               dec_secondary_length_tree_table[1 << SECONDARY_LEN_TREE_TABLE_BITS];

    /* main tree bit lengths */
    byte                dec_main_tree_len[MAX_MAIN_TREE_ELEMENTS];

    /* secondary tree bit lengths */
    byte                dec_secondary_length_tree_len[NUM_SECONDARY_LENGTHS];
    byte                pad1[3]; /* NUM_SECONDARY_LENGTHS == 249 */

    /* aligned offset table */
    char                dec_aligned_table[1 << ALIGNED_TABLE_BITS];
    byte                dec_aligned_len[ALIGNED_NUM_ELEMENTS];

    /* left/right pointers for main tree (2*n shorts left, 2*n shorts for right) */
    short               dec_main_tree_left_right[MAX_MAIN_TREE_ELEMENTS*4];

    /* left/right pointers for secondary length tree */
    short               dec_secondary_length_tree_left_right[NUM_SECONDARY_LENGTHS*4];

    /* input (compressed) data pointers */
    byte *              dec_input_curpos;
    byte *              dec_end_input_pos;

    /* output (uncompressed) data pointer */
    byte *              dec_output_buffer;

    /* position in data stream at start of this decode call */
    long                dec_position_at_start;

    /* previous lengths */
    byte                dec_main_tree_prev_len[MAX_MAIN_TREE_ELEMENTS];
    byte                dec_secondary_length_tree_prev_len[NUM_SECONDARY_LENGTHS];

    /* bitwise i/o */
    ulong               dec_bitbuf;
    signed char         dec_bitcount;

    /* number of distinct position (displacement) slots */
    byte                dec_num_position_slots;

    bool                dec_first_time_this_group;
    bool                dec_error_condition;

    /* misc */
    long                  dec_bufpos;
    ulong                dec_current_file_size;
    ulong                dec_instr_pos;
    ulong               dec_num_cfdata_frames;

    /* original size of current block being decoded (in uncompressed bytes) */
    long                dec_original_block_size;

    /* remaining size of current block being decoded (in uncompressed bytes) */
    long                dec_block_size;

    /* type of current block being decoded */
    lzx_block_type        dec_block_type;

    /* current state of decoder */
    decoder_state        dec_decoder_state;

    /* Indicates whether extra long matches are supported */
    bool            dec_extra_long_matches;

} t_decoder_context;

/* Define some XOnline-friendly types */
typedef t_decoder_context    XONLINE_LZXDECODER_CONTEXT;
typedef t_decoder_context    *PXONLINE_LZXDECODER_CONTEXT;

/*
 * decode an element from the aligned offset tree, without checking 
 * for the end of the input data
 */
#define DECODE_ALIGNED_NOEOFCHECK(j) \
    (j) = context->dec_aligned_table[dec_bitbuf >> (32-ALIGNED_TABLE_BITS)]; \
    FILL_BUF_NOEOFCHECK(context->dec_aligned_len[(j)]);


/*
 * Decode an element from the main tree
 * Check for EOF
 */
#define DECODE_MAIN_TREE(j) \
    j = context->dec_main_tree_table[dec_bitbuf >> (32-MAIN_TREE_TABLE_BITS)];    \
    if (j < 0)                                                            \
    {                                                                    \
        ulong mask = (1L << (32-1-MAIN_TREE_TABLE_BITS));               \
        do                                                                \
        {                                                                \
             j = -j;                                                        \
             if (dec_bitbuf & mask)                                        \
                j = context->dec_main_tree_left_right[j*2+1];                   \
            else                                                        \
                j = context->dec_main_tree_left_right[j*2];                     \
            mask >>= 1;                                                    \
        } while (j < 0);                                                \
    }                                                                    \
    FILL_BUF_FULLCHECK(context->dec_main_tree_len[j]);


/*
 * Decode an element from the secondary length tree
 * No checking for EOF
 */
#define DECODE_LEN_TREE_NOEOFCHECK(matchlen) \
    matchlen = context->dec_secondary_length_tree_table[dec_bitbuf >> (32-SECONDARY_LEN_TREE_TABLE_BITS)]; \
    if (matchlen < 0)                                                    \
    {                                                                    \
        ulong mask = (1L << (32-1-SECONDARY_LEN_TREE_TABLE_BITS));      \
        do                                                              \
        {                                                                \
             matchlen = -matchlen;                                          \
             if (dec_bitbuf & mask)                                      \
                matchlen = context->dec_secondary_length_tree_left_right[matchlen*2+1];\
            else                                                        \
                matchlen = context->dec_secondary_length_tree_left_right[matchlen*2];  \
            mask >>= 1;                                                 \
        } while (matchlen < 0);                                            \
    }                                                                    \
    FILL_BUF_NOEOFCHECK(context->dec_secondary_length_tree_len[matchlen]);      \
    matchlen += NUM_PRIMARY_LENGTHS;


/*
 * read n bits from input stream into dest_var, but don't
 * check for EOF
 */
#define GET_BITS_NOEOFCHECK(N,DEST_VAR) \
{                                               \
   DEST_VAR = dec_bitbuf >> (32-(N));            \
   FILL_BUF_NOEOFCHECK((N));                    \
}


/* same as above, but don't check for EOF */
#define GET_BITS17_NOEOFCHECK(N,DEST_VAR) \
{                                               \
   DEST_VAR = dec_bitbuf >> (32-(N));            \
   FILL_BUF17_NOEOFCHECK((N));                    \
}


/*
 * Remove n bits from the input stream
 * handles 1 <= n <= 17
 *
 * FORCE an EOF check ALWAYS, whether or not we read in more
 * bytes from memory.
 *
 * This is used to ensure that we always get an EOF check often enough
 * to not overrun the extra bytes in the buffer.
 *
 * This routine is used ONLY when decoding the main tree element,
 * where we know that the code we read in will be 16 bits or less
 * in length.  Therefore we don't have to check for bitcount going
 * less than zero, twice.
 */
#define FILL_BUF_FULLCHECK(N) \
{                                            \
    if (dec_input_curpos >= dec_end_input_pos)    \
        return -1; \
    dec_bitbuf <<= (N);                        \
    dec_bitcount -= (N);                    \
    if (dec_bitcount <= 0)                  \
    {                                         \
        dec_bitbuf |= ((((ulong) *dec_input_curpos | (((ulong) *(dec_input_curpos+1)) << 8))) << (-dec_bitcount)); \
        dec_input_curpos += 2;              \
        dec_bitcount += 16;                   \
    }                                       \
}

/*
 * Same as above, but no EOF check 
 *
 * This is used when we know we will not run out of input
 */
#define FILL_BUF_NOEOFCHECK(N)             \
{                                        \
    dec_bitbuf <<= (N);                    \
    dec_bitcount -= (N);                \
    if (dec_bitcount <= 0)              \
    {                                     \
        dec_bitbuf |= ((((ulong) *dec_input_curpos | (((ulong) *(dec_input_curpos+1)) << 8))) << (-dec_bitcount)); \
        dec_input_curpos += 2; \
        dec_bitcount += 16;                \
    }                                   \
}

/*
 * Same as above, but handles n=17 bits
 */
#define FILL_BUF17_NOEOFCHECK(N)        \
{                                        \
    dec_bitbuf <<= (N);                    \
    dec_bitcount -= (N);                \
    if (dec_bitcount <= 0)              \
    {                                     \
        dec_bitbuf |= ((((ulong) *dec_input_curpos | (((ulong) *(dec_input_curpos+1)) << 8))) << (-dec_bitcount)); \
        dec_input_curpos += 2; \
        dec_bitcount += 16;                \
        if (dec_bitcount <= 0) \
        { \
            dec_bitbuf |= ((((ulong) *dec_input_curpos | (((ulong) *(dec_input_curpos+1)) << 8))) << (-dec_bitcount)); \
            dec_input_curpos += 2; \
            dec_bitcount += 16;         \
        } \
    }                                   \
}

/* decblk.c */
long NEAR decode_data(t_decoder_context *context, long bytes_to_decode);

/* decin.c */
void NEAR initialise_decoder_bitbuf(t_decoder_context *context);
void NEAR init_decoder_input(t_decoder_context *context);
void NEAR fillbuf(t_decoder_context *context, int n);
ulong NEAR getbits(t_decoder_context *context, int n);

/* decout.c */
void NEAR copy_data_to_output(t_decoder_context *context, long amount, const byte *data);

/* dectree.c */
bool NEAR read_main_and_secondary_trees(t_decoder_context *context);
bool NEAR read_aligned_offset_tree(t_decoder_context *context);

/* maketbl.c */
bool NEAR make_table(
    t_decoder_context *context, 
    int            nchar,
    const byte    *bitlen,
    byte        tablebits,
    short        *table,
    short        *leftright
);

bool NEAR make_table_8bit(t_decoder_context *context, byte *bitlen, byte *table);
    
/* decxlat.c */
void NEAR init_decoder_translation(t_decoder_context *context);
void NEAR decoder_translate_e8(t_decoder_context *context, byte *mem, long bytes);

/* decalign.c */
int NEAR decode_aligned_offset_block(t_decoder_context *context, long bufpos, int amount_to_decode);

/* decverb.c */
int NEAR decode_verbatim_block(t_decoder_context *context, long bufpos, int amount_to_decode);

/* decuncmp.c */
int NEAR decode_uncompressed_block(t_decoder_context *context, long bufpos, int amount_to_decode);
bool NEAR handle_beginning_of_uncompressed_block(t_decoder_context *context);

// FDI -----------------------------------------------------------------------------------

#ifndef INCLUDED_TYPES_FCI_FDI
#define INCLUDED_TYPES_FCI_FDI 1

#ifndef HUGE
#define HUGE
#endif

#ifndef FAR
#define FAR
#endif

#ifndef DIAMONDAPI
#define DIAMONDAPI __cdecl
#endif


//** Specify structure packing explicitly for clients of FDI
#pragma pack(4)

//** Don't redefine types defined in Win16 WINDOWS.H (_INC_WINDOWS)
//   or Win32 WINDOWS.H (_WINDOWS_)
//
#if !defined(_INC_WINDOWS) && !defined(_WINDOWS_)
typedef int            BOOL;     /* f */
typedef unsigned char  BYTE;     /* b */
typedef unsigned int   UINT;     /* ui */
typedef unsigned short USHORT;   /* us */
typedef unsigned long  ULONG;    /* ul */
#endif   // _INC_WINDOWS

typedef unsigned long  CHECKSUM; /* csum */

typedef unsigned long  UOFF;     /* uoff - uncompressed offset */
typedef unsigned long  COFF;     /* coff - cabinet file offset */


#ifndef TRUE
#define TRUE    1
#endif

#ifndef FALSE
#define FALSE   0
#endif

#ifndef NULL
#define NULL    0
#endif


/***    ERF - Error structure
 *
 *  This structure returns error information from FCI/FDI.  The caller should
 *  not modify this structure.
 */
typedef struct {
    int     erfOper;            // FCI/FDI error code -- see FDIERROR_XXX
                                //  and FCIERR_XXX equates for details.

    int     erfType;            // Optional error value filled in by FCI/FDI.
                                // For FCI, this is usually the C run-time
                                // *errno* value.

    BOOL    fError;             // TRUE => error present
} ERF;      /* erf */
typedef ERF FAR *PERF;  /* perf */

#define CB_MAX_CHUNK            32768U
#define CB_MAX_DISK         0x7ffffffL
#define CB_MAX_FILENAME            256
#define CB_MAX_CABINET_NAME        256
#define CB_MAX_CAB_PATH            256
#define CB_MAX_DISK_NAME           256

/***    tcompXXX - Compression types
 *
 *  These are passed to FCIAddFile(), and are also stored in the CFFOLDER
 *  structures in cabinet files.
 *
 *  NOTE: We reserve bits for the TYPE, QUANTUM_LEVEL, and QUANTUM_MEM
 *        to provide room for future expansion.  Since this value is stored
 *        in the CFDATA records in the cabinet file, we don't want to
 *        have to change the format for existing compression configurations
 *        if we add new ones in the future.  This will allows us to read
 *        old cabinet files in the future.
 */

typedef unsigned short TCOMP; /* tcomp */

#define tcompMASK_TYPE          0x000F  // Mask for compression type
#define tcompTYPE_NONE          0x0000  // No compression
#define tcompTYPE_MSZIP         0x0001  // MSZIP
#define tcompTYPE_QUANTUM       0x0002  // Quantum
#define tcompTYPE_LZX           0x0003  // LZX
#define tcompBAD                0x000F  // Unspecified compression type

#define tcompMASK_LZX_WINDOW    0x1F00  // Mask for LZX Compression Memory
#define tcompLZX_WINDOW_LO      0x0F00  // Lowest LZX Memory (15)
#define tcompLZX_WINDOW_HI      0x1500  // Highest LZX Memory (21)
#define tcompSHIFT_LZX_WINDOW        8  // Amount to shift over to get int

#define tcompMASK_QUANTUM_LEVEL 0x00F0  // Mask for Quantum Compression Level
#define tcompQUANTUM_LEVEL_LO   0x0010  // Lowest Quantum Level (1)
#define tcompQUANTUM_LEVEL_HI   0x0070  // Highest Quantum Level (7)
#define tcompSHIFT_QUANTUM_LEVEL     4  // Amount to shift over to get int

#define tcompMASK_QUANTUM_MEM   0x1F00  // Mask for Quantum Compression Memory
#define tcompQUANTUM_MEM_LO     0x0A00  // Lowest Quantum Memory (10)
#define tcompQUANTUM_MEM_HI     0x1500  // Highest Quantum Memory (21)
#define tcompSHIFT_QUANTUM_MEM       8  // Amount to shift over to get int

#define tcompMASK_RESERVED      0xE000  // Reserved bits (high 3 bits)



#define CompressionTypeFromTCOMP(tc) \
            ((tc) & tcompMASK_TYPE)

#define CompressionLevelFromTCOMP(tc) \
            (((tc) & tcompMASK_QUANTUM_LEVEL) >> tcompSHIFT_QUANTUM_LEVEL)

#define CompressionMemoryFromTCOMP(tc) \
            (((tc) & tcompMASK_QUANTUM_MEM) >> tcompSHIFT_QUANTUM_MEM)

#define TCOMPfromTypeLevelMemory(t,l,m)           \
            (((m) << tcompSHIFT_QUANTUM_MEM  ) |  \
             ((l) << tcompSHIFT_QUANTUM_LEVEL) |  \
             ( t                             ))

#define LZXCompressionWindowFromTCOMP(tc) \
            (((tc) & tcompMASK_LZX_WINDOW) >> tcompSHIFT_LZX_WINDOW)

#define TCOMPfromLZXWindow(w)      \
            (((w) << tcompSHIFT_LZX_WINDOW ) |  \
             ( tcompTYPE_LZX ))


//** Revert to default structure packing
#pragma pack()

#endif // !INCLUDED_TYPES_FCI_FDI

/*
 *  Concepts:
 *      A *cabinet* file contains one or more *folders*.  A folder contains
 *      one or more (pieces of) *files*.  A folder is by definition a
 *      decompression unit, i.e., to extract a file from a folder, all of
 *      the data from the start of the folder up through and including the
 *      desired file must be read and decompressed.
 *
 *      A folder can span one (or more) cabinet boundaries, and by implication
 *      a file can also span one (or more) cabinet boundaries.  Indeed, more
 *      than one file can span a cabinet boundary, since FCI concatenates
 *      files together into a single data stream before compressing (actually,
 *      at most one file will span any one cabinet boundary, but FCI does
 *      not know which file this is, since the mapping from uncompressed bytes
 *      to compressed bytes is pretty obscure.  Also, since FCI compresses
 *      in blocks of 32K (at present), any files with data in a 32K block that
 *      spans a cabinet boundary require FDI to read both cabinet files
 *      to get the two halves of the compressed block).
 *
 *  Overview:
 *      The File Decompression Interface is used to simplify the reading of
 *      cabinet files.  A setup program will proceed in a manner very
 *      similar to the pseudo code below.  An FDI context is created, the
 *      setup program calls FDICopy() for each cabinet to be processed.  For
 *      each file in the cabinet, FDICopy() calls a notification callback
 *      routine, asking the setup program if the file should be copied.
 *      This call-back approach is great because it allows the cabinet file
 *      to be read and decompressed in an optimal manner, and also makes FDI
 *      independent of the run-time environment -- FDI makes *no* C run-time
 *      calls whatsoever.  All memory allocation and file I/O functions are
 *      passed into FDI by the client.
 *
 *      main(...)
 *      {
 *          // Read INF file to construct list of desired files.   
 *          //  Ideally, these would be sorted in the same order as the
 *          //  files appear in the cabinets, so that you can just walk
 *          //  down the list in response to fdintCOPY_FILE notifications.
 *
 *          // Construct list of required cabinets. 
 *
 *          hfdi = FDICreate(...);          // Create FDI context
 *          For (cabinet in List of Cabinets) {
 *              FDICopy(hfdi,cabinet,fdiNotify,...);  // Process each cabinet
 *          }
 *          FDIDestroy(hfdi);
 *          ...
 *      }
 *
 *      // Notification callback function 
 *      fdiNotify(fdint,...)
 *      {
 *          If (User Aborted)               // Permit cancellation
 *              if (fdint == fdintCLOSE_FILE_INFO)
 *                  close open file
 *              return -1;
 *          switch (fdint) {
 *              case fdintCOPY_FILE:        // File to copy, maybe
 *                  // Check file against list of desired files 
 *                  if want to copy file
 *                      open destination file and return handle
 *                  else
 *                      return NULL;        // Skip file
 *              case fdintCLOSE_FILE_INFO:
 *                  close file
 *                  set date, time, and attributes
 *
 *              case fdintNEXT_CABINET:
 *                  if not an error callback
 *                      Tell FDI to use suggested directory name
 *                  else
 *                      Tell user what the problem was, and prompt
 *                          for a new disk and/or path.
 *                      if user aborts
 *                          Tell FDI to abort
 *                      else
 *                          return to FDI to try another cabinet
 *
 *              default:
 *                  return 0;               // more messages may be defined
 *              ...
 *      }
 *
 *  Error Handling Suggestions:
 *      Since you the client have passed in *all* of the functions that
 *      FDI uses to interact with the "outside" world, you are in prime
 *      position to understand and deal with errors.
 *
 *      The general philosophy of FDI is to pass all errors back up to
 *      the client.  FDI returns fairly generic error codes in the case
 *      where one of the callback functions (PFNOPEN, PFNREAD, etc.) fail,
 *      since it assumes that the callback function will save enough
 *      information in a static/global so that when FDICopy() returns
 *      fail, the client can examine this information and report enough
 *      detail about the problem that the user can take corrective action.
 *
 *      For very specific errors (CORRUPT_CABINET, for example), FDI returns
 *      very specific error codes.
 *
 *      THE BEST POLICY IS FOR YOUR CALLBACK ROUTINES TO AVOID RETURNING
 *      ERRORS TO FDI!
 *
 *      Examples:
 *          (1) If the disk is getting full, instead of returning an error
 *              from your PFNWRITE function, you should -- inside your
 *              PFNWRITE function -- put up a dialog telling the user to free
 *              some disk space.
 *          (2) When you get the fdintNEXT_CABINET notification, you should
 *              verify that the cabinet you return is the correct one (call
 *              FDIIsCabinet(), and make sure the setID matches the one for
 *              the current cabinet specified in the fdintCABINET_INFO, and
 *              that the disk number is one greater.
 *
 *              NOTE: FDI will continue to call fdintNEXT_CABINET until it
 *                    gets the cabinet it wants, or until you return -1
 *                    to abort the FDICopy() call.
 *
 *      The documentation below on the FDI error codes provides explicit
 *      guidance on how to avoid each error.
 *
 *      If you find you must return a failure to FDI from one of your
 *      callback functions, then FDICopy() frees all resources it allocated
 *      and closes all files.  If you can figure out how to overcome the
 *      problem, you can call FDICopy() again on the last cabinet, and
 *      skip any files that you already copied.  But, note that FDI does
 *      *not* maintain any state between FDICopy() calls, other than possibly
 *      memory allocated for the decompressor.
 *
 *      See FDIERROR for details on FDI error codes and recommended actions.
 *
 *
 *  Progress Indicator Suggestions:
 *      As above, all of the file I/O functions are supplied by you.  So,
 *      updating a progress indicator is very simple.  You keep track of
 *      the target files handles you have opened, along with the uncompressed
 *      size of the target file.  When you see writes to the handle of a
 *      target file, you use the write count to update your status!
 *      Since this method is available, there is no separate callback from
 *      FDI just for progess indication.
 */

//** Specify structure packing explicitly for clients of FDI
#pragma pack(4)


/***    FDIERROR - Error codes returned in erf.erfOper field
 *
 *  In general, FDI will only fail if one of the passed in memory or
 *  file I/O functions fails.  Other errors are pretty unlikely, and are
 *  caused by corrupted cabinet files, passing in a file which is not a
 *  cabinet file, or cabinet files out of order.
 *
 *  Description:    Summary of error.
 *  Cause:          List of possible causes of this error.
 *  Response:       How client might respond to this error, or avoid it in
 *                  the first place.
 */
typedef enum {
    FDIERROR_NONE,
        // Description: No error
        // Cause:       Function was successfull.
        // Response:    Keep going!

    FDIERROR_CABINET_NOT_FOUND,
        // Description: Cabinet not found
        // Cause:       Bad file name or path passed to FDICopy(), or returned
        //              to fdintNEXT_CABINET.
        // Response:    To prevent this error, validate the existence of the
        //              the cabinet *before* passing the path to FDI.

    FDIERROR_NOT_A_CABINET,
        // Description: Cabinet file does not have the correct format
        // Cause:       File passed to to FDICopy(), or returned to
        //              fdintNEXT_CABINET, is too small to be a cabinet file,
        //              or does not have the cabinet signature in its first
        //              four bytes.
        // Response:    To prevent this error, call FDIIsCabinet() to check a
        //              cabinet before calling FDICopy() or returning the
        //              cabinet path to fdintNEXT_CABINET.

    FDIERROR_UNKNOWN_CABINET_VERSION,
        // Description: Cabinet file has an unknown version number.
        // Cause:       File passed to to FDICopy(), or returned to
        //              fdintNEXT_CABINET, has what looks like a cabinet file
        //              header, but the version of the cabinet file format
        //              is not one understood by this version of FDI.  The
        //              erf.erfType field is filled in with the version number
        //              found in the cabinet file.
        // Response:    To prevent this error, call FDIIsCabinet() to check a
        //              cabinet before calling FDICopy() or returning the
        //              cabinet path to fdintNEXT_CABINET.

    FDIERROR_CORRUPT_CABINET,
        // Description: Cabinet file is corrupt
        // Cause:       FDI returns this error any time it finds a problem
        //              with the logical format of a cabinet file, and any
        //              time one of the passed-in file I/O calls fails when
        //              operating on a cabinet (PFNOPEN, PFNSEEK, PFNREAD,
        //              or PFNCLOSE).  The client can distinguish these two
        //              cases based upon whether the last file I/O call
        //              failed or not.
        // Response:    Assuming this is not a real corruption problem in
        //              a cabinet file, the file I/O functions could attempt
        //              to do retries on failure (for example, if there is a
        //              temporary network connection problem).  If this does
        //              not work, and the file I/O call has to fail, then the
        //              FDI client will have to clean up and call the
        //              FDICopy() function again.

    FDIERROR_ALLOC_FAIL,
        // Description: Could not allocate enough memory
        // Cause:       FDI tried to allocate memory with the PFNALLOC
        //              function, but it failed.
        // Response:    If possible, PFNALLOC should take whatever steps
        //              are possible to allocate the memory requested.  If
        //              memory is not immediately available, it might post a
        //              dialog asking the user to free memory, for example.
        //              Note that the bulk of FDI's memory allocations are
        //              made at FDICreate() time and when the first cabinet
        //              file is opened during FDICopy().

    FDIERROR_BAD_COMPR_TYPE,
        // Description: Unknown compression type in a cabinet folder
        // Cause:       [Should never happen.]  A folder in a cabinet has an
        //              unknown compression type.  This is probably caused by
        //              a mismatch between the version of FCI.LIB used to
        //              create the cabinet and the FDI.LIB used to read the
        //              cabinet.
        // Response:    Abort.

    FDIERROR_MDI_FAIL,
        // Description: Failure decompressing data from a cabinet file
        // Cause:       The decompressor found an error in the data coming
        //              from the file cabinet.  The cabinet file was corrupted.
        //              [11-Apr-1994 bens When checksuming is turned on, this
        //              error should never occur.]
        // Response:    Probably should abort; only other choice is to cleanup
        //              and call FDICopy() again, and hope there was some
        //              intermittent data error that will not reoccur.

    FDIERROR_TARGET_FILE,
        // Description: Failure writing to target file
        // Cause:       FDI returns this error any time it gets an error back
        //              from one of the passed-in file I/O calls fails when
        //              writing to a file being extracted from a cabinet.
        // Response:    To avoid or minimize this error, the file I/O functions
        //              could attempt to avoid failing.  A common cause might
        //              be disk full -- in this case, the PFNWRITE function
        //              could have a check for free space, and put up a dialog
        //              asking the user to free some disk space.

    FDIERROR_RESERVE_MISMATCH,
        // Description: Cabinets in a set do not have the same RESERVE sizes
        // Cause:       [Should never happen]. FDI requires that the sizes of
        //              the per-cabinet, per-folder, and per-data block
        //              RESERVE sections be consistent across all the cabinets
        //              in a set.
        // Response:    Abort.

    FDIERROR_WRONG_CABINET,
        // Description: Cabinet returned on fdintNEXT_CABINET is incorrect
        // Cause:       NOTE: THIS ERROR IS NEVER RETURNED BY FDICopy()!
        //              Rather, FDICopy() keeps calling the fdintNEXT_CABINET
        //              callback until either the correct cabinet is specified,
        //              or you return ABORT.
        //              When FDICopy() is extracting a file that crosses a
        //              cabinet boundary, it calls fdintNEXT_CABINET to ask
        //              for the path to the next cabinet.  Not being very
        //              trusting, FDI then checks to make sure that the
        //              correct continuation cabinet was supplied!  It does
        //              this by checking the "setID" and "iCabinet" fields
        //              in the cabinet.  When MAKECAB.EXE creates a set of
        //              cabinets, it constructs the "setID" using the sum
        //              of the bytes of all the destination file names in
        //              the cabinet set.  FDI makes sure that the 16-bit
        //              setID of the continuation cabinet matches the
        //              cabinet file just processed.  FDI then checks that
        //              the cabinet number (iCabinet) is one more than the
        //              cabinet number for the cabinet just processed.
        // Response:    You need code in your fdintNEXT_CABINET (see below)
        //              handler to do retries if you get recalled with this
        //              error.  See the sample code (EXTRACT.C) to see how
        //              this should be handled.

    FDIERROR_USER_ABORT,
        // Description: FDI aborted.
        // Cause:       An FDI callback returnd -1 (usually).
        // Response:    Up to client.

} FDIERROR;


/*
 * FAT file attribute flag used by FCI/FDI to indicate that
 * the filename in the CAB is a UTF string
 */
#ifndef _A_NAME_IS_UTF
#define _A_NAME_IS_UTF  0x80
#endif

/*
 * FAT file attribute flag used by FCI/FDI to indicate that
 * the file should be executed after extraction
 */
#ifndef _A_EXEC
#define _A_EXEC         0x40
#endif


/***    HFDI - Handle to an FDI context
 *
 *  FDICreate() creates this, and it must be passed to all other FDI
 *  functions.
 */
typedef void FAR *HFDI; /* hfdi */


/***    FDICABINETINFO - Information about a cabinet
 *
 */
typedef struct {
    long        cbCabinet;              // Total length of cabinet file
    USHORT      cFolders;               // Count of folders in cabinet
    USHORT      cFiles;                 // Count of files in cabinet
    USHORT      setID;                  // Cabinet set ID
    USHORT      iCabinet;               // Cabinet number in set (0 based)
    BOOL        fReserve;               // TRUE => RESERVE present in cabinet
    BOOL        hasprev;                // TRUE => Cabinet is chained prev
    BOOL        hasnext;                // TRUE => Cabinet is chained next
} FDICABINETINFO; /* fdici */
typedef FDICABINETINFO FAR *PFDICABINETINFO; /* pfdici */


/***    FDIDECRYPTTYPE - PFNFDIDECRYPT command types
 *
 */
typedef enum {
    fdidtNEW_CABINET,                   // New cabinet
    fdidtNEW_FOLDER,                    // New folder
    fdidtDECRYPT,                       // Decrypt a data block
} FDIDECRYPTTYPE; /* fdidt */


/***    FDIDECRYPT - Data for PFNFDIDECRYPT function
 *
 */
typedef struct {
    FDIDECRYPTTYPE    fdidt;            // Command type (selects union below)
    void FAR         *pvUser;           // Decryption context
    union {
        struct {                        // fdidtNEW_CABINET
            void FAR *pHeaderReserve;   // RESERVE section from CFHEADER
            USHORT    cbHeaderReserve;  // Size of pHeaderReserve
            USHORT    setID;            // Cabinet set ID
            int       iCabinet;         // Cabinet number in set (0 based)
        } cabinet;

        struct {                        // fdidtNEW_FOLDER
            void FAR *pFolderReserve;   // RESERVE section from CFFOLDER
            USHORT    cbFolderReserve;  // Size of pFolderReserve
            USHORT    iFolder;          // Folder number in cabinet (0 based)
        } folder;

        struct {                        // fdidtDECRYPT
            void FAR *pDataReserve;     // RESERVE section from CFDATA
            USHORT    cbDataReserve;    // Size of pDataReserve
            void FAR *pbData;           // Data buffer
            USHORT    cbData;           // Size of data buffer
            BOOL      fSplit;           // TRUE if this is a split data block
            USHORT    cbPartial;        // 0 if this is not a split block, or
                                        //  the first piece of a split block;
                                        // Greater than 0 if this is the
                                        //  second piece of a split block.
        } decrypt;
    };
} FDIDECRYPT; /* fdid */
typedef FDIDECRYPT FAR *PFDIDECRYPT; /* pfdid */


/***    FNALLOC - Memory Allocation
 *      FNFREE  - Memory Free
 *
 *  These are modeled after the C run-time routines malloc() and free()
 *  FDI expects error handling to be identical to these C run-time routines.
 *
 *  As long as you faithfully copy the semantics of malloc() and free(),
 *  you can supply any functions you like!
 *
 *  WARNING: You should never assume anything about the sequence of
 *           PFNALLOC and PFNFREE calls -- incremental releases of
 *           FDI may have radically different numbers of
 *           PFNALLOC calls and allocation sizes!
 */
//** Memory functions for FDI
typedef void HUGE * (FAR DIAMONDAPI *PFNALLOC)(ULONG cb); /* pfna */
#define FNALLOC(fn) void HUGE * FAR DIAMONDAPI fn(ULONG cb)

typedef void (FAR DIAMONDAPI *PFNFREE)(void HUGE *pv); /* pfnf */
#define FNFREE(fn) void FAR DIAMONDAPI fn(void HUGE *pv)


/***    PFNOPEN  - File I/O callbacks for FDI
 *      PFNREAD
 *      PFNWRITE
 *      PFNCLOSE
 *      PFNSEEK
 *
 *  These are modeled after the C run-time routines _open, _read,
 *  _write, _close, and _lseek.  The values for the PFNOPEN oflag
 *  and pmode calls are those defined for _open.  FDI expects error
 *  handling to be identical to these C run-time routines.
 *
 *  As long as you faithfully copy these aspects, you can supply
 *  any functions you like!
 *
 *  WARNING: You should never assume you know what file is being
 *           opened at any one point in time!  FDI will usually
 *           stick to opening cabinet files, but it is possible
 *           that in a future implementation it may open temporary
 *           files or open cabinet files in a different order.
 *
 *  Notes for Memory Mapped File fans:
 *      You can write wrapper routines to allow FDI to work on memory
 *      mapped files.  You'll have to create your own "handle" type so that
 *      you can store the base memory address of the file and the current
 *      seek position, and then you'll allocate and fill in one of these
 *      structures and return a pointer to it in response to the PFNOPEN
 *      call and the fdintCOPY_FILE call.  Your PFNREAD and PFNWRITE
 *      functions will do memcopy(), and update the seek position in your
 *      "handle" structure.  PFNSEEK will just change the seek position
 *      in your "handle" structure.
 */
//** File I/O functions for FDI
typedef int  (FAR DIAMONDAPI *PFNOPEN) (char FAR *pszFile, int oflag, int pmode);
typedef UINT (FAR DIAMONDAPI *PFNREAD) (int hf, void FAR *pv, UINT cb);
typedef UINT (FAR DIAMONDAPI *PFNWRITE)(int hf, void FAR *pv, UINT cb);
typedef int  (FAR DIAMONDAPI *PFNCLOSE)(int hf);
typedef long (FAR DIAMONDAPI *PFNSEEK) (int hf, long dist, int seektype);

#define FNOPEN(fn) int FAR DIAMONDAPI fn(char FAR *pszFile, int oflag, int pmode)
#define FNREAD(fn) UINT FAR DIAMONDAPI fn(int hf, void FAR *pv, UINT cb)
#define FNWRITE(fn) UINT FAR DIAMONDAPI fn(int hf, void FAR *pv, UINT cb)
#define FNCLOSE(fn) int FAR DIAMONDAPI fn(int hf)
#define FNSEEK(fn) long FAR DIAMONDAPI fn(int hf, long dist, int seektype)



/***    PFNFDIDECRYPT - FDI Decryption callback
 *
 *  If this function is passed on the FDICopy() call, then FDI calls it
 *  at various times to update the decryption state and to decrypt FCDATA
 *  blocks.
 *
 *  Common Entry Conditions:
 *      pfdid->fdidt  - Command type
 *      pfdid->pvUser - pvUser value from FDICopy() call
 *
 *  fdidtNEW_CABINET:   //** Notification of a new cabinet
 *      Entry:
 *        pfdid->cabinet.
 *          pHeaderReserve  - RESERVE section from CFHEADER
 *          cbHeaderReserve - Size of pHeaderReserve
 *          setID           - Cabinet set ID
 *          iCabinet        - Cabinet number in set (0 based)
 *      Exit-Success:
 *          returns anything but -1;
 *      Exit-Failure:
 *          returns -1; FDICopy() is aborted.
 *      Notes:
 *      (1) This call allows the decryption code to pick out any information
 *          from the cabinet header reserved area (placed there by DIACRYPT)
 *          needed to perform decryption.  If there is no such information,
 *          this call would presumably be ignored.
 *      (2) This call is made very soon after fdintCABINET_INFO.
 *
 *  fdidtNEW_FOLDER:    //** Notification of a new folder
 *      Entry:
 *        pfdid->folder.
 *          pFolderReserve  - RESERVE section from CFFOLDER
 *          cbFolderReserve - Size of pFolderReserve
 *          iFolder         - Folder number in cabinet (0 based)
 *      Exit-Success:
 *          returns anything but -1;
 *      Exit-Failure:
 *          returns -1; FDICopy() is aborted.
 *      Notes:
 *          This call allows the decryption code to pick out any information
 *          from the folder reserved area (placed there by DIACRYPT) needed
 *          to perform decryption.  If there is no such information, this
 *          call would presumably be ignored.
 *
 *  fdidtDECRYPT:       //** Decrypt a data buffer
 *      Entry:
 *        pfdid->folder.
 *          pDataReserve  - RESERVE section for this CFDATA block
 *          cbDataReserve - Size of pDataReserve
 *          pbData        - Data buffer
 *          cbData        - Size of data buffer
 *          fSplit        - TRUE if this is a split data block
 *          cbPartial     - 0 if this is not a split block, or the first
 *                              piece of a split block; Greater than 0 if
 *                              this is the second piece of a split block.
 *      Exit-Success:
 *          returns TRUE;
 *      Exit-Failure:
 *          returns FALSE; error during decrypt
 *          returns -1; FDICopy() is aborted.
 *      Notes:
 *          FCI will split CFDATA blocks across cabinet boundaries if
 *          necessary.  To provide maximum flexibility, FDI will call the
 *          fdidtDECRYPT function twice on such split blocks, once when
 *          the first portion is read, and again when the second portion
 *          is read.  And, of course, most data blocks will not be split.
 *          So, there are three cases:
 *
 *           1) fSplit == FALSE
 *              You have the entire data block, so decrypt it.
 *
 *           2) fSplit == TRUE, cbPartial == 0
 *              This is the first portion of a split data block, so cbData
 *              is the size of this portion.  You can either choose to decrypt
 *              this piece, or ignore this call and decrypt the full CFDATA
 *              block on the next (second) fdidtDECRYPT call.
 *
 *           3) fSplit == TRUE, cbPartial > 0
 *              This is the second portion of a split data block (indeed,
 *              cbPartial will have the same value as cbData did on the
 *              immediately preceeding fdidtDECRYPT call!).  If you decrypted
 *              the first portion on the first call, then you can decrypt the
 *              second portion now.  If you ignored the first call, then you
 *              can decrypt the entire buffer.
 *              NOTE: pbData points to the second portion of the split data
 *                    block in this case, *not* the entire data block.  If
 *                    you want to wait until the second piece to decrypt the
 *                    *entire* block, pbData-cbPartial is the address of the
 *                    start of the whole block, and cbData+cbPartial is its
 *                    size.
 */
typedef int (FAR DIAMONDAPI *PFNFDIDECRYPT)(PFDIDECRYPT pfdid); /* pfnfdid */
#define FNFDIDECRYPT(fn) int FAR DIAMONDAPI fn(PFDIDECRYPT pfdid)


/***    FDINOTIFICATION - Notification structure for PFNFDINOTIFY
 *
 *  See the FDINOTIFICATIONTYPE definition for information on usage and
 *  meaning of these fields.
 */
typedef struct {
// long fields
    long      cb;
    char FAR *psz1;
    char FAR *psz2;
    char FAR *psz3;                     // Points to a 256 character buffer
    void FAR *pv;                       // Value for client

// int fields
    int       hf;

// short fields
    USHORT    date;
    USHORT    time;
    USHORT    attribs;

    USHORT    setID;                    // Cabinet set ID
    USHORT    iCabinet;                 // Cabinet number (0-based)
    USHORT    iFolder;                  // Folder number (0-based)

    FDIERROR  fdie;
} FDINOTIFICATION, FAR *PFDINOTIFICATION;  /* fdin, pfdin */


/***    FDINOTIFICATIONTYPE - FDICopy notification types
 *
 *  The notification function for FDICopy can be called with the following
 *  values for the fdint parameter.  In all cases, the pfdin->pv field is
 *  filled in with the value of the pvUser argument passed in to FDICopy().
 *
 *  A typical sequence of calls will be something like this:
 *      fdintCABINET_INFO     // Info about the cabinet
 *      fdintENUMERATE        // Starting enumeration
 *      fdintPARTIAL_FILE     // Only if this is not the first cabinet, and
 *                            // one or more files were continued from the
 *                            // previous cabinet.
 *      ...
 *      fdintPARTIAL_FILE
 *      fdintCOPY_FILE        // The first file that starts in this cabinet
 *      ...
 *      fdintCOPY_FILE        // Now let's assume you want this file...
 *      // PFNWRITE called multiple times to write to this file.
 *      fdintCLOSE_FILE_INFO  // File done, set date/time/attributes
 *
 *      fdintCOPY_FILE        // Now let's assume you want this file...
 *      // PFNWRITE called multiple times to write to this file.
 *      fdintNEXT_CABINET     // File was continued to next cabinet!
 *      fdintCABINET_INFO     // Info about the new cabinet
 *      // PFNWRITE called multiple times to write to this file.
 *      fdintCLOSE_FILE_INFO  // File done, set date/time/attributes
 *      ...
 *      fdintENUMERATE        // Ending enumeration
 *
 *  fdintCABINET_INFO:
 *        Called exactly once for each cabinet opened by FDICopy(), including
 *        continuation cabinets opened due to file(s) spanning cabinet
 *        boundaries. Primarily intended to permit EXTRACT.EXE to
 *        automatically select the next cabinet in a cabinet sequence even if
 *        not copying files that span cabinet boundaries.
 *      Entry:
 *          pfdin->psz1     = name of next cabinet
 *          pfdin->psz2     = name of next disk
 *          pfdin->psz3     = cabinet path name
 *          pfdin->setID    = cabinet set ID (a random 16-bit number)
 *          pfdin->iCabinet = Cabinet number within cabinet set (0-based)
 *      Exit-Success:
 *          Return anything but -1
 *      Exit-Failure:
 *          Returns -1 => Abort FDICopy() call
 *      Notes:
 *          This call is made *every* time a new cabinet is examined by
 *          FDICopy().  So if "foo2.cab" is examined because a file is
 *          continued from "foo1.cab", and then you call FDICopy() again
 *          on "foo2.cab", you will get *two* fdintCABINET_INFO calls all
 *          told.
 *
 *  fdintCOPY_FILE:
 *        Called for each file that *starts* in the current cabinet, giving
 *        the client the opportunity to request that the file be copied or
 *        skipped.
 *      Entry:
 *          pfdin->psz1    = file name in cabinet
 *          pfdin->cb      = uncompressed size of file
 *          pfdin->date    = file date
 *          pfdin->time    = file time
 *          pfdin->attribs = file attributes
 *          pfdin->iFolder = file's folder index
 *      Exit-Success:
 *          Return non-zero file handle for destination file; FDI writes
 *          data to this file use the PFNWRITE function supplied to FDICreate,
 *          and then calls fdintCLOSE_FILE_INFO to close the file and set
 *          the date, time, and attributes.  NOTE: This file handle returned
 *          must also be closeable by the PFNCLOSE function supplied to
 *          FDICreate, since if an error occurs while writing to this handle,
 *          FDI will use the PFNCLOSE function to close the file so that the
 *          client may delete it.
 *      Exit-Failure:
 *          Returns 0  => Skip file, do not copy
 *          Returns -1 => Abort FDICopy() call
 *
 *  fdintCLOSE_FILE_INFO:
 *        Called after all of the data has been written to a target file.
 *        This function must close the file and set the file date, time,
 *        and attributes.
 *      Entry:
 *          pfdin->psz1    = file name in cabinet
 *          pfdin->hf      = file handle
 *          pfdin->date    = file date
 *          pfdin->time    = file time
 *          pfdin->attribs = file attributes
 *          pfdin->iFolder = file's folder index
 *          pfdin->cb      = Run After Extract (0 - don't run, 1 Run)
 *      Exit-Success:
 *          Returns TRUE
 *      Exit-Failure:
 *          Returns FALSE, or -1 to abort;
 *
 *              IMPORTANT NOTE IMPORTANT:
 *                  pfdin->cb is overloaded to no longer be the size of
 *                  the file but to be a binary indicated run or not
 *
 *              IMPORTANT NOTE:
 *                  FDI assumes that the target file was closed, even if this
 *                  callback returns failure.  FDI will NOT attempt to use
 *                  the PFNCLOSE function supplied on FDICreate() to close
 *                  the file!
 *
 *  fdintPARTIAL_FILE:
 *        Called for files at the front of the cabinet that are CONTINUED
 *        from a previous cabinet.  This callback occurs only when FDICopy is
 *        started on second or subsequent cabinet in a series that has files
 *        continued from a previous cabinet.
 *      Entry:
 *          pfdin->psz1 = file name of file CONTINUED from a PREVIOUS cabinet
 *          pfdin->psz2 = name of cabinet where file starts
 *          pfdin->psz3 = name of disk where file starts
 *      Exit-Success:
 *          Return anything other than -1; enumeration continues
 *      Exit-Failure:
 *          Returns -1 => Abort FDICopy() call
 *
 *  fdintENUMERATE:
 *        Called once after a call to FDICopy() starts scanning a CAB's
 *        CFFILE entries, and again when there are no more CFFILE entries.
 *        If CAB spanning occurs, an additional call will occur after the
 *        first spanned file is completed.  If the pfdin->iFolder value is
 *        changed from zero, additional calls will occur next time it reaches
 *        zero.  If iFolder is changed to zero, FDICopy will terminate, as if
 *        there were no more CFFILE entries.  Primarily intended to allow an
 *        application with it's own file list to help FDI advance quickly to
 *        a CFFILE entry of interest.  Can also be used to allow an
 *        application to determine the cb values for each file in the CAB.
 *      Entry:
 *        pfdin->cb        = current CFFILE position
 *        pfdin->iFolder   = number of files remaining
 *        pfdin->setID     = current CAB's setID value
 *      Exit-Don't Care:
 *        Don't change anything.
 *        Return anything but -1.
 *      Exit-Forcing a skip:
 *        pfdin->cb        = desired CFFILE position
 *        pfdin->iFolder   = desired # of files remaining
 *        Return anything but -1.
 *      Exit-Stop:
 *        pfdin->iFolder    = set to 0
 *        Return anything but -1.
 *      Exit-Failure:
 *        Return -1 => Abort FDICopy call ("user aborted".)
 *      Notes:
 *        This call can be ignored by applications which want normal file
 *        searching.  The application can adjust the supplied values to
 *        force FDICopy() to continue it's search at another location, or
 *        to force FDICopy() to terminate the search, by setting iFolder to 0.
 *        (FDICopy() will report no error when terminated this way.)
 *        FDI has no means to verify the supplied cb or iFolder values.
 *        Arbitrary values are likely to cause undesirable results.  An
 *        application should cross-check pfdin->setID to be certain the
 *        external database is in sync with the CAB.  Reverse-skips are OK
 *        (but may be inefficient) unless fdintNEXT_CABINET has been called.
 *
 *  fdintNEXT_CABINET:
 *        This function is *only* called when fdintCOPY_FILE was told to copy
 *        a file in the current cabinet that is continued to a subsequent
 *        cabinet file.  It is important that the cabinet path name (psz3)
 *        be validated before returning!  This function should ensure that
 *        the cabinet exists and is readable before returning.  So, this
 *        is the function that should, for example, issue a disk change
 *        prompt and make sure the cabinet file exists.
 *
 *        When this function returns to FDI, FDI will check that the setID
 *        and iCabinet match the expected values for the next cabinet.
 *        If not, FDI will continue to call this function until the correct
 *        cabinet file is specified, or until this function returns -1 to
 *        abort the FDICopy() function.  pfdin->fdie is set to
 *        FDIERROR_WRONG_CABINET to indicate this case.
 *
 *        If you *haven't* ensured that the cabinet file is present and
 *        readable, or the cabinet file has been damaged, pfdin->fdie will
 *        receive other appropriate error codes:
 *
 *              FDIERROR_CABINET_NOT_FOUND
 *              FDIERROR_NOT_A_CABINET
 *              FDIERROR_UNKNOWN_CABINET_VERSION
 *              FDIERROR_CORRUPT_CABINET
 *              FDIERROR_BAD_COMPR_TYPE
 *              FDIERROR_RESERVE_MISMATCH
 *              FDIERROR_WRONG_CABINET
 *
 *      Entry:
 *          pfdin->psz1 = name of next cabinet where current file is continued
 *          pfdin->psz2 = name of next disk where current file is continued
 *          pfdin->psz3 = cabinet path name; FDI concatenates psz3 with psz1
 *                          to produce the fully-qualified path for the cabinet
 *                          file.  The 256-byte buffer pointed at by psz3 may
 *                          be modified, but psz1 may not!
 *          pfdin->fdie = FDIERROR_WRONG_CABINET if the previous call to
 *                        fdintNEXT_CABINET specified a cabinet file that
 *                        did not match the setID/iCabinet that was expected.
 *      Exit-Success:
 *          Return anything but -1
 *      Exit-Failure:
 *          Returns -1 => Abort FDICopy() call
 *      Notes:
 *          This call is almost always made when a target file is open and
 *          being written to, and the next cabinet is needed to get more
 *          data for the file.
 */
typedef enum {
    fdintCABINET_INFO,              // General information about cabinet
    fdintPARTIAL_FILE,              // First file in cabinet is continuation
    fdintCOPY_FILE,                 // File to be copied
    fdintCLOSE_FILE_INFO,           // close the file, set relevant info
    fdintNEXT_CABINET,              // File continued to next cabinet
    fdintENUMERATE,                 // Enumeration status
} FDINOTIFICATIONTYPE; /* fdint */

typedef int (FAR DIAMONDAPI *PFNFDINOTIFY)(FDINOTIFICATIONTYPE fdint,
                                           PFDINOTIFICATION    pfdin); /* pfnfdin */

#define FNFDINOTIFY(fn) int FAR DIAMONDAPI fn(FDINOTIFICATIONTYPE fdint, \
                                              PFDINOTIFICATION    pfdin)


/*** cpuType values for FDICreate()
 *
 *  (Ignored by 32-bit FDI.)
 */
#define     cpuUNKNOWN         (-1)    /* FDI does detection */
#define     cpu80286           (0)     /* '286 opcodes only */
#define     cpu80386           (1)     /* '386 opcodes used */


/***    FDICreate - Create an FDI context
 *
 *  Entry:
 *      pfnalloc
 *      pfnfree
 *      pfnopen
 *      pfnread
 *      pfnwrite
 *      pfnclose
 *      pfnlseek
 *      cpuType  - Select CPU type (auto-detect, 286, or 386+)
 *                 NOTE: For the 32-bit FDI.LIB, this parameter is ignored!
 *      perf
 *
 *  Exit-Success:
 *      Returns non-NULL FDI context handle.
 *
 *  Exit-Failure:
 *      Returns NULL; perf filled in with error code
 *
 */
HFDI FAR DIAMONDAPI FDICreate(PFNALLOC pfnalloc,
                              PFNFREE  pfnfree,
                              PFNOPEN  pfnopen,
                              PFNREAD  pfnread,
                              PFNWRITE pfnwrite,
                              PFNCLOSE pfnclose,
                              PFNSEEK  pfnseek,
                              int      cpuType,
                              PERF     perf);


/***    FDIIsCabinet - Determines if file is a cabinet, returns info if it is
 *
 *  Entry:
 *      hfdi   - Handle to FDI context (created by FDICreate())
 *      hf     - File handle suitable for PFNREAD/PFNSEEK, positioned
 *               at offset 0 in the file to test.
 *      pfdici - Buffer to receive info about cabinet if it is one.
 *
 *  Exit-Success:
 *      Returns TRUE; file is a cabinet, pfdici filled in.
 *
 *  Exit-Failure:
 *      Returns FALSE, file is not a cabinet;  If an error occurred,
 *          perf (passed on FDICreate call!) filled in with error.
 */
BOOL FAR DIAMONDAPI FDIIsCabinet(HFDI            hfdi,
                                 int             hf,
                                 PFDICABINETINFO pfdici);


/***    FDICopy - extracts files from a cabinet
 *
 *  Entry:
 *      hfdi        - handle to FDI context (created by FDICreate())
 *      pszCabinet  - main name of cabinet file
 *      pszCabPath  - Path to cabinet file(s)
 *      flags       - Flags to modify behavior
 *      pfnfdin     - Notification function
 *      pfnfdid     - Decryption function (pass NULL if not used)
 *      pvUser      - User specified value to pass to notification function
 *
 *  Exit-Success:
 *      Returns TRUE;
 *
 *  Exit-Failure:
 *      Returns FALSE, perf (passed on FDICreate call!) filled in with
 *          error.
 *
 *  Notes:
 *  (1) If FDICopy() fails while a target file is being written out, then
 *      FDI will use the PFNCLOSE function to close the file handle for that
 *      target file that was returned from the fdintCOPY_FILE notification.
 *      The client application is then free to delete the target file, since
 *      it will not be in a valid state (since there was an error while
 *      writing it out).
 */
BOOL FAR DIAMONDAPI FDICopy(HFDI          hfdi,
                            char FAR     *pszCabinet,
                            char FAR     *pszCabPath,
                            int           flags,
                            PFNFDINOTIFY  pfnfdin,
                            PFNFDIDECRYPT pfnfdid,
                            void FAR     *pvUser);


/***    FDIDestroy - Destroy an FDI context
 *
 *  Entry:
 *      hfdi - handle to FDI context (created by FDICreate())
 *
 *  Exit-Success:
 *      Returns TRUE;
 *
 *  Exit-Failure:
 *      Returns FALSE;
 */
BOOL FAR DIAMONDAPI FDIDestroy(HFDI hfdi);


//** Revert to default structure packing
#pragma pack()

// CFCACHE -------------------------------------------------------------------------------

//
// We don't keep all CFFILE records in memory, define a cache.
// CFFILE entries are not fixed-size, so we will have to parse a byte
// buffer ...
//
// We choose a seemingly unusual number because async disk reads must be
// sector-aligned (512 bytes). However, since CFFILEs are variable sized,
// it is not likely that we will completely use up the buffer the every
// time. Since the cost of not utilizing the whole buffer is quite steep
// (minimum cost is 512 bytes), I am adding an additional 64 bytes to
// accomodate for leftovers. 64 is chosen because I expect a typical 
// CFFILE entry to be about that size. This should give us 4 full sectors
// plus an incomplete CFFILE entry.
//
#define CFFILECACHE_SIZE        (2048 + 64)

//
// Define a CFFILE cache
//
typedef struct
{
    HANDLE          hFile;            // File handle to read from
    ULARGE_INTEGER  uliReadOffset;    // Offset to read from file
    PBYTE           pbBuffer;        // Buffer pointer
    DWORD           cbBuffer;        // Buffer length
    WORD            wCurrentIndex;    // Index of current CFFILE in cache
    WORD            wCffiles;        // Number of CFFILES in package
    WORD            wCursor;        // Current offset in the buffer
    WORD            wDataSize;        // Bytes of data in the buffer
    WORD            wAlignment;        // Alignment padding
    BYTE            bFlags;            // Informational flags
    BYTE            bPadding;        // Special buffer padding
    BYTE            rgbBuffer[CFFILECACHE_SIZE];
                                    // Default data buffer
    XONLINESYMMDEC_CONTEXT    symmdec; // Decryption context                    

    XONLINETASK_FILEIO        fileio;  // Async file I/O context
    HANDLE                    hEventWork;    // Work event

} XONLINECONTENT_CFFILECACHE, *PXONLINECONTENT_CFFILECACHE;

//
// Define the set of flags for bFlags
//
#define CFFILECACHE_FLAG_READ_PENDING        ((BYTE)0x01)
#define CFFILECACHE_FLAG_DISCARD_PREDATA    ((BYTE)0x02)

//
// Define an I/O pending success code for GetNextCffileEntry
//
#define S_CFFILECACHE_IO_PENDING        ERROR_IO_PENDING

//
// Define an EOF success code for GetNextCffileEntry
//
#define S_CFFILECACHE_NO_MORE_ITEMS        ERROR_NO_MORE_ITEMS

// DIROPS --------------------------------------------------------------------------------

//
// Directory operations
//

//
// Function to kick off an asynchronous recursive create directory. This
// function recursively creates all the directories up till the specified
// path.
//
// Arguments:
// szDirectoryPath - Path of the directory to create. This path may
//            or may not contain a file name, see dwFlags for details.
// dwFlags - Flags for specifying options. The following flag(s) are
//            defined:
//            XONLINETASK_CDFLAG_FILE_PATH - this flag indicates that
//                szDirectoryPath contains a file name. Only the directories
//                up to the file name will be created. If this flag is not
//                present, then entire path will be treated as a directory.
// hWorkEvent - Caller-supplied event to signal work. This event
//            will be signalled when the overlapped read completes
//            This can be NULL for a polling model.
// phTask - receives the task handle on success
//
// Return Values:
// S_OK - Task successfully started
// or any other appropriate error code.
//
// Remarks:
// This function will not validate directory paths
//

#define XONLINETASK_CDFLAG_FILE_PATH        (0x00000001)

#define XONLINETASK_EDFLAG_ENUMERATE_FILES    (0x00000001)
#define XONLINETASK_EDFLAG_ENUMERATE_DIRS    (0x00000002)
#define XONLINETASK_EDFLAG_ENUMERATE_ALL    \
    (XONLINETASK_EDFLAG_ENUMERATE_FILES | XONLINETASK_EDFLAG_ENUMERATE_DIRS)

//
// Define the directory ops
//
typedef enum
{
    diropCreateDirectory = 0,
    diropRemoveDirectory,
    diropEnumerateDirectory,
    diropMaxOp
    
} XONLINEDIROPS_OPS;

//
// Define a structure describing a 'skip' list
//
#define DIROPS_MAX_SKIP_ENTRIES        2

typedef struct
{
    DWORD    dwEntries;
    PSTR    rgszSkipPath[DIROPS_MAX_SKIP_ENTRIES];

} XONLINEDIROPS_SKIP_LIST, *PXONLINEDIROPS_SKIP_LIST;

//
// Define context structure shared by directory ops
//
typedef struct
{
    XONLINETASK_CONTEXT        xontask;    // Task context

    HRESULT                    hr;            // Status code
    XONLINEDIROPS_OPS        dirop;        // Operation to perform
    PSTR                    szPath;        // Path string
    DWORD                    cbPath;        // Path size (excluding NULL)
    DWORD                    cbMax;        // Max buffer size
    PSTR                    szDir;        // Next directory to process
    DWORD                    cbDir;        // Directory length
    DWORD                    cbCurrent;    // Current path length
    DWORD                    dwIndex;    // Index pointer
    DWORD                    dwFlags;    // Flags

    HANDLE                    hFind;        // Find handle
    
    XONLINETASK_HANDLE        hTaskOnData;// OnData subtask
    XONLINETASK_HANDLE        hTaskOnDone;// OnDone subtask

    XONLINEDIROPS_SKIP_LIST    DirsToSkip;    // Dirs to skip
    XONLINEDIROPS_SKIP_LIST    FilesToSkip;// Files to skip

} XONLINETASK_DIROPS, *PXONLINETASK_DIROPS;

//
// Special task context for directory crawling
//
#define MAX_CRAWL_DEPTH        128

typedef struct
{
    XONLINETASK_CONTEXT        xontask;    // Task context
    DWORD                    dwState;    // Current state
    HRESULT                    hr;            // Status code

    PSTR                    szPath;        // Path string
    DWORD                    cbPath;        // Path size (excluding NULL)
    PSTR                    szTarget;    // Next directory to process
    DWORD                    cbTarget;    // Directory length
    DWORD                    cbMax;        // Max length for both path buffers
    DWORD                    dwFlags;    // Flags

    WIN32_FIND_DATA            wfd;        // File/Dir information                                        
    DWORD                    dwDepth;    // Crawl depth
    HANDLE                    rghFind[MAX_CRAWL_DEPTH];        
                                        // Find file handle array
    XONLINETASK_HANDLE        hTaskOnDir;    // OnDir subtask
    XONLINETASK_HANDLE        hTaskOnFile;// OnFile subtask

} XONLINETASK_DIRCRAWL, *PXONLINETASK_DIRCRAWL;

//
// Task context for copying a directory hierarchy
//
typedef struct
{
    XONLINETASK_DIRCRAWL    dircrawl;
    XONLINETASK_CONTEXT        xontaskOnDir;
    XONLINETASK_CONTEXT        xontaskOnFile;

    DWORD                    dwFilesCopied;
    ULARGE_INTEGER            uliBytesCopied;

} XONLINETASK_DIRCOPY, *PXONLINETASK_DIRCOPY;

//
// Define some internal flags. Each flag has a specific meaning
// so do not try to reuse bits
//
#define XONLINETASK_CDFLAG_CREATE_MODE    (0x80000000)
#define XONLINETASK_RDFLAG_POPDIR        (0x40000000)
#define XONLINETASK_EDFLAG_SUBTASK        (0x20000000)

//
// Define the user flags
//
#define XONLINETASK_CDFLAGS_USER        (0x0000ffff)

//
// Define dircopy flags
//
#define XONLINETASK_DCFLAG_NOREPLACE    (0x00000001)

// CONTENT -------------------------------------------------------------------------------

//
// Define the current CATREF protocol version that is supported
//
#define XONLINECONTENT_PROTOCOL_VERSION        ((DWORD)0x11112222)

//
// Content delivery
//

//
// The CFFILE structure has a WORD field for the file time which 
// we will hijack for our special flags. Xbox content will use thie
// field to indicate special options instead of the file time.
// The following bits are defined for the time field, and honored
// by the content installation API.
//

// This flag indicates that the file should be copied to the
// user partition rather than the title area
#define XONLINECONTENT_A_USER_DATA                (0x0001)

// This flag indicates that this file is a continuation of
// a file in the previous folder. The data in this file should
// be appended to the previous file. This file must be the first
// file in the folder.
#define XONLINECONTENT_A_CONTINUED_FROM_PREV    (0x0002)

// This flag indicates that this file will be continued into the
// next folder. The data in the next folder should be appended to 
// this file. This file must be the last file in the folder.
#define XONLINECONTENT_A_CONTINUED_INTO_NEXT    (0x0004)

//
// Define the size of the download buffer. This cannot be 
// less than XONLINECONTENT_LZX_OUTPUT_SIZE
//
#define XONLINECONTENT_DL_BUFFER_SIZE    (1024 * 64)

//
// Define the LZX decoder history window size, this should be no 
// less than 32k (ROM decompressor uses 128k)
//
#define XONLINECONTENT_LZX_WINDOW_SIZE    CHUNK_SIZE

//
// Define the output buffer for decompress. This must not be
// less than 32k
#define XONLINECONTENT_LZX_OUTPUT_SIZE    \
            ((CHUNK_SIZE) + XBOX_HD_SECTOR_SIZE)

//
// Define the base path for all content
//
#define XONLINECONTENT_BASE_PATH            "%c:\\$c\\%08x.%08x\\"
#define XONLINECONTENT_DVD_PATH                "d:\\$c\\%08x\\%08x.%08x\\"
#define XONLINECONTENT_OPEN_TEMPLATE        "%c:\\$c\\%08x.*"
#define XONLINECONTENT_OPEN_PATH            "%c:\\$c\\%s\\"

//
// Define the search paths for local content enumeration
//
#define XONLINECONTENT_HD_SEARCH_PATH        "t:\\$c\\*.*"
#define XONLINECONTENT_DVD_SEARCH_PATH       "d:\\%08x\\$c\\*.*"
#define XONLINECONTENT_HD_ROOT_PATH          "t:\\$c\\"
#define XONLINECONTENT_TITLE_CONTENT_F       "f:\\$c\\%08x.%08x\\"

//
// Define the set of hard paths for autoupdate
//
#define AUTOUPD_DASH_TARGET_PATH            "y:\\$%c\\"
#define AUTOUPD_TITLE_READ_PATH            "t:\\$u\\"
#define AUTOUPD_TITLE_TARGET_PATH            "f:\\$u\\"
#define AUTOUPD_TEMP_DIFF                    "z:\\$t\\"
#define AUTOUPD_TEMP_UPDATE                    "z:\\$u\\"
#define AUTOUPD_DASH_ROOT                    "y:\\"
#define AUTOUPD_DVD_TITLE_ROOT                "d:\\"

//
// Define a macro to get the DWORD represenation of a version
// and its compliement
//
#define MAKE_DWORD_VERSION(major, minor) \
            ((((DWORD)(major)) << 16) | (minor))
#define MAKE_COMPOSITE_VERSION(version, pmajor, pminor) \
            {*(pmajor) = (WORD)((version) >> 16); \
             *(pminor) = (WORD)((version) & 0xffff);}

//
// Define the different types of directories that we know about
//
typedef enum
{
    dirtypeTitleContent = 0,
    dirtypeUserContent,
    dirtypeDVDContent,
    dirtypeTitleUpdate,
    dirtypeDashUpdate0,
    dirtypeDashUpdate1,
    dirtypeTempDiff,
    dirtypeTempUpdate,
    dirtypeDashRoot,
    dirtypeDVDTitleRoot,
    dirtypeTitleUpdateOnF,
    dirtypeTitleContentOnF,
    dirtypeNone,
    dirtypeMax

} XONLINEDIR_TYPE;

//
// Define the referral request XRL
//
#define XONLINECONTENT_REFERRAL_XRL        "/xbos/ContentReferral.ashx"

//
// Define the offering enumeration request XRL
//
#define XONLINEOFFERING_ENUMERATE_XRL    "/xbos/OfferingEnumerate.ashx"

//
// Define the autoupdate referral request XRL
//
#define XONLINEAUTOUPD_REFERRAL_XRL		"/autoupd/AutoupdReferral.ashx"


//
// Define the maximum path size
//
#define XONLINECONTENT_MAX_PATH            (512)

//
// Define the phases for content verification
//
typedef enum
{
    verphaseReadDrm = 0,    // Read the DRM file
    verphaseWriteDrm,        // Write new DRM
    verphaseDone            // Done

} XONLINECONTENT_VERPHASE;

//
// Define the context for content verification
//
typedef struct
{
    XONLINETASK_CONTEXT        xontask;        // Master task context

    XONLINECONTENT_VERPHASE    verphase;        // Processing phase
    XONLINEDIR_TYPE            dirtype;        // Type of directory
    DWORD                    dwFileSize;        // File size
    DWORD                    dwBytesRead;    // Bytes read
    PBYTE                    pbHeader;        // First sector of data
    PBYTE                    pbBuffer;        // Buffer
    DWORD                    cbBuffer;        // Size of buffer
    DWORD                    dwFlags;        // Flags
    DGSTFILE_IDENTIFIER        dfi;

    PBYTE                    pbKeyPackage;    // Per-package key
    PBYTE                    pbKeyPerBox;    // Per-box key

    BYTE                    shactxPackage[XC_SERVICE_SHA_CONTEXT_SIZE];
                                            // SHA context for package
    BYTE                    shactxPerBox[XC_SERVICE_SHA_CONTEXT_SIZE];    
                                            // SHA context for per-box
    
    XONLINETASK_FILEIO        fileio;            // File I/O context

} XONLINETASK_CONTENT_VERIFY, *PXONLINETASK_CONTENT_VERIFY;

//
// Define the internal flags for content verification
//
#define XONLINECONTENT_VERIFY_FLAG_SIGN                    ((DWORD)0x00000001)
#define XONLINECONTENT_VERIFY_FLAG_USER_KEY                ((DWORD)0x00000002)
#define XONLINECONTENT_VERIFY_FLAG_ALLOW_SAME_VERSION    ((DWORD)0x00000004)

//
// Define the different processing phases
//
typedef enum
{
    // Pre-Connect phases
    dlphaseCatref = 0,        // Contact catref for referral
    dlphaseCheckCache,        // Check if a valid cache file exists
    dlphaseReadCache,        // Read header from disk
    dlphaseWipeTarget,        // Wipe the target before fresh install
    dlphaseCreateCache,        // Create cache file
    dlphaseSetupCache,        // Setup CFFILE cache
    dlphaseVerifyInstall,    // Verify if content already installed
    dlphasePreCustom,        // Optional custom pre work

    // Process data phases
    dlphaseRecvHeader,        // Receive header from socket
    dlphaseInstallFiles,    // Install files (may kick off read CFFILE)
    dlphaseCreateTarget,    // Create new target file
    dlphaseWriteTarget,        // Write to target file
    dlphaseCheckpoint,        // Write checkpoint
    dlphaseCreateDirectory,    // Create directory
    dlphaseVerifyCffiles,    // Verify CFFILE entries

    // Post-Download phases
    dlphaseSignDrm,            // Sign the per-box DRM
    dlphaseDeleteCache,        // Delete the cached header
    dlphasePostCustom,        // Optional custom post work

    // Final state
    dlphaseDone,            // Done

} XONLINECONTENT_DLPHASE;

//
// Refactored global function to verify content digests. This is
// for code that exists outside of CXo
//
HRESULT DigestVerifySynchronous(
			PSTR					szManifestFilePath,
			XONLINEDIR_TYPE			dirtype,
			PDGSTFILE_IDENTIFIER	pdfi,
			DWORD					dwFlags,
			PBYTE					pbAlternateKey
			);

//
// Define the master subtask context for content download
//
typedef struct
{
    XONLINETASK_CONTEXT            xontask;    // Main task context

    // Title for which the content is designated
    DWORD                        dwTitleId;    // Title ID

    // Content ID to install
    XONLINEOFFERING_ID            OfferingId;    // Content ID

	// Specifies the install target directory type
	XONLINEDIR_TYPE					dirtypeTarget;

    // Resource path to content (obtained from CATREF)
    CHAR                        szResourcePath[XONLINECONTENT_MAX_PATH];

    // Cryptographic keys
    BYTE                        rgbSymmetricKey[XONLINE_KEY_LENGTH];
    BYTE                        rgbPublicKey[XONLINECONTENT_MAX_PUBLIC_KEY_SIZE];

    // Status info
    XONLINECONTENT_DLPHASE        dlphase;    // Processing phase
    DWORD                        dwExpected;    // Expected bytes for this phase
    DWORD                        dwWritten;    // Bytes written so far
    DWORD                        dwTemp;        // Temp scratchpad
    DWORD                        dwFlags;    // phase-specific flags
    DWORD                       dwBitFlags; // Package bit flags
    DWORD                        dwPackageSize; // Wire package size
    DWORD                        dwInstallSize; // Install size
    DWORD                        dwLastXrl;    // Last XRL accessed

    // Download server info
    XONLINE_SERVICE_INFO        xsiDownload;// Download server info

    // CAB header cache
    XONLINECONTENT_HEADER        header;        // Header cache

    // CAB processing context information
    DWORD                        dwCurrentFolder;// Index of current CFFOLDER
    DWORD                        dwFolderOffset;    // Uncompressed offset in fldr
    CFFILE                        *pcffile;    // Current CFFILE 
    PSTR                        szFileName;    // Current file name
    DWORD                        cbFileName;    // Length of file name
    DWORD                        dwFileSize;    // Size of file
    CFDATA                        cfdata;        // Current CFDATA
    DWORD                        cbUncompData;// Uncompressed data available

    // RC4-SHA1 decryption context
    XONLINESYMMDEC_CONTEXT        symmdecData;// RC4 decryption context

    // Async File I/O context
    XONLINETASK_FILEIO            fileioData;    // Write target file

    // Async directory operations context
    XONLINETASK_DIROPS            dirops;        // Directory management

    // Async verification context
    XONLINETASK_CONTENT_VERIFY    verify;        // Verification of manifest

    // CFFILE cache
    XONLINECONTENT_CFFILECACHE    cffilecache;// CFFILE cache

    // CFFOLDER and HMAC
    CFFOLDER_HMAC                rgcffolderhmac[XONLINECONTENT_MAX_CFFOLDER];
                                            // CFFOLDER with HMAC
    // Receive buffer
    BYTE                        rgbBuffer[XONLINECONTENT_DL_BUFFER_SIZE];

    // Scratchpad for file names and directory names
    CHAR                        szPath[XONLINECONTENT_MAX_PATH];

    // LZX decompression context
    XONLINE_LZXDECODER_CONTEXT    lzx;        // Decompressor context

    // Decompression input and output buffers
    BYTE                        rgbDecompress[XONLINECONTENT_LZX_OUTPUT_SIZE];

    BYTE                        rgbLzxWindow[XONLINECONTENT_LZX_WINDOW_SIZE + (MAX_MATCH+4)];
                                            // Decompressor history window
                                            
    // Optional task handles for pre-install and post-install custom work
    XONLINETASK_HANDLE            hTaskPreCustom;
    XONLINETASK_HANDLE            hTaskPostCustom;
    XONLINECONTENT_DLPHASE        dlphaseNext;    // Next state after custom

#if DBG
    // Debug stuff
    XONLINECONTENT_DLPHASE        dlphaseError;// Last phase before error
#endif

} XONLINECONTENT_INSTALL, *PXONLINECONTENT_INSTALL;

//
// Define the flags
//
#define XONLINECONTENT_FLAG_READ_PENDING         ((DWORD)0x00000001)
#define XONLINECONTENT_FLAG_WRITE_PENDING        ((DWORD)0x00000002)
#define XONLINECONTENT_FLAG_OFFLINE_INSTALL      ((DWORD)0x08000000)
#define XONLINECONTENT_FLAG_NOT_INSTALLED        ((DWORD)0x10000000)
#define XONLINECONTENT_FLAG_CONTINUE_FILE        ((DWORD)0x20000000)
#define XONLINECONTENT_FLAG_RESUME               ((DWORD)0x40000000)
#define XONLINECONTENT_FLAG_DONE_FILES           ((DWORD)0x80000000)

//
// Define the full context for content download
//
typedef struct
{
    // Note: XRL_ASYNC must be the first member of this struct. The
    // reason is because if the title tries to cancel this operation,
    // we want the cancel call to go to the handler for XOnlineDownload
    // because it knows how to handle the cancel (and free the memory
    // at the right location).
    
    XRL_ASYNC                xrlasync;        // XRL download context

    XRL_ASYNC_EXTENDED        xrlasyncCatref; // Catref context

    XONLINECONTENT_INSTALL    install;        // Content install context

} XONLINETASK_CONTENT_DOWNLOAD, *PXONLINETASK_CONTENT_DOWNLOAD;

//
// Define the phases for content removal
//
typedef enum
{
    rmphaseRemoveDrm = 0,        // Remove the DRM file
    rmphaseRemoveTitleData,        // Remove all title content data
    rmphaseRemoveUserData,        // Remove all user content data
    rmphaseDone                    // Done

} XONLINECONTENT_RMPHASE;

//
// Define the context for content removal
//
typedef struct
{
    XONLINETASK_CONTEXT        xontask;    // Master task context
    XONLINECONTENT_RMPHASE    rmphase;    // Current phase
    DWORD                    dwFlags;    // Flags
    DWORD                    dwTitleId;    // Title ID
    XONLINEOFFERING_ID        OfferingId;    // Content ID

    XONLINETASK_DIROPS        dirops;        // Directory operations context

} XONLINETASK_CONTENT_REMOVE, *PXONLINETASK_CONTENT_REMOVE;

// =============================================================
// Autoupdate structures
//

//
// Structure representing an interleave entry
//
typedef struct
{
    DWORD    dwOldOffset;    // Starting offset in old file
    DWORD    dwOldLength;    // Old Length
    DWORD    dwNewLength;    // New Length

} AUTOUPD_INTERLEAVE_ENTRY, *PAUTOUPD_INTERLEAVE_ENTRY;

//
// Structure representing a patch file header
//
typedef struct
{
    DWORD    dwNewFileSize;            // Size of the new file
    DWORD    dwOldFileSize;            // Size of the old (source) file
    DWORD    dwWindowSizeBits;        // Dictionary window size (2^bits)
    DWORD    dwPatchDataSize;        // Remaining size of patch data    
    DWORD    dwDataSize;                // Size of patch data read
    DWORD    dwCurrent;                // Current offset into patch data window
    DWORD    dwTargetWritten;        // Bytes written for current interleave
    DWORD    dwInterleaveEntries;    // Interleave map entries
    DWORD    dwInterleaveCurrent;    // Current interleave map entry

    // There are actually dwInterleaveEntries of them
    AUTOUPD_INTERLEAVE_ENTRY    rgInterleaveInfo[1];

} AUTOUPD_PATCH_FILE_INFO, *PAUTOUPD_PATCH_FILE_INFO;

//
// Progress implementation structure
//
typedef struct
{
    DWORD            dwFilesDone;
    DWORD            dwFilesTotal;
    ULARGE_INTEGER    uliBytesProcessed;
    ULARGE_INTEGER    uliBytesTotal;
    ULARGE_INTEGER    uliActualBytesRequired;
    
} AUTOUPD_PROGRESS_CONTEXT, *PAUTOUPD_PROGRESS_CONTEXT;

#define AUTOUPD_BUMP_PROGRESS(pprogress, bytes)    \
    ((pprogress)->uliBytesProcessed.QuadPart += (bytes))

//
// Define the dash title ID
//
#define AUTOUPD_DASH_TITLE_ID            ((DWORD)0xfffe0000)

//
// Define a structure that holds the dash configuration information
//
typedef struct
{
    DWORD    dwActiveDirectory;        // Active boot directory

} AUTOUPD_DASH_CONFIG, *PAUTOUPD_DASH_CONFIG;

//
// Define the task context for removing old dash files
//
typedef struct
{
	XONLINETASK_CONTEXT	xontask;
	DWORD				iCurrent;

} XONLINETASK_DEL_OLD_DASH, *PXONLINETASK_DEL_OLD_DASH;

//
// Function to read the current dash boot directory 
// from the config file
//
HRESULT XoUpdateReadDashConfig(
            PAUTOUPD_DASH_CONFIG    pConfig,
            BOOL					fFailIfNotFound
            );

//
// Function to write the current dash boot directory 
// to the config file
//
HRESULT XoUpdateWriteDashConfig(
			PAUTOUPD_DASH_CONFIG	pConfig
			);

//
// Function to replace the original dash XBE with the switcher
//
HRESULT XoUpdateInstallSwitcher(
			XONLINEDIR_TYPE	dirtype
			);
			
//
// This function mounts the dash partition as Y: drive. 
//
HRESULT XoUpdateMountDashPartition();

#ifdef XONLINE_FEATURE_XBOX

//
// Function to mount a title's TDATA to the specified drive
//
HRESULT XoUpdateMountTitleTDataToPrivateDrive(
			DWORD	dwTitleId
			);

//
// Function to unmount a drive previously mounted with
// XoMountTitleTdataToDriveLetter. Since this does not do any
// routine cleanup, don't call this function to unmpa any drives
// that is not mapped with XoMountTitleTdataToDriveLetter.
// 
HRESULT XoUpdateUnmountPrivateDrive();

DWORD RebootToUpdaterWhilePreservingDDrive(
		    LPCSTR lpTitlePath,
		    PLAUNCH_UPDATE_INFO plui
		    );

#else

#define XoUpdateMountTitleTDataToPrivateDrive(dwTitleId)	(S_OK)
#define XoUpdateUnmountPrivateDrive()						(S_OK)

#endif

//
// Helper function to get the unmunged title key for the given title ID
//
HRESULT XoUpdateGetRawTitleKey(
            DWORD    dwTitleId,
            PBYTE    pbTitleKey,
            DWORD    *pcbTitleKey
            );

// =============================================================
// Autoupdate and offering wire structures 
//

//
// Common header for wire structures
//
typedef struct
{
    DWORD       cbSize;
    DWORD       dwReserved;

} XONLINE_WIRE_HEADER, *PXONLINE_WIRE_HEADER;

//
// Wire structure for content referral
//
typedef struct
{
    XONLINE_WIRE_HEADER         Header;         // Wire struct header
    ULONGLONG                    MachineId;        // Machine ID
    ULONGLONG                   Puid[XONLINE_MAX_LOGON_USERS];  
                                                // PUIDs of logged on users
    DWORD                       dwTitleId;      // Title ID
    XONLINEOFFERING_ID          OfferingId;     // Offering ID
    DWORD                       dwRating;       // Rating on Xbox
} XONLINECONTENT_REFERRAL_REQ, *PXONLINECONTENT_REFERRAL_REQ;    

//
// Wire structure for autoupdate referral
//
typedef struct
{
    XONLINE_WIRE_HEADER         Header;         // Wire struct header
    ULONGLONG					qwMachineId;	// Machine account
    DWORD                       dwTitleId;      // Title ID 
    DWORD						dwDashVersion;	// Old version of title (dash only)
} XONLINEUPDATE_REFERRAL_REQ, *PXONLINEUPDATE_REFERRAL_REQ;	

//
// Wire structure for offering enumeration
//
typedef struct
{
    XONLINE_WIRE_HEADER         Header;         // Wire struct header
    ULONGLONG                   Puid;           // PUID of user in context
    DWORD                       dwTitleId;      // Title ID
    DWORD                       cbClientBuffer; // Size of client buffer for responses
    DWORD                       dwRating;       // Rating on Xbox
    XONLINEOFFERING_ID          ResumePosition; // Last offering ID received
    XONLINEOFFERING_ENUM_PARAMS Params;         // Caller enum params
} XONLINEOFFERING_ENUM_REQ, *PXONLINEOFFERING_ENUM_REQ;

//
// Wire structure for offering enumeration header
//
typedef struct
{
    XONLINE_WIRE_HEADER         Header;     // Wire struct header
    WORD                        cRecords;   // Number of records returned
    WORD                        fFlags;     // Enumeration response flags
} XONLINEOFFERING_ENUM_RESP_HEADER, *PXONLINEOFFERING_ENUM_RESP_HEADER;

//
// Supported enumeration response flags
//
#define XONLINEOFFERING_RESP_FLAG_MORE_RESULTS      ((WORD)0x0001)
#define XONLINEOFFERING_RESP_FLAG_DONT_CACHE        ((WORD)0x0002)

//
// Wire structure for offering enumeration info records
//
typedef struct
{
    DWORD                   cbRecordSize;   // Size of THIS record (including blob)
    WORD                    iRecordIndex;   // Index of this record (wrt. entire set)
    WORD                    wPadding;       // Alignment padding
    XONLINEOFFERING_INFO    OfferingInfo;   // Offering information
} XONLINEOFFERING_ENUM_RESP_RECORD, *PXONLINEOFFERING_ENUM_RESP_RECORD;

#define    XONLINEREFERRAL_SYM_KEY_SIZE             XONLINE_KEY_LENGTH
#define    XONLINEREFERRAL_PUB_KEY_SIZE             284 
#define    XONLINEREFERRAL_MAX_XRL_SIZE             MAX_PATH

//
// Structure representing a referral location
//
typedef struct
{
    WORD    Rank;                                   // Rank of location
    WORD    cbXrl;                                  // Length of XRL
    CHAR    szXrl[XONLINEREFERRAL_MAX_XRL_SIZE];    // Unterminated XRL
} XONLINEREFERRAL_LOCATION, *PXONLINEREFERRAL_LOCATION;

//
// Wire structure for a referral response
//
typedef struct
{
    XONLINE_WIRE_HEADER         Header;     // Wire struct header
    WORD                        fFlags;     // Referral flags
    WORD                        cLocations; // Number of locations returned
    DWORD                       dwPackageSize; // Wire size of package
    DWORD                       dwInstallSize; // Accurate install size
    DWORD                       dwBitFlags; // Package flags
    BYTE                        rgbSymKey[XONLINEREFERRAL_SYM_KEY_SIZE];
    BYTE                        rgbPubKey[XONLINEREFERRAL_PUB_KEY_SIZE];

    // This is followed by cLocations XONLINEREFERRAL_LOCATION records. The
    // strings will be marshalled using variable lenghts to conserve bandwidth,
    // and each record will be packed and thus may not be on a DWORD-aligned 
    // boundary.
    
} XONLINEREFERRAL_RESP, *PXONLINEREFERRAL_RESP;

//
// Expose a constant string for Content-type: xon/xxxxxxxx
//
#define XONLINE_MAX_CONTENT_TYPE_SIZE	32

//
// Define the states for online offering enumeration
//
typedef enum
{
    enumsrvUpload = 0,    // XRL upload phase
    enumsrvResults,        // Results available
    enumsrvContinue,    // Get more results
    enumsrvDone            // Final phase, done

} XONLINEOFFERING_ENUM_SERVER_STATE;

//
// Define a context for online offering enumeration
//
typedef struct
{
    XONLINETASK_CONTEXT            xontaskEnum;    // Enum task context
    XRL_ASYNC_EXTENDED            xrlasyncext;    // Extended Upload context
    XONLINETASK_CONTEXT            xontaskPostUpload;// Post-upload subtask

    XONLINEOFFERING_ENUM_REQ    enumreq;        // Enumerate request context

    XONLINEOFFERING_ID            OfferingIdLast;    // Last offering ID received
    XONLINEOFFERING_ENUM_SERVER_STATE    State;    // Current state

} XONLINEOFFERING_ENUM_SERVER, *PXONLINEOFFERING_ENUM_SERVER;

//
// Define a context for Local enumeration
//
typedef struct
{
    XONLINETASK_DIROPS    dirops;            // dirops context
    XONLINETASK_CONTEXT    xontask;        // hTaskOnData context
    XONLINETASK_CONTEXT    xontaskDone;    // hTaskOnDone context

    PBYTE                pbBuffer;        // Supplied buffer
    DWORD                cbBuffer;        // Buffer size
    DWORD                dwBitFilter;    // Filtering flags

    CHAR                szPath[XONLINECONTENT_MAX_PATH];
    
} XONLINEOFFERING_ENUM_LOCAL, *PXONLINEOFFERING_ENUM_LOCAL;

//
// Define a generic content enumeration task context
//
typedef struct
{
    union 
    {
        XONLINEOFFERING_ENUM_SERVER    server;        // Server enum context
        XONLINEOFFERING_ENUM_LOCAL     local;         // Local enum context
        
    }                            enumdata;    // enum context
    XONLINEOFFERING_ENUM_DEVICE    edDevice;    // Device

    BOOL                        fPartial;    // Indicates partial results
    DWORD                        dwResults;    // Results received & parsed
    DWORD                        dwMaxResults;// Max results desired

} XONLINETASK_OFFERING_ENUM, *PXONLINETASK_OFFERING_ENUM;

//
// A particular characteristic of Xbox asynchronous WriteFile calls is
// that the call is asynchronous so long as the file size is not exceeded.
// To keep the writes asynchronous, SetEndOfFile is used to grow the file
// in chunks. The following is the increment size used to grow files.
//
// BUGBUG: Need to find an optimal value
//
#define XONLINECONTENT_INCREMENTAL_GROW_FILE_SIZE    ((XBOX_HD_SECTOR_SIZE) << 12)

//
// Define the internal timeout values that we will use for different
// operations
//
#define XONLINECONTENT_REFERRAL_TIMEOUT				((DWORD)(10000))
#define XONLINECONTENT_INSTALL_TIMEOUT				((DWORD)(30000))
#define XONLINEOFFERING_ENUMERATE_TIMEOUT			((DWORD)(10000))
#define XONLINEAUTOUPD_REFERRAL_TIMEOUT				((DWORD)(10000))

//
// Define a context structure for title enumeration
//
typedef struct
{
    XONLINETASK_DIROPS    dirops;            // dirops context
    
    XONLINETASK_CONTEXT    xontask;        // hTaskOnData context

    PDWORD                rgdwTitleId;    // Title ID array
    DWORD                dwTitleId;        // Count of title IDs
    DWORD                dwMaxResults;    // Max results desired

} XONLINECONTENT_ENUM_TITLES, *PXONLINECONTENT_ENUM_TITLES;

//
// Trace tags used by Online Auth APIs
//
ExternTag(AuthVerbose);
ExternTag(AuthWarn);

#ifdef XONLINE_FEATURE_INSECURE

//
// InitOverrideInfo allows you to load overriding IP/Port and KDC info
// from an ini file so that we can more easily test the online services.
// This function can only be used in the insecure build.
//
// This function reads the file E:\xonline.ini on devkits and processes
// each line one by one and stores retults in global variables
// g_pszMACSKDC, g_pszPassportKDC, g_pszXboxKDC, and g_rgServiceInfoOverride.
// The format for each line in the configuration file is one of following:
//
// MKDC:a.b.c.d<CR><LF>
// PKDC:a.b.c.d<CR><LF>
// XKDC:a.b.c.d<CR><LF>
// MKDC<CR><LF>
// PKDC<CR><LF>
// XKDC<CR><LF>
// SX:a.b.c.d:Port<CR><LF>
//
// The ?KDC lines specify the location of the MACS/Passport/Xbox KDCs,
// while SX line specify the IP/Port of service X.
//
// The empty ?KDC lines instruct the client code to
// not perform any operations related to that KDC.
//
// No whitespaces or blank lines are allowed in the file. The
// size of the file must remain less than or equal to 4096 bytes.
//

#endif

#define PASSPORT_AS_DNS     "passport.as.xbox.com"
#define PASSPORT_WEB_DNS    "passport.web.xbox.com"
#define PASSPORT_TGS_DNS    "passport.tgs.xbox.com"
#define XBOX_KDC_DNS        "kdc.xbox.com"
#define MACS_KDC_DNS        "macs.xbox.com"

struct XONLINE_DNS_CACHE_ENTRY
{
    char* name;

    #define DNS_LOOKUP_IN_PROGRESS  1
    #define DNS_LOOKUP_COMPLETE     2
    #define DNS_LOOKUP_ERROR        3
    DWORD dwState;

    XNDNS address;
};

#define XONLINE_NUM_DNS_CACHE_ENTRYS 5

//----------------------------------------------------------------------------
//
// Local cache
//
//----------------------------------------------------------------------------

typedef enum
{
    XONLC_TYPE_RECENT_LOGON_TIME = 0,
    XONLC_TYPE_COMBINED_USER_TICKETS = 1,
    XONLC_TYPE_SERVICE_TICKETS = 2,
    XONLC_TYPE_FRIEND_LIST = 3,
    XONLC_TYPE_LOCKOUT_LIST = 4,
    XONLC_TYPE_LICENSING = 5,
    XONLC_TYPE_BILLING = 6,
    XONLC_TYPE_TITLEDATA = 7,
    XONLC_TYPE_GAMEINVITE = 8,
    XONLC_TYPE_TEST1 = 9,
    XONLC_TYPE_TEST2 = 10,
    XONLC_MAX_CACHE_TYPES = 11
} XONLC_TYPE;

typedef struct
{
    BOOL                                 bValidDataInCache;
    BOOL                                 bCallRetrieveNext;
    LPBYTE                               pbIndexData;   
    DWORD                                dwRecordBufferSize;
    LPBYTE                               pbRecordBuffer;    
} XONLC_CONTEXT, *PXONLC_CONTEXT;

typedef BOOL (CXo::*PFNXONLC_COMPARE_HANDLER)(
    IN const BYTE                        *pbTarget,
    IN const BYTE                        *pbCandidate
    );

/////////////////////////////////////////////////////////////////////////////

//----------------------------------------------------------------------------
//
// Message Client
//
//----------------------------------------------------------------------------
typedef enum
{

    XONMSGCLIENT_TYPE_TITLEID = 0,
    XONMSGCLIENT_TYPE_ERRMSG = 1,
    XONMSGCLIENT_TYPE_MAXTYPES

}XONMSGCLIENT_TYPES;

#pragma pack(push, 1)
typedef struct
{
    WORD       wRecordsCount;
}XONMSGCLIENT_HEADER, *PXONMSGCLIENT_HEADER;

typedef struct 
{
    WORD        wType;
    DWORD       dwID;
    WORD        wLocale;

}XONMSGCLIENT_REQUEST_RECORD, *PXONMSGCLIENT_REQUEST_RECORD;

#pragma pack(pop)

typedef struct 
{
    DWORD       cbBuffer;
    PBYTE       pbBuffer;

}XONMSGCLIENT_RESPONSE_RECORD, *PXONMSGCLIENT_RESPONSE_RECORD;


typedef struct
{
    XONMSGCLIENT_HEADER              Header;
    PXONMSGCLIENT_REQUEST_RECORD     pReqRecords;
}XONMSGCLIENT_REQUEST, *PXONMSGCLIENT_REQUEST;

typedef struct 
{
    DWORD                            cbBuffer;
    PBYTE                            pbBuffer;
}XONMSGCLIENT_RESPONSE, *PXONMSGCLIENT_RESPONSE;

typedef struct 
{
    XONLINETASK_CONTEXT     xonTask;            // Standard Task Pump context info
    XRL_ASYNC_EXTENDED      xonTaskUpload;      // Subsumed context for upload

    HRESULT                 hrFinal;            // Final HRESULT

}XONLINECTXT_MSGCLIENT, *PXONLINECTXT_MSGCLIENT;

typedef PXONLINECTXT_MSGCLIENT XONLINETASK_MSGCLIENT;
typedef PXONLINECTXT_MSGCLIENT *PXONLINETASK_MSGCLIENT;

// Title data API

#define     XONLINE_TITLEDATA_SIZE         32

typedef struct 
{
    char        name[XONLINE_TITLEDATA_SIZE];
}XONLINE_TITLEDATA, *PXONLINE_TITLEDATA;

enum XONTITLECACHE_STATE;

typedef struct
{
    XONLINETASK_CONTEXT     xonTask;            // Standard Task Pump context info
    XONLINECTXT_MSGCLIENT   xonTaskMsgClient;   // Subsumed context for msg client

    XONLINETASK_HANDLE      hTaskLocalCache;    // Task handle for local caching
    HANDLE                  hCache;             // Handle to the local cache

    HRESULT                 hrFinal;            // Final HRESULT

    DWORD                   dwTitleID;          // Info to be passed between pump sessions
    PXONLINE_TITLEDATA      pTitleData;         // Info to be passed between pump sessions

    XONLC_CONTEXT           context;

    PXONMSGCLIENT_REQUEST   pMsgServerReq;      // The request structure
    PBYTE                   pbMsgServerResp;    // Buffer for the response
    DWORD                   cbMsgServerResp;    // Size of the buffer for the response

    XONLINETASK_HANDLE      hSubtask;           // Unified way to pump subtasks
    XONTITLECACHE_STATE     state;              // State of the task


}XONLINECTXT_TITLECACHE, *PXONLINECTXT_TITLECACHE; 

typedef PXONLINECTXT_TITLECACHE XONLINETASK_TITLECACHE;
typedef PXONLINECTXT_TITLECACHE *PXONLINETASK_TITLECACHE;

//////////////////////////////////////////////////////////////////////////////

// ---------------------------------------------------------------------------------------
// CXo
// ---------------------------------------------------------------------------------------

struct  XONLINETASK_AUTOUPD_DVD;
typedef XONLINETASK_AUTOUPD_DVD * PXONLINETASK_AUTOUPD_DVD;
struct  XONLINETASK_AUTOUPD_ONLINE;
typedef XONLINETASK_AUTOUPD_ONLINE * PXONLINETASK_AUTOUPD_ONLINE;
struct  XONLINEAUTOUPD_ONLINE;
typedef XONLINEAUTOUPD_ONLINE * PXONLINEAUTOUPD_ONLINE;
struct  XONLINETASK_DNS_LOOKUP;
typedef XONLINETASK_DNS_LOOKUP * PXONLINETASK_DNS_LOOKUP;
struct  XONLINETASK_GET_SINGLE_TICKET;
typedef XONLINETASK_GET_SINGLE_TICKET * PXONLINETASK_GET_SINGLE_TICKET;
struct  XONLINETASK_GET_MACHINE_ACCOUNT;
typedef XONLINETASK_GET_MACHINE_ACCOUNT * PXONLINETASK_GET_MACHINE_ACCOUNT;
struct  XONLINETASK_GET_COMBINED_TICKET;
typedef XONLINETASK_GET_COMBINED_TICKET  * PXONLINETASK_GET_COMBINED_TICKET;
struct  XONLINETASK_GET_SERVICE_TICKET;
typedef XONLINETASK_GET_SERVICE_TICKET  * PXONLINETASK_GET_SERVICE_TICKET;
struct  XONLINETASK_LOGON;
typedef XONLINETASK_LOGON * PXONLINETASK_LOGON;
struct  XMATCH_EXTENDED_HANDLE;
typedef XMATCH_EXTENDED_HANDLE * PXMATCH_EXTENDED_HANDLE;
enum    XMATCH_TYPE;
enum    SERVER_TYPE;
enum    XPRESENCE_REQUESTTYPE;
struct  XPRESENCE_EXTENDED_HANDLE;
typedef XPRESENCE_EXTENDED_HANDLE * PXPRESENCE_EXTENDED_HANDLE;
struct  XPRESENCE_CACHEEXTENDED_HANDLE;
typedef XPRESENCE_CACHEEXTENDED_HANDLE * PXPRESENCE_CACHEEXTENDED_HANDLE;
enum    XPRESENCE_CACHESTATE;
struct  XPRESENCE_USER;
typedef XPRESENCE_USER * PXPRESENCE_USER;
struct  XO_OFFERING_VERIFY_LICENSE_TASK;
struct  XO_OFFERING_LICENSE;
class   CLocalCache;
typedef CLocalCache *XONLC_CACHE_HANDLE;
typedef CLocalCache **PXONLC_CACHE_HANDLE;
typedef HRESULT (CXo::*PFNDIRCRAWL_HANDLER)(PXONLINETASK_DIRCRAWL pdircrawl);
typedef HRESULT (CXo::*PFNAUTOUPD_DVD_HANDLER)(PXONLINETASK_AUTOUPD_DVD    pautoupd);
typedef HRESULT (CXo::*PFNCONTDL_HANDLER)(PXONLINETASK_CONTENT_DOWNLOAD pcontdl);
typedef HRESULT (CXo::*PFNAUTOUPD_ONLINE_HANDLER)(PXONLINEAUTOUPD_ONLINE pautoupd);
struct  XPRESENCE_GAMEINVITE_RECORD;
typedef XPRESENCE_GAMEINVITE_RECORD * PXPRESENCE_GAMEINVITE_RECORD;

HRESULT BuildTargetDirectory(DWORD dwTitleId, XONLINEOFFERING_ID OfferingId, DWORD dwBitFlags, XONLINEDIR_TYPE dirtype, DWORD * pcbTargetDirectory, CHAR * szTargetDirectory);
HRESULT BuildTargetPath(DWORD dwTitleId, XONLINEOFFERING_ID OfferingId, DWORD dwBitFlags, CHAR * szPostfix, XONLINEDIR_TYPE dirtype, DWORD * pcbTargetPath, CHAR * szTargetPath);
HRESULT BuildExistingContentPath(DWORD dwTitleId, XONLINEOFFERING_ID OfferingId, CHAR *szPostfix, XONLINEDIR_TYPE dirtype, DWORD *pcbTargetPath, CHAR *szTargetPath);
HRESULT ParsePatchHeader(PBYTE pbData, DWORD *pcbData, PBYTE pbParsedData, DWORD *pcbParsedData);


//
// Structure to store extra context about each logged in user, as it pertains to friends and enumeration.
//
struct XPRESENCE_USER
{
    ULONGLONG qwUserID;                                 // UserID
    CHAR szUserName[XONLINE_USERNAME_SIZE];             // User name
    DWORD dwSeqNum;                                     // Sequence number of last sent friend SYNC request
    BOOL fFriendListSynced;                             // Flag indicating whether the friend list for this user is in sync or not
    WORD cNumFriends;                                   // Number of friends in this user's friend list
    DWORD dwFriendListVersion;                          // Version of current friend list
    XONLINE_FRIEND FriendList[MAX_FRIENDS];             // Friend list
    WORD cNumLockoutUsers;                              // Number of users in this lockout list
    DWORD dwLockoutListVersion;                         // Version of current lockout list
    XONLINE_LOCKOUTUSER LockoutList[MAX_LOCKOUTUSERS];  // Lockout list
    WORD cbUserData;                                    // Size of userdata
    PBYTE pbUserData;                                   // Userdata
};

class CXo : public CXoBase
{
    friend class CLocalCache;
    friend class CCacheTask;
    friend class CXoBase;
    friend class CXoTest;

public:

    // XOnline API -----------------------------------------------------------------------

    #undef  XONAPI
    #define XONAPI(ret, fname, arglist, paramlist) ret fname arglist;
    #undef  XONAPI_
    #define XONAPI_(ret, fname, arglist, paramlist)

    XONLINEAPILIST()

    // Public accessors ------------------------------------------------------------------

    INLINE DWORD        GetTitleId()            { return(m_dwTitleId); }
    INLINE DWORD        GetTitleVersion()       { return(m_dwTitleVersion); }
    INLINE DWORD        GetTitleGameRegion()    { return(m_dwTitleGameRegion); }
    INLINE ASN1module_t GetASN1Module()         { return(&m_KRB5_Module); }

    INLINE DWORD        AddRef()                { return(++m_cRefs); }
    INLINE DWORD        Release()               { return(--m_cRefs); }

    HRESULT             Init(PXONLINE_STARTUP_PARAMS pxosp);
    void                Term();

    BOOL                SetMachineAccount(PXONLINEP_USER pUser);

protected:

    // Memory Management -----------------------------------------------------------------

    INLINE void *   SysAlloc(size_t cb, ULONG tag);
    INLINE void *   SysAllocZ(size_t cb, ULONG tag);
    INLINE void     SysFree(void * pv);

    void *          PoolAlloc(size_t cb, ULONG tag);
    void *          PoolAllocZ(size_t cb, ULONG tag);
    void            PoolFree(void * pv);

    // autoupd.cpp -----------------------------------------------------------------------

#ifdef XONLINE_FEATURE_XBOX

    HRESULT         UpdateDVDCountFilesContinue(XONLINETASK_HANDLE hTask);
    HRESULT         dvdupdCountFilesHandler(PXONLINETASK_AUTOUPD_DVD pautoupd);
    HRESULT         dvdupdWipeDestinationHandler(PXONLINETASK_AUTOUPD_DVD pautoupd);
    HRESULT         dvdupdCreateTargetHandler(PXONLINETASK_AUTOUPD_DVD pautoupd);
    HRESULT         dvdupdCopyFilesHandler(PXONLINETASK_AUTOUPD_DVD pautoupd);
    HRESULT         dvdupdWriteConfigHandler(PXONLINETASK_AUTOUPD_DVD pautoupd);
    HRESULT         dvdupdCleanupHandler(PXONLINETASK_AUTOUPD_DVD pautoupd);
    HRESULT         UpdateFromDVDContinue(XONLINETASK_HANDLE hTask);
    VOID            UpdateFromDVDClose(XONLINETASK_HANDLE hTask);
    HRESULT         UpdateFromDVD(DWORD dwTitleID, WORD wVersionHi, WORD wVersionLo, DWORD dwFlags, HANDLE hWorkEvent, XONLINETASK_HANDLE * phTask);
    HRESULT         UpdateDashFromDVD(WORD wVersionHi, WORD wVersionLo, DWORD dwDashId, HANDLE hWorkEvent, XONLINETASK_HANDLE * phTask);
    HRESULT         UpdateTitleFromDVD(DWORD dwTitleID, WORD wVersionHi, WORD wVersionLo, HANDLE hWorkEvent, XONLINETASK_HANDLE * phTask);
    HRESULT         UpdateFromDVDGetProgress(XONLINETASK_HANDLE hTask, DWORD * pdwPercentDone, ULARGE_INTEGER * puliNumerator, ULARGE_INTEGER * puliDenominator);
    HRESULT         UpdateCheckAndBumpRetryCount(DWORD dwUpdateVersion);
    VOID            UpdateResetRetryCount();
    VOID            UpdateDashIfNecessary();

#endif

    // diffpatch.cpp -----------------------------------------------------------------------

#ifdef XONLINE_FEATURE_XBOX

    HRESULT         UpdateOnlineCountFilesContinue(XONLINETASK_HANDLE hTask);
    HRESULT         xoupdPreInitializeHandler(PXONLINEAUTOUPD_ONLINE pautoupd);
    HRESULT         xoupdCountFilesHandler(PXONLINEAUTOUPD_ONLINE pautoupd);
    HRESULT         xoupdFormatTempHandler(PXONLINEAUTOUPD_ONLINE pautoupd);
    HRESULT         xoupdDoneDVDPreInitHandler(PXONLINEAUTOUPD_ONLINE pautoupd);
    HRESULT         xoupdPostInitializeHandler(PXONLINEAUTOUPD_ONLINE pautoupd);
    HRESULT         xoupdVerifyPatchDigestHandler(PXONLINEAUTOUPD_ONLINE pautoupd);
    HRESULT         xoupdVerifyTargetDigestHandler(PXONLINEAUTOUPD_ONLINE pautoupd);
    HRESULT         xoupdWipeTargetHandler(PXONLINEAUTOUPD_ONLINE pautoupd);
    HRESULT         xoupdOpenPatchHandler(PXONLINEAUTOUPD_ONLINE pautoupd);
    HRESULT         xoupdOpenSourceHandler(PXONLINEAUTOUPD_ONLINE pautoupd);
    HRESULT         xoupdCreateTargetHandler(PXONLINEAUTOUPD_ONLINE pautoupd);
    HRESULT         xoupdCreateDirectoryHandler(PXONLINEAUTOUPD_ONLINE pautoupd);
    HRESULT         xoupdReadSourceHandler(PXONLINEAUTOUPD_ONLINE pautoupd);
    HRESULT         xoupdReadPatchHandler(PXONLINEAUTOUPD_ONLINE pautoupd);
    HRESULT         xoupdDecodeDataHandler(PXONLINEAUTOUPD_ONLINE pautoupd);
    HRESULT         xoupdWriteTargetHandler(PXONLINEAUTOUPD_ONLINE pautoupd);
    HRESULT         xoupdCloseFilesHandler(PXONLINEAUTOUPD_ONLINE pautoupd);
    HRESULT         xoupdCopyDigestHandler(PXONLINEAUTOUPD_ONLINE pautoupd);
    HRESULT         xoupdCopyOtherFilesHandler(PXONLINEAUTOUPD_ONLINE pautoupd);
    HRESULT         xoupdSignDigestHandler(PXONLINEAUTOUPD_ONLINE pautoupd);
    HRESULT         xoupdWriteConfigHandler(PXONLINEAUTOUPD_ONLINE pautoupd);
	HRESULT         xoupdCleanupTempHandler(PXONLINEAUTOUPD_ONLINE pautoupd);
    HRESULT         xoupdCleanupOfflineDashFilesHandler(PXONLINEAUTOUPD_ONLINE pautoupd);
    HRESULT         xoupdContinue(XONLINETASK_HANDLE hTask);
    VOID            AutoupdateCleanup(PVOID pvxrlasync);
    HRESULT         AutoupdateInitializeContext(PXONLINETASK_AUTOUPD_ONLINE pxoupd, DWORD dwTitleId, DWORD dwTitleOldVersion, BOOL fOnline, PBYTE pbTitleKey, HANDLE hWorkEvent);
    HRESULT         AutoupdateOnline(DWORD dwTitleId, DWORD dwTitleOldVersion, PBYTE pbTitleKey, HANDLE hWorkEvent, PXONLINETASK_HANDLE pHandle);
    HRESULT         AutoupdateFromDVD(PSTR szUpdatePath, DWORD dwTitleId, DWORD dwTitleOldVersion, PBYTE pbTitleKey, PBYTE pbSymmetricKey, DWORD cbSymmetricKey, PBYTE pbPublicKey, DWORD cbPublicKey, HANDLE hWorkEvent, PXONLINETASK_HANDLE phTask);
    HRESULT         AutoupdateGetProgress(XONLINETASK_HANDLE hTask, DWORD *pdwPercentDone, ULONGLONG *pqwNumerator, ULONGLONG *pqwDenominator);

#endif

    // kerberos.cpp ----------------------------------------------------------------------

    NTSTATUS        XkerbBuildAsRequest(BOOL fMachineAccount, PXONLINEP_USER User, PUCHAR pbRequestMessage, PULONG pdwRequestMessageLength, PXKERB_TGT_CONTEXT pTGTContext);
    NTSTATUS        XkerbVerifyAsReply(PUCHAR pbReplyMessage, ULONG dwReplyMessageLength, PXKERB_TGT_CONTEXT pTGTContext);
    NTSTATUS        XkerbBuildTgsRequest(PXKERB_TGT_CONTEXT pCombinedTGTContext, PUCHAR pbRequestMessage, PULONG pdwRequestMessageLength, PXKERB_SERVICE_CONTEXT pXKerbServiceContext);
    NTSTATUS        XkerbVerifyTgsReply(PXONLINEP_USER pUsers, PXKERB_TGT_CONTEXT pCombinedTGTContext, PUCHAR pbReplyMessage, ULONG dwReplyMessageLength, PXKERB_SERVICE_CONTEXT pXKerbServiceContext);
    NTSTATUS        XkerbBuildApRequest(PXKERB_SERVICE_CONTEXT pServiceContext, LARGE_INTEGER * pliTime, BYTE * pbSha, UINT cbSha, PUCHAR pbRequestMessage, UINT * pdwRequestMessageLength);
    NTSTATUS        XkerbVerifyApReply(PXKERB_SERVICE_CONTEXT pServiceContext, LARGE_INTEGER * pliTime, BYTE * pbSha, UINT cbSha, PUCHAR pbReplyMessage, UINT dwReplyMessageLength);
    XOKERBINFO *    XkerbGetInfo(DWORD dwServiceId);
    NTSTATUS        XkerbBuildApReq(DWORD dwServiceId, LARGE_INTEGER * pliTime, BYTE * pbSha, UINT cbSha, BYTE * pbApReq, UINT * pcbApReq);
    NTSTATUS        XkerbCrackApRep(DWORD dwServiceId, LARGE_INTEGER * pliTime, BYTE * pbSha, UINT cbSha, BYTE * pbApRep, UINT cbApRep);
    void            XkerbGetAuthData(XKERB_AD_XBOX * pAuthData);

    // baseio.cpp ------------------------------------------------------------------------

    HRESULT         ReadWriteFileContinue(XONLINETASK_HANDLE hTask);
    VOID            ReadWriteFileClose(XONLINETASK_HANDLE hTask);
    HRESULT         ReadWriteFileBegin(PXONLINETASK_FILEIO pfileio, BOOL fRead);
    INLINE HRESULT  ReadFileInternal(PXONLINETASK_FILEIO pfileio) { return(ReadWriteFileBegin(pfileio, TRUE)); }
    INLINE HRESULT  WriteFileInternal(PXONLINETASK_FILEIO pfileio) { return(ReadWriteFileBegin(pfileio, FALSE)); }
    VOID            ReadWriteFileInitializeContext(HANDLE hFile, LPBYTE pbBuffer, DWORD cbBytes, ULARGE_INTEGER uliStartingOffset, HANDLE hWorkEvent, PXONLINETASK_FILEIO pfileio);
    HRESULT         ReadWriteFile(HANDLE hFile, LPBYTE pbBuffer, DWORD cbBytes, ULARGE_INTEGER uliStartingOffset, HANDLE hWorkEvent, XONLINETASK_HANDLE* phTask, BOOL fRead);
    HRESULT         GetReadWriteFileResults(XONLINETASK_HANDLE hTask, DWORD * pdwBytesTransferred, LPBYTE * ppbBuffer);
    HRESULT         StreamConnectContinue(XONLINETASK_HANDLE hTask);
    VOID            StreamConnectClose(XONLINETASK_HANDLE hTask);
    HRESULT         StreamConnectBegin(SOCKADDR_IN * psockaddr, PXONLINETASK_SOCKIO psockio);
    VOID            StreamConnectInitializeContext(SOCKET socketIn, HANDLE hWorkEvent, PXONLINETASK_SOCKIO psockio);
    HRESULT         StreamConnect(SOCKET socketIn, SOCKADDR_IN * psockaddr, HANDLE hWorkEvent, XONLINETASK_HANDLE * phTask);
    HRESULT         GetStreamConnectResults(XONLINETASK_HANDLE hTask);
    HRESULT         SendRecvContinue(XONLINETASK_HANDLE hTask);
    VOID            SendRecvClose(XONLINETASK_HANDLE hTask);
    HRESULT         SendRecvBegin(PXONLINETASK_SOCKIO psockio, BOOL fSend);
    INLINE HRESULT  SendInternal(PXONLINETASK_SOCKIO psockio) { return(SendRecvBegin(psockio, TRUE)); }
    INLINE HRESULT  RecvInternal(PXONLINETASK_SOCKIO psockio) { return(SendRecvBegin(psockio, FALSE)); }
    VOID            SendRecvInitializeContext(SOCKET socket, LPWSABUF pBuffers, DWORD dwBufferCount, DWORD dwFlags, HANDLE hWorkEvent, PXONLINETASK_SOCKIO psockio);
    HRESULT         SendRecv(SOCKET socket, LPWSABUF pBuffers, DWORD dwBufferCount, DWORD dwFlags, HANDLE hWorkEvent, XONLINETASK_HANDLE    * phTask, BOOL fSend);
    HRESULT         GetSendRecvResults(XONLINETASK_HANDLE hTask, DWORD * pdwBytesTransferred, DWORD * pdwFlags, LPWSABUF * ppBuffers);
    
    // cfcache.cpp -----------------------------------------------------------------------

    HRESULT         CffileCacheInitialize(HANDLE hFile, DWORD dwCffileOffset, WORD wCffiles, PBYTE pbKey, DWORD cbKey, DWORD cbLength, PBYTE pbBuffer, DWORD cbBuffer, PRC4_SHA_HEADER pHeader, HANDLE hEventWorkAvailable, PXONLINECONTENT_CFFILECACHE pcffilecache);
    HRESULT         CffileCacheGetNextEntry(PXONLINECONTENT_CFFILECACHE pcffilecache, DWORD * pdwIndex, CFFILE ** ppcffile, PSTR * ppszName, DWORD * pcbName);
    HRESULT         CffileCacheVerifyChecksum(PXONLINECONTENT_CFFILECACHE pcffilecache);
    VOID            CffileCacheDeinitialize(PXONLINECONTENT_CFFILECACHE pcffilecache);
    HRESULT         CffileCacheVerify(PXONLINECONTENT_CFFILECACHE pcffilecache);

    // contutil.cpp ----------------------------------------------------------------------

    HRESULT         SetEndOfFileNt(HANDLE hFile, DWORD dwSize);
    HRESULT         HexStringToUlonglong(PSTR szHexValue, DWORD cbHexValue, ULONGLONG * pullValue);
    HRESULT         ConvertToTitleId(PSTR szTitleId, DWORD * pdwTitleId);
    HRESULT         ConvertToOfferingId(PSTR szOfferingId, XONLINEOFFERING_ID * pOfferingId);
    HRESULT         ParseContentDirName(PSTR szContentDir, XONLINEOFFERING_ID * pOfferingId, DWORD * pdwBitFilter);
    HRESULT         InitiateReferralRequest(XONLINEOFFERING_ID OfferingId, PXONLINETASK_CONTENT_DOWNLOAD pcontdl);
    HRESULT         InitiateAutoupdateReferralRequest(DWORD dwTitleId, ULONGLONG qwMachineId, DWORD dwCurrentDashVersion, PXONLINETASK_AUTOUPD_ONLINE pxoupd);
    HRESULT         ParseReferralResults(PXONLINETASK_CONTENT_DOWNLOAD pcontdl, PBYTE pbBuffer, DWORD cbBuffer);

    // contdl.cpp ------------------------------------------------------------------------

    VOID            CheckCorruption(PXONLINECONTENT_INSTALL pinstall);
    HRESULT         VerifyOrSignManifestBegin(PXONLINECONTENT_INSTALL pinstall, PBYTE pbPackageKey);
    HRESULT         VerifyCabHeader(PXONLINECONTENT_HEADER pheader);
    HRESULT         VerifyHeaderSignature(PXONLINECONTENT_INSTALL pinstall, PXONLINECONTENT_HEADER pheader, PBYTE pbSignature);
    HRESULT         ProcessFixedHeader(PXONLINETASK_CONTENT_DOWNLOAD pcontdl, PBYTE pbheader);
    HRESULT         ProcessCffolderEntries(PXONLINETASK_CONTENT_DOWNLOAD pcontdl, PBYTE pbDataBegin);
    HRESULT         SetupInstallFolder(PXONLINECONTENT_INSTALL pinstall, DWORD dwFolderIndex);
    VOID            ResetAfterUnsuccessfulResume(PXONLINECONTENT_INSTALL pinstall);
    VOID            contdlCleanup(PXONLINETASK_CONTENT_DOWNLOAD pcontdl);
    HRESULT         contdlDoneHeaders(PVOID pvxrlasync);
    BOOL            contdlProcessData(PVOID pvxrlasync);
    HRESULT         contdlCompleted(PVOID pvxrlasync);
    VOID            contdlCleanupHandler(PVOID pvxrlasync);
    HRESULT         contdlRecvHeader(PXONLINETASK_CONTENT_DOWNLOAD pcontdl);
    HRESULT         contdlInstallFiles(PXONLINETASK_CONTENT_DOWNLOAD pcontdl);
    HRESULT         contdlCreateTarget(PXONLINETASK_CONTENT_DOWNLOAD pcontdl);
    HRESULT         contdlWriteTarget(PXONLINETASK_CONTENT_DOWNLOAD pcontdl);
    HRESULT         contdlCreateDirectory(PXONLINETASK_CONTENT_DOWNLOAD pcontdl);
    HRESULT         contdlCreateCache(PXONLINETASK_CONTENT_DOWNLOAD    pcontdl);
    HRESULT         contdlCatref(PXONLINETASK_CONTENT_DOWNLOAD pcontdl);
    HRESULT         contdlCheckCache(PXONLINETASK_CONTENT_DOWNLOAD pcontdl);
    HRESULT         contdlReadCache(PXONLINETASK_CONTENT_DOWNLOAD pcontdl);
    HRESULT         contdlWipeTarget(PXONLINETASK_CONTENT_DOWNLOAD pcontdl);
    HRESULT         contdlSetupCache(PXONLINETASK_CONTENT_DOWNLOAD pcontdl);
    HRESULT         contdlVerifyCffiles(PXONLINETASK_CONTENT_DOWNLOAD pcontdl);
    HRESULT         contdlCheckpoint(PXONLINETASK_CONTENT_DOWNLOAD pcontdl);
    HRESULT         contdlVerifyInstall(PXONLINETASK_CONTENT_DOWNLOAD pcontdl);
    HRESULT         contdlPreCustom(PXONLINETASK_CONTENT_DOWNLOAD pcontdl);
    HRESULT         contdlPostCustom(PXONLINETASK_CONTENT_DOWNLOAD pcontdl);
    HRESULT         contdlSignDrm(PXONLINETASK_CONTENT_DOWNLOAD pcontdl);
    HRESULT         contdlDeleteCache(PXONLINETASK_CONTENT_DOWNLOAD pcontdl);
    HRESULT         contdlContinue(XONLINETASK_HANDLE hTask);
    HRESULT         ContentInstallInitializeContext(PXONLINETASK_CONTENT_DOWNLOAD pcontdl, DWORD dwTitleId, XONLINEOFFERING_ID OfferingId, XONLINEDIR_TYPE dirtypeTarget, DWORD dwFlags, DWORD dwTimeout, XONLINETASK_HANDLE hTaskPreCustom, XONLINETASK_HANDLE hTaskPostCustom, HANDLE hWorkEvent);
    HRESULT         BuildExistingContentPath(DWORD dwTitleId, XONLINEOFFERING_ID OfferingId, CHAR *szPostfix, XONLINEDIR_TYPE dirtype, DWORD *pcbTargetPath, CHAR *szTargetPath);

    // contrm.cpp ------------------------------------------------------------------------

    VOID            CheckCorruption(PXONLINETASK_CONTENT_REMOVE pcontrm);
    HRESULT         contrmRemoveDrm(PXONLINETASK_CONTENT_REMOVE pcontrm);
    HRESULT         contrmRemoveTitleData(PXONLINETASK_CONTENT_REMOVE pcontrm);
    HRESULT         contrmRemoveUserData(PXONLINETASK_CONTENT_REMOVE pcontrm);
    HRESULT         contrmCleanup(PXONLINETASK_CONTENT_REMOVE pcontrm);
    HRESULT         contrmContinue(XONLINETASK_HANDLE hTask);
    VOID            contrmClose(XONLINETASK_HANDLE hTask);
    HRESULT         ContentRemoveInternal(DWORD dwTitleId, XONLINEOFFERING_ID OfferingId, DWORD dwFlags, HANDLE hWorkEvent, XONLINETASK_HANDLE * phTask);
    
    // contver.cpp -----------------------------------------------------------------------

    VOID            CheckCorruption(PXONLINETASK_CONTENT_VERIFY pcontver);
    HRESULT         contverReadDrm(PXONLINETASK_CONTENT_VERIFY pcontver);
    HRESULT         contverWriteDrm(PXONLINETASK_CONTENT_VERIFY pcontver);
    HRESULT         contverCleanup(PXONLINETASK_CONTENT_VERIFY pcontver);
    HRESULT         contverContinue(XONLINETASK_HANDLE hTask);
    VOID            contverClose(XONLINETASK_HANDLE hTask);
    HRESULT         ContentVerifyInitializeContext(HANDLE hFile, DWORD dwFileSize, PBYTE pbBuffer, DWORD cbBuffer, PBYTE pbKeyPackage, DWORD dwFlags, PDGSTFILE_IDENTIFIER pdfi, XONLINEDIR_TYPE dirtype, HANDLE hWorkEvent, PXONLINETASK_CONTENT_VERIFY pcontver);
    HRESULT         ContentVerifyBegin(PXONLINETASK_CONTENT_VERIFY pcontver);
    HRESULT         ContentVerifyInternal(PDGSTFILE_IDENTIFIER pdfi, PBYTE pbBuffer, DWORD * pcbBuffer, DWORD dwFlags, XONLINEDIR_TYPE dirtype, HANDLE hWorkEvent, XONLINETASK_HANDLE * phTask);
    HRESULT         DigestVerify(PSTR szManifestFileName, XONLINEDIR_TYPE dirtype, PBYTE pbBuffer, DWORD *pcbBuffer, PBYTE pbAlternateKey, HANDLE hWorkEvent, PXONLINETASK_CONTENT_VERIFY pcontver);

    // contenum.cpp ----------------------------------------------------------------------

    HRESULT         ValidateAndRelocateCatalogRecord(PXONLINEOFFERING_ENUM_RESP_RECORD prechdr, DWORD cbRecord);
    HRESULT         ParseEnumerationResults(PXONLINETASK_OFFERING_ENUM pcontenum);
    HRESULT         contenumPostUploadContinue(XONLINETASK_HANDLE hTask);
    HRESULT         InitiateEnumerationRequest(PXONLINEOFFERING_ENUM_SERVER penum, PBYTE pbBuffer, DWORD cbBuffer, HANDLE hWorkEvent);
    HRESULT         contenumContinue(XONLINETASK_HANDLE hTask);
    HRESULT         contenumClose(XONLINETASK_HANDLE hTask);
    HRESULT         ContentEnumerateServerBegin(DWORD dwTitleId, DWORD dwUserIndex, PXONLINEOFFERING_ENUM_PARAMS pEnumParams, PBYTE pbBuffer, DWORD cbBuffer, HANDLE hWorkEvent, PXONLINETASK_OFFERING_ENUM pcontenum);
    HRESULT         ContentEnumerateLocalContinue(XONLINETASK_HANDLE hTask);
    HRESULT         ContentEnumerateLocalDone(XONLINETASK_HANDLE hTask);
    HRESULT         ContentEnumerateLocalBegin(PSTR szRootPath, PXONLINEOFFERING_ENUM_PARAMS pEnumParams, PBYTE pbBuffer, DWORD cbBuffer, HANDLE hWorkEvent, PXONLINETASK_OFFERING_ENUM pcontenum);
    HRESULT         EnumerateTitlesContinue(XONLINETASK_HANDLE hTask);

    // dirops.cpp ------------------------------------------------------------------------
    
    HRESULT         FindParentPath(PSTR szPath, DWORD * pdwIndex);
    HRESULT         RestoreChildPath(PSTR szPath, DWORD cbPath, DWORD * pdwIndex);
    HRESULT         DoCreateDirectories(PXONLINETASK_DIROPS pdirops);
    BOOL            IsInSkipList(PXONLINEDIROPS_SKIP_LIST pSkipList, PSTR szPath);
    HRESULT         DoRemoveDirectory(PXONLINETASK_DIROPS pdirops);
    HRESULT         DoEnumerateDirectory(PXONLINETASK_DIROPS pdirops);
    VOID            DiropsCleanup(PXONLINETASK_DIROPS pdirops);
    HRESULT         DiropsContinue(XONLINETASK_HANDLE hTask);
    VOID            DiropsClose(XONLINETASK_HANDLE hTask);
    HRESULT         DiropsInitializeContext(XONLINEDIROPS_OPS dirop, PSTR szPath, DWORD cbPath, DWORD cbMax, PSTR szDir, DWORD dwFlags, XONLINETASK_HANDLE hTaskOnData, XONLINETASK_HANDLE hTaskOnDone, HANDLE hWorkEvent, PXONLINETASK_DIROPS pdirops);
    INLINE HRESULT  CreateDirectoryInitializeContext(PSTR szPath, DWORD cbPath, DWORD dwFlags, HANDLE hWorkEvent, PXONLINETASK_DIROPS pdirops) { return(DiropsInitializeContext(diropCreateDirectory, szPath, cbPath, 0, NULL, dwFlags, NULL, NULL, hWorkEvent, pdirops)); }
    INLINE HRESULT  RemoveDirectoryInitializeContext(PSTR szPath, DWORD cbPath, DWORD cbMax, PSTR szDir, DWORD dwFlags, HANDLE hWorkEvent, PXONLINETASK_DIROPS pdirops) { return(DiropsInitializeContext(diropRemoveDirectory, szPath, cbPath, cbMax, szDir, dwFlags, NULL, NULL, hWorkEvent, pdirops)); }
    INLINE HRESULT  EnumerateDirectoryInitializeContext(PSTR szPath, DWORD cbPath, DWORD cbMax, DWORD dwFlags, XONLINETASK_HANDLE hTaskOnData, XONLINETASK_HANDLE hTaskOnDone, HANDLE hWorkEvent, PXONLINETASK_DIROPS pdirops) { return(DiropsInitializeContext(diropEnumerateDirectory, szPath, cbPath, cbMax, NULL, dwFlags, hTaskOnData, hTaskOnDone, hWorkEvent, pdirops)); }
    HRESULT         dircrawlCrawlDirHandler(PXONLINETASK_DIRCRAWL pdircrawl);
    HRESULT         dircrawlOnDirHandler(PXONLINETASK_DIRCRAWL pdircrawl);
    HRESULT         dircrawlOnFileHandler(PXONLINETASK_DIRCRAWL pdircrawl);
    VOID            DircrawlCleanup(PXONLINETASK_DIRCRAWL pdircrawl);
    HRESULT         dircrawlCleanupHandler(PXONLINETASK_DIRCRAWL pdircrawl);
    HRESULT         DircrawlContinue(XONLINETASK_HANDLE hTask);
    VOID            DircrawlClose(XONLINETASK_HANDLE hTask);
    HRESULT         DircrawlInitializeContext(PSTR szPath, PSTR szTarget, DWORD cbMaxPath, DWORD dwFlags, XONLINETASK_HANDLE hTaskOnDir, XONLINETASK_HANDLE hTaskOnFile, HANDLE hWorkEvent, PXONLINETASK_DIRCRAWL pdircrawl);
    HRESULT         DirCopyDirContinue(XONLINETASK_HANDLE hTask);
    HRESULT         DirCopyFileContinue(XONLINETASK_HANDLE hTask);
    HRESULT         CopyDirectoryInitializeContext(PSTR szSourceDirectory, PSTR szTargetDirectory, DWORD cbMaxPath, DWORD dwFlags, HANDLE hWorkEvent, PXONLINETASK_DIRCOPY pdircopy);
    HRESULT         DiropsCreateDirectory(PSTR szDirectoryPath, DWORD dwFlags, HANDLE hWorkEvent, XONLINETASK_HANDLE * phTask);
    HRESULT         DiropsRemoveDirectory(PSTR szDirectoryPath, DWORD cbMaxPathSize, DWORD dwFlags, HANDLE hWorkEvent, XONLINETASK_HANDLE * phTask);

    // download.cpp ----------------------------------------------------------------------

    HRESULT         xrldlPreConnectHandler(PXRL_ASYNC pxrlasync);
    HRESULT         xrldlConnectHandler(PXRL_ASYNC pxrlasync);
    HRESULT         xrldlSendHandler(PXRL_ASYNC pxrlasync);
    HRESULT         xrldlReceiveHandler(PXRL_ASYNC pxrlasync);
    HRESULT         xrldlProcessDataHandler(PXRL_ASYNC pxrlasync);
    HRESULT         xrldlPostDownloadHandler(PXRL_ASYNC pxrlasync);
    HRESULT         xrldlCleanupHandler(PXRL_ASYNC pxrlasync);
    HRESULT         xrldlContinue(XONLINETASK_HANDLE hTask);
    HRESULT         Download(LPCSTR szResourcePath, PBYTE pbExtraHeaders, DWORD cbExtraHeaders, FILETIME * pftModifiedSince, LARGE_INTEGER liResumeFrom, PXRL_ASYNC pxrlasync);
    HRESULT         xrldtmDoneHeaders(PVOID pvxrlasync);    
    BOOL            xrldtmProcessData(PVOID pvxrlasync);
    HRESULT         xrldtmCompleted(PVOID pvxrlasync);
    HRESULT         xrldfDoneHeaders(PVOID pvxrlasync);
    BOOL            xrldfProcessData(PVOID pvxrlasync);
    HRESULT         xrldfCompleted(PVOID pvxrlasync);
    HRESULT         xrldfInitializeTask(XRLDOWNLOAD_EXTTYPE xrldlext, PVOID pvxrlasync, XONLINETASK_HANDLE hTask);
    HRESULT         xrldfGrowFileHandler(PXRL_ASYNC_EXTENDED pxrlasyncext);
    HRESULT         xrldfWriteFileHandler(PXRL_ASYNC_EXTENDED pxrlasyncext);
    HRESULT         xrldfContinue(XONLINETASK_HANDLE hTask);

    // dvdload.cpp -----------------------------------------------------------------------

    HRESULT         dvddlPreConnectHandler(PXRL_ASYNC pxrlasync);
    HRESULT         dvddlEmulateHeadersHandler(PXRL_ASYNC pxrlasync);
    HRESULT         dvddlProcessDataHandler(PXRL_ASYNC pxrlasync);
    HRESULT         dvddlPostDownloadHandler(PXRL_ASYNC pxrlasync);
    HRESULT         dvddlCleanupHandler(PXRL_ASYNC pxrlasync);
    HRESULT         dvddlContinue(XONLINETASK_HANDLE hTask);
    HRESULT         DownloadFromDVD(LPCSTR szResourcePath, FILETIME *pftModifiedSince, LARGE_INTEGER liResumeFrom, PXRL_ASYNC pxrlasync);

    // symmdec.cpp -----------------------------------------------------------------------

    HRESULT         SymmdecInitialize(PBYTE pbKey, DWORD cbKey, DWORD cbLength, PRC4_SHA_HEADER pHeader, PXONLINESYMMDEC_CONTEXT psymmdec);
    HRESULT         SymmdecDecrypt(PXONLINESYMMDEC_CONTEXT psymmdec, PBYTE pbData, DWORD cbData);
    HRESULT         SymmdecVerify(PXONLINESYMMDEC_CONTEXT psymmdec);
    HRESULT         SymmdecGetRemainingCount(PXONLINESYMMDEC_CONTEXT psymmdec, PDWORD pdwBytesRemaining);

    // upload.cpp ------------------------------------------------------------------------

    HRESULT         xrlulPreConnectHandler(PXRL_ASYNC pxrlasync);
    HRESULT         xrlulConnectHandler(PXRL_ASYNC pxrlasync);
    HRESULT         xrlulReadDataHandler(PXRL_ASYNC pxrlasync);
    HRESULT         xrlulSendDataHandler(PXRL_ASYNC pxrlasync);
    HRESULT         xrlulReceiveStatusHandler(PXRL_ASYNC pxrlasync);
    HRESULT         xrlulPostUploadHandler(PXRL_ASYNC pxrlasync);
    HRESULT         xrlulCleanupHandler(PXRL_ASYNC pxrlasync);
    HRESULT         xrlulContinue(XONLINETASK_HANDLE hTask);
    HRESULT         Upload(LPCSTR szTargetPath, PBYTE pbExtraHeaders, DWORD cbExtraHeaders, PXRL_ASYNC pxrlasync);
    HRESULT         xrlulsCompleted(PVOID pvxrlasync);
    HRESULT         xrlulsResponseHeaders(PVOID pvxrlasync);
    HRESULT         xrlufmInitializeTask(XRLUPLOAD_EXTTYPE xrlulext, PVOID pvxrlasync, XONLINETASK_HANDLE hTask);
    HRESULT         xrlufmContinue(XONLINETASK_HANDLE hTask);
    HRESULT         UploadFromMemoryInternal(DWORD dwServiceID, LPCSTR szTargetPath, PBYTE pbBuffer, DWORD cbBuffer, PBYTE pbExtraHeaders, DWORD cbExtraHeaders, PBYTE pbDataToUpload, DWORD cbDataToUpload, DWORD dwTimeout, HANDLE hWorkEvent, PXRL_ASYNC_EXTENDED pxrlasyncext);
    HRESULT         xrlufInitializeTask(XRLUPLOAD_EXTTYPE xrlulext, PVOID pvxrlasync, XONLINETASK_HANDLE hTask);
    HRESULT         xrlufReadDataHandler(PXRL_ASYNC_EXTENDED pxrlasyncext);
    HRESULT         xrlufContinue(XONLINETASK_HANDLE hTask);

    // xontask.cpp -----------------------------------------------------------------------

    VOID            TaskInitializeContext(PXONLINETASK_CONTEXT pContext);
    VOID            TaskVerifyContext(PXONLINETASK_CONTEXT pContext);

    // xrlutil.cpp -----------------------------------------------------------------------

    HRESULT         XRL_FileTimeAsString(LPSTR pBuffer, DWORD * pcbBuffer, PFILETIME pft);
    BOOL            XRL_FileTimeFromString(LPCSTR sz, PFILETIME pft);
    HRESULT         XRL_BuildGetRequestWithResume(DWORD dwServiceID, LPCSTR szResourcePath, DWORD dwIPAddress, char * pBuffer, DWORD * pcbBuffer, PBYTE pbExtraHeaders, DWORD cbExtraHeaders, FILETIME * pModifiedSince, LARGE_INTEGER liResumeFrom);
    HRESULT         XRL_BuildPostRequest(DWORD dwServiceID, LPCSTR szTargetPath, DWORD dwIPAddress, char * pBuffer, DWORD * pcbBuffer, PBYTE pbExtraHeaders, DWORD cbExtraHeaders, ULARGE_INTEGER uliFileSize);
    HRESULT         XRL_LookupServiceIPAddress(PXONLINE_SERVICE_INFO pService, SOCKADDR_IN * psockaddr);
    HRESULT         XRL_SkipToURI(PBYTE pbXRL, DWORD cbXRL, PBYTE * ppbURI, DWORD * pcbURI);
    HRESULT         XRL_ConvertToIPAddressAndPort(PBYTE pbHost, DWORD cbHost, DWORD * pdwIPAddress, WORD *pwPort);
    HRESULT         XRL_AsyncConnect(PXRL_ASYNC pxrlasync);
    BOOL            XRL_ParseOneHeader(LPSTR pStart, PXRL_ASYNC pxrlasync);
    HRESULT         XRL_ProcessHttp(PXRL_ASYNC pxrlasync, DWORD dwNewBytesRead, BOOL * pfDoneHeaders);
    HRESULT         XRL_CreateWorkEventIfNecessary(PXRL_ASYNC pxrlasync, HANDLE * pHandle);
    void            XRL_CleanupHandler(PXRL_ASYNC pxrlasync);
    HRESULT         XRL_CheckDiskSpaceAccurate(char * szFilename, ULARGE_INTEGER uliFileSize);
    HRESULT         XRL_MainContinue(XONLINETASK_HANDLE hTask, const PFNXRL_HANDLER rgpfnxrlHandlers[], DWORD dwFinalState);
    VOID            XRL_MainClose(XONLINETASK_HANDLE hTask);

    // xonlzx.cpp ------------------------------------------------------------------------

    void            LzxResetDecoder(PXONLINE_LZXDECODER_CONTEXT pContext);
    bool            LzxDecodeInit(byte * pbWindowBuffer, ulong ulWindowSize, PXONLINE_LZXDECODER_CONTEXT pContext);
    void            LzxEnableExtraLongMatches(PXONLINE_LZXDECODER_CONTEXT    pContext);
    bool            LzxDecode(PXONLINE_LZXDECODER_CONTEXT pContext, ulong cbDecodedSize, byte * pbInput, ulong cbInput, byte * pbOutput, ulong *     pcbBytesDecoded);
    bool            LzxPopulateDictionary(PXONLINE_LZXDECODER_CONTEXT pContext, byte *pbData, ulong cbData);

    // logon.cpp -------------------------------------------------------------------------

    HRESULT         DNSLookupContinue(XONLINETASK_HANDLE hTask);
    void            DNSLookupClose(XONLINETASK_HANDLE hTask);
    HRESULT         DNSLookup(char * pszDNSName, HANDLE hWorkEvent, XONLINETASK_DNS_LOOKUP * pDNSLookupTask);
    HRESULT         DNSLookupGetResults(XONLINETASK_HANDLE hTask, XNDNS ** ppDestAddr);
    BOOL            DNSLookupIsValidTask(XONLINETASK_HANDLE hTask);
    HRESULT         GetSingleTicketSendAsRequest(PXONLINETASK_GET_SINGLE_TICKET pGetSingleTicketTask);
    HRESULT         GetSingleTicketContinue(XONLINETASK_HANDLE hTask);
    void            GetSingleTicketClose(XONLINETASK_HANDLE hTask);
    HRESULT         GetSingleTicket(BOOL fMachineAccount, PXKERB_TGT_CONTEXT pInputTGTContext, PXONLINE_USER pUser, HANDLE hWorkEvent, PXONLINETASK_HANDLE phGetSingleTicketTask);
    HRESULT         GetSingleTicketGetResults(XONLINETASK_HANDLE hTask, PXKERB_TGT_CONTEXT * ppSingleTGTContext);
    HRESULT         GetMachineAccountSendAsRequest(PXONLINETASK_GET_MACHINE_ACCOUNT pGetMachineAccountTask);
    HRESULT         GetMachineAccountContinue(XONLINETASK_HANDLE hTask);
    void            GetMachineAccountClose(XONLINETASK_HANDLE hTask);
    HRESULT         GetMachineAccount(HANDLE hWorkEvent, PXONLINETASK_HANDLE phGetMachineAccountTask);
    HRESULT         GetMachineAccountGetResults(XONLINETASK_HANDLE hTask, PXONLINE_USER pMachineUser);
    HRESULT         GetCombinedTicketContinue(XONLINETASK_HANDLE hTask);
    void            GetCombinedTicketClose(XONLINETASK_HANDLE hTask);
    HRESULT         GetCombinedTicket(PXONLINE_USER pMachineUser, BOOL fUseCache, HANDLE hWorkEvent, PXONLINETASK_HANDLE phGetCombinedTicketTask);
    HRESULT         GetCombinedTicketGetResults(XONLINETASK_HANDLE hTask, PXKERB_TGT_CONTEXT* ppCombinedTGTContext, BOOL* pfTicketFromCache);
    HRESULT         GetServiceTicketSendTgsRequest(PXONLINETASK_GET_SERVICE_TICKET pGetServiceTicketTask);
    HRESULT         GetServiceTicketContinue(XONLINETASK_HANDLE hTask);
    void            GetServiceTicketClose(XONLINETASK_HANDLE hTask);
    HRESULT         GetServiceTicket(PXKERB_TGT_CONTEXT pCombinedTGTContext, DWORD* pdwServiceIDs, DWORD cServices, BOOL fUseCache, HANDLE hWorkEvent, PXONLINETASK_HANDLE phGetServiceTicketTask);
    HRESULT         GetServiceTicketGetResults(XONLINETASK_HANDLE hTask, PXKERB_SERVICE_CONTEXT * ppXKerbServiceContext, BOOL* pfTicketFromCache);
    HRESULT         LogonTaskContinue(XONLINETASK_HANDLE hTask);
    void            LogonTaskClose(XONLINETASK_HANDLE hTask);

    // match.cpp -------------------------------------------------------------------------

    HRESULT         SessionCreate(XNKID SessionID, DWORD dwPublicCurrent, DWORD dwPublicAvailable, DWORD dwPrivateCurrent, DWORD dwPrivateAvailable, DWORD dwNumAttributes, PXONLINE_ATTRIBUTE pAttributes, HANDLE hWorkEvent, PXONLINETASK_HANDLE phTask);
    HRESULT         MatchSearch(DWORD dwProcedureIndex, DWORD dwNumResults, DWORD dwNumAttributes, PXONLINE_ATTRIBUTE pAttributes, DWORD dwResultsLen, HANDLE hWorkEvent, PXONLINETASK_HANDLE phTask);
    HRESULT         CreateContext(PXMATCH_EXTENDED_HANDLE *ppExtendedHandle, DWORD dwMsgLen, DWORD dwResultsLen, XNKID SessionID, HANDLE hWorkEvent, DWORD dwNumResults, XMATCH_TYPE Type);
    DWORD           TotalAttributeSize(DWORD dwNumAttributes, PXONLINE_ATTRIBUTE pAttributes);
    VOID            WriteAttributes(PBYTE pbBufferStart, DWORD dwNumAttributes, PXONLINE_ATTRIBUTE pAttributes, DWORD * pdwAttributeOffset, PBYTE pbAttribute);
    HRESULT         MatchContinue(XONLINETASK_HANDLE hTask);
    VOID            MatchClose(XONLINETASK_HANDLE hTask);
    VOID            FixupAttributeIDs(DWORD dwNumAttributes, PXONLINE_ATTRIBUTE pAttributes);
    BOOL            ValidateAttributeIDs(DWORD dwNumAttributes, PXONLINE_ATTRIBUTE pAttributes, BOOL fSessionCreate);
    BOOL            IsValidAttributeID(DWORD dwAttributeID, BOOL fSessionCreate);

    // service.cpp -----------------------------------------------------------------------

    HRESULT         InitOverrideInfo(LPSTR pszXOnlineIniFile = NULL);

    // users.cpp -------------------------------------------------------------------------

    VOID            CompleteRecentLogonTimeCacheOpenTask();
    VOID            CopyAndAdjustUser(PXC_ONLINE_USER_ACCOUNT_STRUCT pUserAccount, DWORD dwMUOptions, PXONLINEP_USER pUser);
    VOID            CollectValidUser(PXC_ONLINE_USER_ACCOUNT_STRUCT pUserAccount, DWORD dwMUOptions, FILETIME* pLastLogon, PXONLINEP_USER pUsers, DWORD *pcUsers);

    // presence.cpp ----------------------------------------------------------------------

    HRESULT         NotificationEnumeratePriv(DWORD dwUserIndex, PXONLINE_NOTIFICATION_MSG pbBuffer, WORD wBufferCount, DWORD dwNotificationTypes, PXPRESENCE_EXTENDED_HANDLE pExtendedHandle);
    HRESULT         NotificationSendAlive(PXONLINE_USER pUsers, HANDLE hEvent, PXONLINETASK_HANDLE phTask);
    HRESULT         CreateContext(PXPRESENCE_EXTENDED_HANDLE *ppExtendedHandle, HANDLE hEvent, XPRESENCE_REQUESTTYPE Type, DWORD dwUserIndex);
    HRESULT         CreateMsg(DWORD dwMsgType, DWORD dwMsgLen, PXPRESENCE_EXTENDED_HANDLE pExtendedHandle, SERVER_TYPE Server, PBYTE * ppbMsgBuffer, UINT * pcbMsgBuffer, PBYTE *ppbMsg, DWORD *pdwSeqNum);
    HRESULT         SendMsg(PBYTE pbMsgBuffer, UINT cbMsgBuffer, DWORD dwBufferSize, PXPRESENCE_EXTENDED_HANDLE pExtendedHandle, SERVER_TYPE Server);
    HRESULT         NotificationContinue(XONLINETASK_HANDLE hTask);
    HRESULT         FriendsEnumerateContinue(XONLINETASK_HANDLE hTask);
    HRESULT         FriendsContinue(XONLINETASK_HANDLE hTask);
    HRESULT         HandleGameInvite(XONLINETASK_HANDLE hTask);
    HRESULT         GameInviteContinue(XONLINETASK_HANDLE hTask);
    VOID            GameInviteClose(XONLINETASK_HANDLE hTask);
    VOID            PresenceClose(XONLINETASK_HANDLE hTask);
    PXPRESENCE_USER GetUserFromID(ULONGLONG qwUserID);
    DWORD           GetUserIndexFromID(ULONGLONG qwUserID);
    PXPRESENCE_USER GetUserFromSeqNum(DWORD dwSeqNum);
    HRESULT         FriendListRefresh(PXPRESENCE_EXTENDED_HANDLE pExtendedHandle);
    VOID            ResetFriendList(DWORD dwSeqNum, DWORD dwFriendListVersion, WORD cFriends, P_REPLY_BUDDY * pFriend);
    VOID            ResetLockoutList(DWORD dwSeqNum, DWORD dwLockoutListVersion, WORD cLockouts, P_REPLY_BLOCK *pLockout);
    DWORD           PreprocessNotifications(Q_LIST_REPLY_MSG * pQListReply);
    HRESULT         UpdateUser(PXPRESENCE_USER pUser, ULONGLONG qwFriendID, PBYTE pUserName, DWORD cbUserName, DWORD dwTitleID, DWORD dwState, DWORD dwFriendFlags, ULONGLONG qwMatchSessionID, WORD cbStateData, PBYTE pStateData, WORD cbUserData, PBYTE pUserData, DWORD dwVersion);
    VOID            SetUserFlags(PXPRESENCE_USER pUser, ULONGLONG qwFriendID, DWORD dwFlags, BOOL fSet);
    HRESULT         RemoveUser(PXPRESENCE_USER pUser, ULONGLONG qwFriendID, DWORD dwVersion);
    HRESULT         AddLockoutUser(PXPRESENCE_USER pUser, ULONGLONG qwLockoutID, LPSTR pUserName);
    HRESULT         RemoveLockoutUser(PXPRESENCE_USER pUser, ULONGLONG qwLockoutID);

    BOOL            IsValidStateFlags(DWORD dwStateFlags);
    BOOL            IsValidNotificationType(DWORD dwType);
    WORD            NumGuests(ULONGLONG qwUserID);

    // billing.cpp -----------------------------------------------------------------------

    HRESULT         DoPurchaseContinue(XONLINETASK_HANDLE hTask);
    VOID            DoPurchaseClose(XONLINETASK_HANDLE hTask);
    HRESULT         DoCancelContinue(XONLINETASK_HANDLE hTask);
    VOID            DoCancelClose(XONLINETASK_HANDLE hTask);
    HRESULT         DoDetailsContinue(XONLINETASK_HANDLE hTask);
    VOID            DoDetailsClose(XONLINETASK_HANDLE hTask);
    VOID            XOParsePrices(XONLINETASK_HANDLE hTask);
    HRESULT         VerifyLicenseTaskContinue(XONLINETASK_HANDLE hTask);
    VOID            VerifyLicenseTaskClose(XONLINETASK_HANDLE hTask);
    HRESULT         DoVerifyCacheOpen(XO_OFFERING_VERIFY_LICENSE_TASK* pVerifyTask);
    HRESULT         DoVerifyCacheLookup(XO_OFFERING_VERIFY_LICENSE_TASK* pVerifyTask);
    HRESULT         DoVerifyServerRequest(XO_OFFERING_VERIFY_LICENSE_TASK* pVerifyTask);
    HRESULT         DoVerifyCacheUpdate(XO_OFFERING_VERIFY_LICENSE_TASK* pVerifyTask);
    HRESULT         DoVerifyCacheClose(XO_OFFERING_VERIFY_LICENSE_TASK* pVerifyTask);
    HRESULT         VerifyRights(XO_OFFERING_LICENSE* lic, ULONGLONG puid);

    // localcache.cpp --------------------------------------------------------------------

    HRESULT         CacheOpen(XONLC_TYPE cacheType, PFNXONLC_COMPARE_HANDLER pfnCompareFunc, HANDLE hWorkEvent, PHANDLE phCache, PXONLINETASK_HANDLE phTask);
    HRESULT         CacheUpdate(HANDLE hCache, XONLINETASK_HANDLE hTask, PBYTE pbIndexData, PBYTE pbRecord, BOOL bWriteIndex = TRUE);
    HRESULT         CacheIndexFlush(HANDLE hCache, XONLINETASK_HANDLE hTask);
    HRESULT         CacheLookup(HANDLE hCache, PXONLC_CONTEXT pContext);
    HRESULT         CacheRetrieve(HANDLE hCache, XONLINETASK_HANDLE hTask, PXONLC_CONTEXT pContext);
    HRESULT         CacheDelete(HANDLE hCache, PXONLC_CONTEXT pContext);
    HRESULT         CacheFileDelete(XONLC_TYPE cacheType);
    HRESULT         CacheReset(HANDLE hCache, XONLINETASK_HANDLE hTask);
    HRESULT         CacheClose(HANDLE hCache, XONLINETASK_HANDLE hTask);
    HRESULT         CacheClose(HANDLE hCache);
    HRESULT         CacheContinue(XONLINETASK_HANDLE hTask);
    VOID            CacheTaskClose(XONLINETASK_HANDLE hTask);
    HRESULT         CacheUpdateMRUListPriv(XONLC_CACHE_HANDLE hCache, XONLINETASK_HANDLE hTask, PBYTE pbIndexData, PBYTE pbRecord);
    HRESULT         CacheUpdateIndexPriv(XONLC_CACHE_HANDLE hCache, XONLINETASK_HANDLE hTask, PBYTE pbIndexData);
    HRESULT         CacheUpdateRecordPriv(XONLC_CACHE_HANDLE hCache, XONLINETASK_HANDLE hTask, PBYTE pbRecord);

    // msgclient.cpp --------------------------------------------------------------------

    VOID            InitializeMsgClientContext( XONLINETASK_MSGCLIENT hMsgTask, HANDLE hWorkEvent);
    HRESULT         MsgClientInternal(XONLINETASK_MSGCLIENT hMsgTask, PXONMSGCLIENT_REQUEST pRequest, PXONMSGCLIENT_RESPONSE pResponse);
    HRESULT         DoMsgClientContinue(XONLINETASK_HANDLE hTask);
    VOID            DoMsgClientTaskClose(XONLINETASK_HANDLE hTask);
    HRESULT         ParseMsgServerResults( PXRL_ASYNC pXrlAsync );
        
    HRESULT         TitleCacheInit( HANDLE hWorkEvent, PXONLINETASK_HANDLE phTask);
    BOOL            TitleCacheRetrieve( XONLINETASK_HANDLE hTask, DWORD dwTitleID, PXONLINE_TITLEDATA pTitleData);
    VOID            InitializeTitleCacheContext( XONLINETASK_TITLECACHE hTITLECACHETask, HANDLE hWorkEvent );
    BOOL            DoTitleCacheRetrieveBegin( XONLINETASK_TITLECACHE hTITLECACHETask );
    HRESULT         StartLocalCacheRetrieve( XONLINETASK_TITLECACHE   hTITLECACHETask );
    HRESULT         StartMsgServerRetrieve( XONLINETASK_TITLECACHE   hTITLECACHETask );
    HRESULT         StartLocalCacheUpdate( XONLINETASK_TITLECACHE   hTITLECACHETask );
    HRESULT         DoTitleCacheContinue(XONLINETASK_HANDLE hTask);
    VOID            DoTitleCacheTaskClose(XONLINETASK_HANDLE hTask);

    // accounts.cpp --------------------------------------------------------------------

    HRESULT         DoAcctTempCreateContinue(XONLINETASK_HANDLE hTask);
    void            DoAcctTempCreateClose(XONLINETASK_HANDLE hTask);
    HRESULT         DoGetTagsContinue( XONLINETASK_HANDLE hTask );
    void            DoGetTagsClose(XONLINETASK_HANDLE hTask);
    HRESULT         DoReserveNameContinue( XONLINETASK_HANDLE hTask );
    void            DoReserveNameClose(XONLINETASK_HANDLE hTask);
    HRESULT         DoCreateAccountContinue( XONLINETASK_HANDLE hTask );
    void            DoCreateAccountClose(XONLINETASK_HANDLE hTask);
    LPBYTE          WToUtf8(PWORD pwLen, LPBYTE pbData, LPCWSTR pwszStr);

    // olddash.cpp --------------------------------------------------------------------

    HRESULT         xododContinue(XONLINETASK_HANDLE hTask);
    VOID            xododClose(XONLINETASK_HANDLE hTask);
    HRESULT         XOnlineUpdateDeleteOfflineDash(HANDLE hWorkEvent, PXONLINETASK_DEL_OLD_DASH	pxodod);

    // Windows support -------------------------------------------------------------------

    #ifdef XONLINE_FEATURE_WINDOWS
    DWORD           XGetParentalControlSetting();
    DWORD           XGetLanguage();
    INLINE BYTE *   GetHdKey()          { return(m_abHdKey); }
    #else
    INLINE BYTE *   GetHdKey()          { return((BYTE *)(*XboxHDKey)); }
    #endif

    // Global Data -----------------------------------------------------------------------

    DWORD                               m_cRefs;
    DWORD                               m_dwTitleId;
    DWORD                               m_dwTitleVersion;
    DWORD                               m_dwTitleGameRegion;
    BOOL                                m_fWsaStartup;
    BOOL                                m_fGetNewMachineAccount;
    
    ULONGLONG                           m_qwMachineId;
    
    HANDLE                              m_hConfigVolume;
    
    #ifdef XONLINE_FEATURE_INSECURE
    IN_ADDR                             m_sgAddr;
    XONLINE_SERVICE_INFO                m_rgServiceInfoOverride[XONLINE_MAX_SERVICE_REQUEST];
    DWORD                               m_ctServiceInfoOverride;
    BOOL                                m_fBypassAuth;
    BOOL                                m_fBypassSG;
    BOOL                                m_fForceNewMachineAccount;
    #endif

    struct tagASN1module_t              m_KRB5_Module;

    #if DBG
    BOOL                                m_fSessionCreateInProgress;
    #endif

    #ifdef XNET_FEATURE_ASSERT
    CLeakInfo                           m_LeakInfo;
    #endif

    // Logon Data ------------------------------------------------------------------------

    PXONLINETASK_LOGON                  m_pLogonTask;
    BOOL                                m_fLogonCompletedSuccessfully;
    SERVICE_CONTEXT                     m_rgServiceContexts[XONLINE_MAX_SERVICE_REQUEST];
    XONLINE_USER                        m_rgLogonUsers[XONLINE_MAX_LOGON_USERS];
    DWORD                               m_dwUniqueLogonUsers;
    PXONLINE_USER                       m_apUniqueLogonUsers[XONLINE_MAX_LOGON_USERS];
    DWORD                               m_ctAllocatedServiceContexts;
    PXKERB_SERVICE_CONTEXT              m_pAllocatedServiceContexts[XONLINE_MAX_SERVICE_REQUEST];
    XONLINE_DNS_CACHE_ENTRY             m_DNSCache[XONLINE_NUM_DNS_CACHE_ENTRYS];

    //
    // Hard coded to only match 2 services beyond the sequential ones.
    //
    INLINE DWORD GetServiceArrayIndex(DWORD dwServiceID)
    {
        Assert( XONLINE_MAX_SERVICE_REQUEST == XONLINE_NUMBER_SEQUENTIAL_SERVICES + 2 );
        
        if (dwServiceID < XONLINE_NUMBER_SEQUENTIAL_SERVICES)
        {
            return dwServiceID;
        }
        if (m_rgServiceContexts[XONLINE_NUMBER_SEQUENTIAL_SERVICES].serviceInfo.dwServiceID == dwServiceID)
        {
            return XONLINE_NUMBER_SEQUENTIAL_SERVICES;
        }
        if (m_rgServiceContexts[XONLINE_NUMBER_SEQUENTIAL_SERVICES+1].serviceInfo.dwServiceID == dwServiceID)
        {
            return XONLINE_NUMBER_SEQUENTIAL_SERVICES+1;
        }
        return XONLINE_INVALID_SERVICE;
    }
    
    // Local Cache usage
    #define XON_CACHE_STATE_INITIAL     0
    #define XON_CACHE_STATE_OPENING     1
    #define XON_CACHE_STATE_OPENED      2
    #define XON_CACHE_STATE_UPDATING    3
    #define XON_CACHE_STATE_UPDATED     4
    #define XON_CACHE_STATE_FLUSHING    5
    #define XON_CACHE_STATE_DONE        6
    #define XON_CACHE_STATE_ERROR       7
    
    HANDLE                              m_hLogonTimeCache;
    XONLINETASK_HANDLE                  m_hLogonTimeCacheTask;
    DWORD                               m_dwLogonTimeCacheState;

    // Presence Data ---------------------------------------------------------------------

    XPRESENCE_EXTENDED_HANDLE *         m_pLockoutlistHandle;
    XPRESENCE_EXTENDED_HANDLE *         m_pFriendsHandle;
    // User list for storing friend lists and other context information
    // @@@ drm: This is HUGE.  Should be made smaller or allocated on demand.
    XPRESENCE_USER                      m_Users[4];
    // Global sequence number used to match up requests with responses (either direct
    // responses or notifications through the notification queue).
    DWORD                               m_dwSeqNum;
    // Flag indicated if ALIVE messages have been sent yet.  Used to determine whether SetUserData()
    // API should send the userdata in the ALIVE message or send it as a NICKNAME message.
    BOOL                                m_fAliveDone;
    HANDLE                              m_hCacheGameInvite;
    XONLINETASK_HANDLE                  m_hTaskGameInvite;
    XPRESENCE_GAMEINVITE_RECORD *       m_precordGameInvite;
    XONLC_CONTEXT                       m_contextGameInvite;
    XPRESENCE_CACHESTATE                m_cachestateGameInvite;
    BOOL                                m_fGameInvite;

    // Local Cache Data ------------------------------------------------------------------

    XONLC_CACHE_HANDLE                  m_xonCacheHandles[XONLC_MAX_CACHE_TYPES];

    // Debugging Data --------------------------------------------------------------------

    #if DBG
    LARGE_INTEGER                       m_liTotalTime;
    LARGE_INTEGER                       m_liServiceCount;
    LARGE_INTEGER                       m_liAverageTime;
    LARGE_INTEGER                       m_lirmTotalTime;
    LARGE_INTEGER                       m_lirmServiceCount;
    LARGE_INTEGER                       m_lirmAverageTime;
    LARGE_INTEGER                       m_liverTotalTime;
    LARGE_INTEGER                       m_liverServiceCount;
    LARGE_INTEGER                       m_liverAverageTime;
    #endif

    // Windows Data ----------------------------------------------------------------------

    #ifdef XONLINE_FEATURE_WINDOWS
    BYTE                                m_abHdKey[16];
    #endif

    // Static Data -----------------------------------------------------------------------

    static const PFNAUTOUPD_DVD_HANDLER s_rgpfndvdupdHandlers[];
    static const PFNAUTOUPD_ONLINE_HANDLER s_rgpfnxoupdHandlers[];
    static const PFNCONTDL_HANDLER      s_rgpfncontdlHandlers[];
    static const PFNDIRCRAWL_HANDLER    s_rgpfndircrawlHandlers[];
    static const PFNXRL_HANDLER         s_rgpfnxrldlHandlers[];
    static const PFNXRL_HANDLER         s_rgpfnxrlulHandlers[];
    static const PFNXRL_HANDLER         s_rgpfndvddlHandlers[];
    #if DBG
    static const char * const           s_rgszPhases[];
    static const char * const           s_rgszRemovePhases[];
    static const c