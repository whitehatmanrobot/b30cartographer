BssType;
    DWORD                           dwFlags;           // Flags define above
    DWORD                           dwReasonCode;      // Set only when an applicable reason code is available
}
WDIAG_IHV_WLAN_ID, *PWDIAG_IHV_WLAN_ID;



typedef
DWORD
(WINAPI *DOT11EXT_ALLOCATE_BUFFER)
(
   IN  DWORD    dwByteCount,
   OUT LPVOID*  ppvBuffer
);




typedef
VOID
(WINAPI *DOT11EXT_FREE_BUFFER)
(
   IN LPVOID   pvMemory
);




typedef
DWORD
(WINAPI *DOT11EXT_SET_PROFILE_CUSTOM_USER_DATA)
(
   IN    HANDLE   hDot11SvcHandle,
   IN    HANDLE   hConnectSession,
   IN    DWORD    dwSessionID,
   IN    DWORD    dwDataSize,
   IN    LPVOID   pvData
);




typedef
DWORD
(WINAPI *DOT11EXT_GET_PROFILE_CUSTOM_USER_DATA)
(
   IN    HANDLE   hDot11SvcHandle,
   IN    HANDLE   hConnectSession,
   IN    DWORD    dwSessionID,
   OUT   DWORD*   pdwDataSize,
   OUT   LPVOID*  ppvData
);




typedef
DWORD
(WINAPI *DOT11EXT_SET_CURRENT_PROFILE)
(
    IN  HANDLE                                  hDot11SvcHandle,
    IN  HANDLE                                  hConnectSession,
    IN  PDOT11EXT_IHV_CONNECTIVITY_PROFILE      pIhvConnProfile,
    IN  PDOT11EXT_IHV_SECURITY_PROFILE          pIhvSecProfile
);




typedef
DWORD
(WINAPI *DOT11EXT_SEND_UI_REQUEST)
(
   IN    HANDLE                     hDot11SvcHandle,
   IN    PDOT11EXT_IHV_UI_REQUEST   pIhvUIRequest
);




typedef
DWORD
(WINAPI *DOT11EXT_PRE_ASSOCIATE_COMPLETION)
(
   IN    HANDLE   hDot11SvcHandle,
   IN    HANDLE   hConnectSession,
   IN    DWORD    dwReasonCode,
   IN    DWORD    dwWin32Error
);




typedef
DWORD
(WINAPI *DOT11EXT_POST_ASSOCIATE_COMPLETION)
(
   IN    HANDLE               hDot11SvcHandle,
   IN    HANDLE               hSecuritySessionID,
   IN    PDOT11_MAC_ADDRESS   pPeer,
   IN    DWORD                dwReasonCode,
   IN    DWORD                dwWin32Error
);




typedef
DWORD
(WINAPI *DOT11EXT_SEND_NOTIFICATION)
(
   IN    HANDLE                  hDot11SvcHandle,
   IN    PL2_NOTIFICATION_DATA   pNotificationData
);




typedef
DWORD
(WINAPI *DOT11EXT_SEND_PACKET)
(
   IN    HANDLE   hDot11SvcHandle,
   IN    ULONG    uPacketLen,
   IN    LPVOID   pvPacket,
   IN    HANDLE   hSendCompletion
);




typedef
DWORD
(WINAPI *DOT11EXT_SET_ETHERTYPE_HANDLING)
(
   IN    HANDLE                     hDot11SvcHandle,
   IN    ULONG                      uMaxBackLog,
   IN    ULONG                      uNumOfExemption,
   IN    PDOT11_PRIVACY_EXEMPTION   pExemption,
   IN    ULONG                      uNumOfRegistration,
   IN    USHORT*                    pusRegistration
);




typedef
DWORD
(WINAPI *DOT11EXT_SET_AUTH_ALGORITHM)
(
   IN    HANDLE   hDot11SvcHandle,
   IN    DWORD    dwAuthAlgo
);




typedef
DWORD
(WINAPI *DOT11EXT_SET_UNICAST_CIPHER_ALGORITHM)
(
   IN    HANDLE   hDot11SvcHandle,
   IN    DWORD    dwUnicastCipherAlgo
);




typedef
DWORD
(WINAPI *DOT11EXT_SET_MULTICAST_CIPHER_ALGORITHM)
(
   IN    HANDLE   hDot11SvcHandle,
   IN    DWORD    dwMulticastCipherAlgo
);




typedef
DWORD
(WINAPI *DOT11EXT_SET_DEFAULT_KEY)
(
   IN    HANDLE                           hDot11SvcHandle,
   IN    PDOT11_CIPHER_DEFAULT_KEY_VALUE  pKey,
   IN    DOT11_DIRECTION                  dot11Direction
);




typedef
DWORD
(WINAPI *DOT11EXT_SET_KEY_MAPPING_KEY)
(
   IN    HANDLE                                 hDot11SvcHandle,
   IN    PDOT11_CIPHER_KEY_MAPPING_KEY_VALUE    pKey
);




typedef
DWORD
(WINAPI *DOT11EXT_SET_DEFAULT_KEY_ID)
(
   IN    HANDLE   hDot11SvcHandle,
   IN    ULONG    uDefaultKeyId
);




typedef
DWORD
(WINAPI *DOT11EXT_SET_EXCLUDE_UNENCRYPTED)
(
   IN    HANDLE   hDot11SvcHandle,
   IN    BOOL     bExcludeUnencrypted
);




typedef
DWORD
(WINAPI *DOT11EXT_NIC_SPECIFIC_EXTENSION)
(
   IN       HANDLE   hDot11SvcHandle,
   IN       DWORD    dwInBufferSize,
   IN       LPVOID   pvInBuffer,
   IN OUT   DWORD*   pdwOutBufferSize,
   OUT      LPVOID   pvOutBuffer
);


/*
     IHV should allocate EAP attributes using DOT11EXT_ALLOCATE_BUFFER
     The IHV framework will free them.                      
*/

typedef
DWORD
(WINAPI *DOT11EXT_ONEX_START)
(
   IN       HANDLE   hDot11SvcHandle,
   IN       EAP_ATTRIBUTES *pEapAttributes
);

typedef
DWORD
(WINAPI *DOT11EXT_ONEX_STOP)
(
   IN       HANDLE   hDot11SvcHandle
);

typedef
DWORD
(WINAPI *DOT11EXT_PROCESS_ONEX_PACKET)
(
   IN       HANDLE   hDot11SvcHandle,
   IN       DWORD    dwInPacketSize,
   IN       LPVOID   pvInPacket
);



#define  IHV_VERSION_FUNCTION_NAME  "Dot11ExtIhvGetVersionInfo"
#define  IHV_INIT_FUNCTION_NAME     "Dot11ExtIhvInitService"




typedef
DWORD
(WINAPI *DOT11EXTIHV_GET_VERSION_INFO)
(
   OUT   PDOT11_IHV_VERSION_INFO    pDot11IHVVersionInfo
);




typedef
DWORD
(WINAPI *DOT11EXTIHV_INIT_SERVICE)
(
   IN    DWORD                      dwVerNumUsed,
   IN    PDOT11EXT_APIS             pDot11ExtAPI,
   IN    LPVOID                     pvReserved,
   OUT   PDOT11EXT_IHV_HANDLERS     pDot11IHVHandlers
);




typedef
VOID
(WINAPI *DOT11EXTIHV_DEINIT_SERVICE)
(
   VOID
);




typedef
DWORD
(WINAPI *DOT11EXTIHV_INIT_ADAPTER)
(
   IN    PDOT11_ADAPTER    pDot11Adapter,
   IN    HANDLE            hDot11SvcHandle,
   OUT   PHANDLE           phIhvExtAdapter
);




typedef
VOID
(WINAPI *DOT11EXTIHV_DEINIT_ADAPTER)
(
   IN    HANDLE   hIhvExtAdapter
);




typedef
DWORD
(WINAPI *DOT11EXTIHV_PERFORM_PRE_ASSOCIATE)
(
   IN    HANDLE                                 hIhvExtAdapter,
   IN    HANDLE                                 hConnectSession,
   IN    PDOT11EXT_IHV_PROFILE_PARAMS           pIhvProfileParams,
   IN    PDOT11EXT_IHV_CONNECTIVITY_PROFILE     pIhvConnProfile,
   IN    PDOT11EXT_IHV_SECURITY_PROFILE         pIhvSecProfile,
   IN    PDOT11_BSS_LIST                        pConnectableBssid,
   OUT   PDWORD                                 pdwReasonCode
);




typedef
DWORD
(WINAPI *DOT11EXTIHV_ADAPTER_RESET)
(
   IN    HANDLE   hIhvExtAdapter
);




typedef
DWORD
(WINAPI *DOT11EXTIHV_PERFORM_POST_ASSOCIATE)
(
   IN    HANDLE                                       hIhvExtAdapter,
   IN    HANDLE                                       hSecuritySessionID,
   IN    PDOT11_PORT_STATE                            pPortState,
   IN    ULONG                                        uDot11AssocParamsBytes,
   IN    PDOT11_ASSOCIATION_COMPLETION_PARAMETERS     pDot11AssocParams
);




typedef
DWORD
(WINAPI *DOT11EXTIHV_STOP_POST_ASSOCIATE)
(
   IN    HANDLE               hIhvExtAdapter,
   IN    PDOT11_MAC_ADDRESS   pPeer,
   IN    DOT11_ASSOC_STATUS   dot11AssocStatus
);




typedef
DWORD
(WINAPI *DOT11EXTIHV_VALIDATE_PROFILE)
(
    IN  HANDLE                              hIhvExtAdapter,
    IN  PDOT11EXT_IHV_PROFILE_PARAMS        pIhvProfileParams,
    IN  PDOT11EXT_IHV_CONNECTIVITY_PROFILE  pIhvConnProfile,
    IN  PDOT11EXT_IHV_SECURITY_PROFILE      pIhvSecProfile,
    OUT PDWORD                              pdwReasonCode
);




typedef
DWORD
(WINAPI *DOT11EXTIHV_PERFORM_CAPABILITY_MATCH)
(
    IN  HANDLE                              hIhvExtAdapter,
    IN  PDOT11EXT_IHV_PROFILE_PARAMS        pIhvProfileParams,
    IN  PDOT11EXT_IHV_CONNECTIVITY_PROFILE  pIhvConnProfile,
    IN  PDOT11EXT_IHV_SECURITY_PROFILE      pIhvSecProfile,
    IN  PDOT11_BSS_LIST                     pConnectableBssid,
    OUT PDWORD                              pdwReasonCode
);




typedef
DWORD
(WINAPI *DOT11EXTIHV_CREATE_DISCOVERY_PROFILES)
(
    IN  HANDLE                                      hIhvExtAdapter,
    IN  BOOL                                        bInsecure,
    IN  PDOT11EXT_IHV_PROFILE_PARAMS                pIhvProfileParams,
    IN  PDOT11_BSS_LIST                             pConnectableBssid,
    OUT PDOT11EXT_IHV_DISCOVERY_PROFILE_LIST        pIhvDiscoveryProfileList,
    OUT PDWORD                                      pdwReasonCode
);




typedef
DWORD
(WINAPI *DOT11EXTIHV_PROCESS_SESSION_CHANGE)
(
   IN    ULONG                         uEventType,
#ifndef UNDER_CE
   IN    PWTSSESSION_NOTIFICATION      pSessionNotification
#else
   IN    LPVOID                        pReserved
#endif
);




typedef
DWORD
(WINAPI *DOT11EXTIHV_RECEIVE_INDICATION)
(
    IN  HANDLE                          hIhvExtAdapter,
    IN  DOT11EXT_IHV_INDICATION_TYPE    indicationType,
    IN  ULONG                           uBufferLength,
    IN  LPVOID                          pvBuffer
);




typedef
DWORD
(WINAPI *DOT11EXTIHV_RECEIVE_PACKET)
(
   IN    HANDLE   hIhvExtAdapter,
   IN    DWORD    dwInBufferSize,
   IN    LPVOID   pvInBuffer
);




typedef
DWORD
(WINAPI *DOT11EXTIHV_SEND_PACKET_COMPLETION)
(
   IN    HANDLE   hSendCompletion
);




typedef
DWORD
(WINAPI *DOT11EXTIHV_IS_UI_REQUEST_PENDING)
(
   IN    GUID     guidUIRequest,
   OUT   PBOOL    pbIsRequestPending
);




typedef
DWORD
(WINAPI *DOT11EXTIHV_PROCESS_UI_RESPONSE)
(
   IN    GUID        guidUIRequest,
   IN    DWORD       dwByteCount,
   IN    LPVOID      pvResponseBuffer
);




typedef
DWORD
(WINAPI *DOT11EXTIHV_QUERY_UI_REQUEST)
(
   IN    HANDLE                        hIhvExtAdapter,
   IN    DOT11EXT_IHV_CONNECTION_PHASE connectionPhase,
   OUT   PDOT11EXT_IHV_UI_REQUEST*     ppIhvUIRequest
);


typedef
DWORD
(WINAPI *DOT11EXTIHV_ONEX_INDICATE_RESULT)
(
   IN    HANDLE                           hIhvExtAdapter,
   IN    DOT11_MSONEX_RESULT              msOneXResult,
   IN    PDOT11_MSONEX_RESULT_PARAMS      pDot11MsOneXResultParams
);


typedef
DWORD
(WINAPI *DOT11EXTIHV_CONTROL)
(
   IN    HANDLE    hIhvExtAdapter,
   IN    DWORD     dwInBufferSize,
   IN    PBYTE     pInBuffer,
   IN    DWORD     dwOutBufferSize,
   OUT   PBYTE     pOutBuffer,
   OUT   PDWORD    pdwBytesReturned
);


struct _DOT11EXT_APIS
{
   DOT11EXT_ALLOCATE_BUFFER                     Dot11ExtAllocateBuffer;
   DOT11EXT_FREE_BUFFER                         Dot11ExtFreeBuffer;
   DOT11EXT_SET_PROFILE_CUSTOM_USER_DATA        Dot11ExtSetProfileCustomUserData;
   DOT11EXT_GET_PROFILE_CUSTOM_USER_DATA        Dot11ExtGetProfileCustomUserData;
   DOT11EXT_SET_CURRENT_PROFILE                 Dot11ExtSetCurrentProfile;
   DOT11EXT_SEND_UI_REQUEST                     Dot11ExtSendUIRequest;
   DOT11EXT_PRE_ASSOCIATE_COMPLETION            Dot11ExtPreAssociateCompletion;
   DOT11EXT_POST_ASSOCIATE_COMPLETION           Dot11ExtPostAssociateCompletion;
   DOT11EXT_SEND_NOTIFICATION                   Dot11ExtSendNotification;
   DOT11EXT_SEND_PACKET                         Dot11ExtSendPacket;
   DOT11EXT_SET_ETHERTYPE_HANDLING              Dot11ExtSetEtherTypeHandling;
   DOT11EXT_SET_AUTH_ALGORITHM                  Dot11ExtSetAuthAlgorithm;
   DOT11EXT_SET_UNICAST_CIPHER_ALGORITHM        Dot11ExtSetUnicastCipherAlgorithm;
   DOT11EXT_SET_MULTICAST_CIPHER_ALGORITHM      Dot11ExtSetMulticastCipherAlgorithm;
   DOT11EXT_SET_DEFAULT_KEY                     Dot11ExtSetDefaultKey;
   DOT11EXT_SET_KEY_MAPPING_KEY                 Dot11ExtSetKeyMappingKey;
   DOT11EXT_SET_DEFAULT_KEY_ID                  Dot11ExtSetDefaultKeyId;
   DOT11EXT_NIC_SPECIFIC_EXTENSION              Dot11ExtNicSpecificExtension;
   DOT11EXT_SET_EXCLUDE_UNENCRYPTED             Dot11ExtSetExcludeUnencrypted;
   DOT11EXT_ONEX_START                          Dot11ExtStartOneX;
   DOT11EXT_ONEX_STOP                           Dot11ExtStopOneX;
   DOT11EXT_PROCESS_ONEX_PACKET                 Dot11ExtProcessSecurityPacket;
};




struct _DOT11EXT_IHV_HANDLERS
{
   DOT11EXTIHV_DEINIT_SERVICE                   Dot11ExtIhvDeinitService;
   DOT11EXTIHV_INIT_ADAPTER                     Dot11ExtIhvInitAdapter;
   DOT11EXTIHV_DEINIT_ADAPTER                   Dot11ExtIhvDeinitAdapter;
   DOT11EXTIHV_PERFORM_PRE_ASSOCIATE            Dot11ExtIhvPerformPreAssociate;
   DOT11EXTIHV_ADAPTER_RESET                    Dot11ExtIhvAdapterReset;
   DOT11EXTIHV_PERFORM_POST_ASSOCIATE           Dot11ExtIhvPerformPostAssociate;
   DOT11EXTIHV_STOP_POST_ASSOCIATE              Dot11ExtIhvStopPostAssociate;
   DOT11EXTIHV_VALIDATE_PROFILE                 Dot11ExtIhvValidateProfile;
   DOT11EXTIHV_PERFORM_CAPABILITY_MATCH         Dot11ExtIhvPerformCapabilityMatch;
   DOT11EXTIHV_CREATE_DISCOVERY_PROFILES        Dot11ExtIhvCreateDiscoveryProfiles;
   DOT11EXTIHV_PROCESS_SESSION_CHANGE           Dot11ExtIhvProcessSessionChange;
   DOT11EXTIHV_RECEIVE_INDICATION               Dot11ExtIhvReceiveIndication;
   DOT11EXTIHV_RECEIVE_PACKET                   Dot11ExtIhvReceivePacket;
   DOT11EXTIHV_SEND_PACKET_COMPLETION           Dot11ExtIhvSendPacketCompletion;
   DOT11EXTIHV_IS_UI_REQUEST_PENDING            Dot11ExtIhvIsUIRequestPending;
   DOT11EXTIHV_PROCESS_UI_RESPONSE              Dot11ExtIhvProcessUIResponse;
   DOT11EXTIHV_QUERY_UI_REQUEST                 Dot11ExtIhvQueryUIRequest;
   DOT11EXTIHV_ONEX_INDICATE_RESULT             Dot11ExtIhvOnexIndicateResult;
   DOT11EXTIHV_CONTROL                          Dot11ExtIhvControl;
};




#endif // __WLAN_IHV_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\winutil.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//
//--------------------------------------------------------------------------;

// Generic window handler base classes, December 1995

// Make sure that you call PrepareWindow to initialise the window after
// the object has been constructed. It is a separate method so that
// derived classes can override useful methods like MessageLoop. Also
// any derived class must call DoneWithWindow in its destructor. If it
// doesn't a message may be retrieved and call a derived class member
// function while a thread is executing the base class destructor code

#ifndef __WINUTIL__
#define __WINUTIL__

const int DEFWIDTH = 320;                    // Initial window width
const int DEFHEIGHT = 240;                   // Initial window height
const int CAPTION = 256;                     // Maximum length of caption
const int TIMELENGTH = 50;                   // Maximum length of times
const int PROFILESTR = 128;                  // Normal profile string
const WORD PALVERSION = 0x300;               // GDI palette version
const LONG PALETTE_VERSION = (LONG) 1;       // Initial palette version
const COLORREF VIDEO_COLOUR = 0;             // Defaults to black background
const HANDLE hMEMORY = (HANDLE) (-1);        // Says to open as memory file

#define WIDTH(x) ((*(x)).right - (*(x)).left)
#define HEIGHT(x) ((*(x)).bottom - (*(x)).top)
#define SHOWSTAGE TEXT("WM_SHOWSTAGE")
#define SHOWSTAGETOP TEXT("WM_SHOWSTAGETOP")
#define REALIZEPALETTE TEXT("WM_REALIZEPALETTE")

typedef struct _THRD_WINDOW_CREATE
{
    DWORD       dwExStyle;
    LPCTSTR     lpClassName;
    LPCTSTR     lpWindowName;
    DWORD       dwStyle;
    HINSTANCE   hInstance;
    LPVOID      lpParam;
    HWND        hWnd;
    HANDLE      hStartEvent;
} THRD_WINDOW_CREATE;

class AM_NOVTABLE CBaseWindow
{
protected:

    HINSTANCE m_hInstance;          // Global module instance handle
    HWND m_hwnd;                    // Handle for our window
    HDC m_hdc;                      // Device context for the window
    LONG m_Width;                   // Client window width
    LONG m_Height;                  // Client window height
    BOOL m_bActivated;              // Has the window been activated
    LPTSTR m_pClassName;            // Static string holding class name
    DWORD m_ClassStyles;            // Passed in to our constructor
    DWORD m_WindowStyles;           // Likewise the initial window styles
    DWORD m_WindowStylesEx;         // And the extended window styles
    UINT m_ShowStageMessage;        // Have the window shown with focus
    UINT m_ShowStageTop;            // Makes the window WS_EX_TOPMOST
    UINT m_RealizePalette;          // Makes us realize our new palette
    HDC m_MemoryDC;                 // Used for fast BitBlt operations
    HPALETTE m_hPalette;            // Handle to any palette we may have
    BYTE m_bNoRealize;              // Don't realize palette now
    BYTE m_bBackground;             // Should we realise in background
    BYTE m_bRealizing;              // already realizing the palette
    CCritSec m_WindowLock;          // Serialise window object access
    BOOL m_bDoGetDC;                // Should this window get a DC


    // Maps windows message procedure into C++ methods
    friend LRESULT CALLBACK WndProc(HWND hwnd,      // Window handle
                                    UINT uMsg,      // Message ID
                                    WPARAM wParam,  // First parameter
                                    LPARAM lParam); // Other parameter

    virtual LRESULT OnPaletteChange(HWND hwnd, UINT Message);

public:

    CBaseWindow(BOOL bDoGetDC = TRUE);

#ifdef DEBUG
    virtual ~CBaseWindow();
#endif

    virtual HRESULT DoneWithWindow();
    virtual HRESULT PrepareWindow();
    virtual HRESULT PrepareWindow(BOOL bCreateMsgThread);
    virtual HRESULT InactivateWindow();
    virtual HRESULT ActivateWindow();
    virtual BOOL OnSize(LONG Width, LONG Height);
    virtual BOOL OnClose();
    virtual RECT GetDefaultRect();
    virtual HRESULT UninitialiseWindow();
    virtual HRESULT InitialiseWindow(HWND hwnd);

    HRESULT CompleteConnect();
    HRESULT DoCreateWindow(BOOL bCreateMsgThread);

    HRESULT PerformanceAlignWindow();
    HRESULT DoShowWindow(LONG ShowCmd);
    void PaintWindow(BOOL bErase);
    void DoSetWindowForeground(BOOL bFocus);
    virtual HRESULT SetPalette(HPALETTE hPalette);
    void SetRealize(BOOL bRealize)
    {
        m_bNoRealize = !bRealize;
    }

    //  Jump over to the window thread to set the current palette
    HRESULT SetPalette();

    virtual HRESULT DoRealisePalette(BOOL bForceBackground = FALSE);

    virtual BOOL PossiblyEatMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
    { return FALSE; };

    // Access our window information

    LONG GetWindowWidth();
    LONG GetWindowHeight();
    HWND GetWindowHWND();
    HDC GetMemoryHDC();
    HDC GetWindowHDC();

    // This is the window procedure the derived object should override

    virtual LRESULT OnReceiveMessage(HWND hwnd,          // Window handle
                                     UINT uMsg,          // Message ID
                                     WPARAM wParam,      // First parameter
                                     LPARAM lParam);     // Other parameter

    // Must be overriden to return class and window styles

    virtual LPTSTR GetClassWindowStyles(
                            DWORD *pClassStyles,          // Class styles
                            DWORD *pWindowStyles,         // Window styles
                            DWORD *pWindowStylesEx) PURE; // Extended styles
};


// This helper class is entirely subservient to the owning CBaseWindow object
// All this object does is to split out the actual drawing operation from the
// main object (because it was becoming too large). We have a number of entry
// points to set things like the draw device contexts, to implement the actual
// drawing and to set the destination rectangle in the client window. We have
// no critical section locking in this class because we are used exclusively
// by the owning window object which looks after serialising calls into us

// If you want to use this class make sure you call NotifyAllocator once the
// allocate has been agreed, also call NotifyMediaType with a pointer to a
// NON stack based CMediaType once that has been set (we keep a pointer to
// the original rather than taking a copy). When the palette changes call
// IncrementPaletteVersion (easiest thing to do is to also call this method
// in the SetMediaType method most filters implement). Finally before you
// start rendering anything call SetDrawContext so that we can get the HDCs
// for drawing from the CBaseWindow object we are given during construction

class CDrawImage
{
protected:

    CBaseWindow *m_pBaseWindow;     // Owning video window object
    CRefTime m_StartSample;         // Start time for the current sample
    CRefTime m_EndSample;           // And likewise it's end sample time
    HDC m_hdc;                      // Main window device context
    HDC m_MemoryDC;                 // Offscreen draw device context
    RECT m_TargetRect;              // Target destination rectangle
    RECT m_SourceRect;              // Source image rectangle
    BOOL m_bStretch;                // Do we have to stretch the images
    BOOL m_bUsingImageAllocator;    // Are the samples shared DIBSECTIONs
    CMediaType *m_pMediaType;       // Pointer to the current format
    int m_perfidRenderTime;         // Time taken to render an image
    LONG m_PaletteVersion;          // Current palette version cookie

    // Draw the video images in the window

    void SlowRender(IMediaSample *pMediaSample);
    void FastRender(IMediaSample *pMediaSample);
    void DisplaySampleTimes(IMediaSample *pSample);
    void UpdateColourTable(HDC hdc,BITMAPINFOHEADER *pbmi);
    void SetStretchMode();

public:

    // Used to control the image drawing

    CDrawImage(CBaseWindow *pBaseWindow);
    BOOL DrawImage(IMediaSample *pMediaSample);
    void SetDrawContext();
    void SetTargetRect(RECT *pTargetRect);
    void SetSourceRect(RECT *pSourceRect);
    void GetTargetRect(RECT *pTargetRect);
    void GetSourceRect(RECT *pSourceRect);
    virtual RECT ScaleSourceRect(const RECT *pSource);

    // Handle updating palettes as they change

    LONG GetPaletteVersion();
    void ResetPaletteVersion();
    void IncrementPaletteVersion();

    // Tell us media types and allocator assignments

    void NotifyAllocator(BOOL bUsingImageAllocator);
    void NotifyMediaType(CMediaType *pMediaType);
    BOOL UsingImageAllocator();

    // Called when we are about to draw an image

    void NotifyStartDraw() {
        MSR_START(m_perfidRenderTime);
    };

    // Called when we complete an image rendering

    void NotifyEndDraw() {
        MSR_STOP(m_perfidRenderTime);
    };
};


// This is the structure used to keep information about each GDI DIB. All the
// samples we create from our allocator will have a DIBSECTION allocated to
// them. When we receive the sample we know we can BitBlt straight to an HDC

typedef struct tagDIBDATA {

    LONG        PaletteVersion;     // Current palette version in use
    DIBSECTION  DibSection;         // Details of DIB section allocated
    HBITMAP     hBitmap;            // Handle to bitmap for drawing
    HANDLE      hMapping;           // Handle to shared memory block
    BYTE        *pBase;             // Pointer to base memory address

} DIBDATA;


// This class inherits from CMediaSample and uses all of it's methods but it
// overrides the constructor to initialise itself with the DIBDATA structure
// When we come to render an IMediaSample we will know if we are using our own
// allocator, and if we are, we can cast the IMediaSample to a pointer to one
// of these are retrieve the DIB section information and hence the HBITMAP

class CImageSample : public CMediaSample
{
protected:

    DIBDATA m_DibData;      // Information about the DIBSECTION
    BOOL m_bInit;           // Is the DIB information setup

public:

    // Constructor

    CImageSample(CBaseAllocator *pAllocator,
                 TCHAR *pName,
                 HRESULT *phr,
                 LPBYTE pBuffer,
                 LONG length);

    // Maintain the DIB/DirectDraw state

    void SetDIBData(DIBDATA *pDibData);
    DIBDATA *GetDIBData();
};


// This is an allocator based on the abstract CBaseAllocator base class that
// allocates sample buffers in shared memory. The number and size of these
// are determined when the output pin calls Prepare on us. The shared memory
// blocks are used in subsequent calls to GDI CreateDIBSection, once that
// has been done the output pin can fill the buffers with data which will
// then be handed to GDI through BitBlt calls and thereby remove one copy

class CImageAllocator : public CBaseAllocator
{
protected:

    CBaseFilter *m_pFilter;   // Delegate reference counts to
    CMediaType *m_pMediaType;           // Pointer to the current format

    // Used to create and delete samples

    HRESULT Alloc();
    void Free();

    // Manage the shared DIBSECTION and DCI/DirectDraw buffers

    HRESULT CreateDIB(LONG InSize,DIBDATA &DibData);
    STDMETHODIMP CheckSizes(ALLOCATOR_PROPERTIES *pRequest);
    virtual CImageSample *CreateImageSample(LPBYTE pData,LONG Length);

public:

    // Constructor and destructor

    CImageAllocator(CBaseFilter *pFilter,TCHAR *pName,HRESULT *phr);
#ifdef DEBUG
    ~CImageAllocator();
#endif

    STDMETHODIMP_(ULONG) NonDelegatingAddRef();
    STDMETHODIMP_(ULONG) NonDelegatingRelease();
    void NotifyMediaType(CMediaType *pMediaType);

    // Agree the number of buffers to be used and their size

    STDMETHODIMP SetProperties(
        ALLOCATOR_PROPERTIES *pRequest,
        ALLOCATOR_PROPERTIES *pActual);
};


// This class is a fairly specialised helper class for image renderers that
// have to create and manage palettes. The CBaseWindow class looks after
// realising palettes once they have been installed. This class can be used
// to create the palette handles from a media format (which must contain a
// VIDEOINFO structure in the format block). We try to make the palette an
// identity palette to maximise performance and also only change palettes
// if actually required to (we compare palette colours before updating).
// All the methods are virtual so that they can be overriden if so required

class CImagePalette
{
protected:

    CBaseWindow *m_pBaseWindow;             // Window to realise palette in
    CBaseFilter *m_pFilter;       // Media filter to send events
    CDrawImage *m_pDrawImage;               // Object who will be drawing
    HPALETTE m_hPalette;                    // The palette handle we own

public:

    CImagePalette(CBaseFilter *pBaseFilter,
                  CBaseWindow *pBaseWindow,
                  CDrawImage *pDrawImage);

#ifdef DEBUG
    virtual ~CImagePalette();
#endif

    static HPALETTE MakePalette(const VIDEOINFOHEADER *pVideoInfo, LPTSTR szDevice);
    static HPALETTE MakePalette(const VIDEOINFOHEADER2 *pVideoInfo2, LPTSTR szDevice);
    HRESULT RemovePalette();
    static HRESULT MakeIdentityPalette(PALETTEENTRY *pEntry,INT iColours, LPTSTR szDevice);
    HRESULT CopyPalette(const CMediaType *pSrc,CMediaType *pDest);
    BOOL ShouldUpdate(const VIDEOINFOHEADER *pNewInfo,const VIDEOINFOHEADER *pOldInfo);
    BOOL ShouldUpdate(const VIDEOINFOHEADER2 *pNewInfo2,const VIDEOINFOHEADER2 *pOldInfo2);
    HRESULT PreparePalette(const CMediaType *pmtNew,const CMediaType *pmtOld,LPTSTR szDevice);

private:
    static RGBQUAD *GetBitmapPalette (const VIDEOINFO *pInput);
    static RGBQUAD *GetBitmapPalette (const VIDEOINFO2 *pInput);
    static HPALETTE MakePalette(const BITMAPINFOHEADER *pBmiHeader, const RGBQUAD *pPalette, LPTSTR szDevice);
    BOOL ShouldUpdate(const BITMAPINFOHEADER *pNewBmiHeader,
                      const BITMAPINFOHEADER *pOldBmiHeader,
                      const RGBQUAD *pNewPalette,
                      const RGBQUAD *pOldPalette);

};


// Another helper class really for video based renderers. Most such renderers
// need to know what the display format is to some degree or another. This
// class initialises itself with the display format. The format can be asked
// for through GetDisplayFormat and various other accessor functions. If a
// filter detects a display format change (perhaps it gets a WM_DEVMODECHANGE
// message then it can call RefreshDisplayType to reset that format). Also
// many video renderers will want to check formats as they are proposed by
// source filters. This class provides methods to check formats and only
// accept those video formats that can be efficiently drawn using GDI calls

class CImageDisplay : public CCritSec
{
protected:

    // This holds the display format;
    VIDEOINFO2 m_Display;

    static DWORD CountSetBits(const DWORD Field);
    static DWORD CountPrefixBits(const DWORD Field);
    static BOOL CheckBitFields(const VIDEOINFO *pInput);
    static BOOL CheckBitFields(const VIDEOINFO2 *pInput);

public:

    // Constructor and destructor

    CImageDisplay();

    // Used to manage BITMAPINFOHEADERs and the display format

    const VIDEOINFO2 *GetDisplayFormat();
    HRESULT RefreshDisplayType(LPTSTR szDeviceName);
    static BOOL CheckHeaderValidity(const VIDEOINFO *pInput);
    static BOOL CheckHeaderValidity(const VIDEOINFO2 *pInput);
    static BOOL CheckPaletteHeader(const VIDEOINFO *pInput);
    static BOOL CheckPaletteHeader(const VIDEOINFO2 *pInput);
    BOOL IsPalettised();
    WORD GetDisplayDepth();

    // Provide simple video format type checking

    HRESULT CheckMediaType(const CMediaType *pmtIn);
    HRESULT CheckVideoType(const VIDEOINFO *pInput);
    HRESULT CheckVideoType(const VIDEOINFO2 *pInput);
    HRESULT UpdateFormat(VIDEOINFO *pVideoInfo);
    HRESULT UpdateFormat(VIDEOINFO2 *pVideoInfo);
    const DWORD *GetBitMasks(const VIDEOINFO *pVideoInfo);
    const DWORD *GetBitMasks(const VIDEOINFO2 *pVideoInfo);

    BOOL GetColourMask(DWORD *pMaskRed,
                       DWORD *pMaskGreen,
                       DWORD *pMaskBlue);
private:
    static BOOL CheckBitFields(const DWORD *pBitFields);
    static BOOL CheckHeaderValidity(const BITMAPINFOHEADER *pBmiHeader, const DWORD *pBitFields);
    static BOOL CheckPaletteHeader(const BITMAPINFOHEADER *pBmiHeader);
    HRESULT CheckVideoType(const BITMAPINFOHEADER *pBmiHeader, const DWORD *pInputMask);
    HRESULT UpdateFormat(BITMAPINFOHEADER *pBmiHeader);

    RGBQUAD *GetBitmapPalette (VIDEOINFO *pInput);
    RGBQUAD *GetBitmapPalette (VIDEOINFO2 *pInput2);
};

//  Convert a FORMAT_VideoInfo to FORMAT_VideoInfo2
STDAPI ConvertVideoInfoToVideoInfo2(AM_MEDIA_TYPE *pmt);

#endif // __WINUTIL__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\wlclient.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft shared
// source or premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license agreement,
// you are not authorized to use this source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the SOURCE.RTF on your install media or the root of your tools installation.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++

Copyright (c) 2001 Microsoft Corporation


Module Name:

    wlclient.h

Abstract:

    Header file for wireless windows APIs.

Environment:

    User Level: Windows

Revision History:


--*/


#ifndef __WLCLIENT_H__
#define __WLCLIENT_H__

#pragma once

#ifndef __WINDOT11_H__
#include <windot11.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif



typedef struct _DOT11_ADAPTER {
    GUID gAdapterId;
#ifdef __midl
    [string] LPWSTR pszDescription;
#else
    LPWSTR pszDescription;
#endif
    DOT11_CURRENT_OPERATION_MODE Dot11CurrentOpMode;
} DOT11_ADAPTER, * PDOT11_ADAPTER;





typedef struct _DOT11_BSS_LIST {
    ULONG uNumOfBytes;
#ifdef __midl
    [size_is(uNumOfBytes)] PUCHAR pucBuffer;
#else
    __field_ecount_opt(uNumOfBytes) PUCHAR pucBuffer;
#endif
} DOT11_BSS_LIST, * PDOT11_BSS_LIST;





typedef struct _DOT11_PORT_STATE {
    DOT11_MAC_ADDRESS PeerMacAddress;   // Unicast mac address of the peer
    ULONG uSessionId;
    BOOL bPortControlled;               // TRUE, if the port is controlled by Security Module
    BOOL bPortAuthorized;               // TRUE, if the port is authorized for data packets
} DOT11_PORT_STATE, * PDOT11_PORT_STATE;




#include <packon.h>
typedef struct _DOT11_SECURITY_PACKET_HEADER {
    DOT11_MAC_ADDRESS PeerMac;
    USHORT usEtherType;
    UCHAR Data[1];
} DOT11_SECURITY_PACKET_HEADER, * PDOT11_SECURITY_PACKET_HEADER;
#include <packoff.h>


#ifdef __cplusplus
}
#endif

#endif // __WLCLIENT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\wliteerror.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
// **************************************************************************
// WLiteError.h
// 
// Declaration of Wisp-Lite error codes 
//
// Copyright Microsoft Corporation, All Rights Reserved
//
// **************************************************************************

#pragma once

#ifndef _WINERROR_
#include <winerror.h>
#endif

/*** TPC_E_INVALID_PROPERTY                   0x80040241    -2147220927
*   The property was not found, or supported by the recognizer.
*/
#define TPC_E_INVALID_PROPERTY                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x241)

/*** TPC_E_NO_DEFAULT_TABLET                  0x80040212    -2147220974
*   No default tablet.
*/
#define TPC_E_NO_DEFAULT_TABLET               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x212)

/*** TPC_E_UNKNOWN_PROPERTY                   0x8004021b    -2147220965
*   Unknown property specified.
*/
#define TPC_E_UNKNOWN_PROPERTY                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x21b)

/*** TPC_E_INVALID_INPUT_RECT                 0x80040219    -2147220967
*   An invalid input rectangle was specified.
*/
#define TPC_E_INVALID_INPUT_RECT              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x219)

/*** TPC_E_INVALID_STROKE                     0x80040222    -2147220958
*   The stroke object was deleted.
*/
#define TPC_E_INVALID_STROKE                  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x222)

/*** TPC_E_INITIALIZE_FAIL                    0x80040223    -2147220957
*   Initialize failure.
*/
#define TPC_E_INITIALIZE_FAIL                 MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x223)

/*** TPC_E_NOT_RELEVANT                       0x80040232    -2147220942
*   The data required for the operation was not supplied.
*/
#define TPC_E_NOT_RELEVANT                    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x232)

/*** TPC_E_RECOGNIZER_NOT_REGISTERED          0x80040235    -2147220939
*   There are no Recognizers registered.
*/
#define TPC_E_RECOGNIZER_NOT_REGISTERED       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x235)

/*** TPC_E_INVALID_RIGHTS                     0x80040236    -2147220938
*   User does not have the necessary rights to read recognizer information.
*/
#define TPC_E_INVALID_RIGHTS                  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x236)

/*** TPC_E_OUT_OF_ORDER_CALL                  0x80040237    -2147220937
*   API calls were made in an incorrect order.
*/
#define TPC_E_OUT_OF_ORDER_CALL               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x237)

#define FACILITY_INK      40
#define INK_ERROR_BASE    0x0000

#define MAKE_INK_HRESULT(sev, err) MAKE_HRESULT(sev,FACILITY_INK,err)
#define MAKE_INK_ERROR(err)        MAKE_INK_HRESULT(SEVERITY_ERROR,err+INK_ERROR_BASE)
#define MAKE_INK_SCODE(scode)      MAKE_INK_HRESULT(SEVERITY_SUCCESS,scode+INK_ERROR_BASE)

// IErrorInfo helper for objects that support error info (CLSID_IFoo && IID_IFoo)
#define MAKE_OBJ_ERROR_INFO( ID, hr, helpid, helpfile )     \
            AtlReportError( CLSID_##ID , IDS_##hr,          \
                            helpid, helpfile,               \
                            IID_I##ID, hr,                  \
                            _Module.GetModuleInstance())

// IErrorInfo helper for interfaces that support error info, but are not cocreatable
//      (e.g. IID_IFoo, but NOT CLSID_IFoo)
#define MAKE_INT_ERROR_INFO( ID, hr, helpid, helpfile )     \
            AtlReportError( GUID_NULL , IDS_##hr,           \
                            helpid, helpfile,               \
                            IID_I##ID, hr,                  \
                            _Module.GetModuleInstance())

/*** E_INK_EXCEPTION                                   0x80280001    -2144862207
*   An internal exception occurred while executing the method or property.
*/
#define E_INK_EXCEPTION                                MAKE_INK_ERROR(0x001)

/*** E_INK_MISMATCHED_INK_OBJECT                       0x80280002    -2144862206
*   The object is already associated with an ink object and cannot be reassociated.
*/
#define E_INK_MISMATCHED_INK_OBJECT                    MAKE_INK_ERROR(0x002)

/*** E_INK_COLLECTOR_BUSY                              0x80280003    -2144862205
*   The operation cannot be performed while the user is actively inking.
*/
#define E_INK_COLLECTOR_BUSY                           MAKE_INK_ERROR(0x003)

/*** E_INK_INCOMPATIBLE_OBJECT                          0x80280004    -2144862204
*   The interface pointer points to an object that is incompatible with the Ink API
*/
#define E_INK_INCOMPATIBLE_OBJECT                      MAKE_INK_ERROR(0x004)

/*** E_INK_WINDOW_NOT_SET                              0x80280005    -2144862203
*   The window handle must be set before ink collection can occur.
*/
#define E_INK_WINDOW_NOT_SET                           MAKE_INK_ERROR(0x005)

/*** E_INK_INVALID_MODE                                0x80280006    -2144862202
*   The InkCollector must be gesture mode for gesture features,
            and single tablet mode for single tablet features.
*/
#define E_INK_INVALID_MODE                             MAKE_INK_ERROR(0x006)

/*** E_INK_COLLECTOR_ENABLED                           0x80280007    -2144862201
*   The operation cannot be performed while the InkCollector is enabled.
*/
#define E_INK_COLLECTOR_ENABLED                        MAKE_INK_ERROR(0x007)

/*** E_INK_NO_STROKES_TO_RECOGNIZE                     0x80280008    -2144862200
*   There are no strokes for the recognizer to process.
*/
#define E_INK_NO_STROKES_TO_RECOGNIZE                  MAKE_INK_ERROR(0x008)

/*** E_INK_EMPTY_RECOGNITION_RESULT                    0x80280009    -2144862199
*   There are no strokes for the recognizer to process.
*/
#define E_INK_EMPTY_RECOGNITION_RESULT                 MAKE_INK_ERROR(0x009)

/*** E_INK_OVERLAPPING_INPUT_RECT                    0x80280010    -2144862192
*   "The window input rectangle overlaps with an enabled InkCollector's window input rectangle."
*/
#define E_INK_OVERLAPPING_INPUT_RECT                   MAKE_INK_ERROR(0x010)


// Recognizer Engine Driver Error Codes

/*** TPC_E_INVALID_PACKET_DESCRIPTION         0x80040233    -2147220941
*   Invalid packet description.
*/
#define TPC_E_INVALID_PACKET_DESCRIPTION      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x233)

#define TPC_E_INSUFFICIENT_BUFFER             __HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)

//
// Definition of Success codes
// 
#define TPC_S_TRUNCATED                       MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 0x252)
#define TPC_S_INTERRUPTED                     MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 0x253)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\wmcodecids.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//+-------------------------------------------------------------------------
//
//  Microsoft Windows Media
//
//
//  File:       wmcodecids.h
//
//--------------------------------------------------------------------------

#ifndef __WMCODECIDS_H_
#define __WMCODECIDS_H_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


//
// DMO CLSIDs for Windows Media Codecs
//

EXTERN_GUID(CLSID_CWMADecMediaObject,  0x2eeb4adf, 0x4578, 0x4d10, 0xbc, 0xa7, 0xbb, 0x95, 0x5f, 0x56, 0x32, 0x0a);
EXTERN_GUID(CLSID_CWMSDecMediaObject,  0x874131cb, 0x4ecc, 0x443b, 0x89, 0x48, 0x74, 0x6b, 0x89, 0x59, 0x5d, 0x20);
EXTERN_GUID(CLSID_CWMV9EncMediaObject, 0xd23b90d0, 0x144f, 0x46bd, 0x84, 0x1d, 0x59, 0xe4, 0xeb, 0x19, 0xdc, 0x59);
EXTERN_GUID(CLSID_CWMVDecMediaObject,  0x82d353df, 0x90bd, 0x4382, 0x8b, 0xc2, 0x3f, 0x61, 0x92, 0xb7, 0x6e, 0x34);

//
// DMO Filter CLSIDs for Windows Media Codecs
//
EXTERN_GUID(CLSID_CWMAFILTERObject, 0x5bae8e20, 0xd112, 0x4637, 0xb6, 0x03, 0xb4, 0x84, 0x1f, 0xa7, 0x1d, 0x78);
EXTERN_GUID(CLSID_CWMSFILTERObject, 0x521FB373, 0x7654, 0x49F2, 0xBD, 0xB1, 0x0C, 0x6E, 0x66, 0x60, 0x71, 0x4F);
EXTERN_GUID(CLSID_CWMVFilterObject, 0x3ff9f0d8, 0x2ccc, 0x472f, 0xb5, 0x3f, 0xbf, 0x5c, 0xa5, 0x73, 0x1a, 0x39);
EXTERN_GUID(CLSID_CWMV9EncFilterObject, 0x651b4f0a, 0x4340, 0x4526, 0xab, 0xb0, 0x90, 0x87, 0x9e, 0x9b, 0x5, 0x5a);

#endif  // !defined(__WMCODECIDS_H_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\wmcodectypes.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//+-------------------------------------------------------------------------
//
//  Microsoft Windows Media
//
//
//  File:       wmcodectypes.h
//
//--------------------------------------------------------------------------

#ifndef __WMCODECTYPES_H__
#define __WMCODECTYPES_H__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <mmreg.h>

//
// FOURCC codes for Windows Media Codecs
//

#define FOURCC_WMV1     mmioFOURCC('W','M','V','1')
#define FOURCC_wmv1     mmioFOURCC('w','m','v','1')
#define FOURCC_WMV2     mmioFOURCC('W','M','V','2')
#define FOURCC_wmv2     mmioFOURCC('w','m','v','2')
#define FOURCC_WMV3     mmioFOURCC('W','M','V','3')
#define FOURCC_wmv3     mmioFOURCC('w','m','v','3')
#define FOURCC_WMVP     mmioFOURCC('W','M','V','P')
#define FOURCC_wmvp     mmioFOURCC('w','m','v','p')
#define FOURCC_WMVA     mmioFOURCC('W','M','V','A')
#define FOURCC_wmva     mmioFOURCC('w','m','v','a')
#define FOURCC_WVP2     mmioFOURCC('W','V','P','2')
#define FOURCC_wvp2     mmioFOURCC('w','v','p','2')
#define FOURCC_MPG4     mmioFOURCC('M','P','G','4')
#define FOURCC_mpg4     mmioFOURCC('m','p','g','4')
#define FOURCC_MP42     mmioFOURCC('M','P','4','2')
#define FOURCC_mp42     mmioFOURCC('m','p','4','2')
#define FOURCC_MP43     mmioFOURCC('M','P','4','3')
#define FOURCC_mp43     mmioFOURCC('m','p','4','3')
#define FOURCC_MP4S     mmioFOURCC('M','P','4','S')
#define FOURCC_mp4s     mmioFOURCC('m','p','4','s')
#define FOURCC_M4S2     mmioFOURCC('M','4','S','2')
#define FOURCC_m4s2     mmioFOURCC('m','4','s','2')
// these aren't used anywhere??
#define FOURCC_MSS1     mmioFOURCC('M','S','S','1')
#define FOURCC_mss1     mmioFOURCC('m','s','s','1')
#define FOURCC_MSS2     mmioFOURCC('M','S','S','2')

#define FOURCC_WVC1     mmioFOURCC('W','V','C','1')
#define FOURCC_wvc1     mmioFOURCC('w','v','c','1')


//
// MEDIASUBTYPE GUIDs for Windows Media Codecs
//

EXTERN_GUID(MEDIASUBTYPE_WMV1,
FOURCC_WMV1, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);

EXTERN_GUID(MEDIASUBTYPE_wmv1,
FOURCC_wmv1, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);

EXTERN_GUID(MEDIASUBTYPE_WMV2,
FOURCC_WMV2, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);

EXTERN_GUID(MEDIASUBTYPE_wmv2,
FOURCC_wmv2, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);

EXTERN_GUID(MEDIASUBTYPE_WMV3,
FOURCC_WMV3, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);

EXTERN_GUID(MEDIASUBTYPE_wmv3,
FOURCC_wmv3, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);

EXTERN_GUID(MEDIASUBTYPE_WMVP,
FOURCC_WMVP, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);

EXTERN_GUID(MEDIASUBTYPE_wmvp,
FOURCC_wmvp, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);

EXTERN_GUID(MEDIASUBTYPE_WMVA,
FOURCC_WMVA, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);

EXTERN_GUID(MEDIASUBTYPE_wmva,
FOURCC_wmva, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);

EXTERN_GUID(MEDIASUBTYPE_WVP2,
FOURCC_WVP2, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);

EXTERN_GUID(MEDIASUBTYPE_wvp2,
FOURCC_wvp2, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);

EXTERN_GUID(MEDIASUBTYPE_MPG4,
FOURCC_MPG4, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);

EXTERN_GUID(MEDIASUBTYPE_mpg4,
FOURCC_mpg4, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);

EXTERN_GUID(MEDIASUBTYPE_MP42,
FOURCC_MP42, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);

EXTERN_GUID(MEDIASUBTYPE_mp42,
FOURCC_mp42, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);

EXTERN_GUID(MEDIASUBTYPE_MP43,
FOURCC_MP43, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);

EXTERN_GUID(MEDIASUBTYPE_mp43,
FOURCC_mp43, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);

EXTERN_GUID(MEDIASUBTYPE_MP4S,
FOURCC_MP4S, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);

EXTERN_GUID(MEDIASUBTYPE_mp4s,
FOURCC_mp4s, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);

EXTERN_GUID(MEDIASUBTYPE_WMAVOICE9,
WAVE_FORMAT_WMAVOICE9, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);

EXTERN_GUID(MEDIASUBTYPE_MSAUDIO1,
WAVE_FORMAT_MSAUDIO1, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);

EXTERN_GUID(MEDIASUBTYPE_WMAUDIO2,
WAVE_FORMAT_WMAUDIO2, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);

EXTERN_GUID(MEDIASUBTYPE_WMAUDIO3,
WAVE_FORMAT_WMAUDIO3, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);

EXTERN_GUID(MEDIASUBTYPE_WMAUDIO_LOSSLESS,
WAVE_FORMAT_WMAUDIO_LOSSLESS, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);

DEFINE_GUID(MEDIASUBTYPE_WVC1,
FOURCC_WVC1, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);

DEFINE_GUID(MEDIASUBTYPE_wvc1,
FOURCC_wvc1, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);


#endif //__WMCODECTYPES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\wmcodecstrs.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//+-------------------------------------------------------------------------
//
//  Microsoft Windows Media
//
//
//  File:       wmcodecstrs.h
//
//--------------------------------------------------------------------------

#ifndef __WMCODECSTRS_H_
#define __WMCODECSTRS_H_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


//
// Configuration options for Windows Media Video Codecs
//

#if defined (_X86_) || defined (_ARM_)
static const WCHAR *g_wszWMVCBitRate = L"_BITRATE";
#else
static const WCHAR *g_wszWMVCComplexityEx = L"_COMPLEXITYEX";
static const WCHAR *g_wszWMVCVBRQuality = L"_VBRQUALITY";
#endif
static const WCHAR *g_wszWMVCKeyframeDistance = L"_KEYDIST";
static const WCHAR *g_wszWMVCCrisp = L"_CRISP";
static const WCHAR *g_wszWMVCAvgFrameRate = L"_AVGFRAMERATE";
static const WCHAR *g_wszWMVCWidth = L"_WIDTH";
static const WCHAR *g_wszWMVCHeight = L"_HEIGHT";

#endif  // !defined(__WMCODECSTRS_H_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\wmcontainerpriv.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0543 */
/* Compiler settings for wmcontainerpriv.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wmcontainerpriv_h__
#define __wmcontainerpriv_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IMFASFContentInfoPriv_FWD_DEFINED__
#define __IMFASFContentInfoPriv_FWD_DEFINED__
typedef interface IMFASFContentInfoPriv IMFASFContentInfoPriv;
#endif 	/* __IMFASFContentInfoPriv_FWD_DEFINED__ */


#ifndef __IMFASFBandwidthSharing_FWD_DEFINED__
#define __IMFASFBandwidthSharing_FWD_DEFINED__
typedef interface IMFASFBandwidthSharing IMFASFBandwidthSharing;
#endif 	/* __IMFASFBandwidthSharing_FWD_DEFINED__ */


#ifndef __IMFASFMultiplexerHelperPriv_FWD_DEFINED__
#define __IMFASFMultiplexerHelperPriv_FWD_DEFINED__
typedef interface IMFASFMultiplexerHelperPriv IMFASFMultiplexerHelperPriv;
#endif 	/* __IMFASFMultiplexerHelperPriv_FWD_DEFINED__ */


/* header files for imported files */
#include "asfparse.h"
#include "wmcontainer.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_wmcontainerpriv_0000_0000 */
/* [local] */ 

EXTERN_GUID(MF_ASFPROFILEPRIV_ASFOBJECTS, 0x44d42a2, 0x2faa, 0x4c7d, 0xab, 0x13, 0xc9, 0x86, 0xce, 0xfd, 0x78, 0x1f);
EXTERN_GUID(MF_ASFSTREAMCONFIGPRIV_FLAGS, 0xc5cdd5d1, 0x3fe7, 0x41a7, 0x92, 0xcf, 0x66, 0xe6, 0x18, 0xa4, 0xd2, 0xde);
EXTERN_GUID(MF_ASFSTREAMCONFIGPRIV_PAYLOADEXTS, 0xc5cdd5d2, 0x3fe7, 0x41a7, 0x92, 0xcf, 0x66, 0xe6, 0x18, 0xa4, 0xd2, 0xde);
EXTERN_C const PROPERTYKEY MFPKEY_BITMAPINFOHEADER_ExtraData;


extern RPC_IF_HANDLE __MIDL_itf_wmcontainerpriv_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmcontainerpriv_0000_0000_v0_0_s_ifspec;

#ifndef __IMFASFContentInfoPriv_INTERFACE_DEFINED__
#define __IMFASFContentInfoPriv_INTERFACE_DEFINED__

/* interface IMFASFContentInfoPriv */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFASFContentInfoPriv;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("12558296-E399-11D5-BC2A-00B0D0F3F4AB")
    IMFASFContentInfoPriv : public IMFASFContentInfo
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetASFLibrary( 
            /* [out] */ IASFLibrary **ppILibrary) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFASFContentInfoPrivVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFASFContentInfoPriv * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFASFContentInfoPriv * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFASFContentInfoPriv * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetHeaderSize )( 
            IMFASFContentInfoPriv * This,
            /* [in] */ IMFMediaBuffer *pIStartOfContent,
            /* [out] */ QWORD *cbHeaderSize);
        
        HRESULT ( STDMETHODCALLTYPE *ParseHeader )( 
            IMFASFContentInfoPriv * This,
            /* [in] */ IMFMediaBuffer *pIHeaderBuffer,
            /* [in] */ QWORD cbOffsetWithinHeader);
        
        HRESULT ( STDMETHODCALLTYPE *GenerateHeader )( 
            IMFASFContentInfoPriv * This,
            /* [out][in] */ IMFMediaBuffer *pIHeader,
            /* [out] */ DWORD *pcbHeader);
        
        HRESULT ( STDMETHODCALLTYPE *GetProfile )( 
            IMFASFContentInfoPriv * This,
            /* [out] */ IMFASFProfile **ppIProfile);
        
        HRESULT ( STDMETHODCALLTYPE *SetProfile )( 
            IMFASFContentInfoPriv * This,
            /* [in] */ IMFASFProfile *pIProfile);
        
        HRESULT ( STDMETHODCALLTYPE *GeneratePresentationDescriptor )( 
            IMFASFContentInfoPriv * This,
            /* [out] */ IMFPresentationDescriptor **ppIPresentationDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *GetEncodingConfigurationPropertyStore )( 
            IMFASFContentInfoPriv * This,
            /* [in] */ WORD wStreamNumber,
            /* [out] */ IPropertyStore **ppIStore);
        
        HRESULT ( STDMETHODCALLTYPE *GetASFLibrary )( 
            IMFASFContentInfoPriv * This,
            /* [out] */ IASFLibrary **ppILibrary);
        
        END_INTERFACE
    } IMFASFContentInfoPrivVtbl;

    interface IMFASFContentInfoPriv
    {
        CONST_VTBL struct IMFASFContentInfoPrivVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFASFContentInfoPriv_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFASFContentInfoPriv_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFASFContentInfoPriv_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFASFContentInfoPriv_GetHeaderSize(This,pIStartOfContent,cbHeaderSize)	\
    ( (This)->lpVtbl -> GetHeaderSize(This,pIStartOfContent,cbHeaderSize) ) 

#define IMFASFContentInfoPriv_ParseHeader(This,pIHeaderBuffer,cbOffsetWithinHeader)	\
    ( (This)->lpVtbl -> ParseHeader(This,pIHeaderBuffer,cbOffsetWithinHeader) ) 

#define IMFASFContentInfoPriv_GenerateHeader(This,pIHeader,pcbHeader)	\
    ( (This)->lpVtbl -> GenerateHeader(This,pIHeader,pcbHeader) ) 

#define IMFASFContentInfoPriv_GetProfile(This,ppIProfile)	\
    ( (This)->lpVtbl -> GetProfile(This,ppIProfile) ) 

#define IMFASFContentInfoPriv_SetProfile(This,pIProfile)	\
    ( (This)->lpVtbl -> SetProfile(This,pIProfile) ) 

#define IMFASFContentInfoPriv_GeneratePresentationDescriptor(This,ppIPresentationDescriptor)	\
    ( (This)->lpVtbl -> GeneratePresentationDescriptor(This,ppIPresentationDescriptor) ) 

#define IMFASFContentInfoPriv_GetEncodingConfigurationPropertyStore(This,wStreamNumber,ppIStore)	\
    ( (This)->lpVtbl -> GetEncodingConfigurationPropertyStore(This,wStreamNumber,ppIStore) ) 


#define IMFASFContentInfoPriv_GetASFLibrary(This,ppILibrary)	\
    ( (This)->lpVtbl -> GetASFLibrary(This,ppILibrary) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFASFContentInfoPriv_INTERFACE_DEFINED__ */


#ifndef __IMFASFBandwidthSharing_INTERFACE_DEFINED__
#define __IMFASFBandwidthSharing_INTERFACE_DEFINED__

/* interface IMFASFBandwidthSharing */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFASFBandwidthSharing;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("12558292-E399-11D5-BC2A-00B0D0F3F4AB")
    IMFASFBandwidthSharing : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ GUID *pguidType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetType( 
            /* [in] */ REFGUID guidType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBandwidth( 
            /* [out] */ DWORD *pdwBitrate,
            /* [out] */ DWORD *pdwMsBufferWindow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBandwidth( 
            /* [in] */ DWORD dwBitrate,
            /* [in] */ DWORD dwMsBufferWindow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreams( 
            /* [out] */ WORD *pwStreamNumArray,
            /* [out][in] */ DWORD *pcStreams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddStream( 
            /* [in] */ WORD wStreamNum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveStream( 
            /* [in] */ WORD wStreamNum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IMFASFBandwidthSharing **ppIBandwidthShare) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFASFBandwidthSharingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFASFBandwidthSharing * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFASFBandwidthSharing * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFASFBandwidthSharing * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            IMFASFBandwidthSharing * This,
            /* [out] */ GUID *pguidType);
        
        HRESULT ( STDMETHODCALLTYPE *SetType )( 
            IMFASFBandwidthSharing * This,
            /* [in] */ REFGUID guidType);
        
        HRESULT ( STDMETHODCALLTYPE *GetBandwidth )( 
            IMFASFBandwidthSharing * This,
            /* [out] */ DWORD *pdwBitrate,
            /* [out] */ DWORD *pdwMsBufferWindow);
        
        HRESULT ( STDMETHODCALLTYPE *SetBandwidth )( 
            IMFASFBandwidthSharing * This,
            /* [in] */ DWORD dwBitrate,
            /* [in] */ DWORD dwMsBufferWindow);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreams )( 
            IMFASFBandwidthSharing * This,
            /* [out] */ WORD *pwStreamNumArray,
            /* [out][in] */ DWORD *pcStreams);
        
        HRESULT ( STDMETHODCALLTYPE *AddStream )( 
            IMFASFBandwidthSharing * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveStream )( 
            IMFASFBandwidthSharing * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IMFASFBandwidthSharing * This,
            /* [out] */ IMFASFBandwidthSharing **ppIBandwidthShare);
        
        END_INTERFACE
    } IMFASFBandwidthSharingVtbl;

    interface IMFASFBandwidthSharing
    {
        CONST_VTBL struct IMFASFBandwidthSharingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFASFBandwidthSharing_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFASFBandwidthSharing_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFASFBandwidthSharing_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFASFBandwidthSharing_GetType(This,pguidType)	\
    ( (This)->lpVtbl -> GetType(This,pguidType) ) 

#define IMFASFBandwidthSharing_SetType(This,guidType)	\
    ( (This)->lpVtbl -> SetType(This,guidType) ) 

#define IMFASFBandwidthSharing_GetBandwidth(This,pdwBitrate,pdwMsBufferWindow)	\
    ( (This)->lpVtbl -> GetBandwidth(This,pdwBitrate,pdwMsBufferWindow) ) 

#define IMFASFBandwidthSharing_SetBandwidth(This,dwBitrate,dwMsBufferWindow)	\
    ( (This)->lpVtbl -> SetBandwidth(This,dwBitrate,dwMsBufferWindow) ) 

#define IMFASFBandwidthSharing_GetStreams(This,pwStreamNumArray,pcStreams)	\
    ( (This)->lpVtbl -> GetStreams(This,pwStreamNumArray,pcStreams) ) 

#define IMFASFBandwidthSharing_AddStream(This,wStreamNum)	\
    ( (This)->lpVtbl -> AddStream(This,wStreamNum) ) 

#define IMFASFBandwidthSharing_RemoveStream(This,wStreamNum)	\
    ( (This)->lpVtbl -> RemoveStream(This,wStreamNum) ) 

#define IMFASFBandwidthSharing_Clone(This,ppIBandwidthShare)	\
    ( (This)->lpVtbl -> Clone(This,ppIBandwidthShare) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFASFBandwidthSharing_INTERFACE_DEFINED__ */


#ifndef __IMFASFMultiplexerHelperPriv_INTERFACE_DEFINED__
#define __IMFASFMultiplexerHelperPriv_INTERFACE_DEFINED__

/* interface IMFASFMultiplexerHelperPriv */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFASFMultiplexerHelperPriv;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8E0C289D-FD04-44c1-A9B3-00330FADDC2C")
    IMFASFMultiplexerHelperPriv : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ResetLeakyBucket( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFASFMultiplexerHelperPrivVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFASFMultiplexerHelperPriv * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFASFMultiplexerHelperPriv * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFASFMultiplexerHelperPriv * This);
        
        HRESULT ( STDMETHODCALLTYPE *ResetLeakyBucket )( 
            IMFASFMultiplexerHelperPriv * This);
        
        END_INTERFACE
    } IMFASFMultiplexerHelperPrivVtbl;

    interface IMFASFMultiplexerHelperPriv
    {
        CONST_VTBL struct IMFASFMultiplexerHelperPrivVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFASFMultiplexerHelperPriv_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFASFMultiplexerHelperPriv_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFASFMultiplexerHelperPriv_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFASFMultiplexerHelperPriv_ResetLeakyBucket(This)	\
    ( (This)->lpVtbl -> ResetLeakyBucket(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFASFMultiplexerHelperPriv_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wmcontainerpriv_0000_0003 */
/* [local] */ 

EXTERN_C const GUID MFASFBWSharingType_Exclusive;
EXTERN_C const GUID MFASFBWSharingType_Partial;


extern RPC_IF_HANDLE __MIDL_itf_wmcontainerpriv_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmcontainerpriv_0000_0003_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\wmcontainer.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0543 */
/* Compiler settings for wmcontainer.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wmcontainer_h__
#define __wmcontainer_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IMFASFContentInfo_FWD_DEFINED__
#define __IMFASFContentInfo_FWD_DEFINED__
typedef interface IMFASFContentInfo IMFASFContentInfo;
#endif 	/* __IMFASFContentInfo_FWD_DEFINED__ */


#ifndef __IMFASFProfile_FWD_DEFINED__
#define __IMFASFProfile_FWD_DEFINED__
typedef interface IMFASFProfile IMFASFProfile;
#endif 	/* __IMFASFProfile_FWD_DEFINED__ */


#ifndef __IMFASFStreamConfig_FWD_DEFINED__
#define __IMFASFStreamConfig_FWD_DEFINED__
typedef interface IMFASFStreamConfig IMFASFStreamConfig;
#endif 	/* __IMFASFStreamConfig_FWD_DEFINED__ */


#ifndef __IMFASFMutualExclusion_FWD_DEFINED__
#define __IMFASFMutualExclusion_FWD_DEFINED__
typedef interface IMFASFMutualExclusion IMFASFMutualExclusion;
#endif 	/* __IMFASFMutualExclusion_FWD_DEFINED__ */


#ifndef __IMFASFStreamPrioritization_FWD_DEFINED__
#define __IMFASFStreamPrioritization_FWD_DEFINED__
typedef interface IMFASFStreamPrioritization IMFASFStreamPrioritization;
#endif 	/* __IMFASFStreamPrioritization_FWD_DEFINED__ */


#ifndef __IMFASFSplitter_FWD_DEFINED__
#define __IMFASFSplitter_FWD_DEFINED__
typedef interface IMFASFSplitter IMFASFSplitter;
#endif 	/* __IMFASFSplitter_FWD_DEFINED__ */


#ifndef __IMFASFMultiplexer_FWD_DEFINED__
#define __IMFASFMultiplexer_FWD_DEFINED__
typedef interface IMFASFMultiplexer IMFASFMultiplexer;
#endif 	/* __IMFASFMultiplexer_FWD_DEFINED__ */


#ifndef __IMFASFIndexer_FWD_DEFINED__
#define __IMFASFIndexer_FWD_DEFINED__
typedef interface IMFASFIndexer IMFASFIndexer;
#endif 	/* __IMFASFIndexer_FWD_DEFINED__ */


#ifndef __IMFASFStreamSelector_FWD_DEFINED__
#define __IMFASFStreamSelector_FWD_DEFINED__
typedef interface IMFASFStreamSelector IMFASFStreamSelector;
#endif 	/* __IMFASFStreamSelector_FWD_DEFINED__ */


#ifndef __IMFDRMNetHelper_FWD_DEFINED__
#define __IMFDRMNetHelper_FWD_DEFINED__
typedef interface IMFDRMNetHelper IMFDRMNetHelper;
#endif 	/* __IMFDRMNetHelper_FWD_DEFINED__ */


/* header files for imported files */
#include "mfidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_wmcontainer_0000_0000 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_wmcontainer_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmcontainer_0000_0000_v0_0_s_ifspec;

#ifndef __IMFASFContentInfo_INTERFACE_DEFINED__
#define __IMFASFContentInfo_INTERFACE_DEFINED__

/* interface IMFASFContentInfo */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFASFContentInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B1DCA5CD-D5DA-4451-8E9E-DB5C59914EAD")
    IMFASFContentInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetHeaderSize( 
            /* [in] */ IMFMediaBuffer *pIStartOfContent,
            /* [out] */ QWORD *cbHeaderSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ParseHeader( 
            /* [in] */ IMFMediaBuffer *pIHeaderBuffer,
            /* [in] */ QWORD cbOffsetWithinHeader) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GenerateHeader( 
            /* [out][in] */ IMFMediaBuffer *pIHeader,
            /* [out] */ DWORD *pcbHeader) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProfile( 
            /* [out] */ IMFASFProfile **ppIProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProfile( 
            /* [in] */ IMFASFProfile *pIProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GeneratePresentationDescriptor( 
            /* [out] */ IMFPresentationDescriptor **ppIPresentationDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEncodingConfigurationPropertyStore( 
            /* [in] */ WORD wStreamNumber,
            /* [out] */ IPropertyStore **ppIStore) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFASFContentInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFASFContentInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFASFContentInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFASFContentInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetHeaderSize )( 
            IMFASFContentInfo * This,
            /* [in] */ IMFMediaBuffer *pIStartOfContent,
            /* [out] */ QWORD *cbHeaderSize);
        
        HRESULT ( STDMETHODCALLTYPE *ParseHeader )( 
            IMFASFContentInfo * This,
            /* [in] */ IMFMediaBuffer *pIHeaderBuffer,
            /* [in] */ QWORD cbOffsetWithinHeader);
        
        HRESULT ( STDMETHODCALLTYPE *GenerateHeader )( 
            IMFASFContentInfo * This,
            /* [out][in] */ IMFMediaBuffer *pIHeader,
            /* [out] */ DWORD *pcbHeader);
        
        HRESULT ( STDMETHODCALLTYPE *GetProfile )( 
            IMFASFContentInfo * This,
            /* [out] */ IMFASFProfile **ppIProfile);
        
        HRESULT ( STDMETHODCALLTYPE *SetProfile )( 
            IMFASFContentInfo * This,
            /* [in] */ IMFASFProfile *pIProfile);
        
        HRESULT ( STDMETHODCALLTYPE *GeneratePresentationDescriptor )( 
            IMFASFContentInfo * This,
            /* [out] */ IMFPresentationDescriptor **ppIPresentationDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *GetEncodingConfigurationPropertyStore )( 
            IMFASFContentInfo * This,
            /* [in] */ WORD wStreamNumber,
            /* [out] */ IPropertyStore **ppIStore);
        
        END_INTERFACE
    } IMFASFContentInfoVtbl;

    interface IMFASFContentInfo
    {
        CONST_VTBL struct IMFASFContentInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFASFContentInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFASFContentInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFASFContentInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFASFContentInfo_GetHeaderSize(This,pIStartOfContent,cbHeaderSize)	\
    ( (This)->lpVtbl -> GetHeaderSize(This,pIStartOfContent,cbHeaderSize) ) 

#define IMFASFContentInfo_ParseHeader(This,pIHeaderBuffer,cbOffsetWithinHeader)	\
    ( (This)->lpVtbl -> ParseHeader(This,pIHeaderBuffer,cbOffsetWithinHeader) ) 

#define IMFASFContentInfo_GenerateHeader(This,pIHeader,pcbHeader)	\
    ( (This)->lpVtbl -> GenerateHeader(This,pIHeader,pcbHeader) ) 

#define IMFASFContentInfo_GetProfile(This,ppIProfile)	\
    ( (This)->lpVtbl -> GetProfile(This,ppIProfile) ) 

#define IMFASFContentInfo_SetProfile(This,pIProfile)	\
    ( (This)->lpVtbl -> SetProfile(This,pIProfile) ) 

#define IMFASFContentInfo_GeneratePresentationDescriptor(This,ppIPresentationDescriptor)	\
    ( (This)->lpVtbl -> GeneratePresentationDescriptor(This,ppIPresentationDescriptor) ) 

#define IMFASFContentInfo_GetEncodingConfigurationPropertyStore(This,wStreamNumber,ppIStore)	\
    ( (This)->lpVtbl -> GetEncodingConfigurationPropertyStore(This,wStreamNumber,ppIStore) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFASFContentInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wmcontainer_0000_0001 */
/* [local] */ 

STDAPI MFCreateASFContentInfo( 
        /* out */     IMFASFContentInfo     **ppIContentInfo);
#define MFASF_MIN_HEADER_BYTES ( sizeof( GUID ) + sizeof( QWORD ) )
EXTERN_GUID(MF_PD_ASF_FILEPROPERTIES_FILE_ID, 0x3de649b4, 0xd76d, 0x4e66, 0x9e, 0xc9, 0x78, 0x12, 0xf, 0xb4, 0xc7, 0xe3);
EXTERN_GUID(MF_PD_ASF_FILEPROPERTIES_CREATION_TIME, 0x3de649b6, 0xd76d, 0x4e66, 0x9e, 0xc9, 0x78, 0x12, 0xf, 0xb4, 0xc7, 0xe3);
EXTERN_GUID(MF_PD_ASF_FILEPROPERTIES_PACKETS, 0x3de649b7, 0xd76d, 0x4e66, 0x9e, 0xc9, 0x78, 0x12, 0xf, 0xb4, 0xc7, 0xe3);
EXTERN_GUID(MF_PD_ASF_FILEPROPERTIES_PLAY_DURATION, 0x3de649b8, 0xd76d, 0x4e66, 0x9e, 0xc9, 0x78, 0x12, 0xf, 0xb4, 0xc7, 0xe3);
EXTERN_GUID(MF_PD_ASF_FILEPROPERTIES_SEND_DURATION, 0x3de649b9, 0xd76d, 0x4e66, 0x9e, 0xc9, 0x78, 0x12, 0xf, 0xb4, 0xc7, 0xe3);
EXTERN_GUID(MF_PD_ASF_FILEPROPERTIES_PREROLL, 0x3de649ba, 0xd76d, 0x4e66, 0x9e, 0xc9, 0x78, 0x12, 0xf, 0xb4, 0xc7, 0xe3);
EXTERN_GUID(MF_PD_ASF_FILEPROPERTIES_FLAGS, 0x3de649bb, 0xd76d, 0x4e66, 0x9e, 0xc9, 0x78, 0x12, 0xf, 0xb4, 0xc7, 0xe3);
EXTERN_GUID(MF_PD_ASF_FILEPROPERTIES_MIN_PACKET_SIZE, 0x3de649bc, 0xd76d, 0x4e66, 0x9e, 0xc9, 0x78, 0x12, 0xf, 0xb4, 0xc7, 0xe3);
EXTERN_GUID(MF_PD_ASF_FILEPROPERTIES_MAX_PACKET_SIZE, 0x3de649bd, 0xd76d, 0x4e66, 0x9e, 0xc9, 0x78, 0x12, 0xf, 0xb4, 0xc7, 0xe3);
EXTERN_GUID(MF_PD_ASF_FILEPROPERTIES_MAX_BITRATE, 0x3de649be, 0xd76d, 0x4e66, 0x9e, 0xc9, 0x78, 0x12, 0xf, 0xb4, 0xc7, 0xe3);
EXTERN_GUID(MF_PD_ASF_CONTENTENCRYPTION_TYPE, 0x8520fe3d, 0x277e, 0x46ea, 0x99, 0xe4, 0xe3, 0xa, 0x86, 0xdb, 0x12, 0xbe);
EXTERN_GUID(MF_PD_ASF_CONTENTENCRYPTION_KEYID, 0x8520fe3e, 0x277e, 0x46ea, 0x99, 0xe4, 0xe3, 0xa, 0x86, 0xdb, 0x12, 0xbe);
EXTERN_GUID(MF_PD_ASF_CONTENTENCRYPTION_SECRET_DATA, 0x8520fe3f, 0x277e, 0x46ea, 0x99, 0xe4, 0xe3, 0xa, 0x86, 0xdb, 0x12, 0xbe);
EXTERN_GUID(MF_PD_ASF_CONTENTENCRYPTION_LICENSE_URL, 0x8520fe40, 0x277e, 0x46ea, 0x99, 0xe4, 0xe3, 0xa, 0x86, 0xdb, 0x12, 0xbe);
EXTERN_GUID( MF_PD_ASF_CONTENTENCRYPTIONEX_ENCRYPTION_DATA, 0x62508be5, 0xecdf, 0x4924, 0xa3, 0x59, 0x72, 0xba, 0xb3, 0x39, 0x7b, 0x9d);
EXTERN_GUID( MF_PD_ASF_LANGLIST, 0xf23de43c, 0x9977, 0x460d, 0xa6, 0xec, 0x32, 0x93, 0x7f, 0x16, 0xf, 0x7d);
#if (WINVER >= _WIN32_WINNT_WIN7) 
EXTERN_GUID( MF_PD_ASF_LANGLIST_LEGACYORDER, 0xf23de43d, 0x9977, 0x460d, 0xa6, 0xec, 0x32, 0x93, 0x7f, 0x16, 0xf, 0x7d);
#endif // (WINVER >= _WIN32_WINNT_WIN7) 
EXTERN_GUID(MF_PD_ASF_MARKER, 0x5134330e, 0x83a6, 0x475e, 0xa9, 0xd5, 0x4f, 0xb8, 0x75, 0xfb, 0x2e, 0x31);
EXTERN_GUID( MF_PD_ASF_SCRIPT, 0xe29cd0d7, 0xd602, 0x4923, 0xa7, 0xfe, 0x73, 0xfd, 0x97, 0xec, 0xc6, 0x50);
EXTERN_GUID(MF_PD_ASF_CODECLIST, 0xe4bb3509, 0xc18d, 0x4df1, 0xbb, 0x99, 0x7a, 0x36, 0xb3, 0xcc, 0x41, 0x19);
EXTERN_GUID( MF_PD_ASF_METADATA_IS_VBR, 0x5fc6947a, 0xef60, 0x445d, 0xb4, 0x49, 0x44, 0x2e, 0xcc, 0x78, 0xb4, 0xc1);
EXTERN_GUID( MF_PD_ASF_METADATA_V8_VBRPEAK, 0x5fc6947b, 0xef60, 0x445d, 0xb4, 0x49, 0x44, 0x2e, 0xcc, 0x78, 0xb4, 0xc1);
EXTERN_GUID( MF_PD_ASF_METADATA_V8_BUFFERAVERAGE, 0x5fc6947c, 0xef60, 0x445d, 0xb4, 0x49, 0x44, 0x2e, 0xcc, 0x78, 0xb4, 0xc1);
EXTERN_GUID( MF_PD_ASF_METADATA_LEAKY_BUCKET_PAIRS, 0x5fc6947d, 0xef60, 0x445d, 0xb4, 0x49, 0x44, 0x2e, 0xcc, 0x78, 0xb4, 0xc1);
EXTERN_GUID(MF_PD_ASF_DATA_START_OFFSET, 0xe7d5b3e7, 0x1f29, 0x45d3, 0x88, 0x22, 0x3e, 0x78, 0xfa, 0xe2, 0x72, 0xed);
EXTERN_GUID(MF_PD_ASF_DATA_LENGTH, 0xe7d5b3e8, 0x1f29, 0x45d3, 0x88, 0x22, 0x3e, 0x78, 0xfa, 0xe2, 0x72, 0xed);
EXTERN_GUID(MF_SD_ASF_EXTSTRMPROP_LANGUAGE_ID_INDEX, 0x48f8a522, 0x305d, 0x422d, 0x85, 0x24, 0x25, 0x2, 0xdd, 0xa3, 0x36, 0x80);
EXTERN_GUID(MF_SD_ASF_EXTSTRMPROP_AVG_DATA_BITRATE, 0x48f8a523, 0x305d, 0x422d, 0x85, 0x24, 0x25, 0x2, 0xdd, 0xa3, 0x36, 0x80);
EXTERN_GUID(MF_SD_ASF_EXTSTRMPROP_AVG_BUFFERSIZE, 0x48f8a524, 0x305d, 0x422d, 0x85, 0x24, 0x25, 0x2, 0xdd, 0xa3, 0x36, 0x80);
EXTERN_GUID(MF_SD_ASF_EXTSTRMPROP_MAX_DATA_BITRATE, 0x48f8a525, 0x305d, 0x422d, 0x85, 0x24, 0x25, 0x2, 0xdd, 0xa3, 0x36, 0x80);
EXTERN_GUID(MF_SD_ASF_EXTSTRMPROP_MAX_BUFFERSIZE, 0x48f8a526, 0x305d, 0x422d, 0x85, 0x24, 0x25, 0x2, 0xdd, 0xa3, 0x36, 0x80);
EXTERN_GUID(MF_SD_ASF_STREAMBITRATES_BITRATE, 0xa8e182ed, 0xafc8, 0x43d0, 0xb0, 0xd1, 0xf6, 0x5b, 0xad, 0x9d, 0xa5, 0x58);
EXTERN_GUID(MF_SD_ASF_METADATA_DEVICE_CONFORMANCE_TEMPLATE, 0x245e929d, 0xc44e, 0x4f7e, 0xbb, 0x3c, 0x77, 0xd4, 0xdf, 0xd2, 0x7f, 0x8a);
EXTERN_GUID(MF_PD_ASF_INFO_HAS_AUDIO, 0x80e62295, 0x2296, 0x4a44, 0xb3, 0x1c, 0xd1, 0x3, 0xc6, 0xfe, 0xd2, 0x3c);
EXTERN_GUID(MF_PD_ASF_INFO_HAS_VIDEO, 0x80e62296, 0x2296, 0x4a44, 0xb3, 0x1c, 0xd1, 0x3, 0xc6, 0xfe, 0xd2, 0x3c);
EXTERN_GUID(MF_PD_ASF_INFO_HAS_NON_AUDIO_VIDEO, 0x80e62297, 0x2296, 0x4a44, 0xb3, 0x1c, 0xd1, 0x3, 0xc6, 0xfe, 0xd2, 0x3c);





extern RPC_IF_HANDLE __MIDL_itf_wmcontainer_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmcontainer_0000_0001_v0_0_s_ifspec;

#ifndef __IMFASFProfile_INTERFACE_DEFINED__
#define __IMFASFProfile_INTERFACE_DEFINED__

/* interface IMFASFProfile */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFASFProfile;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D267BF6A-028B-4e0d-903D-43F0EF82D0D4")
    IMFASFProfile : public IMFAttributes
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStreamCount( 
            /* [out] */ DWORD *pcStreams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStream( 
            /* [in] */ DWORD dwStreamIndex,
            /* [out] */ WORD *pwStreamNumber,
            /* [out] */ IMFASFStreamConfig **ppIStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamByNumber( 
            /* [in] */ WORD wStreamNumber,
            /* [out] */ IMFASFStreamConfig **ppIStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStream( 
            /* [in] */ IMFASFStreamConfig *pIStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveStream( 
            /* [in] */ WORD wStreamNumber) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateStream( 
            /* [in] */ IMFMediaType *pIMediaType,
            /* [out] */ IMFASFStreamConfig **ppIStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMutualExclusionCount( 
            /* [out] */ DWORD *pcMutexs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMutualExclusion( 
            /* [in] */ DWORD dwMutexIndex,
            /* [out] */ IMFASFMutualExclusion **ppIMutex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddMutualExclusion( 
            /* [in] */ IMFASFMutualExclusion *pIMutex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveMutualExclusion( 
            /* [in] */ DWORD dwMutexIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateMutualExclusion( 
            /* [out] */ IMFASFMutualExclusion **ppIMutex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamPrioritization( 
            /* [out] */ IMFASFStreamPrioritization **ppIStreamPrioritization) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddStreamPrioritization( 
            /* [in] */ IMFASFStreamPrioritization *pIStreamPrioritization) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveStreamPrioritization( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateStreamPrioritization( 
            /* [out] */ IMFASFStreamPrioritization **ppIStreamPrioritization) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IMFASFProfile **ppIProfile) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFASFProfileVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFASFProfile * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFASFProfile * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFASFProfile * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            IMFASFProfile * This,
            REFGUID guidKey,
            /* [full][out][in] */ PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemType )( 
            IMFASFProfile * This,
            REFGUID guidKey,
            /* [out] */ MF_ATTRIBUTE_TYPE *pType);
        
        HRESULT ( STDMETHODCALLTYPE *CompareItem )( 
            IMFASFProfile * This,
            REFGUID guidKey,
            REFPROPVARIANT Value,
            /* [out] */ BOOL *pbResult);
        
        HRESULT ( STDMETHODCALLTYPE *Compare )( 
            IMFASFProfile * This,
            IMFAttributes *pTheirs,
            MF_ATTRIBUTES_MATCH_TYPE MatchType,
            /* [out] */ BOOL *pbResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetUINT32 )( 
            IMFASFProfile * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *punValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetUINT64 )( 
            IMFASFProfile * This,
            REFGUID guidKey,
            /* [out] */ UINT64 *punValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetDouble )( 
            IMFASFProfile * This,
            REFGUID guidKey,
            /* [out] */ double *pfValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetGUID )( 
            IMFASFProfile * This,
            REFGUID guidKey,
            /* [out] */ GUID *pguidValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetStringLength )( 
            IMFASFProfile * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetString )( 
            IMFASFProfile * This,
            REFGUID guidKey,
            /* [size_is][out] */ LPWSTR pwszValue,
            UINT32 cchBufSize,
            /* [full][out][in] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocatedString )( 
            IMFASFProfile * This,
            REFGUID guidKey,
            /* [size_is][size_is][out] */ LPWSTR *ppwszValue,
            /* [out] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetBlobSize )( 
            IMFASFProfile * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *pcbBlobSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetBlob )( 
            IMFASFProfile * This,
            REFGUID guidKey,
            /* [size_is][out] */ UINT8 *pBuf,
            UINT32 cbBufSize,
            /* [full][out][in] */ UINT32 *pcbBlobSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocatedBlob )( 
            IMFASFProfile * This,
            REFGUID guidKey,
            /* [size_is][size_is][out] */ UINT8 **ppBuf,
            /* [out] */ UINT32 *pcbSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetUnknown )( 
            IMFASFProfile * This,
            REFGUID guidKey,
            REFIID riid,
            /* [iid_is][out] */ LPVOID *ppv);
        
        HRESULT ( STDMETHODCALLTYPE *SetItem )( 
            IMFASFProfile * This,
            REFGUID guidKey,
            REFPROPVARIANT Value);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteItem )( 
            IMFASFProfile * This,
            REFGUID guidKey);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteAllItems )( 
            IMFASFProfile * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetUINT32 )( 
            IMFASFProfile * This,
            REFGUID guidKey,
            UINT32 unValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetUINT64 )( 
            IMFASFProfile * This,
            REFGUID guidKey,
            UINT64 unValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetDouble )( 
            IMFASFProfile * This,
            REFGUID guidKey,
            double fValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetGUID )( 
            IMFASFProfile * This,
            REFGUID guidKey,
            REFGUID guidValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetString )( 
            IMFASFProfile * This,
            REFGUID guidKey,
            /* [string][in] */ LPCWSTR wszValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetBlob )( 
            IMFASFProfile * This,
            REFGUID guidKey,
            /* [size_is][in] */ const UINT8 *pBuf,
            UINT32 cbBufSize);
        
        HRESULT ( STDMETHODCALLTYPE *SetUnknown )( 
            IMFASFProfile * This,
            REFGUID guidKey,
            /* [in] */ IUnknown *pUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *LockStore )( 
            IMFASFProfile * This);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockStore )( 
            IMFASFProfile * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IMFASFProfile * This,
            /* [out] */ UINT32 *pcItems);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemByIndex )( 
            IMFASFProfile * This,
            UINT32 unIndex,
            /* [out] */ GUID *pguidKey,
            /* [full][out][in] */ PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *CopyAllItems )( 
            IMFASFProfile * This,
            /* [in] */ IMFAttributes *pDest);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamCount )( 
            IMFASFProfile * This,
            /* [out] */ DWORD *pcStreams);
        
        HRESULT ( STDMETHODCALLTYPE *GetStream )( 
            IMFASFProfile * This,
            /* [in] */ DWORD dwStreamIndex,
            /* [out] */ WORD *pwStreamNumber,
            /* [out] */ IMFASFStreamConfig **ppIStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamByNumber )( 
            IMFASFProfile * This,
            /* [in] */ WORD wStreamNumber,
            /* [out] */ IMFASFStreamConfig **ppIStream);
        
        HRESULT ( STDMETHODCALLTYPE *SetStream )( 
            IMFASFProfile * This,
            /* [in] */ IMFASFStreamConfig *pIStream);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveStream )( 
            IMFASFProfile * This,
            /* [in] */ WORD wStreamNumber);
        
        HRESULT ( STDMETHODCALLTYPE *CreateStream )( 
            IMFASFProfile * This,
            /* [in] */ IMFMediaType *pIMediaType,
            /* [out] */ IMFASFStreamConfig **ppIStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetMutualExclusionCount )( 
            IMFASFProfile * This,
            /* [out] */ DWORD *pcMutexs);
        
        HRESULT ( STDMETHODCALLTYPE *GetMutualExclusion )( 
            IMFASFProfile * This,
            /* [in] */ DWORD dwMutexIndex,
            /* [out] */ IMFASFMutualExclusion **ppIMutex);
        
        HRESULT ( STDMETHODCALLTYPE *AddMutualExclusion )( 
            IMFASFProfile * This,
            /* [in] */ IMFASFMutualExclusion *pIMutex);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveMutualExclusion )( 
            IMFASFProfile * This,
            /* [in] */ DWORD dwMutexIndex);
        
        HRESULT ( STDMETHODCALLTYPE *CreateMutualExclusion )( 
            IMFASFProfile * This,
            /* [out] */ IMFASFMutualExclusion **ppIMutex);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamPrioritization )( 
            IMFASFProfile * This,
            /* [out] */ IMFASFStreamPrioritization **ppIStreamPrioritization);
        
        HRESULT ( STDMETHODCALLTYPE *AddStreamPrioritization )( 
            IMFASFProfile * This,
            /* [in] */ IMFASFStreamPrioritization *pIStreamPrioritization);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveStreamPrioritization )( 
            IMFASFProfile * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateStreamPrioritization )( 
            IMFASFProfile * This,
            /* [out] */ IMFASFStreamPrioritization **ppIStreamPrioritization);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IMFASFProfile * This,
            /* [out] */ IMFASFProfile **ppIProfile);
        
        END_INTERFACE
    } IMFASFProfileVtbl;

    interface IMFASFProfile
    {
        CONST_VTBL struct IMFASFProfileVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFASFProfile_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFASFProfile_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFASFProfile_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFASFProfile_GetItem(This,guidKey,pValue)	\
    ( (This)->lpVtbl -> GetItem(This,guidKey,pValue) ) 

#define IMFASFProfile_GetItemType(This,guidKey,pType)	\
    ( (This)->lpVtbl -> GetItemType(This,guidKey,pType) ) 

#define IMFASFProfile_CompareItem(This,guidKey,Value,pbResult)	\
    ( (This)->lpVtbl -> CompareItem(This,guidKey,Value,pbResult) ) 

#define IMFASFProfile_Compare(This,pTheirs,MatchType,pbResult)	\
    ( (This)->lpVtbl -> Compare(This,pTheirs,MatchType,pbResult) ) 

#define IMFASFProfile_GetUINT32(This,guidKey,punValue)	\
    ( (This)->lpVtbl -> GetUINT32(This,guidKey,punValue) ) 

#define IMFASFProfile_GetUINT64(This,guidKey,punValue)	\
    ( (This)->lpVtbl -> GetUINT64(This,guidKey,punValue) ) 

#define IMFASFProfile_GetDouble(This,guidKey,pfValue)	\
    ( (This)->lpVtbl -> GetDouble(This,guidKey,pfValue) ) 

#define IMFASFProfile_GetGUID(This,guidKey,pguidValue)	\
    ( (This)->lpVtbl -> GetGUID(This,guidKey,pguidValue) ) 

#define IMFASFProfile_GetStringLength(This,guidKey,pcchLength)	\
    ( (This)->lpVtbl -> GetStringLength(This,guidKey,pcchLength) ) 

#define IMFASFProfile_GetString(This,guidKey,pwszValue,cchBufSize,pcchLength)	\
    ( (This)->lpVtbl -> GetString(This,guidKey,pwszValue,cchBufSize,pcchLength) ) 

#define IMFASFProfile_GetAllocatedString(This,guidKey,ppwszValue,pcchLength)	\
    ( (This)->lpVtbl -> GetAllocatedString(This,guidKey,ppwszValue,pcchLength) ) 

#define IMFASFProfile_GetBlobSize(This,guidKey,pcbBlobSize)	\
    ( (This)->lpVtbl -> GetBlobSize(This,guidKey,pcbBlobSize) ) 

#define IMFASFProfile_GetBlob(This,guidKey,pBuf,cbBufSize,pcbBlobSize)	\
    ( (This)->lpVtbl -> GetBlob(This,guidKey,pBuf,cbBufSize,pcbBlobSize) ) 

#define IMFASFProfile_GetAllocatedBlob(This,guidKey,ppBuf,pcbSize)	\
    ( (This)->lpVtbl -> GetAllocatedBlob(This,guidKey,ppBuf,pcbSize) ) 

#define IMFASFProfile_GetUnknown(This,guidKey,riid,ppv)	\
    ( (This)->lpVtbl -> GetUnknown(This,guidKey,riid,ppv) ) 

#define IMFASFProfile_SetItem(This,guidKey,Value)	\
    ( (This)->lpVtbl -> SetItem(This,guidKey,Value) ) 

#define IMFASFProfile_DeleteItem(This,guidKey)	\
    ( (This)->lpVtbl -> DeleteItem(This,guidKey) ) 

#define IMFASFProfile_DeleteAllItems(This)	\
    ( (This)->lpVtbl -> DeleteAllItems(This) ) 

#define IMFASFProfile_SetUINT32(This,guidKey,unValue)	\
    ( (This)->lpVtbl -> SetUINT32(This,guidKey,unValue) ) 

#define IMFASFProfile_SetUINT64(This,guidKey,unValue)	\
    ( (This)->lpVtbl -> SetUINT64(This,guidKey,unValue) ) 

#define IMFASFProfile_SetDouble(This,guidKey,fValue)	\
    ( (This)->lpVtbl -> SetDouble(This,guidKey,fValue) ) 

#define IMFASFProfile_SetGUID(This,guidKey,guidValue)	\
    ( (This)->lpVtbl -> SetGUID(This,guidKey,guidValue) ) 

#define IMFASFProfile_SetString(This,guidKey,wszValue)	\
    ( (This)->lpVtbl -> SetString(This,guidKey,wszValue) ) 

#define IMFASFProfile_SetBlob(This,guidKey,pBuf,cbBufSize)	\
    ( (This)->lpVtbl -> SetBlob(This,guidKey,pBuf,cbBufSize) ) 

#define IMFASFProfile_SetUnknown(This,guidKey,pUnknown)	\
    ( (This)->lpVtbl -> SetUnknown(This,guidKey,pUnknown) ) 

#define IMFASFProfile_LockStore(This)	\
    ( (This)->lpVtbl -> LockStore(This) ) 

#define IMFASFProfile_UnlockStore(This)	\
    ( (This)->lpVtbl -> UnlockStore(This) ) 

#define IMFASFProfile_GetCount(This,pcItems)	\
    ( (This)->lpVtbl -> GetCount(This,pcItems) ) 

#define IMFASFProfile_GetItemByIndex(This,unIndex,pguidKey,pValue)	\
    ( (This)->lpVtbl -> GetItemByIndex(This,unIndex,pguidKey,pValue) ) 

#define IMFASFProfile_CopyAllItems(This,pDest)	\
    ( (This)->lpVtbl -> CopyAllItems(This,pDest) ) 


#define IMFASFProfile_GetStreamCount(This,pcStreams)	\
    ( (This)->lpVtbl -> GetStreamCount(This,pcStreams) ) 

#define IMFASFProfile_GetStream(This,dwStreamIndex,pwStreamNumber,ppIStream)	\
    ( (This)->lpVtbl -> GetStream(This,dwStreamIndex,pwStreamNumber,ppIStream) ) 

#define IMFASFProfile_GetStreamByNumber(This,wStreamNumber,ppIStream)	\
    ( (This)->lpVtbl -> GetStreamByNumber(This,wStreamNumber,ppIStream) ) 

#define IMFASFProfile_SetStream(This,pIStream)	\
    ( (This)->lpVtbl -> SetStream(This,pIStream) ) 

#define IMFASFProfile_RemoveStream(This,wStreamNumber)	\
    ( (This)->lpVtbl -> RemoveStream(This,wStreamNumber) ) 

#define IMFASFProfile_CreateStream(This,pIMediaType,ppIStream)	\
    ( (This)->lpVtbl -> CreateStream(This,pIMediaType,ppIStream) ) 

#define IMFASFProfile_GetMutualExclusionCount(This,pcMutexs)	\
    ( (This)->lpVtbl -> GetMutualExclusionCount(This,pcMutexs) ) 

#define IMFASFProfile_GetMutualExclusion(This,dwMutexIndex,ppIMutex)	\
    ( (This)->lpVtbl -> GetMutualExclusion(This,dwMutexIndex,ppIMutex) ) 

#define IMFASFProfile_AddMutualExclusion(This,pIMutex)	\
    ( (This)->lpVtbl -> AddMutualExclusion(This,pIMutex) ) 

#define IMFASFProfile_RemoveMutualExclusion(This,dwMutexIndex)	\
    ( (This)->lpVtbl -> RemoveMutualExclusion(This,dwMutexIndex) ) 

#define IMFASFProfile_CreateMutualExclusion(This,ppIMutex)	\
    ( (This)->lpVtbl -> CreateMutualExclusion(This,ppIMutex) ) 

#define IMFASFProfile_GetStreamPrioritization(This,ppIStreamPrioritization)	\
    ( (This)->lpVtbl -> GetStreamPrioritization(This,ppIStreamPrioritization) ) 

#define IMFASFProfile_AddStreamPrioritization(This,pIStreamPrioritization)	\
    ( (This)->lpVtbl -> AddStreamPrioritization(This,pIStreamPrioritization) ) 

#define IMFASFProfile_RemoveStreamPrioritization(This)	\
    ( (This)->lpVtbl -> RemoveStreamPrioritization(This) ) 

#define IMFASFProfile_CreateStreamPrioritization(This,ppIStreamPrioritization)	\
    ( (This)->lpVtbl -> CreateStreamPrioritization(This,ppIStreamPrioritization) ) 

#define IMFASFProfile_Clone(This,ppIProfile)	\
    ( (This)->lpVtbl -> Clone(This,ppIProfile) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFASFProfile_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wmcontainer_0000_0002 */
/* [local] */ 

EXTERN_GUID(MF_ASFPROFILE_MINPACKETSIZE, 0x22587626, 0x47de, 0x4168, 0x87, 0xf5, 0xb5, 0xaa, 0x9b, 0x12, 0xa8, 0xf0);
EXTERN_GUID(MF_ASFPROFILE_MAXPACKETSIZE, 0x22587627, 0x47de, 0x4168, 0x87, 0xf5, 0xb5, 0xaa, 0x9b, 0x12, 0xa8, 0xf0);
STDAPI MFCreateASFProfile( 
        /* out */     IMFASFProfile         **ppIProfile);
STDAPI MFCreateASFProfileFromPresentationDescriptor( 
        /* in  */     IMFPresentationDescriptor  *pIPD,
        /* out */     IMFASFProfile             **ppIProfile);
STDAPI MFCreatePresentationDescriptorFromASFProfile( 
        /* in  */     IMFASFProfile              *pIProfile,
        /* out */     IMFPresentationDescriptor **ppIPD);


extern RPC_IF_HANDLE __MIDL_itf_wmcontainer_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmcontainer_0000_0002_v0_0_s_ifspec;

#ifndef __IMFASFStreamConfig_INTERFACE_DEFINED__
#define __IMFASFStreamConfig_INTERFACE_DEFINED__

/* interface IMFASFStreamConfig */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFASFStreamConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9E8AE8D2-DBBD-4200-9ACA-06E6DF484913")
    IMFASFStreamConfig : public IMFAttributes
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStreamType( 
            /* [out] */ GUID *pguidStreamType) = 0;
        
        virtual WORD STDMETHODCALLTYPE GetStreamNumber( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStreamNumber( 
            /* [in] */ WORD wStreamNum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMediaType( 
            /* [out] */ IMFMediaType **ppIMediaType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMediaType( 
            /* [in] */ IMFMediaType *pIMediaType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPayloadExtensionCount( 
            /* [out] */ WORD *pcPayloadExtensions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPayloadExtension( 
            /* [in] */ WORD wPayloadExtensionNumber,
            /* [out] */ GUID *pguidExtensionSystemID,
            /* [out] */ WORD *pcbExtensionDataSize,
            /* [size_is][optional][out] */ BYTE *pbExtensionSystemInfo,
            /* [optional][out][in] */ DWORD *pcbExtensionSystemInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddPayloadExtension( 
            /* [in] */ GUID guidExtensionSystemID,
            /* [in] */ WORD cbExtensionDataSize,
            /* [size_is][in] */ BYTE *pbExtensionSystemInfo,
            /* [in] */ DWORD cbExtensionSystemInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAllPayloadExtensions( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IMFASFStreamConfig **ppIStreamConfig) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFASFStreamConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFASFStreamConfig * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFASFStreamConfig * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFASFStreamConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            IMFASFStreamConfig * This,
            REFGUID guidKey,
            /* [full][out][in] */ PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemType )( 
            IMFASFStreamConfig * This,
            REFGUID guidKey,
            /* [out] */ MF_ATTRIBUTE_TYPE *pType);
        
        HRESULT ( STDMETHODCALLTYPE *CompareItem )( 
            IMFASFStreamConfig * This,
            REFGUID guidKey,
            REFPROPVARIANT Value,
            /* [out] */ BOOL *pbResult);
        
        HRESULT ( STDMETHODCALLTYPE *Compare )( 
            IMFASFStreamConfig * This,
            IMFAttributes *pTheirs,
            MF_ATTRIBUTES_MATCH_TYPE MatchType,
            /* [out] */ BOOL *pbResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetUINT32 )( 
            IMFASFStreamConfig * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *punValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetUINT64 )( 
            IMFASFStreamConfig * This,
            REFGUID guidKey,
            /* [out] */ UINT64 *punValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetDouble )( 
            IMFASFStreamConfig * This,
            REFGUID guidKey,
            /* [out] */ double *pfValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetGUID )( 
            IMFASFStreamConfig * This,
            REFGUID guidKey,
            /* [out] */ GUID *pguidValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetStringLength )( 
            IMFASFStreamConfig * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetString )( 
            IMFASFStreamConfig * This,
            REFGUID guidKey,
            /* [size_is][out] */ LPWSTR pwszValue,
            UINT32 cchBufSize,
            /* [full][out][in] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocatedString )( 
            IMFASFStreamConfig * This,
            REFGUID guidKey,
            /* [size_is][size_is][out] */ LPWSTR *ppwszValue,
            /* [out] */ UINT32 *pcchLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetBlobSize )( 
            IMFASFStreamConfig * This,
            REFGUID guidKey,
            /* [out] */ UINT32 *pcbBlobSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetBlob )( 
            IMFASFStreamConfig * This,
            REFGUID guidKey,
            /* [size_is][out] */ UINT8 *pBuf,
            UINT32 cbBufSize,
            /* [full][out][in] */ UINT32 *pcbBlobSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocatedBlob )( 
            IMFASFStreamConfig * This,
            REFGUID guidKey,
            /* [size_is][size_is][out] */ UINT8 **ppBuf,
            /* [out] */ UINT32 *pcbSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetUnknown )( 
            IMFASFStreamConfig * This,
            REFGUID guidKey,
            REFIID riid,
            /* [iid_is][out] */ LPVOID *ppv);
        
        HRESULT ( STDMETHODCALLTYPE *SetItem )( 
            IMFASFStreamConfig * This,
            REFGUID guidKey,
            REFPROPVARIANT Value);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteItem )( 
            IMFASFStreamConfig * This,
            REFGUID guidKey);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteAllItems )( 
            IMFASFStreamConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetUINT32 )( 
            IMFASFStreamConfig * This,
            REFGUID guidKey,
            UINT32 unValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetUINT64 )( 
            IMFASFStreamConfig * This,
            REFGUID guidKey,
            UINT64 unValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetDouble )( 
            IMFASFStreamConfig * This,
            REFGUID guidKey,
            double fValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetGUID )( 
            IMFASFStreamConfig * This,
            REFGUID guidKey,
            REFGUID guidValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetString )( 
            IMFASFStreamConfig * This,
            REFGUID guidKey,
            /* [string][in] */ LPCWSTR wszValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetBlob )( 
            IMFASFStreamConfig * This,
            REFGUID guidKey,
            /* [size_is][in] */ const UINT8 *pBuf,
            UINT32 cbBufSize);
        
        HRESULT ( STDMETHODCALLTYPE *SetUnknown )( 
            IMFASFStreamConfig * This,
            REFGUID guidKey,
            /* [in] */ IUnknown *pUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *LockStore )( 
            IMFASFStreamConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockStore )( 
            IMFASFStreamConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IMFASFStreamConfig * This,
            /* [out] */ UINT32 *pcItems);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemByIndex )( 
            IMFASFStreamConfig * This,
            UINT32 unIndex,
            /* [out] */ GUID *pguidKey,
            /* [full][out][in] */ PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *CopyAllItems )( 
            IMFASFStreamConfig * This,
            /* [in] */ IMFAttributes *pDest);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamType )( 
            IMFASFStreamConfig * This,
            /* [out] */ GUID *pguidStreamType);
        
        WORD ( STDMETHODCALLTYPE *GetStreamNumber )( 
            IMFASFStreamConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetStreamNumber )( 
            IMFASFStreamConfig * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaType )( 
            IMFASFStreamConfig * This,
            /* [out] */ IMFMediaType **ppIMediaType);
        
        HRESULT ( STDMETHODCALLTYPE *SetMediaType )( 
            IMFASFStreamConfig * This,
            /* [in] */ IMFMediaType *pIMediaType);
        
        HRESULT ( STDMETHODCALLTYPE *GetPayloadExtensionCount )( 
            IMFASFStreamConfig * This,
            /* [out] */ WORD *pcPayloadExtensions);
        
        HRESULT ( STDMETHODCALLTYPE *GetPayloadExtension )( 
            IMFASFStreamConfig * This,
            /* [in] */ WORD wPayloadExtensionNumber,
            /* [out] */ GUID *pguidExtensionSystemID,
            /* [out] */ WORD *pcbExtensionDataSize,
            /* [size_is][optional][out] */ BYTE *pbExtensionSystemInfo,
            /* [optional][out][in] */ DWORD *pcbExtensionSystemInfo);
        
        HRESULT ( STDMETHODCALLTYPE *AddPayloadExtension )( 
            IMFASFStreamConfig * This,
            /* [in] */ GUID guidExtensionSystemID,
            /* [in] */ WORD cbExtensionDataSize,
            /* [size_is][in] */ BYTE *pbExtensionSystemInfo,
            /* [in] */ DWORD cbExtensionSystemInfo);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAllPayloadExtensions )( 
            IMFASFStreamConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IMFASFStreamConfig * This,
            /* [out] */ IMFASFStreamConfig **ppIStreamConfig);
        
        END_INTERFACE
    } IMFASFStreamConfigVtbl;

    interface IMFASFStreamConfig
    {
        CONST_VTBL struct IMFASFStreamConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFASFStreamConfig_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFASFStreamConfig_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFASFStreamConfig_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFASFStreamConfig_GetItem(This,guidKey,pValue)	\
    ( (This)->lpVtbl -> GetItem(This,guidKey,pValue) ) 

#define IMFASFStreamConfig_GetItemType(This,guidKey,pType)	\
    ( (This)->lpVtbl -> GetItemType(This,guidKey,pType) ) 

#define IMFASFStreamConfig_CompareItem(This,guidKey,Value,pbResult)	\
    ( (This)->lpVtbl -> CompareItem(This,guidKey,Value,pbResult) ) 

#define IMFASFStreamConfig_Compare(This,pTheirs,MatchType,pbResult)	\
    ( (This)->lpVtbl -> Compare(This,pTheirs,MatchType,pbResult) ) 

#define IMFASFStreamConfig_GetUINT32(This,guidKey,punValue)	\
    ( (This)->lpVtbl -> GetUINT32(This,guidKey,punValue) ) 

#define IMFASFStreamConfig_GetUINT64(This,guidKey,punValue)	\
    ( (This)->lpVtbl -> GetUINT64(This,guidKey,punValue) ) 

#define IMFASFStreamConfig_GetDouble(This,guidKey,pfValue)	\
    ( (This)->lpVtbl -> GetDouble(This,guidKey,pfValue) ) 

#define IMFASFStreamConfig_GetGUID(This,guidKey,pguidValue)	\
    ( (This)->lpVtbl -> GetGUID(This,guidKey,pguidValue) ) 

#define IMFASFStreamConfig_GetStringLength(This,guidKey,pcchLength)	\
    ( (This)->lpVtbl -> GetStringLength(This,guidKey,pcchLength) ) 

#define IMFASFStreamConfig_GetString(This,guidKey,pwszValue,cchBufSize,pcchLength)	\
    ( (This)->lpVtbl -> GetString(This,guidKey,pwszValue,cchBufSize,pcchLength) ) 

#define IMFASFStreamConfig_GetAllocatedString(This,guidKey,ppwszValue,pcchLength)	\
    ( (This)->lpVtbl -> GetAllocatedString(This,guidKey,ppwszValue,pcchLength) ) 

#define IMFASFStreamConfig_GetBlobSize(This,guidKey,pcbBlobSize)	\
    ( (This)->lpVtbl -> GetBlobSize(This,guidKey,pcbBlobSize) ) 

#define IMFASFStreamConfig_GetBlob(This,guidKey,pBuf,cbBufSize,pcbBlobSize)	\
    ( (This)->lpVtbl -> GetBlob(This,guidKey,pBuf,cbBufSize,pcbBlobSize) ) 

#define IMFASFStreamConfig_GetAllocatedBlob(This,guidKey,ppBuf,pcbSize)	\
    ( (This)->lpVtbl -> GetAllocatedBlob(This,guidKey,ppBuf,pcbSize) ) 

#define IMFASFStreamConfig_GetUnknown(This,guidKey,riid,ppv)	\
    ( (This)->lpVtbl -> GetUnknown(This,guidKey,riid,ppv) ) 

#define IMFASFStreamConfig_SetItem(This,guidKey,Value)	\
    ( (This)->lpVtbl -> SetItem(This,guidKey,Value) ) 

#define IMFASFStreamConfig_DeleteItem(This,guidKey)	\
    ( (This)->lpVtbl -> DeleteItem(This,guidKey) ) 

#define IMFASFStreamConfig_DeleteAllItems(This)	\
    ( (This)->lpVtbl -> DeleteAllItems(This) ) 

#define IMFASFStreamConfig_SetUINT32(This,guidKey,unValue)	\
    ( (This)->lpVtbl -> SetUINT32(This,guidKey,unValue) ) 

#define IMFASFStreamConfig_SetUINT64(This,guidKey,unValue)	\
    ( (This)->lpVtbl -> SetUINT64(This,guidKey,unValue) ) 

#define IMFASFStreamConfig_SetDouble(This,guidKey,fValue)	\
    ( (This)->lpVtbl -> SetDouble(This,guidKey,fValue) ) 

#define IMFASFStreamConfig_SetGUID(This,guidKey,guidValue)	\
    ( (This)->lpVtbl -> SetGUID(This,guidKey,guidValue) ) 

#define IMFASFStreamConfig_SetString(This,guidKey,wszValue)	\
    ( (This)->lpVtbl -> SetString(This,guidKey,wszValue) ) 

#define IMFASFStreamConfig_SetBlob(This,guidKey,pBuf,cbBufSize)	\
    ( (This)->lpVtbl -> SetBlob(This,guidKey,pBuf,cbBufSize) ) 

#define IMFASFStreamConfig_SetUnknown(This,guidKey,pUnknown)	\
    ( (This)->lpVtbl -> SetUnknown(This,guidKey,pUnknown) ) 

#define IMFASFStreamConfig_LockStore(This)	\
    ( (This)->lpVtbl -> LockStore(This) ) 

#define IMFASFStreamConfig_UnlockStore(This)	\
    ( (This)->lpVtbl -> UnlockStore(This) ) 

#define IMFASFStreamConfig_GetCount(This,pcItems)	\
    ( (This)->lpVtbl -> GetCount(This,pcItems) ) 

#define IMFASFStreamConfig_GetItemByIndex(This,unIndex,pguidKey,pValue)	\
    ( (This)->lpVtbl -> GetItemByIndex(This,unIndex,pguidKey,pValue) ) 

#define IMFASFStreamConfig_CopyAllItems(This,pDest)	\
    ( (This)->lpVtbl -> CopyAllItems(This,pDest) ) 


#define IMFASFStreamConfig_GetStreamType(This,pguidStreamType)	\
    ( (This)->lpVtbl -> GetStreamType(This,pguidStreamType) ) 

#define IMFASFStreamConfig_GetStreamNumber(This)	\
    ( (This)->lpVtbl -> GetStreamNumber(This) ) 

#define IMFASFStreamConfig_SetStreamNumber(This,wStreamNum)	\
    ( (This)->lpVtbl -> SetStreamNumber(This,wStreamNum) ) 

#define IMFASFStreamConfig_GetMediaType(This,ppIMediaType)	\
    ( (This)->lpVtbl -> GetMediaType(This,ppIMediaType) ) 

#define IMFASFStreamConfig_SetMediaType(This,pIMediaType)	\
    ( (This)->lpVtbl -> SetMediaType(This,pIMediaType) ) 

#define IMFASFStreamConfig_GetPayloadExtensionCount(This,pcPayloadExtensions)	\
    ( (This)->lpVtbl -> GetPayloadExtensionCount(This,pcPayloadExtensions) ) 

#define IMFASFStreamConfig_GetPayloadExtension(This,wPayloadExtensionNumber,pguidExtensionSystemID,pcbExtensionDataSize,pbExtensionSystemInfo,pcbExtensionSystemInfo)	\
    ( (This)->lpVtbl -> GetPayloadExtension(This,wPayloadExtensionNumber,pguidExtensionSystemID,pcbExtensionDataSize,pbExtensionSystemInfo,pcbExtensionSystemInfo) ) 

#define IMFASFStreamConfig_AddPayloadExtension(This,guidExtensionSystemID,cbExtensionDataSize,pbExtensionSystemInfo,cbExtensionSystemInfo)	\
    ( (This)->lpVtbl -> AddPayloadExtension(This,guidExtensionSystemID,cbExtensionDataSize,pbExtensionSystemInfo,cbExtensionSystemInfo) ) 

#define IMFASFStreamConfig_RemoveAllPayloadExtensions(This)	\
    ( (This)->lpVtbl -> RemoveAllPayloadExtensions(This) ) 

#define IMFASFStreamConfig_Clone(This,ppIStreamConfig)	\
    ( (This)->lpVtbl -> Clone(This,ppIStreamConfig) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFASFStreamConfig_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wmcontainer_0000_0003 */
/* [local] */ 

EXTERN_GUID(MF_ASFSTREAMCONFIG_LEAKYBUCKET1, 0xc69b5901, 0xea1a, 0x4c9b, 0xb6, 0x92, 0xe2, 0xa0, 0xd2, 0x9a, 0x8a, 0xdd);
EXTERN_GUID(MF_ASFSTREAMCONFIG_LEAKYBUCKET2, 0xc69b5902, 0xea1a, 0x4c9b, 0xb6, 0x92, 0xe2, 0xa0, 0xd2, 0x9a, 0x8a, 0xdd);
EXTERN_GUID(MFASFSampleExtension_SampleDuration, 0xc6bd9450, 0x867f, 0x4907, 0x83, 0xa3, 0xc7, 0x79, 0x21, 0xb7, 0x33, 0xad);
EXTERN_GUID(MFASFSampleExtension_OutputCleanPoint, 0xf72a3c6f, 0x6eb4, 0x4ebc, 0xb1, 0x92, 0x9, 0xad, 0x97, 0x59, 0xe8, 0x28);
EXTERN_GUID(MFASFSampleExtension_SMPTE, 0x399595ec, 0x8667, 0x4e2d, 0x8f, 0xdb, 0x98, 0x81, 0x4c, 0xe7, 0x6c, 0x1e);
EXTERN_GUID(MFASFSampleExtension_FileName, 0xe165ec0e, 0x19ed, 0x45d7, 0xb4, 0xa7, 0x25, 0xcb, 0xd1, 0xe2, 0x8e, 0x9b);
EXTERN_GUID(MFASFSampleExtension_ContentType, 0xd590dc20, 0x07bc, 0x436c, 0x9c, 0xf7, 0xf3, 0xbb, 0xfb, 0xf1, 0xa4, 0xdc);
EXTERN_GUID(MFASFSampleExtension_PixelAspectRatio, 0x1b1ee554, 0xf9ea, 0x4bc8, 0x82, 0x1a, 0x37, 0x6b, 0x74, 0xe4, 0xc4, 0xb8);
EXTERN_GUID(MFASFSampleExtension_Encryption_SampleID, 0x6698B84E, 0x0AFA, 0x4330, 0xAE, 0xB2, 0x1C, 0x0A, 0x98, 0xD7, 0xA4, 0x4D);
EXTERN_GUID(MFASFSampleExtension_Encryption_KeyID, 0x76376591,  0x795f,  0x4da1, 0x86, 0xed, 0x9d, 0x46, 0xec, 0xa1, 0x09, 0xa9);


extern RPC_IF_HANDLE __MIDL_itf_wmcontainer_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmcontainer_0000_0003_v0_0_s_ifspec;

#ifndef __IMFASFMutualExclusion_INTERFACE_DEFINED__
#define __IMFASFMutualExclusion_INTERFACE_DEFINED__

/* interface IMFASFMutualExclusion */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFASFMutualExclusion;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("12558291-E399-11D5-BC2A-00B0D0F3F4AB")
    IMFASFMutualExclusion : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ GUID *pguidType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetType( 
            /* [in] */ REFGUID guidType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordCount( 
            /* [out] */ DWORD *pdwRecordCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamsForRecord( 
            /* [in] */ DWORD dwRecordNumber,
            /* [out] */ WORD *pwStreamNumArray,
            /* [out][in] */ DWORD *pcStreams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddStreamForRecord( 
            /* [in] */ DWORD dwRecordNumber,
            /* [in] */ WORD wStreamNumber) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveStreamFromRecord( 
            /* [in] */ DWORD dwRecordNumber,
            /* [in] */ WORD wStreamNumber) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveRecord( 
            /* [in] */ DWORD dwRecordNumber) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddRecord( 
            /* [out] */ DWORD *pdwRecordNumber) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IMFASFMutualExclusion **ppIMutex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFASFMutualExclusionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFASFMutualExclusion * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFASFMutualExclusion * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFASFMutualExclusion * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            IMFASFMutualExclusion * This,
            /* [out] */ GUID *pguidType);
        
        HRESULT ( STDMETHODCALLTYPE *SetType )( 
            IMFASFMutualExclusion * This,
            /* [in] */ REFGUID guidType);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordCount )( 
            IMFASFMutualExclusion * This,
            /* [out] */ DWORD *pdwRecordCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamsForRecord )( 
            IMFASFMutualExclusion * This,
            /* [in] */ DWORD dwRecordNumber,
            /* [out] */ WORD *pwStreamNumArray,
            /* [out][in] */ DWORD *pcStreams);
        
        HRESULT ( STDMETHODCALLTYPE *AddStreamForRecord )( 
            IMFASFMutualExclusion * This,
            /* [in] */ DWORD dwRecordNumber,
            /* [in] */ WORD wStreamNumber);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveStreamFromRecord )( 
            IMFASFMutualExclusion * This,
            /* [in] */ DWORD dwRecordNumber,
            /* [in] */ WORD wStreamNumber);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveRecord )( 
            IMFASFMutualExclusion * This,
            /* [in] */ DWORD dwRecordNumber);
        
        HRESULT ( STDMETHODCALLTYPE *AddRecord )( 
            IMFASFMutualExclusion * This,
            /* [out] */ DWORD *pdwRecordNumber);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IMFASFMutualExclusion * This,
            /* [out] */ IMFASFMutualExclusion **ppIMutex);
        
        END_INTERFACE
    } IMFASFMutualExclusionVtbl;

    interface IMFASFMutualExclusion
    {
        CONST_VTBL struct IMFASFMutualExclusionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFASFMutualExclusion_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFASFMutualExclusion_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFASFMutualExclusion_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFASFMutualExclusion_GetType(This,pguidType)	\
    ( (This)->lpVtbl -> GetType(This,pguidType) ) 

#define IMFASFMutualExclusion_SetType(This,guidType)	\
    ( (This)->lpVtbl -> SetType(This,guidType) ) 

#define IMFASFMutualExclusion_GetRecordCount(This,pdwRecordCount)	\
    ( (This)->lpVtbl -> GetRecordCount(This,pdwRecordCount) ) 

#define IMFASFMutualExclusion_GetStreamsForRecord(This,dwRecordNumber,pwStreamNumArray,pcStreams)	\
    ( (This)->lpVtbl -> GetStreamsForRecord(This,dwRecordNumber,pwStreamNumArray,pcStreams) ) 

#define IMFASFMutualExclusion_AddStreamForRecord(This,dwRecordNumber,wStreamNumber)	\
    ( (This)->lpVtbl -> AddStreamForRecord(This,dwRecordNumber,wStreamNumber) ) 

#define IMFASFMutualExclusion_RemoveStreamFromRecord(This,dwRecordNumber,wStreamNumber)	\
    ( (This)->lpVtbl -> RemoveStreamFromRecord(This,dwRecordNumber,wStreamNumber) ) 

#define IMFASFMutualExclusion_RemoveRecord(This,dwRecordNumber)	\
    ( (This)->lpVtbl -> RemoveRecord(This,dwRecordNumber) ) 

#define IMFASFMutualExclusion_AddRecord(This,pdwRecordNumber)	\
    ( (This)->lpVtbl -> AddRecord(This,pdwRecordNumber) ) 

#define IMFASFMutualExclusion_Clone(This,ppIMutex)	\
    ( (This)->lpVtbl -> Clone(This,ppIMutex) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFASFMutualExclusion_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wmcontainer_0000_0004 */
/* [local] */ 

EXTERN_GUID(MFASFMutexType_Language, 0x72178C2B, 0xE45B, 0x11D5, 0xBC, 0x2A, 0x00, 0xB0, 0xD0, 0xF3, 0xF4, 0xAB);
EXTERN_GUID(MFASFMutexType_Bitrate, 0x72178C2C, 0xE45B, 0x11D5, 0xBC, 0x2A, 0x00, 0xB0, 0xD0, 0xF3, 0xF4, 0xAB);
EXTERN_GUID(MFASFMutexType_Presentation, 0x72178C2D, 0xE45B, 0x11D5, 0xBC, 0x2A, 0x00, 0xB0, 0xD0, 0xF3, 0xF4, 0xAB);
EXTERN_GUID(MFASFMutexType_Unknown, 0x72178C2E, 0xE45B, 0x11D5, 0xBC, 0x2A, 0x00, 0xB0, 0xD0, 0xF3, 0xF4, 0xAB);


extern RPC_IF_HANDLE __MIDL_itf_wmcontainer_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmcontainer_0000_0004_v0_0_s_ifspec;

#ifndef __IMFASFStreamPrioritization_INTERFACE_DEFINED__
#define __IMFASFStreamPrioritization_INTERFACE_DEFINED__

/* interface IMFASFStreamPrioritization */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFASFStreamPrioritization;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("699bdc27-bbaf-49ff-8e38-9c39c9b5e088")
    IMFASFStreamPrioritization : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStreamCount( 
            /* [out] */ DWORD *pdwStreamCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStream( 
            /* [in] */ DWORD dwStreamIndex,
            /* [out] */ WORD *pwStreamNumber,
            /* [out] */ WORD *pwStreamFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddStream( 
            /* [in] */ WORD wStreamNumber,
            /* [in] */ WORD wStreamFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveStream( 
            /* [in] */ DWORD dwStreamIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IMFASFStreamPrioritization **ppIStreamPrioritization) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFASFStreamPrioritizationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFASFStreamPrioritization * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFASFStreamPrioritization * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFASFStreamPrioritization * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamCount )( 
            IMFASFStreamPrioritization * This,
            /* [out] */ DWORD *pdwStreamCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetStream )( 
            IMFASFStreamPrioritization * This,
            /* [in] */ DWORD dwStreamIndex,
            /* [out] */ WORD *pwStreamNumber,
            /* [out] */ WORD *pwStreamFlags);
        
        HRESULT ( STDMETHODCALLTYPE *AddStream )( 
            IMFASFStreamPrioritization * This,
            /* [in] */ WORD wStreamNumber,
            /* [in] */ WORD wStreamFlags);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveStream )( 
            IMFASFStreamPrioritization * This,
            /* [in] */ DWORD dwStreamIndex);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IMFASFStreamPrioritization * This,
            /* [out] */ IMFASFStreamPrioritization **ppIStreamPrioritization);
        
        END_INTERFACE
    } IMFASFStreamPrioritizationVtbl;

    interface IMFASFStreamPrioritization
    {
        CONST_VTBL struct IMFASFStreamPrioritizationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFASFStreamPrioritization_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFASFStreamPrioritization_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFASFStreamPrioritization_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFASFStreamPrioritization_GetStreamCount(This,pdwStreamCount)	\
    ( (This)->lpVtbl -> GetStreamCount(This,pdwStreamCount) ) 

#define IMFASFStreamPrioritization_GetStream(This,dwStreamIndex,pwStreamNumber,pwStreamFlags)	\
    ( (This)->lpVtbl -> GetStream(This,dwStreamIndex,pwStreamNumber,pwStreamFlags) ) 

#define IMFASFStreamPrioritization_AddStream(This,wStreamNumber,wStreamFlags)	\
    ( (This)->lpVtbl -> AddStream(This,wStreamNumber,wStreamFlags) ) 

#define IMFASFStreamPrioritization_RemoveStream(This,dwStreamIndex)	\
    ( (This)->lpVtbl -> RemoveStream(This,dwStreamIndex) ) 

#define IMFASFStreamPrioritization_Clone(This,ppIStreamPrioritization)	\
    ( (This)->lpVtbl -> Clone(This,ppIStreamPrioritization) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFASFStreamPrioritization_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wmcontainer_0000_0005 */
/* [local] */ 

typedef 
enum MFASF_SPLITTERFLAGS
    {	MFASF_SPLITTER_REVERSE	= 0x1,
	MFASF_SPLITTER_WMDRM	= 0x2
    } 	MFASF_SPLITTERFLAGS;



extern RPC_IF_HANDLE __MIDL_itf_wmcontainer_0000_0005_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmcontainer_0000_0005_v0_0_s_ifspec;

#ifndef __IMFASFSplitter_INTERFACE_DEFINED__
#define __IMFASFSplitter_INTERFACE_DEFINED__

/* interface IMFASFSplitter */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFASFSplitter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("12558295-E399-11D5-BC2A-00B0D0F3F4AB")
    IMFASFSplitter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IMFASFContentInfo *pIContentInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFlags( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFlags( 
            /* [out] */ DWORD *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectStreams( 
            /* [in] */ WORD *pwStreamNumbers,
            /* [in] */ WORD wNumStreams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSelectedStreams( 
            /* [out] */ WORD *pwStreamNumbers,
            /* [out][in] */ WORD *pwNumStreams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ParseData( 
            /* [in] */ IMFMediaBuffer *pIBuffer,
            /* [in] */ DWORD cbBufferOffset,
            /* [in] */ DWORD cbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextSample( 
            /* [out] */ DWORD *pdwStatusFlags,
            /* [out] */ WORD *pwStreamNumber,
            /* [out] */ IMFSample **ppISample) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Flush( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLastSendTime( 
            /* [out] */ DWORD *pdwLastSendTime) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFASFSplitterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFASFSplitter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFASFSplitter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFASFSplitter * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IMFASFSplitter * This,
            /* [in] */ IMFASFContentInfo *pIContentInfo);
        
        HRESULT ( STDMETHODCALLTYPE *SetFlags )( 
            IMFASFSplitter * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetFlags )( 
            IMFASFSplitter * This,
            /* [out] */ DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SelectStreams )( 
            IMFASFSplitter * This,
            /* [in] */ WORD *pwStreamNumbers,
            /* [in] */ WORD wNumStreams);
        
        HRESULT ( STDMETHODCALLTYPE *GetSelectedStreams )( 
            IMFASFSplitter * This,
            /* [out] */ WORD *pwStreamNumbers,
            /* [out][in] */ WORD *pwNumStreams);
        
        HRESULT ( STDMETHODCALLTYPE *ParseData )( 
            IMFASFSplitter * This,
            /* [in] */ IMFMediaBuffer *pIBuffer,
            /* [in] */ DWORD cbBufferOffset,
            /* [in] */ DWORD cbLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextSample )( 
            IMFASFSplitter * This,
            /* [out] */ DWORD *pdwStatusFlags,
            /* [out] */ WORD *pwStreamNumber,
            /* [out] */ IMFSample **ppISample);
        
        HRESULT ( STDMETHODCALLTYPE *Flush )( 
            IMFASFSplitter * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetLastSendTime )( 
            IMFASFSplitter * This,
            /* [out] */ DWORD *pdwLastSendTime);
        
        END_INTERFACE
    } IMFASFSplitterVtbl;

    interface IMFASFSplitter
    {
        CONST_VTBL struct IMFASFSplitterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFASFSplitter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFASFSplitter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFASFSplitter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFASFSplitter_Initialize(This,pIContentInfo)	\
    ( (This)->lpVtbl -> Initialize(This,pIContentInfo) ) 

#define IMFASFSplitter_SetFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> SetFlags(This,dwFlags) ) 

#define IMFASFSplitter_GetFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> GetFlags(This,pdwFlags) ) 

#define IMFASFSplitter_SelectStreams(This,pwStreamNumbers,wNumStreams)	\
    ( (This)->lpVtbl -> SelectStreams(This,pwStreamNumbers,wNumStreams) ) 

#define IMFASFSplitter_GetSelectedStreams(This,pwStreamNumbers,pwNumStreams)	\
    ( (This)->lpVtbl -> GetSelectedStreams(This,pwStreamNumbers,pwNumStreams) ) 

#define IMFASFSplitter_ParseData(This,pIBuffer,cbBufferOffset,cbLength)	\
    ( (This)->lpVtbl -> ParseData(This,pIBuffer,cbBufferOffset,cbLength) ) 

#define IMFASFSplitter_GetNextSample(This,pdwStatusFlags,pwStreamNumber,ppISample)	\
    ( (This)->lpVtbl -> GetNextSample(This,pdwStatusFlags,pwStreamNumber,ppISample) ) 

#define IMFASFSplitter_Flush(This)	\
    ( (This)->lpVtbl -> Flush(This) ) 

#define IMFASFSplitter_GetLastSendTime(This,pdwLastSendTime)	\
    ( (This)->lpVtbl -> GetLastSendTime(This,pdwLastSendTime) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFASFSplitter_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wmcontainer_0000_0006 */
/* [local] */ 

typedef 
enum ASF_STATUSFLAGS
    {	ASF_STATUSFLAGS_INCOMPLETE	= 0x1,
	ASF_STATUSFLAGS_NONFATAL_ERROR	= 0x2
    } 	ASF_STATUSFLAGS;

EXTERN_GUID(MFASFSPLITTER_PACKET_BOUNDARY, 0xfe584a05, 0xe8d6, 0x42e3, 0xb1, 0x76, 0xf1, 0x21, 0x17, 0x5, 0xfb, 0x6f);
STDAPI MFCreateASFSplitter( 
        /* out */     IMFASFSplitter        **ppISplitter);
typedef 
enum MFASF_MULTIPLEXERFLAGS
    {	MFASF_MULTIPLEXER_AUTOADJUST_BITRATE	= 0x1
    } 	MFASF_MULTIPLEXERFLAGS;

typedef struct ASF_MUX_STATISTICS
    {
    DWORD cFramesWritten;
    DWORD cFramesDropped;
    } 	ASF_MUX_STATISTICS;



extern RPC_IF_HANDLE __MIDL_itf_wmcontainer_0000_0006_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmcontainer_0000_0006_v0_0_s_ifspec;

#ifndef __IMFASFMultiplexer_INTERFACE_DEFINED__
#define __IMFASFMultiplexer_INTERFACE_DEFINED__

/* interface IMFASFMultiplexer */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFASFMultiplexer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("57BDD80A-9B38-4838-B737-C58F670D7D4F")
    IMFASFMultiplexer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IMFASFContentInfo *pIContentInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFlags( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFlags( 
            /* [out] */ DWORD *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessSample( 
            /* [in] */ WORD wStreamNumber,
            /* [in] */ IMFSample *pISample,
            /* [in] */ LONGLONG hnsTimestampAdjust) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextPacket( 
            /* [out] */ DWORD *pdwStatusFlags,
            /* [out] */ IMFSample **ppIPacket) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Flush( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE End( 
            /* [out][in] */ IMFASFContentInfo *pIContentInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatistics( 
            /* [in] */ WORD wStreamNumber,
            /* [out] */ ASF_MUX_STATISTICS *pMuxStats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSyncTolerance( 
            /* [in] */ DWORD msSyncTolerance) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFASFMultiplexerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFASFMultiplexer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFASFMultiplexer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFASFMultiplexer * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IMFASFMultiplexer * This,
            /* [in] */ IMFASFContentInfo *pIContentInfo);
        
        HRESULT ( STDMETHODCALLTYPE *SetFlags )( 
            IMFASFMultiplexer * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetFlags )( 
            IMFASFMultiplexer * This,
            /* [out] */ DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessSample )( 
            IMFASFMultiplexer * This,
            /* [in] */ WORD wStreamNumber,
            /* [in] */ IMFSample *pISample,
            /* [in] */ LONGLONG hnsTimestampAdjust);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextPacket )( 
            IMFASFMultiplexer * This,
            /* [out] */ DWORD *pdwStatusFlags,
            /* [out] */ IMFSample **ppIPacket);
        
        HRESULT ( STDMETHODCALLTYPE *Flush )( 
            IMFASFMultiplexer * This);
        
        HRESULT ( STDMETHODCALLTYPE *End )( 
            IMFASFMultiplexer * This,
            /* [out][in] */ IMFASFContentInfo *pIContentInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatistics )( 
            IMFASFMultiplexer * This,
            /* [in] */ WORD wStreamNumber,
            /* [out] */ ASF_MUX_STATISTICS *pMuxStats);
        
        HRESULT ( STDMETHODCALLTYPE *SetSyncTolerance )( 
            IMFASFMultiplexer * This,
            /* [in] */ DWORD msSyncTolerance);
        
        END_INTERFACE
    } IMFASFMultiplexerVtbl;

    interface IMFASFMultiplexer
    {
        CONST_VTBL struct IMFASFMultiplexerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFASFMultiplexer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFASFMultiplexer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFASFMultiplexer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFASFMultiplexer_Initialize(This,pIContentInfo)	\
    ( (This)->lpVtbl -> Initialize(This,pIContentInfo) ) 

#define IMFASFMultiplexer_SetFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> SetFlags(This,dwFlags) ) 

#define IMFASFMultiplexer_GetFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> GetFlags(This,pdwFlags) ) 

#define IMFASFMultiplexer_ProcessSample(This,wStreamNumber,pISample,hnsTimestampAdjust)	\
    ( (This)->lpVtbl -> ProcessSample(This,wStreamNumber,pISample,hnsTimestampAdjust) ) 

#define IMFASFMultiplexer_GetNextPacket(This,pdwStatusFlags,ppIPacket)	\
    ( (This)->lpVtbl -> GetNextPacket(This,pdwStatusFlags,ppIPacket) ) 

#define IMFASFMultiplexer_Flush(This)	\
    ( (This)->lpVtbl -> Flush(This) ) 

#define IMFASFMultiplexer_End(This,pIContentInfo)	\
    ( (This)->lpVtbl -> End(This,pIContentInfo) ) 

#define IMFASFMultiplexer_GetStatistics(This,wStreamNumber,pMuxStats)	\
    ( (This)->lpVtbl -> GetStatistics(This,wStreamNumber,pMuxStats) ) 

#define IMFASFMultiplexer_SetSyncTolerance(This,msSyncTolerance)	\
    ( (This)->lpVtbl -> SetSyncTolerance(This,msSyncTolerance) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFASFMultiplexer_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wmcontainer_0000_0007 */
/* [local] */ 

STDAPI MFCreateASFMultiplexer( 
        /* out */     IMFASFMultiplexer     **ppIMultiplexer);
typedef 
enum MFASF_INDEXERFLAGS
    {	MFASF_INDEXER_WRITE_NEW_INDEX	= 0x1,
	MFASF_INDEXER_READ_FOR_REVERSEPLAYBACK	= 0x2,
	MFASF_INDEXER_WRITE_FOR_LIVEREAD	= 0x4
    } 	MFASF_INDEXER_FLAGS;

typedef struct _ASF_INDEX_IDENTIFIER
    {
    GUID guidIndexType;
    WORD wStreamNumber;
    } 	ASF_INDEX_IDENTIFIER;

typedef struct _ASF_INDEX_DESCRIPTOR
    {
    ASF_INDEX_IDENTIFIER Identifier;
    WORD cPerEntryBytes;
    WCHAR szDescription[ 32 ];
    DWORD dwInterval;
    } 	ASF_INDEX_DESCRIPTOR;



extern RPC_IF_HANDLE __MIDL_itf_wmcontainer_0000_0007_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmcontainer_0000_0007_v0_0_s_ifspec;

#ifndef __IMFASFIndexer_INTERFACE_DEFINED__
#define __IMFASFIndexer_INTERFACE_DEFINED__

/* interface IMFASFIndexer */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFASFIndexer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("53590F48-DC3B-4297-813F-787761AD7B3E")
    IMFASFIndexer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFlags( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFlags( 
            /* [out] */ DWORD *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IMFASFContentInfo *pIContentInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIndexPosition( 
            /* [in] */ IMFASFContentInfo *pIContentInfo,
            /* [out] */ QWORD *pcbIndexOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIndexByteStreams( 
            /* [in] */ IMFByteStream **ppIByteStreams,
            /* [in] */ DWORD cByteStreams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIndexByteStreamCount( 
            /* [out] */ DWORD *pcByteStreams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIndexStatus( 
            /* [in] */ ASF_INDEX_IDENTIFIER *pIndexIdentifier,
            /* [out] */ BOOL *pfIsIndexed,
            /* [out] */ BYTE *pbIndexDescriptor,
            /* [out][in] */ DWORD *pcbIndexDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIndexStatus( 
            /* [in] */ BYTE *pbIndexDescriptor,
            /* [in] */ DWORD cbIndexDescriptor,
            /* [in] */ BOOL fGenerateIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSeekPositionForValue( 
            /* [in] */ const PROPVARIANT *pvarValue,
            /* [in] */ ASF_INDEX_IDENTIFIER *pIndexIdentifier,
            /* [out] */ QWORD *pcbOffsetWithinData,
            /* [optional][out] */ MFTIME *phnsApproxTime,
            /* [optional][out] */ DWORD *pdwPayloadNumberOfStreamWithinPacket) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GenerateIndexEntries( 
            /* [in] */ IMFSample *pIASFPacketSample) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommitIndex( 
            /* [in] */ IMFASFContentInfo *pIContentInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIndexWriteSpace( 
            /* [out] */ QWORD *pcbIndexWriteSpace) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompletedIndex( 
            /* [in] */ IMFMediaBuffer *pIIndexBuffer,
            /* [in] */ QWORD cbOffsetWithinIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFASFIndexerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFASFIndexer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFASFIndexer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFASFIndexer * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFlags )( 
            IMFASFIndexer * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetFlags )( 
            IMFASFIndexer * This,
            /* [out] */ DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IMFASFIndexer * This,
            /* [in] */ IMFASFContentInfo *pIContentInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIndexPosition )( 
            IMFASFIndexer * This,
            /* [in] */ IMFASFContentInfo *pIContentInfo,
            /* [out] */ QWORD *pcbIndexOffset);
        
        HRESULT ( STDMETHODCALLTYPE *SetIndexByteStreams )( 
            IMFASFIndexer * This,
            /* [in] */ IMFByteStream **ppIByteStreams,
            /* [in] */ DWORD cByteStreams);
        
        HRESULT ( STDMETHODCALLTYPE *GetIndexByteStreamCount )( 
            IMFASFIndexer * This,
            /* [out] */ DWORD *pcByteStreams);
        
        HRESULT ( STDMETHODCALLTYPE *GetIndexStatus )( 
            IMFASFIndexer * This,
            /* [in] */ ASF_INDEX_IDENTIFIER *pIndexIdentifier,
            /* [out] */ BOOL *pfIsIndexed,
            /* [out] */ BYTE *pbIndexDescriptor,
            /* [out][in] */ DWORD *pcbIndexDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *SetIndexStatus )( 
            IMFASFIndexer * This,
            /* [in] */ BYTE *pbIndexDescriptor,
            /* [in] */ DWORD cbIndexDescriptor,
            /* [in] */ BOOL fGenerateIndex);
        
        HRESULT ( STDMETHODCALLTYPE *GetSeekPositionForValue )( 
            IMFASFIndexer * This,
            /* [in] */ const PROPVARIANT *pvarValue,
            /* [in] */ ASF_INDEX_IDENTIFIER *pIndexIdentifier,
            /* [out] */ QWORD *pcbOffsetWithinData,
            /* [optional][out] */ MFTIME *phnsApproxTime,
            /* [optional][out] */ DWORD *pdwPayloadNumberOfStreamWithinPacket);
        
        HRESULT ( STDMETHODCALLTYPE *GenerateIndexEntries )( 
            IMFASFIndexer * This,
            /* [in] */ IMFSample *pIASFPacketSample);
        
        HRESULT ( STDMETHODCALLTYPE *CommitIndex )( 
            IMFASFIndexer * This,
            /* [in] */ IMFASFContentInfo *pIContentInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIndexWriteSpace )( 
            IMFASFIndexer * This,
            /* [out] */ QWORD *pcbIndexWriteSpace);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompletedIndex )( 
            IMFASFIndexer * This,
            /* [in] */ IMFMediaBuffer *pIIndexBuffer,
            /* [in] */ QWORD cbOffsetWithinIndex);
        
        END_INTERFACE
    } IMFASFIndexerVtbl;

    interface IMFASFIndexer
    {
        CONST_VTBL struct IMFASFIndexerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFASFIndexer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFASFIndexer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFASFIndexer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFASFIndexer_SetFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> SetFlags(This,dwFlags) ) 

#define IMFASFIndexer_GetFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> GetFlags(This,pdwFlags) ) 

#define IMFASFIndexer_Initialize(This,pIContentInfo)	\
    ( (This)->lpVtbl -> Initialize(This,pIContentInfo) ) 

#define IMFASFIndexer_GetIndexPosition(This,pIContentInfo,pcbIndexOffset)	\
    ( (This)->lpVtbl -> GetIndexPosition(This,pIContentInfo,pcbIndexOffset) ) 

#define IMFASFIndexer_SetIndexByteStreams(This,ppIByteStreams,cByteStreams)	\
    ( (This)->lpVtbl -> SetIndexByteStreams(This,ppIByteStreams,cByteStreams) ) 

#define IMFASFIndexer_GetIndexByteStreamCount(This,pcByteStreams)	\
    ( (This)->lpVtbl -> GetIndexByteStreamCount(This,pcByteStreams) ) 

#define IMFASFIndexer_GetIndexStatus(This,pIndexIdentifier,pfIsIndexed,pbIndexDescriptor,pcbIndexDescriptor)	\
    ( (This)->lpVtbl -> GetIndexStatus(This,pIndexIdentifier,pfIsIndexed,pbIndexDescriptor,pcbIndexDescriptor) ) 

#define IMFASFIndexer_SetIndexStatus(This,pbIndexDescriptor,cbIndexDescriptor,fGenerateIndex)	\
    ( (This)->lpVtbl -> SetIndexStatus(This,pbIndexDescriptor,cbIndexDescriptor,fGenerateIndex) ) 

#define IMFASFIndexer_GetSeekPositionForValue(This,pvarValue,pIndexIdentifier,pcbOffsetWithinData,phnsApproxTime,pdwPayloadNumberOfStreamWithinPacket)	\
    ( (This)->lpVtbl -> GetSeekPositionForValue(This,pvarValue,pIndexIdentifier,pcbOffsetWithinData,phnsApproxTime,pdwPayloadNumberOfStreamWithinPacket) ) 

#define IMFASFIndexer_GenerateIndexEntries(This,pIASFPacketSample)	\
    ( (This)->lpVtbl -> GenerateIndexEntries(This,pIASFPacketSample) ) 

#define IMFASFIndexer_CommitIndex(This,pIContentInfo)	\
    ( (This)->lpVtbl -> CommitIndex(This,pIContentInfo) ) 

#define IMFASFIndexer_GetIndexWriteSpace(This,pcbIndexWriteSpace)	\
    ( (This)->lpVtbl -> GetIndexWriteSpace(This,pcbIndexWriteSpace) ) 

#define IMFASFIndexer_GetCompletedIndex(This,pIIndexBuffer,cbOffsetWithinIndex)	\
    ( (This)->lpVtbl -> GetCompletedIndex(This,pIIndexBuffer,cbOffsetWithinIndex) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFASFIndexer_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wmcontainer_0000_0008 */
/* [local] */ 

#if (WINVER >= _WIN32_WINNT_WIN7) 
EXTERN_GUID( MFASFINDEXER_TYPE_TIMECODE, 0x49815231, 0x6bad, 0x44fd, 0x81, 0xa, 0x3f, 0x60, 0x98, 0x4e, 0xc7, 0xfd );
#endif // (WINVER >= _WIN32_WINNT_WIN7) 
#define MFASFINDEXER_PER_ENTRY_BYTES_DYNAMIC        0xffff
#define MFASFINDEXER_NO_FIXED_INTERVAL              0xffffffff
#define MFASFINDEXER_READ_FOR_REVERSEPLAYBACK_OUTOFDATASEGMENT        0xffffffffffffffff
#define MFASFINDEXER_APPROX_SEEK_TIME_UNKNOWN 0xffffffffffffffff
STDAPI MFCreateASFIndexer( 
        /* out */     IMFASFIndexer         **ppIIndexer);
STDAPI MFCreateASFIndexerByteStream( 
        /* in */      IMFByteStream         *pIContentByteStream,
        /* in */      QWORD                  cbIndexStartOffset,
        /* out */     IMFByteStream        **pIIndexByteStream);
typedef 
enum MFASF_STREAMSELECTORFLAGS
    {	MFASF_STREAMSELECTOR_DISABLE_THINNING	= 0x1,
	MFASF_STREAMSELECTOR_USE_AVERAGE_BITRATE	= 0x2
    } 	MFASF_STREAMSELECTOR_FLAGS;

typedef 
enum ASF_SELECTION_STATUS
    {	ASF_STATUS_NOTSELECTED	= 0,
	ASF_STATUS_CLEANPOINTSONLY	= 1,
	ASF_STATUS_ALLDATAUNITS	= 2
    } 	ASF_SELECTION_STATUS;



extern RPC_IF_HANDLE __MIDL_itf_wmcontainer_0000_0008_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmcontainer_0000_0008_v0_0_s_ifspec;

#ifndef __IMFASFStreamSelector_INTERFACE_DEFINED__
#define __IMFASFStreamSelector_INTERFACE_DEFINED__

/* interface IMFASFStreamSelector */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFASFStreamSelector;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d01bad4a-4fa0-4a60-9349-c27e62da9d41")
    IMFASFStreamSelector : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStreamCount( 
            /* [out] */ DWORD *pcStreams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputCount( 
            /* [out] */ DWORD *pcOutputs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputStreamCount( 
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ DWORD *pcStreams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputStreamNumbers( 
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ WORD *rgwStreamNumbers) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputFromStream( 
            /* [in] */ WORD wStreamNum,
            /* [out] */ DWORD *pdwOutput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputOverride( 
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ ASF_SELECTION_STATUS *pSelection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOutputOverride( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ ASF_SELECTION_STATUS Selection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputMutexCount( 
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ DWORD *pcMutexes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputMutex( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ DWORD dwMutexNum,
            /* [out] */ IUnknown **ppMutex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOutputMutexSelection( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ DWORD dwMutexNum,
            /* [in] */ WORD wSelectedRecord) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBandwidthStepCount( 
            /* [out] */ DWORD *pcStepCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBandwidthStep( 
            /* [in] */ DWORD dwStepNum,
            /* [out] */ DWORD *pdwBitrate,
            /* [out] */ WORD *rgwStreamNumbers,
            /* [out] */ ASF_SELECTION_STATUS *rgSelections) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BitrateToStepNumber( 
            /* [in] */ DWORD dwBitrate,
            /* [out] */ DWORD *pdwStepNum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStreamSelectorFlags( 
            /* [in] */ DWORD dwStreamSelectorFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFASFStreamSelectorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFASFStreamSelector * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFASFStreamSelector * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFASFStreamSelector * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamCount )( 
            IMFASFStreamSelector * This,
            /* [out] */ DWORD *pcStreams);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputCount )( 
            IMFASFStreamSelector * This,
            /* [out] */ DWORD *pcOutputs);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputStreamCount )( 
            IMFASFStreamSelector * This,
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ DWORD *pcStreams);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputStreamNumbers )( 
            IMFASFStreamSelector * This,
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ WORD *rgwStreamNumbers);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputFromStream )( 
            IMFASFStreamSelector * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ DWORD *pdwOutput);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputOverride )( 
            IMFASFStreamSelector * This,
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ ASF_SELECTION_STATUS *pSelection);
        
        HRESULT ( STDMETHODCALLTYPE *SetOutputOverride )( 
            IMFASFStreamSelector * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ ASF_SELECTION_STATUS Selection);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputMutexCount )( 
            IMFASFStreamSelector * This,
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ DWORD *pcMutexes);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputMutex )( 
            IMFASFStreamSelector * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ DWORD dwMutexNum,
            /* [out] */ IUnknown **ppMutex);
        
        HRESULT ( STDMETHODCALLTYPE *SetOutputMutexSelection )( 
            IMFASFStreamSelector * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ DWORD dwMutexNum,
            /* [in] */ WORD wSelectedRecord);
        
        HRESULT ( STDMETHODCALLTYPE *GetBandwidthStepCount )( 
            IMFASFStreamSelector * This,
            /* [out] */ DWORD *pcStepCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetBandwidthStep )( 
            IMFASFStreamSelector * This,
            /* [in] */ DWORD dwStepNum,
            /* [out] */ DWORD *pdwBitrate,
            /* [out] */ WORD *rgwStreamNumbers,
            /* [out] */ ASF_SELECTION_STATUS *rgSelections);
        
        HRESULT ( STDMETHODCALLTYPE *BitrateToStepNumber )( 
            IMFASFStreamSelector * This,
            /* [in] */ DWORD dwBitrate,
            /* [out] */ DWORD *pdwStepNum);
        
        HRESULT ( STDMETHODCALLTYPE *SetStreamSelectorFlags )( 
            IMFASFStreamSelector * This,
            /* [in] */ DWORD dwStreamSelectorFlags);
        
        END_INTERFACE
    } IMFASFStreamSelectorVtbl;

    interface IMFASFStreamSelector
    {
        CONST_VTBL struct IMFASFStreamSelectorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFASFStreamSelector_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFASFStreamSelector_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFASFStreamSelector_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFASFStreamSelector_GetStreamCount(This,pcStreams)	\
    ( (This)->lpVtbl -> GetStreamCount(This,pcStreams) ) 

#define IMFASFStreamSelector_GetOutputCount(This,pcOutputs)	\
    ( (This)->lpVtbl -> GetOutputCount(This,pcOutputs) ) 

#define IMFASFStreamSelector_GetOutputStreamCount(This,dwOutputNum,pcStreams)	\
    ( (This)->lpVtbl -> GetOutputStreamCount(This,dwOutputNum,pcStreams) ) 

#define IMFASFStreamSelector_GetOutputStreamNumbers(This,dwOutputNum,rgwStreamNumbers)	\
    ( (This)->lpVtbl -> GetOutputStreamNumbers(This,dwOutputNum,rgwStreamNumbers) ) 

#define IMFASFStreamSelector_GetOutputFromStream(This,wStreamNum,pdwOutput)	\
    ( (This)->lpVtbl -> GetOutputFromStream(This,wStreamNum,pdwOutput) ) 

#define IMFASFStreamSelector_GetOutputOverride(This,dwOutputNum,pSelection)	\
    ( (This)->lpVtbl -> GetOutputOverride(This,dwOutputNum,pSelection) ) 

#define IMFASFStreamSelector_SetOutputOverride(This,dwOutputNum,Selection)	\
    ( (This)->lpVtbl -> SetOutputOverride(This,dwOutputNum,Selection) ) 

#define IMFASFStreamSelector_GetOutputMutexCount(This,dwOutputNum,pcMutexes)	\
    ( (This)->lpVtbl -> GetOutputMutexCount(This,dwOutputNum,pcMutexes) ) 

#define IMFASFStreamSelector_GetOutputMutex(This,dwOutputNum,dwMutexNum,ppMutex)	\
    ( (This)->lpVtbl -> GetOutputMutex(This,dwOutputNum,dwMutexNum,ppMutex) ) 

#define IMFASFStreamSelector_SetOutputMutexSelection(This,dwOutputNum,dwMutexNum,wSelectedRecord)	\
    ( (This)->lpVtbl -> SetOutputMutexSelection(This,dwOutputNum,dwMutexNum,wSelectedRecord) ) 

#define IMFASFStreamSelector_GetBandwidthStepCount(This,pcStepCount)	\
    ( (This)->lpVtbl -> GetBandwidthStepCount(This,pcStepCount) ) 

#define IMFASFStreamSelector_GetBandwidthStep(This,dwStepNum,pdwBitrate,rgwStreamNumbers,rgSelections)	\
    ( (This)->lpVtbl -> GetBandwidthStep(This,dwStepNum,pdwBitrate,rgwStreamNumbers,rgSelections) ) 

#define IMFASFStreamSelector_BitrateToStepNumber(This,dwBitrate,pdwStepNum)	\
    ( (This)->lpVtbl -> BitrateToStepNumber(This,dwBitrate,pdwStepNum) ) 

#define IMFASFStreamSelector_SetStreamSelectorFlags(This,dwStreamSelectorFlags)	\
    ( (This)->lpVtbl -> SetStreamSelectorFlags(This,dwStreamSelectorFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFASFStreamSelector_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wmcontainer_0000_0009 */
/* [local] */ 

STDAPI MFCreateASFStreamSelector( 
    /* in */ IMFASFProfile *pIASFProfile, 
    /* out */ IMFASFStreamSelector **ppSelector );
STDAPI
MFCreateASFMediaSink(
    IMFByteStream *pIByteStream,
    IMFMediaSink** ppIMediaSink
    );
STDAPI MFCreateASFMediaSinkActivate(
    LPCWSTR pwszFileName,
    IMFASFContentInfo *pContentInfo,
    IMFActivate** ppIActivate
    );
HRESULT STDMETHODCALLTYPE
MFCreateWMVEncoderActivate(
    IMFMediaType * pMediaType, 
    IPropertyStore * pEncodingConfigurationProperties, 
    IMFActivate ** ppActivate 
    );
HRESULT STDMETHODCALLTYPE
MFCreateWMAEncoderActivate(
    IMFMediaType * pMediaType, 
    IPropertyStore * pEncodingConfigurationProperties, 
    IMFActivate ** ppActivate 
    );
STDAPI
MFCreateASFStreamingMediaSink(
    IMFByteStream *pIByteStream,
    IMFMediaSink** ppIMediaSink
    );
STDAPI MFCreateASFStreamingMediaSinkActivate(
    IMFActivate *pByteStreamActivate,
    IMFASFContentInfo *pContentInfo,
    IMFActivate** ppIActivate
    );
EXTERN_C const DECLSPEC_SELECTANY PROPERTYKEY MFPKEY_ASFMEDIASINK_BASE_SENDTIME = { { 0xcddcbc82, 0x3411, 0x4119, 0x91, 0x35, 0x84, 0x23, 0xc4, 0x1b, 0x39, 0x57}, 3  }; 
EXTERN_C const DECLSPEC_SELECTANY PROPERTYKEY MFPKEY_ASFMEDIASINK_AUTOADJUST_BITRATE = { { 0xcddcbc82, 0x3411, 0x4119, 0x91, 0x35, 0x84, 0x23, 0xc4, 0x1b, 0x39, 0x57}, 4  }; 
EXTERN_C const DECLSPEC_SELECTANY PROPERTYKEY MFPKEY_ASFMEDIASINK_DRMACTION = { { 0xa1db6f6c, 0x1d0a, 0x4cb6, 0x82, 0x54, 0xcb, 0x36, 0xbe, 0xed, 0xbc, 0x48}, 5  }; 
typedef 
enum _MFSINK_WMDRMACTION
    {	MFSINK_WMDRMACTION_UNDEFINED	= 0,
	MFSINK_WMDRMACTION_ENCODE	= 1,
	MFSINK_WMDRMACTION_TRANSCODE	= 2,
	MFSINK_WMDRMACTION_TRANSCRYPT	= 3,
	MFSINK_WMDRMACTION_LAST	= 3
    } 	MFSINK_WMDRMACTION;

EXTERN_C const DECLSPEC_SELECTANY PROPERTYKEY MFPKEY_ASFSTREAMSINK_CORRECTED_LEAKYBUCKET = { { 0xa2f152fb, 0x8ad9, 0x4a11, 0xb3, 0x45, 0x2c, 0xe2, 0xfa, 0xd8, 0x72, 0x3d}, 1  }; 
// 
// Define WMContainer constants 
// 
#define  MFASF_MAX_STREAM_NUMBER       127
#define  MFASF_INVALID_STREAM_NUMBER  ( MFASF_MAX_STREAM_NUMBER + 1 )
#define  MFASF_PAYLOADEXTENSION_MAX_SIZE        0xff
#define  MFASF_PAYLOADEXTENSION_VARIABLE_SIZE   0xffff
#define  MFASF_DEFAULT_BUFFER_WINDOW_MS 		3000
// 
#if (WINVER >= _WIN32_WINNT_WIN7) 


extern RPC_IF_HANDLE __MIDL_itf_wmcontainer_0000_0009_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmcontainer_0000_0009_v0_0_s_ifspec;

#ifndef __IMFDRMNetHelper_INTERFACE_DEFINED__
#define __IMFDRMNetHelper_INTERFACE_DEFINED__

/* interface IMFDRMNetHelper */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMFDRMNetHelper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3D1FF0EA-679A-4190-8D46-7FA69E8C7E15")
    IMFDRMNetHelper : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ProcessLicenseRequest( 
            /* [size_is][in] */ BYTE *pLicenseRequest,
            /* [in] */ DWORD cbLicenseRequest,
            /* [size_is][size_is][out] */ BYTE **ppLicenseResponse,
            /* [out] */ DWORD *pcbLicenseResponse,
            /* [out] */ BSTR *pbstrKID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetChainedLicenseResponse( 
            /* [size_is][size_is][out] */ BYTE **ppLicenseResponse,
            /* [out] */ DWORD *pcbLicenseResponse) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFDRMNetHelperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMFDRMNetHelper * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMFDRMNetHelper * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMFDRMNetHelper * This);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessLicenseRequest )( 
            IMFDRMNetHelper * This,
            /* [size_is][in] */ BYTE *pLicenseRequest,
            /* [in] */ DWORD cbLicenseRequest,
            /* [size_is][size_is][out] */ BYTE **ppLicenseResponse,
            /* [out] */ DWORD *pcbLicenseResponse,
            /* [out] */ BSTR *pbstrKID);
        
        HRESULT ( STDMETHODCALLTYPE *GetChainedLicenseResponse )( 
            IMFDRMNetHelper * This,
            /* [size_is][size_is][out] */ BYTE **ppLicenseResponse,
            /* [out] */ DWORD *pcbLicenseResponse);
        
        END_INTERFACE
    } IMFDRMNetHelperVtbl;

    interface IMFDRMNetHelper
    {
        CONST_VTBL struct IMFDRMNetHelperVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFDRMNetHelper_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFDRMNetHelper_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFDRMNetHelper_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFDRMNetHelper_ProcessLicenseRequest(This,pLicenseRequest,cbLicenseRequest,ppLicenseResponse,pcbLicenseResponse,pbstrKID)	\
    ( (This)->lpVtbl -> ProcessLicenseRequest(This,pLicenseRequest,cbLicenseRequest,ppLicenseResponse,pcbLicenseResponse,pbstrKID) ) 

#define IMFDRMNetHelper_GetChainedLicenseResponse(This,ppLicenseResponse,pcbLicenseResponse)	\
    ( (This)->lpVtbl -> GetChainedLicenseResponse(This,ppLicenseResponse,pcbLicenseResponse) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFDRMNetHelper_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_wmcontainer_0000_0010 */
/* [local] */ 

#endif // (WINVER >= _WIN32_WINNT_WIN7) 


extern RPC_IF_HANDLE __MIDL_itf_wmcontainer_0000_0010_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmcontainer_0000_0010_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\wmpocx.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0543 */
/* Compiler settings for wmpocx.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wmpocx_h__
#define __wmpocx_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWMPPlayer_FWD_DEFINED__
#define __IWMPPlayer_FWD_DEFINED__
typedef interface IWMPPlayer IWMPPlayer;
#endif 	/* __IWMPPlayer_FWD_DEFINED__ */


#ifndef __IWMPPlayer2_FWD_DEFINED__
#define __IWMPPlayer2_FWD_DEFINED__
typedef interface IWMPPlayer2 IWMPPlayer2;
#endif 	/* __IWMPPlayer2_FWD_DEFINED__ */


#ifndef __IWMPPlayer3_FWD_DEFINED__
#define __IWMPPlayer3_FWD_DEFINED__
typedef interface IWMPPlayer3 IWMPPlayer3;
#endif 	/* __IWMPPlayer3_FWD_DEFINED__ */


#ifndef __IWMPPlayer4_FWD_DEFINED__
#define __IWMPPlayer4_FWD_DEFINED__
typedef interface IWMPPlayer4 IWMPPlayer4;
#endif 	/* __IWMPPlayer4_FWD_DEFINED__ */


#ifndef __IWMPSettings2_FWD_DEFINED__
#define __IWMPSettings2_FWD_DEFINED__
typedef interface IWMPSettings2 IWMPSettings2;
#endif 	/* __IWMPSettings2_FWD_DEFINED__ */


#ifndef __IWMPEvents_FWD_DEFINED__
#define __IWMPEvents_FWD_DEFINED__
typedef interface IWMPEvents IWMPEvents;
#endif 	/* __IWMPEvents_FWD_DEFINED__ */


#ifndef ___WMPOCXEvents_FWD_DEFINED__
#define ___WMPOCXEvents_FWD_DEFINED__
typedef interface _WMPOCXEvents _WMPOCXEvents;
#endif 	/* ___WMPOCXEvents_FWD_DEFINED__ */


#ifndef __WMPOCX_FWD_DEFINED__
#define __WMPOCX_FWD_DEFINED__

#ifdef __cplusplus
typedef class WMPOCX WMPOCX;
#else
typedef struct WMPOCX WMPOCX;
#endif /* __cplusplus */

#endif 	/* __WMPOCX_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "oaidl.h"
#include "ocidl.h"
#include "objsafe.h"
#include "wmpcore.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_wmpocx_0000_0000 */
/* [local] */ 

#pragma once


extern RPC_IF_HANDLE __MIDL_itf_wmpocx_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmpocx_0000_0000_v0_0_s_ifspec;

#ifndef __IWMPPlayer_INTERFACE_DEFINED__
#define __IWMPPlayer_INTERFACE_DEFINED__

/* interface IWMPPlayer */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPPlayer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6BF52A4F-394A-11d3-B153-00C04F79FAA6")
    IWMPPlayer : public IWMPCore
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_enabled( 
            /* [retval][out] */ VARIANT_BOOL *pbEnabled) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_enabled( 
            /* [in] */ VARIANT_BOOL bEnabled) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_fullScreen( 
            /* [retval][out] */ VARIANT_BOOL *pbFullScreen) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_fullScreen( 
            VARIANT_BOOL bFullScreen) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_enableContextMenu( 
            /* [retval][out] */ VARIANT_BOOL *pbEnableContextMenu) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_enableContextMenu( 
            VARIANT_BOOL bEnableContextMenu) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_uiMode( 
            /* [in] */ BSTR bstrMode) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_uiMode( 
            /* [retval][out] */ BSTR *pbstrMode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPPlayerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMPPlayer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMPPlayer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMPPlayer * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMPPlayer * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMPPlayer * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMPPlayer * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMPPlayer * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *close )( 
            IWMPPlayer * This);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_URL )( 
            IWMPPlayer * This,
            /* [retval][out] */ BSTR *pbstrURL);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_URL )( 
            IWMPPlayer * This,
            /* [in] */ BSTR bstrURL);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_openState )( 
            IWMPPlayer * This,
            /* [retval][out] */ WMPOpenState *pwmpos);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_playState )( 
            IWMPPlayer * This,
            /* [retval][out] */ WMPPlayState *pwmpps);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_controls )( 
            IWMPPlayer * This,
            /* [retval][out] */ IWMPControls **ppControl);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_settings )( 
            IWMPPlayer * This,
            /* [retval][out] */ IWMPSettings **ppSettings);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_currentMedia )( 
            IWMPPlayer * This,
            /* [retval][out] */ IWMPMedia **ppMedia);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_currentMedia )( 
            IWMPPlayer * This,
            /* [in] */ IWMPMedia *pMedia);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_mediaCollection )( 
            IWMPPlayer * This,
            /* [retval][out] */ IWMPMediaCollection **ppMediaCollection);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_playlistCollection )( 
            IWMPPlayer * This,
            /* [retval][out] */ IWMPPlaylistCollection **ppPlaylistCollection);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_versionInfo )( 
            IWMPPlayer * This,
            /* [retval][out] */ BSTR *pbstrVersionInfo);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *launchURL )( 
            IWMPPlayer * This,
            BSTR bstrURL);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_network )( 
            IWMPPlayer * This,
            /* [retval][out] */ IWMPNetwork **ppQNI);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_currentPlaylist )( 
            IWMPPlayer * This,
            /* [retval][out] */ IWMPPlaylist **ppPL);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_currentPlaylist )( 
            IWMPPlayer * This,
            /* [in] */ IWMPPlaylist *pPL);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_cdromCollection )( 
            IWMPPlayer * This,
            /* [retval][out] */ IWMPCdromCollection **ppCdromCollection);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_closedCaption )( 
            IWMPPlayer * This,
            /* [retval][out] */ IWMPClosedCaption **ppClosedCaption);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_isOnline )( 
            IWMPPlayer * This,
            /* [retval][out] */ VARIANT_BOOL *pfOnline);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_error )( 
            IWMPPlayer * This,
            /* [retval][out] */ IWMPError **ppError);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_status )( 
            IWMPPlayer * This,
            /* [retval][out] */ BSTR *pbstrStatus);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_enabled )( 
            IWMPPlayer * This,
            /* [retval][out] */ VARIANT_BOOL *pbEnabled);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_enabled )( 
            IWMPPlayer * This,
            /* [in] */ VARIANT_BOOL bEnabled);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_fullScreen )( 
            IWMPPlayer * This,
            /* [retval][out] */ VARIANT_BOOL *pbFullScreen);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_fullScreen )( 
            IWMPPlayer * This,
            VARIANT_BOOL bFullScreen);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_enableContextMenu )( 
            IWMPPlayer * This,
            /* [retval][out] */ VARIANT_BOOL *pbEnableContextMenu);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_enableContextMenu )( 
            IWMPPlayer * This,
            VARIANT_BOOL bEnableContextMenu);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_uiMode )( 
            IWMPPlayer * This,
            /* [in] */ BSTR bstrMode);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_uiMode )( 
            IWMPPlayer * This,
            /* [retval][out] */ BSTR *pbstrMode);
        
        END_INTERFACE
    } IWMPPlayerVtbl;

    interface IWMPPlayer
    {
        CONST_VTBL struct IWMPPlayerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPPlayer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMPPlayer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMPPlayer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMPPlayer_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWMPPlayer_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWMPPlayer_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWMPPlayer_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWMPPlayer_close(This)	\
    ( (This)->lpVtbl -> close(This) ) 

#define IWMPPlayer_get_URL(This,pbstrURL)	\
    ( (This)->lpVtbl -> get_URL(This,pbstrURL) ) 

#define IWMPPlayer_put_URL(This,bstrURL)	\
    ( (This)->lpVtbl -> put_URL(This,bstrURL) ) 

#define IWMPPlayer_get_openState(This,pwmpos)	\
    ( (This)->lpVtbl -> get_openState(This,pwmpos) ) 

#define IWMPPlayer_get_playState(This,pwmpps)	\
    ( (This)->lpVtbl -> get_playState(This,pwmpps) ) 

#define IWMPPlayer_get_controls(This,ppControl)	\
    ( (This)->lpVtbl -> get_controls(This,ppControl) ) 

#define IWMPPlayer_get_settings(This,ppSettings)	\
    ( (This)->lpVtbl -> get_settings(This,ppSettings) ) 

#define IWMPPlayer_get_currentMedia(This,ppMedia)	\
    ( (This)->lpVtbl -> get_currentMedia(This,ppMedia) ) 

#define IWMPPlayer_put_currentMedia(This,pMedia)	\
    ( (This)->lpVtbl -> put_currentMedia(This,pMedia) ) 

#define IWMPPlayer_get_mediaCollection(This,ppMediaCollection)	\
    ( (This)->lpVtbl -> get_mediaCollection(This,ppMediaCollection) ) 

#define IWMPPlayer_get_playlistCollection(This,ppPlaylistCollection)	\
    ( (This)->lpVtbl -> get_playlistCollection(This,ppPlaylistCollection) ) 

#define IWMPPlayer_get_versionInfo(This,pbstrVersionInfo)	\
    ( (This)->lpVtbl -> get_versionInfo(This,pbstrVersionInfo) ) 

#define IWMPPlayer_launchURL(This,bstrURL)	\
    ( (This)->lpVtbl -> launchURL(This,bstrURL) ) 

#define IWMPPlayer_get_network(This,ppQNI)	\
    ( (This)->lpVtbl -> get_network(This,ppQNI) ) 

#define IWMPPlayer_get_currentPlaylist(This,ppPL)	\
    ( (This)->lpVtbl -> get_currentPlaylist(This,ppPL) ) 

#define IWMPPlayer_put_currentPlaylist(This,pPL)	\
    ( (This)->lpVtbl -> put_currentPlaylist(This,pPL) ) 

#define IWMPPlayer_get_cdromCollection(This,ppCdromCollection)	\
    ( (This)->lpVtbl -> get_cdromCollection(This,ppCdromCollection) ) 

#define IWMPPlayer_get_closedCaption(This,ppClosedCaption)	\
    ( (This)->lpVtbl -> get_closedCaption(This,ppClosedCaption) ) 

#define IWMPPlayer_get_isOnline(This,pfOnline)	\
    ( (This)->lpVtbl -> get_isOnline(This,pfOnline) ) 

#define IWMPPlayer_get_error(This,ppError)	\
    ( (This)->lpVtbl -> get_error(This,ppError) ) 

#define IWMPPlayer_get_status(This,pbstrStatus)	\
    ( (This)->lpVtbl -> get_status(This,pbstrStatus) ) 


#define IWMPPlayer_get_enabled(This,pbEnabled)	\
    ( (This)->lpVtbl -> get_enabled(This,pbEnabled) ) 

#define IWMPPlayer_put_enabled(This,bEnabled)	\
    ( (This)->lpVtbl -> put_enabled(This,bEnabled) ) 

#define IWMPPlayer_get_fullScreen(This,pbFullScreen)	\
    ( (This)->lpVtbl -> get_fullScreen(This,pbFullScreen) ) 

#define IWMPPlayer_put_fullScreen(This,bFullScreen)	\
    ( (This)->lpVtbl -> put_fullScreen(This,bFullScreen) ) 

#define IWMPPlayer_get_enableContextMenu(This,pbEnableContextMenu)	\
    ( (This)->lpVtbl -> get_enableContextMenu(This,pbEnableContextMenu) ) 

#define IWMPPlayer_put_enableContextMenu(This,bEnableContextMenu)	\
    ( (This)->lpVtbl -> put_enableContextMenu(This,bEnableContextMenu) ) 

#define IWMPPlayer_put_uiMode(This,bstrMode)	\
    ( (This)->lpVtbl -> put_uiMode(This,bstrMode) ) 

#define IWMPPlayer_get_uiMode(This,pbstrMode)	\
    ( (This)->lpVtbl -> get_uiMode(This,pbstrMode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMPPlayer_INTERFACE_DEFINED__ */


#ifndef __IWMPPlayer2_INTERFACE_DEFINED__
#define __IWMPPlayer2_INTERFACE_DEFINED__

/* interface IWMPPlayer2 */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPPlayer2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0E6B01D1-D407-4c85-BF5F-1C01F6150280")
    IWMPPlayer2 : public IWMPCore
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_enabled( 
            /* [retval][out] */ VARIANT_BOOL *pbEnabled) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_enabled( 
            /* [in] */ VARIANT_BOOL bEnabled) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_fullScreen( 
            /* [retval][out] */ VARIANT_BOOL *pbFullScreen) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_fullScreen( 
            VARIANT_BOOL bFullScreen) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_enableContextMenu( 
            /* [retval][out] */ VARIANT_BOOL *pbEnableContextMenu) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_enableContextMenu( 
            VARIANT_BOOL bEnableContextMenu) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_uiMode( 
            /* [in] */ BSTR bstrMode) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_uiMode( 
            /* [retval][out] */ BSTR *pbstrMode) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_stretchToFit( 
            /* [retval][out] */ VARIANT_BOOL *pbEnabled) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_stretchToFit( 
            /* [in] */ VARIANT_BOOL bEnabled) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_windowlessVideo( 
            /* [retval][out] */ VARIANT_BOOL *pbEnabled) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_windowlessVideo( 
            /* [in] */ VARIANT_BOOL bEnabled) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPPlayer2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMPPlayer2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMPPlayer2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMPPlayer2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMPPlayer2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMPPlayer2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMPPlayer2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMPPlayer2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *close )( 
            IWMPPlayer2 * This);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_URL )( 
            IWMPPlayer2 * This,
            /* [retval][out] */ BSTR *pbstrURL);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_URL )( 
            IWMPPlayer2 * This,
            /* [in] */ BSTR bstrURL);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_openState )( 
            IWMPPlayer2 * This,
            /* [retval][out] */ WMPOpenState *pwmpos);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_playState )( 
            IWMPPlayer2 * This,
            /* [retval][out] */ WMPPlayState *pwmpps);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_controls )( 
            IWMPPlayer2 * This,
            /* [retval][out] */ IWMPControls **ppControl);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_settings )( 
            IWMPPlayer2 * This,
            /* [retval][out] */ IWMPSettings **ppSettings);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_currentMedia )( 
            IWMPPlayer2 * This,
            /* [retval][out] */ IWMPMedia **ppMedia);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_currentMedia )( 
            IWMPPlayer2 * This,
            /* [in] */ IWMPMedia *pMedia);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_mediaCollection )( 
            IWMPPlayer2 * This,
            /* [retval][out] */ IWMPMediaCollection **ppMediaCollection);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_playlistCollection )( 
            IWMPPlayer2 * This,
            /* [retval][out] */ IWMPPlaylistCollection **ppPlaylistCollection);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_versionInfo )( 
            IWMPPlayer2 * This,
            /* [retval][out] */ BSTR *pbstrVersionInfo);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *launchURL )( 
            IWMPPlayer2 * This,
            BSTR bstrURL);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_network )( 
            IWMPPlayer2 * This,
            /* [retval][out] */ IWMPNetwork **ppQNI);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_currentPlaylist )( 
            IWMPPlayer2 * This,
            /* [retval][out] */ IWMPPlaylist **ppPL);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_currentPlaylist )( 
            IWMPPlayer2 * This,
            /* [in] */ IWMPPlaylist *pPL);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_cdromCollection )( 
            IWMPPlayer2 * This,
            /* [retval][out] */ IWMPCdromCollection **ppCdromCollection);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_closedCaption )( 
            IWMPPlayer2 * This,
            /* [retval][out] */ IWMPClosedCaption **ppClosedCaption);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_isOnline )( 
            IWMPPlayer2 * This,
            /* [retval][out] */ VARIANT_BOOL *pfOnline);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_error )( 
            IWMPPlayer2 * This,
            /* [retval][out] */ IWMPError **ppError);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_status )( 
            IWMPPlayer2 * This,
            /* [retval][out] */ BSTR *pbstrStatus);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_enabled )( 
            IWMPPlayer2 * This,
            /* [retval][out] */ VARIANT_BOOL *pbEnabled);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_enabled )( 
            IWMPPlayer2 * This,
            /* [in] */ VARIANT_BOOL bEnabled);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_fullScreen )( 
            IWMPPlayer2 * This,
            /* [retval][out] */ VARIANT_BOOL *pbFullScreen);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_fullScreen )( 
            IWMPPlayer2 * This,
            VARIANT_BOOL bFullScreen);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_enableContextMenu )( 
            IWMPPlayer2 * This,
            /* [retval][out] */ VARIANT_BOOL *pbEnableContextMenu);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_enableContextMenu )( 
            IWMPPlayer2 * This,
            VARIANT_BOOL bEnableContextMenu);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_uiMode )( 
            IWMPPlayer2 * This,
            /* [in] */ BSTR bstrMode);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_uiMode )( 
            IWMPPlayer2 * This,
            /* [retval][out] */ BSTR *pbstrMode);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_stretchToFit )( 
            IWMPPlayer2 * This,
            /* [retval][out] */ VARIANT_BOOL *pbEnabled);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_stretchToFit )( 
            IWMPPlayer2 * This,
            /* [in] */ VARIANT_BOOL bEnabled);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_windowlessVideo )( 
            IWMPPlayer2 * This,
            /* [retval][out] */ VARIANT_BOOL *pbEnabled);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_windowlessVideo )( 
            IWMPPlayer2 * This,
            /* [in] */ VARIANT_BOOL bEnabled);
        
        END_INTERFACE
    } IWMPPlayer2Vtbl;

    interface IWMPPlayer2
    {
        CONST_VTBL struct IWMPPlayer2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPPlayer2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMPPlayer2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMPPlayer2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMPPlayer2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWMPPlayer2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWMPPlayer2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWMPPlayer2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWMPPlayer2_close(This)	\
    ( (This)->lpVtbl -> close(This) ) 

#define IWMPPlayer2_get_URL(This,pbstrURL)	\
    ( (This)->lpVtbl -> get_URL(This,pbstrURL) ) 

#define IWMPPlayer2_put_URL(This,bstrURL)	\
    ( (This)->lpVtbl -> put_URL(This,bstrURL) ) 

#define IWMPPlayer2_get_openState(This,pwmpos)	\
    ( (This)->lpVtbl -> get_openState(This,pwmpos) ) 

#define IWMPPlayer2_get_playState(This,pwmpps)	\
    ( (This)->lpVtbl -> get_playState(This,pwmpps) ) 

#define IWMPPlayer2_get_controls(This,ppControl)	\
    ( (This)->lpVtbl -> get_controls(This,ppControl) ) 

#define IWMPPlayer2_get_settings(This,ppSettings)	\
    ( (This)->lpVtbl -> get_settings(This,ppSettings) ) 

#define IWMPPlayer2_get_currentMedia(This,ppMedia)	\
    ( (This)->lpVtbl -> get_currentMedia(This,ppMedia) ) 

#define IWMPPlayer2_put_currentMedia(This,pMedia)	\
    ( (This)->lpVtbl -> put_currentMedia(This,pMedia) ) 

#define IWMPPlayer2_get_mediaCollection(This,ppMediaCollection)	\
    ( (This)->lpVtbl -> get_mediaCollection(This,ppMediaCollection) ) 

#define IWMPPlayer2_get_playlistCollection(This,ppPlaylistCollection)	\
    ( (This)->lpVtbl -> get_playlistCollection(This,ppPlaylistCollection) ) 

#define IWMPPlayer2_get_versionInfo(This,pbstrVersionInfo)	\
    ( (This)->lpVtbl -> get_versionInfo(This,pbstrVersionInfo) ) 

#define IWMPPlayer2_launchURL(This,bstrURL)	\
    ( (This)->lpVtbl -> launchURL(This,bstrURL) ) 

#define IWMPPlayer2_get_network(This,ppQNI)	\
    ( (This)->lpVtbl -> get_network(This,ppQNI) ) 

#define IWMPPlayer2_get_currentPlaylist(This,ppPL)	\
    ( (This)->lpVtbl -> get_currentPlaylist(This,ppPL) ) 

#define IWMPPlayer2_put_currentPlaylist(This,pPL)	\
    ( (This)->lpVtbl -> put_currentPlaylist(This,pPL) ) 

#define IWMPPlayer2_get_cdromCollection(This,ppCdromCollection)	\
    ( (This)->lpVtbl -> get_cdromCollection(This,ppCdromCollection) ) 

#define IWMPPlayer2_get_closedCaption(This,ppClosedCaption)	\
    ( (This)->lpVtbl -> get_closedCaption(This,ppClosedCaption) ) 

#define IWMPPlayer2_get_isOnline(This,pfOnline)	\
    ( (This)->lpVtbl -> get_isOnline(This,pfOnline) ) 

#define IWMPPlayer2_get_error(This,ppError)	\
    ( (This)->lpVtbl -> get_error(This,ppError) ) 

#define IWMPPlayer2_get_status(This,pbstrStatus)	\
    ( (This)->lpVtbl -> get_status(This,pbstrStatus) ) 


#define IWMPPlayer2_get_enabled(This,pbEnabled)	\
    ( (This)->lpVtbl -> get_enabled(This,pbEnabled) ) 

#define IWMPPlayer2_put_enabled(This,bEnabled)	\
    ( (This)->lpVtbl -> put_enabled(This,bEnabled) ) 

#define IWMPPlayer2_get_fullScreen(This,pbFullScreen)	\
    ( (This)->lpVtbl -> get_fullScreen(This,pbFullScreen) ) 

#define IWMPPlayer2_put_fullScreen(This,bFullScreen)	\
    ( (This)->lpVtbl -> put_fullScreen(This,bFullScreen) ) 

#define IWMPPlayer2_get_enableContextMenu(This,pbEnableContextMenu)	\
    ( (This)->lpVtbl -> get_enableContextMenu(This,pbEnableContextMenu) ) 

#define IWMPPlayer2_put_enableContextMenu(This,bEnableContextMenu)	\
    ( (This)->lpVtbl -> put_enableContextMenu(This,bEnableContextMenu) ) 

#define IWMPPlayer2_put_uiMode(This,bstrMode)	\
    ( (This)->lpVtbl -> put_uiMode(This,bstrMode) ) 

#define IWMPPlayer2_get_uiMode(This,pbstrMode)	\
    ( (This)->lpVtbl -> get_uiMode(This,pbstrMode) ) 

#define IWMPPlayer2_get_stretchToFit(This,pbEnabled)	\
    ( (This)->lpVtbl -> get_stretchToFit(This,pbEnabled) ) 

#define IWMPPlayer2_put_stretchToFit(This,bEnabled)	\
    ( (This)->lpVtbl -> put_stretchToFit(This,bEnabled) ) 

#define IWMPPlayer2_get_windowlessVideo(This,pbEnabled)	\
    ( (This)->lpVtbl -> get_windowlessVideo(This,pbEnabled) ) 

#define IWMPPlayer2_put_windowlessVideo(This,bEnabled)	\
    ( (This)->lpVtbl -> put_windowlessVideo(This,bEnabled) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMPPlayer2_INTERFACE_DEFINED__ */


#ifndef __IWMPPlayer3_INTERFACE_DEFINED__
#define __IWMPPlayer3_INTERFACE_DEFINED__

/* interface IWMPPlayer3 */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPPlayer3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("54062B68-052A-4c25-A39F-8B63346511D4")
    IWMPPlayer3 : public IWMPCore2
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_enabled( 
            /* [retval][out] */ VARIANT_BOOL *pbEnabled) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_enabled( 
            /* [in] */ VARIANT_BOOL bEnabled) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_fullScreen( 
            /* [retval][out] */ VARIANT_BOOL *pbFullScreen) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_fullScreen( 
            VARIANT_BOOL bFullScreen) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_enableContextMenu( 
            /* [retval][out] */ VARIANT_BOOL *pbEnableContextMenu) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_enableContextMenu( 
            VARIANT_BOOL bEnableContextMenu) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_uiMode( 
            /* [in] */ BSTR bstrMode) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_uiMode( 
            /* [retval][out] */ BSTR *pbstrMode) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_stretchToFit( 
            /* [retval][out] */ VARIANT_BOOL *pbEnabled) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_stretchToFit( 
            /* [in] */ VARIANT_BOOL bEnabled) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_windowlessVideo( 
            /* [retval][out] */ VARIANT_BOOL *pbEnabled) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_windowlessVideo( 
            /* [in] */ VARIANT_BOOL bEnabled) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPPlayer3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMPPlayer3 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMPPlayer3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMPPlayer3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMPPlayer3 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMPPlayer3 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMPPlayer3 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMPPlayer3 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *close )( 
            IWMPPlayer3 * This);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_URL )( 
            IWMPPlayer3 * This,
            /* [retval][out] */ BSTR *pbstrURL);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_URL )( 
            IWMPPlayer3 * This,
            /* [in] */ BSTR bstrURL);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_openState )( 
            IWMPPlayer3 * This,
            /* [retval][out] */ WMPOpenState *pwmpos);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_playState )( 
            IWMPPlayer3 * This,
            /* [retval][out] */ WMPPlayState *pwmpps);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_controls )( 
            IWMPPlayer3 * This,
            /* [retval][out] */ IWMPControls **ppControl);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_settings )( 
            IWMPPlayer3 * This,
            /* [retval][out] */ IWMPSettings **ppSettings);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_currentMedia )( 
            IWMPPlayer3 * This,
            /* [retval][out] */ IWMPMedia **ppMedia);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_currentMedia )( 
            IWMPPlayer3 * This,
            /* [in] */ IWMPMedia *pMedia);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_mediaCollection )( 
            IWMPPlayer3 * This,
            /* [retval][out] */ IWMPMediaCollection **ppMediaCollection);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_playlistCollection )( 
            IWMPPlayer3 * This,
            /* [retval][out] */ IWMPPlaylistCollection **ppPlaylistCollection);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_versionInfo )( 
            IWMPPlayer3 * This,
            /* [retval][out] */ BSTR *pbstrVersionInfo);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *launchURL )( 
            IWMPPlayer3 * This,
            BSTR bstrURL);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_network )( 
            IWMPPlayer3 * This,
            /* [retval][out] */ IWMPNetwork **ppQNI);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_currentPlaylist )( 
            IWMPPlayer3 * This,
            /* [retval][out] */ IWMPPlaylist **ppPL);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_currentPlaylist )( 
            IWMPPlayer3 * This,
            /* [in] */ IWMPPlaylist *pPL);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_cdromCollection )( 
            IWMPPlayer3 * This,
            /* [retval][out] */ IWMPCdromCollection **ppCdromCollection);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_closedCaption )( 
            IWMPPlayer3 * This,
            /* [retval][out] */ IWMPClosedCaption **ppClosedCaption);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_isOnline )( 
            IWMPPlayer3 * This,
            /* [retval][out] */ VARIANT_BOOL *pfOnline);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_error )( 
            IWMPPlayer3 * This,
            /* [retval][out] */ IWMPError **ppError);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_status )( 
            IWMPPlayer3 * This,
            /* [retval][out] */ BSTR *pbstrStatus);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_dvd )( 
            IWMPPlayer3 * This,
            /* [retval][out] */ IWMPDVD **ppDVD);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_enabled )( 
            IWMPPlayer3 * This,
            /* [retval][out] */ VARIANT_BOOL *pbEnabled);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_enabled )( 
            IWMPPlayer3 * This,
            /* [in] */ VARIANT_BOOL bEnabled);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_fullScreen )( 
            IWMPPlayer3 * This,
            /* [retval][out] */ VARIANT_BOOL *pbFullScreen);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_fullScreen )( 
            IWMPPlayer3 * This,
            VARIANT_BOOL bFullScreen);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_enableContextMenu )( 
            IWMPPlayer3 * This,
            /* [retval][out] */ VARIANT_BOOL *pbEnableContextMenu);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_enableContextMenu )( 
            IWMPPlayer3 * This,
            VARIANT_BOOL bEnableContextMenu);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_uiMode )( 
            IWMPPlayer3 * This,
            /* [in] */ BSTR bstrMode);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_uiMode )( 
            IWMPPlayer3 * This,
            /* [retval][out] */ BSTR *pbstrMode);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_stretchToFit )( 
            IWMPPlayer3 * This,
            /* [retval][out] */ VARIANT_BOOL *pbEnabled);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_stretchToFit )( 
            IWMPPlayer3 * This,
            /* [in] */ VARIANT_BOOL bEnabled);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_windowlessVideo )( 
            IWMPPlayer3 * This,
            /* [retval][out] */ VARIANT_BOOL *pbEnabled);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_windowlessVideo )( 
            IWMPPlayer3 * This,
            /* [in] */ VARIANT_BOOL bEnabled);
        
        END_INTERFACE
    } IWMPPlayer3Vtbl;

    interface IWMPPlayer3
    {
        CONST_VTBL struct IWMPPlayer3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPPlayer3_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMPPlayer3_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMPPlayer3_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMPPlayer3_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWMPPlayer3_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWMPPlayer3_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWMPPlayer3_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWMPPlayer3_close(This)	\
    ( (This)->lpVtbl -> close(This) ) 

#define IWMPPlayer3_get_URL(This,pbstrURL)	\
    ( (This)->lpVtbl -> get_URL(This,pbstrURL) ) 

#define IWMPPlayer3_put_URL(This,bstrURL)	\
    ( (This)->lpVtbl -> put_URL(This,bstrURL) ) 

#define IWMPPlayer3_get_openState(This,pwmpos)	\
    ( (This)->lpVtbl -> get_openState(This,pwmpos) ) 

#define IWMPPlayer3_get_playState(This,pwmpps)	\
    ( (This)->lpVtbl -> get_playState(This,pwmpps) ) 

#define IWMPPlayer3_get_controls(This,ppControl)	\
    ( (This)->lpVtbl -> get_controls(This,ppControl) ) 

#define IWMPPlayer3_get_settings(This,ppSettings)	\
    ( (This)->lpVtbl -> get_settings(This,ppSettings) ) 

#define IWMPPlayer3_get_currentMedia(This,ppMedia)	\
    ( (This)->lpVtbl -> get_currentMedia(This,ppMedia) ) 

#define IWMPPlayer3_put_currentMedia(This,pMedia)	\
    ( (This)->lpVtbl -> put_currentMedia(This,pMedia) ) 

#define IWMPPlayer3_get_mediaCollection(This,ppMediaCollection)	\
    ( (This)->lpVtbl -> get_mediaCollection(This,ppMediaCollection) ) 

#define IWMPPlayer3_get_playlistCollection(This,ppPlaylistCollection)	\
    ( (This)->lpVtbl -> get_playlistCollection(This,ppPlaylistCollection) ) 

#define IWMPPlayer3_get_versionInfo(This,pbstrVersionInfo)	\
    ( (This)->lpVtbl -> get_versionInfo(This,pbstrVersionInfo) ) 

#define IWMPPlayer3_launchURL(This,bstrURL)	\
    ( (This)->lpVtbl -> launchURL(This,bstrURL) ) 

#define IWMPPlayer3_get_network(This,ppQNI)	\
    ( (This)->lpVtbl -> get_network(This,ppQNI) ) 

#define IWMPPlayer3_get_currentPlaylist(This,ppPL)	\
    ( (This)->lpVtbl -> get_currentPlaylist(This,ppPL) ) 

#define IWMPPlayer3_put_currentPlaylist(This,pPL)	\
    ( (This)->lpVtbl -> put_currentPlaylist(This,pPL) ) 

#define IWMPPlayer3_get_cdromCollection(This,ppCdromCollection)	\
    ( (This)->lpVtbl -> get_cdromCollection(This,ppCdromCollection) ) 

#define IWMPPlayer3_get_closedCaption(This,ppClosedCaption)	\
    ( (This)->lpVtbl -> get_closedCaption(This,ppClosedCaption) ) 

#define IWMPPlayer3_get_isOnline(This,pfOnline)	\
    ( (This)->lpVtbl -> get_isOnline(This,pfOnline) ) 

#define IWMPPlayer3_get_error(This,ppError)	\
    ( (This)->lpVtbl -> get_error(This,ppError) ) 

#define IWMPPlayer3_get_status(This,pbstrStatus)	\
    ( (This)->lpVtbl -> get_status(This,pbstrStatus) ) 


#define IWMPPlayer3_get_dvd(This,ppDVD)	\
    ( (This)->lpVtbl -> get_dvd(This,ppDVD) ) 


#define IWMPPlayer3_get_enabled(This,pbEnabled)	\
    ( (This)->lpVtbl -> get_enabled(This,pbEnabled) ) 

#define IWMPPlayer3_put_enabled(This,bEnabled)	\
    ( (This)->lpVtbl -> put_enabled(This,bEnabled) ) 

#define IWMPPlayer3_get_fullScreen(This,pbFullScreen)	\
    ( (This)->lpVtbl -> get_fullScreen(This,pbFullScreen) ) 

#define IWMPPlayer3_put_fullScreen(This,bFullScreen)	\
    ( (This)->lpVtbl -> put_fullScreen(This,bFullScreen) ) 

#define IWMPPlayer3_get_enableContextMenu(This,pbEnableContextMenu)	\
    ( (This)->lpVtbl -> get_enableContextMenu(This,pbEnableContextMenu) ) 

#define IWMPPlayer3_put_enableContextMenu(This,bEnableContextMenu)	\
    ( (This)->lpVtbl -> put_enableContextMenu(This,bEnableContextMenu) ) 

#define IWMPPlayer3_put_uiMode(This,bstrMode)	\
    ( (This)->lpVtbl -> put_uiMode(This,bstrMode) ) 

#define IWMPPlayer3_get_uiMode(This,pbstrMode)	\
    ( (This)->lpVtbl -> get_uiMode(This,pbstrMode) ) 

#define IWMPPlayer3_get_stretchToFit(This,pbEnabled)	\
    ( (This)->lpVtbl -> get_stretchToFit(This,pbEnabled) ) 

#define IWMPPlayer3_put_stretchToFit(This,bEnabled)	\
    ( (This)->lpVtbl -> put_stretchToFit(This,bEnabled) ) 

#define IWMPPlayer3_get_windowlessVideo(This,pbEnabled)	\
    ( (This)->lpVtbl -> get_windowlessVideo(This,pbEnabled) ) 

#define IWMPPlayer3_put_windowlessVideo(This,bEnabled)	\
    ( (This)->lpVtbl -> put_windowlessVideo(This,bEnabled) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMPPlayer3_INTERFACE_DEFINED__ */


#ifndef __IWMPPlayer4_INTERFACE_DEFINED__
#define __IWMPPlayer4_INTERFACE_DEFINED__

/* interface IWMPPlayer4 */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPPlayer4;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6C497D62-8919-413c-82DB-E935FB3EC584")
    IWMPPlayer4 : public IWMPCore3
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_enabled( 
            /* [retval][out] */ VARIANT_BOOL *pbEnabled) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_enabled( 
            /* [in] */ VARIANT_BOOL bEnabled) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_fullScreen( 
            /* [retval][out] */ VARIANT_BOOL *pbFullScreen) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_fullScreen( 
            VARIANT_BOOL bFullScreen) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_enableContextMenu( 
            /* [retval][out] */ VARIANT_BOOL *pbEnableContextMenu) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_enableContextMenu( 
            VARIANT_BOOL bEnableContextMenu) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_uiMode( 
            /* [in] */ BSTR bstrMode) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_uiMode( 
            /* [retval][out] */ BSTR *pbstrMode) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_stretchToFit( 
            /* [retval][out] */ VARIANT_BOOL *pbEnabled) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_stretchToFit( 
            /* [in] */ VARIANT_BOOL bEnabled) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_windowlessVideo( 
            /* [retval][out] */ VARIANT_BOOL *pbEnabled) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_windowlessVideo( 
            /* [in] */ VARIANT_BOOL bEnabled) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_isRemote( 
            /* [retval][out] */ VARIANT_BOOL *pvarfIsRemote) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_playerApplication( 
            /* [retval][out] */ IWMPPlayerApplication **ppIWMPPlayerApplication) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE openPlayer( 
            /* [in] */ BSTR bstrURL) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPPlayer4Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMPPlayer4 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMPPlayer4 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMPPlayer4 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMPPlayer4 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMPPlayer4 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMPPlayer4 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMPPlayer4 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *close )( 
            IWMPPlayer4 * This);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_URL )( 
            IWMPPlayer4 * This,
            /* [retval][out] */ BSTR *pbstrURL);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_URL )( 
            IWMPPlayer4 * This,
            /* [in] */ BSTR bstrURL);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_openState )( 
            IWMPPlayer4 * This,
            /* [retval][out] */ WMPOpenState *pwmpos);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_playState )( 
            IWMPPlayer4 * This,
            /* [retval][out] */ WMPPlayState *pwmpps);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_controls )( 
            IWMPPlayer4 * This,
            /* [retval][out] */ IWMPControls **ppControl);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_settings )( 
            IWMPPlayer4 * This,
            /* [retval][out] */ IWMPSettings **ppSettings);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_currentMedia )( 
            IWMPPlayer4 * This,
            /* [retval][out] */ IWMPMedia **ppMedia);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_currentMedia )( 
            IWMPPlayer4 * This,
            /* [in] */ IWMPMedia *pMedia);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_mediaCollection )( 
            IWMPPlayer4 * This,
            /* [retval][out] */ IWMPMediaCollection **ppMediaCollection);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_playlistCollection )( 
            IWMPPlayer4 * This,
            /* [retval][out] */ IWMPPlaylistCollection **ppPlaylistCollection);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_versionInfo )( 
            IWMPPlayer4 * This,
            /* [retval][out] */ BSTR *pbstrVersionInfo);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *launchURL )( 
            IWMPPlayer4 * This,
            BSTR bstrURL);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_network )( 
            IWMPPlayer4 * This,
            /* [retval][out] */ IWMPNetwork **ppQNI);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_currentPlaylist )( 
            IWMPPlayer4 * This,
            /* [retval][out] */ IWMPPlaylist **ppPL);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_currentPlaylist )( 
            IWMPPlayer4 * This,
            /* [in] */ IWMPPlaylist *pPL);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_cdromCollection )( 
            IWMPPlayer4 * This,
            /* [retval][out] */ IWMPCdromCollection **ppCdromCollection);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_closedCaption )( 
            IWMPPlayer4 * This,
            /* [retval][out] */ IWMPClosedCaption **ppClosedCaption);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_isOnline )( 
            IWMPPlayer4 * This,
            /* [retval][out] */ VARIANT_BOOL *pfOnline);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_error )( 
            IWMPPlayer4 * This,
            /* [retval][out] */ IWMPError **ppError);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_status )( 
            IWMPPlayer4 * This,
            /* [retval][out] */ BSTR *pbstrStatus);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_dvd )( 
            IWMPPlayer4 * This,
            /* [retval][out] */ IWMPDVD **ppDVD);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *newMedia )( 
            IWMPPlayer4 * This,
            /* [in] */ BSTR bstrURL,
            /* [retval][out] */ IWMPMedia **ppMedia);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *newPlaylist )( 
            IWMPPlayer4 * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrURL,
            /* [retval][out] */ IWMPPlaylist **ppPlaylist);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_enabled )( 
            IWMPPlayer4 * This,
            /* [retval][out] */ VARIANT_BOOL *pbEnabled);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_enabled )( 
            IWMPPlayer4 * This,
            /* [in] */ VARIANT_BOOL bEnabled);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_fullScreen )( 
            IWMPPlayer4 * This,
            /* [retval][out] */ VARIANT_BOOL *pbFullScreen);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_fullScreen )( 
            IWMPPlayer4 * This,
            VARIANT_BOOL bFullScreen);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_enableContextMenu )( 
            IWMPPlayer4 * This,
            /* [retval][out] */ VARIANT_BOOL *pbEnableContextMenu);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_enableContextMenu )( 
            IWMPPlayer4 * This,
            VARIANT_BOOL bEnableContextMenu);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_uiMode )( 
            IWMPPlayer4 * This,
            /* [in] */ BSTR bstrMode);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_uiMode )( 
            IWMPPlayer4 * This,
            /* [retval][out] */ BSTR *pbstrMode);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_stretchToFit )( 
            IWMPPlayer4 * This,
            /* [retval][out] */ VARIANT_BOOL *pbEnabled);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_stretchToFit )( 
            IWMPPlayer4 * This,
            /* [in] */ VARIANT_BOOL bEnabled);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_windowlessVideo )( 
            IWMPPlayer4 * This,
            /* [retval][out] */ VARIANT_BOOL *pbEnabled);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_windowlessVideo )( 
            IWMPPlayer4 * This,
            /* [in] */ VARIANT_BOOL bEnabled);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_isRemote )( 
            IWMPPlayer4 * This,
            /* [retval][out] */ VARIANT_BOOL *pvarfIsRemote);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_playerApplication )( 
            IWMPPlayer4 * This,
            /* [retval][out] */ IWMPPlayerApplication **ppIWMPPlayerApplication);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *openPlayer )( 
            IWMPPlayer4 * This,
            /* [in] */ BSTR bstrURL);
        
        END_INTERFACE
    } IWMPPlayer4Vtbl;

    interface IWMPPlayer4
    {
        CONST_VTBL struct IWMPPlayer4Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPPlayer4_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMPPlayer4_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMPPlayer4_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMPPlayer4_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWMPPlayer4_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWMPPlayer4_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWMPPlayer4_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWMPPlayer4_close(This)	\
    ( (This)->lpVtbl -> close(This) ) 

#define IWMPPlayer4_get_URL(This,pbstrURL)	\
    ( (This)->lpVtbl -> get_URL(This,pbstrURL) ) 

#define IWMPPlayer4_put_URL(This,bstrURL)	\
    ( (This)->lpVtbl -> put_URL(This,bstrURL) ) 

#define IWMPPlayer4_get_openState(This,pwmpos)	\
    ( (This)->lpVtbl -> get_openState(This,pwmpos) ) 

#define IWMPPlayer4_get_playState(This,pwmpps)	\
    ( (This)->lpVtbl -> get_playState(This,pwmpps) ) 

#define IWMPPlayer4_get_controls(This,ppControl)	\
    ( (This)->lpVtbl -> get_controls(This,ppControl) ) 

#define IWMPPlayer4_get_settings(This,ppSettings)	\
    ( (This)->lpVtbl -> get_settings(This,ppSettings) ) 

#define IWMPPlayer4_get_currentMedia(This,ppMedia)	\
    ( (This)->lpVtbl -> get_currentMedia(This,ppMedia) ) 

#define IWMPPlayer4_put_currentMedia(This,pMedia)	\
    ( (This)->lpVtbl -> put_currentMedia(This,pMedia) ) 

#define IWMPPlayer4_get_mediaCollection(This,ppMediaCollection)	\
    ( (This)->lpVtbl -> get_mediaCollection(This,ppMediaCollection) ) 

#define IWMPPlayer4_get_playlistCollection(This,ppPlaylistCollection)	\
    ( (This)->lpVtbl -> get_playlistCollection(This,ppPlaylistCollection) ) 

#define IWMPPlayer4_get_versionInfo(This,pbstrVersionInfo)	\
    ( (This)->lpVtbl -> get_versionInfo(This,pbstrVersionInfo) ) 

#define IWMPPlayer4_launchURL(This,bstrURL)	\
    ( (This)->lpVtbl -> launchURL(This,bstrURL) ) 

#define IWMPPlayer4_get_network(This,ppQNI)	\
    ( (This)->lpVtbl -> get_network(This,ppQNI) ) 

#define IWMPPlayer4_get_currentPlaylist(This,ppPL)	\
    ( (This)->lpVtbl -> get_currentPlaylist(This,ppPL) ) 

#define IWMPPlayer4_put_currentPlaylist(This,pPL)	\
    ( (This)->lpVtbl -> put_currentPlaylist(This,pPL) ) 

#define IWMPPlayer4_get_cdromCollection(This,ppCdromCollection)	\
    ( (This)->lpVtbl -> get_cdromCollection(This,ppCdromCollection) ) 

#define IWMPPlayer4_get_closedCaption(This,ppClosedCaption)	\
    ( (This)->lpVtbl -> get_closedCaption(This,ppClosedCaption) ) 

#define IWMPPlayer4_get_isOnline(This,pfOnline)	\
    ( (This)->lpVtbl -> get_isOnline(This,pfOnline) ) 

#define IWMPPlayer4_get_error(This,ppError)	\
    ( (This)->lpVtbl -> get_error(This,ppError) ) 

#define IWMPPlayer4_get_status(This,pbstrStatus)	\
    ( (This)->lpVtbl -> get_status(This,pbstrStatus) ) 


#define IWMPPlayer4_get_dvd(This,ppDVD)	\
    ( (This)->lpVtbl -> get_dvd(This,ppDVD) ) 


#define IWMPPlayer4_newMedia(This,bstrURL,ppMedia)	\
    ( (This)->lpVtbl -> newMedia(This,bstrURL,ppMedia) ) 

#define IWMPPlayer4_newPlaylist(This,bstrName,bstrURL,ppPlaylist)	\
    ( (This)->lpVtbl -> newPlaylist(This,bstrName,bstrURL,ppPlaylist) ) 


#define IWMPPlayer4_get_enabled(This,pbEnabled)	\
    ( (This)->lpVtbl -> get_enabled(This,pbEnabled) ) 

#define IWMPPlayer4_put_enabled(This,bEnabled)	\
    ( (This)->lpVtbl -> put_enabled(This,bEnabled) ) 

#define IWMPPlayer4_get_fullScreen(This,pbFullScreen)	\
    ( (This)->lpVtbl -> get_fullScreen(This,pbFullScreen) ) 

#define IWMPPlayer4_put_fullScreen(This,bFullScreen)	\
    ( (This)->lpVtbl -> put_fullScreen(This,bFullScreen) ) 

#define IWMPPlayer4_get_enableContextMenu(This,pbEnableContextMenu)	\
    ( (This)->lpVtbl -> get_enableContextMenu(This,pbEnableContextMenu) ) 

#define IWMPPlayer4_put_enableContextMenu(This,bEnableContextMenu)	\
    ( (This)->lpVtbl -> put_enableContextMenu(This,bEnableContextMenu) ) 

#define IWMPPlayer4_put_uiMode(This,bstrMode)	\
    ( (This)->lpVtbl -> put_uiMode(This,bstrMode) ) 

#define IWMPPlayer4_get_uiMode(This,pbstrMode)	\
    ( (This)->lpVtbl -> get_uiMode(This,pbstrMode) ) 

#define IWMPPlayer4_get_stretchToFit(This,pbEnabled)	\
    ( (This)->lpVtbl -> get_stretchToFit(This,pbEnabled) ) 

#define IWMPPlayer4_put_stretchToFit(This,bEnabled)	\
    ( (This)->lpVtbl -> put_stretchToFit(This,bEnabled) ) 

#define IWMPPlayer4_get_windowlessVideo(This,pbEnabled)	\
    ( (This)->lpVtbl -> get_windowlessVideo(This,pbEnabled) ) 

#define IWMPPlayer4_put_windowlessVideo(This,bEnabled)	\
    ( (This)->lpVtbl -> put_windowlessVideo(This,bEnabled) ) 

#define IWMPPlayer4_get_isRemote(This,pvarfIsRemote)	\
    ( (This)->lpVtbl -> get_isRemote(This,pvarfIsRemote) ) 

#define IWMPPlayer4_get_playerApplication(This,ppIWMPPlayerApplication)	\
    ( (This)->lpVtbl -> get_playerApplication(This,ppIWMPPlayerApplication) ) 

#define IWMPPlayer4_openPlayer(This,bstrURL)	\
    ( (This)->lpVtbl -> openPlayer(This,bstrURL) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMPPlayer4_INTERFACE_DEFINED__ */


#ifndef __IWMPSettings2_INTERFACE_DEFINED__
#define __IWMPSettings2_INTERFACE_DEFINED__

/* interface IWMPSettings2 */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPSettings2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FDA937A4-EECE-4da5-A0B6-39BF89ADE2C2")
    IWMPSettings2 : public IWMPSettings
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_defaultAudioLanguage( 
            /* [retval][out] */ long *plLangID) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_mediaAccessRights( 
            /* [retval][out] */ BSTR *pbstrRights) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE requestMediaAccessRights( 
            /* [in] */ BSTR bstrDesiredAccess,
            /* [retval][out] */ VARIANT_BOOL *pvbAccepted) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPSettings2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMPSettings2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMPSettings2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMPSettings2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMPSettings2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMPSettings2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMPSettings2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMPSettings2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_isAvailable )( 
            IWMPSettings2 * This,
            /* [in] */ BSTR bstrItem,
            /* [retval][out] */ VARIANT_BOOL *pIsAvailable);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_autoStart )( 
            IWMPSettings2 * This,
            /* [retval][out] */ VARIANT_BOOL *pfAutoStart);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_autoStart )( 
            IWMPSettings2 * This,
            /* [in] */ VARIANT_BOOL fAutoStart);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_baseURL )( 
            IWMPSettings2 * This,
            /* [retval][out] */ BSTR *pbstrBaseURL);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_baseURL )( 
            IWMPSettings2 * This,
            /* [in] */ BSTR bstrBaseURL);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_defaultFrame )( 
            IWMPSettings2 * This,
            /* [retval][out] */ BSTR *pbstrDefaultFrame);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_defaultFrame )( 
            IWMPSettings2 * This,
            /* [in] */ BSTR bstrDefaultFrame);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_invokeURLs )( 
            IWMPSettings2 * This,
            /* [retval][out] */ VARIANT_BOOL *pfInvokeURLs);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_invokeURLs )( 
            IWMPSettings2 * This,
            /* [in] */ VARIANT_BOOL fInvokeURLs);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_mute )( 
            IWMPSettings2 * This,
            /* [retval][out] */ VARIANT_BOOL *pfMute);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_mute )( 
            IWMPSettings2 * This,
            /* [in] */ VARIANT_BOOL fMute);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_playCount )( 
            IWMPSettings2 * This,
            /* [retval][out] */ long *plCount);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_playCount )( 
            IWMPSettings2 * This,
            /* [in] */ long lCount);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_rate )( 
            IWMPSettings2 * This,
            /* [retval][out] */ double *pdRate);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_rate )( 
            IWMPSettings2 * This,
            /* [in] */ double dRate);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_balance )( 
            IWMPSettings2 * This,
            /* [retval][out] */ long *plBalance);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_balance )( 
            IWMPSettings2 * This,
            /* [in] */ long lBalance);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_volume )( 
            IWMPSettings2 * This,
            /* [retval][out] */ long *plVolume);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_volume )( 
            IWMPSettings2 * This,
            /* [in] */ long lVolume);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *getMode )( 
            IWMPSettings2 * This,
            /* [in] */ BSTR bstrMode,
            /* [retval][out] */ VARIANT_BOOL *pvarfMode);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *setMode )( 
            IWMPSettings2 * This,
            /* [in] */ BSTR bstrMode,
            /* [in] */ VARIANT_BOOL varfMode);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_enableErrorDialogs )( 
            IWMPSettings2 * This,
            /* [retval][out] */ VARIANT_BOOL *pfEnableErrorDialogs);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_enableErrorDialogs )( 
            IWMPSettings2 * This,
            /* [in] */ VARIANT_BOOL fEnableErrorDialogs);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_defaultAudioLanguage )( 
            IWMPSettings2 * This,
            /* [retval][out] */ long *plLangID);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_mediaAccessRights )( 
            IWMPSettings2 * This,
            /* [retval][out] */ BSTR *pbstrRights);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *requestMediaAccessRights )( 
            IWMPSettings2 * This,
            /* [in] */ BSTR bstrDesiredAccess,
            /* [retval][out] */ VARIANT_BOOL *pvbAccepted);
        
        END_INTERFACE
    } IWMPSettings2Vtbl;

    interface IWMPSettings2
    {
        CONST_VTBL struct IWMPSettings2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPSettings2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMPSettings2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMPSettings2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMPSettings2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWMPSettings2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWMPSettings2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWMPSettings2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWMPSettings2_get_isAvailable(This,bstrItem,pIsAvailable)	\
    ( (This)->lpVtbl -> get_isAvailable(This,bstrItem,pIsAvailable) ) 

#define IWMPSettings2_get_autoStart(This,pfAutoStart)	\
    ( (This)->lpVtbl -> get_autoStart(This,pfAutoStart) ) 

#define IWMPSettings2_put_autoStart(This,fAutoStart)	\
    ( (This)->lpVtbl -> put_autoStart(This,fAutoStart) ) 

#define IWMPSettings2_get_baseURL(This,pbstrBaseURL)	\
    ( (This)->lpVtbl -> get_baseURL(This,pbstrBaseURL) ) 

#define IWMPSettings2_put_baseURL(This,bstrBaseURL)	\
    ( (This)->lpVtbl -> put_baseURL(This,bstrBaseURL) ) 

#define IWMPSettings2_get_defaultFrame(This,pbstrDefaultFrame)	\
    ( (This)->lpVtbl -> get_defaultFrame(This,pbstrDefaultFrame) ) 

#define IWMPSettings2_put_defaultFrame(This,bstrDefaultFrame)	\
    ( (This)->lpVtbl -> put_defaultFrame(This,bstrDefaultFrame) ) 

#define IWMPSettings2_get_invokeURLs(This,pfInvokeURLs)	\
    ( (This)->lpVtbl -> get_invokeURLs(This,pfInvokeURLs) ) 

#define IWMPSettings2_put_invokeURLs(This,fInvokeURLs)	\
    ( (This)->lpVtbl -> put_invokeURLs(This,fInvokeURLs) ) 

#define IWMPSettings2_get_mute(This,pfMute)	\
    ( (This)->lpVtbl -> get_mute(This,pfMute) ) 

#define IWMPSettings2_put_mute(This,fMute)	\
    ( (This)->lpVtbl -> put_mute(This,fMute) ) 

#define IWMPSettings2_get_playCount(This,plCount)	\
    ( (This)->lpVtbl -> get_playCount(This,plCount) ) 

#define IWMPSettings2_put_playCount(This,lCount)	\
    ( (This)->lpVtbl -> put_playCount(This,lCount) ) 

#define IWMPSettings2_get_rate(This,pdRate)	\
    ( (This)->lpVtbl -> get_rate(This,pdRate) ) 

#define IWMPSettings2_put_rate(This,dRate)	\
    ( (This)->lpVtbl -> put_rate(This,dRate) ) 

#define IWMPSettings2_get_balance(This,plBalance)	\
    ( (This)->lpVtbl -> get_balance(This,plBalance) ) 

#define IWMPSettings2_put_balance(This,lBalance)	\
    ( (This)->lpVtbl -> put_balance(This,lBalance) ) 

#define IWMPSettings2_get_volume(This,plVolume)	\
    ( (This)->lpVtbl -> get_volume(This,plVolume) ) 

#define IWMPSettings2_put_volume(This,lVolume)	\
    ( (This)->lpVtbl -> put_volume(This,lVolume) ) 

#define IWMPSettings2_getMode(This,bstrMode,pvarfMode)	\
    ( (This)->lpVtbl -> getMode(This,bstrMode,pvarfMode) ) 

#define IWMPSettings2_setMode(This,bstrMode,varfMode)	\
    ( (This)->lpVtbl -> setMode(This,bstrMode,varfMode) ) 

#define IWMPSettings2_get_enableErrorDialogs(This,pfEnableErrorDialogs)	\
    ( (This)->lpVtbl -> get_enableErrorDialogs(This,pfEnableErrorDialogs) ) 

#define IWMPSettings2_put_enableErrorDialogs(This,fEnableErrorDialogs)	\
    ( (This)->lpVtbl -> put_enableErrorDialogs(This,fEnableErrorDialogs) ) 


#define IWMPSettings2_get_defaultAudioLanguage(This,plLangID)	\
    ( (This)->lpVtbl -> get_defaultAudioLanguage(This,plLangID) ) 

#define IWMPSettings2_get_mediaAccessRights(This,pbstrRights)	\
    ( (This)->lpVtbl -> get_mediaAccessRights(This,pbstrRights) ) 

#define IWMPSettings2_requestMediaAccessRights(This,bstrDesiredAccess,pvbAccepted)	\
    ( (This)->lpVtbl -> requestMediaAccessRights(This,bstrDesiredAccess,pvbAccepted) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMPSettings2_INTERFACE_DEFINED__ */



#ifndef __WMPOCX_LIBRARY_DEFINED__
#define __WMPOCX_LIBRARY_DEFINED__

/* library WMPOCX */
/* [version][uuid] */ 


EXTERN_C const IID LIBID_WMPOCX;

#ifndef __IWMPEvents_INTERFACE_DEFINED__
#define __IWMPEvents_INTERFACE_DEFINED__

/* interface IWMPEvents */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IWMPEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("19A6627B-DA9E-47c1-BB23-00B5E668236A")
    IWMPEvents : public IUnknown
    {
    public:
        virtual /* [id] */ void STDMETHODCALLTYPE OpenStateChange( 
            /* [in] */ long NewState) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE PlayStateChange( 
            /* [in] */ long NewState) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE AudioLanguageChange( 
            /* [in] */ long LangID) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE StatusChange( void) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE ScriptCommand( 
            /* [in] */ BSTR scType,
            /* [in] */ BSTR Param) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE NewStream( void) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE Disconnect( 
            /* [in] */ long Result) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE Buffering( 
            /* [in] */ VARIANT_BOOL Start) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE Error( void) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE Warning( 
            /* [in] */ long WarningType,
            /* [in] */ long Param,
            /* [in] */ BSTR Description) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE EndOfStream( 
            /* [in] */ long Result) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE PositionChange( 
            /* [in] */ double oldPosition,
            /* [in] */ double newPosition) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE MarkerHit( 
            /* [in] */ long MarkerNum) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE DurationUnitChange( 
            /* [in] */ long NewDurationUnit) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE CdromMediaChange( 
            /* [in] */ long CdromNum) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE PlaylistChange( 
            /* [in] */ IDispatch *Playlist,
            /* [in] */ WMPPlaylistChangeEventType change) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE CurrentPlaylistChange( 
            /* [in] */ WMPPlaylistChangeEventType change) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE CurrentPlaylistItemAvailable( 
            /* [in] */ BSTR bstrItemName) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE MediaChange( 
            /* [in] */ IDispatch *Item) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE CurrentMediaItemAvailable( 
            /* [in] */ BSTR bstrItemName) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE CurrentItemChange( 
            /* [in] */ IDispatch *pdispMedia) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE MediaCollectionChange( void) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE MediaCollectionAttributeStringAdded( 
            /* [in] */ BSTR bstrAttribName,
            /* [in] */ BSTR bstrAttribVal) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE MediaCollectionAttributeStringRemoved( 
            /* [in] */ BSTR bstrAttribName,
            /* [in] */ BSTR bstrAttribVal) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE MediaCollectionAttributeStringChanged( 
            /* [in] */ BSTR bstrAttribName,
            /* [in] */ BSTR bstrOldAttribVal,
            /* [in] */ BSTR bstrNewAttribVal) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE PlaylistCollectionChange( void) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE PlaylistCollectionPlaylistAdded( 
            /* [in] */ BSTR bstrPlaylistName) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE PlaylistCollectionPlaylistRemoved( 
            /* [in] */ BSTR bstrPlaylistName) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE PlaylistCollectionPlaylistSetAsDeleted( 
            /* [in] */ BSTR bstrPlaylistName,
            /* [in] */ VARIANT_BOOL varfIsDeleted) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE ModeChange( 
            /* [in] */ BSTR ModeName,
            /* [in] */ VARIANT_BOOL NewValue) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE MediaError( 
            /* [in] */ IDispatch *pMediaObject) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE OpenPlaylistSwitch( 
            /* [in] */ IDispatch *pItem) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE DomainChange( 
            /* [in] */ BSTR strDomain) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE SwitchedToPlayerApplication( void) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE SwitchedToControl( void) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE PlayerDockedStateChange( void) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE PlayerReconnect( void) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE Click( 
            /* [in] */ short nButton,
            /* [in] */ short nShiftState,
            /* [in] */ long fX,
            /* [in] */ long fY) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE DoubleClick( 
            /* [in] */ short nButton,
            /* [in] */ short nShiftState,
            /* [in] */ long fX,
            /* [in] */ long fY) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE KeyDown( 
            /* [in] */ short nKeyCode,
            /* [in] */ short nShiftState) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE KeyPress( 
            /* [in] */ short nKeyAscii) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE KeyUp( 
            /* [in] */ short nKeyCode,
            /* [in] */ short nShiftState) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE MouseDown( 
            /* [in] */ short nButton,
            /* [in] */ short nShiftState,
            /* [in] */ long fX,
            /* [in] */ long fY) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE MouseMove( 
            /* [in] */ short nButton,
            /* [in] */ short nShiftState,
            /* [in] */ long fX,
            /* [in] */ long fY) = 0;
        
        virtual /* [id] */ void STDMETHODCALLTYPE MouseUp( 
            /* [in] */ short nButton,
            /* [in] */ short nShiftState,
            /* [in] */ long fX,
            /* [in] */ long fY) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMPEvents * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMPEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMPEvents * This);
        
        /* [id] */ void ( STDMETHODCALLTYPE *OpenStateChange )( 
            IWMPEvents * This,
            /* [in] */ long NewState);
        
        /* [id] */ void ( STDMETHODCALLTYPE *PlayStateChange )( 
            IWMPEvents * This,
            /* [in] */ long NewState);
        
        /* [id] */ void ( STDMETHODCALLTYPE *AudioLanguageChange )( 
            IWMPEvents * This,
            /* [in] */ long LangID);
        
        /* [id] */ void ( STDMETHODCALLTYPE *StatusChange )( 
            IWMPEvents * This);
        
        /* [id] */ void ( STDMETHODCALLTYPE *ScriptCommand )( 
            IWMPEvents * This,
            /* [in] */ BSTR scType,
            /* [in] */ BSTR Param);
        
        /* [id] */ void ( STDMETHODCALLTYPE *NewStream )( 
            IWMPEvents * This);
        
        /* [id] */ void ( STDMETHODCALLTYPE *Disconnect )( 
            IWMPEvents * This,
            /* [in] */ long Result);
        
        /* [id] */ void ( STDMETHODCALLTYPE *Buffering )( 
            IWMPEvents * This,
            /* [in] */ VARIANT_BOOL Start);
        
        /* [id] */ void ( STDMETHODCALLTYPE *Error )( 
            IWMPEvents * This);
        
        /* [id] */ void ( STDMETHODCALLTYPE *Warning )( 
            IWMPEvents * This,
            /* [in] */ long WarningType,
            /* [in] */ long Param,
            /* [in] */ BSTR Description);
        
        /* [id] */ void ( STDMETHODCALLTYPE *EndOfStream )( 
            IWMPEvents * This,
            /* [in] */ long Result);
        
        /* [id] */ void ( STDMETHODCALLTYPE *PositionChange )( 
            IWMPEvents * This,
            /* [in] */ double oldPosition,
            /* [in] */ double newPosition);
        
        /* [id] */ void ( STDMETHODCALLTYPE *MarkerHit )( 
            IWMPEvents * This,
            /* [in] */ long MarkerNum);
        
        /* [id] */ void ( STDMETHODCALLTYPE *DurationUnitChange )( 
            IWMPEvents * This,
            /* [in] */ long NewDurationUnit);
        
        /* [id] */ void ( STDMETHODCALLTYPE *CdromMediaChange )( 
            IWMPEvents * This,
            /* [in] */ long CdromNum);
        
        /* [id] */ void ( STDMETHODCALLTYPE *PlaylistChange )( 
            IWMPEvents * This,
            /* [in] */ IDispatch *Playlist,
            /* [in] */ WMPPlaylistChangeEventType change);
        
        /* [id] */ void ( STDMETHODCALLTYPE *CurrentPlaylistChange )( 
            IWMPEvents * This,
            /* [in] */ WMPPlaylistChangeEventType change);
        
        /* [id] */ void ( STDMETHODCALLTYPE *CurrentPlaylistItemAvailable )( 
            IWMPEvents * This,
            /* [in] */ BSTR bstrItemName);
        
        /* [id] */ void ( STDMETHODCALLTYPE *MediaChange )( 
            IWMPEvents * This,
            /* [in] */ IDispatch *Item);
        
        /* [id] */ void ( STDMETHODCALLTYPE *CurrentMediaItemAvailable )( 
            IWMPEvents * This,
            /* [in] */ BSTR bstrItemName);
        
        /* [id] */ void ( STDMETHODCALLTYPE *CurrentItemChange )( 
            IWMPEvents * This,
            /* [in] */ IDispatch *pdispMedia);
        
        /* [id] */ void ( STDMETHODCALLTYPE *MediaCollectionChange )( 
            IWMPEvents * This);
        
        /* [id] */ void ( STDMETHODCALLTYPE *MediaCollectionAttributeStringAdded )( 
            IWMPEvents * This,
            /* [in] */ BSTR bstrAttribName,
            /* [in] */ BSTR bstrAttribVal);
        
        /* [id] */ void ( STDMETHODCALLTYPE *MediaCollectionAttributeStringRemoved )( 
            IWMPEvents * This,
            /* [in] */ BSTR bstrAttribName,
            /* [in] */ BSTR bstrAttribVal);
        
        /* [id] */ void ( STDMETHODCALLTYPE *MediaCollectionAttributeStringChanged )( 
            IWMPEvents * This,
            /* [in] */ BSTR bstrAttribName,
            /* [in] */ BSTR bstrOldAttribVal,
            /* [in] */ BSTR bstrNewAttribVal);
        
        /* [id] */ void ( STDMETHODCALLTYPE *PlaylistCollectionChange )( 
            IWMPEvents * This);
        
        /* [id] */ void ( STDMETHODCALLTYPE *PlaylistCollectionPlaylistAdded )( 
            IWMPEvents * This,
            /* [in] */ BSTR bstrPlaylistName);
        
        /* [id] */ void ( STDMETHODCALLTYPE *PlaylistCollectionPlaylistRemoved )( 
            IWMPEvents * This,
            /* [in] */ BSTR bstrPlaylistName);
        
        /* [id] */ void ( STDMETHODCALLTYPE *PlaylistCollectionPlaylistSetAsDeleted )( 
            IWMPEvents * This,
            /* [in] */ BSTR bstrPlaylistName,
            /* [in] */ VARIANT_BOOL varfIsDeleted);
        
        /* [id] */ void ( STDMETHODCALLTYPE *ModeChange )( 
            IWMPEvents * This,
            /* [in] */ BSTR ModeName,
            /* [in] */ VARIANT_BOOL NewValue);
        
        /* [id] */ void ( STDMETHODCALLTYPE *MediaError )( 
            IWMPEvents * This,
            /* [in] */ IDispatch *pMediaObject);
        
        /* [id] */ void ( STDMETHODCALLTYPE *OpenPlaylistSwitch )( 
            IWMPEvents * This,
            /* [in] */ IDispatch *pItem);
        
        /* [id] */ void ( STDMETHODCALLTYPE *DomainChange )( 
            IWMPEvents * This,
            /* [in] */ BSTR strDomain);
        
        /* [id] */ void ( STDMETHODCALLTYPE *SwitchedToPlayerApplication )( 
            IWMPEvents * This);
        
        /* [id] */ void ( STDMETHODCALLTYPE *SwitchedToControl )( 
            IWMPEvents * This);
        
        /* [id] */ void ( STDMETHODCALLTYPE *PlayerDockedStateChange )( 
            IWMPEvents * This);
        
        /* [id] */ void ( STDMETHODCALLTYPE *PlayerReconnect )( 
            IWMPEvents * This);
        
        /* [id] */ void ( STDMETHODCALLTYPE *Click )( 
            IWMPEvents * This,
            /* [in] */ short nButton,
            /* [in] */ short nShiftState,
            /* [in] */ long fX,
            /* [in] */ long fY);
        
        /* [id] */ void ( STDMETHODCALLTYPE *DoubleClick )( 
            IWMPEvents * This,
            /* [in] */ short nButton,
            /* [in] */ short nShiftState,
            /* [in] */ long fX,
            /* [in] */ long fY);
        
        /* [id] */ void ( STDMETHODCALLTYPE *KeyDown )( 
            IWMPEvents * This,
            /* [in] */ short nKeyCode,
            /* [in] */ short nShiftState);
        
        /* [id] */ void ( STDMETHODCALLTYPE *KeyPress )( 
            IWMPEvents * This,
            /* [in] */ short nKeyAscii);
        
        /* [id] */ void ( STDMETHODCALLTYPE *KeyUp )( 
            IWMPEvents * This,
            /* [in] */ short nKeyCode,
            /* [in] */ short nShiftState);
        
        /* [id] */ void ( STDMETHODCALLTYPE *MouseDown )( 
            IWMPEvents * This,
            /* [in] */ short nButton,
            /* [in] */ short nShiftState,
            /* [in] */ long fX,
            /* [in] */ long fY);
        
        /* [id] */ void ( STDMETHODCALLTYPE *MouseMove )( 
            IWMPEvents * This,
            /* [in] */ short nButton,
            /* [in] */ short nShiftState,
            /* [in] */ long fX,
            /* [in] */ long fY);
        
        /* [id] */ void ( STDMETHODCALLTYPE *MouseUp )( 
            IWMPEvents * This,
            /* [in] */ short nButton,
            /* [in] */ short nShiftState,
            /* [in] */ long fX,
            /* [in] */ long fY);
        
        END_INTERFACE
    } IWMPEventsVtbl;

    interface IWMPEvents
    {
        CONST_VTBL struct IWMPEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMPEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMPEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMPEvents_OpenStateChange(This,NewState)	\
    ( (This)->lpVtbl -> OpenStateChange(This,NewState) ) 

#define IWMPEvents_PlayStateChange(This,NewState)	\
    ( (This)->lpVtbl -> PlayStateChange(This,NewState) ) 

#define IWMPEvents_AudioLanguageChange(This,LangID)	\
    ( (This)->lpVtbl -> AudioLanguageChange(This,LangID) ) 

#define IWMPEvents_StatusChange(This)	\
    ( (This)->lpVtbl -> StatusChange(This) ) 

#define IWMPEvents_ScriptCommand(This,scType,Param)	\
    ( (This)->lpVtbl -> ScriptCommand(This,scType,Param) ) 

#define IWMPEvents_NewStream(This)	\
    ( (This)->lpVtbl -> NewStream(This) ) 

#define IWMPEvents_Disconnect(This,Result)	\
    ( (This)->lpVtbl -> Disconnect(This,Result) ) 

#define IWMPEvents_Buffering(This,Start)	\
    ( (This)->lpVtbl -> Buffering(This,Start) ) 

#define IWMPEvents_Error(This)	\
    ( (This)->lpVtbl -> Error(This) ) 

#define IWMPEvents_Warning(This,WarningType,Param,Description)	\
    ( (This)->lpVtbl -> Warning(This,WarningType,Param,Description) ) 

#define IWMPEvents_EndOfStream(This,Result)	\
    ( (This)->lpVtbl -> EndOfStream(This,Result) ) 

#define IWMPEvents_PositionChange(This,oldPosition,newPosition)	\
    ( (This)->lpVtbl -> PositionChange(This,oldPosition,newPosition) ) 

#define IWMPEvents_MarkerHit(This,MarkerNum)	\
    ( (This)->lpVtbl -> MarkerHit(This,MarkerNum) ) 

#define IWMPEvents_DurationUnitChange(This,NewDurationUnit)	\
    ( (This)->lpVtbl -> DurationUnitChange(This,NewDurationUnit) ) 

#define IWMPEvents_CdromMediaChange(This,CdromNum)	\
    ( (This)->lpVtbl -> CdromMediaChange(This,CdromNum) ) 

#define IWMPEvents_PlaylistChange(This,Playlist,change)	\
    ( (This)->lpVtbl -> PlaylistChange(This,Playlist,change) ) 

#define IWMPEvents_CurrentPlaylistChange(This,change)	\
    ( (This)->lpVtbl -> CurrentPlaylistChange(This,change) ) 

#define IWMPEvents_CurrentPlaylistItemAvailable(This,bstrItemName)	\
    ( (This)->lpVtbl -> CurrentPlaylistItemAvailable(This,bstrItemName) ) 

#define IWMPEvents_MediaChange(This,Item)	\
    ( (This)->lpVtbl -> MediaChange(This,Item) ) 

#define IWMPEvents_CurrentMediaItemAvailable(This,bstrItemName)	\
    ( (This)->lpVtbl -> CurrentMediaItemAvailable(This,bstrItemName) ) 

#define IWMPEvents_CurrentItemChange(This,pdispMedia)	\
    ( (This)->lpVtbl -> CurrentItemChange(This,pdispMedia) ) 

#define IWMPEvents_MediaCollectionChange(This)	\
    ( (This)->lpVtbl -> MediaCollectionChange(This) ) 

#define IWMPEvents_MediaCollectionAttributeStringAdded(This,bstrAttribName,bstrAttribVal)	\
    ( (This)->lpVtbl -> MediaCollectionAttributeStringAdded(This,bstrAttribName,bstrAttribVal) ) 

#define IWMPEvents_MediaCollectionAttributeStringRemoved(This,bstrAttribName,bstrAttribVal)	\
    ( (This)->lpVtbl -> MediaCollectionAttributeStringRemoved(This,bstrAttribName,bstrAttribVal) ) 

#define IWMPEvents_MediaCollectionAttributeStringChanged(This,bstrAttribName,bstrOldAttribVal,bstrNewAttribVal)	\
    ( (This)->lpVtbl -> MediaCollectionAttributeStringChanged(This,bstrAttribName,bstrOldAttribVal,bstrNewAttribVal) ) 

#define IWMPEvents_PlaylistCollectionChange(This)	\
    ( (This)->lpVtbl -> PlaylistCollectionChange(This) ) 

#define IWMPEvents_PlaylistCollectionPlaylistAdded(This,bstrPlaylistName)	\
    ( (This)->lpVtbl -> PlaylistCollectionPlaylistAdded(This,bstrPlaylistName) ) 

#define IWMPEvents_PlaylistCollectionPlaylistRemoved(This,bstrPlaylistName)	\
    ( (This)->lpVtbl -> PlaylistCollectionPlaylistRemoved(This,bstrPlaylistName) ) 

#define IWMPEvents_PlaylistCollectionPlaylistSetAsDeleted(This,bstrPlaylistName,varfIsDeleted)	\
    ( (This)->lpVtbl -> PlaylistCollectionPlaylistSetAsDeleted(This,bstrPlaylistName,varfIsDeleted) ) 

#define IWMPEvents_ModeChange(This,ModeName,NewValue)	\
    ( (This)->lpVtbl -> ModeChange(This,ModeName,NewValue) ) 

#define IWMPEvents_MediaError(This,pMediaObject)	\
    ( (This)->lpVtbl -> MediaError(This,pMediaObject) ) 

#define IWMPEvents_OpenPlaylistSwitch(This,pItem)	\
    ( (This)->lpVtbl -> OpenPlaylistSwitch(This,pItem) ) 

#define IWMPEvents_DomainChange(This,strDomain)	\
    ( (This)->lpVtbl -> DomainChange(This,strDomain) ) 

#define IWMPEvents_SwitchedToPlayerApplication(This)	\
    ( (This)->lpVtbl -> SwitchedToPlayerApplication(This) ) 

#define IWMPEvents_SwitchedToControl(This)	\
    ( (This)->lpVtbl -> SwitchedToControl(This) ) 

#define IWMPEvents_PlayerDockedStateChange(This)	\
    ( (This)->lpVtbl -> PlayerDockedStateChange(This) ) 

#define IWMPEvents_PlayerReconnect(This)	\
    ( (This)->lpVtbl -> PlayerReconnect(This) ) 

#define IWMPEvents_Click(This,nButton,nShiftState,fX,fY)	\
    ( (This)->lpVtbl -> Click(This,nButton,nShiftState,fX,fY) ) 

#define IWMPEvents_DoubleClick(This,nButton,nShiftState,fX,fY)	\
    ( (This)->lpVtbl -> DoubleClick(This,nButton,nShiftState,fX,fY) ) 

#define IWMPEvents_KeyDown(This,nKeyCode,nShiftState)	\
    ( (This)->lpVtbl -> KeyDown(This,nKeyCode,nShiftState) ) 

#define IWMPEvents_KeyPress(This,nKeyAscii)	\
    ( (This)->lpVtbl -> KeyPress(This,nKeyAscii) ) 

#define IWMPEvents_KeyUp(This,nKeyCode,nShiftState)	\
    ( (This)->lpVtbl -> KeyUp(This,nKeyCode,nShiftState) ) 

#define IWMPEvents_MouseDown(This,nButton,nShiftState,fX,fY)	\
    ( (This)->lpVtbl -> MouseDown(This,nButton,nShiftState,fX,fY) ) 

#define IWMPEvents_MouseMove(This,nButton,nShiftState,fX,fY)	\
    ( (This)->lpVtbl -> MouseMove(This,nButton,nShiftState,fX,fY) ) 

#define IWMPEvents_MouseUp(This,nButton,nShiftState,fX,fY)	\
    ( (This)->lpVtbl -> MouseUp(This,nButton,nShiftState,fX,fY) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMPEvents_INTERFACE_DEFINED__ */


#ifndef ___WMPOCXEvents_DISPINTERFACE_DEFINED__
#define ___WMPOCXEvents_DISPINTERFACE_DEFINED__

/* dispinterface _WMPOCXEvents */
/* [hidden][uuid] */ 


EXTERN_C const IID DIID__WMPOCXEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("6BF52A51-394A-11d3-B153-00C04F79FAA6")
    _WMPOCXEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct _WMPOCXEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            _WMPOCXEvents * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            _WMPOCXEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            _WMPOCXEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            _WMPOCXEvents * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            _WMPOCXEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            _WMPOCXEvents * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            _WMPOCXEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } _WMPOCXEventsVtbl;

    interface _WMPOCXEvents
    {
        CONST_VTBL struct _WMPOCXEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _WMPOCXEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define _WMPOCXEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define _WMPOCXEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define _WMPOCXEvents_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define _WMPOCXEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define _WMPOCXEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define _WMPOCXEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* ___WMPOCXEvents_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_WMPOCX;

#ifdef __cplusplus

class DECLSPEC_UUID("6BF52A52-394A-11d3-B153-00C04F79FAA6")
WMPOCX;
#endif
#endif /* __WMPOCX_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\wmpcore.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0543 */
/* Compiler settings for wmpcore.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wmpcore_h__
#define __wmpcore_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWMPMediaCollection_FWD_DEFINED__
#define __IWMPMediaCollection_FWD_DEFINED__
typedef interface IWMPMediaCollection IWMPMediaCollection;
#endif 	/* __IWMPMediaCollection_FWD_DEFINED__ */


#ifndef __IWMPPlaylistCollection_FWD_DEFINED__
#define __IWMPPlaylistCollection_FWD_DEFINED__
typedef interface IWMPPlaylistCollection IWMPPlaylistCollection;
#endif 	/* __IWMPPlaylistCollection_FWD_DEFINED__ */


#ifndef __IWMPCdromCollection_FWD_DEFINED__
#define __IWMPCdromCollection_FWD_DEFINED__
typedef interface IWMPCdromCollection IWMPCdromCollection;
#endif 	/* __IWMPCdromCollection_FWD_DEFINED__ */


#ifndef __IWMPClosedCaption_FWD_DEFINED__
#define __IWMPClosedCaption_FWD_DEFINED__
typedef interface IWMPClosedCaption IWMPClosedCaption;
#endif 	/* __IWMPClosedCaption_FWD_DEFINED__ */


#ifndef __IWMPDVD_FWD_DEFINED__
#define __IWMPDVD_FWD_DEFINED__
typedef interface IWMPDVD IWMPDVD;
#endif 	/* __IWMPDVD_FWD_DEFINED__ */


#ifndef __IWMPPlayerApplication_FWD_DEFINED__
#define __IWMPPlayerApplication_FWD_DEFINED__
typedef interface IWMPPlayerApplication IWMPPlayerApplication;
#endif 	/* __IWMPPlayerApplication_FWD_DEFINED__ */


#ifndef __IWMPCore_FWD_DEFINED__
#define __IWMPCore_FWD_DEFINED__
typedef interface IWMPCore IWMPCore;
#endif 	/* __IWMPCore_FWD_DEFINED__ */


#ifndef __IWMPCore2_FWD_DEFINED__
#define __IWMPCore2_FWD_DEFINED__
typedef interface IWMPCore2 IWMPCore2;
#endif 	/* __IWMPCore2_FWD_DEFINED__ */


#ifndef __IWMPCore3_FWD_DEFINED__
#define __IWMPCore3_FWD_DEFINED__
typedef interface IWMPCore3 IWMPCore3;
#endif 	/* __IWMPCore3_FWD_DEFINED__ */


#ifndef __IWMPControls_FWD_DEFINED__
#define __IWMPControls_FWD_DEFINED__
typedef interface IWMPControls IWMPControls;
#endif 	/* __IWMPControls_FWD_DEFINED__ */


#ifndef __IWMPControls2_FWD_DEFINED__
#define __IWMPControls2_FWD_DEFINED__
typedef interface IWMPControls2 IWMPControls2;
#endif 	/* __IWMPControls2_FWD_DEFINED__ */


#ifndef __IWMPControls3_FWD_DEFINED__
#define __IWMPControls3_FWD_DEFINED__
typedef interface IWMPControls3 IWMPControls3;
#endif 	/* __IWMPControls3_FWD_DEFINED__ */


#ifndef __IWMPSettings_FWD_DEFINED__
#define __IWMPSettings_FWD_DEFINED__
typedef interface IWMPSettings IWMPSettings;
#endif 	/* __IWMPSettings_FWD_DEFINED__ */


#ifndef __IWMPNetwork_FWD_DEFINED__
#define __IWMPNetwork_FWD_DEFINED__
typedef interface IWMPNetwork IWMPNetwork;
#endif 	/* __IWMPNetwork_FWD_DEFINED__ */


#ifndef __IWMPMedia_FWD_DEFINED__
#define __IWMPMedia_FWD_DEFINED__
typedef interface IWMPMedia IWMPMedia;
#endif 	/* __IWMPMedia_FWD_DEFINED__ */


#ifndef __IWMPMedia2_FWD_DEFINED__
#define __IWMPMedia2_FWD_DEFINED__
typedef interface IWMPMedia2 IWMPMedia2;
#endif 	/* __IWMPMedia2_FWD_DEFINED__ */


#ifndef __IWMPPlaylist_FWD_DEFINED__
#define __IWMPPlaylist_FWD_DEFINED__
typedef interface IWMPPlaylist IWMPPlaylist;
#endif 	/* __IWMPPlaylist_FWD_DEFINED__ */


#ifndef __IWMPErrorItem_FWD_DEFINED__
#define __IWMPErrorItem_FWD_DEFINED__
typedef interface IWMPErrorItem IWMPErrorItem;
#endif 	/* __IWMPErrorItem_FWD_DEFINED__ */


#ifndef __IWMPErrorItem2_FWD_DEFINED__
#define __IWMPErrorItem2_FWD_DEFINED__
typedef interface IWMPErrorItem2 IWMPErrorItem2;
#endif 	/* __IWMPErrorItem2_FWD_DEFINED__ */


#ifndef __IWMPError_FWD_DEFINED__
#define __IWMPError_FWD_DEFINED__
typedef interface IWMPError IWMPError;
#endif 	/* __IWMPError_FWD_DEFINED__ */


#ifndef __DummyCoClass_FWD_DEFINED__
#define __DummyCoClass_FWD_DEFINED__

#ifdef __cplusplus
typedef class DummyCoClass DummyCoClass;
#else
typedef struct DummyCoClass DummyCoClass;
#endif /* __cplusplus */

#endif 	/* __DummyCoClass_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_wmpcore_0000_0000 */
/* [local] */ 

#pragma once
typedef /* [public] */ 
enum WMPOpenState
    {	wmposUndefined	= 0,
	wmposPlaylistChanging	= ( wmposUndefined + 1 ) ,
	wmposPlaylistLocating	= ( wmposPlaylistChanging + 1 ) ,
	wmposPlaylistConnecting	= ( wmposPlaylistLocating + 1 ) ,
	wmposPlaylistLoading	= ( wmposPlaylistConnecting + 1 ) ,
	wmposPlaylistOpening	= ( wmposPlaylistLoading + 1 ) ,
	wmposPlaylistOpenNoMedia	= ( wmposPlaylistOpening + 1 ) ,
	wmposPlaylistChanged	= ( wmposPlaylistOpenNoMedia + 1 ) ,
	wmposMediaChanging	= ( wmposPlaylistChanged + 1 ) ,
	wmposMediaLocating	= ( wmposMediaChanging + 1 ) ,
	wmposMediaConnecting	= ( wmposMediaLocating + 1 ) ,
	wmposMediaLoading	= ( wmposMediaConnecting + 1 ) ,
	wmposMediaOpening	= ( wmposMediaLoading + 1 ) ,
	wmposMediaOpen	= ( wmposMediaOpening + 1 ) ,
	wmposBeginCodecAcquisition	= ( wmposMediaOpen + 1 ) ,
	wmposEndCodecAcquisition	= ( wmposBeginCodecAcquisition + 1 ) ,
	wmposBeginLicenseAcquisition	= ( wmposEndCodecAcquisition + 1 ) ,
	wmposEndLicenseAcquisition	= ( wmposBeginLicenseAcquisition + 1 ) ,
	wmposBeginIndividualization	= ( wmposEndLicenseAcquisition + 1 ) ,
	wmposEndIndividualization	= ( wmposBeginIndividualization + 1 ) ,
	wmposMediaWaiting	= ( wmposEndIndividualization + 1 ) ,
	wmposOpeningUnknownURL	= ( wmposMediaWaiting + 1 ) 
    } 	WMPOpenState;

typedef /* [public] */ 
enum WMPPlayState
    {	wmppsUndefined	= 0,
	wmppsStopped	= ( wmppsUndefined + 1 ) ,
	wmppsPaused	= ( wmppsStopped + 1 ) ,
	wmppsPlaying	= ( wmppsPaused + 1 ) ,
	wmppsScanForward	= ( wmppsPlaying + 1 ) ,
	wmppsScanReverse	= ( wmppsScanForward + 1 ) ,
	wmppsBuffering	= ( wmppsScanReverse + 1 ) ,
	wmppsWaiting	= ( wmppsBuffering + 1 ) ,
	wmppsMediaEnded	= ( wmppsWaiting + 1 ) ,
	wmppsTransitioning	= ( wmppsMediaEnded + 1 ) ,
	wmppsReady	= ( wmppsTransitioning + 1 ) ,
	wmppsReconnecting	= ( wmppsReady + 1 ) ,
	wmppsLast	= ( wmppsReconnecting + 1 ) 
    } 	WMPPlayState;

typedef /* [public] */ 
enum WMPPlaylistChangeEventType
    {	wmplcUnknown	= 0,
	wmplcClear	= ( wmplcUnknown + 1 ) ,
	wmplcInfoChange	= ( wmplcClear + 1 ) ,
	wmplcMove	= ( wmplcInfoChange + 1 ) ,
	wmplcDelete	= ( wmplcMove + 1 ) ,
	wmplcInsert	= ( wmplcDelete + 1 ) ,
	wmplcAppend	= ( wmplcInsert + 1 ) ,
	wmplcPrivate	= ( wmplcAppend + 1 ) ,
	wmplcNameChange	= ( wmplcPrivate + 1 ) ,
	wmplcMorph	= ( wmplcNameChange + 1 ) ,
	wmplcSort	= ( wmplcMorph + 1 ) ,
	wmplcLast	= ( wmplcSort + 1 ) 
    } 	WMPPlaylistChangeEventType;













extern RPC_IF_HANDLE __MIDL_itf_wmpcore_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmpcore_0000_0000_v0_0_s_ifspec;

#ifndef __IWMPMediaCollection_INTERFACE_DEFINED__
#define __IWMPMediaCollection_INTERFACE_DEFINED__

/* interface IWMPMediaCollection */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPMediaCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8363BC22-B4B4-4b19-989D-1CD765749DD1")
    IWMPMediaCollection : public IDispatch
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IWMPMediaCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMPMediaCollection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMPMediaCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMPMediaCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMPMediaCollection * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMPMediaCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMPMediaCollection * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMPMediaCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } IWMPMediaCollectionVtbl;

    interface IWMPMediaCollection
    {
        CONST_VTBL struct IWMPMediaCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPMediaCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMPMediaCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMPMediaCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMPMediaCollection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWMPMediaCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWMPMediaCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWMPMediaCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMPMediaCollection_INTERFACE_DEFINED__ */


#ifndef __IWMPPlaylistCollection_INTERFACE_DEFINED__
#define __IWMPPlaylistCollection_INTERFACE_DEFINED__

/* interface IWMPPlaylistCollection */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPPlaylistCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("10A13217-23A7-439b-B1C0-D847C79B7774")
    IWMPPlaylistCollection : public IDispatch
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IWMPPlaylistCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMPPlaylistCollection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMPPlaylistCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMPPlaylistCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMPPlaylistCollection * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMPPlaylistCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMPPlaylistCollection * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMPPlaylistCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } IWMPPlaylistCollectionVtbl;

    interface IWMPPlaylistCollection
    {
        CONST_VTBL struct IWMPPlaylistCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPPlaylistCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMPPlaylistCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMPPlaylistCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMPPlaylistCollection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWMPPlaylistCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWMPPlaylistCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWMPPlaylistCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMPPlaylistCollection_INTERFACE_DEFINED__ */


#ifndef __IWMPCdromCollection_INTERFACE_DEFINED__
#define __IWMPCdromCollection_INTERFACE_DEFINED__

/* interface IWMPCdromCollection */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPCdromCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EE4C8FE2-34B2-11d3-A3BF-006097C9B344")
    IWMPCdromCollection : public IDispatch
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IWMPCdromCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMPCdromCollection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMPCdromCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMPCdromCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMPCdromCollection * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMPCdromCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMPCdromCollection * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMPCdromCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } IWMPCdromCollectionVtbl;

    interface IWMPCdromCollection
    {
        CONST_VTBL struct IWMPCdromCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPCdromCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMPCdromCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMPCdromCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMPCdromCollection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWMPCdromCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWMPCdromCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWMPCdromCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMPCdromCollection_INTERFACE_DEFINED__ */


#ifndef __IWMPClosedCaption_INTERFACE_DEFINED__
#define __IWMPClosedCaption_INTERFACE_DEFINED__

/* interface IWMPClosedCaption */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPClosedCaption;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4F2DF574-C588-11d3-9ED0-00C04FB6E937")
    IWMPClosedCaption : public IDispatch
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IWMPClosedCaptionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMPClosedCaption * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMPClosedCaption * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMPClosedCaption * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMPClosedCaption * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMPClosedCaption * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMPClosedCaption * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMPClosedCaption * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } IWMPClosedCaptionVtbl;

    interface IWMPClosedCaption
    {
        CONST_VTBL struct IWMPClosedCaptionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPClosedCaption_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMPClosedCaption_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMPClosedCaption_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMPClosedCaption_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWMPClosedCaption_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWMPClosedCaption_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWMPClosedCaption_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMPClosedCaption_INTERFACE_DEFINED__ */


#ifndef __IWMPDVD_INTERFACE_DEFINED__
#define __IWMPDVD_INTERFACE_DEFINED__

/* interface IWMPDVD */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPDVD;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8DA61686-4668-4a5c-AE5D-803193293DBE")
    IWMPDVD : public IDispatch
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IWMPDVDVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMPDVD * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMPDVD * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMPDVD * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMPDVD * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMPDVD * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMPDVD * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMPDVD * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } IWMPDVDVtbl;

    interface IWMPDVD
    {
        CONST_VTBL struct IWMPDVDVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPDVD_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMPDVD_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMPDVD_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMPDVD_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWMPDVD_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWMPDVD_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWMPDVD_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMPDVD_INTERFACE_DEFINED__ */


#ifndef __IWMPPlayerApplication_INTERFACE_DEFINED__
#define __IWMPPlayerApplication_INTERFACE_DEFINED__

/* interface IWMPPlayerApplication */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPPlayerApplication;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("40897764-CEAB-47be-AD4A-8E28537F9BBF")
    IWMPPlayerApplication : public IDispatch
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IWMPPlayerApplicationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMPPlayerApplication * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMPPlayerApplication * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMPPlayerApplication * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMPPlayerApplication * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMPPlayerApplication * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMPPlayerApplication * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMPPlayerApplication * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } IWMPPlayerApplicationVtbl;

    interface IWMPPlayerApplication
    {
        CONST_VTBL struct IWMPPlayerApplicationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPPlayerApplication_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMPPlayerApplication_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMPPlayerApplication_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMPPlayerApplication_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWMPPlayerApplication_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWMPPlayerApplication_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWMPPlayerApplication_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMPPlayerApplication_INTERFACE_DEFINED__ */


#ifndef __IWMPCore_INTERFACE_DEFINED__
#define __IWMPCore_INTERFACE_DEFINED__

/* interface IWMPCore */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPCore;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D84CCA99-CCE2-11d2-9ECC-0000F8085981")
    IWMPCore : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE close( void) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_URL( 
            /* [retval][out] */ BSTR *pbstrURL) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_URL( 
            /* [in] */ BSTR bstrURL) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_openState( 
            /* [retval][out] */ WMPOpenState *pwmpos) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_playState( 
            /* [retval][out] */ WMPPlayState *pwmpps) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_controls( 
            /* [retval][out] */ IWMPControls **ppControl) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_settings( 
            /* [retval][out] */ IWMPSettings **ppSettings) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_currentMedia( 
            /* [retval][out] */ IWMPMedia **ppMedia) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_currentMedia( 
            /* [in] */ IWMPMedia *pMedia) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_mediaCollection( 
            /* [retval][out] */ IWMPMediaCollection **ppMediaCollection) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_playlistCollection( 
            /* [retval][out] */ IWMPPlaylistCollection **ppPlaylistCollection) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_versionInfo( 
            /* [retval][out] */ BSTR *pbstrVersionInfo) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE launchURL( 
            BSTR bstrURL) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_network( 
            /* [retval][out] */ IWMPNetwork **ppQNI) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_currentPlaylist( 
            /* [retval][out] */ IWMPPlaylist **ppPL) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_currentPlaylist( 
            /* [in] */ IWMPPlaylist *pPL) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_cdromCollection( 
            /* [retval][out] */ IWMPCdromCollection **ppCdromCollection) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_closedCaption( 
            /* [retval][out] */ IWMPClosedCaption **ppClosedCaption) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_isOnline( 
            /* [retval][out] */ VARIANT_BOOL *pfOnline) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_error( 
            /* [retval][out] */ IWMPError **ppError) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_status( 
            /* [retval][out] */ BSTR *pbstrStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPCoreVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMPCore * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMPCore * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMPCore * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMPCore * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMPCore * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMPCore * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMPCore * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *close )( 
            IWMPCore * This);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_URL )( 
            IWMPCore * This,
            /* [retval][out] */ BSTR *pbstrURL);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_URL )( 
            IWMPCore * This,
            /* [in] */ BSTR bstrURL);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_openState )( 
            IWMPCore * This,
            /* [retval][out] */ WMPOpenState *pwmpos);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_playState )( 
            IWMPCore * This,
            /* [retval][out] */ WMPPlayState *pwmpps);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_controls )( 
            IWMPCore * This,
            /* [retval][out] */ IWMPControls **ppControl);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_settings )( 
            IWMPCore * This,
            /* [retval][out] */ IWMPSettings **ppSettings);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_currentMedia )( 
            IWMPCore * This,
            /* [retval][out] */ IWMPMedia **ppMedia);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_currentMedia )( 
            IWMPCore * This,
            /* [in] */ IWMPMedia *pMedia);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_mediaCollection )( 
            IWMPCore * This,
            /* [retval][out] */ IWMPMediaCollection **ppMediaCollection);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_playlistCollection )( 
            IWMPCore * This,
            /* [retval][out] */ IWMPPlaylistCollection **ppPlaylistCollection);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_versionInfo )( 
            IWMPCore * This,
            /* [retval][out] */ BSTR *pbstrVersionInfo);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *launchURL )( 
            IWMPCore * This,
            BSTR bstrURL);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_network )( 
            IWMPCore * This,
            /* [retval][out] */ IWMPNetwork **ppQNI);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_currentPlaylist )( 
            IWMPCore * This,
            /* [retval][out] */ IWMPPlaylist **ppPL);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_currentPlaylist )( 
            IWMPCore * This,
            /* [in] */ IWMPPlaylist *pPL);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_cdromCollection )( 
            IWMPCore * This,
            /* [retval][out] */ IWMPCdromCollection **ppCdromCollection);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_closedCaption )( 
            IWMPCore * This,
            /* [retval][out] */ IWMPClosedCaption **ppClosedCaption);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_isOnline )( 
            IWMPCore * This,
            /* [retval][out] */ VARIANT_BOOL *pfOnline);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_error )( 
            IWMPCore * This,
            /* [retval][out] */ IWMPError **ppError);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_status )( 
            IWMPCore * This,
            /* [retval][out] */ BSTR *pbstrStatus);
        
        END_INTERFACE
    } IWMPCoreVtbl;

    interface IWMPCore
    {
        CONST_VTBL struct IWMPCoreVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPCore_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMPCore_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMPCore_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMPCore_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWMPCore_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWMPCore_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWMPCore_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWMPCore_close(This)	\
    ( (This)->lpVtbl -> close(This) ) 

#define IWMPCore_get_URL(This,pbstrURL)	\
    ( (This)->lpVtbl -> get_URL(This,pbstrURL) ) 

#define IWMPCore_put_URL(This,bstrURL)	\
    ( (This)->lpVtbl -> put_URL(This,bstrURL) ) 

#define IWMPCore_get_openState(This,pwmpos)	\
    ( (This)->lpVtbl -> get_openState(This,pwmpos) ) 

#define IWMPCore_get_playState(This,pwmpps)	\
    ( (This)->lpVtbl -> get_playState(This,pwmpps) ) 

#define IWMPCore_get_controls(This,ppControl)	\
    ( (This)->lpVtbl -> get_controls(This,ppControl) ) 

#define IWMPCore_get_settings(This,ppSettings)	\
    ( (This)->lpVtbl -> get_settings(This,ppSettings) ) 

#define IWMPCore_get_currentMedia(This,ppMedia)	\
    ( (This)->lpVtbl -> get_currentMedia(This,ppMedia) ) 

#define IWMPCore_put_currentMedia(This,pMedia)	\
    ( (This)->lpVtbl -> put_currentMedia(This,pMedia) ) 

#define IWMPCore_get_mediaCollection(This,ppMediaCollection)	\
    ( (This)->lpVtbl -> get_mediaCollection(This,ppMediaCollection) ) 

#define IWMPCore_get_playlistCollection(This,ppPlaylistCollection)	\
    ( (This)->lpVtbl -> get_playlistCollection(This,ppPlaylistCollection) ) 

#define IWMPCore_get_versionInfo(This,pbstrVersionInfo)	\
    ( (This)->lpVtbl -> get_versionInfo(This,pbstrVersionInfo) ) 

#define IWMPCore_launchURL(This,bstrURL)	\
    ( (This)->lpVtbl -> launchURL(This,bstrURL) ) 

#define IWMPCore_get_network(This,ppQNI)	\
    ( (This)->lpVtbl -> get_network(This,ppQNI) ) 

#define IWMPCore_get_currentPlaylist(This,ppPL)	\
    ( (This)->lpVtbl -> get_currentPlaylist(This,ppPL) ) 

#define IWMPCore_put_currentPlaylist(This,pPL)	\
    ( (This)->lpVtbl -> put_currentPlaylist(This,pPL) ) 

#define IWMPCore_get_cdromCollection(This,ppCdromCollection)	\
    ( (This)->lpVtbl -> get_cdromCollection(This,ppCdromCollection) ) 

#define IWMPCore_get_closedCaption(This,ppClosedCaption)	\
    ( (This)->lpVtbl -> get_closedCaption(This,ppClosedCaption) ) 

#define IWMPCore_get_isOnline(This,pfOnline)	\
    ( (This)->lpVtbl -> get_isOnline(This,pfOnline) ) 

#define IWMPCore_get_error(This,ppError)	\
    ( (This)->lpVtbl -> get_error(This,ppError) ) 

#define IWMPCore_get_status(This,pbstrStatus)	\
    ( (This)->lpVtbl -> get_status(This,pbstrStatus) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMPCore_INTERFACE_DEFINED__ */


#ifndef __IWMPCore2_INTERFACE_DEFINED__
#define __IWMPCore2_INTERFACE_DEFINED__

/* interface IWMPCore2 */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPCore2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BC17E5B7-7561-4c18-BB90-17D485775659")
    IWMPCore2 : public IWMPCore
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_dvd( 
            /* [retval][out] */ IWMPDVD **ppDVD) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPCore2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMPCore2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMPCore2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMPCore2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMPCore2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMPCore2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMPCore2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMPCore2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *close )( 
            IWMPCore2 * This);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_URL )( 
            IWMPCore2 * This,
            /* [retval][out] */ BSTR *pbstrURL);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_URL )( 
            IWMPCore2 * This,
            /* [in] */ BSTR bstrURL);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_openState )( 
            IWMPCore2 * This,
            /* [retval][out] */ WMPOpenState *pwmpos);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_playState )( 
            IWMPCore2 * This,
            /* [retval][out] */ WMPPlayState *pwmpps);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_controls )( 
            IWMPCore2 * This,
            /* [retval][out] */ IWMPControls **ppControl);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_settings )( 
            IWMPCore2 * This,
            /* [retval][out] */ IWMPSettings **ppSettings);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_currentMedia )( 
            IWMPCore2 * This,
            /* [retval][out] */ IWMPMedia **ppMedia);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_currentMedia )( 
            IWMPCore2 * This,
            /* [in] */ IWMPMedia *pMedia);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_mediaCollection )( 
            IWMPCore2 * This,
            /* [retval][out] */ IWMPMediaCollection **ppMediaCollection);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_playlistCollection )( 
            IWMPCore2 * This,
            /* [retval][out] */ IWMPPlaylistCollection **ppPlaylistCollection);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_versionInfo )( 
            IWMPCore2 * This,
            /* [retval][out] */ BSTR *pbstrVersionInfo);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *launchURL )( 
            IWMPCore2 * This,
            BSTR bstrURL);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_network )( 
            IWMPCore2 * This,
            /* [retval][out] */ IWMPNetwork **ppQNI);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_currentPlaylist )( 
            IWMPCore2 * This,
            /* [retval][out] */ IWMPPlaylist **ppPL);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_currentPlaylist )( 
            IWMPCore2 * This,
            /* [in] */ IWMPPlaylist *pPL);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_cdromCollection )( 
            IWMPCore2 * This,
            /* [retval][out] */ IWMPCdromCollection **ppCdromCollection);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_closedCaption )( 
            IWMPCore2 * This,
            /* [retval][out] */ IWMPClosedCaption **ppClosedCaption);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_isOnline )( 
            IWMPCore2 * This,
            /* [retval][out] */ VARIANT_BOOL *pfOnline);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_error )( 
            IWMPCore2 * This,
            /* [retval][out] */ IWMPError **ppError);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_status )( 
            IWMPCore2 * This,
            /* [retval][out] */ BSTR *pbstrStatus);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_dvd )( 
            IWMPCore2 * This,
            /* [retval][out] */ IWMPDVD **ppDVD);
        
        END_INTERFACE
    } IWMPCore2Vtbl;

    interface IWMPCore2
    {
        CONST_VTBL struct IWMPCore2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPCore2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMPCore2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMPCore2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMPCore2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWMPCore2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWMPCore2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWMPCore2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWMPCore2_close(This)	\
    ( (This)->lpVtbl -> close(This) ) 

#define IWMPCore2_get_URL(This,pbstrURL)	\
    ( (This)->lpVtbl -> get_URL(This,pbstrURL) ) 

#define IWMPCore2_put_URL(This,bstrURL)	\
    ( (This)->lpVtbl -> put_URL(This,bstrURL) ) 

#define IWMPCore2_get_openState(This,pwmpos)	\
    ( (This)->lpVtbl -> get_openState(This,pwmpos) ) 

#define IWMPCore2_get_playState(This,pwmpps)	\
    ( (This)->lpVtbl -> get_playState(This,pwmpps) ) 

#define IWMPCore2_get_controls(This,ppControl)	\
    ( (This)->lpVtbl -> get_controls(This,ppControl) ) 

#define IWMPCore2_get_settings(This,ppSettings)	\
    ( (This)->lpVtbl -> get_settings(This,ppSettings) ) 

#define IWMPCore2_get_currentMedia(This,ppMedia)	\
    ( (This)->lpVtbl -> get_currentMedia(This,ppMedia) ) 

#define IWMPCore2_put_currentMedia(This,pMedia)	\
    ( (This)->lpVtbl -> put_currentMedia(This,pMedia) ) 

#define IWMPCore2_get_mediaCollection(This,ppMediaCollection)	\
    ( (This)->lpVtbl -> get_mediaCollection(This,ppMediaCollection) ) 

#define IWMPCore2_get_playlistCollection(This,ppPlaylistCollection)	\
    ( (This)->lpVtbl -> get_playlistCollection(This,ppPlaylistCollection) ) 

#define IWMPCore2_get_versionInfo(This,pbstrVersionInfo)	\
    ( (This)->lpVtbl -> get_versionInfo(This,pbstrVersionInfo) ) 

#define IWMPCore2_launchURL(This,bstrURL)	\
    ( (This)->lpVtbl -> launchURL(This,bstrURL) ) 

#define IWMPCore2_get_network(This,ppQNI)	\
    ( (This)->lpVtbl -> get_network(This,ppQNI) ) 

#define IWMPCore2_get_currentPlaylist(This,ppPL)	\
    ( (This)->lpVtbl -> get_currentPlaylist(This,ppPL) ) 

#define IWMPCore2_put_currentPlaylist(This,pPL)	\
    ( (This)->lpVtbl -> put_currentPlaylist(This,pPL) ) 

#define IWMPCore2_get_cdromCollection(This,ppCdromCollection)	\
    ( (This)->lpVtbl -> get_cdromCollection(This,ppCdromCollection) ) 

#define IWMPCore2_get_closedCaption(This,ppClosedCaption)	\
    ( (This)->lpVtbl -> get_closedCaption(This,ppClosedCaption) ) 

#define IWMPCore2_get_isOnline(This,pfOnline)	\
    ( (This)->lpVtbl -> get_isOnline(This,pfOnline) ) 

#define IWMPCore2_get_error(This,ppError)	\
    ( (This)->lpVtbl -> get_error(This,ppError) ) 

#define IWMPCore2_get_status(This,pbstrStatus)	\
    ( (This)->lpVtbl -> get_status(This,pbstrStatus) ) 


#define IWMPCore2_get_dvd(This,ppDVD)	\
    ( (This)->lpVtbl -> get_dvd(This,ppDVD) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMPCore2_INTERFACE_DEFINED__ */


#ifndef __IWMPCore3_INTERFACE_DEFINED__
#define __IWMPCore3_INTERFACE_DEFINED__

/* interface IWMPCore3 */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPCore3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7587C667-628F-499f-88E7-6A6F4E888464")
    IWMPCore3 : public IWMPCore2
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE newMedia( 
            /* [in] */ BSTR bstrURL,
            /* [retval][out] */ IWMPMedia **ppMedia) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE newPlaylist( 
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrURL,
            /* [retval][out] */ IWMPPlaylist **ppPlaylist) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPCore3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMPCore3 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMPCore3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMPCore3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMPCore3 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMPCore3 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMPCore3 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMPCore3 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *close )( 
            IWMPCore3 * This);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_URL )( 
            IWMPCore3 * This,
            /* [retval][out] */ BSTR *pbstrURL);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_URL )( 
            IWMPCore3 * This,
            /* [in] */ BSTR bstrURL);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_openState )( 
            IWMPCore3 * This,
            /* [retval][out] */ WMPOpenState *pwmpos);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_playState )( 
            IWMPCore3 * This,
            /* [retval][out] */ WMPPlayState *pwmpps);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_controls )( 
            IWMPCore3 * This,
            /* [retval][out] */ IWMPControls **ppControl);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_settings )( 
            IWMPCore3 * This,
            /* [retval][out] */ IWMPSettings **ppSettings);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_currentMedia )( 
            IWMPCore3 * This,
            /* [retval][out] */ IWMPMedia **ppMedia);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_currentMedia )( 
            IWMPCore3 * This,
            /* [in] */ IWMPMedia *pMedia);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_mediaCollection )( 
            IWMPCore3 * This,
            /* [retval][out] */ IWMPMediaCollection **ppMediaCollection);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_playlistCollection )( 
            IWMPCore3 * This,
            /* [retval][out] */ IWMPPlaylistCollection **ppPlaylistCollection);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_versionInfo )( 
            IWMPCore3 * This,
            /* [retval][out] */ BSTR *pbstrVersionInfo);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *launchURL )( 
            IWMPCore3 * This,
            BSTR bstrURL);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_network )( 
            IWMPCore3 * This,
            /* [retval][out] */ IWMPNetwork **ppQNI);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_currentPlaylist )( 
            IWMPCore3 * This,
            /* [retval][out] */ IWMPPlaylist **ppPL);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_currentPlaylist )( 
            IWMPCore3 * This,
            /* [in] */ IWMPPlaylist *pPL);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_cdromCollection )( 
            IWMPCore3 * This,
            /* [retval][out] */ IWMPCdromCollection **ppCdromCollection);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_closedCaption )( 
            IWMPCore3 * This,
            /* [retval][out] */ IWMPClosedCaption **ppClosedCaption);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_isOnline )( 
            IWMPCore3 * This,
            /* [retval][out] */ VARIANT_BOOL *pfOnline);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_error )( 
            IWMPCore3 * This,
            /* [retval][out] */ IWMPError **ppError);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_status )( 
            IWMPCore3 * This,
            /* [retval][out] */ BSTR *pbstrStatus);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_dvd )( 
            IWMPCore3 * This,
            /* [retval][out] */ IWMPDVD **ppDVD);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *newMedia )( 
            IWMPCore3 * This,
            /* [in] */ BSTR bstrURL,
            /* [retval][out] */ IWMPMedia **ppMedia);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *newPlaylist )( 
            IWMPCore3 * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrURL,
            /* [retval][out] */ IWMPPlaylist **ppPlaylist);
        
        END_INTERFACE
    } IWMPCore3Vtbl;

    interface IWMPCore3
    {
        CONST_VTBL struct IWMPCore3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPCore3_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMPCore3_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMPCore3_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMPCore3_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWMPCore3_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWMPCore3_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWMPCore3_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWMPCore3_close(This)	\
    ( (This)->lpVtbl -> close(This) ) 

#define IWMPCore3_get_URL(This,pbstrURL)	\
    ( (This)->lpVtbl -> get_URL(This,pbstrURL) ) 

#define IWMPCore3_put_URL(This,bstrURL)	\
    ( (This)->lpVtbl -> put_URL(This,bstrURL) ) 

#define IWMPCore3_get_openState(This,pwmpos)	\
    ( (This)->lpVtbl -> get_openState(This,pwmpos) ) 

#define IWMPCore3_get_playState(This,pwmpps)	\
    ( (This)->lpVtbl -> get_playState(This,pwmpps) ) 

#define IWMPCore3_get_controls(This,ppControl)	\
    ( (This)->lpVtbl -> get_controls(This,ppControl) ) 

#define IWMPCore3_get_settings(This,ppSettings)	\
    ( (This)->lpVtbl -> get_settings(This,ppSettings) ) 

#define IWMPCore3_get_currentMedia(This,ppMedia)	\
    ( (This)->lpVtbl -> get_currentMedia(This,ppMedia) ) 

#define IWMPCore3_put_currentMedia(This,pMedia)	\
    ( (This)->lpVtbl -> put_currentMedia(This,pMedia) ) 

#define IWMPCore3_get_mediaCollection(This,ppMediaCollection)	\
    ( (This)->lpVtbl -> get_mediaCollection(This,ppMediaCollection) ) 

#define IWMPCore3_get_playlistCollection(This,ppPlaylistCollection)	\
    ( (This)->lpVtbl -> get_playlistCollection(This,ppPlaylistCollection) ) 

#define IWMPCore3_get_versionInfo(This,pbstrVersionInfo)	\
    ( (This)->lpVtbl -> get_versionInfo(This,pbstrVersionInfo) ) 

#define IWMPCore3_launchURL(This,bstrURL)	\
    ( (This)->lpVtbl -> launchURL(This,bstrURL) ) 

#define IWMPCore3_get_network(This,ppQNI)	\
    ( (This)->lpVtbl -> get_network(This,ppQNI) ) 

#define IWMPCore3_get_currentPlaylist(This,ppPL)	\
    ( (This)->lpVtbl -> get_currentPlaylist(This,ppPL) ) 

#define IWMPCore3_put_currentPlaylist(This,pPL)	\
    ( (This)->lpVtbl -> put_currentPlaylist(This,pPL) ) 

#define IWMPCore3_get_cdromCollection(This,ppCdromCollection)	\
    ( (This)->lpVtbl -> get_cdromCollection(This,ppCdromCollection) ) 

#define IWMPCore3_get_closedCaption(This,ppClosedCaption)	\
    ( (This)->lpVtbl -> get_closedCaption(This,ppClosedCaption) ) 

#define IWMPCore3_get_isOnline(This,pfOnline)	\
    ( (This)->lpVtbl -> get_isOnline(This,pfOnline) ) 

#define IWMPCore3_get_error(This,ppError)	\
    ( (This)->lpVtbl -> get_error(This,ppError) ) 

#define IWMPCore3_get_status(This,pbstrStatus)	\
    ( (This)->lpVtbl -> get_status(This,pbstrStatus) ) 


#define IWMPCore3_get_dvd(This,ppDVD)	\
    ( (This)->lpVtbl -> get_dvd(This,ppDVD) ) 


#define IWMPCore3_newMedia(This,bstrURL,ppMedia)	\
    ( (This)->lpVtbl -> newMedia(This,bstrURL,ppMedia) ) 

#define IWMPCore3_newPlaylist(This,bstrName,bstrURL,ppPlaylist)	\
    ( (This)->lpVtbl -> newPlaylist(This,bstrName,bstrURL,ppPlaylist) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMPCore3_INTERFACE_DEFINED__ */


#ifndef __IWMPControls_INTERFACE_DEFINED__
#define __IWMPControls_INTERFACE_DEFINED__

/* interface IWMPControls */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPControls;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("74C09E02-F828-11d2-A74B-00A0C905F36E")
    IWMPControls : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_isAvailable( 
            /* [in] */ BSTR bstrItem,
            /* [retval][out] */ VARIANT_BOOL *pIsAvailable) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE play( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE stop( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE pause( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE fastForward( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE fastReverse( void) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_currentPosition( 
            /* [retval][out] */ double *pdCurrentPosition) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_currentPosition( 
            /* [in] */ double dCurrentPosition) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_currentPositionString( 
            /* [retval][out] */ BSTR *pbstrCurrentPosition) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE next( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE previous( void) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_currentItem( 
            /* [retval][out] */ IWMPMedia **ppIWMPMedia) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_currentItem( 
            /* [in] */ IWMPMedia *pIWMPMedia) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_currentMarker( 
            /* [retval][out] */ long *plMarker) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_currentMarker( 
            /* [in] */ long lMarker) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE playItem( 
            /* [in] */ IWMPMedia *pIWMPMedia) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPControlsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMPControls * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMPControls * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMPControls * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMPControls * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMPControls * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMPControls * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMPControls * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_isAvailable )( 
            IWMPControls * This,
            /* [in] */ BSTR bstrItem,
            /* [retval][out] */ VARIANT_BOOL *pIsAvailable);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *play )( 
            IWMPControls * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *stop )( 
            IWMPControls * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *pause )( 
            IWMPControls * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *fastForward )( 
            IWMPControls * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *fastReverse )( 
            IWMPControls * This);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_currentPosition )( 
            IWMPControls * This,
            /* [retval][out] */ double *pdCurrentPosition);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_currentPosition )( 
            IWMPControls * This,
            /* [in] */ double dCurrentPosition);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_currentPositionString )( 
            IWMPControls * This,
            /* [retval][out] */ BSTR *pbstrCurrentPosition);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *next )( 
            IWMPControls * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *previous )( 
            IWMPControls * This);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_currentItem )( 
            IWMPControls * This,
            /* [retval][out] */ IWMPMedia **ppIWMPMedia);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_currentItem )( 
            IWMPControls * This,
            /* [in] */ IWMPMedia *pIWMPMedia);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_currentMarker )( 
            IWMPControls * This,
            /* [retval][out] */ long *plMarker);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_currentMarker )( 
            IWMPControls * This,
            /* [in] */ long lMarker);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *playItem )( 
            IWMPControls * This,
            /* [in] */ IWMPMedia *pIWMPMedia);
        
        END_INTERFACE
    } IWMPControlsVtbl;

    interface IWMPControls
    {
        CONST_VTBL struct IWMPControlsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPControls_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMPControls_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMPControls_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMPControls_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWMPControls_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWMPControls_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWMPControls_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWMPControls_get_isAvailable(This,bstrItem,pIsAvailable)	\
    ( (This)->lpVtbl -> get_isAvailable(This,bstrItem,pIsAvailable) ) 

#define IWMPControls_play(This)	\
    ( (This)->lpVtbl -> play(This) ) 

#define IWMPControls_stop(This)	\
    ( (This)->lpVtbl -> stop(This) ) 

#define IWMPControls_pause(This)	\
    ( (This)->lpVtbl -> pause(This) ) 

#define IWMPControls_fastForward(This)	\
    ( (This)->lpVtbl -> fastForward(This) ) 

#define IWMPControls_fastReverse(This)	\
    ( (This)->lpVtbl -> fastReverse(This) ) 

#define IWMPControls_get_currentPosition(This,pdCurrentPosition)	\
    ( (This)->lpVtbl -> get_currentPosition(This,pdCurrentPosition) ) 

#define IWMPControls_put_currentPosition(This,dCurrentPosition)	\
    ( (This)->lpVtbl -> put_currentPosition(This,dCurrentPosition) ) 

#define IWMPControls_get_currentPositionString(This,pbstrCurrentPosition)	\
    ( (This)->lpVtbl -> get_currentPositionString(This,pbstrCurrentPosition) ) 

#define IWMPControls_next(This)	\
    ( (This)->lpVtbl -> next(This) ) 

#define IWMPControls_previous(This)	\
    ( (This)->lpVtbl -> previous(This) ) 

#define IWMPControls_get_currentItem(This,ppIWMPMedia)	\
    ( (This)->lpVtbl -> get_currentItem(This,ppIWMPMedia) ) 

#define IWMPControls_put_currentItem(This,pIWMPMedia)	\
    ( (This)->lpVtbl -> put_currentItem(This,pIWMPMedia) ) 

#define IWMPControls_get_currentMarker(This,plMarker)	\
    ( (This)->lpVtbl -> get_currentMarker(This,plMarker) ) 

#define IWMPControls_put_currentMarker(This,lMarker)	\
    ( (This)->lpVtbl -> put_currentMarker(This,lMarker) ) 

#define IWMPControls_playItem(This,pIWMPMedia)	\
    ( (This)->lpVtbl -> playItem(This,pIWMPMedia) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMPControls_INTERFACE_DEFINED__ */


#ifndef __IWMPControls2_INTERFACE_DEFINED__
#define __IWMPControls2_INTERFACE_DEFINED__

/* interface IWMPControls2 */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPControls2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6F030D25-0890-480f-9775-1F7E40AB5B8E")
    IWMPControls2 : public IWMPControls
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE step( 
            /* [in] */ long lStep) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPControls2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMPControls2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMPControls2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMPControls2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMPControls2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMPControls2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMPControls2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMPControls2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_isAvailable )( 
            IWMPControls2 * This,
            /* [in] */ BSTR bstrItem,
            /* [retval][out] */ VARIANT_BOOL *pIsAvailable);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *play )( 
            IWMPControls2 * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *stop )( 
            IWMPControls2 * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *pause )( 
            IWMPControls2 * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *fastForward )( 
            IWMPControls2 * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *fastReverse )( 
            IWMPControls2 * This);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_currentPosition )( 
            IWMPControls2 * This,
            /* [retval][out] */ double *pdCurrentPosition);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_currentPosition )( 
            IWMPControls2 * This,
            /* [in] */ double dCurrentPosition);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_currentPositionString )( 
            IWMPControls2 * This,
            /* [retval][out] */ BSTR *pbstrCurrentPosition);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *next )( 
            IWMPControls2 * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *previous )( 
            IWMPControls2 * This);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_currentItem )( 
            IWMPControls2 * This,
            /* [retval][out] */ IWMPMedia **ppIWMPMedia);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_currentItem )( 
            IWMPControls2 * This,
            /* [in] */ IWMPMedia *pIWMPMedia);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_currentMarker )( 
            IWMPControls2 * This,
            /* [retval][out] */ long *plMarker);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_currentMarker )( 
            IWMPControls2 * This,
            /* [in] */ long lMarker);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *playItem )( 
            IWMPControls2 * This,
            /* [in] */ IWMPMedia *pIWMPMedia);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *step )( 
            IWMPControls2 * This,
            /* [in] */ long lStep);
        
        END_INTERFACE
    } IWMPControls2Vtbl;

    interface IWMPControls2
    {
        CONST_VTBL struct IWMPControls2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPControls2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMPControls2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMPControls2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMPControls2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWMPControls2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWMPControls2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWMPControls2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWMPControls2_get_isAvailable(This,bstrItem,pIsAvailable)	\
    ( (This)->lpVtbl -> get_isAvailable(This,bstrItem,pIsAvailable) ) 

#define IWMPControls2_play(This)	\
    ( (This)->lpVtbl -> play(This) ) 

#define IWMPControls2_stop(This)	\
    ( (This)->lpVtbl -> stop(This) ) 

#define IWMPControls2_pause(This)	\
    ( (This)->lpVtbl -> pause(This) ) 

#define IWMPControls2_fastForward(This)	\
    ( (This)->lpVtbl -> fastForward(This) ) 

#define IWMPControls2_fastReverse(This)	\
    ( (This)->lpVtbl -> fastReverse(This) ) 

#define IWMPControls2_get_currentPosition(This,pdCurrentPosition)	\
    ( (This)->lpVtbl -> get_currentPosition(This,pdCurrentPosition) ) 

#define IWMPControls2_put_currentPosition(This,dCurrentPosition)	\
    ( (This)->lpVtbl -> put_currentPosition(This,dCurrentPosition) ) 

#define IWMPControls2_get_currentPositionString(This,pbstrCurrentPosition)	\
    ( (This)->lpVtbl -> get_currentPositionString(This,pbstrCurrentPosition) ) 

#define IWMPControls2_next(This)	\
    ( (This)->lpVtbl -> next(This) ) 

#define IWMPControls2_previous(This)	\
    ( (This)->lpVtbl -> previous(This) ) 

#define IWMPControls2_get_currentItem(This,ppIWMPMedia)	\
    ( (This)->lpVtbl -> get_currentItem(This,ppIWMPMedia) ) 

#define IWMPControls2_put_currentItem(This,pIWMPMedia)	\
    ( (This)->lpVtbl -> put_currentItem(This,pIWMPMedia) ) 

#define IWMPControls2_get_currentMarker(This,plMarker)	\
    ( (This)->lpVtbl -> get_currentMarker(This,plMarker) ) 

#define IWMPControls2_put_currentMarker(This,lMarker)	\
    ( (This)->lpVtbl -> put_currentMarker(This,lMarker) ) 

#define IWMPControls2_playItem(This,pIWMPMedia)	\
    ( (This)->lpVtbl -> playItem(This,pIWMPMedia) ) 


#define IWMPControls2_step(This,lStep)	\
    ( (This)->lpVtbl -> step(This,lStep) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMPControls2_INTERFACE_DEFINED__ */


#ifndef __IWMPControls3_INTERFACE_DEFINED__
#define __IWMPControls3_INTERFACE_DEFINED__

/* interface IWMPControls3 */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPControls3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A1D1110E-D545-476a-9A78-AC3E4CB1E6BD")
    IWMPControls3 : public IWMPControls2
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_audioLanguageCount( 
            /* [retval][out] */ long *plCount) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getAudioLanguageID( 
            /* [in] */ long lIndex,
            /* [retval][out] */ long *plLangID) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getAudioLanguageDescription( 
            /* [in] */ long lIndex,
            /* [retval][out] */ BSTR *pbstrLangDesc) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_currentAudioLanguage( 
            /* [retval][out] */ long *plLangID) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_currentAudioLanguage( 
            /* [in] */ long lLangID) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_currentAudioLanguageIndex( 
            /* [retval][out] */ long *plIndex) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_currentAudioLanguageIndex( 
            /* [in] */ long lIndex) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getLanguageName( 
            /* [in] */ long lLangID,
            /* [retval][out] */ BSTR *pbstrLangName) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_currentPositionTimecode( 
            /* [retval][out] */ BSTR *bstrTimecode) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_currentPositionTimecode( 
            /* [in] */ BSTR bstrTimecode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPControls3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMPControls3 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMPControls3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMPControls3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMPControls3 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMPControls3 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMPControls3 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMPControls3 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_isAvailable )( 
            IWMPControls3 * This,
            /* [in] */ BSTR bstrItem,
            /* [retval][out] */ VARIANT_BOOL *pIsAvailable);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *play )( 
            IWMPControls3 * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *stop )( 
            IWMPControls3 * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *pause )( 
            IWMPControls3 * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *fastForward )( 
            IWMPControls3 * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *fastReverse )( 
            IWMPControls3 * This);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_currentPosition )( 
            IWMPControls3 * This,
            /* [retval][out] */ double *pdCurrentPosition);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_currentPosition )( 
            IWMPControls3 * This,
            /* [in] */ double dCurrentPosition);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_currentPositionString )( 
            IWMPControls3 * This,
            /* [retval][out] */ BSTR *pbstrCurrentPosition);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *next )( 
            IWMPControls3 * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *previous )( 
            IWMPControls3 * This);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_currentItem )( 
            IWMPControls3 * This,
            /* [retval][out] */ IWMPMedia **ppIWMPMedia);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_currentItem )( 
            IWMPControls3 * This,
            /* [in] */ IWMPMedia *pIWMPMedia);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_currentMarker )( 
            IWMPControls3 * This,
            /* [retval][out] */ long *plMarker);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_currentMarker )( 
            IWMPControls3 * This,
            /* [in] */ long lMarker);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *playItem )( 
            IWMPControls3 * This,
            /* [in] */ IWMPMedia *pIWMPMedia);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *step )( 
            IWMPControls3 * This,
            /* [in] */ long lStep);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_audioLanguageCount )( 
            IWMPControls3 * This,
            /* [retval][out] */ long *plCount);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *getAudioLanguageID )( 
            IWMPControls3 * This,
            /* [in] */ long lIndex,
            /* [retval][out] */ long *plLangID);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *getAudioLanguageDescription )( 
            IWMPControls3 * This,
            /* [in] */ long lIndex,
            /* [retval][out] */ BSTR *pbstrLangDesc);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_currentAudioLanguage )( 
            IWMPControls3 * This,
            /* [retval][out] */ long *plLangID);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_currentAudioLanguage )( 
            IWMPControls3 * This,
            /* [in] */ long lLangID);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_currentAudioLanguageIndex )( 
            IWMPControls3 * This,
            /* [retval][out] */ long *plIndex);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_currentAudioLanguageIndex )( 
            IWMPControls3 * This,
            /* [in] */ long lIndex);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *getLanguageName )( 
            IWMPControls3 * This,
            /* [in] */ long lLangID,
            /* [retval][out] */ BSTR *pbstrLangName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_currentPositionTimecode )( 
            IWMPControls3 * This,
            /* [retval][out] */ BSTR *bstrTimecode);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_currentPositionTimecode )( 
            IWMPControls3 * This,
            /* [in] */ BSTR bstrTimecode);
        
        END_INTERFACE
    } IWMPControls3Vtbl;

    interface IWMPControls3
    {
        CONST_VTBL struct IWMPControls3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPControls3_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMPControls3_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMPControls3_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMPControls3_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWMPControls3_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWMPControls3_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWMPControls3_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWMPControls3_get_isAvailable(This,bstrItem,pIsAvailable)	\
    ( (This)->lpVtbl -> get_isAvailable(This,bstrItem,pIsAvailable) ) 

#define IWMPControls3_play(This)	\
    ( (This)->lpVtbl -> play(This) ) 

#define IWMPControls3_stop(This)	\
    ( (This)->lpVtbl -> stop(This) ) 

#define IWMPControls3_pause(This)	\
    ( (This)->lpVtbl -> pause(This) ) 

#define IWMPControls3_fastForward(This)	\
    ( (This)->lpVtbl -> fastForward(This) ) 

#define IWMPControls3_fastReverse(This)	\
    ( (This)->lpVtbl -> fastReverse(This) ) 

#define IWMPControls3_get_currentPosition(This,pdCurrentPosition)	\
    ( (This)->lpVtbl -> get_currentPosition(This,pdCurrentPosition) ) 

#define IWMPControls3_put_currentPosition(This,dCurrentPosition)	\
    ( (This)->lpVtbl -> put_currentPosition(This,dCurrentPosition) ) 

#define IWMPControls3_get_currentPositionString(This,pbstrCurrentPosition)	\
    ( (This)->lpVtbl -> get_currentPositionString(This,pbstrCurrentPosition) ) 

#define IWMPControls3_next(This)	\
    ( (This)->lpVtbl -> next(This) ) 

#define IWMPControls3_previous(This)	\
    ( (This)->lpVtbl -> previous(This) ) 

#define IWMPControls3_get_currentItem(This,ppIWMPMedia)	\
    ( (This)->lpVtbl -> get_currentItem(This,ppIWMPMedia) ) 

#define IWMPControls3_put_currentItem(This,pIWMPMedia)	\
    ( (This)->lpVtbl -> put_currentItem(This,pIWMPMedia) ) 

#define IWMPControls3_get_currentMarker(This,plMarker)	\
    ( (This)->lpVtbl -> get_currentMarker(This,plMarker) ) 

#define IWMPControls3_put_currentMarker(This,lMarker)	\
    ( (This)->lpVtbl -> put_currentMarker(This,lMarker) ) 

#define IWMPControls3_playItem(This,pIWMPMedia)	\
    ( (This)->lpVtbl -> playItem(This,pIWMPMedia) ) 


#define IWMPControls3_step(This,lStep)	\
    ( (This)->lpVtbl -> step(This,lStep) ) 


#define IWMPControls3_get_audioLanguageCount(This,plCount)	\
    ( (This)->lpVtbl -> get_audioLanguageCount(This,plCount) ) 

#define IWMPControls3_getAudioLanguageID(This,lIndex,plLangID)	\
    ( (This)->lpVtbl -> getAudioLanguageID(This,lIndex,plLangID) ) 

#define IWMPControls3_getAudioLanguageDescription(This,lIndex,pbstrLangDesc)	\
    ( (This)->lpVtbl -> getAudioLanguageDescription(This,lIndex,pbstrLangDesc) ) 

#define IWMPControls3_get_currentAudioLanguage(This,plLangID)	\
    ( (This)->lpVtbl -> get_currentAudioLanguage(This,plLangID) ) 

#define IWMPControls3_put_currentAudioLanguage(This,lLangID)	\
    ( (This)->lpVtbl -> put_currentAudioLanguage(This,lLangID) ) 

#define IWMPControls3_get_currentAudioLanguageIndex(This,plIndex)	\
    ( (This)->lpVtbl -> get_currentAudioLanguageIndex(This,plIndex) ) 

#define IWMPControls3_put_currentAudioLanguageIndex(This,lIndex)	\
    ( (This)->lpVtbl -> put_currentAudioLanguageIndex(This,lIndex) ) 

#define IWMPControls3_getLanguageName(This,lLangID,pbstrLangName)	\
    ( (This)->lpVtbl -> getLanguageName(This,lLangID,pbstrLangName) ) 

#define IWMPControls3_get_currentPositionTimecode(This,bstrTimecode)	\
    ( (This)->lpVtbl -> get_currentPositionTimecode(This,bstrTimecode) ) 

#define IWMPControls3_put_currentPositionTimecode(This,bstrTimecode)	\
    ( (This)->lpVtbl -> put_currentPositionTimecode(This,bstrTimecode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMPControls3_INTERFACE_DEFINED__ */


#ifndef __IWMPSettings_INTERFACE_DEFINED__
#define __IWMPSettings_INTERFACE_DEFINED__

/* interface IWMPSettings */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPSettings;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9104D1AB-80C9-4fed-ABF0-2E6417A6DF14")
    IWMPSettings : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_isAvailable( 
            /* [in] */ BSTR bstrItem,
            /* [retval][out] */ VARIANT_BOOL *pIsAvailable) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_autoStart( 
            /* [retval][out] */ VARIANT_BOOL *pfAutoStart) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_autoStart( 
            /* [in] */ VARIANT_BOOL fAutoStart) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_baseURL( 
            /* [retval][out] */ BSTR *pbstrBaseURL) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_baseURL( 
            /* [in] */ BSTR bstrBaseURL) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_defaultFrame( 
            /* [retval][out] */ BSTR *pbstrDefaultFrame) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_defaultFrame( 
            /* [in] */ BSTR bstrDefaultFrame) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_invokeURLs( 
            /* [retval][out] */ VARIANT_BOOL *pfInvokeURLs) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_invokeURLs( 
            /* [in] */ VARIANT_BOOL fInvokeURLs) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_mute( 
            /* [retval][out] */ VARIANT_BOOL *pfMute) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_mute( 
            /* [in] */ VARIANT_BOOL fMute) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_playCount( 
            /* [retval][out] */ long *plCount) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_playCount( 
            /* [in] */ long lCount) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_rate( 
            /* [retval][out] */ double *pdRate) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_rate( 
            /* [in] */ double dRate) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_balance( 
            /* [retval][out] */ long *plBalance) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_balance( 
            /* [in] */ long lBalance) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_volume( 
            /* [retval][out] */ long *plVolume) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_volume( 
            /* [in] */ long lVolume) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getMode( 
            /* [in] */ BSTR bstrMode,
            /* [retval][out] */ VARIANT_BOOL *pvarfMode) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE setMode( 
            /* [in] */ BSTR bstrMode,
            /* [in] */ VARIANT_BOOL varfMode) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_enableErrorDialogs( 
            /* [retval][out] */ VARIANT_BOOL *pfEnableErrorDialogs) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_enableErrorDialogs( 
            /* [in] */ VARIANT_BOOL fEnableErrorDialogs) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPSettingsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMPSettings * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMPSettings * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMPSettings * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMPSettings * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMPSettings * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMPSettings * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMPSettings * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_isAvailable )( 
            IWMPSettings * This,
            /* [in] */ BSTR bstrItem,
            /* [retval][out] */ VARIANT_BOOL *pIsAvailable);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_autoStart )( 
            IWMPSettings * This,
            /* [retval][out] */ VARIANT_BOOL *pfAutoStart);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_autoStart )( 
            IWMPSettings * This,
            /* [in] */ VARIANT_BOOL fAutoStart);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_baseURL )( 
            IWMPSettings * This,
            /* [retval][out] */ BSTR *pbstrBaseURL);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_baseURL )( 
            IWMPSettings * This,
            /* [in] */ BSTR bstrBaseURL);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_defaultFrame )( 
            IWMPSettings * This,
            /* [retval][out] */ BSTR *pbstrDefaultFrame);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_defaultFrame )( 
            IWMPSettings * This,
            /* [in] */ BSTR bstrDefaultFrame);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_invokeURLs )( 
            IWMPSettings * This,
            /* [retval][out] */ VARIANT_BOOL *pfInvokeURLs);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_invokeURLs )( 
            IWMPSettings * This,
            /* [in] */ VARIANT_BOOL fInvokeURLs);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_mute )( 
            IWMPSettings * This,
            /* [retval][out] */ VARIANT_BOOL *pfMute);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_mute )( 
            IWMPSettings * This,
            /* [in] */ VARIANT_BOOL fMute);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_playCount )( 
            IWMPSettings * This,
            /* [retval][out] */ long *plCount);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_playCount )( 
            IWMPSettings * This,
            /* [in] */ long lCount);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_rate )( 
            IWMPSettings * This,
            /* [retval][out] */ double *pdRate);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_rate )( 
            IWMPSettings * This,
            /* [in] */ double dRate);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_balance )( 
            IWMPSettings * This,
            /* [retval][out] */ long *plBalance);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_balance )( 
            IWMPSettings * This,
            /* [in] */ long lBalance);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_volume )( 
            IWMPSettings * This,
            /* [retval][out] */ long *plVolume);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_volume )( 
            IWMPSettings * This,
            /* [in] */ long lVolume);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *getMode )( 
            IWMPSettings * This,
            /* [in] */ BSTR bstrMode,
            /* [retval][out] */ VARIANT_BOOL *pvarfMode);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *setMode )( 
            IWMPSettings * This,
            /* [in] */ BSTR bstrMode,
            /* [in] */ VARIANT_BOOL varfMode);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_enableErrorDialogs )( 
            IWMPSettings * This,
            /* [retval][out] */ VARIANT_BOOL *pfEnableErrorDialogs);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_enableErrorDialogs )( 
            IWMPSettings * This,
            /* [in] */ VARIANT_BOOL fEnableErrorDialogs);
        
        END_INTERFACE
    } IWMPSettingsVtbl;

    interface IWMPSettings
    {
        CONST_VTBL struct IWMPSettingsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPSettings_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMPSettings_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMPSettings_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMPSettings_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWMPSettings_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWMPSettings_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWMPSettings_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWMPSettings_get_isAvailable(This,bstrItem,pIsAvailable)	\
    ( (This)->lpVtbl -> get_isAvailable(This,bstrItem,pIsAvailable) ) 

#define IWMPSettings_get_autoStart(This,pfAutoStart)	\
    ( (This)->lpVtbl -> get_autoStart(This,pfAutoStart) ) 

#define IWMPSettings_put_autoStart(This,fAutoStart)	\
    ( (This)->lpVtbl -> put_autoStart(This,fAutoStart) ) 

#define IWMPSettings_get_baseURL(This,pbstrBaseURL)	\
    ( (This)->lpVtbl -> get_baseURL(This,pbstrBaseURL) ) 

#define IWMPSettings_put_baseURL(This,bstrBaseURL)	\
    ( (This)->lpVtbl -> put_baseURL(This,bstrBaseURL) ) 

#define IWMPSettings_get_defaultFrame(This,pbstrDefaultFrame)	\
    ( (This)->lpVtbl -> get_defaultFrame(This,pbstrDefaultFrame) ) 

#define IWMPSettings_put_defaultFrame(This,bstrDefaultFrame)	\
    ( (This)->lpVtbl -> put_defaultFrame(This,bstrDefaultFrame) ) 

#define IWMPSettings_get_invokeURLs(This,pfInvokeURLs)	\
    ( (This)->lpVtbl -> get_invokeURLs(This,pfInvokeURLs) ) 

#define IWMPSettings_put_invokeURLs(This,fInvokeURLs)	\
    ( (This)->lpVtbl -> put_invokeURLs(This,fInvokeURLs) ) 

#define IWMPSettings_get_mute(This,pfMute)	\
    ( (This)->lpVtbl -> get_mute(This,pfMute) ) 

#define IWMPSettings_put_mute(This,fMute)	\
    ( (This)->lpVtbl -> put_mute(This,fMute) ) 

#define IWMPSettings_get_playCount(This,plCount)	\
    ( (This)->lpVtbl -> get_playCount(This,plCount) ) 

#define IWMPSettings_put_playCount(This,lCount)	\
    ( (This)->lpVtbl -> put_playCount(This,lCount) ) 

#define IWMPSettings_get_rate(This,pdRate)	\
    ( (This)->lpVtbl -> get_rate(This,pdRate) ) 

#define IWMPSettings_put_rate(This,dRate)	\
    ( (This)->lpVtbl -> put_rate(This,dRate) ) 

#define IWMPSettings_get_balance(This,plBalance)	\
    ( (This)->lpVtbl -> get_balance(This,plBalance) ) 

#define IWMPSettings_put_balance(This,lBalance)	\
    ( (This)->lpVtbl -> put_balance(This,lBalance) ) 

#define IWMPSettings_get_volume(This,plVolume)	\
    ( (This)->lpVtbl -> get_volume(This,plVolume) ) 

#define IWMPSettings_put_volume(This,lVolume)	\
    ( (This)->lpVtbl -> put_volume(This,lVolume) ) 

#define IWMPSettings_getMode(This,bstrMode,pvarfMode)	\
    ( (This)->lpVtbl -> getMode(This,bstrMode,pvarfMode) ) 

#define IWMPSettings_setMode(This,bstrMode,varfMode)	\
    ( (This)->lpVtbl -> setMode(This,bstrMode,varfMode) ) 

#define IWMPSettings_get_enableErrorDialogs(This,pfEnableErrorDialogs)	\
    ( (This)->lpVtbl -> get_enableErrorDialogs(This,pfEnableErrorDialogs) ) 

#define IWMPSettings_put_enableErrorDialogs(This,fEnableErrorDialogs)	\
    ( (This)->lpVtbl -> put_enableErrorDialogs(This,fEnableErrorDialogs) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMPSettings_INTERFACE_DEFINED__ */


#ifndef __IWMPNetwork_INTERFACE_DEFINED__
#define __IWMPNetwork_INTERFACE_DEFINED__

/* interface IWMPNetwork */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPNetwork;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EC21B779-EDEF-462d-BBA4-AD9DDE2B29A7")
    IWMPNetwork : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_bandWidth( 
            /* [retval][out] */ long *plBandwidth) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_recoveredPackets( 
            /* [retval][out] */ long *plRecoveredPackets) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_sourceProtocol( 
            /* [retval][out] */ BSTR *pbstrSourceProtocol) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_receivedPackets( 
            /* [retval][out] */ long *plReceivedPackets) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_lostPackets( 
            /* [retval][out] */ long *plLostPackets) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_receptionQuality( 
            /* [retval][out] */ long *plReceptionQuality) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_bufferingCount( 
            /* [retval][out] */ long *plBufferingCount) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_bufferingProgress( 
            /* [retval][out] */ long *plBufferingProgress) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_bufferingTime( 
            /* [retval][out] */ long *plBufferingTime) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_bufferingTime( 
            /* [in] */ long lBufferingTime) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_frameRate( 
            /* [retval][out] */ long *plFrameRate) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_maxBitRate( 
            /* [retval][out] */ long *plBitRate) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_bitRate( 
            /* [retval][out] */ long *plBitRate) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getProxySettings( 
            /* [in] */ BSTR bstrProtocol,
            /* [retval][out] */ long *plProxySetting) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE setProxySettings( 
            /* [in] */ BSTR bstrProtocol,
            /* [in] */ long lProxySetting) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getProxyName( 
            /* [in] */ BSTR bstrProtocol,
            /* [retval][out] */ BSTR *pbstrProxyName) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE setProxyName( 
            /* [in] */ BSTR bstrProtocol,
            /* [in] */ BSTR bstrProxyName) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getProxyPort( 
            /* [in] */ BSTR bstrProtocol,
            /* [retval][out] */ long *lProxyPort) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE setProxyPort( 
            /* [in] */ BSTR bstrProtocol,
            /* [in] */ long lProxyPort) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getProxyExceptionList( 
            /* [in] */ BSTR bstrProtocol,
            /* [retval][out] */ BSTR *pbstrExceptionList) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE setProxyExceptionList( 
            /* [in] */ BSTR bstrProtocol,
            /* [in] */ BSTR pbstrExceptionList) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getProxyBypassForLocal( 
            /* [in] */ BSTR bstrProtocol,
            /* [retval][out] */ VARIANT_BOOL *pfBypassForLocal) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE setProxyBypassForLocal( 
            /* [in] */ BSTR bstrProtocol,
            /* [in] */ VARIANT_BOOL fBypassForLocal) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_maxBandwidth( 
            /* [retval][out] */ long *lMaxBandwidth) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_maxBandwidth( 
            /* [in] */ long lMaxBandwidth) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_downloadProgress( 
            /* [retval][out] */ long *plDownloadProgress) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_encodedFrameRate( 
            /* [retval][out] */ long *plFrameRate) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_framesSkipped( 
            /* [retval][out] */ long *plFrames) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPNetworkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMPNetwork * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMPNetwork * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMPNetwork * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMPNetwork * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMPNetwork * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMPNetwork * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMPNetwork * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_bandWidth )( 
            IWMPNetwork * This,
            /* [retval][out] */ long *plBandwidth);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_recoveredPackets )( 
            IWMPNetwork * This,
            /* [retval][out] */ long *plRecoveredPackets);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_sourceProtocol )( 
            IWMPNetwork * This,
            /* [retval][out] */ BSTR *pbstrSourceProtocol);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_receivedPackets )( 
            IWMPNetwork * This,
            /* [retval][out] */ long *plReceivedPackets);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_lostPackets )( 
            IWMPNetwork * This,
            /* [retval][out] */ long *plLostPackets);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_receptionQuality )( 
            IWMPNetwork * This,
            /* [retval][out] */ long *plReceptionQuality);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_bufferingCount )( 
            IWMPNetwork * This,
            /* [retval][out] */ long *plBufferingCount);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_bufferingProgress )( 
            IWMPNetwork * This,
            /* [retval][out] */ long *plBufferingProgress);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_bufferingTime )( 
            IWMPNetwork * This,
            /* [retval][out] */ long *plBufferingTime);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_bufferingTime )( 
            IWMPNetwork * This,
            /* [in] */ long lBufferingTime);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_frameRate )( 
            IWMPNetwork * This,
            /* [retval][out] */ long *plFrameRate);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_maxBitRate )( 
            IWMPNetwork * This,
            /* [retval][out] */ long *plBitRate);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_bitRate )( 
            IWMPNetwork * This,
            /* [retval][out] */ long *plBitRate);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *getProxySettings )( 
            IWMPNetwork * This,
            /* [in] */ BSTR bstrProtocol,
            /* [retval][out] */ long *plProxySetting);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *setProxySettings )( 
            IWMPNetwork * This,
            /* [in] */ BSTR bstrProtocol,
            /* [in] */ long lProxySetting);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *getProxyName )( 
            IWMPNetwork * This,
            /* [in] */ BSTR bstrProtocol,
            /* [retval][out] */ BSTR *pbstrProxyName);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *setProxyName )( 
            IWMPNetwork * This,
            /* [in] */ BSTR bstrProtocol,
            /* [in] */ BSTR bstrProxyName);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *getProxyPort )( 
            IWMPNetwork * This,
            /* [in] */ BSTR bstrProtocol,
            /* [retval][out] */ long *lProxyPort);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *setProxyPort )( 
            IWMPNetwork * This,
            /* [in] */ BSTR bstrProtocol,
            /* [in] */ long lProxyPort);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *getProxyExceptionList )( 
            IWMPNetwork * This,
            /* [in] */ BSTR bstrProtocol,
            /* [retval][out] */ BSTR *pbstrExceptionList);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *setProxyExceptionList )( 
            IWMPNetwork * This,
            /* [in] */ BSTR bstrProtocol,
            /* [in] */ BSTR pbstrExceptionList);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *getProxyBypassForLocal )( 
            IWMPNetwork * This,
            /* [in] */ BSTR bstrProtocol,
            /* [retval][out] */ VARIANT_BOOL *pfBypassForLocal);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *setProxyBypassForLocal )( 
            IWMPNetwork * This,
            /* [in] */ BSTR bstrProtocol,
            /* [in] */ VARIANT_BOOL fBypassForLocal);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_maxBandwidth )( 
            IWMPNetwork * This,
            /* [retval][out] */ long *lMaxBandwidth);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_maxBandwidth )( 
            IWMPNetwork * This,
            /* [in] */ long lMaxBandwidth);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_downloadProgress )( 
            IWMPNetwork * This,
            /* [retval][out] */ long *plDownloadProgress);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_encodedFrameRate )( 
            IWMPNetwork * This,
            /* [retval][out] */ long *plFrameRate);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_framesSkipped )( 
            IWMPNetwork * This,
            /* [retval][out] */ long *plFrames);
        
        END_INTERFACE
    } IWMPNetworkVtbl;

    interface IWMPNetwork
    {
        CONST_VTBL struct IWMPNetworkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPNetwork_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMPNetwork_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMPNetwork_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMPNetwork_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWMPNetwork_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWMPNetwork_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWMPNetwork_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWMPNetwork_get_bandWidth(This,plBandwidth)	\
    ( (This)->lpVtbl -> get_bandWidth(This,plBandwidth) ) 

#define IWMPNetwork_get_recoveredPackets(This,plRecoveredPackets)	\
    ( (This)->lpVtbl -> get_recoveredPackets(This,plRecoveredPackets) ) 

#define IWMPNetwork_get_sourceProtocol(This,pbstrSourceProtocol)	\
    ( (This)->lpVtbl -> get_sourceProtocol(This,pbstrSourceProtocol) ) 

#define IWMPNetwork_get_receivedPackets(This,plReceivedPackets)	\
    ( (This)->lpVtbl -> get_receivedPackets(This,plReceivedPackets) ) 

#define IWMPNetwork_get_lostPackets(This,plLostPackets)	\
    ( (This)->lpVtbl -> get_lostPackets(This,plLostPackets) ) 

#define IWMPNetwork_get_receptionQuality(This,plReceptionQuality)	\
    ( (This)->lpVtbl -> get_receptionQuality(This,plReceptionQuality) ) 

#define IWMPNetwork_get_bufferingCount(This,plBufferingCount)	\
    ( (This)->lpVtbl -> get_bufferingCount(This,plBufferingCount) ) 

#define IWMPNetwork_get_bufferingProgress(This,plBufferingProgress)	\
    ( (This)->lpVtbl -> get_bufferingProgress(This,plBufferingProgress) ) 

#define IWMPNetwork_get_bufferingTime(This,plBufferingTime)	\
    ( (This)->lpVtbl -> get_bufferingTime(This,plBufferingTime) ) 

#define IWMPNetwork_put_bufferingTime(This,lBufferingTime)	\
    ( (This)->lpVtbl -> put_bufferingTime(This,lBufferingTime) ) 

#define IWMPNetwork_get_frameRate(This,plFrameRate)	\
    ( (This)->lpVtbl -> get_frameRate(This,plFrameRate) ) 

#define IWMPNetwork_get_maxBitRate(This,plBitRate)	\
    ( (This)->lpVtbl -> get_maxBitRate(This,plBitRate) ) 

#define IWMPNetwork_get_bitRate(This,plBitRate)	\
    ( (This)->lpVtbl -> get_bitRate(This,plBitRate) ) 

#define IWMPNetwork_getProxySettings(This,bstrProtocol,plProxySetting)	\
    ( (This)->lpVtbl -> getProxySettings(This,bstrProtocol,plProxySetting) ) 

#define IWMPNetwork_setProxySettings(This,bstrProtocol,lProxySetting)	\
    ( (This)->lpVtbl -> setProxySettings(This,bstrProtocol,lProxySetting) ) 

#define IWMPNetwork_getProxyName(This,bstrProtocol,pbstrProxyName)	\
    ( (This)->lpVtbl -> getProxyName(This,bstrProtocol,pbstrProxyName) ) 

#define IWMPNetwork_setProxyName(This,bstrProtocol,bstrProxyName)	\
    ( (This)->lpVtbl -> setProxyName(This,bstrProtocol,bstrProxyName) ) 

#define IWMPNetwork_getProxyPort(This,bstrProtocol,lProxyPort)	\
    ( (This)->lpVtbl -> getProxyPort(This,bstrProtocol,lProxyPort) ) 

#define IWMPNetwork_setProxyPort(This,bstrProtocol,lProxyPort)	\
    ( (This)->lpVtbl -> setProxyPort(This,bstrProtocol,lProxyPort) ) 

#define IWMPNetwork_getProxyExceptionList(This,bstrProtocol,pbstrExceptionList)	\
    ( (This)->lpVtbl -> getProxyExceptionList(This,bstrProtocol,pbstrExceptionList) ) 

#define IWMPNetwork_setProxyExceptionList(This,bstrProtocol,pbstrExceptionList)	\
    ( (This)->lpVtbl -> setProxyExceptionList(This,bstrProtocol,pbstrExceptionList) ) 

#define IWMPNetwork_getProxyBypassForLocal(This,bstrProtocol,pfBypassForLocal)	\
    ( (This)->lpVtbl -> getProxyBypassForLocal(This,bstrProtocol,pfBypassForLocal) ) 

#define IWMPNetwork_setProxyBypassForLocal(This,bstrProtocol,fBypassForLocal)	\
    ( (This)->lpVtbl -> setProxyBypassForLocal(This,bstrProtocol,fBypassForLocal) ) 

#define IWMPNetwork_get_maxBandwidth(This,lMaxBandwidth)	\
    ( (This)->lpVtbl -> get_maxBandwidth(This,lMaxBandwidth) ) 

#define IWMPNetwork_put_maxBandwidth(This,lMaxBandwidth)	\
    ( (This)->lpVtbl -> put_maxBandwidth(This,lMaxBandwidth) ) 

#define IWMPNetwork_get_downloadProgress(This,plDownloadProgress)	\
    ( (This)->lpVtbl -> get_downloadProgress(This,plDownloadProgress) ) 

#define IWMPNetwork_get_encodedFrameRate(This,plFrameRate)	\
    ( (This)->lpVtbl -> get_encodedFrameRate(This,plFrameRate) ) 

#define IWMPNetwork_get_framesSkipped(This,plFrames)	\
    ( (This)->lpVtbl -> get_framesSkipped(This,plFrames) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMPNetwork_INTERFACE_DEFINED__ */


#ifndef __IWMPMedia_INTERFACE_DEFINED__
#define __IWMPMedia_INTERFACE_DEFINED__

/* interface IWMPMedia */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPMedia;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("94D55E95-3FAC-11d3-B155-00C04F79FAA6")
    IWMPMedia : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_isIdentical( 
            /* [in] */ IWMPMedia *pIWMPMedia,
            /* [retval][out] */ VARIANT_BOOL *pvbool) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_sourceURL( 
            /* [retval][out] */ BSTR *pbstrSourceURL) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_name( 
            /* [retval][out] */ BSTR *pbstrName) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_name( 
            /* [in] */ BSTR bstrName) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_imageSourceWidth( 
            /* [retval][out] */ long *pWidth) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_imageSourceHeight( 
            /* [retval][out] */ long *pHeight) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_markerCount( 
            /* [retval][out] */ long *pMarkerCount) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getMarkerTime( 
            /* [in] */ long MarkerNum,
            /* [retval][out] */ double *pMarkerTime) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getMarkerName( 
            /* [in] */ long MarkerNum,
            /* [retval][out] */ BSTR *pbstrMarkerName) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_duration( 
            /* [retval][out] */ double *pDuration) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_durationString( 
            /* [retval][out] */ BSTR *pbstrDuration) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_attributeCount( 
            /* [retval][out] */ long *plCount) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getAttributeName( 
            /* [in] */ long lIndex,
            /* [retval][out] */ BSTR *pbstrItemName) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getItemInfo( 
            /* [in] */ BSTR bstrItemName,
            /* [retval][out] */ BSTR *pbstrVal) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE setItemInfo( 
            /* [in] */ BSTR bstrItemName,
            /* [in] */ BSTR bstrVal) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getItemInfoByAtom( 
            /* [in] */ long lAtom,
            /* [retval][out] */ BSTR *pbstrVal) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE isMemberOf( 
            /* [in] */ IWMPPlaylist *pPlaylist,
            /* [retval][out] */ VARIANT_BOOL *pvarfIsMemberOf) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE isReadOnlyItem( 
            /* [in] */ BSTR bstrItemName,
            /* [retval][out] */ VARIANT_BOOL *pvarfIsReadOnly) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPMediaVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMPMedia * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMPMedia * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMPMedia * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMPMedia * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMPMedia * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMPMedia * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMPMedia * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_isIdentical )( 
            IWMPMedia * This,
            /* [in] */ IWMPMedia *pIWMPMedia,
            /* [retval][out] */ VARIANT_BOOL *pvbool);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_sourceURL )( 
            IWMPMedia * This,
            /* [retval][out] */ BSTR *pbstrSourceURL);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_name )( 
            IWMPMedia * This,
            /* [retval][out] */ BSTR *pbstrName);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_name )( 
            IWMPMedia * This,
            /* [in] */ BSTR bstrName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_imageSourceWidth )( 
            IWMPMedia * This,
            /* [retval][out] */ long *pWidth);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_imageSourceHeight )( 
            IWMPMedia * This,
            /* [retval][out] */ long *pHeight);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_markerCount )( 
            IWMPMedia * This,
            /* [retval][out] */ long *pMarkerCount);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *getMarkerTime )( 
            IWMPMedia * This,
            /* [in] */ long MarkerNum,
            /* [retval][out] */ double *pMarkerTime);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *getMarkerName )( 
            IWMPMedia * This,
            /* [in] */ long MarkerNum,
            /* [retval][out] */ BSTR *pbstrMarkerName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_duration )( 
            IWMPMedia * This,
            /* [retval][out] */ double *pDuration);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_durationString )( 
            IWMPMedia * This,
            /* [retval][out] */ BSTR *pbstrDuration);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_attributeCount )( 
            IWMPMedia * This,
            /* [retval][out] */ long *plCount);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *getAttributeName )( 
            IWMPMedia * This,
            /* [in] */ long lIndex,
            /* [retval][out] */ BSTR *pbstrItemName);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *getItemInfo )( 
            IWMPMedia * This,
            /* [in] */ BSTR bstrItemName,
            /* [retval][out] */ BSTR *pbstrVal);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *setItemInfo )( 
            IWMPMedia * This,
            /* [in] */ BSTR bstrItemName,
            /* [in] */ BSTR bstrVal);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *getItemInfoByAtom )( 
            IWMPMedia * This,
            /* [in] */ long lAtom,
            /* [retval][out] */ BSTR *pbstrVal);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *isMemberOf )( 
            IWMPMedia * This,
            /* [in] */ IWMPPlaylist *pPlaylist,
            /* [retval][out] */ VARIANT_BOOL *pvarfIsMemberOf);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *isReadOnlyItem )( 
            IWMPMedia * This,
            /* [in] */ BSTR bstrItemName,
            /* [retval][out] */ VARIANT_BOOL *pvarfIsReadOnly);
        
        END_INTERFACE
    } IWMPMediaVtbl;

    interface IWMPMedia
    {
        CONST_VTBL struct IWMPMediaVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPMedia_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMPMedia_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMPMedia_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMPMedia_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWMPMedia_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWMPMedia_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWMPMedia_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWMPMedia_get_isIdentical(This,pIWMPMedia,pvbool)	\
    ( (This)->lpVtbl -> get_isIdentical(This,pIWMPMedia,pvbool) ) 

#define IWMPMedia_get_sourceURL(This,pbstrSourceURL)	\
    ( (This)->lpVtbl -> get_sourceURL(This,pbstrSourceURL) ) 

#define IWMPMedia_get_name(This,pbstrName)	\
    ( (This)->lpVtbl -> get_name(This,pbstrName) ) 

#define IWMPMedia_put_name(This,bstrName)	\
    ( (This)->lpVtbl -> put_name(This,bstrName) ) 

#define IWMPMedia_get_imageSourceWidth(This,pWidth)	\
    ( (This)->lpVtbl -> get_imageSourceWidth(This,pWidth) ) 

#define IWMPMedia_get_imageSourceHeight(This,pHeight)	\
    ( (This)->lpVtbl -> get_imageSourceHeight(This,pHeight) ) 

#define IWMPMedia_get_markerCount(This,pMarkerCount)	\
    ( (This)->lpVtbl -> get_markerCount(This,pMarkerCount) ) 

#define IWMPMedia_getMarkerTime(This,MarkerNum,pMarkerTime)	\
    ( (This)->lpVtbl -> getMarkerTime(This,MarkerNum,pMarkerTime) ) 

#define IWMPMedia_getMarkerName(This,MarkerNum,pbstrMarkerName)	\
    ( (This)->lpVtbl -> getMarkerName(This,MarkerNum,pbstrMarkerName) ) 

#define IWMPMedia_get_duration(This,pDuration)	\
    ( (This)->lpVtbl -> get_duration(This,pDuration) ) 

#define IWMPMedia_get_durationString(This,pbstrDuration)	\
    ( (This)->lpVtbl -> get_durationString(This,pbstrDuration) ) 

#define IWMPMedia_get_attributeCount(This,plCount)	\
    ( (This)->lpVtbl -> get_attributeCount(This,plCount) ) 

#define IWMPMedia_getAttributeName(This,lIndex,pbstrItemName)	\
    ( (This)->lpVtbl -> getAttributeName(This,lIndex,pbstrItemName) ) 

#define IWMPMedia_getItemInfo(This,bstrItemName,pbstrVal)	\
    ( (This)->lpVtbl -> getItemInfo(This,bstrItemName,pbstrVal) ) 

#define IWMPMedia_setItemInfo(This,bstrItemName,bstrVal)	\
    ( (This)->lpVtbl -> setItemInfo(This,bstrItemName,bstrVal) ) 

#define IWMPMedia_getItemInfoByAtom(This,lAtom,pbstrVal)	\
    ( (This)->lpVtbl -> getItemInfoByAtom(This,lAtom,pbstrVal) ) 

#define IWMPMedia_isMemberOf(This,pPlaylist,pvarfIsMemberOf)	\
    ( (This)->lpVtbl -> isMemberOf(This,pPlaylist,pvarfIsMemberOf) ) 

#define IWMPMedia_isReadOnlyItem(This,bstrItemName,pvarfIsReadOnly)	\
    ( (This)->lpVtbl -> isReadOnlyItem(This,bstrItemName,pvarfIsReadOnly) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMPMedia_INTERFACE_DEFINED__ */


#ifndef __IWMPMedia2_INTERFACE_DEFINED__
#define __IWMPMedia2_INTERFACE_DEFINED__

/* interface IWMPMedia2 */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPMedia2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AB7C88BB-143E-4ea4-ACC3-E4350B2106C3")
    IWMPMedia2 : public IWMPMedia
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_error( 
            /* [out] */ IWMPErrorItem **pIWMPErrorItem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPMedia2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMPMedia2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMPMedia2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMPMedia2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMPMedia2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMPMedia2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMPMedia2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMPMedia2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_isIdentical )( 
            IWMPMedia2 * This,
            /* [in] */ IWMPMedia *pIWMPMedia,
            /* [retval][out] */ VARIANT_BOOL *pvbool);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_sourceURL )( 
            IWMPMedia2 * This,
            /* [retval][out] */ BSTR *pbstrSourceURL);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_name )( 
            IWMPMedia2 * This,
            /* [retval][out] */ BSTR *pbstrName);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_name )( 
            IWMPMedia2 * This,
            /* [in] */ BSTR bstrName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_imageSourceWidth )( 
            IWMPMedia2 * This,
            /* [retval][out] */ long *pWidth);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_imageSourceHeight )( 
            IWMPMedia2 * This,
            /* [retval][out] */ long *pHeight);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_markerCount )( 
            IWMPMedia2 * This,
            /* [retval][out] */ long *pMarkerCount);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *getMarkerTime )( 
            IWMPMedia2 * This,
            /* [in] */ long MarkerNum,
            /* [retval][out] */ double *pMarkerTime);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *getMarkerName )( 
            IWMPMedia2 * This,
            /* [in] */ long MarkerNum,
            /* [retval][out] */ BSTR *pbstrMarkerName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_duration )( 
            IWMPMedia2 * This,
            /* [retval][out] */ double *pDuration);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_durationString )( 
            IWMPMedia2 * This,
            /* [retval][out] */ BSTR *pbstrDuration);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_attributeCount )( 
            IWMPMedia2 * This,
            /* [retval][out] */ long *plCount);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *getAttributeName )( 
            IWMPMedia2 * This,
            /* [in] */ long lIndex,
            /* [retval][out] */ BSTR *pbstrItemName);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *getItemInfo )( 
            IWMPMedia2 * This,
            /* [in] */ BSTR bstrItemName,
            /* [retval][out] */ BSTR *pbstrVal);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *setItemInfo )( 
            IWMPMedia2 * This,
            /* [in] */ BSTR bstrItemName,
            /* [in] */ BSTR bstrVal);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *getItemInfoByAtom )( 
            IWMPMedia2 * This,
            /* [in] */ long lAtom,
            /* [retval][out] */ BSTR *pbstrVal);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *isMemberOf )( 
            IWMPMedia2 * This,
            /* [in] */ IWMPPlaylist *pPlaylist,
            /* [retval][out] */ VARIANT_BOOL *pvarfIsMemberOf);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *isReadOnlyItem )( 
            IWMPMedia2 * This,
            /* [in] */ BSTR bstrItemName,
            /* [retval][out] */ VARIANT_BOOL *pvarfIsReadOnly);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_error )( 
            IWMPMedia2 * This,
            /* [out] */ IWMPErrorItem **pIWMPErrorItem);
        
        END_INTERFACE
    } IWMPMedia2Vtbl;

    interface IWMPMedia2
    {
        CONST_VTBL struct IWMPMedia2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPMedia2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMPMedia2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMPMedia2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMPMedia2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWMPMedia2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWMPMedia2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWMPMedia2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWMPMedia2_get_isIdentical(This,pIWMPMedia,pvbool)	\
    ( (This)->lpVtbl -> get_isIdentical(This,pIWMPMedia,pvbool) ) 

#define IWMPMedia2_get_sourceURL(This,pbstrSourceURL)	\
    ( (This)->lpVtbl -> get_sourceURL(This,pbstrSourceURL) ) 

#define IWMPMedia2_get_name(This,pbstrName)	\
    ( (This)->lpVtbl -> get_name(This,pbstrName) ) 

#define IWMPMedia2_put_name(This,bstrName)	\
    ( (This)->lpVtbl -> put_name(This,bstrName) ) 

#define IWMPMedia2_get_imageSourceWidth(This,pWidth)	\
    ( (This)->lpVtbl -> get_imageSourceWidth(This,pWidth) ) 

#define IWMPMedia2_get_imageSourceHeight(This,pHeight)	\
    ( (This)->lpVtbl -> get_imageSourceHeight(This,pHeight) ) 

#define IWMPMedia2_get_markerCount(This,pMarkerCount)	\
    ( (This)->lpVtbl -> get_markerCount(This,pMarkerCount) ) 

#define IWMPMedia2_getMarkerTime(This,MarkerNum,pMarkerTime)	\
    ( (This)->lpVtbl -> getMarkerTime(This,MarkerNum,pMarkerTime) ) 

#define IWMPMedia2_getMarkerName(This,MarkerNum,pbstrMarkerName)	\
    ( (This)->lpVtbl -> getMarkerName(This,MarkerNum,pbstrMarkerName) ) 

#define IWMPMedia2_get_duration(This,pDuration)	\
    ( (This)->lpVtbl -> get_duration(This,pDuration) ) 

#define IWMPMedia2_get_durationString(This,pbstrDuration)	\
    ( (This)->lpVtbl -> get_durationString(This,pbstrDuration) ) 

#define IWMPMedia2_get_attributeCount(This,plCount)	\
    ( (This)->lpVtbl -> get_attributeCount(This,plCount) ) 

#define IWMPMedia2_getAttributeName(This,lIndex,pbstrItemName)	\
    ( (This)->lpVtbl -> getAttributeName(This,lIndex,pbstrItemName) ) 

#define IWMPMedia2_getItemInfo(This,bstrItemName,pbstrVal)	\
    ( (This)->lpVtbl -> getItemInfo(This,bstrItemName,pbstrVal) ) 

#define IWMPMedia2_setItemInfo(This,bstrItemName,bstrVal)	\
    ( (This)->lpVtbl -> setItemInfo(This,bstrItemName,bstrVal) ) 

#define IWMPMedia2_getItemInfoByAtom(This,lAtom,pbstrVal)	\
    ( (This)->lpVtbl -> getItemInfoByAtom(This,lAtom,pbstrVal) ) 

#define IWMPMedia2_isMemberOf(This,pPlaylist,pvarfIsMemberOf)	\
    ( (This)->lpVtbl -> isMemberOf(This,pPlaylist,pvarfIsMemberOf) ) 

#define IWMPMedia2_isReadOnlyItem(This,bstrItemName,pvarfIsReadOnly)	\
    ( (This)->lpVtbl -> isReadOnlyItem(This,bstrItemName,pvarfIsReadOnly) ) 


#define IWMPMedia2_get_error(This,pIWMPErrorItem)	\
    ( (This)->lpVtbl -> get_error(This,pIWMPErrorItem) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMPMedia2_INTERFACE_DEFINED__ */


#ifndef __IWMPPlaylist_INTERFACE_DEFINED__
#define __IWMPPlaylist_INTERFACE_DEFINED__

/* interface IWMPPlaylist */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPPlaylist;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D5F0F4F1-130C-11d3-B14E-00C04F79FAA6")
    IWMPPlaylist : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_count( 
            /* [retval][out] */ long *plCount) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_name( 
            /* [retval][out] */ BSTR *pbstrName) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_name( 
            /* [in] */ BSTR bstrName) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_attributeCount( 
            /* [retval][out] */ long *plCount) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_attributeName( 
            /* [in] */ long lIndex,
            /* [retval][out] */ BSTR *pbstrAttributeName) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_item( 
            long lIndex,
            /* [retval][out] */ IWMPMedia **ppIWMPMedia) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getItemInfo( 
            BSTR bstrName,
            /* [retval][out] */ BSTR *pbstrVal) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE setItemInfo( 
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrValue) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_isIdentical( 
            /* [in] */ IWMPPlaylist *pIWMPPlaylist,
            /* [retval][out] */ VARIANT_BOOL *pvbool) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE clear( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE insertItem( 
            /* [in] */ long lIndex,
            /* [in] */ IWMPMedia *pIWMPMedia) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE appendItem( 
            /* [in] */ IWMPMedia *pIWMPMedia) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE removeItem( 
            /* [in] */ IWMPMedia *pIWMPMedia) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE moveItem( 
            long lIndexOld,
            long lIndexNew) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPPlaylistVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMPPlaylist * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMPPlaylist * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMPPlaylist * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMPPlaylist * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMPPlaylist * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMPPlaylist * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMPPlaylist * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_count )( 
            IWMPPlaylist * This,
            /* [retval][out] */ long *plCount);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_name )( 
            IWMPPlaylist * This,
            /* [retval][out] */ BSTR *pbstrName);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_name )( 
            IWMPPlaylist * This,
            /* [in] */ BSTR bstrName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_attributeCount )( 
            IWMPPlaylist * This,
            /* [retval][out] */ long *plCount);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_attributeName )( 
            IWMPPlaylist * This,
            /* [in] */ long lIndex,
            /* [retval][out] */ BSTR *pbstrAttributeName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_item )( 
            IWMPPlaylist * This,
            long lIndex,
            /* [retval][out] */ IWMPMedia **ppIWMPMedia);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *getItemInfo )( 
            IWMPPlaylist * This,
            BSTR bstrName,
            /* [retval][out] */ BSTR *pbstrVal);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *setItemInfo )( 
            IWMPPlaylist * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrValue);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_isIdentical )( 
            IWMPPlaylist * This,
            /* [in] */ IWMPPlaylist *pIWMPPlaylist,
            /* [retval][out] */ VARIANT_BOOL *pvbool);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *clear )( 
            IWMPPlaylist * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *insertItem )( 
            IWMPPlaylist * This,
            /* [in] */ long lIndex,
            /* [in] */ IWMPMedia *pIWMPMedia);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *appendItem )( 
            IWMPPlaylist * This,
            /* [in] */ IWMPMedia *pIWMPMedia);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *removeItem )( 
            IWMPPlaylist * This,
            /* [in] */ IWMPMedia *pIWMPMedia);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *moveItem )( 
            IWMPPlaylist * This,
            long lIndexOld,
            long lIndexNew);
        
        END_INTERFACE
    } IWMPPlaylistVtbl;

    interface IWMPPlaylist
    {
        CONST_VTBL struct IWMPPlaylistVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPPlaylist_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMPPlaylist_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMPPlaylist_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMPPlaylist_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWMPPlaylist_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWMPPlaylist_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWMPPlaylist_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWMPPlaylist_get_count(This,plCount)	\
    ( (This)->lpVtbl -> get_count(This,plCount) ) 

#define IWMPPlaylist_get_name(This,pbstrName)	\
    ( (This)->lpVtbl -> get_name(This,pbstrName) ) 

#define IWMPPlaylist_put_name(This,bstrName)	\
    ( (This)->lpVtbl -> put_name(This,bstrName) ) 

#define IWMPPlaylist_get_attributeCount(This,plCount)	\
    ( (This)->lpVtbl -> get_attributeCount(This,plCount) ) 

#define IWMPPlaylist_get_attributeName(This,lIndex,pbstrAttributeName)	\
    ( (This)->lpVtbl -> get_attributeName(This,lIndex,pbstrAttributeName) ) 

#define IWMPPlaylist_get_item(This,lIndex,ppIWMPMedia)	\
    ( (This)->lpVtbl -> get_item(This,lIndex,ppIWMPMedia) ) 

#define IWMPPlaylist_getItemInfo(This,bstrName,pbstrVal)	\
    ( (This)->lpVtbl -> getItemInfo(This,bstrName,pbstrVal) ) 

#define IWMPPlaylist_setItemInfo(This,bstrName,bstrValue)	\
    ( (This)->lpVtbl -> setItemInfo(This,bstrName,bstrValue) ) 

#define IWMPPlaylist_get_isIdentical(This,pIWMPPlaylist,pvbool)	\
    ( (This)->lpVtbl -> get_isIdentical(This,pIWMPPlaylist,pvbool) ) 

#define IWMPPlaylist_clear(This)	\
    ( (This)->lpVtbl -> clear(This) ) 

#define IWMPPlaylist_insertItem(This,lIndex,pIWMPMedia)	\
    ( (This)->lpVtbl -> insertItem(This,lIndex,pIWMPMedia) ) 

#define IWMPPlaylist_appendItem(This,pIWMPMedia)	\
    ( (This)->lpVtbl -> appendItem(This,pIWMPMedia) ) 

#define IWMPPlaylist_removeItem(This,pIWMPMedia)	\
    ( (This)->lpVtbl -> removeItem(This,pIWMPMedia) ) 

#define IWMPPlaylist_moveItem(This,lIndexOld,lIndexNew)	\
    ( (This)->lpVtbl -> moveItem(This,lIndexOld,lIndexNew) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMPPlaylist_INTERFACE_DEFINED__ */


#ifndef __IWMPErrorItem_INTERFACE_DEFINED__
#define __IWMPErrorItem_INTERFACE_DEFINED__

/* interface IWMPErrorItem */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPErrorItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3614C646-3B3B-4de7-A81E-930E3F2127B3")
    IWMPErrorItem : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_errorCode( 
            /* [retval][out] */ long *phr) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_errorDescription( 
            /* [retval][out] */ BSTR *pbstrDescription) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_errorContext( 
            /* [retval][out] */ VARIANT *pvarContext) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_remedy( 
            /* [retval][out] */ long *plRemedy) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_customUrl( 
            /* [retval][out] */ BSTR *pbstrCustomUrl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPErrorItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMPErrorItem * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMPErrorItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMPErrorItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMPErrorItem * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMPErrorItem * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMPErrorItem * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMPErrorItem * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_errorCode )( 
            IWMPErrorItem * This,
            /* [retval][out] */ long *phr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_errorDescription )( 
            IWMPErrorItem * This,
            /* [retval][out] */ BSTR *pbstrDescription);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_errorContext )( 
            IWMPErrorItem * This,
            /* [retval][out] */ VARIANT *pvarContext);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_remedy )( 
            IWMPErrorItem * This,
            /* [retval][out] */ long *plRemedy);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_customUrl )( 
            IWMPErrorItem * This,
            /* [retval][out] */ BSTR *pbstrCustomUrl);
        
        END_INTERFACE
    } IWMPErrorItemVtbl;

    interface IWMPErrorItem
    {
        CONST_VTBL struct IWMPErrorItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPErrorItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMPErrorItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMPErrorItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMPErrorItem_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWMPErrorItem_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWMPErrorItem_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWMPErrorItem_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWMPErrorItem_get_errorCode(This,phr)	\
    ( (This)->lpVtbl -> get_errorCode(This,phr) ) 

#define IWMPErrorItem_get_errorDescription(This,pbstrDescription)	\
    ( (This)->lpVtbl -> get_errorDescription(This,pbstrDescription) ) 

#define IWMPErrorItem_get_errorContext(This,pvarContext)	\
    ( (This)->lpVtbl -> get_errorContext(This,pvarContext) ) 

#define IWMPErrorItem_get_remedy(This,plRemedy)	\
    ( (This)->lpVtbl -> get_remedy(This,plRemedy) ) 

#define IWMPErrorItem_get_customUrl(This,pbstrCustomUrl)	\
    ( (This)->lpVtbl -> get_customUrl(This,pbstrCustomUrl) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMPErrorItem_INTERFACE_DEFINED__ */


#ifndef __IWMPErrorItem2_INTERFACE_DEFINED__
#define __IWMPErrorItem2_INTERFACE_DEFINED__

/* interface IWMPErrorItem2 */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPErrorItem2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F75CCEC0-C67C-475c-931E-8719870BEE7D")
    IWMPErrorItem2 : public IWMPErrorItem
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_condition( 
            /* [retval][out] */ long *plCondition) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPErrorItem2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMPErrorItem2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMPErrorItem2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMPErrorItem2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMPErrorItem2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMPErrorItem2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMPErrorItem2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMPErrorItem2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_errorCode )( 
            IWMPErrorItem2 * This,
            /* [retval][out] */ long *phr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_errorDescription )( 
            IWMPErrorItem2 * This,
            /* [retval][out] */ BSTR *pbstrDescription);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_errorContext )( 
            IWMPErrorItem2 * This,
            /* [retval][out] */ VARIANT *pvarContext);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_remedy )( 
            IWMPErrorItem2 * This,
            /* [retval][out] */ long *plRemedy);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_customUrl )( 
            IWMPErrorItem2 * This,
            /* [retval][out] */ BSTR *pbstrCustomUrl);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_condition )( 
            IWMPErrorItem2 * This,
            /* [retval][out] */ long *plCondition);
        
        END_INTERFACE
    } IWMPErrorItem2Vtbl;

    interface IWMPErrorItem2
    {
        CONST_VTBL struct IWMPErrorItem2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPErrorItem2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMPErrorItem2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMPErrorItem2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMPErrorItem2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWMPErrorItem2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWMPErrorItem2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWMPErrorItem2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWMPErrorItem2_get_errorCode(This,phr)	\
    ( (This)->lpVtbl -> get_errorCode(This,phr) ) 

#define IWMPErrorItem2_get_errorDescription(This,pbstrDescription)	\
    ( (This)->lpVtbl -> get_errorDescription(This,pbstrDescription) ) 

#define IWMPErrorItem2_get_errorContext(This,pvarContext)	\
    ( (This)->lpVtbl -> get_errorContext(This,pvarContext) ) 

#define IWMPErrorItem2_get_remedy(This,plRemedy)	\
    ( (This)->lpVtbl -> get_remedy(This,plRemedy) ) 

#define IWMPErrorItem2_get_customUrl(This,pbstrCustomUrl)	\
    ( (This)->lpVtbl -> get_customUrl(This,pbstrCustomUrl) ) 


#define IWMPErrorItem2_get_condition(This,plCondition)	\
    ( (This)->lpVtbl -> get_condition(This,plCondition) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMPErrorItem2_INTERFACE_DEFINED__ */


#ifndef __IWMPError_INTERFACE_DEFINED__
#define __IWMPError_INTERFACE_DEFINED__

/* interface IWMPError */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPError;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A12DCF7D-14AB-4c1b-A8CD-63909F06025B")
    IWMPError : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE clearErrorQueue( void) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_errorCount( 
            /* [retval][out] */ long *pdwNumErrors) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_item( 
            /* [in] */ long dwIndex,
            /* [retval][out] */ IWMPErrorItem **ppErrorItem) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE webHelp( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPErrorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMPError * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMPError * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMPError * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMPError * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMPError * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMPError * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMPError * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *clearErrorQueue )( 
            IWMPError * This);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_errorCount )( 
            IWMPError * This,
            /* [retval][out] */ long *pdwNumErrors);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_item )( 
            IWMPError * This,
            /* [in] */ long dwIndex,
            /* [retval][out] */ IWMPErrorItem **ppErrorItem);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *webHelp )( 
            IWMPError * This);
        
        END_INTERFACE
    } IWMPErrorVtbl;

    interface IWMPError
    {
        CONST_VTBL struct IWMPErrorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPError_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMPError_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMPError_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMPError_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWMPError_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWMPError_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWMPError_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWMPError_clearErrorQueue(This)	\
    ( (This)->lpVtbl -> clearErrorQueue(This) ) 

#define IWMPError_get_errorCount(This,pdwNumErrors)	\
    ( (This)->lpVtbl -> get_errorCount(This,pdwNumErrors) ) 

#define IWMPError_get_item(This,dwIndex,ppErrorItem)	\
    ( (This)->lpVtbl -> get_item(This,dwIndex,ppErrorItem) ) 

#define IWMPError_webHelp(This)	\
    ( (This)->lpVtbl -> webHelp(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMPError_INTERFACE_DEFINED__ */



#ifndef __DummyLib_LIBRARY_DEFINED__
#define __DummyLib_LIBRARY_DEFINED__

/* library DummyLib */
/* [version][uuid] */ 


EXTERN_C const IID LIBID_DummyLib;

EXTERN_C const CLSID CLSID_DummyCoClass;

#ifdef __cplusplus

class DECLSPEC_UUID("09428D37-E0B9-11d2-B147-00C04F79FAA6")
DummyCoClass;
#endif
#endif /* __DummyLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\wmpplug.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0543 */
/* Compiler settings for wmpplug.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wmpplug_h__
#define __wmpplug_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWMPPluginUI_FWD_DEFINED__
#define __IWMPPluginUI_FWD_DEFINED__
typedef interface IWMPPluginUI IWMPPluginUI;
#endif 	/* __IWMPPluginUI_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "wmpocx.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_wmpplug_0000_0000 */
/* [local] */ 

//=========================================================================
//
// Microsoft Windows Media Technologies
// Copyright (C) Microsoft Corporation. All rights reserved.
//
//=========================================================================
#define PLUGIN_INSTALLREGKEY                L"Software\\Microsoft\\MediaPlayer\\UIPlugins"
#define PLUGIN_INSTALLREGKEY_FRIENDLYNAME   L"FriendlyName"
#define PLUGIN_INSTALLREGKEY_DESCRIPTION    L"Description"
#define PLUGIN_INSTALLREGKEY_CAPABILITIES   L"Capabilities"
#define PLUGIN_INSTALLREGKEY_UNINSTALL      L"UninstallPath"
#define	PLUGIN_TYPE_BACKGROUND	( 0x1 )

#define	PLUGIN_TYPE_SEPARATEWINDOW	( 0x2 )

#define	PLUGIN_TYPE_DISPLAYAREA	( 0x3 )

#define	PLUGIN_TYPE_SETTINGSAREA	( 0x4 )

#define	PLUGIN_TYPE_METADATAAREA	( 0x5 )

#define	PLUGIN_FLAGS_HASPROPERTYPAGE	( 0x80000000 )

#define	PLUGIN_FLAGS_INSTALLAUTORUN	( 0x40000000 )

#define	PLUGIN_FLAGS_LAUNCHPROPERTYPAGE	( 0x20000000 )

#define	PLUGIN_FLAGS_ACCEPTSMEDIA	( 0x10000000 )

#define	PLUGIN_FLAGS_ACCEPTSPLAYLISTS	( 0x8000000 )

#define	PLUGIN_FLAGS_HASPRESETS	( 0x4000000 )

#define	PLUGIN_FLAGS_HIDDEN	( 0x2000000 )

#define PLUGIN_MISC_PRESETCOUNT      L"PresetCount"
#define PLUGIN_MISC_PRESETNAMES      L"PresetNames"
#define PLUGIN_MISC_CURRENTPRESET    L"CurrentPreset"
#define PLUGIN_SEPARATEWINDOW_RESIZABLE     L"Resizable"
#define PLUGIN_SEPARATEWINDOW_DEFAULTWIDTH  L"DefaultWidth"
#define PLUGIN_SEPARATEWINDOW_DEFAULTHEIGHT L"DefaultHeight"
#define PLUGIN_SEPARATEWINDOW_MINWIDTH      L"MinWidth"
#define PLUGIN_SEPARATEWINDOW_MINHEIGHT     L"MinHeight"
#define PLUGIN_SEPARATEWINDOW_MAXWIDTH      L"MaxWidth"
#define PLUGIN_SEPARATEWINDOW_MAXHEIGHT     L"MaxHeight"
#define PLUGIN_MISC_QUERYDESTROY            L"QueryDestroy"
#define PLUGIN_ALL_MEDIASENDTO              L"MediaSendTo"
#define PLUGIN_ALL_PLAYLISTSENDTO           L"PlaylistSendTo"
__inline BOOL WMPNotifyPluginAddRemove()
{
    return( ::PostMessage( HWND_BROADCAST, ::RegisterWindowMessageA( "WMPlayer_PluginAddRemove" ), 0, 0 ) );
}


extern RPC_IF_HANDLE __MIDL_itf_wmpplug_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmpplug_0000_0000_v0_0_s_ifspec;

#ifndef __IWMPPluginUI_INTERFACE_DEFINED__
#define __IWMPPluginUI_INTERFACE_DEFINED__

/* interface IWMPPluginUI */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMPPluginUI;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4C5E8F9F-AD3E-4bf9-9753-FCD30D6D38DD")
    IWMPPluginUI : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetCore( 
            /* [in] */ IWMPCore *pCore) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Create( 
            /* [in] */ HWND hwndParent,
            /* [out] */ HWND *phwndWindow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Destroy( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisplayPropertyPage( 
            /* [in] */ HWND hwndParent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ const WCHAR *pwszName,
            /* [out] */ VARIANT *pvarProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [in] */ const WCHAR *pwszName,
            /* [in] */ const VARIANT *pvarProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TranslateAccelerator( 
            /* [in] */ LPMSG lpmsg) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPPluginUIVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMPPluginUI * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMPPluginUI * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMPPluginUI * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetCore )( 
            IWMPPluginUI * This,
            /* [in] */ IWMPCore *pCore);
        
        HRESULT ( STDMETHODCALLTYPE *Create )( 
            IWMPPluginUI * This,
            /* [in] */ HWND hwndParent,
            /* [out] */ HWND *phwndWindow);
        
        HRESULT ( STDMETHODCALLTYPE *Destroy )( 
            IWMPPluginUI * This);
        
        HRESULT ( STDMETHODCALLTYPE *DisplayPropertyPage )( 
            IWMPPluginUI * This,
            /* [in] */ HWND hwndParent);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IWMPPluginUI * This,
            /* [in] */ const WCHAR *pwszName,
            /* [out] */ VARIANT *pvarProperty);
        
        HRESULT ( STDMETHODCALLTYPE *SetProperty )( 
            IWMPPluginUI * This,
            /* [in] */ const WCHAR *pwszName,
            /* [in] */ const VARIANT *pvarProperty);
        
        HRESULT ( STDMETHODCALLTYPE *TranslateAccelerator )( 
            IWMPPluginUI * This,
            /* [in] */ LPMSG lpmsg);
        
        END_INTERFACE
    } IWMPPluginUIVtbl;

    interface IWMPPluginUI
    {
        CONST_VTBL struct IWMPPluginUIVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPPluginUI_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMPPluginUI_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMPPluginUI_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMPPluginUI_SetCore(This,pCore)	\
    ( (This)->lpVtbl -> SetCore(This,pCore) ) 

#define IWMPPluginUI_Create(This,hwndParent,phwndWindow)	\
    ( (This)->lpVtbl -> Create(This,hwndParent,phwndWindow) ) 

#define IWMPPluginUI_Destroy(This)	\
    ( (This)->lpVtbl -> Destroy(This) ) 

#define IWMPPluginUI_DisplayPropertyPage(This,hwndParent)	\
    ( (This)->lpVtbl -> DisplayPropertyPage(This,hwndParent) ) 

#define IWMPPluginUI_GetProperty(This,pwszName,pvarProperty)	\
    ( (This)->lpVtbl -> GetProperty(This,pwszName,pvarProperty) ) 

#define IWMPPluginUI_SetProperty(This,pwszName,pvarProperty)	\
    ( (This)->lpVtbl -> SetProperty(This,pwszName,pvarProperty) ) 

#define IWMPPluginUI_TranslateAccelerator(This,lpmsg)	\
    ( (This)->lpVtbl -> TranslateAccelerator(This,lpmsg) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMPPluginUI_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long *, HWND * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\wmistr.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    Wmistr.h

Abstract:

    WMI structure definitions

--*/

#ifndef _WMISTR_
#define _WMISTR_

#pragma once

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable: 4200) // nonstandard extension used : zero-sized array in struct/union
#pragma warning(disable: 4201) // nonstandard extension used : nameless struct/union

//
// WNODE definition
typedef struct _WNODE_HEADER
{
    ULONG BufferSize;        // Size of entire buffer inclusive of this ULONG
    ULONG ProviderId;    // Provider Id of driver returning this buffer
    union
    {
        ULONG64 HistoricalContext;  // Logger use
        struct
            {
            ULONG Version;           // Reserved
            ULONG Linkage;           // Linkage field reserved for WMI
        };
    };

    union
    {
        ULONG CountLost;         // Reserved
        HANDLE KernelHandle;     // Kernel handle for data block
        LARGE_INTEGER TimeStamp; // Timestamp as returned in units of 100ns
                                 // since 1/1/1601
    };
    GUID Guid;                  // Guid for data block returned with results
    ULONG ClientContext;
    ULONG Flags;             // Flags, see below
} WNODE_HEADER, *PWNODE_HEADER;

//
// WNODE_HEADER flags are defined as follows
#define WNODE_FLAG_ALL_DATA        0x00000001 // set for WNODE_ALL_DATA
#define WNODE_FLAG_SINGLE_INSTANCE 0x00000002 // set for WNODE_SINGLE_INSTANCE
#define WNODE_FLAG_SINGLE_ITEM     0x00000004 // set for WNODE_SINGLE_ITEM
#define WNODE_FLAG_EVENT_ITEM      0x00000008 // set for WNODE_EVENT_ITEM

                                              // Set if data block size is
                                              // identical for all instances
                                              // (used with  WNODE_ALL_DATA
                                              // only)
#define WNODE_FLAG_FIXED_INSTANCE_SIZE 0x00000010

#define WNODE_FLAG_TOO_SMALL           0x00000020 // set for WNODE_TOO_SMALL

                                 // Set when a data provider returns a
                                 // WNODE_ALL_DATA in which the number of
                                 // instances and their names returned
                                 // are identical to those returned from the
                                 // previous WNODE_ALL_DATA query. Only data
                                 // blocks registered with dynamic instance
                                 // names should use this flag.
#define WNODE_FLAG_INSTANCES_SAME  0x00000040

                                 // Instance names are not specified in
                                 // WNODE_ALL_DATA; values specified at
                                 // registration are used instead. Always
                                 // set for guids registered with static
                                 // instance names
#define WNODE_FLAG_STATIC_INSTANCE_NAMES 0x00000080

#define WNODE_FLAG_INTERNAL      0x00000100  // Used internally by WMI

                                 // timestamp should not be modified by
                                 // a historical logger
#define WNODE_FLAG_USE_TIMESTAMP 0x00000200

#if (NTDDI_VERSION >= NTDDI_WINXP)
#define WNODE_FLAG_PERSIST_EVENT 0x00000400
#endif

#define WNODE_FLAG_EVENT_REFERENCE 0x00002000

// Set if Instance names are ansi. Only set when returning from
// WMIQuerySingleInstanceA and WMIQueryAllDataA
#define WNODE_FLAG_ANSI_INSTANCENAMES 0x00004000

// Set if WNODE is a method call
#define WNODE_FLAG_METHOD_ITEM     0x00008000

// Set if instance names originated from a PDO
#define WNODE_FLAG_PDO_INSTANCE_NAMES  0x00010000

// The second byte, except the first bit is used exclusively for tracing
#define WNODE_FLAG_TRACED_GUID   0x00020000 // denotes a trace

#define WNODE_FLAG_LOG_WNODE     0x00040000 // request to log Wnode

#define WNODE_FLAG_USE_GUID_PTR  0x00080000 // Guid is actually a pointer

#define WNODE_FLAG_USE_MOF_PTR   0x00100000 // MOF data are dereferenced

#if (NTDDI_VERSION >= NTDDI_WINXP)
#define WNODE_FLAG_NO_HEADER     0x00200000 // Trace without header
#endif

#if (NTDDI_VERSION >= NTDDI_LONGHORN)
#define WNODE_FLAG_SEND_DATA_BLOCK  0x00400000 // Data Block delivery
#endif

// Set for events that are WNODE_EVENT_REFERENCE
// Mask for event severity level. Level 0xff is the most severe type of event
#define WNODE_FLAG_SEVERITY_MASK 0xff000000


//
// This structure is used within the WNODE_ALL_DATA when the data blocks
// for the different instances are different lengths. If the data blocks
// for the different instances are identical lengths then
// WNODE_FLAG_FIXED_INSTANCE_SIZE should be set and FixedInstanceSize
// set to the common data block size.
typedef struct
{
    ULONG OffsetInstanceData;   // Offset from beginning of WNODE_ALL_DATA
                                // to Data block for instance
    ULONG LengthInstanceData;   // Length of data block for instance
} OFFSETINSTANCEDATAANDLENGTH, *POFFSETINSTANCEDATAANDLENGTH;

typedef struct tagWNODE_ALL_DATA
{
    struct _WNODE_HEADER WnodeHeader;

    ULONG DataBlockOffset;// Offset from begin of WNODE to first data block

    ULONG InstanceCount;  // Count of instances whose data follows.

                      // Offset to an array of offsets to the instance names
    ULONG OffsetInstanceNameOffsets;

    // If WNODE_FLAG_FIXED_INSTANCE_SIZE is set in Flags then
    // FixedInstanceSize specifies the size of each data block. In this case
    // there is one ULONG followed by the data blocks.
    // If WNODE_FLAG_FIXED_INSTANCE_SIZE is not set
    // then OffsetInstanceDataAndLength
    // is an array of OFFSETINSTANCEDATAANDLENGTH that specifies the
    // offsets and lengths of the data blocks for each instance.
    union
    {
        ULONG FixedInstanceSize;
        OFFSETINSTANCEDATAANDLENGTH OffsetInstanceDataAndLength[];
                                    /* [InstanceCount] */
    };

    // padding so that first data block begins on a 8 byte boundry

    // data blocks and instance names for all instances

} WNODE_ALL_DATA, *PWNODE_ALL_DATA;


typedef struct tagWNODE_SINGLE_INSTANCE
{
    struct _WNODE_HEADER WnodeHeader;

                            // Offset from beginning of WNODE_SINGLE_INSTANCE
                            // to instance name. Use when
                            // WNODE_FLAG_STATIC_INSTANCE_NAMES is reset
                            // (Dynamic instance names)
    ULONG OffsetInstanceName;

                            // Instance index when
                            // WNODE_FLAG_STATIC_INSTANCE_NAME is set
    ULONG InstanceIndex;    // (Static Instance Names)

    ULONG DataBlockOffset;  // offset from beginning of WNODE to data block
    ULONG SizeDataBlock;    // Size of data block for instance

    UCHAR VariableData[];
    // instance names and padding so data block begins on 8 byte boundry

    // data block
} WNODE_SINGLE_INSTANCE, *PWNODE_SINGLE_INSTANCE;


typedef struct tagWNODE_SINGLE_ITEM
{
    struct _WNODE_HEADER WnodeHeader;

                            // Offset from beginning of WNODE_SINGLE_INSTANCE
                            // to instance name. Examine when
                            // WNODE_FLAG_STATIC_INSTANCE_NAME is reset
                            // (Dynamic instance names)
    ULONG OffsetInstanceName;

                            // Instance index when
                            // WNODE_FLAG_STATIC_INSTANCE_NAME
    ULONG InstanceIndex;    //  set (Static Instance Names)

    ULONG ItemId;           // Item Id for data item being set

    ULONG DataBlockOffset;  // offset from WNODE begin to data item value
    ULONG SizeDataItem;     // Size of data item

    UCHAR VariableData[];
    // instance names and padding so data value begins on 8 byte boundry

    // data item value
} WNODE_SINGLE_ITEM, *PWNODE_SINGLE_ITEM;

typedef struct tagWNODE_METHOD_ITEM
{
    struct _WNODE_HEADER WnodeHeader;

                            // Offset from beginning of WNODE_METHOD_ITEM
                            // to instance name. Examine when
                            // WNODE_FLAG_STATIC_INSTANCE_NAME is reset
                            // (Dynamic instance names)
    ULONG OffsetInstanceName;

                            // Instance index when
                            // WNODE_FLAG_STATIC_INSTANCE_NAME
    ULONG InstanceIndex;    //  set (Static Instance Names)

    ULONG MethodId;         // Method id of method being called

    ULONG DataBlockOffset;  // On Entry: offset from WNODE to input data
                            // On Return: offset from WNODE to input and
                            //            output data blocks
    ULONG SizeDataBlock;    // On Entry: Size of input data, 0 if no input
                            //           data
                            // On Return: Size of output data, 0 if no output
                            //            data

    UCHAR VariableData[];
    // instance names and padding so data value begins on 8 byte boundry

    // data item value
} WNODE_METHOD_ITEM, *PWNODE_METHOD_ITEM;

typedef struct tagWNODE_EVENT_ITEM
{
    struct _WNODE_HEADER WnodeHeader;

    // Different data could be here depending upon the flags set in the
    // WNODE_HEADER above. If the WNODE_FLAG_ALL_DATA flag is set then the
    // contents of a WNODE_ALL_DATA  (excluding WNODE_HEADER) is here. If the
    // WNODE_FLAG_SINGLE_INSTANCE flag is set then a WNODE_SINGLE_INSTANCE
    // (excluding WNODE_HEADER) is here. Lastly if the  WNODE_FLAG_SINGLE_ITEM
    // flag is set then a WNODE_SINGLE_ITEM (excluding WNODE_HEADER) is here.
} WNODE_EVENT_ITEM, *PWNODE_EVENT_ITEM;


//
// If a KM data provider needs to fire an event that is larger than the
// maximum size that WMI allows then it should fire a WNODE_EVENT_REFERENCE
// that specifies which guid and instance name to query for the actual data
// that should be part of the event.
typedef struct tagWNODE_EVENT_REFERENCE
{
    struct _WNODE_HEADER WnodeHeader;
    GUID TargetGuid;
    ULONG TargetDataBlockSize;
    union
    {
        ULONG TargetInstanceIndex;
        WCHAR TargetInstanceName[];
    };
} WNODE_EVENT_REFERENCE, *PWNODE_EVENT_REFERENCE;


typedef struct tagWNODE_TOO_SMALL
{
    struct _WNODE_HEADER WnodeHeader;
    ULONG SizeNeeded;                   // Size needed to build WNODE result
} WNODE_TOO_SMALL, *PWNODE_TOO_SMALL;


typedef struct
{
    GUID Guid;             // Guid of data block being registered or updated
    ULONG Flags;         // Flags

    ULONG InstanceCount; // Count of static instances names for the guid

    union
    {
                     // If WMIREG_FLAG_INSTANCE_LIST then this has the offset
                     // to a list of InstanceCount counted UNICODE
                     // strings placed end to end.
        ULONG InstanceNameList;
                        
                     // If WMIREG_FLAG_INSTANCE_BASENAME then this has the
                     // offset to a single counted UNICODE string that
                     // has the basename for the instance names.
                        
        ULONG BaseNameOffset;
                        
                     // If WMIREG_FLAG_INSTANCE_PDO is set then InstanceInfo
                     // has the PDO whose device instance path will
                     // become the instance name
        ULONG_PTR Pdo;
                        
                     // If WMIREG_FLAG_INSTANCE_REFERENCE then this points to
                     // a WMIREGINSTANCEREF structure.
                        
        ULONG_PTR InstanceInfo;// Offset from beginning of the WMIREGINFO structure to
    };

} WMIREGGUIDW, *PWMIREGGUIDW;

typedef WMIREGGUIDW WMIREGGUID;
typedef PWMIREGGUIDW PWMIREGGUID;

// Set if collection must be enabled for the guid before the data provider
// can be queried for data.
#define WMIREG_FLAG_EXPENSIVE          0x00000001

// Set if instance names for this guid are specified in a static list within
// the WMIREGINFO
#define WMIREG_FLAG_INSTANCE_LIST      0x00000004

// Set if instance names are to be static and generated by WMI using a
// base name in the WMIREGINFO and an index
#define WMIREG_FLAG_INSTANCE_BASENAME  0x00000008

// Set if WMI should do automatic mapping of a PDO to device instance name
// as the instance name for the guid. This flag should only be used by
// kernel mode data providers.
#define WMIREG_FLAG_INSTANCE_PDO       0x00000020

// Note the flags WMIREG_FLAG_INSTANCE_LIST, WMIREG_FLAG_INSTANCE_BASENAME,
// WMIREG_FLAG_INSTANCE_REFERENCE and WMIREG_FLAG_INSTANCE_PDO are mutually
// exclusive.

//
// These flags are only valid in a response to WMI_GUID_REGUPDATE
#define WMIREG_FLAG_REMOVE_GUID       0x00010000 // Remove support for  guid
#define WMIREG_FLAG_RESERVED1         0x00020000 // Reserved by WMI
#define WMIREG_FLAG_RESERVED2         0x00040000 // Reserved by WMI

// Set if guid is one that is written to trace log.
// This guid cannot be queried directly via WMI, but must be read using
// logger apis.
#define WMIREG_FLAG_TRACED_GUID        0x00080000

//
// Only those Trace Guids that have this bit set can receive
// Enable/Disable Notifications.
//
#define WMIREG_FLAG_TRACE_CONTROL_GUID 0x00001000

//
// Set if the guid is only used for firing events. Guids that can be queried
// and that fire events should not have this bit set.
#define WMIREG_FLAG_EVENT_ONLY_GUID    0x00000040

typedef struct
{
// Size of entire WMIREGINFO structure including this ULONG     
// and any static instance names that follow
    ULONG BufferSize;

    ULONG NextWmiRegInfo;         // Offset to next WMIREGINFO structure

    ULONG RegistryPath; // Offset from beginning of WMIREGINFO structure to a
                        // counted Unicode string containing
                        // the driver registry path (under HKLM\CCS\Services)
                        // This must be filled only by kernel mode data
                                                // providers
                                                        
// Offset from beginning of WMIREGINFO structure to a
// counted Unicode string containing
// the name of resource in driver file containing MOF info
    ULONG MofResourceName;

// Count of WMIREGGUID structures immediately following
    ULONG GuidCount;
    WMIREGGUIDW WmiRegGuid[];  // array of GuidCount WMIREGGUID structures
    // Variable length data including :
    //     Instance Names
} WMIREGINFOW, *PWMIREGINFOW;

typedef WMIREGINFOW WMIREGINFO;
typedef PWMIREGINFOW PWMIREGINFO;

//
// WMI request codes
typedef enum
{
#ifndef _WMIKM_
    WMI_GET_ALL_DATA = 0,
    WMI_GET_SINGLE_INSTANCE = 1,
    WMI_SET_SINGLE_INSTANCE = 2,
    WMI_SET_SINGLE_ITEM = 3,
    WMI_ENABLE_EVENTS = 4,
    WMI_DISABLE_EVENTS  = 5,
    WMI_ENABLE_COLLECTION = 6,
    WMI_DISABLE_COLLECTION = 7,
    WMI_REGINFO = 8,
    WMI_EXECUTE_METHOD = 9
#endif
} WMIDPREQUESTCODE;

#if defined(_WINNT_) || defined(WINNT)
//
// WMI guid objects have the following rights
// WMIGUID_QUERY
// WMIGUID_SET
// WMIGUID_NOTIFICATION
// WMIGUID_READ_DESCRIPTION
// WMIGUID_EXECUTE
// TRACELOG_CREATE_REALTIME
// TRACELOG_CREATE_ONDISK
// TRACELOG_GUID_ENABLE
// TRACELOG_ACCESS_KERNEL_LOGGER
// TRACELOG_LOG_EVENT or TRACELOG_CREATE_INPROC
// TRACELOG_ACCESS_REALTIME
// TRACELOG_REGISTER_GUIDS

//
// GuidTypes 
//
//#ifndef _WMIKM_
#define WMI_GUIDTYPE_TRACECONTROL 0
#define WMI_GUIDTYPE_TRACE        1
#define WMI_GUIDTYPE_DATA         2
#define WMI_GUIDTYPE_EVENT        3
//#endif

//
// Specific rights for WMI guid objects. These are available from 0x0001 to
// 0xffff (ie up to 16 rights)
//
#define WMIGUID_QUERY                 0x0001
#define WMIGUID_SET                   0x0002
#define WMIGUID_NOTIFICATION          0x0004
#define WMIGUID_READ_DESCRIPTION      0x0008
#define WMIGUID_EXECUTE               0x0010
#define TRACELOG_CREATE_REALTIME      0x0020
#define TRACELOG_CREATE_ONDISK        0x0040
#define TRACELOG_GUID_ENABLE          0x0080
#define TRACELOG_ACCESS_KERNEL_LOGGER 0x0100
#define TRACELOG_LOG_EVENT            0x0200 // used on Vista and greater
#define TRACELOG_CREATE_INPROC        0x0200 // used pre-Vista
#define TRACELOG_ACCESS_REALTIME      0x0400
#define TRACELOG_REGISTER_GUIDS       0x0800

#define WMIGUID_ALL_ACCESS_WIN2K (STANDARD_RIGHTS_READ | \
                                  WMIGUID_QUERY | \
                                  WMIGUID_SET | \
                                  WMIGUID_NOTIFICATION | \
                                  WMIGUID_READ_DESCRIPTION | \
                                  WMIGUID_EXECUTE | \
                                  TRACELOG_CREATE_REALTIME | \
                                  TRACELOG_CREATE_ONDISK | \
                                  TRACELOG_GUID_ENABLE | \
                                  TRACELOG_ACCESS_KERNEL_LOGGER | \
                                  TRACELOG_CREATE_INPROC | \
                                  TRACELOG_ACCESS_REALTIME)
                                  
#define WMIGUID_ALL_ACCESS_WINXP (WMIGUID_ALL_ACCESS_WIN2K | \
                                  SYNCHRONIZE | \
                                  TRACELOG_REGISTER_GUIDS)
                                  
#if (NTDDI_VERSION >= NTDDI_WINXP)

#define WMIGUID_ALL_ACCESS WMIGUID_ALL_ACCESS_WINXP

#else

#define WMIGUID_ALL_ACCESS WMIGUID_ALL_ACCESS_WIN2K

#endif

#define WMI_GLOBAL_LOGGER_ID          0x0001
#endif

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default: 4200) // nonstandard extension used : zero-sized array in struct/union
#pragma warning(default: 4201) // nonstandard extension used : nameless struct/union
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\wmsdkidl.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0543 */
/* Compiler settings for wmsdkidl.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wmsdkidl_h__
#define __wmsdkidl_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWMMediaProps_FWD_DEFINED__
#define __IWMMediaProps_FWD_DEFINED__
typedef interface IWMMediaProps IWMMediaProps;
#endif 	/* __IWMMediaProps_FWD_DEFINED__ */


#ifndef __IWMVideoMediaProps_FWD_DEFINED__
#define __IWMVideoMediaProps_FWD_DEFINED__
typedef interface IWMVideoMediaProps IWMVideoMediaProps;
#endif 	/* __IWMVideoMediaProps_FWD_DEFINED__ */


#ifndef __IWMWriter_FWD_DEFINED__
#define __IWMWriter_FWD_DEFINED__
typedef interface IWMWriter IWMWriter;
#endif 	/* __IWMWriter_FWD_DEFINED__ */


#ifndef __IWMInputMediaProps_FWD_DEFINED__
#define __IWMInputMediaProps_FWD_DEFINED__
typedef interface IWMInputMediaProps IWMInputMediaProps;
#endif 	/* __IWMInputMediaProps_FWD_DEFINED__ */


#ifndef __IWMReader_FWD_DEFINED__
#define __IWMReader_FWD_DEFINED__
typedef interface IWMReader IWMReader;
#endif 	/* __IWMReader_FWD_DEFINED__ */


#ifndef __IWMOutputMediaProps_FWD_DEFINED__
#define __IWMOutputMediaProps_FWD_DEFINED__
typedef interface IWMOutputMediaProps IWMOutputMediaProps;
#endif 	/* __IWMOutputMediaProps_FWD_DEFINED__ */


#ifndef __IWMStatusCallback_FWD_DEFINED__
#define __IWMStatusCallback_FWD_DEFINED__
typedef interface IWMStatusCallback IWMStatusCallback;
#endif 	/* __IWMStatusCallback_FWD_DEFINED__ */


#ifndef __IWMReaderCallback_FWD_DEFINED__
#define __IWMReaderCallback_FWD_DEFINED__
typedef interface IWMReaderCallback IWMReaderCallback;
#endif 	/* __IWMReaderCallback_FWD_DEFINED__ */


#ifndef __IWMCredentialCallback_FWD_DEFINED__
#define __IWMCredentialCallback_FWD_DEFINED__
typedef interface IWMCredentialCallback IWMCredentialCallback;
#endif 	/* __IWMCredentialCallback_FWD_DEFINED__ */


#ifndef __IWMMetadataEditor_FWD_DEFINED__
#define __IWMMetadataEditor_FWD_DEFINED__
typedef interface IWMMetadataEditor IWMMetadataEditor;
#endif 	/* __IWMMetadataEditor_FWD_DEFINED__ */


#ifndef __IWMHeaderInfo_FWD_DEFINED__
#define __IWMHeaderInfo_FWD_DEFINED__
typedef interface IWMHeaderInfo IWMHeaderInfo;
#endif 	/* __IWMHeaderInfo_FWD_DEFINED__ */


#ifndef __IWMHeaderInfo2_FWD_DEFINED__
#define __IWMHeaderInfo2_FWD_DEFINED__
typedef interface IWMHeaderInfo2 IWMHeaderInfo2;
#endif 	/* __IWMHeaderInfo2_FWD_DEFINED__ */


#ifndef __IWMHeaderInfo3_FWD_DEFINED__
#define __IWMHeaderInfo3_FWD_DEFINED__
typedef interface IWMHeaderInfo3 IWMHeaderInfo3;
#endif 	/* __IWMHeaderInfo3_FWD_DEFINED__ */


#ifndef __IWMProfileManager_FWD_DEFINED__
#define __IWMProfileManager_FWD_DEFINED__
typedef interface IWMProfileManager IWMProfileManager;
#endif 	/* __IWMProfileManager_FWD_DEFINED__ */


#ifndef __IWMProfileManager2_FWD_DEFINED__
#define __IWMProfileManager2_FWD_DEFINED__
typedef interface IWMProfileManager2 IWMProfileManager2;
#endif 	/* __IWMProfileManager2_FWD_DEFINED__ */


#ifndef __IWMProfile_FWD_DEFINED__
#define __IWMProfile_FWD_DEFINED__
typedef interface IWMProfile IWMProfile;
#endif 	/* __IWMProfile_FWD_DEFINED__ */


#ifndef __IWMProfile2_FWD_DEFINED__
#define __IWMProfile2_FWD_DEFINED__
typedef interface IWMProfile2 IWMProfile2;
#endif 	/* __IWMProfile2_FWD_DEFINED__ */


#ifndef __IWMStreamConfig_FWD_DEFINED__
#define __IWMStreamConfig_FWD_DEFINED__
typedef interface IWMStreamConfig IWMStreamConfig;
#endif 	/* __IWMStreamConfig_FWD_DEFINED__ */


#ifndef __IWMPacketSize_FWD_DEFINED__
#define __IWMPacketSize_FWD_DEFINED__
typedef interface IWMPacketSize IWMPacketSize;
#endif 	/* __IWMPacketSize_FWD_DEFINED__ */


#ifndef __IWMStreamList_FWD_DEFINED__
#define __IWMStreamList_FWD_DEFINED__
typedef interface IWMStreamList IWMStreamList;
#endif 	/* __IWMStreamList_FWD_DEFINED__ */


#ifndef __IWMMutualExclusion_FWD_DEFINED__
#define __IWMMutualExclusion_FWD_DEFINED__
typedef interface IWMMutualExclusion IWMMutualExclusion;
#endif 	/* __IWMMutualExclusion_FWD_DEFINED__ */


#ifndef __IWMWriterAdvanced_FWD_DEFINED__
#define __IWMWriterAdvanced_FWD_DEFINED__
typedef interface IWMWriterAdvanced IWMWriterAdvanced;
#endif 	/* __IWMWriterAdvanced_FWD_DEFINED__ */


#ifndef __IWMWriterAdvanced2_FWD_DEFINED__
#define __IWMWriterAdvanced2_FWD_DEFINED__
typedef interface IWMWriterAdvanced2 IWMWriterAdvanced2;
#endif 	/* __IWMWriterAdvanced2_FWD_DEFINED__ */


#ifndef __IWMWriterPostViewCallback_FWD_DEFINED__
#define __IWMWriterPostViewCallback_FWD_DEFINED__
typedef interface IWMWriterPostViewCallback IWMWriterPostViewCallback;
#endif 	/* __IWMWriterPostViewCallback_FWD_DEFINED__ */


#ifndef __IWMWriterPostView_FWD_DEFINED__
#define __IWMWriterPostView_FWD_DEFINED__
typedef interface IWMWriterPostView IWMWriterPostView;
#endif 	/* __IWMWriterPostView_FWD_DEFINED__ */


#ifndef __IWMWriterSink_FWD_DEFINED__
#define __IWMWriterSink_FWD_DEFINED__
typedef interface IWMWriterSink IWMWriterSink;
#endif 	/* __IWMWriterSink_FWD_DEFINED__ */


#ifndef __IWMRegisterCallback_FWD_DEFINED__
#define __IWMRegisterCallback_FWD_DEFINED__
typedef interface IWMRegisterCallback IWMRegisterCallback;
#endif 	/* __IWMRegisterCallback_FWD_DEFINED__ */


#ifndef __IWMWriterFileSink_FWD_DEFINED__
#define __IWMWriterFileSink_FWD_DEFINED__
typedef interface IWMWriterFileSink IWMWriterFileSink;
#endif 	/* __IWMWriterFileSink_FWD_DEFINED__ */


#ifndef __IWMWriterFileSink2_FWD_DEFINED__
#define __IWMWriterFileSink2_FWD_DEFINED__
typedef interface IWMWriterFileSink2 IWMWriterFileSink2;
#endif 	/* __IWMWriterFileSink2_FWD_DEFINED__ */


#ifndef __IWMWriterNetworkSink_FWD_DEFINED__
#define __IWMWriterNetworkSink_FWD_DEFINED__
typedef interface IWMWriterNetworkSink IWMWriterNetworkSink;
#endif 	/* __IWMWriterNetworkSink_FWD_DEFINED__ */


#ifndef __IWMClientConnections_FWD_DEFINED__
#define __IWMClientConnections_FWD_DEFINED__
typedef interface IWMClientConnections IWMClientConnections;
#endif 	/* __IWMClientConnections_FWD_DEFINED__ */


#ifndef __IWMReaderAdvanced_FWD_DEFINED__
#define __IWMReaderAdvanced_FWD_DEFINED__
typedef interface IWMReaderAdvanced IWMReaderAdvanced;
#endif 	/* __IWMReaderAdvanced_FWD_DEFINED__ */


#ifndef __IWMReaderAdvanced2_FWD_DEFINED__
#define __IWMReaderAdvanced2_FWD_DEFINED__
typedef interface IWMReaderAdvanced2 IWMReaderAdvanced2;
#endif 	/* __IWMReaderAdvanced2_FWD_DEFINED__ */


#ifndef __IWMReaderAllocatorEx_FWD_DEFINED__
#define __IWMReaderAllocatorEx_FWD_DEFINED__
typedef interface IWMReaderAllocatorEx IWMReaderAllocatorEx;
#endif 	/* __IWMReaderAllocatorEx_FWD_DEFINED__ */


#ifndef __IWMReaderTypeNegotiation_FWD_DEFINED__
#define __IWMReaderTypeNegotiation_FWD_DEFINED__
typedef interface IWMReaderTypeNegotiation IWMReaderTypeNegotiation;
#endif 	/* __IWMReaderTypeNegotiation_FWD_DEFINED__ */


#ifndef __IWMReaderCallbackAdvanced_FWD_DEFINED__
#define __IWMReaderCallbackAdvanced_FWD_DEFINED__
typedef interface IWMReaderCallbackAdvanced IWMReaderCallbackAdvanced;
#endif 	/* __IWMReaderCallbackAdvanced_FWD_DEFINED__ */


#ifndef __IWMDRMReader_FWD_DEFINED__
#define __IWMDRMReader_FWD_DEFINED__
typedef interface IWMDRMReader IWMDRMReader;
#endif 	/* __IWMDRMReader_FWD_DEFINED__ */


#ifndef __IWMReaderNetworkConfig_FWD_DEFINED__
#define __IWMReaderNetworkConfig_FWD_DEFINED__
typedef interface IWMReaderNetworkConfig IWMReaderNetworkConfig;
#endif 	/* __IWMReaderNetworkConfig_FWD_DEFINED__ */


#ifndef __IWMReaderStreamClock_FWD_DEFINED__
#define __IWMReaderStreamClock_FWD_DEFINED__
typedef interface IWMReaderStreamClock IWMReaderStreamClock;
#endif 	/* __IWMReaderStreamClock_FWD_DEFINED__ */


#ifndef __IWMIndexer_FWD_DEFINED__
#define __IWMIndexer_FWD_DEFINED__
typedef interface IWMIndexer IWMIndexer;
#endif 	/* __IWMIndexer_FWD_DEFINED__ */


#ifndef __IWMLicenseBackup_FWD_DEFINED__
#define __IWMLicenseBackup_FWD_DEFINED__
typedef interface IWMLicenseBackup IWMLicenseBackup;
#endif 	/* __IWMLicenseBackup_FWD_DEFINED__ */


#ifndef __IWMLicenseRestore_FWD_DEFINED__
#define __IWMLicenseRestore_FWD_DEFINED__
typedef interface IWMLicenseRestore IWMLicenseRestore;
#endif 	/* __IWMLicenseRestore_FWD_DEFINED__ */


#ifndef __IWMBackupRestoreProps_FWD_DEFINED__
#define __IWMBackupRestoreProps_FWD_DEFINED__
typedef interface IWMBackupRestoreProps IWMBackupRestoreProps;
#endif 	/* __IWMBackupRestoreProps_FWD_DEFINED__ */


#ifndef __IWMCodecInfo_FWD_DEFINED__
#define __IWMCodecInfo_FWD_DEFINED__
typedef interface IWMCodecInfo IWMCodecInfo;
#endif 	/* __IWMCodecInfo_FWD_DEFINED__ */


#ifndef __IWMCodecInfo2_FWD_DEFINED__
#define __IWMCodecInfo2_FWD_DEFINED__
typedef interface IWMCodecInfo2 IWMCodecInfo2;
#endif 	/* __IWMCodecInfo2_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "wmsbuffer.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_wmsdkidl_0000_0000 */
/* [local] */ 

//=========================================================================
//
//  THIS SOFTWARE HAS BEEN LICENSED FROM MICROSOFT CORPORATION PURSUANT 
//  TO THE TERMS OF AN END USER LICENSE AGREEMENT ("EULA").  
//  PLEASE REFER TO THE TEXT OF THE EULA TO DETERMINE THE RIGHTS TO USE THE SOFTWARE.  
//
// Copyright (C) Microsoft Corporation, 1999 - 1999  All Rights Reserved.
//
//=========================================================================
typedef unsigned __int64 QWORD;






























////////////////////////////////////////////////////////////////
//
// These are the special case attributes that give information 
// about the Windows Media file.
//
static const DWORD g_dwWMSpecialAttributes = 14;
static const WCHAR *g_wszWMDuration = L"Duration";
static const WCHAR *g_wszWMBitrate = L"Bitrate";
static const WCHAR *g_wszWMSeekable = L"Seekable";
static const WCHAR *g_wszWMStridable = L"Stridable";
static const WCHAR *g_wszWMBroadcast = L"Broadcast";
static const WCHAR *g_wszWMProtected = L"Is_Protected";
static const WCHAR *g_wszWMTrusted = L"Is_Trusted";
static const WCHAR *g_wszWMSignature_Name = L"Signature_Name";
static const WCHAR *g_wszWMHasAudio = L"HasAudio";
static const WCHAR *g_wszWMHasImage = L"HasImage";
static const WCHAR *g_wszWMHasScript = L"HasScript";
static const WCHAR *g_wszWMHasVideo = L"HasVideo";
static const WCHAR *g_wszWMCurrentBitrate = L"CurrentBitrate";
static const WCHAR *g_wszWMOptimalBitrate = L"OptimalBitrate";

////////////////////////////////////////////////////////////////
//
// The content description object supports 5 basic attributes.
//
static const DWORD g_dwWMContentAttributes = 5;
static const WCHAR *g_wszWMTitle = L"Title";
static const WCHAR *g_wszWMAuthor = L"Author";
static const WCHAR *g_wszWMDescription = L"Description";
static const WCHAR *g_wszWMRating = L"Rating";
static const WCHAR *g_wszWMCopyright = L"Copyright";

////////////////////////////////////////////////////////////////
//
// These attributes are used to set DRM properties.
//
static const WCHAR *g_wszWMUse_DRM = L"Use_DRM";
static const WCHAR *g_wszWMDRM_Flags = L"DRM_Flags";
static const WCHAR *g_wszWMDRM_Level = L"DRM_Level";

////////////////////////////////////////////////////////////////
//
// These are the additional attributes defined in the WM attribute
// namespace that give information about the content.
//
static const WCHAR *g_wszWMAlbumTitle = L"WM/AlbumTitle";
static const WCHAR *g_wszWMTrack = L"WM/Track";
static const WCHAR *g_wszWMPromotionURL = L"WM/PromotionURL";
static const WCHAR *g_wszWMAlbumCoverURL = L"WM/AlbumCoverURL";
static const WCHAR *g_wszWMGenre = L"WM/Genre";
static const WCHAR *g_wszWMYear = L"WM/Year";
static const WCHAR *g_wszWMGenreID = L"WM/GenreID";
static const WCHAR *g_wszWMMCDI = L"WM/MCDI";

////////////////////////////////////////////////////////////////
//
// These optional attributes may be used to give information 
// about the branding of the content.
//
static const WCHAR *g_wszWMBannerImageType = L"BannerImageType";
static const WCHAR *g_wszWMBannerImageData = L"BannerImageData";
static const WCHAR *g_wszWMBannerImageURL = L"BannerImageURL";
static const WCHAR *g_wszWMCopyrightURL = L"CopyrightURL";
////////////////////////////////////////////////////////////////
//
// The NSC file supports the following attributes.
//
static const DWORD g_dwWMNSCAttributes = 5;
static const WCHAR *g_wszWMNSCName = L"NSC_Name";
static const WCHAR *g_wszWMNSCAddress = L"NSC_Address";
static const WCHAR *g_wszWMNSCPhone = L"NSC_Phone";
static const WCHAR *g_wszWMNSCEmail = L"NSC_Email";
static const WCHAR *g_wszWMNSCDescription = L"NSC_Description";

////////////////////////////////////////////////////////////////
//
// These are setting names for use in Get/SetOutputSetting
//
static const WCHAR *g_wszEarlyDataDelivery = L"EarlyDataDelivery";
static const WCHAR *g_wszJustInTimeDecode = L"JustInTimeDecode";
static const WCHAR *g_wszSingleOutputBuffer = L"SingleOutputBuffer";
static const WCHAR *g_wszSoftwareScaling = L"SoftwareScaling";

////////////////////////////////////////////////////////////////
//
// These are setting names for use in Get/SetInputSetting
//
static const WCHAR *g_wszDeinterlaceMode = L"DeinterlaceMode";

////////////////////////////////////////////////////////////////
//
// Flags that can be passed into the Start method of IWMReader
//
#define WM_START_CURRENTPOSITION     ( ( QWORD )-1 )

#define WM_BACKUP_OVERWRITE    ((DWORD) 0x00000001)
#define WM_RESTORE_INDIVIDUALIZE    ((DWORD) 0x00000002)
#define WAVE_FORMAT_DRM            0x0009

enum __MIDL___MIDL_itf_wmsdkidl_0000_0000_0001
    {	WM_SF_CLEANPOINT	= 0x1,
	WM_SF_DISCONTINUITY	= 0x2,
	WM_SF_DATALOSS	= 0x4
    } ;

enum __MIDL___MIDL_itf_wmsdkidl_0000_0000_0002
    {	WM_SFEX_NOTASYNCPOINT	= 0x2,
	WM_SFEX_DATALOSS	= 0x4
    } ;
typedef 
enum WMT_STATUS
    {	WMT_ERROR	= 0,
	WMT_OPENED	= 1,
	WMT_BUFFERING_START	= 2,
	WMT_BUFFERING_STOP	= 3,
	WMT_EOF	= 4,
	WMT_END_OF_FILE	= 4,
	WMT_END_OF_SEGMENT	= 5,
	WMT_END_OF_STREAMING	= 6,
	WMT_LOCATING	= 7,
	WMT_CONNECTING	= 8,
	WMT_NO_RIGHTS	= 9,
	WMT_MISSING_CODEC	= 10,
	WMT_STARTED	= 11,
	WMT_STOPPED	= 12,
	WMT_CLOSED	= 13,
	WMT_STRIDING	= 14,
	WMT_TIMER	= 15,
	WMT_INDEX_PROGRESS	= 16,
	WMT_SAVEAS_START	= 17,
	WMT_SAVEAS_STOP	= 18,
	WMT_NEW_SOURCEFLAGS	= 19,
	WMT_NEW_METADATA	= 20,
	WMT_BACKUPRESTORE_BEGIN	= 21,
	WMT_SOURCE_SWITCH	= 22,
	WMT_ACQUIRE_LICENSE	= 23,
	WMT_INDIVIDUALIZE	= 24,
	WMT_NEEDS_INDIVIDUALIZATION	= 25,
	WMT_NO_RIGHTS_EX	= 26,
	WMT_BACKUPRESTORE_END	= 27,
	WMT_BACKUPRESTORE_CONNECTING	= 28,
	WMT_BACKUPRESTORE_DISCONNECTING	= 29,
	WMT_ERROR_WITHURL	= 30,
	WMT_RESTRICTED_LICENSE	= 31,
	WMT_CLIENT_CONNECT	= 32,
	WMT_CLIENT_DISCONNECT	= 33
    } 	WMT_STATUS;

typedef 
enum WMT_RIGHTS
    {	WMT_RIGHT_PLAYBACK	= 0x1,
	WMT_RIGHT_COPY_TO_NON_SDMI_DEVICE	= 0x2,
	WMT_RIGHT_COPY_TO_CD	= 0x8,
	WMT_RIGHT_COPY_TO_SDMI_DEVICE	= 0x10,
	WMT_RIGHT_ONE_TIME	= 0x20,
	WMT_RIGHT_SDMI_TRIGGER	= 0x10000,
	WMT_RIGHT_SDMI_NOMORECOPIES	= 0x20000
    } 	WMT_RIGHTS;

typedef 
enum WMT_STREAM_SELECTION
    {	WMT_OFF	= 0,
	WMT_CLEANPOINT_ONLY	= 1,
	WMT_ON	= 2
    } 	WMT_STREAM_SELECTION;

typedef 
enum WMT_ATTR_DATATYPE
    {	WMT_TYPE_DWORD	= 0,
	WMT_TYPE_STRING	= 1,
	WMT_TYPE_BINARY	= 2,
	WMT_TYPE_BOOL	= 3,
	WMT_TYPE_QWORD	= 4,
	WMT_TYPE_WORD	= 5,
	WMT_TYPE_GUID	= 6
    } 	WMT_ATTR_DATATYPE;

typedef 
enum WMT_ATTR_IMAGETYPE
    {	WMT_IMAGETYPE_BITMAP	= 1,
	WMT_IMAGETYPE_JPEG	= 2,
	WMT_IMAGETYPE_GIF	= 3
    } 	WMT_ATTR_IMAGETYPE;

typedef 
enum WMT_VERSION
    {	WMT_VER_4_0	= 0x40000,
	WMT_VER_7_0	= 0x70000
    } 	WMT_VERSION;

typedef 
enum WMT_NET_PROTOCOL
    {	WMT_PROTOCOL_HTTP	= 0
    } 	WMT_NET_PROTOCOL;

typedef 
enum WMT_PLAY_MODE
    {	WMT_PLAY_MODE_AUTOSELECT	= 0,
	WMT_PLAY_MODE_LOCAL	= 1,
	WMT_PLAY_MODE_DOWNLOAD	= 2,
	WMT_PLAY_MODE_STREAMING	= 3
    } 	WMT_PLAY_MODE;

typedef 
enum WMT_PROXY_SETTINGS
    {	WMT_PROXY_SETTING_NONE	= 0,
	WMT_PROXY_SETTING_MANUAL	= 1,
	WMT_PROXY_SETTING_AUTO	= 2,
	WMT_PROXY_SETTING_BROWSER	= 3
    } 	WMT_PROXY_SETTINGS;

typedef 
enum WMT_CODEC_INFO_TYPE
    {	WMT_CODECINFO_AUDIO	= 0,
	WMT_CODECINFO_VIDEO	= 1,
	WMT_CODECINFO_UNKNOWN	= 0xffffffff
    } 	WMT_CODEC_INFO_TYPE;

typedef 
enum DRM_HTTP_STATUS
    {	HTTP_NOTINITIATED	= 0,
	HTTP_CONNECTING	= ( HTTP_NOTINITIATED + 1 ) ,
	HTTP_REQUESTING	= ( HTTP_CONNECTING + 1 ) ,
	HTTP_RECEIVING	= ( HTTP_REQUESTING + 1 ) ,
	HTTP_COMPLETED	= ( HTTP_RECEIVING + 1 ) 
    } 	DRM_HTTP_STATUS;

typedef 
enum DRM_INDIVIDUALIZATION_STATUS
    {	INDI_UNDEFINED	= 0,
	INDI_BEGIN	= 0x1,
	INDI_SUCCEED	= 0x2,
	INDI_FAIL	= 0x4,
	INDI_CANCEL	= 0x8,
	INDI_DOWNLOAD	= 0x10,
	INDI_INSTALL	= 0x20
    } 	DRM_INDIVIDUALIZATION_STATUS;


enum __MIDL___MIDL_itf_wmsdkidl_0000_0000_0003
    {	WM_DM_NOTINTERLACED	= 0,
	WM_DM_DEINTERLACE_NORMAL	= 1,
	WM_DM_DEINTERLACE_HALFSIZE	= 2,
	WM_DM_DEINTERLACE_HALFSIZEDOUBLERATE	= 3,
	WM_DM_DEINTERLACE_INVERSETELECINE	= 4,
	WM_DM_DEINTERLACE_VERTICALHALFSIZEDOUBLERATE	= 5
    } ;
typedef struct _WMWriterStatistics
    {
    QWORD qwSampleCount;
    QWORD qwByteCount;
    QWORD qwDroppedSampleCount;
    QWORD qwDroppedByteCount;
    DWORD dwCurrentBitrate;
    DWORD dwAverageBitrate;
    DWORD dwExpectedBitrate;
    DWORD dwCurrentSampleRate;
    DWORD dwAverageSampleRate;
    DWORD dwExpectedSampleRate;
    } 	WM_WRITER_STATISTICS;

typedef struct _WMReaderStatistics
    {
    DWORD cbSize;
    DWORD dwBandwidth;
    DWORD cPacketsReceived;
    DWORD cPacketsRecovered;
    DWORD cPacketsLost;
    WORD wQuality;
    } 	WM_READER_STATISTICS;

typedef struct _WMReaderClientInfo
    {
    DWORD cbSize;
    WCHAR *wszLang;
    WCHAR *wszBrowserUserAgent;
    WCHAR *wszBrowserWebPage;
    QWORD qwReserved;
    LPARAM *pReserved;
    WCHAR *wszHostExe;
    QWORD qwHostVersion;
    } 	WM_READER_CLIENTINFO;

typedef struct _WMIndividualizeStatus
    {
    HRESULT hr;
    DRM_INDIVIDUALIZATION_STATUS enIndiStatus;
    LPSTR pszIndiRespUrl;
    DWORD dwHTTPRequest;
    DRM_HTTP_STATUS enHTTPStatus;
    DWORD dwHTTPReadProgress;
    DWORD dwHTTPReadTotal;
    } 	WM_INDIVIDUALIZE_STATUS;

typedef struct _WMGetLicenseData
    {
    DWORD dwSize;
    HRESULT hr;
    WCHAR *wszURL;
    WCHAR *wszLocalFilename;
    BYTE *pbPostData;
    DWORD dwPostDataSize;
    } 	WM_GET_LICENSE_DATA;

typedef struct _WMClientProperties
    {
    DWORD dwIPAddress;
    DWORD dwPort;
    } 	WM_CLIENT_PROPERTIES;

typedef struct _WMPortNumberRange
    {
    WORD wPortBegin;
    WORD wPortEnd;
    } 	WM_PORT_NUMBER_RANGE;

typedef struct _WMMediaType
    {
    GUID majortype;
    GUID subtype;
    BOOL bFixedSizeSamples;
    BOOL bTemporalCompression;
    ULONG lSampleSize;
    GUID formattype;
    IUnknown *pUnk;
    ULONG cbFormat;
    BYTE *pbFormat;
    } 	WM_MEDIA_TYPE;

typedef struct tagWMVIDEOINFOHEADER
{
    //
    // The bit we really want to use.
    //
    RECT rcSource;

    //
    // Where the video should go.
    //
    RECT rcTarget;

    //
    // Approximate bit data rate.
    //
    DWORD dwBitRate;

    //
    // Bit error rate for this stream.
    //
    DWORD dwBitErrorRate;

    //
    // Average time per frame (100ns units).
    //
    LONGLONG AvgTimePerFrame;

    BITMAPINFOHEADER bmiHeader;
} WMVIDEOINFOHEADER;
typedef struct tagWMSCRIPTFORMAT
{
    GUID    scriptType; 
} WMSCRIPTFORMAT;
// 00000000-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_Base 
EXTERN_GUID(WMMEDIASUBTYPE_Base, 
0x00000000, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 73646976-0000-0010-8000-00AA00389B71  'vids' == WMMEDIATYPE_Video 
EXTERN_GUID(WMMEDIATYPE_Video, 
0x73646976, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// e436eb78-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB1 
EXTERN_GUID(WMMEDIASUBTYPE_RGB1, 
0xe436eb78, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); 
// e436eb79-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB4 
EXTERN_GUID(WMMEDIASUBTYPE_RGB4, 
0xe436eb79, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); 
// e436eb7a-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB8 
EXTERN_GUID(WMMEDIASUBTYPE_RGB8, 
0xe436eb7a, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); 
// e436eb7b-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB565 
EXTERN_GUID(WMMEDIASUBTYPE_RGB565, 
0xe436eb7b, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); 
// e436eb7c-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB555 
EXTERN_GUID(WMMEDIASUBTYPE_RGB555, 
0xe436eb7c, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); 
// e436eb7d-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB24 
EXTERN_GUID(WMMEDIASUBTYPE_RGB24, 
0xe436eb7d, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); 
// e436eb7e-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB32 
EXTERN_GUID(WMMEDIASUBTYPE_RGB32, 
0xe436eb7e, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); 
// 30323449-0000-0010-8000-00AA00389B71  'YV12' ==  MEDIASUBTYPE_I420 
EXTERN_GUID(WMMEDIASUBTYPE_I420, 
0x30323449, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 56555949-0000-0010-8000-00AA00389B71  'YV12' ==  MEDIASUBTYPE_IYUV 
EXTERN_GUID(WMMEDIASUBTYPE_IYUV, 
0x56555949, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 32313259-0000-0010-8000-00AA00389B71  'YV12' ==  MEDIASUBTYPE_YV12 
EXTERN_GUID(WMMEDIASUBTYPE_YV12, 
0x32315659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 36313259-0000-0010-8000-00AA00389B71  'YV16' ==  MEDIASUBTYPE_YV16 
EXTERN_GUID(WMMEDIASUBTYPE_YV16, 
0x36315659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 32595559-0000-0010-8000-00AA00389B71  'YUY2' == MEDIASUBTYPE_YUY2 
EXTERN_GUID(WMMEDIASUBTYPE_YUY2, 
0x32595559, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 59565955-0000-0010-8000-00AA00389B71  'UYVY' ==  MEDIASUBTYPE_UYVY 
EXTERN_GUID(WMMEDIASUBTYPE_UYVY, 
0x59565955, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 55595659-0000-0010-8000-00AA00389B71  'YVYU' == MEDIASUBTYPE_YVYU 
EXTERN_GUID(WMMEDIASUBTYPE_YVYU, 
0x55595659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 39555659-0000-0010-8000-00AA00389B71  'YVU9' == MEDIASUBTYPE_YVU9 
EXTERN_GUID(WMMEDIASUBTYPE_YVU9, 
0x39555659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 3334504D-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_MP43 
EXTERN_GUID(WMMEDIASUBTYPE_MP43, 
0x3334504D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 5334504D-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_MP4S 
EXTERN_GUID(WMMEDIASUBTYPE_MP4S, 
0x5334504D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 31564D57-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_WMV1 
EXTERN_GUID(WMMEDIASUBTYPE_WMV1, 
0x31564D57, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 3153534D-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_MSS1 
EXTERN_GUID(WMMEDIASUBTYPE_MSS1, 
0x3153534D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 73647561-0000-0010-8000-00AA00389B71  'auds' == WMMEDIATYPE_Audio 
EXTERN_GUID(WMMEDIATYPE_Audio, 
0x73647561, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 00000001-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_PCM 
EXTERN_GUID(WMMEDIASUBTYPE_PCM, 
0x00000001, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 00000009-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_DRM 
EXTERN_GUID(WMMEDIASUBTYPE_DRM, 
0x00000009, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 00000161-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_WMAudioV7 
EXTERN_GUID(WMMEDIASUBTYPE_WMAudioV7, 
0x00000161, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 00000161-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_WMAudioV2 
EXTERN_GUID(WMMEDIASUBTYPE_WMAudioV2, 
0x00000161, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 00000130-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_ACELPnet 
EXTERN_GUID(WMMEDIASUBTYPE_ACELPnet, 
0x00000130, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); 
// 73636d64-0000-0010-8000-00AA00389B71  'scmd' == MEDIATYPE_Script 
EXTERN_GUID(WMMEDIATYPE_Script, 
0x73636d64, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); 
// 34A50FD8-8AA5-4386-81FE-A0EFE0488E31            WMMEDIATYPE_Image 
EXTERN_GUID(WMMEDIATYPE_Image, 
0x34a50fd8, 0x8aa5, 0x4386, 0x81, 0xfe, 0xa0, 0xef, 0xe0, 0x48, 0x8e, 0x31); 
// 05589f80-c356-11ce-bf01-00aa0055595a        WMFORMAT_VideoInfo 
EXTERN_GUID(WMFORMAT_VideoInfo, 
0x05589f80, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a); 
// 05589f81-c356-11ce-bf01-00aa0055595a        WMFORMAT_WaveFormatEx 
EXTERN_GUID(WMFORMAT_WaveFormatEx, 
0x05589f81, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a); 
// 5C8510F2-DEBE-4ca7-BBA5-F07A104F8DFF        WMFORMAT_Script 
EXTERN_GUID(WMFORMAT_Script, 
0x5c8510f2, 0xdebe, 0x4ca7, 0xbb, 0xa5, 0xf0, 0x7a, 0x10, 0x4f, 0x8d, 0xff); 
// 82f38a70-c29f-11d1-97ad-00a0c95ea850        WMSCRIPTTYPE_TwoStrings 
EXTERN_GUID( WMSCRIPTTYPE_TwoStrings, 
0x82f38a70,0xc29f,0x11d1,0x97,0xad,0x00,0xa0,0xc9,0x5e,0xa8,0x50); 
EXTERN_GUID( IID_IWMMediaProps,         0x96406bce,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMVideoMediaProps,    0x96406bcf,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMWriter,             0x96406bd4,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMInputMediaProps,    0x96406bd5,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMReader,             0x96406bd6,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMOutputMediaProps,   0x96406bd7,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMStatusCallback,     0x6d7cdc70,0x9888,0x11d3,0x8e,0xdc,0x00,0xc0,0x4f,0x61,0x09,0xcf );
EXTERN_GUID( IID_IWMReaderCallback,     0x96406bd8,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMCredentialCallback, 0x342e0eb7,0xe651,0x450c,0x97,0x5b,0x2a,0xce,0x2c,0x90,0xc4,0x8e );
EXTERN_GUID( IID_IWMMetadataEditor,     0x96406bd9,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMHeaderInfo,         0x96406bda,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMHeaderInfo2,        0x15cf9781,0x454e,0x482e,0xb3,0x93,0x85,0xfa,0xe4,0x87,0xa8,0x10 );
EXTERN_GUID( IID_IWMHeaderInfo3,        0x15CC68E3,0x27CC,0x4ecd,0xB2,0x22,0x3F,0x5D,0x02,0xD8,0x0B,0xD5 );
EXTERN_GUID( IID_IWMProfileManager,     0xd16679f2,0x6ca0,0x472d,0x8d,0x31,0x2f,0x5d,0x55,0xae,0xe1,0x55 );
EXTERN_GUID( IID_IWMProfileManager2,    0x7a924e51,0x73c1,0x494d,0x80,0x19,0x23,0xd3,0x7e,0xd9,0xb8,0x9a );
EXTERN_GUID( IID_IWMProfile,            0x96406bdb,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMProfile2,           0x07e72d33,0xd94e,0x4be7,0x88,0x43,0x60,0xae,0x5f,0xf7,0xe5,0xf5 );
EXTERN_GUID( IID_IWMStreamConfig,       0x96406bdc,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMStreamList,         0x96406bdd,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMMutualExclusion,    0x96406bde,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMWriterAdvanced,     0x96406be3,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMWriterAdvanced2,    0x962dc1ec,0xc046,0x4db8,0x9c,0xc7,0x26,0xce,0xae,0x50,0x08,0x17 );
EXTERN_GUID( IID_IWMWriterSink,         0x96406be4,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMWriterFileSink,     0x96406be5,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMWriterFileSink2,    0x14282ba7,0x4aef,0x4205,0x8c,0xe5,0xc2,0x29,0x03,0x5a,0x05,0xbc );
EXTERN_GUID( IID_IWMWriterNetworkSink,  0x96406be7,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMClientConnections,  0x73c66010,0xa299,0x41df,0xb1,0xf0,0xcc,0xf0,0x3b,0x09,0xc1,0xc6 );
EXTERN_GUID( IID_IWMReaderAdvanced,     0x96406bea,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMReaderAdvanced2,    0xae14a945,0xb90c,0x4d0d,0x91,0x27,0x80,0xd6,0x65,0xf7,0xd7,0x3e );
EXTERN_GUID( IID_IWMDRMReader,          0xd2827540,0x3ee7,0x432c,0xb1,0x4c,0xdc,0x17,0xf0,0x85,0xd3,0xb3 );
EXTERN_GUID( IID_IWMReaderCallbackAdvanced, 0x96406beb,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMReaderNetworkConfig,0x96406bec,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMReaderStreamClock,  0x96406bed,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );
EXTERN_GUID( IID_IWMIndexer,            0x6d7cdc71,0x9888,0x11d3,0x8e,0xdc,0x00,0xc0,0x4f,0x61,0x09,0xcf );
EXTERN_GUID( IID_IWMReaderAllocatorEx,  0x9f762fa7,0xa22e,0x428d,0x93,0xc9,0xac,0x82,0xf3,0xaa,0xfe,0x5a );
EXTERN_GUID( IID_IWMReaderTypeNegotiation, 0xfdbe5592,0x81a1,0x41ea,0x93,0xbd,0x73,0x5c,0xad,0x1a,0xdc,0x5 );
EXTERN_GUID( IID_IWMLicenseBackup,      0x05E5AC9F,0x3FB6,0x4508,0xBB,0x43,0xA4,0x06,0x7B,0xA1,0xEB,0xE8);
EXTERN_GUID( IID_IWMLicenseRestore,     0xC70B6334,0xa22e,0x4efb,0xA2,0x45,0x15,0xE6,0x5A,0x00,0x4A,0x13);
EXTERN_GUID( IID_IWMBackupRestoreProps, 0x3C8E0DA6,0x996F,0x4ff3,0xA1,0xAF,0x48,0x38,0xF9,0x37,0x7e,0x2e);
EXTERN_GUID( IID_IWMPacketSize,         0xcdfb97ab,0x188f,0x40b3,0xb6,0x43,0x5b,0x79,0x03,0x97,0x5c,0x59);
EXTERN_GUID( IID_IWMRegisterCallback,   0xcf4b1f99,0x4de2,0x4e49,0xa3,0x63,0x25,0x27,0x40,0xd9,0x9b,0xc1);
EXTERN_GUID( IID_IWMWriterPostView,     0x81e20ce4,0x75ef,0x491a,0x80,0x04,0xfc,0x53,0xc4,0x5b,0xdc,0x3e);
EXTERN_GUID( IID_IWMWriterPostViewCallback, 0xd9d6549d,0xa193,0x4f24,0xb3,0x08,0x03,0x12,0x3d,0x9b,0x7f,0x8d);
EXTERN_GUID( IID_IWMCodecInfo,          0xa970f41e,0x34de,0x4a98,0xb3,0xba,0xe4,0xb3,0xca,0x75,0x28,0xf0);
EXTERN_GUID( IID_IWMCodecInfo2,         0xaa65e273,0xb686,0x4056,0x91,0xec,0xdd,0x76,0x8d,0x4d,0xf7,0x10);
EXTERN_GUID( CLSID_WMMUTEX_Bitrate, 0xD6E22A01,0x35DA,0x11D1,0x90,0x34,0x00,0xA0,0xC9,0x03,0x49,0xBE );
#define WM_MAX_VIDEO_STREAMS            0x00c
HRESULT STDMETHODCALLTYPE WMCreateCertificate( IUnknown** pUnkCert );
HRESULT STDMETHODCALLTYPE WMCreateWriter( IUnknown* pUnkCert, IWMWriter **ppWriter );
HRESULT STDMETHODCALLTYPE WMCreateReader( IUnknown* pUnkCert, DWORD dwRights, IWMReader **ppReader );
HRESULT STDMETHODCALLTYPE WMCreateEditor( IWMMetadataEditor **ppEditor );
HRESULT STDMETHODCALLTYPE WMCreateIndexer( IWMIndexer **ppIndexer );
HRESULT STDMETHODCALLTYPE WMCreateBackupRestorer( IUnknown *pCallback, IWMLicenseBackup **ppBackup );
HRESULT STDMETHODCALLTYPE WMCreateProfileManager( IWMProfileManager **ppProfileManager );
HRESULT STDMETHODCALLTYPE WMCreateWriterFileSink( IWMWriterFileSink **ppSink );
HRESULT STDMETHODCALLTYPE WMCreateWriterNetworkSink( IWMWriterNetworkSink **ppSink );


extern RPC_IF_HANDLE __MIDL_itf_wmsdkidl_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmsdkidl_0000_0000_v0_0_s_ifspec;

#ifndef __IWMMediaProps_INTERFACE_DEFINED__
#define __IWMMediaProps_INTERFACE_DEFINED__

/* interface IWMMediaProps */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMMediaProps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BCE-2B2B-11d3-B36B-00C04F6108FF")
    IWMMediaProps : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ GUID *pguidType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMediaType( 
            /* [out] */ WM_MEDIA_TYPE *pType,
            /* [out][in] */ DWORD *pcbType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMediaType( 
            /* [in] */ WM_MEDIA_TYPE *pType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMMediaPropsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMMediaProps * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMMediaProps * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMMediaProps * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            IWMMediaProps * This,
            /* [out] */ GUID *pguidType);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaType )( 
            IWMMediaProps * This,
            /* [out] */ WM_MEDIA_TYPE *pType,
            /* [out][in] */ DWORD *pcbType);
        
        HRESULT ( STDMETHODCALLTYPE *SetMediaType )( 
            IWMMediaProps * This,
            /* [in] */ WM_MEDIA_TYPE *pType);
        
        END_INTERFACE
    } IWMMediaPropsVtbl;

    interface IWMMediaProps
    {
        CONST_VTBL struct IWMMediaPropsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMMediaProps_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMMediaProps_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMMediaProps_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMMediaProps_GetType(This,pguidType)	\
    ( (This)->lpVtbl -> GetType(This,pguidType) ) 

#define IWMMediaProps_GetMediaType(This,pType,pcbType)	\
    ( (This)->lpVtbl -> GetMediaType(This,pType,pcbType) ) 

#define IWMMediaProps_SetMediaType(This,pType)	\
    ( (This)->lpVtbl -> SetMediaType(This,pType) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMMediaProps_INTERFACE_DEFINED__ */


#ifndef __IWMVideoMediaProps_INTERFACE_DEFINED__
#define __IWMVideoMediaProps_INTERFACE_DEFINED__

/* interface IWMVideoMediaProps */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMVideoMediaProps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BCF-2B2B-11d3-B36B-00C04F6108FF")
    IWMVideoMediaProps : public IWMMediaProps
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMaxKeyFrameSpacing( 
            /* [out] */ LONGLONG *pllTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMaxKeyFrameSpacing( 
            /* [in] */ LONGLONG llTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetQuality( 
            /* [out] */ DWORD *pdwQuality) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetQuality( 
            /* [in] */ DWORD dwQuality) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMVideoMediaPropsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMVideoMediaProps * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMVideoMediaProps * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMVideoMediaProps * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            IWMVideoMediaProps * This,
            /* [out] */ GUID *pguidType);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaType )( 
            IWMVideoMediaProps * This,
            /* [out] */ WM_MEDIA_TYPE *pType,
            /* [out][in] */ DWORD *pcbType);
        
        HRESULT ( STDMETHODCALLTYPE *SetMediaType )( 
            IWMVideoMediaProps * This,
            /* [in] */ WM_MEDIA_TYPE *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxKeyFrameSpacing )( 
            IWMVideoMediaProps * This,
            /* [out] */ LONGLONG *pllTime);
        
        HRESULT ( STDMETHODCALLTYPE *SetMaxKeyFrameSpacing )( 
            IWMVideoMediaProps * This,
            /* [in] */ LONGLONG llTime);
        
        HRESULT ( STDMETHODCALLTYPE *GetQuality )( 
            IWMVideoMediaProps * This,
            /* [out] */ DWORD *pdwQuality);
        
        HRESULT ( STDMETHODCALLTYPE *SetQuality )( 
            IWMVideoMediaProps * This,
            /* [in] */ DWORD dwQuality);
        
        END_INTERFACE
    } IWMVideoMediaPropsVtbl;

    interface IWMVideoMediaProps
    {
        CONST_VTBL struct IWMVideoMediaPropsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMVideoMediaProps_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMVideoMediaProps_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMVideoMediaProps_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMVideoMediaProps_GetType(This,pguidType)	\
    ( (This)->lpVtbl -> GetType(This,pguidType) ) 

#define IWMVideoMediaProps_GetMediaType(This,pType,pcbType)	\
    ( (This)->lpVtbl -> GetMediaType(This,pType,pcbType) ) 

#define IWMVideoMediaProps_SetMediaType(This,pType)	\
    ( (This)->lpVtbl -> SetMediaType(This,pType) ) 


#define IWMVideoMediaProps_GetMaxKeyFrameSpacing(This,pllTime)	\
    ( (This)->lpVtbl -> GetMaxKeyFrameSpacing(This,pllTime) ) 

#define IWMVideoMediaProps_SetMaxKeyFrameSpacing(This,llTime)	\
    ( (This)->lpVtbl -> SetMaxKeyFrameSpacing(This,llTime) ) 

#define IWMVideoMediaProps_GetQuality(This,pdwQuality)	\
    ( (This)->lpVtbl -> GetQuality(This,pdwQuality) ) 

#define IWMVideoMediaProps_SetQuality(This,dwQuality)	\
    ( (This)->lpVtbl -> SetQuality(This,dwQuality) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMVideoMediaProps_INTERFACE_DEFINED__ */


#ifndef __IWMWriter_INTERFACE_DEFINED__
#define __IWMWriter_INTERFACE_DEFINED__

/* interface IWMWriter */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BD4-2B2B-11d3-B36B-00C04F6108FF")
    IWMWriter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetProfileByID( 
            /* [in] */ REFGUID guidProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProfile( 
            /* [in] */ IWMProfile *pProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOutputFilename( 
            /* [in] */ const WCHAR *pwszFilename) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInputCount( 
            /* [out] */ DWORD *pcInputs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInputProps( 
            /* [in] */ DWORD dwInputNum,
            /* [out] */ IWMInputMediaProps **ppInput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInputProps( 
            /* [in] */ DWORD dwInputNum,
            /* [in] */ IWMInputMediaProps *pInput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInputFormatCount( 
            /* [in] */ DWORD dwInputNumber,
            /* [out] */ DWORD *pcFormats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInputFormat( 
            /* [in] */ DWORD dwInputNumber,
            /* [in] */ DWORD dwFormatNumber,
            /* [out] */ IWMInputMediaProps **pProps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginWriting( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndWriting( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocateSample( 
            /* [in] */ DWORD dwSampleSize,
            /* [out] */ INSSBuffer **ppSample) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteSample( 
            /* [in] */ DWORD dwInputNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer *pSample) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Flush( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMWriter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMWriter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMWriter * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetProfileByID )( 
            IWMWriter * This,
            /* [in] */ REFGUID guidProfile);
        
        HRESULT ( STDMETHODCALLTYPE *SetProfile )( 
            IWMWriter * This,
            /* [in] */ IWMProfile *pProfile);
        
        HRESULT ( STDMETHODCALLTYPE *SetOutputFilename )( 
            IWMWriter * This,
            /* [in] */ const WCHAR *pwszFilename);
        
        HRESULT ( STDMETHODCALLTYPE *GetInputCount )( 
            IWMWriter * This,
            /* [out] */ DWORD *pcInputs);
        
        HRESULT ( STDMETHODCALLTYPE *GetInputProps )( 
            IWMWriter * This,
            /* [in] */ DWORD dwInputNum,
            /* [out] */ IWMInputMediaProps **ppInput);
        
        HRESULT ( STDMETHODCALLTYPE *SetInputProps )( 
            IWMWriter * This,
            /* [in] */ DWORD dwInputNum,
            /* [in] */ IWMInputMediaProps *pInput);
        
        HRESULT ( STDMETHODCALLTYPE *GetInputFormatCount )( 
            IWMWriter * This,
            /* [in] */ DWORD dwInputNumber,
            /* [out] */ DWORD *pcFormats);
        
        HRESULT ( STDMETHODCALLTYPE *GetInputFormat )( 
            IWMWriter * This,
            /* [in] */ DWORD dwInputNumber,
            /* [in] */ DWORD dwFormatNumber,
            /* [out] */ IWMInputMediaProps **pProps);
        
        HRESULT ( STDMETHODCALLTYPE *BeginWriting )( 
            IWMWriter * This);
        
        HRESULT ( STDMETHODCALLTYPE *EndWriting )( 
            IWMWriter * This);
        
        HRESULT ( STDMETHODCALLTYPE *AllocateSample )( 
            IWMWriter * This,
            /* [in] */ DWORD dwSampleSize,
            /* [out] */ INSSBuffer **ppSample);
        
        HRESULT ( STDMETHODCALLTYPE *WriteSample )( 
            IWMWriter * This,
            /* [in] */ DWORD dwInputNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer *pSample);
        
        HRESULT ( STDMETHODCALLTYPE *Flush )( 
            IWMWriter * This);
        
        END_INTERFACE
    } IWMWriterVtbl;

    interface IWMWriter
    {
        CONST_VTBL struct IWMWriterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMWriter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMWriter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMWriter_SetProfileByID(This,guidProfile)	\
    ( (This)->lpVtbl -> SetProfileByID(This,guidProfile) ) 

#define IWMWriter_SetProfile(This,pProfile)	\
    ( (This)->lpVtbl -> SetProfile(This,pProfile) ) 

#define IWMWriter_SetOutputFilename(This,pwszFilename)	\
    ( (This)->lpVtbl -> SetOutputFilename(This,pwszFilename) ) 

#define IWMWriter_GetInputCount(This,pcInputs)	\
    ( (This)->lpVtbl -> GetInputCount(This,pcInputs) ) 

#define IWMWriter_GetInputProps(This,dwInputNum,ppInput)	\
    ( (This)->lpVtbl -> GetInputProps(This,dwInputNum,ppInput) ) 

#define IWMWriter_SetInputProps(This,dwInputNum,pInput)	\
    ( (This)->lpVtbl -> SetInputProps(This,dwInputNum,pInput) ) 

#define IWMWriter_GetInputFormatCount(This,dwInputNumber,pcFormats)	\
    ( (This)->lpVtbl -> GetInputFormatCount(This,dwInputNumber,pcFormats) ) 

#define IWMWriter_GetInputFormat(This,dwInputNumber,dwFormatNumber,pProps)	\
    ( (This)->lpVtbl -> GetInputFormat(This,dwInputNumber,dwFormatNumber,pProps) ) 

#define IWMWriter_BeginWriting(This)	\
    ( (This)->lpVtbl -> BeginWriting(This) ) 

#define IWMWriter_EndWriting(This)	\
    ( (This)->lpVtbl -> EndWriting(This) ) 

#define IWMWriter_AllocateSample(This,dwSampleSize,ppSample)	\
    ( (This)->lpVtbl -> AllocateSample(This,dwSampleSize,ppSample) ) 

#define IWMWriter_WriteSample(This,dwInputNum,cnsSampleTime,dwFlags,pSample)	\
    ( (This)->lpVtbl -> WriteSample(This,dwInputNum,cnsSampleTime,dwFlags,pSample) ) 

#define IWMWriter_Flush(This)	\
    ( (This)->lpVtbl -> Flush(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMWriter_INTERFACE_DEFINED__ */


#ifndef __IWMInputMediaProps_INTERFACE_DEFINED__
#define __IWMInputMediaProps_INTERFACE_DEFINED__

/* interface IWMInputMediaProps */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMInputMediaProps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BD5-2B2B-11d3-B36B-00C04F6108FF")
    IWMInputMediaProps : public IWMMediaProps
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetConnectionName( 
            /* [out] */ WCHAR *pwszName,
            /* [out][in] */ WORD *pcchName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGroupName( 
            /* [out] */ WCHAR *pwszName,
            /* [out][in] */ WORD *pcchName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMInputMediaPropsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMInputMediaProps * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMInputMediaProps * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMInputMediaProps * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            IWMInputMediaProps * This,
            /* [out] */ GUID *pguidType);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaType )( 
            IWMInputMediaProps * This,
            /* [out] */ WM_MEDIA_TYPE *pType,
            /* [out][in] */ DWORD *pcbType);
        
        HRESULT ( STDMETHODCALLTYPE *SetMediaType )( 
            IWMInputMediaProps * This,
            /* [in] */ WM_MEDIA_TYPE *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetConnectionName )( 
            IWMInputMediaProps * This,
            /* [out] */ WCHAR *pwszName,
            /* [out][in] */ WORD *pcchName);
        
        HRESULT ( STDMETHODCALLTYPE *GetGroupName )( 
            IWMInputMediaProps * This,
            /* [out] */ WCHAR *pwszName,
            /* [out][in] */ WORD *pcchName);
        
        END_INTERFACE
    } IWMInputMediaPropsVtbl;

    interface IWMInputMediaProps
    {
        CONST_VTBL struct IWMInputMediaPropsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMInputMediaProps_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMInputMediaProps_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMInputMediaProps_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMInputMediaProps_GetType(This,pguidType)	\
    ( (This)->lpVtbl -> GetType(This,pguidType) ) 

#define IWMInputMediaProps_GetMediaType(This,pType,pcbType)	\
    ( (This)->lpVtbl -> GetMediaType(This,pType,pcbType) ) 

#define IWMInputMediaProps_SetMediaType(This,pType)	\
    ( (This)->lpVtbl -> SetMediaType(This,pType) ) 


#define IWMInputMediaProps_GetConnectionName(This,pwszName,pcchName)	\
    ( (This)->lpVtbl -> GetConnectionName(This,pwszName,pcchName) ) 

#define IWMInputMediaProps_GetGroupName(This,pwszName,pcchName)	\
    ( (This)->lpVtbl -> GetGroupName(This,pwszName,pcchName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMInputMediaProps_INTERFACE_DEFINED__ */


#ifndef __IWMReader_INTERFACE_DEFINED__
#define __IWMReader_INTERFACE_DEFINED__

/* interface IWMReader */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BD6-2B2B-11d3-B36B-00C04F6108FF")
    IWMReader : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ const WCHAR *pwszURL,
            /* [in] */ IWMReaderCallback *pCallback,
            /* [in] */ void *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputCount( 
            /* [out] */ DWORD *pcOutputs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputProps( 
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ IWMOutputMediaProps **ppOutput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOutputProps( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ IWMOutputMediaProps *pOutput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputFormatCount( 
            /* [in] */ DWORD dwOutputNumber,
            /* [out] */ DWORD *pcFormats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputFormat( 
            /* [in] */ DWORD dwOutputNumber,
            /* [in] */ DWORD dwFormatNumber,
            /* [out] */ IWMOutputMediaProps **ppProps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Start( 
            /* [in] */ QWORD cnsStart,
            /* [in] */ QWORD cnsDuration,
            /* [in] */ float fRate,
            /* [in] */ void *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMReader * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMReader * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *Open )( 
            IWMReader * This,
            /* [in] */ const WCHAR *pwszURL,
            /* [in] */ IWMReaderCallback *pCallback,
            /* [in] */ void *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            IWMReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputCount )( 
            IWMReader * This,
            /* [out] */ DWORD *pcOutputs);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputProps )( 
            IWMReader * This,
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ IWMOutputMediaProps **ppOutput);
        
        HRESULT ( STDMETHODCALLTYPE *SetOutputProps )( 
            IWMReader * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ IWMOutputMediaProps *pOutput);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputFormatCount )( 
            IWMReader * This,
            /* [in] */ DWORD dwOutputNumber,
            /* [out] */ DWORD *pcFormats);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputFormat )( 
            IWMReader * This,
            /* [in] */ DWORD dwOutputNumber,
            /* [in] */ DWORD dwFormatNumber,
            /* [out] */ IWMOutputMediaProps **ppProps);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            IWMReader * This,
            /* [in] */ QWORD cnsStart,
            /* [in] */ QWORD cnsDuration,
            /* [in] */ float fRate,
            /* [in] */ void *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IWMReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IWMReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IWMReader * This);
        
        END_INTERFACE
    } IWMReaderVtbl;

    interface IWMReader
    {
        CONST_VTBL struct IWMReaderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReader_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMReader_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMReader_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMReader_Open(This,pwszURL,pCallback,pvContext)	\
    ( (This)->lpVtbl -> Open(This,pwszURL,pCallback,pvContext) ) 

#define IWMReader_Close(This)	\
    ( (This)->lpVtbl -> Close(This) ) 

#define IWMReader_GetOutputCount(This,pcOutputs)	\
    ( (This)->lpVtbl -> GetOutputCount(This,pcOutputs) ) 

#define IWMReader_GetOutputProps(This,dwOutputNum,ppOutput)	\
    ( (This)->lpVtbl -> GetOutputProps(This,dwOutputNum,ppOutput) ) 

#define IWMReader_SetOutputProps(This,dwOutputNum,pOutput)	\
    ( (This)->lpVtbl -> SetOutputProps(This,dwOutputNum,pOutput) ) 

#define IWMReader_GetOutputFormatCount(This,dwOutputNumber,pcFormats)	\
    ( (This)->lpVtbl -> GetOutputFormatCount(This,dwOutputNumber,pcFormats) ) 

#define IWMReader_GetOutputFormat(This,dwOutputNumber,dwFormatNumber,ppProps)	\
    ( (This)->lpVtbl -> GetOutputFormat(This,dwOutputNumber,dwFormatNumber,ppProps) ) 

#define IWMReader_Start(This,cnsStart,cnsDuration,fRate,pvContext)	\
    ( (This)->lpVtbl -> Start(This,cnsStart,cnsDuration,fRate,pvContext) ) 

#define IWMReader_Stop(This)	\
    ( (This)->lpVtbl -> Stop(This) ) 

#define IWMReader_Pause(This)	\
    ( (This)->lpVtbl -> Pause(This) ) 

#define IWMReader_Resume(This)	\
    ( (This)->lpVtbl -> Resume(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMReader_INTERFACE_DEFINED__ */


#ifndef __IWMOutputMediaProps_INTERFACE_DEFINED__
#define __IWMOutputMediaProps_INTERFACE_DEFINED__

/* interface IWMOutputMediaProps */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMOutputMediaProps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BD7-2B2B-11d3-B36B-00C04F6108FF")
    IWMOutputMediaProps : public IWMMediaProps
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStreamGroupName( 
            /* [out] */ WCHAR *pwszName,
            /* [out][in] */ WORD *pcchName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConnectionName( 
            /* [out] */ WCHAR *pwszName,
            /* [out][in] */ WORD *pcchName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMOutputMediaPropsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMOutputMediaProps * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMOutputMediaProps * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMOutputMediaProps * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            IWMOutputMediaProps * This,
            /* [out] */ GUID *pguidType);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaType )( 
            IWMOutputMediaProps * This,
            /* [out] */ WM_MEDIA_TYPE *pType,
            /* [out][in] */ DWORD *pcbType);
        
        HRESULT ( STDMETHODCALLTYPE *SetMediaType )( 
            IWMOutputMediaProps * This,
            /* [in] */ WM_MEDIA_TYPE *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamGroupName )( 
            IWMOutputMediaProps * This,
            /* [out] */ WCHAR *pwszName,
            /* [out][in] */ WORD *pcchName);
        
        HRESULT ( STDMETHODCALLTYPE *GetConnectionName )( 
            IWMOutputMediaProps * This,
            /* [out] */ WCHAR *pwszName,
            /* [out][in] */ WORD *pcchName);
        
        END_INTERFACE
    } IWMOutputMediaPropsVtbl;

    interface IWMOutputMediaProps
    {
        CONST_VTBL struct IWMOutputMediaPropsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMOutputMediaProps_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMOutputMediaProps_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMOutputMediaProps_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMOutputMediaProps_GetType(This,pguidType)	\
    ( (This)->lpVtbl -> GetType(This,pguidType) ) 

#define IWMOutputMediaProps_GetMediaType(This,pType,pcbType)	\
    ( (This)->lpVtbl -> GetMediaType(This,pType,pcbType) ) 

#define IWMOutputMediaProps_SetMediaType(This,pType)	\
    ( (This)->lpVtbl -> SetMediaType(This,pType) ) 


#define IWMOutputMediaProps_GetStreamGroupName(This,pwszName,pcchName)	\
    ( (This)->lpVtbl -> GetStreamGroupName(This,pwszName,pcchName) ) 

#define IWMOutputMediaProps_GetConnectionName(This,pwszName,pcchName)	\
    ( (This)->lpVtbl -> GetConnectionName(This,pwszName,pcchName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMOutputMediaProps_INTERFACE_DEFINED__ */


#ifndef __IWMStatusCallback_INTERFACE_DEFINED__
#define __IWMStatusCallback_INTERFACE_DEFINED__

/* interface IWMStatusCallback */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMStatusCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6d7cdc70-9888-11d3-8edc-00c04f6109cf")
    IWMStatusCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnStatus( 
            /* [in] */ WMT_STATUS Status,
            /* [in] */ HRESULT hr,
            /* [in] */ WMT_ATTR_DATATYPE dwType,
            /* [in] */ BYTE *pValue,
            /* [in] */ void *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMStatusCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMStatusCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMStatusCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMStatusCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnStatus )( 
            IWMStatusCallback * This,
            /* [in] */ WMT_STATUS Status,
            /* [in] */ HRESULT hr,
            /* [in] */ WMT_ATTR_DATATYPE dwType,
            /* [in] */ BYTE *pValue,
            /* [in] */ void *pvContext);
        
        END_INTERFACE
    } IWMStatusCallbackVtbl;

    interface IWMStatusCallback
    {
        CONST_VTBL struct IWMStatusCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMStatusCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMStatusCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMStatusCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMStatusCallback_OnStatus(This,Status,hr,dwType,pValue,pvContext)	\
    ( (This)->lpVtbl -> OnStatus(This,Status,hr,dwType,pValue,pvContext) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMStatusCallback_INTERFACE_DEFINED__ */


#ifndef __IWMReaderCallback_INTERFACE_DEFINED__
#define __IWMReaderCallback_INTERFACE_DEFINED__

/* interface IWMReaderCallback */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BD8-2B2B-11d3-B36B-00C04F6108FF")
    IWMReaderCallback : public IWMStatusCallback
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnSample( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer *pSample,
            /* [in] */ void *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMReaderCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMReaderCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMReaderCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnStatus )( 
            IWMReaderCallback * This,
            /* [in] */ WMT_STATUS Status,
            /* [in] */ HRESULT hr,
            /* [in] */ WMT_ATTR_DATATYPE dwType,
            /* [in] */ BYTE *pValue,
            /* [in] */ void *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE *OnSample )( 
            IWMReaderCallback * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer *pSample,
            /* [in] */ void *pvContext);
        
        END_INTERFACE
    } IWMReaderCallbackVtbl;

    interface IWMReaderCallback
    {
        CONST_VTBL struct IWMReaderCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMReaderCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMReaderCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMReaderCallback_OnStatus(This,Status,hr,dwType,pValue,pvContext)	\
    ( (This)->lpVtbl -> OnStatus(This,Status,hr,dwType,pValue,pvContext) ) 


#define IWMReaderCallback_OnSample(This,dwOutputNum,cnsSampleTime,cnsSampleDuration,dwFlags,pSample,pvContext)	\
    ( (This)->lpVtbl -> OnSample(This,dwOutputNum,cnsSampleTime,cnsSampleDuration,dwFlags,pSample,pvContext) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMReaderCallback_INTERFACE_DEFINED__ */


#ifndef __IWMCredentialCallback_INTERFACE_DEFINED__
#define __IWMCredentialCallback_INTERFACE_DEFINED__

/* interface IWMCredentialCallback */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMCredentialCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("342e0eb7-e651-450c-975b-2ace2c90c48e")
    IWMCredentialCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AcquireCredentials( 
            /* [in] */ WCHAR *pwszRealm,
            /* [in] */ WCHAR *pwszSite,
            /* [size_is][out][in] */ WCHAR *pwszUser,
            /* [in] */ DWORD cchUser,
            /* [size_is][out][in] */ WCHAR *pwszPassword,
            /* [in] */ DWORD cchPassword,
            /* [in] */ HRESULT hrStatus,
            /* [out][in] */ DWORD *pdwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMCredentialCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMCredentialCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMCredentialCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMCredentialCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *AcquireCredentials )( 
            IWMCredentialCallback * This,
            /* [in] */ WCHAR *pwszRealm,
            /* [in] */ WCHAR *pwszSite,
            /* [size_is][out][in] */ WCHAR *pwszUser,
            /* [in] */ DWORD cchUser,
            /* [size_is][out][in] */ WCHAR *pwszPassword,
            /* [in] */ DWORD cchPassword,
            /* [in] */ HRESULT hrStatus,
            /* [out][in] */ DWORD *pdwFlags);
        
        END_INTERFACE
    } IWMCredentialCallbackVtbl;

    interface IWMCredentialCallback
    {
        CONST_VTBL struct IWMCredentialCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMCredentialCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMCredentialCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMCredentialCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMCredentialCallback_AcquireCredentials(This,pwszRealm,pwszSite,pwszUser,cchUser,pwszPassword,cchPassword,hrStatus,pdwFlags)	\
    ( (This)->lpVtbl -> AcquireCredentials(This,pwszRealm,pwszSite,pwszUser,cchUser,pwszPassword,cchPassword,hrStatus,pdwFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMCredentialCallback_INTERFACE_DEFINED__ */


#ifndef __IWMMetadataEditor_INTERFACE_DEFINED__
#define __IWMMetadataEditor_INTERFACE_DEFINED__

/* interface IWMMetadataEditor */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMMetadataEditor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BD9-2B2B-11d3-B36B-00C04F6108FF")
    IWMMetadataEditor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ const WCHAR *pwszFilename) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Flush( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMMetadataEditorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMMetadataEditor * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMMetadataEditor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMMetadataEditor * This);
        
        HRESULT ( STDMETHODCALLTYPE *Open )( 
            IWMMetadataEditor * This,
            /* [in] */ const WCHAR *pwszFilename);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            IWMMetadataEditor * This);
        
        HRESULT ( STDMETHODCALLTYPE *Flush )( 
            IWMMetadataEditor * This);
        
        END_INTERFACE
    } IWMMetadataEditorVtbl;

    interface IWMMetadataEditor
    {
        CONST_VTBL struct IWMMetadataEditorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMMetadataEditor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMMetadataEditor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMMetadataEditor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMMetadataEditor_Open(This,pwszFilename)	\
    ( (This)->lpVtbl -> Open(This,pwszFilename) ) 

#define IWMMetadataEditor_Close(This)	\
    ( (This)->lpVtbl -> Close(This) ) 

#define IWMMetadataEditor_Flush(This)	\
    ( (This)->lpVtbl -> Flush(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMMetadataEditor_INTERFACE_DEFINED__ */


#ifndef __IWMHeaderInfo_INTERFACE_DEFINED__
#define __IWMHeaderInfo_INTERFACE_DEFINED__

/* interface IWMHeaderInfo */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMHeaderInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BDA-2B2B-11d3-B36B-00C04F6108FF")
    IWMHeaderInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAttributeCount( 
            /* [in] */ WORD wStreamNum,
            /* [out] */ WORD *pcAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributeByIndex( 
            /* [in] */ WORD wIndex,
            /* [out][in] */ WORD *pwStreamNum,
            /* [out] */ WCHAR *pwszName,
            /* [out][in] */ WORD *pcchNameLen,
            /* [out] */ WMT_ATTR_DATATYPE *pType,
            /* [out] */ BYTE *pValue,
            /* [out][in] */ WORD *pcbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributeByName( 
            /* [out][in] */ WORD *pwStreamNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE *pType,
            /* [out] */ BYTE *pValue,
            /* [out][in] */ WORD *pcbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAttribute( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE *pValue,
            /* [in] */ WORD cbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMarkerCount( 
            /* [out] */ WORD *pcMarkers) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMarker( 
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR *pwszMarkerName,
            /* [out][in] */ WORD *pcchMarkerNameLen,
            /* [out] */ QWORD *pcnsMarkerTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddMarker( 
            /* [in] */ WCHAR *pwszMarkerName,
            /* [in] */ QWORD cnsMarkerTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveMarker( 
            /* [in] */ WORD wIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScriptCount( 
            /* [out] */ WORD *pcScripts) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScript( 
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR *pwszType,
            /* [out][in] */ WORD *pcchTypeLen,
            /* [out] */ WCHAR *pwszCommand,
            /* [out][in] */ WORD *pcchCommandLen,
            /* [out] */ QWORD *pcnsScriptTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddScript( 
            /* [in] */ WCHAR *pwszType,
            /* [in] */ WCHAR *pwszCommand,
            /* [in] */ QWORD cnsScriptTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveScript( 
            /* [in] */ WORD wIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMHeaderInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMHeaderInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMHeaderInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMHeaderInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributeCount )( 
            IWMHeaderInfo * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ WORD *pcAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributeByIndex )( 
            IWMHeaderInfo * This,
            /* [in] */ WORD wIndex,
            /* [out][in] */ WORD *pwStreamNum,
            /* [out] */ WCHAR *pwszName,
            /* [out][in] */ WORD *pcchNameLen,
            /* [out] */ WMT_ATTR_DATATYPE *pType,
            /* [out] */ BYTE *pValue,
            /* [out][in] */ WORD *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributeByName )( 
            IWMHeaderInfo * This,
            /* [out][in] */ WORD *pwStreamNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE *pType,
            /* [out] */ BYTE *pValue,
            /* [out][in] */ WORD *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE *SetAttribute )( 
            IWMHeaderInfo * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE *pValue,
            /* [in] */ WORD cbLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetMarkerCount )( 
            IWMHeaderInfo * This,
            /* [out] */ WORD *pcMarkers);
        
        HRESULT ( STDMETHODCALLTYPE *GetMarker )( 
            IWMHeaderInfo * This,
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR *pwszMarkerName,
            /* [out][in] */ WORD *pcchMarkerNameLen,
            /* [out] */ QWORD *pcnsMarkerTime);
        
        HRESULT ( STDMETHODCALLTYPE *AddMarker )( 
            IWMHeaderInfo * This,
            /* [in] */ WCHAR *pwszMarkerName,
            /* [in] */ QWORD cnsMarkerTime);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveMarker )( 
            IWMHeaderInfo * This,
            /* [in] */ WORD wIndex);
        
        HRESULT ( STDMETHODCALLTYPE *GetScriptCount )( 
            IWMHeaderInfo * This,
            /* [out] */ WORD *pcScripts);
        
        HRESULT ( STDMETHODCALLTYPE *GetScript )( 
            IWMHeaderInfo * This,
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR *pwszType,
            /* [out][in] */ WORD *pcchTypeLen,
            /* [out] */ WCHAR *pwszCommand,
            /* [out][in] */ WORD *pcchCommandLen,
            /* [out] */ QWORD *pcnsScriptTime);
        
        HRESULT ( STDMETHODCALLTYPE *AddScript )( 
            IWMHeaderInfo * This,
            /* [in] */ WCHAR *pwszType,
            /* [in] */ WCHAR *pwszCommand,
            /* [in] */ QWORD cnsScriptTime);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveScript )( 
            IWMHeaderInfo * This,
            /* [in] */ WORD wIndex);
        
        END_INTERFACE
    } IWMHeaderInfoVtbl;

    interface IWMHeaderInfo
    {
        CONST_VTBL struct IWMHeaderInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMHeaderInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMHeaderInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMHeaderInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMHeaderInfo_GetAttributeCount(This,wStreamNum,pcAttributes)	\
    ( (This)->lpVtbl -> GetAttributeCount(This,wStreamNum,pcAttributes) ) 

#define IWMHeaderInfo_GetAttributeByIndex(This,wIndex,pwStreamNum,pwszName,pcchNameLen,pType,pValue,pcbLength)	\
    ( (This)->lpVtbl -> GetAttributeByIndex(This,wIndex,pwStreamNum,pwszName,pcchNameLen,pType,pValue,pcbLength) ) 

#define IWMHeaderInfo_GetAttributeByName(This,pwStreamNum,pszName,pType,pValue,pcbLength)	\
    ( (This)->lpVtbl -> GetAttributeByName(This,pwStreamNum,pszName,pType,pValue,pcbLength) ) 

#define IWMHeaderInfo_SetAttribute(This,wStreamNum,pszName,Type,pValue,cbLength)	\
    ( (This)->lpVtbl -> SetAttribute(This,wStreamNum,pszName,Type,pValue,cbLength) ) 

#define IWMHeaderInfo_GetMarkerCount(This,pcMarkers)	\
    ( (This)->lpVtbl -> GetMarkerCount(This,pcMarkers) ) 

#define IWMHeaderInfo_GetMarker(This,wIndex,pwszMarkerName,pcchMarkerNameLen,pcnsMarkerTime)	\
    ( (This)->lpVtbl -> GetMarker(This,wIndex,pwszMarkerName,pcchMarkerNameLen,pcnsMarkerTime) ) 

#define IWMHeaderInfo_AddMarker(This,pwszMarkerName,cnsMarkerTime)	\
    ( (This)->lpVtbl -> AddMarker(This,pwszMarkerName,cnsMarkerTime) ) 

#define IWMHeaderInfo_RemoveMarker(This,wIndex)	\
    ( (This)->lpVtbl -> RemoveMarker(This,wIndex) ) 

#define IWMHeaderInfo_GetScriptCount(This,pcScripts)	\
    ( (This)->lpVtbl -> GetScriptCount(This,pcScripts) ) 

#define IWMHeaderInfo_GetScript(This,wIndex,pwszType,pcchTypeLen,pwszCommand,pcchCommandLen,pcnsScriptTime)	\
    ( (This)->lpVtbl -> GetScript(This,wIndex,pwszType,pcchTypeLen,pwszCommand,pcchCommandLen,pcnsScriptTime) ) 

#define IWMHeaderInfo_AddScript(This,pwszType,pwszCommand,cnsScriptTime)	\
    ( (This)->lpVtbl -> AddScript(This,pwszType,pwszCommand,cnsScriptTime) ) 

#define IWMHeaderInfo_RemoveScript(This,wIndex)	\
    ( (This)->lpVtbl -> RemoveScript(This,wIndex) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMHeaderInfo_INTERFACE_DEFINED__ */


#ifndef __IWMHeaderInfo2_INTERFACE_DEFINED__
#define __IWMHeaderInfo2_INTERFACE_DEFINED__

/* interface IWMHeaderInfo2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMHeaderInfo2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("15CF9781-454E-482e-B393-85FAE487A810")
    IWMHeaderInfo2 : public IWMHeaderInfo
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCodecInfoCount( 
            /* [out] */ DWORD *pcCodecInfos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodecInfo( 
            /* [in] */ DWORD wIndex,
            /* [out][in] */ WORD *pcchName,
            /* [out] */ WCHAR *pwszName,
            /* [out][in] */ WORD *pcchDescription,
            /* [out] */ WCHAR *pwszDescription,
            /* [out] */ WMT_CODEC_INFO_TYPE *pCodecType,
            /* [out][in] */ WORD *pcbCodecInfo,
            /* [out] */ BYTE *pbCodecInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMHeaderInfo2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMHeaderInfo2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMHeaderInfo2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMHeaderInfo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributeCount )( 
            IWMHeaderInfo2 * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ WORD *pcAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributeByIndex )( 
            IWMHeaderInfo2 * This,
            /* [in] */ WORD wIndex,
            /* [out][in] */ WORD *pwStreamNum,
            /* [out] */ WCHAR *pwszName,
            /* [out][in] */ WORD *pcchNameLen,
            /* [out] */ WMT_ATTR_DATATYPE *pType,
            /* [out] */ BYTE *pValue,
            /* [out][in] */ WORD *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributeByName )( 
            IWMHeaderInfo2 * This,
            /* [out][in] */ WORD *pwStreamNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE *pType,
            /* [out] */ BYTE *pValue,
            /* [out][in] */ WORD *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE *SetAttribute )( 
            IWMHeaderInfo2 * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE *pValue,
            /* [in] */ WORD cbLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetMarkerCount )( 
            IWMHeaderInfo2 * This,
            /* [out] */ WORD *pcMarkers);
        
        HRESULT ( STDMETHODCALLTYPE *GetMarker )( 
            IWMHeaderInfo2 * This,
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR *pwszMarkerName,
            /* [out][in] */ WORD *pcchMarkerNameLen,
            /* [out] */ QWORD *pcnsMarkerTime);
        
        HRESULT ( STDMETHODCALLTYPE *AddMarker )( 
            IWMHeaderInfo2 * This,
            /* [in] */ WCHAR *pwszMarkerName,
            /* [in] */ QWORD cnsMarkerTime);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveMarker )( 
            IWMHeaderInfo2 * This,
            /* [in] */ WORD wIndex);
        
        HRESULT ( STDMETHODCALLTYPE *GetScriptCount )( 
            IWMHeaderInfo2 * This,
            /* [out] */ WORD *pcScripts);
        
        HRESULT ( STDMETHODCALLTYPE *GetScript )( 
            IWMHeaderInfo2 * This,
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR *pwszType,
            /* [out][in] */ WORD *pcchTypeLen,
            /* [out] */ WCHAR *pwszCommand,
            /* [out][in] */ WORD *pcchCommandLen,
            /* [out] */ QWORD *pcnsScriptTime);
        
        HRESULT ( STDMETHODCALLTYPE *AddScript )( 
            IWMHeaderInfo2 * This,
            /* [in] */ WCHAR *pwszType,
            /* [in] */ WCHAR *pwszCommand,
            /* [in] */ QWORD cnsScriptTime);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveScript )( 
            IWMHeaderInfo2 * This,
            /* [in] */ WORD wIndex);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodecInfoCount )( 
            IWMHeaderInfo2 * This,
            /* [out] */ DWORD *pcCodecInfos);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodecInfo )( 
            IWMHeaderInfo2 * This,
            /* [in] */ DWORD wIndex,
            /* [out][in] */ WORD *pcchName,
            /* [out] */ WCHAR *pwszName,
            /* [out][in] */ WORD *pcchDescription,
            /* [out] */ WCHAR *pwszDescription,
            /* [out] */ WMT_CODEC_INFO_TYPE *pCodecType,
            /* [out][in] */ WORD *pcbCodecInfo,
            /* [out] */ BYTE *pbCodecInfo);
        
        END_INTERFACE
    } IWMHeaderInfo2Vtbl;

    interface IWMHeaderInfo2
    {
        CONST_VTBL struct IWMHeaderInfo2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMHeaderInfo2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMHeaderInfo2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMHeaderInfo2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMHeaderInfo2_GetAttributeCount(This,wStreamNum,pcAttributes)	\
    ( (This)->lpVtbl -> GetAttributeCount(This,wStreamNum,pcAttributes) ) 

#define IWMHeaderInfo2_GetAttributeByIndex(This,wIndex,pwStreamNum,pwszName,pcchNameLen,pType,pValue,pcbLength)	\
    ( (This)->lpVtbl -> GetAttributeByIndex(This,wIndex,pwStreamNum,pwszName,pcchNameLen,pType,pValue,pcbLength) ) 

#define IWMHeaderInfo2_GetAttributeByName(This,pwStreamNum,pszName,pType,pValue,pcbLength)	\
    ( (This)->lpVtbl -> GetAttributeByName(This,pwStreamNum,pszName,pType,pValue,pcbLength) ) 

#define IWMHeaderInfo2_SetAttribute(This,wStreamNum,pszName,Type,pValue,cbLength)	\
    ( (This)->lpVtbl -> SetAttribute(This,wStreamNum,pszName,Type,pValue,cbLength) ) 

#define IWMHeaderInfo2_GetMarkerCount(This,pcMarkers)	\
    ( (This)->lpVtbl -> GetMarkerCount(This,pcMarkers) ) 

#define IWMHeaderInfo2_GetMarker(This,wIndex,pwszMarkerName,pcchMarkerNameLen,pcnsMarkerTime)	\
    ( (This)->lpVtbl -> GetMarker(This,wIndex,pwszMarkerName,pcchMarkerNameLen,pcnsMarkerTime) ) 

#define IWMHeaderInfo2_AddMarker(This,pwszMarkerName,cnsMarkerTime)	\
    ( (This)->lpVtbl -> AddMarker(This,pwszMarkerName,cnsMarkerTime) ) 

#define IWMHeaderInfo2_RemoveMarker(This,wIndex)	\
    ( (This)->lpVtbl -> RemoveMarker(This,wIndex) ) 

#define IWMHeaderInfo2_GetScriptCount(This,pcScripts)	\
    ( (This)->lpVtbl -> GetScriptCount(This,pcScripts) ) 

#define IWMHeaderInfo2_GetScript(This,wIndex,pwszType,pcchTypeLen,pwszCommand,pcchCommandLen,pcnsScriptTime)	\
    ( (This)->lpVtbl -> GetScript(This,wIndex,pwszType,pcchTypeLen,pwszCommand,pcchCommandLen,pcnsScriptTime) ) 

#define IWMHeaderInfo2_AddScript(This,pwszType,pwszCommand,cnsScriptTime)	\
    ( (This)->lpVtbl -> AddScript(This,pwszType,pwszCommand,cnsScriptTime) ) 

#define IWMHeaderInfo2_RemoveScript(This,wIndex)	\
    ( (This)->lpVtbl -> RemoveScript(This,wIndex) ) 


#define IWMHeaderInfo2_GetCodecInfoCount(This,pcCodecInfos)	\
    ( (This)->lpVtbl -> GetCodecInfoCount(This,pcCodecInfos) ) 

#define IWMHeaderInfo2_GetCodecInfo(This,wIndex,pcchName,pwszName,pcchDescription,pwszDescription,pCodecType,pcbCodecInfo,pbCodecInfo)	\
    ( (This)->lpVtbl -> GetCodecInfo(This,wIndex,pcchName,pwszName,pcchDescription,pwszDescription,pCodecType,pcbCodecInfo,pbCodecInfo) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMHeaderInfo2_INTERFACE_DEFINED__ */


#ifndef __IWMHeaderInfo3_INTERFACE_DEFINED__
#define __IWMHeaderInfo3_INTERFACE_DEFINED__

/* interface IWMHeaderInfo3 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMHeaderInfo3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("15CC68E3-27CC-4ecd-B222-3F5D02D80BD5")
    IWMHeaderInfo3 : public IWMHeaderInfo2
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAttributeCountEx( 
            /* [in] */ WORD wStreamNum,
            /* [out] */ WORD *pcAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributeIndices( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ LPCWSTR pwszName,
            /* [in] */ WORD *pwLangIndex,
            /* [size_is][out] */ WORD *pwIndices,
            /* [out][in] */ WORD *pwCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributeByIndexEx( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ WORD wIndex,
            /* [size_is][out] */ LPWSTR pwszName,
            /* [out][in] */ WORD *pwNameLen,
            /* [out] */ WMT_ATTR_DATATYPE *pType,
            /* [out] */ WORD *pwLangIndex,
            /* [size_is][out] */ BYTE *pValue,
            /* [out][in] */ DWORD *pdwDataLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ModifyAttribute( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ WORD wIndex,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ WORD wLangIndex,
            /* [size_is][in] */ const BYTE *pValue,
            /* [in] */ DWORD dwLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddAttribute( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WORD *pwIndex,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ WORD wLangIndex,
            /* [size_is][in] */ const BYTE *pValue,
            /* [in] */ DWORD dwLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteAttribute( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ WORD wIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddCodecInfo( 
            /* [in] */ WCHAR *pwszName,
            /* [in] */ WCHAR *pwszDescription,
            /* [in] */ WMT_CODEC_INFO_TYPE codecType,
            /* [in] */ WORD cbCodecInfo,
            /* [size_is][in] */ BYTE *pbCodecInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMHeaderInfo3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMHeaderInfo3 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMHeaderInfo3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMHeaderInfo3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributeCount )( 
            IWMHeaderInfo3 * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ WORD *pcAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributeByIndex )( 
            IWMHeaderInfo3 * This,
            /* [in] */ WORD wIndex,
            /* [out][in] */ WORD *pwStreamNum,
            /* [out] */ WCHAR *pwszName,
            /* [out][in] */ WORD *pcchNameLen,
            /* [out] */ WMT_ATTR_DATATYPE *pType,
            /* [out] */ BYTE *pValue,
            /* [out][in] */ WORD *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributeByName )( 
            IWMHeaderInfo3 * This,
            /* [out][in] */ WORD *pwStreamNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE *pType,
            /* [out] */ BYTE *pValue,
            /* [out][in] */ WORD *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE *SetAttribute )( 
            IWMHeaderInfo3 * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE *pValue,
            /* [in] */ WORD cbLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetMarkerCount )( 
            IWMHeaderInfo3 * This,
            /* [out] */ WORD *pcMarkers);
        
        HRESULT ( STDMETHODCALLTYPE *GetMarker )( 
            IWMHeaderInfo3 * This,
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR *pwszMarkerName,
            /* [out][in] */ WORD *pcchMarkerNameLen,
            /* [out] */ QWORD *pcnsMarkerTime);
        
        HRESULT ( STDMETHODCALLTYPE *AddMarker )( 
            IWMHeaderInfo3 * This,
            /* [in] */ WCHAR *pwszMarkerName,
            /* [in] */ QWORD cnsMarkerTime);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveMarker )( 
            IWMHeaderInfo3 * This,
            /* [in] */ WORD wIndex);
        
        HRESULT ( STDMETHODCALLTYPE *GetScriptCount )( 
            IWMHeaderInfo3 * This,
            /* [out] */ WORD *pcScripts);
        
        HRESULT ( STDMETHODCALLTYPE *GetScript )( 
            IWMHeaderInfo3 * This,
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR *pwszType,
            /* [out][in] */ WORD *pcchTypeLen,
            /* [out] */ WCHAR *pwszCommand,
            /* [out][in] */ WORD *pcchCommandLen,
            /* [out] */ QWORD *pcnsScriptTime);
        
        HRESULT ( STDMETHODCALLTYPE *AddScript )( 
            IWMHeaderInfo3 * This,
            /* [in] */ WCHAR *pwszType,
            /* [in] */ WCHAR *pwszCommand,
            /* [in] */ QWORD cnsScriptTime);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveScript )( 
            IWMHeaderInfo3 * This,
            /* [in] */ WORD wIndex);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodecInfoCount )( 
            IWMHeaderInfo3 * This,
            /* [out] */ DWORD *pcCodecInfos);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodecInfo )( 
            IWMHeaderInfo3 * This,
            /* [in] */ DWORD wIndex,
            /* [out][in] */ WORD *pcchName,
            /* [out] */ WCHAR *pwszName,
            /* [out][in] */ WORD *pcchDescription,
            /* [out] */ WCHAR *pwszDescription,
            /* [out] */ WMT_CODEC_INFO_TYPE *pCodecType,
            /* [out][in] */ WORD *pcbCodecInfo,
            /* [out] */ BYTE *pbCodecInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributeCountEx )( 
            IWMHeaderInfo3 * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ WORD *pcAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributeIndices )( 
            IWMHeaderInfo3 * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ LPCWSTR pwszName,
            /* [in] */ WORD *pwLangIndex,
            /* [size_is][out] */ WORD *pwIndices,
            /* [out][in] */ WORD *pwCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributeByIndexEx )( 
            IWMHeaderInfo3 * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ WORD wIndex,
            /* [size_is][out] */ LPWSTR pwszName,
            /* [out][in] */ WORD *pwNameLen,
            /* [out] */ WMT_ATTR_DATATYPE *pType,
            /* [out] */ WORD *pwLangIndex,
            /* [size_is][out] */ BYTE *pValue,
            /* [out][in] */ DWORD *pdwDataLength);
        
        HRESULT ( STDMETHODCALLTYPE *ModifyAttribute )( 
            IWMHeaderInfo3 * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ WORD wIndex,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ WORD wLangIndex,
            /* [size_is][in] */ const BYTE *pValue,
            /* [in] */ DWORD dwLength);
        
        HRESULT ( STDMETHODCALLTYPE *AddAttribute )( 
            IWMHeaderInfo3 * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WORD *pwIndex,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ WORD wLangIndex,
            /* [size_is][in] */ const BYTE *pValue,
            /* [in] */ DWORD dwLength);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteAttribute )( 
            IWMHeaderInfo3 * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ WORD wIndex);
        
        HRESULT ( STDMETHODCALLTYPE *AddCodecInfo )( 
            IWMHeaderInfo3 * This,
            /* [in] */ WCHAR *pwszName,
            /* [in] */ WCHAR *pwszDescription,
            /* [in] */ WMT_CODEC_INFO_TYPE codecType,
            /* [in] */ WORD cbCodecInfo,
            /* [size_is][in] */ BYTE *pbCodecInfo);
        
        END_INTERFACE
    } IWMHeaderInfo3Vtbl;

    interface IWMHeaderInfo3
    {
        CONST_VTBL struct IWMHeaderInfo3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMHeaderInfo3_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMHeaderInfo3_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMHeaderInfo3_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMHeaderInfo3_GetAttributeCount(This,wStreamNum,pcAttributes)	\
    ( (This)->lpVtbl -> GetAttributeCount(This,wStreamNum,pcAttributes) ) 

#define IWMHeaderInfo3_GetAttributeByIndex(This,wIndex,pwStreamNum,pwszName,pcchNameLen,pType,pValue,pcbLength)	\
    ( (This)->lpVtbl -> GetAttributeByIndex(This,wIndex,pwStreamNum,pwszName,pcchNameLen,pType,pValue,pcbLength) ) 

#define IWMHeaderInfo3_GetAttributeByName(This,pwStreamNum,pszName,pType,pValue,pcbLength)	\
    ( (This)->lpVtbl -> GetAttributeByName(This,pwStreamNum,pszName,pType,pValue,pcbLength) ) 

#define IWMHeaderInfo3_SetAttribute(This,wStreamNum,pszName,Type,pValue,cbLength)	\
    ( (This)->lpVtbl -> SetAttribute(This,wStreamNum,pszName,Type,pValue,cbLength) ) 

#define IWMHeaderInfo3_GetMarkerCount(This,pcMarkers)	\
    ( (This)->lpVtbl -> GetMarkerCount(This,pcMarkers) ) 

#define IWMHeaderInfo3_GetMarker(This,wIndex,pwszMarkerName,pcchMarkerNameLen,pcnsMarkerTime)	\
    ( (This)->lpVtbl -> GetMarker(This,wIndex,pwszMarkerName,pcchMarkerNameLen,pcnsMarkerTime) ) 

#define IWMHeaderInfo3_AddMarker(This,pwszMarkerName,cnsMarkerTime)	\
    ( (This)->lpVtbl -> AddMarker(This,pwszMarkerName,cnsMarkerTime) ) 

#define IWMHeaderInfo3_RemoveMarker(This,wIndex)	\
    ( (This)->lpVtbl -> RemoveMarker(This,wIndex) ) 

#define IWMHeaderInfo3_GetScriptCount(This,pcScripts)	\
    ( (This)->lpVtbl -> GetScriptCount(This,pcScripts) ) 

#define IWMHeaderInfo3_GetScript(This,wIndex,pwszType,pcchTypeLen,pwszCommand,pcchCommandLen,pcnsScriptTime)	\
    ( (This)->lpVtbl -> GetScript(This,wIndex,pwszType,pcchTypeLen,pwszCommand,pcchCommandLen,pcnsScriptTime) ) 

#define IWMHeaderInfo3_AddScript(This,pwszType,pwszCommand,cnsScriptTime)	\
    ( (This)->lpVtbl -> AddScript(This,pwszType,pwszCommand,cnsScriptTime) ) 

#define IWMHeaderInfo3_RemoveScript(This,wIndex)	\
    ( (This)->lpVtbl -> RemoveScript(This,wIndex) ) 


#define IWMHeaderInfo3_GetCodecInfoCount(This,pcCodecInfos)	\
    ( (This)->lpVtbl -> GetCodecInfoCount(This,pcCodecInfos) ) 

#define IWMHeaderInfo3_GetCodecInfo(This,wIndex,pcchName,pwszName,pcchDescription,pwszDescription,pCodecType,pcbCodecInfo,pbCodecInfo)	\
    ( (This)->lpVtbl -> GetCodecInfo(This,wIndex,pcchName,pwszName,pcchDescription,pwszDescription,pCodecType,pcbCodecInfo,pbCodecInfo) ) 


#define IWMHeaderInfo3_GetAttributeCountEx(This,wStreamNum,pcAttributes)	\
    ( (This)->lpVtbl -> GetAttributeCountEx(This,wStreamNum,pcAttributes) ) 

#define IWMHeaderInfo3_GetAttributeIndices(This,wStreamNum,pwszName,pwLangIndex,pwIndices,pwCount)	\
    ( (This)->lpVtbl -> GetAttributeIndices(This,wStreamNum,pwszName,pwLangIndex,pwIndices,pwCount) ) 

#define IWMHeaderInfo3_GetAttributeByIndexEx(This,wStreamNum,wIndex,pwszName,pwNameLen,pType,pwLangIndex,pValue,pdwDataLength)	\
    ( (This)->lpVtbl -> GetAttributeByIndexEx(This,wStreamNum,wIndex,pwszName,pwNameLen,pType,pwLangIndex,pValue,pdwDataLength) ) 

#define IWMHeaderInfo3_ModifyAttribute(This,wStreamNum,wIndex,Type,wLangIndex,pValue,dwLength)	\
    ( (This)->lpVtbl -> ModifyAttribute(This,wStreamNum,wIndex,Type,wLangIndex,pValue,dwLength) ) 

#define IWMHeaderInfo3_AddAttribute(This,wStreamNum,pszName,pwIndex,Type,wLangIndex,pValue,dwLength)	\
    ( (This)->lpVtbl -> AddAttribute(This,wStreamNum,pszName,pwIndex,Type,wLangIndex,pValue,dwLength) ) 

#define IWMHeaderInfo3_DeleteAttribute(This,wStreamNum,wIndex)	\
    ( (This)->lpVtbl -> DeleteAttribute(This,wStreamNum,wIndex) ) 

#define IWMHeaderInfo3_AddCodecInfo(This,pwszName,pwszDescription,codecType,cbCodecInfo,pbCodecInfo)	\
    ( (This)->lpVtbl -> AddCodecInfo(This,pwszName,pwszDescription,codecType,cbCodecInfo,pbCodecInfo) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMHeaderInfo3_INTERFACE_DEFINED__ */


#ifndef __IWMProfileManager_INTERFACE_DEFINED__
#define __IWMProfileManager_INTERFACE_DEFINED__

/* interface IWMProfileManager */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMProfileManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d16679f2-6ca0-472d-8d31-2f5d55aee155")
    IWMProfileManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateEmptyProfile( 
            /* [in] */ WMT_VERSION dwVersion,
            /* [out] */ IWMProfile **ppProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadProfileByID( 
            /* [in] */ REFGUID guidProfile,
            /* [out] */ IWMProfile **ppProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadProfileByData( 
            /* [in] */ const WCHAR *pwszProfile,
            /* [out] */ IWMProfile **ppProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveProfile( 
            /* [in] */ IWMProfile *pIWMProfile,
            /* [in] */ WCHAR *pwszProfile,
            /* [out][in] */ DWORD *pdwLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSystemProfileCount( 
            /* [out] */ DWORD *pcProfiles) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadSystemProfile( 
            /* [in] */ DWORD dwProfileIndex,
            /* [out] */ IWMProfile **ppProfile) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMProfileManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMProfileManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMProfileManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMProfileManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateEmptyProfile )( 
            IWMProfileManager * This,
            /* [in] */ WMT_VERSION dwVersion,
            /* [out] */ IWMProfile **ppProfile);
        
        HRESULT ( STDMETHODCALLTYPE *LoadProfileByID )( 
            IWMProfileManager * This,
            /* [in] */ REFGUID guidProfile,
            /* [out] */ IWMProfile **ppProfile);
        
        HRESULT ( STDMETHODCALLTYPE *LoadProfileByData )( 
            IWMProfileManager * This,
            /* [in] */ const WCHAR *pwszProfile,
            /* [out] */ IWMProfile **ppProfile);
        
        HRESULT ( STDMETHODCALLTYPE *SaveProfile )( 
            IWMProfileManager * This,
            /* [in] */ IWMProfile *pIWMProfile,
            /* [in] */ WCHAR *pwszProfile,
            /* [out][in] */ DWORD *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetSystemProfileCount )( 
            IWMProfileManager * This,
            /* [out] */ DWORD *pcProfiles);
        
        HRESULT ( STDMETHODCALLTYPE *LoadSystemProfile )( 
            IWMProfileManager * This,
            /* [in] */ DWORD dwProfileIndex,
            /* [out] */ IWMProfile **ppProfile);
        
        END_INTERFACE
    } IWMProfileManagerVtbl;

    interface IWMProfileManager
    {
        CONST_VTBL struct IWMProfileManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMProfileManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMProfileManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMProfileManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMProfileManager_CreateEmptyProfile(This,dwVersion,ppProfile)	\
    ( (This)->lpVtbl -> CreateEmptyProfile(This,dwVersion,ppProfile) ) 

#define IWMProfileManager_LoadProfileByID(This,guidProfile,ppProfile)	\
    ( (This)->lpVtbl -> LoadProfileByID(This,guidProfile,ppProfile) ) 

#define IWMProfileManager_LoadProfileByData(This,pwszProfile,ppProfile)	\
    ( (This)->lpVtbl -> LoadProfileByData(This,pwszProfile,ppProfile) ) 

#define IWMProfileManager_SaveProfile(This,pIWMProfile,pwszProfile,pdwLength)	\
    ( (This)->lpVtbl -> SaveProfile(This,pIWMProfile,pwszProfile,pdwLength) ) 

#define IWMProfileManager_GetSystemProfileCount(This,pcProfiles)	\
    ( (This)->lpVtbl -> GetSystemProfileCount(This,pcProfiles) ) 

#define IWMProfileManager_LoadSystemProfile(This,dwProfileIndex,ppProfile)	\
    ( (This)->lpVtbl -> LoadSystemProfile(This,dwProfileIndex,ppProfile) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMProfileManager_INTERFACE_DEFINED__ */


#ifndef __IWMProfileManager2_INTERFACE_DEFINED__
#define __IWMProfileManager2_INTERFACE_DEFINED__

/* interface IWMProfileManager2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMProfileManager2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7A924E51-73C1-494d-8019-23D37ED9B89A")
    IWMProfileManager2 : public IWMProfileManager
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSystemProfileVersion( 
            WMT_VERSION *pdwVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSystemProfileVersion( 
            WMT_VERSION dwVersion) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMProfileManager2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMProfileManager2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMProfileManager2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMProfileManager2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateEmptyProfile )( 
            IWMProfileManager2 * This,
            /* [in] */ WMT_VERSION dwVersion,
            /* [out] */ IWMProfile **ppProfile);
        
        HRESULT ( STDMETHODCALLTYPE *LoadProfileByID )( 
            IWMProfileManager2 * This,
            /* [in] */ REFGUID guidProfile,
            /* [out] */ IWMProfile **ppProfile);
        
        HRESULT ( STDMETHODCALLTYPE *LoadProfileByData )( 
            IWMProfileManager2 * This,
            /* [in] */ const WCHAR *pwszProfile,
            /* [out] */ IWMProfile **ppProfile);
        
        HRESULT ( STDMETHODCALLTYPE *SaveProfile )( 
            IWMProfileManager2 * This,
            /* [in] */ IWMProfile *pIWMProfile,
            /* [in] */ WCHAR *pwszProfile,
            /* [out][in] */ DWORD *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetSystemProfileCount )( 
            IWMProfileManager2 * This,
            /* [out] */ DWORD *pcProfiles);
        
        HRESULT ( STDMETHODCALLTYPE *LoadSystemProfile )( 
            IWMProfileManager2 * This,
            /* [in] */ DWORD dwProfileIndex,
            /* [out] */ IWMProfile **ppProfile);
        
        HRESULT ( STDMETHODCALLTYPE *GetSystemProfileVersion )( 
            IWMProfileManager2 * This,
            WMT_VERSION *pdwVersion);
        
        HRESULT ( STDMETHODCALLTYPE *SetSystemProfileVersion )( 
            IWMProfileManager2 * This,
            WMT_VERSION dwVersion);
        
        END_INTERFACE
    } IWMProfileManager2Vtbl;

    interface IWMProfileManager2
    {
        CONST_VTBL struct IWMProfileManager2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMProfileManager2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMProfileManager2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMProfileManager2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMProfileManager2_CreateEmptyProfile(This,dwVersion,ppProfile)	\
    ( (This)->lpVtbl -> CreateEmptyProfile(This,dwVersion,ppProfile) ) 

#define IWMProfileManager2_LoadProfileByID(This,guidProfile,ppProfile)	\
    ( (This)->lpVtbl -> LoadProfileByID(This,guidProfile,ppProfile) ) 

#define IWMProfileManager2_LoadProfileByData(This,pwszProfile,ppProfile)	\
    ( (This)->lpVtbl -> LoadProfileByData(This,pwszProfile,ppProfile) ) 

#define IWMProfileManager2_SaveProfile(This,pIWMProfile,pwszProfile,pdwLength)	\
    ( (This)->lpVtbl -> SaveProfile(This,pIWMProfile,pwszProfile,pdwLength) ) 

#define IWMProfileManager2_GetSystemProfileCount(This,pcProfiles)	\
    ( (This)->lpVtbl -> GetSystemProfileCount(This,pcProfiles) ) 

#define IWMProfileManager2_LoadSystemProfile(This,dwProfileIndex,ppProfile)	\
    ( (This)->lpVtbl -> LoadSystemProfile(This,dwProfileIndex,ppProfile) ) 


#define IWMProfileManager2_GetSystemProfileVersion(This,pdwVersion)	\
    ( (This)->lpVtbl -> GetSystemProfileVersion(This,pdwVersion) ) 

#define IWMProfileManager2_SetSystemProfileVersion(This,dwVersion)	\
    ( (This)->lpVtbl -> SetSystemProfileVersion(This,dwVersion) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMProfileManager2_INTERFACE_DEFINED__ */


#ifndef __IWMProfile_INTERFACE_DEFINED__
#define __IWMProfile_INTERFACE_DEFINED__

/* interface IWMProfile */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMProfile;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BDB-2B2B-11d3-B36B-00C04F6108FF")
    IWMProfile : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetVersion( 
            /* [out] */ WMT_VERSION *pdwVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out] */ WCHAR *pwszName,
            /* [out][in] */ DWORD *pcchName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetName( 
            /* [in] */ const WCHAR *pwszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescription( 
            /* [out] */ WCHAR *pwszDescription,
            /* [out][in] */ DWORD *pcchName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDescription( 
            /* [in] */ const WCHAR *pwszDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamCount( 
            /* [out] */ DWORD *pcStreams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStream( 
            /* [in] */ DWORD dwStreamIndex,
            /* [out] */ IWMStreamConfig **ppConfig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamByNumber( 
            /* [in] */ WORD wStreamNum,
            /* [out] */ IWMStreamConfig **ppConfig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveStream( 
            /* [in] */ IWMStreamConfig *pConfig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveStreamByNumber( 
            /* [in] */ WORD wStreamNum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddStream( 
            /* [in] */ IWMStreamConfig *pConfig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReconfigStream( 
            /* [in] */ IWMStreamConfig *pConfig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateNewStream( 
            /* [in] */ REFGUID guidStreamType,
            /* [out] */ IWMStreamConfig **ppConfig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMutualExclusionCount( 
            /* [out] */ DWORD *pcME) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMutualExclusion( 
            /* [in] */ DWORD dwMEIndex,
            /* [out] */ IWMMutualExclusion **ppME) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveMutualExclusion( 
            /* [in] */ IWMMutualExclusion *pME) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddMutualExclusion( 
            /* [in] */ IWMMutualExclusion *pME) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateNewMutualExclusion( 
            /* [out] */ IWMMutualExclusion **ppME) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMProfileVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMProfile * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMProfile * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMProfile * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersion )( 
            IWMProfile * This,
            /* [out] */ WMT_VERSION *pdwVersion);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IWMProfile * This,
            /* [out] */ WCHAR *pwszName,
            /* [out][in] */ DWORD *pcchName);
        
        HRESULT ( STDMETHODCALLTYPE *SetName )( 
            IWMProfile * This,
            /* [in] */ const WCHAR *pwszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescription )( 
            IWMProfile * This,
            /* [out] */ WCHAR *pwszDescription,
            /* [out][in] */ DWORD *pcchName);
        
        HRESULT ( STDMETHODCALLTYPE *SetDescription )( 
            IWMProfile * This,
            /* [in] */ const WCHAR *pwszDescription);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamCount )( 
            IWMProfile * This,
            /* [out] */ DWORD *pcStreams);
        
        HRESULT ( STDMETHODCALLTYPE *GetStream )( 
            IWMProfile * This,
            /* [in] */ DWORD dwStreamIndex,
            /* [out] */ IWMStreamConfig **ppConfig);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamByNumber )( 
            IWMProfile * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ IWMStreamConfig **ppConfig);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveStream )( 
            IWMProfile * This,
            /* [in] */ IWMStreamConfig *pConfig);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveStreamByNumber )( 
            IWMProfile * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE *AddStream )( 
            IWMProfile * This,
            /* [in] */ IWMStreamConfig *pConfig);
        
        HRESULT ( STDMETHODCALLTYPE *ReconfigStream )( 
            IWMProfile * This,
            /* [in] */ IWMStreamConfig *pConfig);
        
        HRESULT ( STDMETHODCALLTYPE *CreateNewStream )( 
            IWMProfile * This,
            /* [in] */ REFGUID guidStreamType,
            /* [out] */ IWMStreamConfig **ppConfig);
        
        HRESULT ( STDMETHODCALLTYPE *GetMutualExclusionCount )( 
            IWMProfile * This,
            /* [out] */ DWORD *pcME);
        
        HRESULT ( STDMETHODCALLTYPE *GetMutualExclusion )( 
            IWMProfile * This,
            /* [in] */ DWORD dwMEIndex,
            /* [out] */ IWMMutualExclusion **ppME);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveMutualExclusion )( 
            IWMProfile * This,
            /* [in] */ IWMMutualExclusion *pME);
        
        HRESULT ( STDMETHODCALLTYPE *AddMutualExclusion )( 
            IWMProfile * This,
            /* [in] */ IWMMutualExclusion *pME);
        
        HRESULT ( STDMETHODCALLTYPE *CreateNewMutualExclusion )( 
            IWMProfile * This,
            /* [out] */ IWMMutualExclusion **ppME);
        
        END_INTERFACE
    } IWMProfileVtbl;

    interface IWMProfile
    {
        CONST_VTBL struct IWMProfileVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMProfile_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMProfile_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMProfile_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMProfile_GetVersion(This,pdwVersion)	\
    ( (This)->lpVtbl -> GetVersion(This,pdwVersion) ) 

#define IWMProfile_GetName(This,pwszName,pcchName)	\
    ( (This)->lpVtbl -> GetName(This,pwszName,pcchName) ) 

#define IWMProfile_SetName(This,pwszName)	\
    ( (This)->lpVtbl -> SetName(This,pwszName) ) 

#define IWMProfile_GetDescription(This,pwszDescription,pcchName)	\
    ( (This)->lpVtbl -> GetDescription(This,pwszDescription,pcchName) ) 

#define IWMProfile_SetDescription(This,pwszDescription)	\
    ( (This)->lpVtbl -> SetDescription(This,pwszDescription) ) 

#define IWMProfile_GetStreamCount(This,pcStreams)	\
    ( (This)->lpVtbl -> GetStreamCount(This,pcStreams) ) 

#define IWMProfile_GetStream(This,dwStreamIndex,ppConfig)	\
    ( (This)->lpVtbl -> GetStream(This,dwStreamIndex,ppConfig) ) 

#define IWMProfile_GetStreamByNumber(This,wStreamNum,ppConfig)	\
    ( (This)->lpVtbl -> GetStreamByNumber(This,wStreamNum,ppConfig) ) 

#define IWMProfile_RemoveStream(This,pConfig)	\
    ( (This)->lpVtbl -> RemoveStream(This,pConfig) ) 

#define IWMProfile_RemoveStreamByNumber(This,wStreamNum)	\
    ( (This)->lpVtbl -> RemoveStreamByNumber(This,wStreamNum) ) 

#define IWMProfile_AddStream(This,pConfig)	\
    ( (This)->lpVtbl -> AddStream(This,pConfig) ) 

#define IWMProfile_ReconfigStream(This,pConfig)	\
    ( (This)->lpVtbl -> ReconfigStream(This,pConfig) ) 

#define IWMProfile_CreateNewStream(This,guidStreamType,ppConfig)	\
    ( (This)->lpVtbl -> CreateNewStream(This,guidStreamType,ppConfig) ) 

#define IWMProfile_GetMutualExclusionCount(This,pcME)	\
    ( (This)->lpVtbl -> GetMutualExclusionCount(This,pcME) ) 

#define IWMProfile_GetMutualExclusion(This,dwMEIndex,ppME)	\
    ( (This)->lpVtbl -> GetMutualExclusion(This,dwMEIndex,ppME) ) 

#define IWMProfile_RemoveMutualExclusion(This,pME)	\
    ( (This)->lpVtbl -> RemoveMutualExclusion(This,pME) ) 

#define IWMProfile_AddMutualExclusion(This,pME)	\
    ( (This)->lpVtbl -> AddMutualExclusion(This,pME) ) 

#define IWMProfile_CreateNewMutualExclusion(This,ppME)	\
    ( (This)->lpVtbl -> CreateNewMutualExclusion(This,ppME) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMProfile_INTERFACE_DEFINED__ */


#ifndef __IWMProfile2_INTERFACE_DEFINED__
#define __IWMProfile2_INTERFACE_DEFINED__

/* interface IWMProfile2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMProfile2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("07E72D33-D94E-4be7-8843-60AE5FF7E5F5")
    IWMProfile2 : public IWMProfile
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProfileID( 
            /* [out] */ GUID *pguidID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMProfile2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMProfile2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMProfile2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMProfile2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersion )( 
            IWMProfile2 * This,
            /* [out] */ WMT_VERSION *pdwVersion);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IWMProfile2 * This,
            /* [out] */ WCHAR *pwszName,
            /* [out][in] */ DWORD *pcchName);
        
        HRESULT ( STDMETHODCALLTYPE *SetName )( 
            IWMProfile2 * This,
            /* [in] */ const WCHAR *pwszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescription )( 
            IWMProfile2 * This,
            /* [out] */ WCHAR *pwszDescription,
            /* [out][in] */ DWORD *pcchName);
        
        HRESULT ( STDMETHODCALLTYPE *SetDescription )( 
            IWMProfile2 * This,
            /* [in] */ const WCHAR *pwszDescription);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamCount )( 
            IWMProfile2 * This,
            /* [out] */ DWORD *pcStreams);
        
        HRESULT ( STDMETHODCALLTYPE *GetStream )( 
            IWMProfile2 * This,
            /* [in] */ DWORD dwStreamIndex,
            /* [out] */ IWMStreamConfig **ppConfig);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamByNumber )( 
            IWMProfile2 * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ IWMStreamConfig **ppConfig);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveStream )( 
            IWMProfile2 * This,
            /* [in] */ IWMStreamConfig *pConfig);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveStreamByNumber )( 
            IWMProfile2 * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE *AddStream )( 
            IWMProfile2 * This,
            /* [in] */ IWMStreamConfig *pConfig);
        
        HRESULT ( STDMETHODCALLTYPE *ReconfigStream )( 
            IWMProfile2 * This,
            /* [in] */ IWMStreamConfig *pConfig);
        
        HRESULT ( STDMETHODCALLTYPE *CreateNewStream )( 
            IWMProfile2 * This,
            /* [in] */ REFGUID guidStreamType,
            /* [out] */ IWMStreamConfig **ppConfig);
        
        HRESULT ( STDMETHODCALLTYPE *GetMutualExclusionCount )( 
            IWMProfile2 * This,
            /* [out] */ DWORD *pcME);
        
        HRESULT ( STDMETHODCALLTYPE *GetMutualExclusion )( 
            IWMProfile2 * This,
            /* [in] */ DWORD dwMEIndex,
            /* [out] */ IWMMutualExclusion **ppME);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveMutualExclusion )( 
            IWMProfile2 * This,
            /* [in] */ IWMMutualExclusion *pME);
        
        HRESULT ( STDMETHODCALLTYPE *AddMutualExclusion )( 
            IWMProfile2 * This,
            /* [in] */ IWMMutualExclusion *pME);
        
        HRESULT ( STDMETHODCALLTYPE *CreateNewMutualExclusion )( 
            IWMProfile2 * This,
            /* [out] */ IWMMutualExclusion **ppME);
        
        HRESULT ( STDMETHODCALLTYPE *GetProfileID )( 
            IWMProfile2 * This,
            /* [out] */ GUID *pguidID);
        
        END_INTERFACE
    } IWMProfile2Vtbl;

    interface IWMProfile2
    {
        CONST_VTBL struct IWMProfile2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMProfile2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMProfile2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMProfile2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMProfile2_GetVersion(This,pdwVersion)	\
    ( (This)->lpVtbl -> GetVersion(This,pdwVersion) ) 

#define IWMProfile2_GetName(This,pwszName,pcchName)	\
    ( (This)->lpVtbl -> GetName(This,pwszName,pcchName) ) 

#define IWMProfile2_SetName(This,pwszName)	\
    ( (This)->lpVtbl -> SetName(This,pwszName) ) 

#define IWMProfile2_GetDescription(This,pwszDescription,pcchName)	\
    ( (This)->lpVtbl -> GetDescription(This,pwszDescription,pcchName) ) 

#define IWMProfile2_SetDescription(This,pwszDescription)	\
    ( (This)->lpVtbl -> SetDescription(This,pwszDescription) ) 

#define IWMProfile2_GetStreamCount(This,pcStreams)	\
    ( (This)->lpVtbl -> GetStreamCount(This,pcStreams) ) 

#define IWMProfile2_GetStream(This,dwStreamIndex,ppConfig)	\
    ( (This)->lpVtbl -> GetStream(This,dwStreamIndex,ppConfig) ) 

#define IWMProfile2_GetStreamByNumber(This,wStreamNum,ppConfig)	\
    ( (This)->lpVtbl -> GetStreamByNumber(This,wStreamNum,ppConfig) ) 

#define IWMProfile2_RemoveStream(This,pConfig)	\
    ( (This)->lpVtbl -> RemoveStream(This,pConfig) ) 

#define IWMProfile2_RemoveStreamByNumber(This,wStreamNum)	\
    ( (This)->lpVtbl -> RemoveStreamByNumber(This,wStreamNum) ) 

#define IWMProfile2_AddStream(This,pConfig)	\
    ( (This)->lpVtbl -> AddStream(This,pConfig) ) 

#define IWMProfile2_ReconfigStream(This,pConfig)	\
    ( (This)->lpVtbl -> ReconfigStream(This,pConfig) ) 

#define IWMProfile2_CreateNewStream(This,guidStreamType,ppConfig)	\
    ( (This)->lpVtbl -> CreateNewStream(This,guidStreamType,ppConfig) ) 

#define IWMProfile2_GetMutualExclusionCount(This,pcME)	\
    ( (This)->lpVtbl -> GetMutualExclusionCount(This,pcME) ) 

#define IWMProfile2_GetMutualExclusion(This,dwMEIndex,ppME)	\
    ( (This)->lpVtbl -> GetMutualExclusion(This,dwMEIndex,ppME) ) 

#define IWMProfile2_RemoveMutualExclusion(This,pME)	\
    ( (This)->lpVtbl -> RemoveMutualExclusion(This,pME) ) 

#define IWMProfile2_AddMutualExclusion(This,pME)	\
    ( (This)->lpVtbl -> AddMutualExclusion(This,pME) ) 

#define IWMProfile2_CreateNewMutualExclusion(This,ppME)	\
    ( (This)->lpVtbl -> CreateNewMutualExclusion(This,ppME) ) 


#define IWMProfile2_GetProfileID(This,pguidID)	\
    ( (This)->lpVtbl -> GetProfileID(This,pguidID) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMProfile2_INTERFACE_DEFINED__ */


#ifndef __IWMStreamConfig_INTERFACE_DEFINED__
#define __IWMStreamConfig_INTERFACE_DEFINED__

/* interface IWMStreamConfig */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMStreamConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BDC-2B2B-11d3-B36B-00C04F6108FF")
    IWMStreamConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStreamType( 
            /* [out] */ GUID *pguidStreamType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamNumber( 
            /* [out] */ WORD *pwStreamNum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStreamNumber( 
            /* [in] */ WORD wStreamNum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamName( 
            /* [out] */ WCHAR *pwszStreamName,
            /* [out][in] */ WORD *pcchStreamName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStreamName( 
            /* [in] */ WCHAR *pwszStreamName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConnectionName( 
            /* [out] */ WCHAR *pwszInputName,
            /* [out][in] */ WORD *pcchInputName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConnectionName( 
            /* [in] */ WCHAR *pwszInputName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBitrate( 
            /* [out] */ DWORD *pdwBitrate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBitrate( 
            /* [in] */ DWORD pdwBitrate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBufferWindow( 
            /* [out] */ DWORD *pmsBufferWindow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBufferWindow( 
            /* [in] */ DWORD msBufferWindow) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMStreamConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMStreamConfig * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMStreamConfig * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMStreamConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamType )( 
            IWMStreamConfig * This,
            /* [out] */ GUID *pguidStreamType);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamNumber )( 
            IWMStreamConfig * This,
            /* [out] */ WORD *pwStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE *SetStreamNumber )( 
            IWMStreamConfig * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamName )( 
            IWMStreamConfig * This,
            /* [out] */ WCHAR *pwszStreamName,
            /* [out][in] */ WORD *pcchStreamName);
        
        HRESULT ( STDMETHODCALLTYPE *SetStreamName )( 
            IWMStreamConfig * This,
            /* [in] */ WCHAR *pwszStreamName);
        
        HRESULT ( STDMETHODCALLTYPE *GetConnectionName )( 
            IWMStreamConfig * This,
            /* [out] */ WCHAR *pwszInputName,
            /* [out][in] */ WORD *pcchInputName);
        
        HRESULT ( STDMETHODCALLTYPE *SetConnectionName )( 
            IWMStreamConfig * This,
            /* [in] */ WCHAR *pwszInputName);
        
        HRESULT ( STDMETHODCALLTYPE *GetBitrate )( 
            IWMStreamConfig * This,
            /* [out] */ DWORD *pdwBitrate);
        
        HRESULT ( STDMETHODCALLTYPE *SetBitrate )( 
            IWMStreamConfig * This,
            /* [in] */ DWORD pdwBitrate);
        
        HRESULT ( STDMETHODCALLTYPE *GetBufferWindow )( 
            IWMStreamConfig * This,
            /* [out] */ DWORD *pmsBufferWindow);
        
        HRESULT ( STDMETHODCALLTYPE *SetBufferWindow )( 
            IWMStreamConfig * This,
            /* [in] */ DWORD msBufferWindow);
        
        END_INTERFACE
    } IWMStreamConfigVtbl;

    interface IWMStreamConfig
    {
        CONST_VTBL struct IWMStreamConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMStreamConfig_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMStreamConfig_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMStreamConfig_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMStreamConfig_GetStreamType(This,pguidStreamType)	\
    ( (This)->lpVtbl -> GetStreamType(This,pguidStreamType) ) 

#define IWMStreamConfig_GetStreamNumber(This,pwStreamNum)	\
    ( (This)->lpVtbl -> GetStreamNumber(This,pwStreamNum) ) 

#define IWMStreamConfig_SetStreamNumber(This,wStreamNum)	\
    ( (This)->lpVtbl -> SetStreamNumber(This,wStreamNum) ) 

#define IWMStreamConfig_GetStreamName(This,pwszStreamName,pcchStreamName)	\
    ( (This)->lpVtbl -> GetStreamName(This,pwszStreamName,pcchStreamName) ) 

#define IWMStreamConfig_SetStreamName(This,pwszStreamName)	\
    ( (This)->lpVtbl -> SetStreamName(This,pwszStreamName) ) 

#define IWMStreamConfig_GetConnectionName(This,pwszInputName,pcchInputName)	\
    ( (This)->lpVtbl -> GetConnectionName(This,pwszInputName,pcchInputName) ) 

#define IWMStreamConfig_SetConnectionName(This,pwszInputName)	\
    ( (This)->lpVtbl -> SetConnectionName(This,pwszInputName) ) 

#define IWMStreamConfig_GetBitrate(This,pdwBitrate)	\
    ( (This)->lpVtbl -> GetBitrate(This,pdwBitrate) ) 

#define IWMStreamConfig_SetBitrate(This,pdwBitrate)	\
    ( (This)->lpVtbl -> SetBitrate(This,pdwBitrate) ) 

#define IWMStreamConfig_GetBufferWindow(This,pmsBufferWindow)	\
    ( (This)->lpVtbl -> GetBufferWindow(This,pmsBufferWindow) ) 

#define IWMStreamConfig_SetBufferWindow(This,msBufferWindow)	\
    ( (This)->lpVtbl -> SetBufferWindow(This,msBufferWindow) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMStreamConfig_INTERFACE_DEFINED__ */


#ifndef __IWMPacketSize_INTERFACE_DEFINED__
#define __IWMPacketSize_INTERFACE_DEFINED__

/* interface IWMPacketSize */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMPacketSize;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CDFB97AB-188F-40b3-B643-5B7903975C59")
    IWMPacketSize : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMaxPacketSize( 
            /* [out] */ DWORD *pdwMaxPacketSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMaxPacketSize( 
            /* [in] */ DWORD dwMaxPacketSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPacketSizeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMPacketSize * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMPacketSize * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMPacketSize * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxPacketSize )( 
            IWMPacketSize * This,
            /* [out] */ DWORD *pdwMaxPacketSize);
        
        HRESULT ( STDMETHODCALLTYPE *SetMaxPacketSize )( 
            IWMPacketSize * This,
            /* [in] */ DWORD dwMaxPacketSize);
        
        END_INTERFACE
    } IWMPacketSizeVtbl;

    interface IWMPacketSize
    {
        CONST_VTBL struct IWMPacketSizeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPacketSize_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMPacketSize_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMPacketSize_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMPacketSize_GetMaxPacketSize(This,pdwMaxPacketSize)	\
    ( (This)->lpVtbl -> GetMaxPacketSize(This,pdwMaxPacketSize) ) 

#define IWMPacketSize_SetMaxPacketSize(This,dwMaxPacketSize)	\
    ( (This)->lpVtbl -> SetMaxPacketSize(This,dwMaxPacketSize) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMPacketSize_INTERFACE_DEFINED__ */


#ifndef __IWMStreamList_INTERFACE_DEFINED__
#define __IWMStreamList_INTERFACE_DEFINED__

/* interface IWMStreamList */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMStreamList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BDD-2B2B-11d3-B36B-00C04F6108FF")
    IWMStreamList : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStreams( 
            /* [out] */ WORD *pwStreamNumArray,
            /* [out][in] */ WORD *pcStreams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddStream( 
            /* [in] */ WORD wStreamNum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveStream( 
            /* [in] */ WORD wStreamNum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMStreamListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMStreamList * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMStreamList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMStreamList * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreams )( 
            IWMStreamList * This,
            /* [out] */ WORD *pwStreamNumArray,
            /* [out][in] */ WORD *pcStreams);
        
        HRESULT ( STDMETHODCALLTYPE *AddStream )( 
            IWMStreamList * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveStream )( 
            IWMStreamList * This,
            /* [in] */ WORD wStreamNum);
        
        END_INTERFACE
    } IWMStreamListVtbl;

    interface IWMStreamList
    {
        CONST_VTBL struct IWMStreamListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMStreamList_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMStreamList_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMStreamList_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMStreamList_GetStreams(This,pwStreamNumArray,pcStreams)	\
    ( (This)->lpVtbl -> GetStreams(This,pwStreamNumArray,pcStreams) ) 

#define IWMStreamList_AddStream(This,wStreamNum)	\
    ( (This)->lpVtbl -> AddStream(This,wStreamNum) ) 

#define IWMStreamList_RemoveStream(This,wStreamNum)	\
    ( (This)->lpVtbl -> RemoveStream(This,wStreamNum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMStreamList_INTERFACE_DEFINED__ */


#ifndef __IWMMutualExclusion_INTERFACE_DEFINED__
#define __IWMMutualExclusion_INTERFACE_DEFINED__

/* interface IWMMutualExclusion */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMMutualExclusion;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BDE-2B2B-11d3-B36B-00C04F6108FF")
    IWMMutualExclusion : public IWMStreamList
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ GUID *pguidType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetType( 
            /* [in] */ REFGUID guidType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMMutualExclusionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMMutualExclusion * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMMutualExclusion * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMMutualExclusion * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreams )( 
            IWMMutualExclusion * This,
            /* [out] */ WORD *pwStreamNumArray,
            /* [out][in] */ WORD *pcStreams);
        
        HRESULT ( STDMETHODCALLTYPE *AddStream )( 
            IWMMutualExclusion * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveStream )( 
            IWMMutualExclusion * This,
            /* [in] */ WORD wStreamNum);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            IWMMutualExclusion * This,
            /* [out] */ GUID *pguidType);
        
        HRESULT ( STDMETHODCALLTYPE *SetType )( 
            IWMMutualExclusion * This,
            /* [in] */ REFGUID guidType);
        
        END_INTERFACE
    } IWMMutualExclusionVtbl;

    interface IWMMutualExclusion
    {
        CONST_VTBL struct IWMMutualExclusionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMMutualExclusion_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMMutualExclusion_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMMutualExclusion_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMMutualExclusion_GetStreams(This,pwStreamNumArray,pcStreams)	\
    ( (This)->lpVtbl -> GetStreams(This,pwStreamNumArray,pcStreams) ) 

#define IWMMutualExclusion_AddStream(This,wStreamNum)	\
    ( (This)->lpVtbl -> AddStream(This,wStreamNum) ) 

#define IWMMutualExclusion_RemoveStream(This,wStreamNum)	\
    ( (This)->lpVtbl -> RemoveStream(This,wStreamNum) ) 


#define IWMMutualExclusion_GetType(This,pguidType)	\
    ( (This)->lpVtbl -> GetType(This,pguidType) ) 

#define IWMMutualExclusion_SetType(This,guidType)	\
    ( (This)->lpVtbl -> SetType(This,guidType) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMMutualExclusion_INTERFACE_DEFINED__ */


#ifndef __IWMWriterAdvanced_INTERFACE_DEFINED__
#define __IWMWriterAdvanced_INTERFACE_DEFINED__

/* interface IWMWriterAdvanced */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterAdvanced;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BE3-2B2B-11d3-B36B-00C04F6108FF")
    IWMWriterAdvanced : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSinkCount( 
            /* [out] */ DWORD *pcSinks) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSink( 
            /* [in] */ DWORD dwSinkNum,
            /* [out] */ IWMWriterSink **ppSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddSink( 
            /* [in] */ IWMWriterSink *pSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveSink( 
            /* [in] */ IWMWriterSink *pSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteStreamSample( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ DWORD msSampleSendTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer *pSample) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLiveSource( 
            BOOL fIsLiveSource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsRealTime( 
            /* [out] */ BOOL *pfRealTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWriterTime( 
            /* [out] */ QWORD *pcnsCurrentTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatistics( 
            /* [in] */ WORD wStreamNum,
            /* [out] */ WM_WRITER_STATISTICS *pStats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSyncTolerance( 
            /* [in] */ DWORD msWindow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSyncTolerance( 
            /* [out] */ DWORD *pmsWindow) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterAdvancedVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMWriterAdvanced * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMWriterAdvanced * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMWriterAdvanced * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSinkCount )( 
            IWMWriterAdvanced * This,
            /* [out] */ DWORD *pcSinks);
        
        HRESULT ( STDMETHODCALLTYPE *GetSink )( 
            IWMWriterAdvanced * This,
            /* [in] */ DWORD dwSinkNum,
            /* [out] */ IWMWriterSink **ppSink);
        
        HRESULT ( STDMETHODCALLTYPE *AddSink )( 
            IWMWriterAdvanced * This,
            /* [in] */ IWMWriterSink *pSink);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveSink )( 
            IWMWriterAdvanced * This,
            /* [in] */ IWMWriterSink *pSink);
        
        HRESULT ( STDMETHODCALLTYPE *WriteStreamSample )( 
            IWMWriterAdvanced * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ DWORD msSampleSendTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer *pSample);
        
        HRESULT ( STDMETHODCALLTYPE *SetLiveSource )( 
            IWMWriterAdvanced * This,
            BOOL fIsLiveSource);
        
        HRESULT ( STDMETHODCALLTYPE *IsRealTime )( 
            IWMWriterAdvanced * This,
            /* [out] */ BOOL *pfRealTime);
        
        HRESULT ( STDMETHODCALLTYPE *GetWriterTime )( 
            IWMWriterAdvanced * This,
            /* [out] */ QWORD *pcnsCurrentTime);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatistics )( 
            IWMWriterAdvanced * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ WM_WRITER_STATISTICS *pStats);
        
        HRESULT ( STDMETHODCALLTYPE *SetSyncTolerance )( 
            IWMWriterAdvanced * This,
            /* [in] */ DWORD msWindow);
        
        HRESULT ( STDMETHODCALLTYPE *GetSyncTolerance )( 
            IWMWriterAdvanced * This,
            /* [out] */ DWORD *pmsWindow);
        
        END_INTERFACE
    } IWMWriterAdvancedVtbl;

    interface IWMWriterAdvanced
    {
        CONST_VTBL struct IWMWriterAdvancedVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterAdvanced_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMWriterAdvanced_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMWriterAdvanced_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMWriterAdvanced_GetSinkCount(This,pcSinks)	\
    ( (This)->lpVtbl -> GetSinkCount(This,pcSinks) ) 

#define IWMWriterAdvanced_GetSink(This,dwSinkNum,ppSink)	\
    ( (This)->lpVtbl -> GetSink(This,dwSinkNum,ppSink) ) 

#define IWMWriterAdvanced_AddSink(This,pSink)	\
    ( (This)->lpVtbl -> AddSink(This,pSink) ) 

#define IWMWriterAdvanced_RemoveSink(This,pSink)	\
    ( (This)->lpVtbl -> RemoveSink(This,pSink) ) 

#define IWMWriterAdvanced_WriteStreamSample(This,wStreamNum,cnsSampleTime,msSampleSendTime,cnsSampleDuration,dwFlags,pSample)	\
    ( (This)->lpVtbl -> WriteStreamSample(This,wStreamNum,cnsSampleTime,msSampleSendTime,cnsSampleDuration,dwFlags,pSample) ) 

#define IWMWriterAdvanced_SetLiveSource(This,fIsLiveSource)	\
    ( (This)->lpVtbl -> SetLiveSource(This,fIsLiveSource) ) 

#define IWMWriterAdvanced_IsRealTime(This,pfRealTime)	\
    ( (This)->lpVtbl -> IsRealTime(This,pfRealTime) ) 

#define IWMWriterAdvanced_GetWriterTime(This,pcnsCurrentTime)	\
    ( (This)->lpVtbl -> GetWriterTime(This,pcnsCurrentTime) ) 

#define IWMWriterAdvanced_GetStatistics(This,wStreamNum,pStats)	\
    ( (This)->lpVtbl -> GetStatistics(This,wStreamNum,pStats) ) 

#define IWMWriterAdvanced_SetSyncTolerance(This,msWindow)	\
    ( (This)->lpVtbl -> SetSyncTolerance(This,msWindow) ) 

#define IWMWriterAdvanced_GetSyncTolerance(This,pmsWindow)	\
    ( (This)->lpVtbl -> GetSyncTolerance(This,pmsWindow) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMWriterAdvanced_INTERFACE_DEFINED__ */


#ifndef __IWMWriterAdvanced2_INTERFACE_DEFINED__
#define __IWMWriterAdvanced2_INTERFACE_DEFINED__

/* interface IWMWriterAdvanced2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterAdvanced2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("962dc1ec-c046-4db8-9cc7-26ceae500817")
    IWMWriterAdvanced2 : public IWMWriterAdvanced
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetInputSetting( 
            /* [in] */ DWORD dwInputNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE *pType,
            /* [out] */ BYTE *pValue,
            /* [out][in] */ WORD *pcbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInputSetting( 
            /* [in] */ DWORD dwInputNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE *pValue,
            /* [in] */ WORD cbLength) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterAdvanced2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMWriterAdvanced2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMWriterAdvanced2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMWriterAdvanced2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSinkCount )( 
            IWMWriterAdvanced2 * This,
            /* [out] */ DWORD *pcSinks);
        
        HRESULT ( STDMETHODCALLTYPE *GetSink )( 
            IWMWriterAdvanced2 * This,
            /* [in] */ DWORD dwSinkNum,
            /* [out] */ IWMWriterSink **ppSink);
        
        HRESULT ( STDMETHODCALLTYPE *AddSink )( 
            IWMWriterAdvanced2 * This,
            /* [in] */ IWMWriterSink *pSink);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveSink )( 
            IWMWriterAdvanced2 * This,
            /* [in] */ IWMWriterSink *pSink);
        
        HRESULT ( STDMETHODCALLTYPE *WriteStreamSample )( 
            IWMWriterAdvanced2 * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ DWORD msSampleSendTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer *pSample);
        
        HRESULT ( STDMETHODCALLTYPE *SetLiveSource )( 
            IWMWriterAdvanced2 * This,
            BOOL fIsLiveSource);
        
        HRESULT ( STDMETHODCALLTYPE *IsRealTime )( 
            IWMWriterAdvanced2 * This,
            /* [out] */ BOOL *pfRealTime);
        
        HRESULT ( STDMETHODCALLTYPE *GetWriterTime )( 
            IWMWriterAdvanced2 * This,
            /* [out] */ QWORD *pcnsCurrentTime);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatistics )( 
            IWMWriterAdvanced2 * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ WM_WRITER_STATISTICS *pStats);
        
        HRESULT ( STDMETHODCALLTYPE *SetSyncTolerance )( 
            IWMWriterAdvanced2 * This,
            /* [in] */ DWORD msWindow);
        
        HRESULT ( STDMETHODCALLTYPE *GetSyncTolerance )( 
            IWMWriterAdvanced2 * This,
            /* [out] */ DWORD *pmsWindow);
        
        HRESULT ( STDMETHODCALLTYPE *GetInputSetting )( 
            IWMWriterAdvanced2 * This,
            /* [in] */ DWORD dwInputNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE *pType,
            /* [out] */ BYTE *pValue,
            /* [out][in] */ WORD *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE *SetInputSetting )( 
            IWMWriterAdvanced2 * This,
            /* [in] */ DWORD dwInputNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE *pValue,
            /* [in] */ WORD cbLength);
        
        END_INTERFACE
    } IWMWriterAdvanced2Vtbl;

    interface IWMWriterAdvanced2
    {
        CONST_VTBL struct IWMWriterAdvanced2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterAdvanced2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMWriterAdvanced2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMWriterAdvanced2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMWriterAdvanced2_GetSinkCount(This,pcSinks)	\
    ( (This)->lpVtbl -> GetSinkCount(This,pcSinks) ) 

#define IWMWriterAdvanced2_GetSink(This,dwSinkNum,ppSink)	\
    ( (This)->lpVtbl -> GetSink(This,dwSinkNum,ppSink) ) 

#define IWMWriterAdvanced2_AddSink(This,pSink)	\
    ( (This)->lpVtbl -> AddSink(This,pSink) ) 

#define IWMWriterAdvanced2_RemoveSink(This,pSink)	\
    ( (This)->lpVtbl -> RemoveSink(This,pSink) ) 

#define IWMWriterAdvanced2_WriteStreamSample(This,wStreamNum,cnsSampleTime,msSampleSendTime,cnsSampleDuration,dwFlags,pSample)	\
    ( (This)->lpVtbl -> WriteStreamSample(This,wStreamNum,cnsSampleTime,msSampleSendTime,cnsSampleDuration,dwFlags,pSample) ) 

#define IWMWriterAdvanced2_SetLiveSource(This,fIsLiveSource)	\
    ( (This)->lpVtbl -> SetLiveSource(This,fIsLiveSource) ) 

#define IWMWriterAdvanced2_IsRealTime(This,pfRealTime)	\
    ( (This)->lpVtbl -> IsRealTime(This,pfRealTime) ) 

#define IWMWriterAdvanced2_GetWriterTime(This,pcnsCurrentTime)	\
    ( (This)->lpVtbl -> GetWriterTime(This,pcnsCurrentTime) ) 

#define IWMWriterAdvanced2_GetStatistics(This,wStreamNum,pStats)	\
    ( (This)->lpVtbl -> GetStatistics(This,wStreamNum,pStats) ) 

#define IWMWriterAdvanced2_SetSyncTolerance(This,msWindow)	\
    ( (This)->lpVtbl -> SetSyncTolerance(This,msWindow) ) 

#define IWMWriterAdvanced2_GetSyncTolerance(This,pmsWindow)	\
    ( (This)->lpVtbl -> GetSyncTolerance(This,pmsWindow) ) 


#define IWMWriterAdvanced2_GetInputSetting(This,dwInputNum,pszName,pType,pValue,pcbLength)	\
    ( (This)->lpVtbl -> GetInputSetting(This,dwInputNum,pszName,pType,pValue,pcbLength) ) 

#define IWMWriterAdvanced2_SetInputSetting(This,dwInputNum,pszName,Type,pValue,cbLength)	\
    ( (This)->lpVtbl -> SetInputSetting(This,dwInputNum,pszName,Type,pValue,cbLength) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMWriterAdvanced2_INTERFACE_DEFINED__ */


#ifndef __IWMWriterPostViewCallback_INTERFACE_DEFINED__
#define __IWMWriterPostViewCallback_INTERFACE_DEFINED__

/* interface IWMWriterPostViewCallback */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterPostViewCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D9D6549D-A193-4f24-B308-03123D9B7F8D")
    IWMWriterPostViewCallback : public IWMStatusCallback
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnPostViewSample( 
            /* [in] */ WORD wStreamNumber,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer *pSample,
            /* [in] */ void *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocateForPostView( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer **ppBuffer,
            /* [in] */ void *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterPostViewCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMWriterPostViewCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMWriterPostViewCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMWriterPostViewCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnStatus )( 
            IWMWriterPostViewCallback * This,
            /* [in] */ WMT_STATUS Status,
            /* [in] */ HRESULT hr,
            /* [in] */ WMT_ATTR_DATATYPE dwType,
            /* [in] */ BYTE *pValue,
            /* [in] */ void *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE *OnPostViewSample )( 
            IWMWriterPostViewCallback * This,
            /* [in] */ WORD wStreamNumber,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer *pSample,
            /* [in] */ void *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE *AllocateForPostView )( 
            IWMWriterPostViewCallback * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer **ppBuffer,
            /* [in] */ void *pvContext);
        
        END_INTERFACE
    } IWMWriterPostViewCallbackVtbl;

    interface IWMWriterPostViewCallback
    {
        CONST_VTBL struct IWMWriterPostViewCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterPostViewCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMWriterPostViewCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMWriterPostViewCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMWriterPostViewCallback_OnStatus(This,Status,hr,dwType,pValue,pvContext)	\
    ( (This)->lpVtbl -> OnStatus(This,Status,hr,dwType,pValue,pvContext) ) 


#define IWMWriterPostViewCallback_OnPostViewSample(This,wStreamNumber,cnsSampleTime,cnsSampleDuration,dwFlags,pSample,pvContext)	\
    ( (This)->lpVtbl -> OnPostViewSample(This,wStreamNumber,cnsSampleTime,cnsSampleDuration,dwFlags,pSample,pvContext) ) 

#define IWMWriterPostViewCallback_AllocateForPostView(This,wStreamNum,cbBuffer,ppBuffer,pvContext)	\
    ( (This)->lpVtbl -> AllocateForPostView(This,wStreamNum,cbBuffer,ppBuffer,pvContext) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMWriterPostViewCallback_INTERFACE_DEFINED__ */


#ifndef __IWMWriterPostView_INTERFACE_DEFINED__
#define __IWMWriterPostView_INTERFACE_DEFINED__

/* interface IWMWriterPostView */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterPostView;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("81E20CE4-75EF-491a-8004-FC53C45BDC3E")
    IWMWriterPostView : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetPostViewCallback( 
            IWMWriterPostViewCallback *pCallback,
            void *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetReceivePostViewSamples( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ BOOL fReceivePostViewSamples) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReceivePostViewSamples( 
            /* [in] */ WORD wStreamNum,
            /* [out] */ BOOL *pfReceivePostViewSamples) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPostViewProps( 
            /* [in] */ WORD wStreamNumber,
            /* [out] */ IWMMediaProps **ppOutput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPostViewProps( 
            /* [in] */ WORD wStreamNumber,
            /* [in] */ IWMMediaProps *pOutput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPostViewFormatCount( 
            /* [in] */ WORD wStreamNumber,
            /* [out] */ DWORD *pcFormats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPostViewFormat( 
            /* [in] */ WORD wStreamNumber,
            /* [in] */ DWORD dwFormatNumber,
            /* [out] */ IWMMediaProps **ppProps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAllocateForPostView( 
            /* [in] */ WORD wStreamNumber,
            /* [in] */ BOOL fAllocate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllocateForPostView( 
            /* [in] */ WORD wStreamNumber,
            /* [out] */ BOOL *pfAllocate) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterPostViewVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMWriterPostView * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMWriterPostView * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMWriterPostView * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPostViewCallback )( 
            IWMWriterPostView * This,
            IWMWriterPostViewCallback *pCallback,
            void *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE *SetReceivePostViewSamples )( 
            IWMWriterPostView * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ BOOL fReceivePostViewSamples);
        
        HRESULT ( STDMETHODCALLTYPE *GetReceivePostViewSamples )( 
            IWMWriterPostView * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ BOOL *pfReceivePostViewSamples);
        
        HRESULT ( STDMETHODCALLTYPE *GetPostViewProps )( 
            IWMWriterPostView * This,
            /* [in] */ WORD wStreamNumber,
            /* [out] */ IWMMediaProps **ppOutput);
        
        HRESULT ( STDMETHODCALLTYPE *SetPostViewProps )( 
            IWMWriterPostView * This,
            /* [in] */ WORD wStreamNumber,
            /* [in] */ IWMMediaProps *pOutput);
        
        HRESULT ( STDMETHODCALLTYPE *GetPostViewFormatCount )( 
            IWMWriterPostView * This,
            /* [in] */ WORD wStreamNumber,
            /* [out] */ DWORD *pcFormats);
        
        HRESULT ( STDMETHODCALLTYPE *GetPostViewFormat )( 
            IWMWriterPostView * This,
            /* [in] */ WORD wStreamNumber,
            /* [in] */ DWORD dwFormatNumber,
            /* [out] */ IWMMediaProps **ppProps);
        
        HRESULT ( STDMETHODCALLTYPE *SetAllocateForPostView )( 
            IWMWriterPostView * This,
            /* [in] */ WORD wStreamNumber,
            /* [in] */ BOOL fAllocate);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocateForPostView )( 
            IWMWriterPostView * This,
            /* [in] */ WORD wStreamNumber,
            /* [out] */ BOOL *pfAllocate);
        
        END_INTERFACE
    } IWMWriterPostViewVtbl;

    interface IWMWriterPostView
    {
        CONST_VTBL struct IWMWriterPostViewVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterPostView_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMWriterPostView_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMWriterPostView_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMWriterPostView_SetPostViewCallback(This,pCallback,pvContext)	\
    ( (This)->lpVtbl -> SetPostViewCallback(This,pCallback,pvContext) ) 

#define IWMWriterPostView_SetReceivePostViewSamples(This,wStreamNum,fReceivePostViewSamples)	\
    ( (This)->lpVtbl -> SetReceivePostViewSamples(This,wStreamNum,fReceivePostViewSamples) ) 

#define IWMWriterPostView_GetReceivePostViewSamples(This,wStreamNum,pfReceivePostViewSamples)	\
    ( (This)->lpVtbl -> GetReceivePostViewSamples(This,wStreamNum,pfReceivePostViewSamples) ) 

#define IWMWriterPostView_GetPostViewProps(This,wStreamNumber,ppOutput)	\
    ( (This)->lpVtbl -> GetPostViewProps(This,wStreamNumber,ppOutput) ) 

#define IWMWriterPostView_SetPostViewProps(This,wStreamNumber,pOutput)	\
    ( (This)->lpVtbl -> SetPostViewProps(This,wStreamNumber,pOutput) ) 

#define IWMWriterPostView_GetPostViewFormatCount(This,wStreamNumber,pcFormats)	\
    ( (This)->lpVtbl -> GetPostViewFormatCount(This,wStreamNumber,pcFormats) ) 

#define IWMWriterPostView_GetPostViewFormat(This,wStreamNumber,dwFormatNumber,ppProps)	\
    ( (This)->lpVtbl -> GetPostViewFormat(This,wStreamNumber,dwFormatNumber,ppProps) ) 

#define IWMWriterPostView_SetAllocateForPostView(This,wStreamNumber,fAllocate)	\
    ( (This)->lpVtbl -> SetAllocateForPostView(This,wStreamNumber,fAllocate) ) 

#define IWMWriterPostView_GetAllocateForPostView(This,wStreamNumber,pfAllocate)	\
    ( (This)->lpVtbl -> GetAllocateForPostView(This,wStreamNumber,pfAllocate) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMWriterPostView_INTERFACE_DEFINED__ */


#ifndef __IWMWriterSink_INTERFACE_DEFINED__
#define __IWMWriterSink_INTERFACE_DEFINED__

/* interface IWMWriterSink */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BE4-2B2B-11d3-B36B-00C04F6108FF")
    IWMWriterSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnHeader( 
            /* [in] */ INSSBuffer *pHeader) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsRealTime( 
            /* [out] */ BOOL *pfRealTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocateDataUnit( 
            /* [in] */ DWORD cbDataUnit,
            /* [out] */ INSSBuffer **ppDataUnit) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDataUnit( 
            /* [in] */ INSSBuffer *pDataUnit) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnEndWriting( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMWriterSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMWriterSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMWriterSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnHeader )( 
            IWMWriterSink * This,
            /* [in] */ INSSBuffer *pHeader);
        
        HRESULT ( STDMETHODCALLTYPE *IsRealTime )( 
            IWMWriterSink * This,
            /* [out] */ BOOL *pfRealTime);
        
        HRESULT ( STDMETHODCALLTYPE *AllocateDataUnit )( 
            IWMWriterSink * This,
            /* [in] */ DWORD cbDataUnit,
            /* [out] */ INSSBuffer **ppDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE *OnDataUnit )( 
            IWMWriterSink * This,
            /* [in] */ INSSBuffer *pDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE *OnEndWriting )( 
            IWMWriterSink * This);
        
        END_INTERFACE
    } IWMWriterSinkVtbl;

    interface IWMWriterSink
    {
        CONST_VTBL struct IWMWriterSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterSink_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMWriterSink_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMWriterSink_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMWriterSink_OnHeader(This,pHeader)	\
    ( (This)->lpVtbl -> OnHeader(This,pHeader) ) 

#define IWMWriterSink_IsRealTime(This,pfRealTime)	\
    ( (This)->lpVtbl -> IsRealTime(This,pfRealTime) ) 

#define IWMWriterSink_AllocateDataUnit(This,cbDataUnit,ppDataUnit)	\
    ( (This)->lpVtbl -> AllocateDataUnit(This,cbDataUnit,ppDataUnit) ) 

#define IWMWriterSink_OnDataUnit(This,pDataUnit)	\
    ( (This)->lpVtbl -> OnDataUnit(This,pDataUnit) ) 

#define IWMWriterSink_OnEndWriting(This)	\
    ( (This)->lpVtbl -> OnEndWriting(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMWriterSink_INTERFACE_DEFINED__ */


#ifndef __IWMRegisterCallback_INTERFACE_DEFINED__
#define __IWMRegisterCallback_INTERFACE_DEFINED__

/* interface IWMRegisterCallback */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMRegisterCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CF4B1F99-4DE2-4e49-A363-252740D99BC1")
    IWMRegisterCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Advise( 
            /* [in] */ IWMStatusCallback *pCallback,
            /* [in] */ void *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unadvise( 
            /* [in] */ IWMStatusCallback *pCallback,
            /* [in] */ void *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMRegisterCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMRegisterCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMRegisterCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMRegisterCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *Advise )( 
            IWMRegisterCallback * This,
            /* [in] */ IWMStatusCallback *pCallback,
            /* [in] */ void *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE *Unadvise )( 
            IWMRegisterCallback * This,
            /* [in] */ IWMStatusCallback *pCallback,
            /* [in] */ void *pvContext);
        
        END_INTERFACE
    } IWMRegisterCallbackVtbl;

    interface IWMRegisterCallback
    {
        CONST_VTBL struct IWMRegisterCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMRegisterCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMRegisterCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMRegisterCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMRegisterCallback_Advise(This,pCallback,pvContext)	\
    ( (This)->lpVtbl -> Advise(This,pCallback,pvContext) ) 

#define IWMRegisterCallback_Unadvise(This,pCallback,pvContext)	\
    ( (This)->lpVtbl -> Unadvise(This,pCallback,pvContext) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMRegisterCallback_INTERFACE_DEFINED__ */


#ifndef __IWMWriterFileSink_INTERFACE_DEFINED__
#define __IWMWriterFileSink_INTERFACE_DEFINED__

/* interface IWMWriterFileSink */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterFileSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BE5-2B2B-11d3-B36B-00C04F6108FF")
    IWMWriterFileSink : public IWMWriterSink
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ const WCHAR *pwszFilename) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterFileSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMWriterFileSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMWriterFileSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMWriterFileSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnHeader )( 
            IWMWriterFileSink * This,
            /* [in] */ INSSBuffer *pHeader);
        
        HRESULT ( STDMETHODCALLTYPE *IsRealTime )( 
            IWMWriterFileSink * This,
            /* [out] */ BOOL *pfRealTime);
        
        HRESULT ( STDMETHODCALLTYPE *AllocateDataUnit )( 
            IWMWriterFileSink * This,
            /* [in] */ DWORD cbDataUnit,
            /* [out] */ INSSBuffer **ppDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE *OnDataUnit )( 
            IWMWriterFileSink * This,
            /* [in] */ INSSBuffer *pDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE *OnEndWriting )( 
            IWMWriterFileSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *Open )( 
            IWMWriterFileSink * This,
            /* [in] */ const WCHAR *pwszFilename);
        
        END_INTERFACE
    } IWMWriterFileSinkVtbl;

    interface IWMWriterFileSink
    {
        CONST_VTBL struct IWMWriterFileSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterFileSink_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMWriterFileSink_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMWriterFileSink_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMWriterFileSink_OnHeader(This,pHeader)	\
    ( (This)->lpVtbl -> OnHeader(This,pHeader) ) 

#define IWMWriterFileSink_IsRealTime(This,pfRealTime)	\
    ( (This)->lpVtbl -> IsRealTime(This,pfRealTime) ) 

#define IWMWriterFileSink_AllocateDataUnit(This,cbDataUnit,ppDataUnit)	\
    ( (This)->lpVtbl -> AllocateDataUnit(This,cbDataUnit,ppDataUnit) ) 

#define IWMWriterFileSink_OnDataUnit(This,pDataUnit)	\
    ( (This)->lpVtbl -> OnDataUnit(This,pDataUnit) ) 

#define IWMWriterFileSink_OnEndWriting(This)	\
    ( (This)->lpVtbl -> OnEndWriting(This) ) 


#define IWMWriterFileSink_Open(This,pwszFilename)	\
    ( (This)->lpVtbl -> Open(This,pwszFilename) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMWriterFileSink_INTERFACE_DEFINED__ */


#ifndef __IWMWriterFileSink2_INTERFACE_DEFINED__
#define __IWMWriterFileSink2_INTERFACE_DEFINED__

/* interface IWMWriterFileSink2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterFileSink2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("14282BA7-4AEF-4205-8CE5-C229035A05BC")
    IWMWriterFileSink2 : public IWMWriterFileSink
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Start( 
            /* [in] */ QWORD cnsStartTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( 
            /* [in] */ QWORD cnsStopTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsStopped( 
            /* [out] */ BOOL *pfStopped) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFileDuration( 
            /* [out] */ QWORD *pcnsDuration) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFileSize( 
            /* [out] */ QWORD *pcbFile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsClosed( 
            /* [out] */ BOOL *pfClosed) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterFileSink2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMWriterFileSink2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMWriterFileSink2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMWriterFileSink2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnHeader )( 
            IWMWriterFileSink2 * This,
            /* [in] */ INSSBuffer *pHeader);
        
        HRESULT ( STDMETHODCALLTYPE *IsRealTime )( 
            IWMWriterFileSink2 * This,
            /* [out] */ BOOL *pfRealTime);
        
        HRESULT ( STDMETHODCALLTYPE *AllocateDataUnit )( 
            IWMWriterFileSink2 * This,
            /* [in] */ DWORD cbDataUnit,
            /* [out] */ INSSBuffer **ppDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE *OnDataUnit )( 
            IWMWriterFileSink2 * This,
            /* [in] */ INSSBuffer *pDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE *OnEndWriting )( 
            IWMWriterFileSink2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Open )( 
            IWMWriterFileSink2 * This,
            /* [in] */ const WCHAR *pwszFilename);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            IWMWriterFileSink2 * This,
            /* [in] */ QWORD cnsStartTime);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IWMWriterFileSink2 * This,
            /* [in] */ QWORD cnsStopTime);
        
        HRESULT ( STDMETHODCALLTYPE *IsStopped )( 
            IWMWriterFileSink2 * This,
            /* [out] */ BOOL *pfStopped);
        
        HRESULT ( STDMETHODCALLTYPE *GetFileDuration )( 
            IWMWriterFileSink2 * This,
            /* [out] */ QWORD *pcnsDuration);
        
        HRESULT ( STDMETHODCALLTYPE *GetFileSize )( 
            IWMWriterFileSink2 * This,
            /* [out] */ QWORD *pcbFile);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            IWMWriterFileSink2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsClosed )( 
            IWMWriterFileSink2 * This,
            /* [out] */ BOOL *pfClosed);
        
        END_INTERFACE
    } IWMWriterFileSink2Vtbl;

    interface IWMWriterFileSink2
    {
        CONST_VTBL struct IWMWriterFileSink2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterFileSink2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMWriterFileSink2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMWriterFileSink2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMWriterFileSink2_OnHeader(This,pHeader)	\
    ( (This)->lpVtbl -> OnHeader(This,pHeader) ) 

#define IWMWriterFileSink2_IsRealTime(This,pfRealTime)	\
    ( (This)->lpVtbl -> IsRealTime(This,pfRealTime) ) 

#define IWMWriterFileSink2_AllocateDataUnit(This,cbDataUnit,ppDataUnit)	\
    ( (This)->lpVtbl -> AllocateDataUnit(This,cbDataUnit,ppDataUnit) ) 

#define IWMWriterFileSink2_OnDataUnit(This,pDataUnit)	\
    ( (This)->lpVtbl -> OnDataUnit(This,pDataUnit) ) 

#define IWMWriterFileSink2_OnEndWriting(This)	\
    ( (This)->lpVtbl -> OnEndWriting(This) ) 


#define IWMWriterFileSink2_Open(This,pwszFilename)	\
    ( (This)->lpVtbl -> Open(This,pwszFilename) ) 


#define IWMWriterFileSink2_Start(This,cnsStartTime)	\
    ( (This)->lpVtbl -> Start(This,cnsStartTime) ) 

#define IWMWriterFileSink2_Stop(This,cnsStopTime)	\
    ( (This)->lpVtbl -> Stop(This,cnsStopTime) ) 

#define IWMWriterFileSink2_IsStopped(This,pfStopped)	\
    ( (This)->lpVtbl -> IsStopped(This,pfStopped) ) 

#define IWMWriterFileSink2_GetFileDuration(This,pcnsDuration)	\
    ( (This)->lpVtbl -> GetFileDuration(This,pcnsDuration) ) 

#define IWMWriterFileSink2_GetFileSize(This,pcbFile)	\
    ( (This)->lpVtbl -> GetFileSize(This,pcbFile) ) 

#define IWMWriterFileSink2_Close(This)	\
    ( (This)->lpVtbl -> Close(This) ) 

#define IWMWriterFileSink2_IsClosed(This,pfClosed)	\
    ( (This)->lpVtbl -> IsClosed(This,pfClosed) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMWriterFileSink2_INTERFACE_DEFINED__ */


#ifndef __IWMWriterNetworkSink_INTERFACE_DEFINED__
#define __IWMWriterNetworkSink_INTERFACE_DEFINED__

/* interface IWMWriterNetworkSink */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMWriterNetworkSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BE7-2B2B-11d3-B36B-00C04F6108FF")
    IWMWriterNetworkSink : public IWMWriterSink
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetMaximumClients( 
            /* [in] */ DWORD dwMaxClients) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaximumClients( 
            /* [out] */ DWORD *pdwMaxClients) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNetworkProtocol( 
            /* [in] */ WMT_NET_PROTOCOL protocol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNetworkProtocol( 
            /* [out] */ WMT_NET_PROTOCOL *pProtocol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHostURL( 
            /* [out] */ WCHAR *pwszURL,
            /* [out][in] */ DWORD *pcchURL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [out][in] */ DWORD *pdwPortNum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMWriterNetworkSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMWriterNetworkSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMWriterNetworkSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMWriterNetworkSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnHeader )( 
            IWMWriterNetworkSink * This,
            /* [in] */ INSSBuffer *pHeader);
        
        HRESULT ( STDMETHODCALLTYPE *IsRealTime )( 
            IWMWriterNetworkSink * This,
            /* [out] */ BOOL *pfRealTime);
        
        HRESULT ( STDMETHODCALLTYPE *AllocateDataUnit )( 
            IWMWriterNetworkSink * This,
            /* [in] */ DWORD cbDataUnit,
            /* [out] */ INSSBuffer **ppDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE *OnDataUnit )( 
            IWMWriterNetworkSink * This,
            /* [in] */ INSSBuffer *pDataUnit);
        
        HRESULT ( STDMETHODCALLTYPE *OnEndWriting )( 
            IWMWriterNetworkSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetMaximumClients )( 
            IWMWriterNetworkSink * This,
            /* [in] */ DWORD dwMaxClients);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaximumClients )( 
            IWMWriterNetworkSink * This,
            /* [out] */ DWORD *pdwMaxClients);
        
        HRESULT ( STDMETHODCALLTYPE *SetNetworkProtocol )( 
            IWMWriterNetworkSink * This,
            /* [in] */ WMT_NET_PROTOCOL protocol);
        
        HRESULT ( STDMETHODCALLTYPE *GetNetworkProtocol )( 
            IWMWriterNetworkSink * This,
            /* [out] */ WMT_NET_PROTOCOL *pProtocol);
        
        HRESULT ( STDMETHODCALLTYPE *GetHostURL )( 
            IWMWriterNetworkSink * This,
            /* [out] */ WCHAR *pwszURL,
            /* [out][in] */ DWORD *pcchURL);
        
        HRESULT ( STDMETHODCALLTYPE *Open )( 
            IWMWriterNetworkSink * This,
            /* [out][in] */ DWORD *pdwPortNum);
        
        HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            IWMWriterNetworkSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            IWMWriterNetworkSink * This);
        
        END_INTERFACE
    } IWMWriterNetworkSinkVtbl;

    interface IWMWriterNetworkSink
    {
        CONST_VTBL struct IWMWriterNetworkSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMWriterNetworkSink_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMWriterNetworkSink_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMWriterNetworkSink_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMWriterNetworkSink_OnHeader(This,pHeader)	\
    ( (This)->lpVtbl -> OnHeader(This,pHeader) ) 

#define IWMWriterNetworkSink_IsRealTime(This,pfRealTime)	\
    ( (This)->lpVtbl -> IsRealTime(This,pfRealTime) ) 

#define IWMWriterNetworkSink_AllocateDataUnit(This,cbDataUnit,ppDataUnit)	\
    ( (This)->lpVtbl -> AllocateDataUnit(This,cbDataUnit,ppDataUnit) ) 

#define IWMWriterNetworkSink_OnDataUnit(This,pDataUnit)	\
    ( (This)->lpVtbl -> OnDataUnit(This,pDataUnit) ) 

#define IWMWriterNetworkSink_OnEndWriting(This)	\
    ( (This)->lpVtbl -> OnEndWriting(This) ) 


#define IWMWriterNetworkSink_SetMaximumClients(This,dwMaxClients)	\
    ( (This)->lpVtbl -> SetMaximumClients(This,dwMaxClients) ) 

#define IWMWriterNetworkSink_GetMaximumClients(This,pdwMaxClients)	\
    ( (This)->lpVtbl -> GetMaximumClients(This,pdwMaxClients) ) 

#define IWMWriterNetworkSink_SetNetworkProtocol(This,protocol)	\
    ( (This)->lpVtbl -> SetNetworkProtocol(This,protocol) ) 

#define IWMWriterNetworkSink_GetNetworkProtocol(This,pProtocol)	\
    ( (This)->lpVtbl -> GetNetworkProtocol(This,pProtocol) ) 

#define IWMWriterNetworkSink_GetHostURL(This,pwszURL,pcchURL)	\
    ( (This)->lpVtbl -> GetHostURL(This,pwszURL,pcchURL) ) 

#define IWMWriterNetworkSink_Open(This,pdwPortNum)	\
    ( (This)->lpVtbl -> Open(This,pdwPortNum) ) 

#define IWMWriterNetworkSink_Disconnect(This)	\
    ( (This)->lpVtbl -> Disconnect(This) ) 

#define IWMWriterNetworkSink_Close(This)	\
    ( (This)->lpVtbl -> Close(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMWriterNetworkSink_INTERFACE_DEFINED__ */


#ifndef __IWMClientConnections_INTERFACE_DEFINED__
#define __IWMClientConnections_INTERFACE_DEFINED__

/* interface IWMClientConnections */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMClientConnections;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("73C66010-A299-41df-B1F0-CCF03B09C1C6")
    IWMClientConnections : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetClientCount( 
            /* [out] */ DWORD *pcClients) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClientProperties( 
            /* [in] */ DWORD dwClientNum,
            /* [out] */ WM_CLIENT_PROPERTIES *pClientProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMClientConnectionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMClientConnections * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMClientConnections * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMClientConnections * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClientCount )( 
            IWMClientConnections * This,
            /* [out] */ DWORD *pcClients);
        
        HRESULT ( STDMETHODCALLTYPE *GetClientProperties )( 
            IWMClientConnections * This,
            /* [in] */ DWORD dwClientNum,
            /* [out] */ WM_CLIENT_PROPERTIES *pClientProperties);
        
        END_INTERFACE
    } IWMClientConnectionsVtbl;

    interface IWMClientConnections
    {
        CONST_VTBL struct IWMClientConnectionsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMClientConnections_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMClientConnections_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMClientConnections_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMClientConnections_GetClientCount(This,pcClients)	\
    ( (This)->lpVtbl -> GetClientCount(This,pcClients) ) 

#define IWMClientConnections_GetClientProperties(This,dwClientNum,pClientProperties)	\
    ( (This)->lpVtbl -> GetClientProperties(This,dwClientNum,pClientProperties) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMClientConnections_INTERFACE_DEFINED__ */


#ifndef __IWMReaderAdvanced_INTERFACE_DEFINED__
#define __IWMReaderAdvanced_INTERFACE_DEFINED__

/* interface IWMReaderAdvanced */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderAdvanced;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BEA-2B2B-11d3-B36B-00C04F6108FF")
    IWMReaderAdvanced : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetUserProvidedClock( 
            /* [in] */ BOOL fUserClock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUserProvidedClock( 
            /* [out] */ BOOL *pfUserClock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeliverTime( 
            /* [in] */ QWORD cnsTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetManualStreamSelection( 
            /* [in] */ BOOL fSelection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetManualStreamSelection( 
            /* [out] */ BOOL *pfSelection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStreamsSelected( 
            /* [in] */ WORD cStreamCount,
            /* [in] */ WORD *pwStreamNumbers,
            /* [in] */ WMT_STREAM_SELECTION *pSelections) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamSelected( 
            /* [in] */ WORD wStreamNum,
            /* [out] */ WMT_STREAM_SELECTION *pSelection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetReceiveSelectionCallbacks( 
            /* [in] */ BOOL fGetCallbacks) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReceiveSelectionCallbacks( 
            /* [in] */ BOOL *pfGetCallbacks) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetReceiveStreamSamples( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ BOOL fReceiveStreamSamples) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReceiveStreamSamples( 
            /* [in] */ WORD wStreamNum,
            /* [out] */ BOOL *pfReceiveStreamSamples) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAllocateForOutput( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ BOOL fAllocate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllocateForOutput( 
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ BOOL *pfAllocate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAllocateForStream( 
            /* [in] */ WORD dwStreamNum,
            /* [in] */ BOOL fAllocate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllocateForStream( 
            /* [in] */ WORD dwSreamNum,
            /* [out] */ BOOL *pfAllocate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatistics( 
            /* [in] */ WM_READER_STATISTICS *pStatistics) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetClientInfo( 
            /* [in] */ WM_READER_CLIENTINFO *pClientInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxOutputSampleSize( 
            /* [in] */ DWORD dwOutput,
            /* [out] */ DWORD *pcbMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxStreamSampleSize( 
            /* [in] */ WORD wStream,
            /* [out] */ DWORD *pcbMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyLateDelivery( 
            QWORD cnsLateness) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderAdvancedVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMReaderAdvanced * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMReaderAdvanced * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMReaderAdvanced * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetUserProvidedClock )( 
            IWMReaderAdvanced * This,
            /* [in] */ BOOL fUserClock);
        
        HRESULT ( STDMETHODCALLTYPE *GetUserProvidedClock )( 
            IWMReaderAdvanced * This,
            /* [out] */ BOOL *pfUserClock);
        
        HRESULT ( STDMETHODCALLTYPE *DeliverTime )( 
            IWMReaderAdvanced * This,
            /* [in] */ QWORD cnsTime);
        
        HRESULT ( STDMETHODCALLTYPE *SetManualStreamSelection )( 
            IWMReaderAdvanced * This,
            /* [in] */ BOOL fSelection);
        
        HRESULT ( STDMETHODCALLTYPE *GetManualStreamSelection )( 
            IWMReaderAdvanced * This,
            /* [out] */ BOOL *pfSelection);
        
        HRESULT ( STDMETHODCALLTYPE *SetStreamsSelected )( 
            IWMReaderAdvanced * This,
            /* [in] */ WORD cStreamCount,
            /* [in] */ WORD *pwStreamNumbers,
            /* [in] */ WMT_STREAM_SELECTION *pSelections);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamSelected )( 
            IWMReaderAdvanced * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ WMT_STREAM_SELECTION *pSelection);
        
        HRESULT ( STDMETHODCALLTYPE *SetReceiveSelectionCallbacks )( 
            IWMReaderAdvanced * This,
            /* [in] */ BOOL fGetCallbacks);
        
        HRESULT ( STDMETHODCALLTYPE *GetReceiveSelectionCallbacks )( 
            IWMReaderAdvanced * This,
            /* [in] */ BOOL *pfGetCallbacks);
        
        HRESULT ( STDMETHODCALLTYPE *SetReceiveStreamSamples )( 
            IWMReaderAdvanced * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ BOOL fReceiveStreamSamples);
        
        HRESULT ( STDMETHODCALLTYPE *GetReceiveStreamSamples )( 
            IWMReaderAdvanced * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ BOOL *pfReceiveStreamSamples);
        
        HRESULT ( STDMETHODCALLTYPE *SetAllocateForOutput )( 
            IWMReaderAdvanced * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ BOOL fAllocate);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocateForOutput )( 
            IWMReaderAdvanced * This,
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ BOOL *pfAllocate);
        
        HRESULT ( STDMETHODCALLTYPE *SetAllocateForStream )( 
            IWMReaderAdvanced * This,
            /* [in] */ WORD dwStreamNum,
            /* [in] */ BOOL fAllocate);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocateForStream )( 
            IWMReaderAdvanced * This,
            /* [in] */ WORD dwSreamNum,
            /* [out] */ BOOL *pfAllocate);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatistics )( 
            IWMReaderAdvanced * This,
            /* [in] */ WM_READER_STATISTICS *pStatistics);
        
        HRESULT ( STDMETHODCALLTYPE *SetClientInfo )( 
            IWMReaderAdvanced * This,
            /* [in] */ WM_READER_CLIENTINFO *pClientInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxOutputSampleSize )( 
            IWMReaderAdvanced * This,
            /* [in] */ DWORD dwOutput,
            /* [out] */ DWORD *pcbMax);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxStreamSampleSize )( 
            IWMReaderAdvanced * This,
            /* [in] */ WORD wStream,
            /* [out] */ DWORD *pcbMax);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyLateDelivery )( 
            IWMReaderAdvanced * This,
            QWORD cnsLateness);
        
        END_INTERFACE
    } IWMReaderAdvancedVtbl;

    interface IWMReaderAdvanced
    {
        CONST_VTBL struct IWMReaderAdvancedVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderAdvanced_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMReaderAdvanced_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMReaderAdvanced_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMReaderAdvanced_SetUserProvidedClock(This,fUserClock)	\
    ( (This)->lpVtbl -> SetUserProvidedClock(This,fUserClock) ) 

#define IWMReaderAdvanced_GetUserProvidedClock(This,pfUserClock)	\
    ( (This)->lpVtbl -> GetUserProvidedClock(This,pfUserClock) ) 

#define IWMReaderAdvanced_DeliverTime(This,cnsTime)	\
    ( (This)->lpVtbl -> DeliverTime(This,cnsTime) ) 

#define IWMReaderAdvanced_SetManualStreamSelection(This,fSelection)	\
    ( (This)->lpVtbl -> SetManualStreamSelection(This,fSelection) ) 

#define IWMReaderAdvanced_GetManualStreamSelection(This,pfSelection)	\
    ( (This)->lpVtbl -> GetManualStreamSelection(This,pfSelection) ) 

#define IWMReaderAdvanced_SetStreamsSelected(This,cStreamCount,pwStreamNumbers,pSelections)	\
    ( (This)->lpVtbl -> SetStreamsSelected(This,cStreamCount,pwStreamNumbers,pSelections) ) 

#define IWMReaderAdvanced_GetStreamSelected(This,wStreamNum,pSelection)	\
    ( (This)->lpVtbl -> GetStreamSelected(This,wStreamNum,pSelection) ) 

#define IWMReaderAdvanced_SetReceiveSelectionCallbacks(This,fGetCallbacks)	\
    ( (This)->lpVtbl -> SetReceiveSelectionCallbacks(This,fGetCallbacks) ) 

#define IWMReaderAdvanced_GetReceiveSelectionCallbacks(This,pfGetCallbacks)	\
    ( (This)->lpVtbl -> GetReceiveSelectionCallbacks(This,pfGetCallbacks) ) 

#define IWMReaderAdvanced_SetReceiveStreamSamples(This,wStreamNum,fReceiveStreamSamples)	\
    ( (This)->lpVtbl -> SetReceiveStreamSamples(This,wStreamNum,fReceiveStreamSamples) ) 

#define IWMReaderAdvanced_GetReceiveStreamSamples(This,wStreamNum,pfReceiveStreamSamples)	\
    ( (This)->lpVtbl -> GetReceiveStreamSamples(This,wStreamNum,pfReceiveStreamSamples) ) 

#define IWMReaderAdvanced_SetAllocateForOutput(This,dwOutputNum,fAllocate)	\
    ( (This)->lpVtbl -> SetAllocateForOutput(This,dwOutputNum,fAllocate) ) 

#define IWMReaderAdvanced_GetAllocateForOutput(This,dwOutputNum,pfAllocate)	\
    ( (This)->lpVtbl -> GetAllocateForOutput(This,dwOutputNum,pfAllocate) ) 

#define IWMReaderAdvanced_SetAllocateForStream(This,dwStreamNum,fAllocate)	\
    ( (This)->lpVtbl -> SetAllocateForStream(This,dwStreamNum,fAllocate) ) 

#define IWMReaderAdvanced_GetAllocateForStream(This,dwSreamNum,pfAllocate)	\
    ( (This)->lpVtbl -> GetAllocateForStream(This,dwSreamNum,pfAllocate) ) 

#define IWMReaderAdvanced_GetStatistics(This,pStatistics)	\
    ( (This)->lpVtbl -> GetStatistics(This,pStatistics) ) 

#define IWMReaderAdvanced_SetClientInfo(This,pClientInfo)	\
    ( (This)->lpVtbl -> SetClientInfo(This,pClientInfo) ) 

#define IWMReaderAdvanced_GetMaxOutputSampleSize(This,dwOutput,pcbMax)	\
    ( (This)->lpVtbl -> GetMaxOutputSampleSize(This,dwOutput,pcbMax) ) 

#define IWMReaderAdvanced_GetMaxStreamSampleSize(This,wStream,pcbMax)	\
    ( (This)->lpVtbl -> GetMaxStreamSampleSize(This,wStream,pcbMax) ) 

#define IWMReaderAdvanced_NotifyLateDelivery(This,cnsLateness)	\
    ( (This)->lpVtbl -> NotifyLateDelivery(This,cnsLateness) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMReaderAdvanced_INTERFACE_DEFINED__ */


#ifndef __IWMReaderAdvanced2_INTERFACE_DEFINED__
#define __IWMReaderAdvanced2_INTERFACE_DEFINED__

/* interface IWMReaderAdvanced2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderAdvanced2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ae14a945-b90c-4d0d-9127-80d665f7d73e")
    IWMReaderAdvanced2 : public IWMReaderAdvanced
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetPlayMode( 
            /* [in] */ WMT_PLAY_MODE Mode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPlayMode( 
            /* [out] */ WMT_PLAY_MODE *pMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBufferProgress( 
            /* [out] */ DWORD *pdwPercent,
            /* [out] */ QWORD *pcnsBuffering) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDownloadProgress( 
            /* [out] */ DWORD *pdwPercent,
            /* [out] */ QWORD *pqwBytesDownloaded,
            /* [out] */ QWORD *pcnsDownload) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSaveAsProgress( 
            /* [out] */ DWORD *pdwPercent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveFileAs( 
            /* [in] */ const WCHAR *pwszFilename) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProtocolName( 
            /* [out] */ WCHAR *pwszProtocol,
            /* [out][in] */ DWORD *pcchProtocol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartAtMarker( 
            /* [in] */ WORD wMarkerIndex,
            /* [in] */ QWORD cnsDuration,
            /* [in] */ float fRate,
            /* [in] */ void *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputSetting( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE *pType,
            /* [out] */ BYTE *pValue,
            /* [out][in] */ WORD *pcbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOutputSetting( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE *pValue,
            /* [in] */ WORD cbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Preroll( 
            /* [in] */ QWORD cnsStart,
            /* [in] */ QWORD cnsDuration,
            /* [in] */ float fRate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLogClientID( 
            /* [in] */ BOOL fLogClientID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLogClientID( 
            /* [out] */ BOOL *pfLogClientID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopBuffering( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenStream( 
            /* [in] */ IStream *pStream,
            /* [in] */ IWMReaderCallback *pCallback,
            /* [in] */ void *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderAdvanced2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMReaderAdvanced2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMReaderAdvanced2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetUserProvidedClock )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ BOOL fUserClock);
        
        HRESULT ( STDMETHODCALLTYPE *GetUserProvidedClock )( 
            IWMReaderAdvanced2 * This,
            /* [out] */ BOOL *pfUserClock);
        
        HRESULT ( STDMETHODCALLTYPE *DeliverTime )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ QWORD cnsTime);
        
        HRESULT ( STDMETHODCALLTYPE *SetManualStreamSelection )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ BOOL fSelection);
        
        HRESULT ( STDMETHODCALLTYPE *GetManualStreamSelection )( 
            IWMReaderAdvanced2 * This,
            /* [out] */ BOOL *pfSelection);
        
        HRESULT ( STDMETHODCALLTYPE *SetStreamsSelected )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ WORD cStreamCount,
            /* [in] */ WORD *pwStreamNumbers,
            /* [in] */ WMT_STREAM_SELECTION *pSelections);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamSelected )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ WMT_STREAM_SELECTION *pSelection);
        
        HRESULT ( STDMETHODCALLTYPE *SetReceiveSelectionCallbacks )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ BOOL fGetCallbacks);
        
        HRESULT ( STDMETHODCALLTYPE *GetReceiveSelectionCallbacks )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ BOOL *pfGetCallbacks);
        
        HRESULT ( STDMETHODCALLTYPE *SetReceiveStreamSamples )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ BOOL fReceiveStreamSamples);
        
        HRESULT ( STDMETHODCALLTYPE *GetReceiveStreamSamples )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ WORD wStreamNum,
            /* [out] */ BOOL *pfReceiveStreamSamples);
        
        HRESULT ( STDMETHODCALLTYPE *SetAllocateForOutput )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ BOOL fAllocate);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocateForOutput )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ DWORD dwOutputNum,
            /* [out] */ BOOL *pfAllocate);
        
        HRESULT ( STDMETHODCALLTYPE *SetAllocateForStream )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ WORD dwStreamNum,
            /* [in] */ BOOL fAllocate);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllocateForStream )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ WORD dwSreamNum,
            /* [out] */ BOOL *pfAllocate);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatistics )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ WM_READER_STATISTICS *pStatistics);
        
        HRESULT ( STDMETHODCALLTYPE *SetClientInfo )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ WM_READER_CLIENTINFO *pClientInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxOutputSampleSize )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ DWORD dwOutput,
            /* [out] */ DWORD *pcbMax);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxStreamSampleSize )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ WORD wStream,
            /* [out] */ DWORD *pcbMax);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyLateDelivery )( 
            IWMReaderAdvanced2 * This,
            QWORD cnsLateness);
        
        HRESULT ( STDMETHODCALLTYPE *SetPlayMode )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ WMT_PLAY_MODE Mode);
        
        HRESULT ( STDMETHODCALLTYPE *GetPlayMode )( 
            IWMReaderAdvanced2 * This,
            /* [out] */ WMT_PLAY_MODE *pMode);
        
        HRESULT ( STDMETHODCALLTYPE *GetBufferProgress )( 
            IWMReaderAdvanced2 * This,
            /* [out] */ DWORD *pdwPercent,
            /* [out] */ QWORD *pcnsBuffering);
        
        HRESULT ( STDMETHODCALLTYPE *GetDownloadProgress )( 
            IWMReaderAdvanced2 * This,
            /* [out] */ DWORD *pdwPercent,
            /* [out] */ QWORD *pqwBytesDownloaded,
            /* [out] */ QWORD *pcnsDownload);
        
        HRESULT ( STDMETHODCALLTYPE *GetSaveAsProgress )( 
            IWMReaderAdvanced2 * This,
            /* [out] */ DWORD *pdwPercent);
        
        HRESULT ( STDMETHODCALLTYPE *SaveFileAs )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ const WCHAR *pwszFilename);
        
        HRESULT ( STDMETHODCALLTYPE *GetProtocolName )( 
            IWMReaderAdvanced2 * This,
            /* [out] */ WCHAR *pwszProtocol,
            /* [out][in] */ DWORD *pcchProtocol);
        
        HRESULT ( STDMETHODCALLTYPE *StartAtMarker )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ WORD wMarkerIndex,
            /* [in] */ QWORD cnsDuration,
            /* [in] */ float fRate,
            /* [in] */ void *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputSetting )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE *pType,
            /* [out] */ BYTE *pValue,
            /* [out][in] */ WORD *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE *SetOutputSetting )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE *pValue,
            /* [in] */ WORD cbLength);
        
        HRESULT ( STDMETHODCALLTYPE *Preroll )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ QWORD cnsStart,
            /* [in] */ QWORD cnsDuration,
            /* [in] */ float fRate);
        
        HRESULT ( STDMETHODCALLTYPE *SetLogClientID )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ BOOL fLogClientID);
        
        HRESULT ( STDMETHODCALLTYPE *GetLogClientID )( 
            IWMReaderAdvanced2 * This,
            /* [out] */ BOOL *pfLogClientID);
        
        HRESULT ( STDMETHODCALLTYPE *StopBuffering )( 
            IWMReaderAdvanced2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *OpenStream )( 
            IWMReaderAdvanced2 * This,
            /* [in] */ IStream *pStream,
            /* [in] */ IWMReaderCallback *pCallback,
            /* [in] */ void *pvContext);
        
        END_INTERFACE
    } IWMReaderAdvanced2Vtbl;

    interface IWMReaderAdvanced2
    {
        CONST_VTBL struct IWMReaderAdvanced2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderAdvanced2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMReaderAdvanced2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMReaderAdvanced2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMReaderAdvanced2_SetUserProvidedClock(This,fUserClock)	\
    ( (This)->lpVtbl -> SetUserProvidedClock(This,fUserClock) ) 

#define IWMReaderAdvanced2_GetUserProvidedClock(This,pfUserClock)	\
    ( (This)->lpVtbl -> GetUserProvidedClock(This,pfUserClock) ) 

#define IWMReaderAdvanced2_DeliverTime(This,cnsTime)	\
    ( (This)->lpVtbl -> DeliverTime(This,cnsTime) ) 

#define IWMReaderAdvanced2_SetManualStreamSelection(This,fSelection)	\
    ( (This)->lpVtbl -> SetManualStreamSelection(This,fSelection) ) 

#define IWMReaderAdvanced2_GetManualStreamSelection(This,pfSelection)	\
    ( (This)->lpVtbl -> GetManualStreamSelection(This,pfSelection) ) 

#define IWMReaderAdvanced2_SetStreamsSelected(This,cStreamCount,pwStreamNumbers,pSelections)	\
    ( (This)->lpVtbl -> SetStreamsSelected(This,cStreamCount,pwStreamNumbers,pSelections) ) 

#define IWMReaderAdvanced2_GetStreamSelected(This,wStreamNum,pSelection)	\
    ( (This)->lpVtbl -> GetStreamSelected(This,wStreamNum,pSelection) ) 

#define IWMReaderAdvanced2_SetReceiveSelectionCallbacks(This,fGetCallbacks)	\
    ( (This)->lpVtbl -> SetReceiveSelectionCallbacks(This,fGetCallbacks) ) 

#define IWMReaderAdvanced2_GetReceiveSelectionCallbacks(This,pfGetCallbacks)	\
    ( (This)->lpVtbl -> GetReceiveSelectionCallbacks(This,pfGetCallbacks) ) 

#define IWMReaderAdvanced2_SetReceiveStreamSamples(This,wStreamNum,fReceiveStreamSamples)	\
    ( (This)->lpVtbl -> SetReceiveStreamSamples(This,wStreamNum,fReceiveStreamSamples) ) 

#define IWMReaderAdvanced2_GetReceiveStreamSamples(This,wStreamNum,pfReceiveStreamSamples)	\
    ( (This)->lpVtbl -> GetReceiveStreamSamples(This,wStreamNum,pfReceiveStreamSamples) ) 

#define IWMReaderAdvanced2_SetAllocateForOutput(This,dwOutputNum,fAllocate)	\
    ( (This)->lpVtbl -> SetAllocateForOutput(This,dwOutputNum,fAllocate) ) 

#define IWMReaderAdvanced2_GetAllocateForOutput(This,dwOutputNum,pfAllocate)	\
    ( (This)->lpVtbl -> GetAllocateForOutput(This,dwOutputNum,pfAllocate) ) 

#define IWMReaderAdvanced2_SetAllocateForStream(This,dwStreamNum,fAllocate)	\
    ( (This)->lpVtbl -> SetAllocateForStream(This,dwStreamNum,fAllocate) ) 

#define IWMReaderAdvanced2_GetAllocateForStream(This,dwSreamNum,pfAllocate)	\
    ( (This)->lpVtbl -> GetAllocateForStream(This,dwSreamNum,pfAllocate) ) 

#define IWMReaderAdvanced2_GetStatistics(This,pStatistics)	\
    ( (This)->lpVtbl -> GetStatistics(This,pStatistics) ) 

#define IWMReaderAdvanced2_SetClientInfo(This,pClientInfo)	\
    ( (This)->lpVtbl -> SetClientInfo(This,pClientInfo) ) 

#define IWMReaderAdvanced2_GetMaxOutputSampleSize(This,dwOutput,pcbMax)	\
    ( (This)->lpVtbl -> GetMaxOutputSampleSize(This,dwOutput,pcbMax) ) 

#define IWMReaderAdvanced2_GetMaxStreamSampleSize(This,wStream,pcbMax)	\
    ( (This)->lpVtbl -> GetMaxStreamSampleSize(This,wStream,pcbMax) ) 

#define IWMReaderAdvanced2_NotifyLateDelivery(This,cnsLateness)	\
    ( (This)->lpVtbl -> NotifyLateDelivery(This,cnsLateness) ) 


#define IWMReaderAdvanced2_SetPlayMode(This,Mode)	\
    ( (This)->lpVtbl -> SetPlayMode(This,Mode) ) 

#define IWMReaderAdvanced2_GetPlayMode(This,pMode)	\
    ( (This)->lpVtbl -> GetPlayMode(This,pMode) ) 

#define IWMReaderAdvanced2_GetBufferProgress(This,pdwPercent,pcnsBuffering)	\
    ( (This)->lpVtbl -> GetBufferProgress(This,pdwPercent,pcnsBuffering) ) 

#define IWMReaderAdvanced2_GetDownloadProgress(This,pdwPercent,pqwBytesDownloaded,pcnsDownload)	\
    ( (This)->lpVtbl -> GetDownloadProgress(This,pdwPercent,pqwBytesDownloaded,pcnsDownload) ) 

#define IWMReaderAdvanced2_GetSaveAsProgress(This,pdwPercent)	\
    ( (This)->lpVtbl -> GetSaveAsProgress(This,pdwPercent) ) 

#define IWMReaderAdvanced2_SaveFileAs(This,pwszFilename)	\
    ( (This)->lpVtbl -> SaveFileAs(This,pwszFilename) ) 

#define IWMReaderAdvanced2_GetProtocolName(This,pwszProtocol,pcchProtocol)	\
    ( (This)->lpVtbl -> GetProtocolName(This,pwszProtocol,pcchProtocol) ) 

#define IWMReaderAdvanced2_StartAtMarker(This,wMarkerIndex,cnsDuration,fRate,pvContext)	\
    ( (This)->lpVtbl -> StartAtMarker(This,wMarkerIndex,cnsDuration,fRate,pvContext) ) 

#define IWMReaderAdvanced2_GetOutputSetting(This,dwOutputNum,pszName,pType,pValue,pcbLength)	\
    ( (This)->lpVtbl -> GetOutputSetting(This,dwOutputNum,pszName,pType,pValue,pcbLength) ) 

#define IWMReaderAdvanced2_SetOutputSetting(This,dwOutputNum,pszName,Type,pValue,cbLength)	\
    ( (This)->lpVtbl -> SetOutputSetting(This,dwOutputNum,pszName,Type,pValue,cbLength) ) 

#define IWMReaderAdvanced2_Preroll(This,cnsStart,cnsDuration,fRate)	\
    ( (This)->lpVtbl -> Preroll(This,cnsStart,cnsDuration,fRate) ) 

#define IWMReaderAdvanced2_SetLogClientID(This,fLogClientID)	\
    ( (This)->lpVtbl -> SetLogClientID(This,fLogClientID) ) 

#define IWMReaderAdvanced2_GetLogClientID(This,pfLogClientID)	\
    ( (This)->lpVtbl -> GetLogClientID(This,pfLogClientID) ) 

#define IWMReaderAdvanced2_StopBuffering(This)	\
    ( (This)->lpVtbl -> StopBuffering(This) ) 

#define IWMReaderAdvanced2_OpenStream(This,pStream,pCallback,pvContext)	\
    ( (This)->lpVtbl -> OpenStream(This,pStream,pCallback,pvContext) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMReaderAdvanced2_INTERFACE_DEFINED__ */


#ifndef __IWMReaderAllocatorEx_INTERFACE_DEFINED__
#define __IWMReaderAllocatorEx_INTERFACE_DEFINED__

/* interface IWMReaderAllocatorEx */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderAllocatorEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9F762FA7-A22E-428d-93C9-AC82F3AAFE5A")
    IWMReaderAllocatorEx : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AllocateForStreamEx( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer **ppBuffer,
            /* [in] */ DWORD dwFlags,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ void *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocateForOutputEx( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer **ppBuffer,
            /* [in] */ DWORD dwFlags,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ void *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderAllocatorExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMReaderAllocatorEx * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMReaderAllocatorEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMReaderAllocatorEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *AllocateForStreamEx )( 
            IWMReaderAllocatorEx * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer **ppBuffer,
            /* [in] */ DWORD dwFlags,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ void *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE *AllocateForOutputEx )( 
            IWMReaderAllocatorEx * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer **ppBuffer,
            /* [in] */ DWORD dwFlags,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ void *pvContext);
        
        END_INTERFACE
    } IWMReaderAllocatorExVtbl;

    interface IWMReaderAllocatorEx
    {
        CONST_VTBL struct IWMReaderAllocatorExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderAllocatorEx_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMReaderAllocatorEx_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMReaderAllocatorEx_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMReaderAllocatorEx_AllocateForStreamEx(This,wStreamNum,cbBuffer,ppBuffer,dwFlags,cnsSampleTime,cnsSampleDuration,pvContext)	\
    ( (This)->lpVtbl -> AllocateForStreamEx(This,wStreamNum,cbBuffer,ppBuffer,dwFlags,cnsSampleTime,cnsSampleDuration,pvContext) ) 

#define IWMReaderAllocatorEx_AllocateForOutputEx(This,dwOutputNum,cbBuffer,ppBuffer,dwFlags,cnsSampleTime,cnsSampleDuration,pvContext)	\
    ( (This)->lpVtbl -> AllocateForOutputEx(This,dwOutputNum,cbBuffer,ppBuffer,dwFlags,cnsSampleTime,cnsSampleDuration,pvContext) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMReaderAllocatorEx_INTERFACE_DEFINED__ */


#ifndef __IWMReaderTypeNegotiation_INTERFACE_DEFINED__
#define __IWMReaderTypeNegotiation_INTERFACE_DEFINED__

/* interface IWMReaderTypeNegotiation */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderTypeNegotiation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FDBE5592-81A1-41ea-93BD-735CAD1ADC05")
    IWMReaderTypeNegotiation : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE TryOutputProps( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ IWMOutputMediaProps *pOutput) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderTypeNegotiationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMReaderTypeNegotiation * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMReaderTypeNegotiation * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMReaderTypeNegotiation * This);
        
        HRESULT ( STDMETHODCALLTYPE *TryOutputProps )( 
            IWMReaderTypeNegotiation * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ IWMOutputMediaProps *pOutput);
        
        END_INTERFACE
    } IWMReaderTypeNegotiationVtbl;

    interface IWMReaderTypeNegotiation
    {
        CONST_VTBL struct IWMReaderTypeNegotiationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderTypeNegotiation_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMReaderTypeNegotiation_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMReaderTypeNegotiation_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMReaderTypeNegotiation_TryOutputProps(This,dwOutputNum,pOutput)	\
    ( (This)->lpVtbl -> TryOutputProps(This,dwOutputNum,pOutput) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMReaderTypeNegotiation_INTERFACE_DEFINED__ */


#ifndef __IWMReaderCallbackAdvanced_INTERFACE_DEFINED__
#define __IWMReaderCallbackAdvanced_INTERFACE_DEFINED__

/* interface IWMReaderCallbackAdvanced */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderCallbackAdvanced;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BEB-2B2B-11d3-B36B-00C04F6108FF")
    IWMReaderCallbackAdvanced : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnStreamSample( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer *pSample,
            /* [in] */ void *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnTime( 
            /* [in] */ QWORD cnsCurrentTime,
            /* [in] */ void *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnStreamSelection( 
            /* [in] */ WORD wStreamCount,
            /* [in] */ WORD *pStreamNumbers,
            /* [in] */ WMT_STREAM_SELECTION *pSelections,
            /* [in] */ void *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnOutputPropsChanged( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ WM_MEDIA_TYPE *pMediaType,
            /* [in] */ void *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocateForStream( 
            /* [in] */ WORD wStreamNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer **ppBuffer,
            /* [in] */ void *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocateForOutput( 
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer **ppBuffer,
            /* [in] */ void *pvContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderCallbackAdvancedVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMReaderCallbackAdvanced * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMReaderCallbackAdvanced * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMReaderCallbackAdvanced * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnStreamSample )( 
            IWMReaderCallbackAdvanced * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ QWORD cnsSampleTime,
            /* [in] */ QWORD cnsSampleDuration,
            /* [in] */ DWORD dwFlags,
            /* [in] */ INSSBuffer *pSample,
            /* [in] */ void *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE *OnTime )( 
            IWMReaderCallbackAdvanced * This,
            /* [in] */ QWORD cnsCurrentTime,
            /* [in] */ void *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE *OnStreamSelection )( 
            IWMReaderCallbackAdvanced * This,
            /* [in] */ WORD wStreamCount,
            /* [in] */ WORD *pStreamNumbers,
            /* [in] */ WMT_STREAM_SELECTION *pSelections,
            /* [in] */ void *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE *OnOutputPropsChanged )( 
            IWMReaderCallbackAdvanced * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ WM_MEDIA_TYPE *pMediaType,
            /* [in] */ void *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE *AllocateForStream )( 
            IWMReaderCallbackAdvanced * This,
            /* [in] */ WORD wStreamNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer **ppBuffer,
            /* [in] */ void *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE *AllocateForOutput )( 
            IWMReaderCallbackAdvanced * This,
            /* [in] */ DWORD dwOutputNum,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ INSSBuffer **ppBuffer,
            /* [in] */ void *pvContext);
        
        END_INTERFACE
    } IWMReaderCallbackAdvancedVtbl;

    interface IWMReaderCallbackAdvanced
    {
        CONST_VTBL struct IWMReaderCallbackAdvancedVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderCallbackAdvanced_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMReaderCallbackAdvanced_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMReaderCallbackAdvanced_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMReaderCallbackAdvanced_OnStreamSample(This,wStreamNum,cnsSampleTime,cnsSampleDuration,dwFlags,pSample,pvContext)	\
    ( (This)->lpVtbl -> OnStreamSample(This,wStreamNum,cnsSampleTime,cnsSampleDuration,dwFlags,pSample,pvContext) ) 

#define IWMReaderCallbackAdvanced_OnTime(This,cnsCurrentTime,pvContext)	\
    ( (This)->lpVtbl -> OnTime(This,cnsCurrentTime,pvContext) ) 

#define IWMReaderCallbackAdvanced_OnStreamSelection(This,wStreamCount,pStreamNumbers,pSelections,pvContext)	\
    ( (This)->lpVtbl -> OnStreamSelection(This,wStreamCount,pStreamNumbers,pSelections,pvContext) ) 

#define IWMReaderCallbackAdvanced_OnOutputPropsChanged(This,dwOutputNum,pMediaType,pvContext)	\
    ( (This)->lpVtbl -> OnOutputPropsChanged(This,dwOutputNum,pMediaType,pvContext) ) 

#define IWMReaderCallbackAdvanced_AllocateForStream(This,wStreamNum,cbBuffer,ppBuffer,pvContext)	\
    ( (This)->lpVtbl -> AllocateForStream(This,wStreamNum,cbBuffer,ppBuffer,pvContext) ) 

#define IWMReaderCallbackAdvanced_AllocateForOutput(This,dwOutputNum,cbBuffer,ppBuffer,pvContext)	\
    ( (This)->lpVtbl -> AllocateForOutput(This,dwOutputNum,cbBuffer,ppBuffer,pvContext) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMReaderCallbackAdvanced_INTERFACE_DEFINED__ */


#ifndef __IWMDRMReader_INTERFACE_DEFINED__
#define __IWMDRMReader_INTERFACE_DEFINED__

/* interface IWMDRMReader */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMDRMReader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D2827540-3EE7-432c-B14C-DC17F085D3B3")
    IWMDRMReader : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AcquireLicense( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelLicenseAcquisition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Individualize( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelIndividualization( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MonitorLicenseAcquisition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelMonitorLicenseAcquisition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDRMProperty( 
            /* [in] */ LPCWSTR pwstrName,
            /* [in] */ WMT_ATTR_DATATYPE dwType,
            /* [in] */ const BYTE *pValue,
            /* [in] */ WORD cbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDRMProperty( 
            /* [in] */ LPCWSTR pwstrName,
            /* [out] */ WMT_ATTR_DATATYPE *pdwType,
            /* [out] */ BYTE *pValue,
            /* [out] */ WORD *pcbLength) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMDRMReaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMDRMReader * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMDRMReader * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMDRMReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *AcquireLicense )( 
            IWMDRMReader * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *CancelLicenseAcquisition )( 
            IWMDRMReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *Individualize )( 
            IWMDRMReader * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *CancelIndividualization )( 
            IWMDRMReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *MonitorLicenseAcquisition )( 
            IWMDRMReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *CancelMonitorLicenseAcquisition )( 
            IWMDRMReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDRMProperty )( 
            IWMDRMReader * This,
            /* [in] */ LPCWSTR pwstrName,
            /* [in] */ WMT_ATTR_DATATYPE dwType,
            /* [in] */ const BYTE *pValue,
            /* [in] */ WORD cbLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetDRMProperty )( 
            IWMDRMReader * This,
            /* [in] */ LPCWSTR pwstrName,
            /* [out] */ WMT_ATTR_DATATYPE *pdwType,
            /* [out] */ BYTE *pValue,
            /* [out] */ WORD *pcbLength);
        
        END_INTERFACE
    } IWMDRMReaderVtbl;

    interface IWMDRMReader
    {
        CONST_VTBL struct IWMDRMReaderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMDRMReader_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMDRMReader_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMDRMReader_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMDRMReader_AcquireLicense(This,dwFlags)	\
    ( (This)->lpVtbl -> AcquireLicense(This,dwFlags) ) 

#define IWMDRMReader_CancelLicenseAcquisition(This)	\
    ( (This)->lpVtbl -> CancelLicenseAcquisition(This) ) 

#define IWMDRMReader_Individualize(This,dwFlags)	\
    ( (This)->lpVtbl -> Individualize(This,dwFlags) ) 

#define IWMDRMReader_CancelIndividualization(This)	\
    ( (This)->lpVtbl -> CancelIndividualization(This) ) 

#define IWMDRMReader_MonitorLicenseAcquisition(This)	\
    ( (This)->lpVtbl -> MonitorLicenseAcquisition(This) ) 

#define IWMDRMReader_CancelMonitorLicenseAcquisition(This)	\
    ( (This)->lpVtbl -> CancelMonitorLicenseAcquisition(This) ) 

#define IWMDRMReader_SetDRMProperty(This,pwstrName,dwType,pValue,cbLength)	\
    ( (This)->lpVtbl -> SetDRMProperty(This,pwstrName,dwType,pValue,cbLength) ) 

#define IWMDRMReader_GetDRMProperty(This,pwstrName,pdwType,pValue,pcbLength)	\
    ( (This)->lpVtbl -> GetDRMProperty(This,pwstrName,pdwType,pValue,pcbLength) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMDRMReader_INTERFACE_DEFINED__ */


#ifndef __IWMReaderNetworkConfig_INTERFACE_DEFINED__
#define __IWMReaderNetworkConfig_INTERFACE_DEFINED__

/* interface IWMReaderNetworkConfig */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderNetworkConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BEC-2B2B-11d3-B36B-00C04F6108FF")
    IWMReaderNetworkConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetBufferingTime( 
            /* [out] */ QWORD *pcnsBufferingTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBufferingTime( 
            /* [in] */ QWORD cnsBufferingTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUDPPortRanges( 
            /* [out] */ WM_PORT_NUMBER_RANGE *pRangeArray,
            /* [out][in] */ DWORD *pcRanges) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUDPPortRanges( 
            /* [in] */ WM_PORT_NUMBER_RANGE *pRangeArray,
            /* [in] */ DWORD cRanges) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProxySettings( 
            LPCWSTR pwszProtocol,
            WMT_PROXY_SETTINGS *pProxySetting) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProxySettings( 
            LPCWSTR pwszProtocol,
            WMT_PROXY_SETTINGS ProxySetting) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProxyHostName( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ WCHAR *pwszHostName,
            /* [out][in] */ DWORD *pcchHostName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProxyHostName( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ LPCWSTR pwszHostName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProxyPort( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ DWORD *pdwPort) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProxyPort( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ DWORD dwPort) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProxyExceptionList( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ WCHAR *pwszExceptionList,
            /* [out][in] */ DWORD *pcchExceptionList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProxyExceptionList( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ LPCWSTR pwszExceptionList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProxyBypassForLocal( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ BOOL *pfBypassForLocal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProxyBypassForLocal( 
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ BOOL fBypassForLocal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetForceRerunAutoProxyDetection( 
            /* [out] */ BOOL *pfForceRerunDetection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetForceRerunAutoProxyDetection( 
            /* [in] */ BOOL fForceRerunDetection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnableMulticast( 
            /* [out] */ BOOL *pfEnableMulticast) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEnableMulticast( 
            /* [in] */ BOOL fEnableMulticast) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnableHTTP( 
            /* [out] */ BOOL *pfEnableHTTP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEnableHTTP( 
            /* [in] */ BOOL fEnableHTTP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnableUDP( 
            /* [out] */ BOOL *pfEnableUDP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEnableUDP( 
            /* [in] */ BOOL fEnableUDP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnableTCP( 
            /* [out] */ BOOL *pfEnableTCP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEnableTCP( 
            /* [in] */ BOOL fEnableTCP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResetProtocolRollover( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConnectionBandwidth( 
            /* [out] */ DWORD *pdwConnectionBandwidth) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConnectionBandwidth( 
            /* [in] */ DWORD dwConnectionBandwidth) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNumProtocolsSupported( 
            /* [out] */ DWORD *pcProtocols) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSupportedProtocolName( 
            /* [in] */ DWORD dwProtocolNum,
            /* [out] */ WCHAR *pwszProtocolName,
            /* [out][in] */ DWORD *pcchProtocolName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddLoggingUrl( 
            /* [in] */ LPCWSTR pwszUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLoggingUrl( 
            /* [in] */ DWORD dwIndex,
            /* [out] */ LPWSTR pwszUrl,
            /* [out][in] */ DWORD *pcchUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLoggingUrlCount( 
            /* [out] */ DWORD *pdwUrlCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResetLoggingUrlList( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderNetworkConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMReaderNetworkConfig * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMReaderNetworkConfig * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMReaderNetworkConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetBufferingTime )( 
            IWMReaderNetworkConfig * This,
            /* [out] */ QWORD *pcnsBufferingTime);
        
        HRESULT ( STDMETHODCALLTYPE *SetBufferingTime )( 
            IWMReaderNetworkConfig * This,
            /* [in] */ QWORD cnsBufferingTime);
        
        HRESULT ( STDMETHODCALLTYPE *GetUDPPortRanges )( 
            IWMReaderNetworkConfig * This,
            /* [out] */ WM_PORT_NUMBER_RANGE *pRangeArray,
            /* [out][in] */ DWORD *pcRanges);
        
        HRESULT ( STDMETHODCALLTYPE *SetUDPPortRanges )( 
            IWMReaderNetworkConfig * This,
            /* [in] */ WM_PORT_NUMBER_RANGE *pRangeArray,
            /* [in] */ DWORD cRanges);
        
        HRESULT ( STDMETHODCALLTYPE *GetProxySettings )( 
            IWMReaderNetworkConfig * This,
            LPCWSTR pwszProtocol,
            WMT_PROXY_SETTINGS *pProxySetting);
        
        HRESULT ( STDMETHODCALLTYPE *SetProxySettings )( 
            IWMReaderNetworkConfig * This,
            LPCWSTR pwszProtocol,
            WMT_PROXY_SETTINGS ProxySetting);
        
        HRESULT ( STDMETHODCALLTYPE *GetProxyHostName )( 
            IWMReaderNetworkConfig * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ WCHAR *pwszHostName,
            /* [out][in] */ DWORD *pcchHostName);
        
        HRESULT ( STDMETHODCALLTYPE *SetProxyHostName )( 
            IWMReaderNetworkConfig * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ LPCWSTR pwszHostName);
        
        HRESULT ( STDMETHODCALLTYPE *GetProxyPort )( 
            IWMReaderNetworkConfig * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ DWORD *pdwPort);
        
        HRESULT ( STDMETHODCALLTYPE *SetProxyPort )( 
            IWMReaderNetworkConfig * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ DWORD dwPort);
        
        HRESULT ( STDMETHODCALLTYPE *GetProxyExceptionList )( 
            IWMReaderNetworkConfig * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ WCHAR *pwszExceptionList,
            /* [out][in] */ DWORD *pcchExceptionList);
        
        HRESULT ( STDMETHODCALLTYPE *SetProxyExceptionList )( 
            IWMReaderNetworkConfig * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ LPCWSTR pwszExceptionList);
        
        HRESULT ( STDMETHODCALLTYPE *GetProxyBypassForLocal )( 
            IWMReaderNetworkConfig * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [out] */ BOOL *pfBypassForLocal);
        
        HRESULT ( STDMETHODCALLTYPE *SetProxyBypassForLocal )( 
            IWMReaderNetworkConfig * This,
            /* [in] */ LPCWSTR pwszProtocol,
            /* [in] */ BOOL fBypassForLocal);
        
        HRESULT ( STDMETHODCALLTYPE *GetForceRerunAutoProxyDetection )( 
            IWMReaderNetworkConfig * This,
            /* [out] */ BOOL *pfForceRerunDetection);
        
        HRESULT ( STDMETHODCALLTYPE *SetForceRerunAutoProxyDetection )( 
            IWMReaderNetworkConfig * This,
            /* [in] */ BOOL fForceRerunDetection);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnableMulticast )( 
            IWMReaderNetworkConfig * This,
            /* [out] */ BOOL *pfEnableMulticast);
        
        HRESULT ( STDMETHODCALLTYPE *SetEnableMulticast )( 
            IWMReaderNetworkConfig * This,
            /* [in] */ BOOL fEnableMulticast);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnableHTTP )( 
            IWMReaderNetworkConfig * This,
            /* [out] */ BOOL *pfEnableHTTP);
        
        HRESULT ( STDMETHODCALLTYPE *SetEnableHTTP )( 
            IWMReaderNetworkConfig * This,
            /* [in] */ BOOL fEnableHTTP);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnableUDP )( 
            IWMReaderNetworkConfig * This,
            /* [out] */ BOOL *pfEnableUDP);
        
        HRESULT ( STDMETHODCALLTYPE *SetEnableUDP )( 
            IWMReaderNetworkConfig * This,
            /* [in] */ BOOL fEnableUDP);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnableTCP )( 
            IWMReaderNetworkConfig * This,
            /* [out] */ BOOL *pfEnableTCP);
        
        HRESULT ( STDMETHODCALLTYPE *SetEnableTCP )( 
            IWMReaderNetworkConfig * This,
            /* [in] */ BOOL fEnableTCP);
        
        HRESULT ( STDMETHODCALLTYPE *ResetProtocolRollover )( 
            IWMReaderNetworkConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetConnectionBandwidth )( 
            IWMReaderNetworkConfig * This,
            /* [out] */ DWORD *pdwConnectionBandwidth);
        
        HRESULT ( STDMETHODCALLTYPE *SetConnectionBandwidth )( 
            IWMReaderNetworkConfig * This,
            /* [in] */ DWORD dwConnectionBandwidth);
        
        HRESULT ( STDMETHODCALLTYPE *GetNumProtocolsSupported )( 
            IWMReaderNetworkConfig * This,
            /* [out] */ DWORD *pcProtocols);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedProtocolName )( 
            IWMReaderNetworkConfig * This,
            /* [in] */ DWORD dwProtocolNum,
            /* [out] */ WCHAR *pwszProtocolName,
            /* [out][in] */ DWORD *pcchProtocolName);
        
        HRESULT ( STDMETHODCALLTYPE *AddLoggingUrl )( 
            IWMReaderNetworkConfig * This,
            /* [in] */ LPCWSTR pwszUrl);
        
        HRESULT ( STDMETHODCALLTYPE *GetLoggingUrl )( 
            IWMReaderNetworkConfig * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ LPWSTR pwszUrl,
            /* [out][in] */ DWORD *pcchUrl);
        
        HRESULT ( STDMETHODCALLTYPE *GetLoggingUrlCount )( 
            IWMReaderNetworkConfig * This,
            /* [out] */ DWORD *pdwUrlCount);
        
        HRESULT ( STDMETHODCALLTYPE *ResetLoggingUrlList )( 
            IWMReaderNetworkConfig * This);
        
        END_INTERFACE
    } IWMReaderNetworkConfigVtbl;

    interface IWMReaderNetworkConfig
    {
        CONST_VTBL struct IWMReaderNetworkConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderNetworkConfig_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMReaderNetworkConfig_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMReaderNetworkConfig_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMReaderNetworkConfig_GetBufferingTime(This,pcnsBufferingTime)	\
    ( (This)->lpVtbl -> GetBufferingTime(This,pcnsBufferingTime) ) 

#define IWMReaderNetworkConfig_SetBufferingTime(This,cnsBufferingTime)	\
    ( (This)->lpVtbl -> SetBufferingTime(This,cnsBufferingTime) ) 

#define IWMReaderNetworkConfig_GetUDPPortRanges(This,pRangeArray,pcRanges)	\
    ( (This)->lpVtbl -> GetUDPPortRanges(This,pRangeArray,pcRanges) ) 

#define IWMReaderNetworkConfig_SetUDPPortRanges(This,pRangeArray,cRanges)	\
    ( (This)->lpVtbl -> SetUDPPortRanges(This,pRangeArray,cRanges) ) 

#define IWMReaderNetworkConfig_GetProxySettings(This,pwszProtocol,pProxySetting)	\
    ( (This)->lpVtbl -> GetProxySettings(This,pwszProtocol,pProxySetting) ) 

#define IWMReaderNetworkConfig_SetProxySettings(This,pwszProtocol,ProxySetting)	\
    ( (This)->lpVtbl -> SetProxySettings(This,pwszProtocol,ProxySetting) ) 

#define IWMReaderNetworkConfig_GetProxyHostName(This,pwszProtocol,pwszHostName,pcchHostName)	\
    ( (This)->lpVtbl -> GetProxyHostName(This,pwszProtocol,pwszHostName,pcchHostName) ) 

#define IWMReaderNetworkConfig_SetProxyHostName(This,pwszProtocol,pwszHostName)	\
    ( (This)->lpVtbl -> SetProxyHostName(This,pwszProtocol,pwszHostName) ) 

#define IWMReaderNetworkConfig_GetProxyPort(This,pwszProtocol,pdwPort)	\
    ( (This)->lpVtbl -> GetProxyPort(This,pwszProtocol,pdwPort) ) 

#define IWMReaderNetworkConfig_SetProxyPort(This,pwszProtocol,dwPort)	\
    ( (This)->lpVtbl -> SetProxyPort(This,pwszProtocol,dwPort) ) 

#define IWMReaderNetworkConfig_GetProxyExceptionList(This,pwszProtocol,pwszExceptionList,pcchExceptionList)	\
    ( (This)->lpVtbl -> GetProxyExceptionList(This,pwszProtocol,pwszExceptionList,pcchExceptionList) ) 

#define IWMReaderNetworkConfig_SetProxyExceptionList(This,pwszProtocol,pwszExceptionList)	\
    ( (This)->lpVtbl -> SetProxyExceptionList(This,pwszProtocol,pwszExceptionList) ) 

#define IWMReaderNetworkConfig_GetProxyBypassForLocal(This,pwszProtocol,pfBypassForLocal)	\
    ( (This)->lpVtbl -> GetProxyBypassForLocal(This,pwszProtocol,pfBypassForLocal) ) 

#define IWMReaderNetworkConfig_SetProxyBypassForLocal(This,pwszProtocol,fBypassForLocal)	\
    ( (This)->lpVtbl -> SetProxyBypassForLocal(This,pwszProtocol,fBypassForLocal) ) 

#define IWMReaderNetworkConfig_GetForceRerunAutoProxyDetection(This,pfForceRerunDetection)	\
    ( (This)->lpVtbl -> GetForceRerunAutoProxyDetection(This,pfForceRerunDetection) ) 

#define IWMReaderNetworkConfig_SetForceRerunAutoProxyDetection(This,fForceRerunDetection)	\
    ( (This)->lpVtbl -> SetForceRerunAutoProxyDetection(This,fForceRerunDetection) ) 

#define IWMReaderNetworkConfig_GetEnableMulticast(This,pfEnableMulticast)	\
    ( (This)->lpVtbl -> GetEnableMulticast(This,pfEnableMulticast) ) 

#define IWMReaderNetworkConfig_SetEnableMulticast(This,fEnableMulticast)	\
    ( (This)->lpVtbl -> SetEnableMulticast(This,fEnableMulticast) ) 

#define IWMReaderNetworkConfig_GetEnableHTTP(This,pfEnableHTTP)	\
    ( (This)->lpVtbl -> GetEnableHTTP(This,pfEnableHTTP) ) 

#define IWMReaderNetworkConfig_SetEnableHTTP(This,fEnableHTTP)	\
    ( (This)->lpVtbl -> SetEnableHTTP(This,fEnableHTTP) ) 

#define IWMReaderNetworkConfig_GetEnableUDP(This,pfEnableUDP)	\
    ( (This)->lpVtbl -> GetEnableUDP(This,pfEnableUDP) ) 

#define IWMReaderNetworkConfig_SetEnableUDP(This,fEnableUDP)	\
    ( (This)->lpVtbl -> SetEnableUDP(This,fEnableUDP) ) 

#define IWMReaderNetworkConfig_GetEnableTCP(This,pfEnableTCP)	\
    ( (This)->lpVtbl -> GetEnableTCP(This,pfEnableTCP) ) 

#define IWMReaderNetworkConfig_SetEnableTCP(This,fEnableTCP)	\
    ( (This)->lpVtbl -> SetEnableTCP(This,fEnableTCP) ) 

#define IWMReaderNetworkConfig_ResetProtocolRollover(This)	\
    ( (This)->lpVtbl -> ResetProtocolRollover(This) ) 

#define IWMReaderNetworkConfig_GetConnectionBandwidth(This,pdwConnectionBandwidth)	\
    ( (This)->lpVtbl -> GetConnectionBandwidth(This,pdwConnectionBandwidth) ) 

#define IWMReaderNetworkConfig_SetConnectionBandwidth(This,dwConnectionBandwidth)	\
    ( (This)->lpVtbl -> SetConnectionBandwidth(This,dwConnectionBandwidth) ) 

#define IWMReaderNetworkConfig_GetNumProtocolsSupported(This,pcProtocols)	\
    ( (This)->lpVtbl -> GetNumProtocolsSupported(This,pcProtocols) ) 

#define IWMReaderNetworkConfig_GetSupportedProtocolName(This,dwProtocolNum,pwszProtocolName,pcchProtocolName)	\
    ( (This)->lpVtbl -> GetSupportedProtocolName(This,dwProtocolNum,pwszProtocolName,pcchProtocolName) ) 

#define IWMReaderNetworkConfig_AddLoggingUrl(This,pwszUrl)	\
    ( (This)->lpVtbl -> AddLoggingUrl(This,pwszUrl) ) 

#define IWMReaderNetworkConfig_GetLoggingUrl(This,dwIndex,pwszUrl,pcchUrl)	\
    ( (This)->lpVtbl -> GetLoggingUrl(This,dwIndex,pwszUrl,pcchUrl) ) 

#define IWMReaderNetworkConfig_GetLoggingUrlCount(This,pdwUrlCount)	\
    ( (This)->lpVtbl -> GetLoggingUrlCount(This,pdwUrlCount) ) 

#define IWMReaderNetworkConfig_ResetLoggingUrlList(This)	\
    ( (This)->lpVtbl -> ResetLoggingUrlList(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMReaderNetworkConfig_INTERFACE_DEFINED__ */


#ifndef __IWMReaderStreamClock_INTERFACE_DEFINED__
#define __IWMReaderStreamClock_INTERFACE_DEFINED__

/* interface IWMReaderStreamClock */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMReaderStreamClock;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96406BED-2B2B-11d3-B36B-00C04F6108FF")
    IWMReaderStreamClock : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTime( 
            /* [in] */ QWORD *pcnsNow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTimer( 
            /* [in] */ QWORD cnsWhen,
            /* [in] */ void *pvParam,
            /* [out] */ DWORD *pdwTimerId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE KillTimer( 
            /* [in] */ DWORD dwTimerId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMReaderStreamClockVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMReaderStreamClock * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMReaderStreamClock * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMReaderStreamClock * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTime )( 
            IWMReaderStreamClock * This,
            /* [in] */ QWORD *pcnsNow);
        
        HRESULT ( STDMETHODCALLTYPE *SetTimer )( 
            IWMReaderStreamClock * This,
            /* [in] */ QWORD cnsWhen,
            /* [in] */ void *pvParam,
            /* [out] */ DWORD *pdwTimerId);
        
        HRESULT ( STDMETHODCALLTYPE *KillTimer )( 
            IWMReaderStreamClock * This,
            /* [in] */ DWORD dwTimerId);
        
        END_INTERFACE
    } IWMReaderStreamClockVtbl;

    interface IWMReaderStreamClock
    {
        CONST_VTBL struct IWMReaderStreamClockVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMReaderStreamClock_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMReaderStreamClock_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMReaderStreamClock_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMReaderStreamClock_GetTime(This,pcnsNow)	\
    ( (This)->lpVtbl -> GetTime(This,pcnsNow) ) 

#define IWMReaderStreamClock_SetTimer(This,cnsWhen,pvParam,pdwTimerId)	\
    ( (This)->lpVtbl -> SetTimer(This,cnsWhen,pvParam,pdwTimerId) ) 

#define IWMReaderStreamClock_KillTimer(This,dwTimerId)	\
    ( (This)->lpVtbl -> KillTimer(This,dwTimerId) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMReaderStreamClock_INTERFACE_DEFINED__ */


#ifndef __IWMIndexer_INTERFACE_DEFINED__
#define __IWMIndexer_INTERFACE_DEFINED__

/* interface IWMIndexer */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMIndexer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6d7cdc71-9888-11d3-8edc-00c04f6109cf")
    IWMIndexer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StartIndexing( 
            /* [in] */ const WCHAR *pwszURL,
            /* [in] */ IWMStatusCallback *pCallback,
            /* [in] */ void *pvContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMIndexerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMIndexer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMIndexer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMIndexer * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartIndexing )( 
            IWMIndexer * This,
            /* [in] */ const WCHAR *pwszURL,
            /* [in] */ IWMStatusCallback *pCallback,
            /* [in] */ void *pvContext);
        
        HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            IWMIndexer * This);
        
        END_INTERFACE
    } IWMIndexerVtbl;

    interface IWMIndexer
    {
        CONST_VTBL struct IWMIndexerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMIndexer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMIndexer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMIndexer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMIndexer_StartIndexing(This,pwszURL,pCallback,pvContext)	\
    ( (This)->lpVtbl -> StartIndexing(This,pwszURL,pCallback,pvContext) ) 

#define IWMIndexer_Cancel(This)	\
    ( (This)->lpVtbl -> Cancel(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMIndexer_INTERFACE_DEFINED__ */


#ifndef __IWMLicenseBackup_INTERFACE_DEFINED__
#define __IWMLicenseBackup_INTERFACE_DEFINED__

/* interface IWMLicenseBackup */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMLicenseBackup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("05E5AC9F-3FB6-4508-BB43-A4067BA1EBE8")
    IWMLicenseBackup : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BackupLicenses( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IWMStatusCallback *pCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelLicenseBackup( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMLicenseBackupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMLicenseBackup * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMLicenseBackup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMLicenseBackup * This);
        
        HRESULT ( STDMETHODCALLTYPE *BackupLicenses )( 
            IWMLicenseBackup * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IWMStatusCallback *pCallback);
        
        HRESULT ( STDMETHODCALLTYPE *CancelLicenseBackup )( 
            IWMLicenseBackup * This);
        
        END_INTERFACE
    } IWMLicenseBackupVtbl;

    interface IWMLicenseBackup
    {
        CONST_VTBL struct IWMLicenseBackupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMLicenseBackup_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMLicenseBackup_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMLicenseBackup_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMLicenseBackup_BackupLicenses(This,dwFlags,pCallback)	\
    ( (This)->lpVtbl -> BackupLicenses(This,dwFlags,pCallback) ) 

#define IWMLicenseBackup_CancelLicenseBackup(This)	\
    ( (This)->lpVtbl -> CancelLicenseBackup(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMLicenseBackup_INTERFACE_DEFINED__ */


#ifndef __IWMLicenseRestore_INTERFACE_DEFINED__
#define __IWMLicenseRestore_INTERFACE_DEFINED__

/* interface IWMLicenseRestore */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMLicenseRestore;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C70B6334-0544-4efb-A245-15E65A004A13")
    IWMLicenseRestore : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RestoreLicenses( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IWMStatusCallback *pCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelLicenseRestore( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMLicenseRestoreVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMLicenseRestore * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMLicenseRestore * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMLicenseRestore * This);
        
        HRESULT ( STDMETHODCALLTYPE *RestoreLicenses )( 
            IWMLicenseRestore * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IWMStatusCallback *pCallback);
        
        HRESULT ( STDMETHODCALLTYPE *CancelLicenseRestore )( 
            IWMLicenseRestore * This);
        
        END_INTERFACE
    } IWMLicenseRestoreVtbl;

    interface IWMLicenseRestore
    {
        CONST_VTBL struct IWMLicenseRestoreVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMLicenseRestore_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMLicenseRestore_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMLicenseRestore_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMLicenseRestore_RestoreLicenses(This,dwFlags,pCallback)	\
    ( (This)->lpVtbl -> RestoreLicenses(This,dwFlags,pCallback) ) 

#define IWMLicenseRestore_CancelLicenseRestore(This)	\
    ( (This)->lpVtbl -> CancelLicenseRestore(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMLicenseRestore_INTERFACE_DEFINED__ */


#ifndef __IWMBackupRestoreProps_INTERFACE_DEFINED__
#define __IWMBackupRestoreProps_INTERFACE_DEFINED__

/* interface IWMBackupRestoreProps */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMBackupRestoreProps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3C8E0DA6-996F-4ff3-A1AF-4838F9377E2E")
    IWMBackupRestoreProps : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPropCount( 
            /* [out] */ WORD *pcProps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropByIndex( 
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR *pwszName,
            /* [out][in] */ WORD *pcchNameLen,
            /* [out] */ WMT_ATTR_DATATYPE *pType,
            /* [out] */ BYTE *pValue,
            /* [out][in] */ WORD *pcbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropByName( 
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE *pType,
            /* [out] */ BYTE *pValue,
            /* [out][in] */ WORD *pcbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProp( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE *pValue,
            /* [in] */ WORD cbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveProp( 
            /* [in] */ LPCWSTR pcwszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAllProps( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMBackupRestorePropsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMBackupRestoreProps * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMBackupRestoreProps * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMBackupRestoreProps * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropCount )( 
            IWMBackupRestoreProps * This,
            /* [out] */ WORD *pcProps);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropByIndex )( 
            IWMBackupRestoreProps * This,
            /* [in] */ WORD wIndex,
            /* [out] */ WCHAR *pwszName,
            /* [out][in] */ WORD *pcchNameLen,
            /* [out] */ WMT_ATTR_DATATYPE *pType,
            /* [out] */ BYTE *pValue,
            /* [out][in] */ WORD *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropByName )( 
            IWMBackupRestoreProps * This,
            /* [in] */ LPCWSTR pszName,
            /* [out] */ WMT_ATTR_DATATYPE *pType,
            /* [out] */ BYTE *pValue,
            /* [out][in] */ WORD *pcbLength);
        
        HRESULT ( STDMETHODCALLTYPE *SetProp )( 
            IWMBackupRestoreProps * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ WMT_ATTR_DATATYPE Type,
            /* [in] */ const BYTE *pValue,
            /* [in] */ WORD cbLength);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveProp )( 
            IWMBackupRestoreProps * This,
            /* [in] */ LPCWSTR pcwszName);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAllProps )( 
            IWMBackupRestoreProps * This);
        
        END_INTERFACE
    } IWMBackupRestorePropsVtbl;

    interface IWMBackupRestoreProps
    {
        CONST_VTBL struct IWMBackupRestorePropsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMBackupRestoreProps_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMBackupRestoreProps_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMBackupRestoreProps_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMBackupRestoreProps_GetPropCount(This,pcProps)	\
    ( (This)->lpVtbl -> GetPropCount(This,pcProps) ) 

#define IWMBackupRestoreProps_GetPropByIndex(This,wIndex,pwszName,pcchNameLen,pType,pValue,pcbLength)	\
    ( (This)->lpVtbl -> GetPropByIndex(This,wIndex,pwszName,pcchNameLen,pType,pValue,pcbLength) ) 

#define IWMBackupRestoreProps_GetPropByName(This,pszName,pType,pValue,pcbLength)	\
    ( (This)->lpVtbl -> GetPropByName(This,pszName,pType,pValue,pcbLength) ) 

#define IWMBackupRestoreProps_SetProp(This,pszName,Type,pValue,cbLength)	\
    ( (This)->lpVtbl -> SetProp(This,pszName,Type,pValue,cbLength) ) 

#define IWMBackupRestoreProps_RemoveProp(This,pcwszName)	\
    ( (This)->lpVtbl -> RemoveProp(This,pcwszName) ) 

#define IWMBackupRestoreProps_RemoveAllProps(This)	\
    ( (This)->lpVtbl -> RemoveAllProps(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMBackupRestoreProps_INTERFACE_DEFINED__ */


#ifndef __IWMCodecInfo_INTERFACE_DEFINED__
#define __IWMCodecInfo_INTERFACE_DEFINED__

/* interface IWMCodecInfo */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMCodecInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A970F41E-34DE-4a98-B3BA-E4B3CA7528F0")
    IWMCodecInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCodecInfoCount( 
            /* [in] */ REFGUID guidType,
            /* [out] */ DWORD *pcCodecs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodecFormatCount( 
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [out] */ DWORD *pcFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodecFormat( 
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [in] */ DWORD dwFormatIndex,
            /* [out] */ IWMStreamConfig **ppIStreamConfig) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMCodecInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMCodecInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMCodecInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMCodecInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodecInfoCount )( 
            IWMCodecInfo * This,
            /* [in] */ REFGUID guidType,
            /* [out] */ DWORD *pcCodecs);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodecFormatCount )( 
            IWMCodecInfo * This,
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [out] */ DWORD *pcFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodecFormat )( 
            IWMCodecInfo * This,
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [in] */ DWORD dwFormatIndex,
            /* [out] */ IWMStreamConfig **ppIStreamConfig);
        
        END_INTERFACE
    } IWMCodecInfoVtbl;

    interface IWMCodecInfo
    {
        CONST_VTBL struct IWMCodecInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMCodecInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMCodecInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMCodecInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMCodecInfo_GetCodecInfoCount(This,guidType,pcCodecs)	\
    ( (This)->lpVtbl -> GetCodecInfoCount(This,guidType,pcCodecs) ) 

#define IWMCodecInfo_GetCodecFormatCount(This,guidType,dwCodecIndex,pcFormat)	\
    ( (This)->lpVtbl -> GetCodecFormatCount(This,guidType,dwCodecIndex,pcFormat) ) 

#define IWMCodecInfo_GetCodecFormat(This,guidType,dwCodecIndex,dwFormatIndex,ppIStreamConfig)	\
    ( (This)->lpVtbl -> GetCodecFormat(This,guidType,dwCodecIndex,dwFormatIndex,ppIStreamConfig) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMCodecInfo_INTERFACE_DEFINED__ */


#ifndef __IWMCodecInfo2_INTERFACE_DEFINED__
#define __IWMCodecInfo2_INTERFACE_DEFINED__

/* interface IWMCodecInfo2 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMCodecInfo2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AA65E273-B686-4056-91EC-DD768D4DF710")
    IWMCodecInfo2 : public IWMCodecInfo
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCodecName( 
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [size_is][out] */ WCHAR *wszName,
            /* [out][in] */ DWORD *pcchName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodecFormatDesc( 
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [in] */ DWORD dwFormatIndex,
            /* [out] */ IWMStreamConfig **ppIStreamConfig,
            /* [size_is][out] */ WCHAR *wszDesc,
            /* [out][in] */ DWORD *pcchDesc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMCodecInfo2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMCodecInfo2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMCodecInfo2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMCodecInfo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodecInfoCount )( 
            IWMCodecInfo2 * This,
            /* [in] */ REFGUID guidType,
            /* [out] */ DWORD *pcCodecs);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodecFormatCount )( 
            IWMCodecInfo2 * This,
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [out] */ DWORD *pcFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodecFormat )( 
            IWMCodecInfo2 * This,
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [in] */ DWORD dwFormatIndex,
            /* [out] */ IWMStreamConfig **ppIStreamConfig);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodecName )( 
            IWMCodecInfo2 * This,
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [size_is][out] */ WCHAR *wszName,
            /* [out][in] */ DWORD *pcchName);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodecFormatDesc )( 
            IWMCodecInfo2 * This,
            /* [in] */ REFGUID guidType,
            /* [in] */ DWORD dwCodecIndex,
            /* [in] */ DWORD dwFormatIndex,
            /* [out] */ IWMStreamConfig **ppIStreamConfig,
            /* [size_is][out] */ WCHAR *wszDesc,
            /* [out][in] */ DWORD *pcchDesc);
        
        END_INTERFACE
    } IWMCodecInfo2Vtbl;

    interface IWMCodecInfo2
    {
        CONST_VTBL struct IWMCodecInfo2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMCodecInfo2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMCodecInfo2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMCodecInfo2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMCodecInfo2_GetCodecInfoCount(This,guidType,pcCodecs)	\
    ( (This)->lpVtbl -> GetCodecInfoCount(This,guidType,pcCodecs) ) 

#define IWMCodecInfo2_GetCodecFormatCount(This,guidType,dwCodecIndex,pcFormat)	\
    ( (This)->lpVtbl -> GetCodecFormatCount(This,guidType,dwCodecIndex,pcFormat) ) 

#define IWMCodecInfo2_GetCodecFormat(This,guidType,dwCodecIndex,dwFormatIndex,ppIStreamConfig)	\
    ( (This)->lpVtbl -> GetCodecFormat(This,guidType,dwCodecIndex,dwFormatIndex,ppIStreamConfig) ) 


#define IWMCodecInfo2_GetCodecName(This,guidType,dwCodecIndex,wszName,pcchName)	\
    ( (This)->lpVtbl -> GetCodecName(This,guidType,dwCodecIndex,wszName,pcchName) ) 

#define IWMCodecInfo2_GetCodecFormatDesc(This,guidType,dwCodecIndex,dwFormatIndex,ppIStreamConfig,wszDesc,pcchDesc)	\
    ( (This)->lpVtbl -> GetCodecFormatDesc(This,guidType,dwCodecIndex,dwFormatIndex,ppIStreamConfig,wszDesc,pcchDesc) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMCodecInfo2_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\wmsbuffer.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0543 */
/* Compiler settings for wmsbuffer.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wmsbuffer_h__
#define __wmsbuffer_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __INSSBuffer_FWD_DEFINED__
#define __INSSBuffer_FWD_DEFINED__
typedef interface INSSBuffer INSSBuffer;
#endif 	/* __INSSBuffer_FWD_DEFINED__ */


#ifndef __INSSBuffer2_FWD_DEFINED__
#define __INSSBuffer2_FWD_DEFINED__
typedef interface INSSBuffer2 INSSBuffer2;
#endif 	/* __INSSBuffer2_FWD_DEFINED__ */


#ifndef __IWMSBufferAllocator_FWD_DEFINED__
#define __IWMSBufferAllocator_FWD_DEFINED__
typedef interface IWMSBufferAllocator IWMSBufferAllocator;
#endif 	/* __IWMSBufferAllocator_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_wmsbuffer_0000_0000 */
/* [local] */ 

//=========================================================================
//
//  THIS SOFTWARE HAS BEEN LICENSED FROM MICROSOFT CORPORATION PURSUANT 
//  TO THE TERMS OF AN END USER LICENSE AGREEMENT ("EULA").  
//  PLEASE REFER TO THE TEXT OF THE EULA TO DETERMINE THE RIGHTS TO USE THE SOFTWARE.  
//
// Copyright (C) Microsoft Corporation, 1999 - 1999  All Rights Reserved.
//
//=========================================================================
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
EXTERN_GUID( IID_INSSBuffer, 0xE1CD3524,0x03D7,0x11d2,0x9E,0xED,0x00,0x60,0x97,0xD2,0xD7,0xCF );
EXTERN_GUID( IID_IWMSBuffer, 0xE1CD3524,0x03D7,0x11d2,0x9E,0xED,0x00,0x60,0x97,0xD2,0xD7,0xCF );
EXTERN_GUID( IID_IWMSBufferAllocator, 0x61103CA4,0x2033,0x11d2,0x9E,0xF1,0x00,0x60,0x97,0xD2,0xD7,0xCF );
EXTERN_GUID( IID_INSSBuffer2, 0x4f528693, 0x1035, 0x43fe, 0xb4, 0x28, 0x75, 0x75, 0x61, 0xad, 0x3a, 0x68);
#define IWMSBuffer INSSBuffer



extern RPC_IF_HANDLE __MIDL_itf_wmsbuffer_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wmsbuffer_0000_0000_v0_0_s_ifspec;

#ifndef __INSSBuffer_INTERFACE_DEFINED__
#define __INSSBuffer_INTERFACE_DEFINED__

/* interface INSSBuffer */
/* [version][uuid][unique][object][local] */ 


EXTERN_C const IID IID_INSSBuffer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E1CD3524-03D7-11d2-9EED-006097D2D7CF")
    INSSBuffer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ DWORD *pdwLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLength( 
            /* [in] */ DWORD dwLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxLength( 
            /* [out] */ DWORD *pdwLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBuffer( 
            /* [out] */ BYTE **ppdwBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBufferAndLength( 
            /* [out] */ BYTE **ppdwBuffer,
            /* [out] */ DWORD *pdwLength) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INSSBufferVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INSSBuffer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INSSBuffer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INSSBuffer * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            INSSBuffer * This,
            /* [out] */ DWORD *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE *SetLength )( 
            INSSBuffer * This,
            /* [in] */ DWORD dwLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxLength )( 
            INSSBuffer * This,
            /* [out] */ DWORD *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetBuffer )( 
            INSSBuffer * This,
            /* [out] */ BYTE **ppdwBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *GetBufferAndLength )( 
            INSSBuffer * This,
            /* [out] */ BYTE **ppdwBuffer,
            /* [out] */ DWORD *pdwLength);
        
        END_INTERFACE
    } INSSBufferVtbl;

    interface INSSBuffer
    {
        CONST_VTBL struct INSSBufferVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INSSBuffer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INSSBuffer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INSSBuffer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INSSBuffer_GetLength(This,pdwLength)	\
    ( (This)->lpVtbl -> GetLength(This,pdwLength) ) 

#define INSSBuffer_SetLength(This,dwLength)	\
    ( (This)->lpVtbl -> SetLength(This,dwLength) ) 

#define INSSBuffer_GetMaxLength(This,pdwLength)	\
    ( (This)->lpVtbl -> GetMaxLength(This,pdwLength) ) 

#define INSSBuffer_GetBuffer(This,ppdwBuffer)	\
    ( (This)->lpVtbl -> GetBuffer(This,ppdwBuffer) ) 

#define INSSBuffer_GetBufferAndLength(This,ppdwBuffer,pdwLength)	\
    ( (This)->lpVtbl -> GetBufferAndLength(This,ppdwBuffer,pdwLength) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INSSBuffer_INTERFACE_DEFINED__ */


#ifndef __INSSBuffer2_INTERFACE_DEFINED__
#define __INSSBuffer2_INTERFACE_DEFINED__

/* interface INSSBuffer2 */
/* [version][uuid][unique][object][local] */ 


EXTERN_C const IID IID_INSSBuffer2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4F528693-1035-43fe-B428-757561AD3A68")
    INSSBuffer2 : public INSSBuffer
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSampleProperties( 
            /* [in] */ DWORD cbProperties,
            /* [out] */ BYTE *pbProperties) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSampleProperties( 
            /* [in] */ DWORD cbProperties,
            /* [in] */ BYTE *pbProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INSSBuffer2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INSSBuffer2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INSSBuffer2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INSSBuffer2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            INSSBuffer2 * This,
            /* [out] */ DWORD *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE *SetLength )( 
            INSSBuffer2 * This,
            /* [in] */ DWORD dwLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxLength )( 
            INSSBuffer2 * This,
            /* [out] */ DWORD *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetBuffer )( 
            INSSBuffer2 * This,
            /* [out] */ BYTE **ppdwBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *GetBufferAndLength )( 
            INSSBuffer2 * This,
            /* [out] */ BYTE **ppdwBuffer,
            /* [out] */ DWORD *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetSampleProperties )( 
            INSSBuffer2 * This,
            /* [in] */ DWORD cbProperties,
            /* [out] */ BYTE *pbProperties);
        
        HRESULT ( STDMETHODCALLTYPE *SetSampleProperties )( 
            INSSBuffer2 * This,
            /* [in] */ DWORD cbProperties,
            /* [in] */ BYTE *pbProperties);
        
        END_INTERFACE
    } INSSBuffer2Vtbl;

    interface INSSBuffer2
    {
        CONST_VTBL struct INSSBuffer2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INSSBuffer2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INSSBuffer2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INSSBuffer2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INSSBuffer2_GetLength(This,pdwLength)	\
    ( (This)->lpVtbl -> GetLength(This,pdwLength) ) 

#define INSSBuffer2_SetLength(This,dwLength)	\
    ( (This)->lpVtbl -> SetLength(This,dwLength) ) 

#define INSSBuffer2_GetMaxLength(This,pdwLength)	\
    ( (This)->lpVtbl -> GetMaxLength(This,pdwLength) ) 

#define INSSBuffer2_GetBuffer(This,ppdwBuffer)	\
    ( (This)->lpVtbl -> GetBuffer(This,ppdwBuffer) ) 

#define INSSBuffer2_GetBufferAndLength(This,ppdwBuffer,pdwLength)	\
    ( (This)->lpVtbl -> GetBufferAndLength(This,ppdwBuffer,pdwLength) ) 


#define INSSBuffer2_GetSampleProperties(This,cbProperties,pbProperties)	\
    ( (This)->lpVtbl -> GetSampleProperties(This,cbProperties,pbProperties) ) 

#define INSSBuffer2_SetSampleProperties(This,cbProperties,pbProperties)	\
    ( (This)->lpVtbl -> SetSampleProperties(This,cbProperties,pbProperties) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INSSBuffer2_INTERFACE_DEFINED__ */


#ifndef __IWMSBufferAllocator_INTERFACE_DEFINED__
#define __IWMSBufferAllocator_INTERFACE_DEFINED__

/* interface IWMSBufferAllocator */
/* [version][uuid][unique][object][local] */ 


EXTERN_C const IID IID_IWMSBufferAllocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("61103CA4-2033-11d2-9EF1-006097D2D7CF")
    IWMSBufferAllocator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AllocateBuffer( 
            /* [in] */ DWORD dwMaxBufferSize,
            /* [out] */ INSSBuffer **ppBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocatePageSizeBuffer( 
            /* [in] */ DWORD dwMaxBufferSize,
            /* [out] */ INSSBuffer **ppBuffer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSBufferAllocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSBufferAllocator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSBufferAllocator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSBufferAllocator * This);
        
        HRESULT ( STDMETHODCALLTYPE *AllocateBuffer )( 
            IWMSBufferAllocator * This,
            /* [in] */ DWORD dwMaxBufferSize,
            /* [out] */ INSSBuffer **ppBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *AllocatePageSizeBuffer )( 
            IWMSBufferAllocator * This,
            /* [in] */ DWORD dwMaxBufferSize,
            /* [out] */ INSSBuffer **ppBuffer);
        
        END_INTERFACE
    } IWMSBufferAllocatorVtbl;

    interface IWMSBufferAllocator
    {
        CONST_VTBL struct IWMSBufferAllocatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSBufferAllocator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMSBufferAllocator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMSBufferAllocator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMSBufferAllocator_AllocateBuffer(This,dwMaxBufferSize,ppBuffer)	\
    ( (This)->lpVtbl -> AllocateBuffer(This,dwMaxBufferSize,ppBuffer) ) 

#define IWMSBufferAllocator_AllocatePageSizeBuffer(This,dwMaxBufferSize,ppBuffer)	\
    ( (This)->lpVtbl -> AllocatePageSizeBuffer(This,dwMaxBufferSize,ppBuffer) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMSBufferAllocator_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\ws2bth.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++


Module Name:

        ws2bth.h

Abstract:

        Winsock 2 Bluetooth Annex definitions.

--*/
#pragma once

#ifndef __WS2BTH__H
#define __WS2BTH__H

//#include <bt_100.h>
//Take only necessary declarations from bt_100.h
#define BTH_MAX_NAME_SIZE          (248)    // max length of device friendly name.

typedef ULONGLONG bt_addr, *pbt_addr, BT_ADDR, *PBT_ADDR;
typedef ULONG  bt_cod, BT_COD;
typedef ULONG  bt_lap, BT_LAP;

#define NAP_MASK                ((ULONGLONG) 0xFFFF00000000)
#define SAP_MASK                ((ULONGLONG) 0x0000FFFFFFFF)

#define NAP_BIT_OFFSET          (8 * 4)
#define SAP_BIT_OFFSET          (0)

#define GET_NAP(_bt_addr)       ((USHORT) (((_bt_addr) & NAP_MASK) >> NAP_BIT_OFFSET))
#define GET_SAP(_bt_addr)       ((ULONG)  (((_bt_addr) & SAP_MASK) >> SAP_BIT_OFFSET))

#define SET_NAP(_nap) (((ULONGLONG) ((USHORT) (_nap))) << NAP_BIT_OFFSET)
#define SET_SAP(_sap) (((ULONGLONG) ((ULONG)  (_sap))) << SAP_BIT_OFFSET)

#define SET_NAP_SAP(_nap, _sap) (SET_NAP(_nap) | SET_SAP(_sap))

// Turn 1 byte packing of structures on

#ifndef L2CAP_MAX_MTU
#define L2CAP_MAX_MTU  65535
#endif

#define BT_ADDR_NULL       0x000000000000
#define BT_ADDR_IAC_FIRST  0x9E8B00
#define BT_ADDR_IAC_LAST   0x9E8B3f
#define BT_ADDR_LIAC       0x9E8B00
#define BT_ADDR_GIAC       0x9E8B33

#define BT_PORT_NULL       0
#define BT_PORT_WILDCARD   0
#define BT_PORT_ANY        -1
#define BT_PORT_MIN        0x1
#define BT_PORT_MAX        0xffff
#define BT_PORT_DYN_FIRST  0x1001
#define BT_PORT_EXCL_BIT   0x0100

//
// AF_BTH is properly defined in ws2def.h as of CE 7.
// To support legacy code which relied upon the definition
// found in this file and does not include ws2def.h, we still
// define AF_BTH here.
//
#ifndef AF_BTH
#define AF_BTH              32
#ifdef AF_MAX
#undef AF_MAX
#endif // AF_MAX
#define AF_MAX              33
#endif // AF_BTH

#define AF_BT               AF_BTH
#define WINDOWS_AF_BT       AF_BTH

#ifndef PF_BTH
#define PF_BTH  AF_BTH
#undef  PF_MAX
#define PF_MAX  AF_BTH
#endif

#define NS_BTH  16

DEFINE_GUID(SVCID_BTH_PROVIDER, 0x6aa63e0, 0x7d60, 0x41ff, 0xaf, 0xb2, 0x3e, 0xe6, 0xd2, 0xd9, 0x39, 0x2d);


// Bluetooth protocol #s are assigned according to the Bluetooth
// Assigned Numbers portion of the Bluetooth Specification
#define BTHPROTO_RFCOMM  0x0003
#define BTHPROTO_L2CAP   0x0100

#define SDP_ENUMDEVICES   0x00000010
#define SDP_SET           0x00000011
#define SDP_QUERY         0x00000012

#define RFCOMM_FLOW_CONTROL   0x00000013

#define SOL_RFCOMM  0x03
#define SOL_BTHTDI  0x100
#define SOL_SDP     0x0101

typedef struct _BTH_SOCKOPT_SECURITY {
    int             iLength;    // == 0 or 16 for link key, 0<=..<=16 for PIN. 0 = revoke
    bt_addr         btAddr;
    unsigned char   caData[16];
} BTH_SOCKOPT_SECURITY, *PBTH_SOCKOPT_SECURITY;

typedef struct _BTH_LOCAL_VERSION {
    unsigned char   hci_version;
    unsigned short  hci_revision;
    unsigned char   lmp_version;
    unsigned short  lmp_subversion;
    unsigned short  manufacturer;
    unsigned char   lmp_features[8];
} BTH_LOCAL_VERSION, *PBTH_LOCAL_VERSION;

typedef struct _BTH_REMOTE_VERSION {
    unsigned char   lmp_version;
    unsigned short  lmp_subversion;
    unsigned short  manufacturer;
    unsigned char   lmp_features[8];
} BTH_REMOTE_VERSION, *PBTH_REMOTE_VERSION;

typedef struct _BTH_REMOTE_NAME {
    BT_ADDR         bt;
    WCHAR           szNameBuffer[248];
} BTH_REMOTE_NAME, *PBTH_REMOTE_NAME;

typedef struct _BTH_HOLD_MODE {
    unsigned short  hold_mode_max;
    unsigned short  hold_mode_min;
    unsigned short  interval;   // out
} BTH_HOLD_MODE, *PBTH_HOLD_MODE;

typedef struct _BTH_SNIFF_MODE {
    unsigned short  sniff_mode_max;
    unsigned short  sniff_mode_min;
    unsigned short  sniff_attempt;
    unsigned short  sniff_timeout;
    unsigned short  interval;   // out
} BTH_SNIFF_MODE, *PBTH_SNIFF_MODE;

typedef struct _BTH_PARK_MODE {
    unsigned short beacon_max;
    unsigned short beacon_min;
    unsigned short  interval;   // out
} BTH_PARK_MODE, *PBTH_PARK_MODE;

#define SO_BTH_AUTHENTICATE         0x00000001  // optlen=0, optval ignored
#define SO_BTH_ENCRYPT              0x00000002  // optlen=sizeof(unsigned int), optval = &(unsigned int)TRUE/FALSE
#define SO_BTH_SET_PIN              0x00000003  // bound only! survives socket! optlen=sizeof(BTH_SOCKOPT_SECURITY), optval=&BTH_SOCKOPT_SECURITY
#define SO_BTH_SET_LINK             0x00000004  // bound only! survives socket! optlen=sizeof(BTH_SOCKOPT_SECURITY), optval=&BTH_SOCKOPT_SECURITY
#define SO_BTH_SET_MTU              0x00000006  // unconnected only! optlen=sizeof(unsigned int), optval = &mtu
#define SO_BTH_GET_MTU              0x00000007  // optlen=sizeof(unsigned int), optval = &mtu
#define SO_BTH_SET_MTU_MAX          0x00000008  // unconnected only! optlen=sizeof(unsigned int), optval = &max. mtu
#define SO_BTH_GET_MTU_MAX          0x00000009  // bound only! optlen=sizeof(unsigned int), optval = &max. mtu
#define SO_BTH_SET_MTU_MIN          0x0000000a  // unconnected only! optlen=sizeof(unsigned int), optval = &min. mtu
#define SO_BTH_GET_MTU_MIN          0x0000000b  // bound only! optlen=sizeof(unsigned int), optval = &min. mtu
#define SO_BTH_SET_XON_LIM          0x0000000c  // optlen=sizeof(unsigned int), optval = &xon limit (set flow off)
#define SO_BTH_GET_XON_LIM          0x0000000d  // optlen=sizeof(unsigned int), optval = &xon
#define SO_BTH_SET_XOFF_LIM         0x0000000e  // optlen=sizeof(unsigned int), optval = &xoff limit (set flow on)
#define SO_BTH_GET_XOFF_LIM         0x0000000f  // optlen=sizeof(unsigned int), optval = &xoff
#define SO_BTH_SET_SEND_BUFFER      0x00000010  // optlen=sizeof(unsigned int), optval = &max buffered size for send
#define SO_BTH_GET_SEND_BUFFER      0x00000011  // optlen=sizeof(unsigned int), optval = &max buffered size for send
#define SO_BTH_SET_RECV_BUFFER      0x00000012  // optlen=sizeof(unsigned int), optval = &max buffered size for recv
#define SO_BTH_GET_RECV_BUFFER      0x00000013  // optlen=sizeof(unsigned int), optval = &max buffered size for recv
#define SO_BTH_GET_V24_BR           0x00000014  // connected only! optlen=2*sizeof(unsigned int), optval = &{v24 , br}
#define SO_BTH_GET_RLS              0x00000015  // connected only! optlen=sizeof(unsigned int), optval = &rls
#define SO_BTH_SEND_MSC             0x00000016  // connected only! optlen=2*sizeof(unsigned int), optval = &{v24, br}
#define SO_BTH_SEND_RLS             0x00000017  // connected only! optlen=sizeof(unsigned int), optval = &rls
#define SO_BTH_GET_FLOW_TYPE        0x00000018  // connected only! optlen=sizeof(unsigned int), optval=&1=credit-based, 0=legacy
#define SO_BTH_SET_PAGE_TO          0x00000019  // no restrictions. optlen=sizeof(unsigned int), optval = &page timeout
#define SO_BTH_GET_PAGE_TO          0x0000001a  // no restrictions. optlen=sizeof(unsigned int), optval = &page timeout
#define SO_BTH_SET_SCAN             0x0000001b  // no restrictions. optlen=sizeof(unsigned int), optval = &scan mode
#define SO_BTH_GET_SCAN             0x0000001c  // no restrictions. optlen=sizeof(unsigned int), optval = &scan mode
#define SO_BTH_SET_COD              0x0000001d  // no restrictions. optlen=sizeof(unsigned int), optval = &cod
#define SO_BTH_GET_COD              0x0000001e  // no restrictions. optlen=sizeof(unsigned int), optval = &cod
#define SO_BTH_GET_LOCAL_VER        0x0000001f  // no restrictions. optlen=sizeof(BTH_LOCAL_VERSION), optval = &BTH_LOCAL_VERSION
#define SO_BTH_GET_REMOTE_VER       0x00000020  // connected only! optlen=sizeof(BTH_REMOTE_VERSION), optval = &BTH_REMOTE_VERSION
#define SO_BTH_GET_AUTHN_ENABLE     0x00000021  // no restrictions. optlen=sizeof(unsigned int), optval = &authentication enable
#define SO_BTH_SET_AUTHN_ENABLE     0x00000022  // no restrictions. optlen=sizeof(unsigned int), optval = &authentication enable
#define SO_BTH_SET_READ_REMOTE_NAME 0x00000023  // no restrictions. optlen=sizeof(BTH_REMOTE_NAME), optval=&BTH_REMOTE_NAME
#define SO_BTH_GET_LINK_POLICY      0x00000024  // connected only! optlen=sizeof(unsigned int), optval = &link policy
#define SO_BTH_SET_LINK_POLICY      0x00000025  // connected only! optlen=sizeof(unsigned int), optval = &link policy
#define SO_BTH_ENTER_HOLD_MODE      0x00000026  // connected only! optlen=sizeof(BTH_HOLD_MODE), optval = &BTH_HOLD_MODE
#define SO_BTH_ENTER_SNIFF_MODE     0x00000027  // connected only! optlen=sizeof(BTH_SNIFF_MODE), optval = &BTH_SNIFF_MODE
#define SO_BTH_EXIT_SNIFF_MODE      0x00000028  // connected only! optlen=0, optval - ignored
#define SO_BTH_ENTER_PARK_MODE      0x00000029  // connected only! optlen=sizeof(BTH_PARK_MODE), optval = &BTH_PARK_MODE
#define SO_BTH_EXIT_PARK_MODE       0x0000002a  // connected only! optlen=0, optval - ignored
#define SO_BTH_GET_MODE             0x0000002b  // connected only! optlen=sizeof(int), optval = &mode

typedef struct _SOCKADDR_BTH
{
    USHORT   addressFamily;
    bt_addr  btAddr;
    GUID     serviceClassId;
    ULONG    port;
} SOCKADDR_BTH, *PSOCKADDR_BTH;

typedef struct __bth_inquiry_result {
    BT_ADDR         ba;
    unsigned int    cod;
    unsigned short  clock_offset;
    unsigned char   page_scan_mode;
    unsigned char   page_scan_period_mode;
    unsigned char   page_scan_repetition_mode;
} BthInquiryResult;

#endif // __WS2BTH__H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\ws2atm.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++


Module Name:

	ws2atm.h

Abstract:

	Winsock 2 ATM Annex definitions.

Revision History:

Notes:

--*/

#ifndef _WS2ATM_H_
#define _WS2ATM_H_

#if _MSC_VER > 1000
#pragma once
#endif

#include <pshpack4.h>

#define ATMPROTO_AALUSER           0x00   /* User-defined AAL */
#define ATMPROTO_AAL1              0x01   /* AAL 1 */
#define ATMPROTO_AAL2              0x02   /* AAL 2 */
#define ATMPROTO_AAL34             0x03   /* AAL 3/4 */
#define ATMPROTO_AAL5              0x05   /* AAL 5 */

#define SAP_FIELD_ABSENT           0xFFFFFFFE
#define SAP_FIELD_ANY              0xFFFFFFFF
#define SAP_FIELD_ANY_AESA_SEL     0xFFFFFFFA
#define SAP_FIELD_ANY_AESA_REST    0xFFFFFFFB

/*
 *  values used for AddressType in struct ATM_ADDRESS
 */
#define ATM_E164               0x01   /* E.164 addressing scheme */
#define ATM_NSAP               0x02   /* NSAP-style ATM Endsystem Address scheme */
#define ATM_AESA               0x02   /* NSAP-style ATM Endsystem Address scheme */

#define ATM_ADDR_SIZE          20
typedef struct {
    DWORD AddressType;                /* E.164 or NSAP-style ATM Endsystem Address */
    DWORD NumofDigits;                /* number of digits; */
    UCHAR Addr[ATM_ADDR_SIZE];        /* IA5 digits for E164, BCD encoding for NSAP */
                                      /* format as defined in the ATM Forum UNI 3.1 */
} ATM_ADDRESS;

/*
 *  values used for Layer2Protocol in B-LLI
 */
#define BLLI_L2_ISO_1745           0x01   /* Basic mode ISO 1745                      */
#define BLLI_L2_Q921               0x02   /* CCITT Rec. Q.921                         */
#define BLLI_L2_X25L               0x06   /* CCITT Rec. X.25, link layer              */
#define BLLI_L2_X25M               0x07   /* CCITT Rec. X.25, multilink               */
#define BLLI_L2_ELAPB              0x08   /* Extended LAPB; for half duplex operation */
#define BLLI_L2_HDLC_ARM           0x09   /* HDLC ARM (ISO 4335)                      */
#define BLLI_L2_HDLC_NRM           0x0A   /* HDLC NRM (ISO 4335)                      */
#define BLLI_L2_HDLC_ABM           0x0B   /* HDLC ABM (ISO 4335)                      */
#define BLLI_L2_LLC                0x0C   /* LAN logical link control (ISO 8802/2)    */
#define BLLI_L2_X75                0x0D   /* CCITT Rec. X.75, single link procedure   */
#define BLLI_L2_Q922               0x0E   /* CCITT Rec. Q.922                         */
#define BLLI_L2_USER_SPECIFIED     0x10   /* User Specified                           */
#define BLLI_L2_ISO_7776           0x11   /* ISO 7776 DTE-DTE operation               */

/*
 *  values used for Layer3Protocol in B-LLI
 */
#define BLLI_L3_X25                0x06   /* CCITT Rec. X.25, packet layer            */
#define BLLI_L3_ISO_8208           0x07   /* ISO/IEC 8208 (X.25 packet layer for DTE  */
#define BLLI_L3_X223               0x08   /* X.223/ISO 8878                           */
#define BLLI_L3_SIO_8473           0x09   /* ISO/IEC 8473 (OSI connectionless)        */
#define BLLI_L3_T70                0x0A   /* CCITT Rec. T.70 min. network layer       */
#define BLLI_L3_ISO_TR9577         0x0B   /* ISO/IEC TR 9577 Network Layer Protocol ID*/
#define BLLI_L3_USER_SPECIFIED     0x10   /* User Specified                           */

/*
 *  values used for Layer3IPI in B-LLI
 */
#define BLLI_L3_IPI_SNAP           0x80   /* IEEE 802.1 SNAP identifier               */
#define BLLI_L3_IPI_IP             0xCC   /* Internet Protocol (IP) identifier        */

typedef struct {
    DWORD Layer2Protocol;                 /* User information layer 2 protocol           */
    DWORD Layer2UserSpecifiedProtocol;    /* User specified layer 2 protocol information */
    DWORD Layer3Protocol;                 /* User information layer 3 protocol           */
    DWORD Layer3UserSpecifiedProtocol;    /* User specified layer 3 protocol information */
    DWORD Layer3IPI;                      /* ISO/IEC TR 9577 Initial Protocol Identifier */
    UCHAR SnapID[5];                      /* SNAP ID consisting of OUI and PID           */
} ATM_BLLI;

/*
 *  values used for the HighLayerInfoType field in ATM_BHLI
 */
#define BHLI_ISO                   0x00   /* ISO                                 */
#define BHLI_UserSpecific          0x01   /* User Specific                       */
#define BHLI_HighLayerProfile      0x02   /* High layer profile (only in UNI3.0) */
#define BHLI_VendorSpecificAppId   0x03   /* Vendor-Specific Application ID      */

typedef struct {
    DWORD HighLayerInfoType;          /* High Layer Information Type      */
    DWORD HighLayerInfoLength;        /* number of bytes in HighLayerInfo */
    UCHAR HighLayerInfo[8];           /* the value dependent on the       */
                                      /*   HighLayerInfoType field        */
} ATM_BHLI;

typedef struct sockaddr_atm {
    u_short satm_family;              /* address family should be AF_ATM  */
    ATM_ADDRESS satm_number;          /* ATM address                      */
    ATM_BLLI satm_blli;               /* B-LLI                            */
    ATM_BHLI satm_bhli;               /* B-HLI                            */
} sockaddr_atm, SOCKADDR_ATM, *PSOCKADDR_ATM, *LPSOCKADDR_ATM;

typedef enum {
    IE_AALParameters,
    IE_TrafficDescriptor,
    IE_BroadbandBearerCapability,
    IE_BHLI,
    IE_BLLI,
    IE_CalledPartyNumber,
    IE_CalledPartySubaddress,
    IE_CallingPartyNumber,
    IE_CallingPartySubaddress,
    IE_Cause,
    IE_QOSClass,
    IE_TransitNetworkSelection,
} Q2931_IE_TYPE;

typedef struct {
    Q2931_IE_TYPE IEType;
    ULONG         IELength;
    UCHAR         IE[1];
} Q2931_IE;

/*
 *  manifest constants for the AALType field in struct AAL_PARAMETERS_IE
 */
typedef enum {
    AALTYPE_5     = 5,   /* AAL 5 */
    AALTYPE_USER  = 16,  /* user-defined AAL */
} AAL_TYPE;

/*
 *  values used for the Mode field in struct AAL5_PARAMETERS
 */
#define AAL5_MODE_MESSAGE           0x01
#define AAL5_MODE_STREAMING         0x02

/*
 *  values used for the SSCSType field in struct AAL5_PARAMETERS
 */
#define AAL5_SSCS_NULL              0x00
#define AAL5_SSCS_SSCOP_ASSURED     0x01
#define AAL5_SSCS_SSCOP_NON_ASSURED 0x02
#define AAL5_SSCS_FRAME_RELAY       0x04

typedef struct {
    ULONG ForwardMaxCPCSSDUSize;
    ULONG BackwardMaxCPCSSDUSize;
    UCHAR Mode;                        /* only available in UNI 3.0 */
    UCHAR SSCSType;
} AAL5_PARAMETERS;

typedef struct {
    ULONG UserDefined;
} AALUSER_PARAMETERS;

typedef struct {
    AAL_TYPE AALType;
    union {
        AAL5_PARAMETERS     AAL5Parameters;
        AALUSER_PARAMETERS  AALUserParameters;
    } AALSpecificParameters;
} AAL_PARAMETERS_IE;

typedef struct {
    ULONG PeakCellRate_CLP0;
    ULONG PeakCellRate_CLP01;
    ULONG SustainableCellRate_CLP0;
    ULONG SustainableCellRate_CLP01;
    ULONG MaxBurstSize_CLP0;
    ULONG MaxBurstSize_CLP01;
    BOOL  Tagging;
} ATM_TD;

typedef struct {
    ATM_TD Forward;
    ATM_TD Backward;
    BOOL   BestEffort;
} ATM_TRAFFIC_DESCRIPTOR_IE;

/*
 *  values used for the BearerClass field in struct ATM_BROADBAND_BEARER_CAPABILITY_IE
 */
#define BCOB_A                   0x01   /* Bearer class A                      */
#define BCOB_C                   0x03   /* Bearer class C                      */
#define BCOB_X                   0x10   /* Bearer class X                      */

/*
 *  values used for the TrafficType field in struct ATM_BROADBAND_BEARER_CAPABILITY_IE
 */
#define TT_NOIND                 0x00   /* No indication of traffic type       */
#define TT_CBR                   0x04   /* Constant bit rate                   */
#define TT_VBR                   0x08   /* Variable bit rate                   */

/*
 *  values used for the TimingRequirements field in struct ATM_BROADBAND_BEARER_CAPABILITY_IE
 */
#define TR_NOIND                 0x00   /* No timing requirement indication    */
#define TR_END_TO_END            0x01   /* End-to-end timing required          */
#define TR_NO_END_TO_END         0x02   /* End-to-end timing not required      */

/*
 *  values used for the ClippingSusceptability field in struct ATM_BROADBAND_BEARER_CAPABILITY_IE
 */
#define CLIP_NOT                 0x00   /* Not susceptible to clipping         */
#define CLIP_SUS                 0x20   /* Susceptible to clipping             */

/*
 *  values used for the UserPlaneConnectionConfig field in
 *  struct ATM_BROADBAND_BEARER_CAPABILITY_IE
 */
#define UP_P2P                   0x00   /* Point-to-point connection           */
#define UP_P2MP                  0x01   /* Point-to-multipoint connection      */

typedef struct {
    UCHAR BearerClass;
    UCHAR TrafficType;
    UCHAR TimingRequirements;
    UCHAR ClippingSusceptability;
    UCHAR UserPlaneConnectionConfig;
} ATM_BROADBAND_BEARER_CAPABILITY_IE;

typedef ATM_BHLI ATM_BHLI_IE;

/*
 *  values used for the Layer2Mode field in struct ATM_BLLI_IE
 */
#define BLLI_L2_MODE_NORMAL         0x40
#define BLLI_L2_MODE_EXT            0x80

/*
 *  values used for the Layer3Mode field in struct ATM_BLLI_IE
 */
#define BLLI_L3_MODE_NORMAL         0x40
#define BLLI_L3_MODE_EXT            0x80

/*
 *  values used for the Layer3DefaultPacketSize field in struct ATM_BLLI_IE
 */
#define BLLI_L3_PACKET_16           0x04
#define BLLI_L3_PACKET_32           0x05
#define BLLI_L3_PACKET_64           0x06
#define BLLI_L3_PACKET_128          0x07
#define BLLI_L3_PACKET_256          0x08
#define BLLI_L3_PACKET_512          0x09
#define BLLI_L3_PACKET_1024         0x0A
#define BLLI_L3_PACKET_2048         0x0B
#define BLLI_L3_PACKET_4096         0x0C

typedef struct {
    DWORD Layer2Protocol;                 /* User information layer 2 protocol           */
    UCHAR Layer2Mode;
    UCHAR Layer2WindowSize;
    DWORD Layer2UserSpecifiedProtocol;    /* User specified layer 2 protocol information */
    DWORD Layer3Protocol;                 /* User information layer 3 protocol           */
    UCHAR Layer3Mode;
    UCHAR Layer3DefaultPacketSize;
    UCHAR Layer3PacketWindowSize;
    DWORD Layer3UserSpecifiedProtocol;    /* User specified layer 3 protocol information */
    DWORD Layer3IPI;                      /* ISO/IEC TR 9577 Initial Protocol Identifier */
    UCHAR SnapID[5];                      /* SNAP ID consisting of OUI and PID           */
} ATM_BLLI_IE;

typedef ATM_ADDRESS ATM_CALLED_PARTY_NUMBER_IE;

typedef ATM_ADDRESS ATM_CALLED_PARTY_SUBADDRESS_IE;

/*
 *  values used for the Presentation_Indication field in
 *  struct ATM_CALLING_PARTY_NUMBER_IE
 */
#define PI_ALLOWED                  0x00
#define PI_RESTRICTED               0x40
#define PI_NUMBER_NOT_AVAILABLE     0x80

/*
 *  values used for the Screening_Indicator field in
 *  struct ATM_CALLING_PARTY_NUMBER_IE
 */
#define SI_USER_NOT_SCREENED        0x00
#define SI_USER_PASSED              0x01
#define SI_USER_FAILED              0x02
#define SI_NETWORK                  0x03

typedef struct {
    ATM_ADDRESS ATM_Number;
    UCHAR       Presentation_Indication;
    UCHAR       Screening_Indicator;
} ATM_CALLING_PARTY_NUMBER_IE;

typedef ATM_ADDRESS ATM_CALLING_PARTY_SUBADDRESS_IE;

/*
 *  values used for the Location field in struct ATM_CAUSE_IE
 */
#define CAUSE_LOC_USER                      0x00
#define CAUSE_LOC_PRIVATE_LOCAL             0x01
#define CAUSE_LOC_PUBLIC_LOCAL              0x02
#define CAUSE_LOC_TRANSIT_NETWORK           0x03
#define CAUSE_LOC_PUBLIC_REMOTE             0x04
#define CAUSE_LOC_PRIVATE_REMOTE            0x05
#define CAUSE_LOC_INTERNATIONAL_NETWORK     0x07
#define CAUSE_LOC_BEYOND_INTERWORKING       0x0A

/*
 *  values used for the Cause field in struct ATM_CAUSE_IE
 */
#define CAUSE_UNALLOCATED_NUMBER                0x01
#define CAUSE_NO_ROUTE_TO_TRANSIT_NETWORK       0x02
#define CAUSE_NO_ROUTE_TO_DESTINATION           0x03
#define CAUSE_VPI_VCI_UNACCEPTABLE              0x0A
#define CAUSE_NORMAL_CALL_CLEARING              0x10
#define CAUSE_USER_BUSY                         0x11
#define CAUSE_NO_USER_RESPONDING                0x12
#define CAUSE_CALL_REJECTED                     0x15
#define CAUSE_NUMBER_CHANGED                    0x16
#define CAUSE_USER_REJECTS_CLIR                 0x17
#define CAUSE_DESTINATION_OUT_OF_ORDER          0x1B
#define CAUSE_INVALID_NUMBER_FORMAT             0x1C
#define CAUSE_STATUS_ENQUIRY_RESPONSE           0x1E
#define CAUSE_NORMAL_UNSPECIFIED                0x1F
#define CAUSE_VPI_VCI_UNAVAILABLE               0x23
#define CAUSE_NETWORK_OUT_OF_ORDER              0x26
#define CAUSE_TEMPORARY_FAILURE                 0x29
#define CAUSE_ACCESS_INFORMAION_DISCARDED       0x2B
#define CAUSE_NO_VPI_VCI_AVAILABLE              0x2D
#define CAUSE_RESOURCE_UNAVAILABLE              0x2F
#define CAUSE_QOS_UNAVAILABLE                   0x31
#define CAUSE_USER_CELL_RATE_UNAVAILABLE        0x33
#define CAUSE_BEARER_CAPABILITY_UNAUTHORIZED    0x39
#define CAUSE_BEARER_CAPABILITY_UNAVAILABLE     0x3A
#define CAUSE_OPTION_UNAVAILABLE                0x3F
#define CAUSE_BEARER_CAPABILITY_UNIMPLEMENTED   0x41
#define CAUSE_UNSUPPORTED_TRAFFIC_PARAMETERS    0x49
#define CAUSE_INVALID_CALL_REFERENCE            0x51
#define CAUSE_CHANNEL_NONEXISTENT               0x52
#define CAUSE_INCOMPATIBLE_DESTINATION          0x58
#define CAUSE_INVALID_ENDPOINT_REFERENCE        0x59
#define CAUSE_INVALID_TRANSIT_NETWORK_SELECTION 0x5B
#define CAUSE_TOO_MANY_PENDING_ADD_PARTY        0x5C
#define CAUSE_AAL_PARAMETERS_UNSUPPORTED        0x5D
#define CAUSE_MANDATORY_IE_MISSING              0x60
#define CAUSE_UNIMPLEMENTED_MESSAGE_TYPE        0x61
#define CAUSE_UNIMPLEMENTED_IE                  0x63
#define CAUSE_INVALID_IE_CONTENTS               0x64
#define CAUSE_INVALID_STATE_FOR_MESSAGE         0x65
#define CAUSE_RECOVERY_ON_TIMEOUT               0x66
#define CAUSE_INCORRECT_MESSAGE_LENGTH          0x68
#define CAUSE_PROTOCOL_ERROR                    0x6F

/*
 *  values used for the Condition portion of the Diagnostics field
 *  in struct ATM_CAUSE_IE, for certain Cause values
 */
#define CAUSE_COND_UNKNOWN                  0x00
#define CAUSE_COND_PERMANENT                0x01
#define CAUSE_COND_TRANSIENT                0x02

/*
 *  values used for the Rejection Reason portion of the Diagnostics field
 *  in struct ATM_CAUSE_IE, for certain Cause values
 */
#define CAUSE_REASON_USER                   0x00
#define CAUSE_REASON_IE_MISSING             0x04
#define CAUSE_REASON_IE_INSUFFICIENT        0x08

/*
 *  values used for the P-U flag of the Diagnostics field
 *  in struct ATM_CAUSE_IE, for certain Cause values
 */
#define CAUSE_PU_PROVIDER                   0x00
#define CAUSE_PU_USER                       0x08

/*
 *  values used for the N-A flag of the Diagnostics field
 *  in struct ATM_CAUSE_IE, for certain Cause values
 */
#define CAUSE_NA_NORMAL                     0x00
#define CAUSE_NA_ABNORMAL                   0x04

typedef struct {
    UCHAR Location;
    UCHAR Cause;
    UCHAR DiagnosticsLength;
    UCHAR Diagnostics[4];
} ATM_CAUSE_IE;

/*
 *  values used for the QOSClassForward and QOSClassBackward
 *  field in struct ATM_QOS_CLASS_IE
 */
#define QOS_CLASS0                  0x00
#define QOS_CLASS1                  0x01
#define QOS_CLASS2                  0x02
#define QOS_CLASS3                  0x03
#define QOS_CLASS4                  0x04

typedef struct {
    UCHAR QOSClassForward;
    UCHAR QOSClassBackward;
} ATM_QOS_CLASS_IE;

/*
 *  values used for the TypeOfNetworkId field in struct ATM_TRANSIT_NETWORK_SELECTION_IE
 */
#define TNS_TYPE_NATIONAL           0x40

/*
 *  values used for the NetworkIdPlan field in struct ATM_TRANSIT_NETWORK_SELECTION_IE
 */
#define TNS_PLAN_CARRIER_ID_CODE    0x01

typedef struct {
    UCHAR TypeOfNetworkId;
    UCHAR NetworkIdPlan;
    UCHAR NetworkIdLength;
    UCHAR NetworkId[1];
} ATM_TRANSIT_NETWORK_SELECTION_IE;

/*
 *  ATM specific Ioctl codes
 */
#define SIO_GET_NUMBER_OF_ATM_DEVICES   0x50160001
#define SIO_GET_ATM_ADDRESS             0xd0160002
#define SIO_ASSOCIATE_PVC               0x90160003
#define SIO_GET_ATM_CONNECTION_ID       0x50160004

/* ATM Connection Identifier */

typedef struct {
    DWORD  DeviceNumber;
    DWORD  VPI;
    DWORD  VCI;
} ATM_CONNECTION_ID;

/*
 * Input buffer format for SIO_ASSOCIATE_PVC
 */

typedef struct {
   ATM_CONNECTION_ID   PvcConnectionId;
   QOS                 PvcQos;
} ATM_PVC_PARAMS;

#include <poppack.h>

#endif   /* _WS2ATM_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\ws2tcpip.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*
**  WS2TCPIP.H - WinSock2 Extension for TCP/IP protocols
**
**  This file contains TCP/IP specific information for use
**  by WinSock2 compatible applications.
**
**  Copyright (c) Microsoft Corporation. All rights reserved.
**
**  To provide the backward compatibility, all the TCP/IP
**  specific definitions that were included in the WINSOCK.H
**   file are now included in WINSOCK2.H file. WS2TCPIP.H
**  file includes only the definitions  introduced in the
**  "WinSock 2 Protocol-Specific Annex" document.
**
**  Rev 0.3 Nov 13, 1995
**      Rev 0.4 Dec 15, 1996
*/

#ifndef _WS2TCPIP_H_
#define _WS2TCPIP_H_

#if _MSC_VER > 1000
#pragma once
#endif

#include <winsock2.h>
#include <ws2ipdef.h>
#include <limits.h>

/* Option to use with [gs]etsockopt at the IPPROTO_UDP level */

#define UDP_NOCHECKSUM  1
#define UDP_CHECKSUM_COVERAGE   20  /* Set/get UDP-Lite checksum coverage */

#ifdef _MSC_VER
#define WS2TCPIP_INLINE __inline
#else
#define WS2TCPIP_INLINE extern inline /* GNU style */
#endif

/* Error codes from getaddrinfo() */

#define EAI_AGAIN       WSATRY_AGAIN
#define EAI_BADFLAGS    WSAEINVAL
#define EAI_FAIL        WSANO_RECOVERY
#define EAI_FAMILY      WSAEAFNOSUPPORT
#define EAI_MEMORY      WSA_NOT_ENOUGH_MEMORY
//#define EAI_NODATA      WSANO_DATA
#define EAI_NONAME      WSAHOST_NOT_FOUND
#define EAI_SERVICE     WSATYPE_NOT_FOUND
#define EAI_SOCKTYPE    WSAESOCKTNOSUPPORT

//
//  DCR_FIX:  EAI_NODATA remove or fix
//
//  EAI_NODATA was removed from rfc2553bis
//  need to find out from the authors why and
//  determine the error for "no records of this type"
//  temporarily, we'll keep #define to avoid changing
//  code that could change back;  use NONAME
//

#define EAI_NODATA      EAI_NONAME


/* Structure used in getaddrinfo() call */

typedef struct addrinfo
{
    int                 ai_flags;       // AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST
    int                 ai_family;      // PF_xxx
    int                 ai_socktype;    // SOCK_xxx
    int                 ai_protocol;    // 0 or IPPROTO_xxx for IPv4 and IPv6
    size_t              ai_addrlen;     // Length of ai_addr
    char *              ai_canonname;   // Canonical name for nodename
    __field_bcount(ai_addrlen) struct sockaddr *   ai_addr;        // Binary address
    struct addrinfo *   ai_next;        // Next structure in linked list
}
ADDRINFOA, *PADDRINFOA;

typedef struct addrinfoW
{
    int                 ai_flags;       // AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST
    int                 ai_family;      // PF_xxx
    int                 ai_socktype;    // SOCK_xxx
    int                 ai_protocol;    // 0 or IPPROTO_xxx for IPv4 and IPv6
    size_t              ai_addrlen;     // Length of ai_addr
    PWSTR               ai_canonname;   // Canonical name for nodename
    __field_bcount(ai_addrlen) struct sockaddr *   ai_addr;        // Binary address
    struct addrinfoW *  ai_next;        // Next structure in linked list
}
ADDRINFOW, *PADDRINFOW;

//  Switchable definition for GetAddrInfo()

#ifdef UNICODE
typedef ADDRINFOW       ADDRINFOT, *PADDRINFOT;
#else
typedef ADDRINFOA       ADDRINFOT, *PADDRINFOT;
#endif

//  RFC standard definition for getaddrinfo()

typedef ADDRINFOA       ADDRINFO, FAR * LPADDRINFO;

#if (_WIN32_WINNT >= 0x0600)

typedef struct addrinfoexA
{
    int                 ai_flags;       // AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST
    int                 ai_family;      // PF_xxx
    int                 ai_socktype;    // SOCK_xxx
    int                 ai_protocol;    // 0 or IPPROTO_xxx for IPv4 and IPv6
    size_t              ai_addrlen;     // Length of ai_addr
    char               *ai_canonname;   // Canonical name for nodename
    struct sockaddr    *ai_addr;        // Binary address
    void               *ai_blob;
    size_t              ai_bloblen;
    LPGUID              ai_provider;
    struct addrinfoexA *ai_next;        // Next structure in linked list
} ADDRINFOEXA, *PADDRINFOEXA, *LPADDRINFOEXA;

typedef struct addrinfoexW
{
    int                 ai_flags;       // AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST
    int                 ai_family;      // PF_xxx
    int                 ai_socktype;    // SOCK_xxx
    int                 ai_protocol;    // 0 or IPPROTO_xxx for IPv4 and IPv6
    size_t              ai_addrlen;     // Length of ai_addr
    PWSTR               ai_canonname;   // Canonical name for nodename
    __field_bcount(ai_addrlen) struct sockaddr    *ai_addr;        // Binary address
    __field_ecount(ai_bloblen) void               *ai_blob;
    size_t              ai_bloblen;
    LPGUID              ai_provider;
    struct addrinfoexW *ai_next;        // Next structure in linked list
} ADDRINFOEXW, *PADDRINFOEXW, *LPADDRINFOEXW;

#ifdef UNICODE
typedef ADDRINFOEXW     ADDRINFOEX, *PADDRINFOEX;
#else
typedef ADDRINFOEXA     ADDRINFOEX, *PADDRINFOEX;
#endif

#endif


//
//  Flags used in "hints" argument to getaddrinfo()
//      - AI_ADDRCONFIG is supported starting with Vista
//      - default is AI_ADDRCONFIG ON whether the flag is set or not
//        because the performance penalty in not having ADDRCONFIG in
//        the multi-protocol stack environment is severe;
//        this defaulting may be disabled by specifying the AI_ALL flag,
//        in that case AI_ADDRCONFIG must be EXPLICITLY specified to
//        enable ADDRCONFIG behavior
//

#define AI_PASSIVE      0x00000001  // Socket address will be used in bind() call
#define AI_CANONNAME    0x00000002  // Return canonical name in first ai_canonname
#define AI_NUMERICHOST  0x00000004  // Nodename must be a numeric address string
#define AI_NUMERICSERV  0x00000008  // Servicename must be a numeric port number

#define AI_ALL          0x00000100  // Query both IP6 and IP4 with AI_V4MAPPED
#define AI_ADDRCONFIG   0x00000400  // Resolution only if global address configured
#define AI_V4MAPPED     0x00000800  // On v6 failure, query v4 and convert to V4MAPPED format


#define AI_NON_AUTHORITATIVE        LUP_NON_AUTHORITATIVE       // 0x4000
#define AI_SECURE                   LUP_SECURE                  // 0x8000
#define AI_RETURN_PREFERRED_NAMES   LUP_RETURN_PREFERRED_NAMES  // 0x10000

#ifdef __cplusplus
extern "C" {
#endif

WINSOCK_API_LINKAGE
INT
WSAAPI
getaddrinfo(
    __in_opt        PCSTR               pNodeName,
    __in_opt        PCSTR               pServiceName,
    __in_opt        const ADDRINFOA *   pHints,
    __deref_out     PADDRINFOA *        ppResult
    );

#if (_WIN32_WINNT >= 0x0502)
WINSOCK_API_LINKAGE
INT
WSAAPI
GetAddrInfoW(
    __in_opt        PCWSTR              pNodeName,
    __in_opt        PCWSTR              pServiceName,
    __in_opt        const ADDRINFOW *   pHints,
    __deref_out     PADDRINFOW *        ppResult
    );

#define GetAddrInfoA    getaddrinfo

#ifdef UNICODE
#define GetAddrInfo     GetAddrInfoW
#else
#define GetAddrInfo     GetAddrInfoA
#endif
#endif

#if INCL_WINSOCK_API_TYPEDEFS
typedef
INT
(WSAAPI * LPFN_GETADDRINFO)(
    __in_opt        PCSTR               pNodeName,
    __in_opt        PCSTR               pServiceName,
    __in_opt        const ADDRINFOA *   pHints,
    __deref_out     PADDRINFOA *        ppResult
    );

typedef
INT
(WSAAPI * LPFN_GETADDRINFOW)(
    __in_opt        PCWSTR              pNodeName,
    __in_opt        PCWSTR              pServiceName,
    __in_opt        const ADDRINFOW *   pHints,
    __deref_out     PADDRINFOW *        ppResult
    );

#define LPFN_GETADDRINFOA      LPFN_GETADDRINFO

#ifdef UNICODE
#define LPFN_GETADDRINFOT      LPFN_GETADDRINFOW
#else
#define LPFN_GETADDRINFOT      LPFN_GETADDRINFOA
#endif
#endif

#if (_WIN32_WINNT >= 0x0600)

typedef
void
(CALLBACK * LPLOOKUPSERVICE_COMPLETION_ROUTINE)(
    IN      DWORD    dwError,
    IN      DWORD    dwBytes,
    __in    LPWSAOVERLAPPED lpOverlapped
    );

WINSOCK_API_LINKAGE
INT
WSAAPI
GetAddrInfoExA(
    __in_opt    PCSTR           pName,
    __in_opt    PCSTR           pServiceName,
    __in        DWORD           dwNameSpace,
    __in_opt    LPGUID          lpNspId,
    __in_opt    const ADDRINFOEXA *hints,
    __deref_out PADDRINFOEXA *  ppResult,
    __in_opt    struct timeval *timeout,
    __in_opt    LPOVERLAPPED    lpOverlapped,
    __in_opt    LPLOOKUPSERVICE_COMPLETION_ROUTINE  lpCompletionRoutine,
    __out_opt   LPHANDLE        lpNameHandle
    );

WINSOCK_API_LINKAGE
INT
WSAAPI
GetAddrInfoExW(
    __in_opt    PCWSTR          pName,
    __in_opt    PCWSTR          pServiceName,
    __in        DWORD           dwNameSpace,
    __in_opt    LPGUID          lpNspId,
    __in_opt    const ADDRINFOEXW *hints,
    __deref_out PADDRINFOEXW *  ppResult,
    __in_opt    struct timeval *timeout,
    __in_opt    LPOVERLAPPED    lpOverlapped,
    __in_opt    LPLOOKUPSERVICE_COMPLETION_ROUTINE  lpCompletionRoutine,
    __out_opt   LPHANDLE        lpHandle
    );

#ifdef UNICODE
#define GetAddrInfoEx       GetAddrInfoExW
#else
#define GetAddrInfoEx       GetAddrInfoExA
#endif

#if INCL_WINSOCK_API_TYPEDEFS

typedef
INT
(WSAAPI *LPFN_GETADDRINFOEXA)(
    __in        PCSTR           pName,
    __in_opt    PCSTR           pServiceName,
    __in        DWORD           dwNameSpace,
    __in_opt    LPGUID          lpNspId,
    __in_opt    const ADDRINFOEXA *hints,
    __deref_out PADDRINFOEXA   *ppResult,
    __in_opt    struct timeval *timeout,
    __in_opt    LPOVERLAPPED    lpOverlapped,
    __in_opt    LPLOOKUPSERVICE_COMPLETION_ROUTINE  lpCompletionRoutine,
    __out_opt   LPHANDLE        lpNameHandle
    );

typedef
INT
(WSAAPI *LPFN_GETADDRINFOEXW)(
    __in        PCWSTR          pName,
    __in_opt    PCWSTR          pServiceName,
    __in        DWORD           dwNameSpace,
    __in_opt    LPGUID          lpNspId,
    __in_opt    const ADDRINFOEXW *hints,
    __deref_out PADDRINFOEXW   *ppResult,
    __in_opt    struct timeval *timeout,
    __in_opt    LPOVERLAPPED    lpOverlapped,
    __in_opt    LPLOOKUPSERVICE_COMPLETION_ROUTINE  lpCompletionRoutine,
    __out_opt   LPHANDLE        lpHandle
    );

#ifdef UNICODE
#define LPFN_GETADDRINFOEX      LPFN_GETADDRINFOEXW
#else
#define LPFN_GETADDRINFOEX      LPFN_GETADDRINFOEXA
#endif
#endif

#endif

#if (_WIN32_WINNT >= 0x0600)

WINSOCK_API_LINKAGE
INT
WSAAPI
SetAddrInfoExA(
    __in        PCSTR           pName,
    __in_opt    PCSTR           pServiceName,
    __in_opt    SOCKET_ADDRESS *pAddresses,
    __in        DWORD           dwAddressCount,
    __in_opt    LPBLOB          lpBlob,
    __in        DWORD           dwFlags,
    __in        DWORD           dwNameSpace,
    __in_opt    LPGUID          lpNspId,
    __in_opt    struct timeval *timeout,
    __in_opt    LPOVERLAPPED    lpOverlapped,
    __in_opt    LPLOOKUPSERVICE_COMPLETION_ROUTINE  lpCompletionRoutine,
    __out_opt   LPHANDLE        lpNameHandle
    );

WINSOCK_API_LINKAGE
INT
WSAAPI
SetAddrInfoExW(
    __in        PCWSTR          pName,
    __in_opt    PCWSTR          pServiceName,
    __in_opt    SOCKET_ADDRESS *pAddresses,
    __in        DWORD           dwAddressCount,
    __in_opt    LPBLOB          lpBlob,
    __in        DWORD           dwFlags,
    __in        DWORD           dwNameSpace,
    __in_opt    LPGUID          lpNspId,
    __in_opt    struct timeval *timeout,
    __in_opt    LPOVERLAPPED    lpOverlapped,
    __in_opt    LPLOOKUPSERVICE_COMPLETION_ROUTINE  lpCompletionRoutine,
    __out_opt   LPHANDLE        lpNameHandle
    );

#ifdef UNICODE
#define SetAddrInfoEx       SetAddrInfoExW
#else
#define SetAddrInfoEx       SetAddrInfoExA
#endif

#if INCL_WINSOCK_API_TYPEDEFS
typedef
INT
(WSAAPI *LPFN_SETADDRINFOEXA)(
    __in        PCSTR           pName,
    __in_opt    PCSTR           pServiceName,
    __in_opt    SOCKET_ADDRESS *pAddresses,
    __in        DWORD           dwAddressCount,
    __in_opt    LPBLOB          lpBlob,
    __in        DWORD           dwFlags,
    __in        DWORD           dwNameSpace,
    __in_opt    LPGUID          lpNspId,
    __in_opt    struct timeval *timeout,
    __in_opt    LPOVERLAPPED    lpOverlapped,
    __in_opt    LPLOOKUPSERVICE_COMPLETION_ROUTINE  lpCompletionRoutine,
    __out_opt   LPHANDLE        lpNameHandle
    );

typedef
INT
(WSAAPI *LPFN_SETADDRINFOEXW)(
    __in        PCWSTR          pName,
    __in_opt    PCWSTR          pServiceName,
    __in_opt    SOCKET_ADDRESS *pAddresses,
    __in        DWORD           dwAddressCount,
    __in_opt    LPBLOB          lpBlob,
    __in        DWORD           dwFlags,
    __in        DWORD           dwNameSpace,
    __in_opt    LPGUID          lpNspId,
    __in_opt    struct timeval *timeout,
    __in_opt    LPOVERLAPPED    lpOverlapped,
    __in_opt    LPLOOKUPSERVICE_COMPLETION_ROUTINE  lpCompletionRoutine,
    __out_opt   LPHANDLE        lpNameHandle
    );

#ifdef UNICODE
#define LPFN_SETADDRINFOEX      LPFN_SETADDRINFOEXW
#else
#define LPFN_SETADDRINFOEX      LPFN_SETADDRINFOEXA
#endif
#endif

#endif

WINSOCK_API_LINKAGE
VOID
WSAAPI
freeaddrinfo(
    __in_opt        PADDRINFOA      pAddrInfo
    );

#if (_WIN32_WINNT >= 0x0502)
WINSOCK_API_LINKAGE
VOID
WSAAPI
FreeAddrInfoW(
    __in_opt        PADDRINFOW      pAddrInfo
    );

#define FreeAddrInfoA   freeaddrinfo

#ifdef UNICODE
#define FreeAddrInfo    FreeAddrInfoW
#else
#define FreeAddrInfo    FreeAddrInfoA
#endif
#endif


#if INCL_WINSOCK_API_TYPEDEFS
typedef
VOID
(WSAAPI * LPFN_FREEADDRINFO)(
    __in_opt        PADDRINFOA      pAddrInfo
    );
typedef
VOID
(WSAAPI * LPFN_FREEADDRINFOW)(
    __in_opt        PADDRINFOW      pAddrInfo
    );

#define LPFN_FREEADDRINFOA      LPFN_FREEADDRINFO

#ifdef UNICODE
#define LPFN_FREEADDRINFOT      LPFN_FREEADDRINFOW
#else
#define LPFN_FREEADDRINFOT      LPFN_FREEADDRINFOA
#endif
#endif

#if (_WIN32_WINNT >= 0x0600)

WINSOCK_API_LINKAGE
void
WSAAPI
FreeAddrInfoEx(
    __in_opt  PADDRINFOEXA    pAddrInfoEx
    );

WINSOCK_API_LINKAGE
void
WSAAPI
FreeAddrInfoExW(
    __in_opt  PADDRINFOEXW    pAddrInfoEx
    );

#define FreeAddrInfoExA     FreeAddrInfoEx

#ifdef UNICODE
#define FreeAddrInfoEx      FreeAddrInfoExW
#endif

#ifdef INCL_WINSOCK_API_TYPEDEFS
typedef
void
(WSAAPI *LPFN_FREEADDRINFOEXA)(
    __in    PADDRINFOEXA    pAddrInfoEx
    );

typedef
void
(WSAAPI *LPFN_FREEADDRINFOEXW)(
    __in    PADDRINFOEXW    pAddrInfoEx
    );


#ifdef UNICODE
#define LPFN_FREEADDRINFOEX     LPFN_FREEADDRINFOEXW
#else
#define LPFN_FREEADDRINFOEX     LPFN_FREEADDRINFOEXA
#endif

#endif
#endif

typedef int socklen_t;

WINSOCK_API_LINKAGE
INT
WSAAPI
getnameinfo(
    __in_bcount(SockaddrLength)         const SOCKADDR *    pSockaddr,
    __in                                socklen_t           SockaddrLength,
    __out_ecount_opt(NodeBufferSize)    PCHAR               pNodeBuffer,
    __in                                DWORD               NodeBufferSize,
    __out_ecount_opt(ServiceBufferSize) PCHAR               pServiceBuffer,
    __in                                DWORD               ServiceBufferSize,
    __in                                INT                 Flags
    );

#if (_WIN32_WINNT >= 0x0502)
WINSOCK_API_LINKAGE
INT
WSAAPI
GetNameInfoW(
    __in_bcount(SockaddrLength)         const SOCKADDR *    pSockaddr,
    __in                                socklen_t           SockaddrLength,
    __out_ecount_opt(NodeBufferSize)    PWCHAR              pNodeBuffer,
    __in                                DWORD               NodeBufferSize,
    __out_ecount_opt(ServiceBufferSize) PWCHAR              pServiceBuffer,
    __in                                DWORD               ServiceBufferSize,
    __in                                INT                 Flags
    );

#define GetNameInfoA    getnameinfo

#ifdef UNICODE
#define GetNameInfo     GetNameInfoW
#else
#define GetNameInfo     GetNameInfoA
#endif
#endif

#if INCL_WINSOCK_API_TYPEDEFS
typedef
int
(WSAAPI * LPFN_GETNAMEINFO)(
    __in_bcount(SockaddrLength)         const SOCKADDR *    pSockaddr,
    __in                                socklen_t           SockaddrLength,
    __out_ecount_opt(NodeBufferSize)    PCHAR               pNodeBuffer,
    __in                                DWORD               NodeBufferSize,
    __out_ecount_opt(ServiceBufferSize) PCHAR               pServiceBuffer,
    __in                                DWORD               ServiceBufferSize,
    __in                                INT                 Flags
    );

typedef
INT
(WSAAPI * LPFN_GETNAMEINFOW)(
    __in_bcount(SockaddrLength)         const SOCKADDR *    pSockaddr,
    __in                                socklen_t           SockaddrLength,
    __out_ecount_opt(NodeBufferSize)    PWCHAR              pNodeBuffer,
    __in                                DWORD               NodeBufferSize,
    __out_ecount_opt(ServiceBufferSize) PWCHAR              pServiceBuffer,
    __in                                DWORD               ServiceBufferSize,
    __in                                INT                 Flags
    );

#define LPFN_GETNAMEINFOA      LPFN_GETNAMEINFO

#ifdef UNICODE
#define LPFN_GETNAMEINFOT      LPFN_GETNAMEINFOW
#else
#define LPFN_GETNAMEINFOT      LPFN_GETNAMEINFOA
#endif
#endif


#if (NTDDI_VERSION >= NTDDI_VISTA)
WINSOCK_API_LINKAGE
INT
WSAAPI
inet_pton(
    __in                                INT             Family,
    __in                                PCSTR           pszAddrString,
    __out_bcount(sizeof(IN6_ADDR))      PVOID           pAddrBuf
    );

INT
WSAAPI
InetPtonW(
    __in                                INT             Family,
    __in                                PCWSTR          pszAddrString,
    __out_bcount(sizeof(IN6_ADDR))      PVOID           pAddrBuf
    );

PCSTR
WSAAPI
inet_ntop(
    __in                                INT             Family,
    __in                                PVOID           pAddr,
    __out_ecount(StringBufSize)         PSTR            pStringBuf,
    __in                                size_t          StringBufSize
    );

PCWSTR
WSAAPI
InetNtopW(
    __in                                INT             Family,
    __in                                PVOID           pAddr,
    __out_ecount(StringBufSize)         PWSTR           pStringBuf,
    __in                                size_t          StringBufSize
    );

#define InetPtonA       inet_pton
#define InetNtopA       inet_ntop

#ifdef UNICODE
#define InetPton        InetPtonW
#define InetNtop        InetNtopW
#else
#define InetPton        InetPtonA
#define InetNtop        InetNtopA
#endif

#if INCL_WINSOCK_API_TYPEDEFS
typedef
INT
(WSAAPI * LPFN_INET_PTONA)(
    __in                                INT             Family,
    __in                                PCSTR           pszAddrString,
    __out_bcount(sizeof(IN6_ADDR))      PVOID           pAddrBuf
    );

typedef
INT
(WSAAPI * LPFN_INET_PTONW)(
    __in                                INT             Family,
    __in                                PCWSTR          pszAddrString,
    __out_bcount(sizeof(IN6_ADDR))      PVOID           pAddrBuf
    );

typedef
PCSTR
(WSAAPI * LPFN_INET_NTOPA)(
    __in                                INT             Family,
    __in                                PVOID           pAddr,
    __out_ecount(StringBufSize)         PSTR            pStringBuf,
    __in                                size_t          StringBufSize
    );

typedef
PCWSTR
(WSAAPI * LPFN_INET_NTOPW)(
    __in                                INT             Family,
    __in                                PVOID           pAddr,
    __out_ecount(StringBufSize)         PWSTR           pStringBuf,
    __in                                size_t          StringBufSize
    );

#ifdef UNICODE
#define LPFN_INET_PTON          LPFN_INET_PTONW
#define LPFN_INET_NTOP          LPFN_INET_NTOPW
#else
#define LPFN_INET_PTON          LPFN_INET_PTONA
#define LPFN_INET_NTOP          LPFN_INET_NTOPA
#endif

#endif  //  TYPEDEFS
#endif  //  LONGHORN



#if INCL_WINSOCK_API_PROTOTYPES
#ifdef UNICODE
#define gai_strerror   gai_strerrorW
#else
#define gai_strerror   gai_strerrorA
#endif  /* UNICODE */

// WARNING: The gai_strerror inline functions below use static buffers,
// and hence are not thread-safe.  We'll use buffers long enough to hold
// 1k characters.  Any system error messages longer than this will be
// returned as empty strings.  However 1k should work for the error codes
// used by getaddrinfo().
#define GAI_STRERROR_BUFFER_SIZE 1024

WS2TCPIP_INLINE
char *
gai_strerrorA(
    IN int ecode)
{
    DWORD dwMsgLen;
    static char buff[GAI_STRERROR_BUFFER_SIZE + 1];

    dwMsgLen = FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM
                             |FORMAT_MESSAGE_IGNORE_INSERTS
                             |FORMAT_MESSAGE_MAX_WIDTH_MASK,
                              NULL,
                              ecode,
                              MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                              (LPSTR)buff,
                              GAI_STRERROR_BUFFER_SIZE,
                              NULL);

    return buff;
}

WS2TCPIP_INLINE
WCHAR *
gai_strerrorW(
    IN int ecode
    )
{
    DWORD dwMsgLen;
    static WCHAR buff[GAI_STRERROR_BUFFER_SIZE + 1];

    dwMsgLen = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM
                             |FORMAT_MESSAGE_IGNORE_INSERTS
                             |FORMAT_MESSAGE_MAX_WIDTH_MASK,
                              NULL,
                              ecode,
                              MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                              (LPWSTR)buff,
                              GAI_STRERROR_BUFFER_SIZE,
                              NULL);

    return buff;
}
#endif /* INCL_WINSOCK_API_PROTOTYPES */




#define NI_MAXHOST  1025  /* Max size of a fully-qualified domain name */
#define NI_MAXSERV    32  /* Max size of a service name */

/* Flags for getnameinfo() */

#define NI_NOFQDN       0x01  /* Only return nodename portion for local hosts */
#define NI_NUMERICHOST  0x02  /* Return numeric form of the host's address */
#define NI_NAMEREQD     0x04  /* Error if the host's name not in DNS */
#define NI_NUMERICSERV  0x08  /* Return numeric form of the service (port #) */
#define NI_DGRAM        0x10  /* Service is a datagram service */

/* Multicast source filter APIs from RFC 3678. */

WS2TCPIP_INLINE
int
setipv4sourcefilter(
    IN SOCKET Socket,
    IN IN_ADDR Interface,
    IN IN_ADDR Group,
    IN MULTICAST_MODE_TYPE FilterMode,
    IN ULONG SourceCount,
    IN CONST IN_ADDR *SourceList
    )
{
    int Error;
    DWORD Size, Returned;
    PIP_MSFILTER Filter;

    if (SourceCount >
        (((ULONG) (ULONG_MAX - sizeof(*Filter))) / sizeof(*SourceList))) {
        WSASetLastError(WSAENOBUFS);
        return SOCKET_ERROR;
    }

    Size = IP_MSFILTER_SIZE(SourceCount);
    Filter = (PIP_MSFILTER) HeapAlloc(GetProcessHeap(), 0, Size);
    if (Filter == NULL) {
        WSASetLastError(WSAENOBUFS);
        return SOCKET_ERROR;
    }

    Filter->imsf_multiaddr = Group;
    Filter->imsf_interface = Interface;
    Filter->imsf_fmode = FilterMode;
    Filter->imsf_numsrc = SourceCount;
    if (SourceCount > 0) {
        CopyMemory(Filter->imsf_slist, SourceList,
                   SourceCount * sizeof(*SourceList));
    }

    Error = WSAIoctl(Socket, SIOCSIPMSFILTER, Filter, Size, NULL, 0,
                     &Returned, NULL, NULL);

    HeapFree(GetProcessHeap(), 0, Filter);

    return Error;
}

WS2TCPIP_INLINE
int
getipv4sourcefilter(
    IN SOCKET Socket,
    IN IN_ADDR Interface,
    IN IN_ADDR Group,
    OUT MULTICAST_MODE_TYPE *FilterMode,
    IN OUT ULONG *SourceCount,
    OUT IN_ADDR *SourceList
    )
{
    int Error;
    DWORD Size, Returned;
    PIP_MSFILTER Filter;

    if (*SourceCount >
        (((ULONG) (ULONG_MAX - sizeof(*Filter))) / sizeof(*SourceList))) {
        WSASetLastError(WSAENOBUFS);
        return SOCKET_ERROR;
    }

    Size = IP_MSFILTER_SIZE(*SourceCount);
    Filter = (PIP_MSFILTER) HeapAlloc(GetProcessHeap(), 0, Size);
    if (Filter == NULL) {
        WSASetLastError(WSAENOBUFS);
        return SOCKET_ERROR;
    }

    Filter->imsf_multiaddr = Group;
    Filter->imsf_interface = Interface;
    Filter->imsf_numsrc = *SourceCount;

    Error = WSAIoctl(Socket, SIOCGIPMSFILTER, Filter, Size, Filter, Size,
                     &Returned, NULL, NULL);

    if (Error == 0) {
        if (*SourceCount > 0) {
            CopyMemory(SourceList, Filter->imsf_slist,
                       *SourceCount * sizeof(*SourceList));
            *SourceCount = Filter->imsf_numsrc;
        }
        *FilterMode = Filter->imsf_fmode;
    }

    HeapFree(GetProcessHeap(), 0, Filter);

    return Error;
}

#if (NTDDI_VERSION >= NTDDI_WINXP)
WS2TCPIP_INLINE
int
setsourcefilter(
    IN SOCKET Socket,
    IN ULONG Interface,
    IN CONST SOCKADDR *Group,
    IN int GroupLength,
    IN MULTICAST_MODE_TYPE FilterMode,
    IN ULONG SourceCount,
    IN CONST SOCKADDR_STORAGE *SourceList
    )
{
    int Error;
    DWORD Size, Returned;
    PGROUP_FILTER Filter;

    if (SourceCount >=
        (((ULONG) (ULONG_MAX - sizeof(*Filter))) / sizeof(*SourceList))) {
        WSASetLastError(WSAENOBUFS);
        return SOCKET_ERROR;
    }

    Size = GROUP_FILTER_SIZE(SourceCount);
    Filter = (PGROUP_FILTER) HeapAlloc(GetProcessHeap(), 0, Size);
    if (Filter == NULL) {
        WSASetLastError(WSAENOBUFS);
        return SOCKET_ERROR;
    }

    Filter->gf_interface = Interface;
    ZeroMemory(&Filter->gf_group, sizeof(Filter->gf_group));
    CopyMemory(&Filter->gf_group, Group, GroupLength);
    Filter->gf_fmode = FilterMode;
    Filter->gf_numsrc = SourceCount;
    if (SourceCount > 0) {
        CopyMemory(Filter->gf_slist, SourceList,
                   SourceCount * sizeof(*SourceList));
    }

    Error = WSAIoctl(Socket, SIOCSMSFILTER, Filter, Size, NULL, 0,
                     &Returned, NULL, NULL);

    HeapFree(GetProcessHeap(), 0, Filter);

    return Error;
}

WS2TCPIP_INLINE
int
getsourcefilter(
    IN SOCKET Socket,
    IN ULONG Interface,
    IN CONST SOCKADDR *Group,
    IN int GroupLength,
    OUT MULTICAST_MODE_TYPE *FilterMode,
    IN OUT ULONG *SourceCount,
    OUT SOCKADDR_STORAGE *SourceList
    )
{
    int Error;
    DWORD Size, Returned;
    PGROUP_FILTER Filter;

    if (*SourceCount >
        (((ULONG) (ULONG_MAX - sizeof(*Filter))) / sizeof(*SourceList))) {
        WSASetLastError(WSAENOBUFS);
        return SOCKET_ERROR;
    }

    Size = GROUP_FILTER_SIZE(*SourceCount);
    Filter = (PGROUP_FILTER) HeapAlloc(GetProcessHeap(), 0, Size);
    if (Filter == NULL) {
        WSASetLastError(WSAENOBUFS);
        return SOCKET_ERROR;
    }

    Filter->gf_interface = Interface;
    ZeroMemory(&Filter->gf_group, sizeof(Filter->gf_group));
    CopyMemory(&Filter->gf_group, Group, GroupLength);
    Filter->gf_numsrc = *SourceCount;

    Error = WSAIoctl(Socket, SIOCGMSFILTER, Filter, Size, Filter, Size,
                     &Returned, NULL, NULL);

    if (Error == 0) {
        if (*SourceCount > 0) {
            CopyMemory(SourceList, Filter->gf_slist,
                       *SourceCount * sizeof(*SourceList));
            *SourceCount = Filter->gf_numsrc;
        }
        *FilterMode = Filter->gf_fmode;
    }

    HeapFree(GetProcessHeap(), 0, Filter);

    return Error;
}
#endif

#if (_WIN32_WINNT >= 0x0600)
#ifdef _SECURE_SOCKET_TYPES_DEFINED_

//
// Secure socket API definitions
//

WINSOCK_API_LINKAGE
INT
WSAAPI
WSASetSocketSecurity (
   __in SOCKET Socket,
   __in_bcount_opt(SecuritySettingsLen) const SOCKET_SECURITY_SETTINGS* SecuritySettings,
   __in ULONG SecuritySettingsLen,
   __in_opt LPWSAOVERLAPPED Overlapped,
   __in_opt LPWSAOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine
);

WINSOCK_API_LINKAGE
INT
WSAAPI
WSAQuerySocketSecurity (
   __in SOCKET Socket,
   __in_bcount_opt(SecurityQueryTemplateLen) const SOCKET_SECURITY_QUERY_TEMPLATE* SecurityQueryTemplate,
   __in ULONG SecurityQueryTemplateLen,
   __out_bcount_part_opt(*SecurityQueryInfoLen, *SecurityQueryInfoLen) SOCKET_SECURITY_QUERY_INFO* SecurityQueryInfo,
   __inout ULONG* SecurityQueryInfoLen,
   __in_opt LPWSAOVERLAPPED Overlapped,
   __in_opt LPWSAOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine
);

WINSOCK_API_LINKAGE
INT
WSAAPI
WSASetSocketPeerTargetName (
   __in SOCKET Socket,
   __in_bcount(PeerTargetNameLen) const SOCKET_PEER_TARGET_NAME* PeerTargetName,
   __in ULONG PeerTargetNameLen,
   __in_opt LPWSAOVERLAPPED Overlapped,
   __in_opt LPWSAOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine
);

WINSOCK_API_LINKAGE
INT
WSAAPI
WSADeleteSocketPeerTargetName (
   __in SOCKET Socket,
   __in_bcount(PeerAddrLen) const struct sockaddr* PeerAddr,
   __in ULONG PeerAddrLen,
   __in_opt LPWSAOVERLAPPED Overlapped,
   __in_opt LPWSAOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine
);

WINSOCK_API_LINKAGE
INT
WSAAPI
WSAImpersonateSocketPeer (
   __in SOCKET Socket,
   __in_bcount_opt(PeerAddrLen) const struct sockaddr* PeerAddr,
   __in ULONG PeerAddrLen
);

WINSOCK_API_LINKAGE
INT
WSAAPI
WSARevertImpersonation ();

#endif //_SECURE_SOCKET_TYPES_DEFINED_
#endif //(_WIN32_WINNT >= 0x0600)

#ifdef __cplusplus
}
#endif

//
// Unless the build environment is explicitly targeting only
// platforms that include built-in getaddrinfo() support, include
// the backwards-compatibility version of the relevant APIs.
//
#if !defined(_WIN32_WINNT) || (_WIN32_WINNT <= 0x0500)
#ifndef UNDER_CE
#include <wspiapi.h>
#endif
#endif

#endif  /* _WS2TCPIP_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\ws2ipdef.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ws2ipdef.h

Abstract:

    This file contains TCP/IP specific information for use
    by WinSock2 compatible applications.
  
   Copyright (c) Microsoft Corporation. All rights reserved.
  
    To provide the backward compatibility, all the TCP/IP
    specific definitions that were included in the WINSOCK.H
    file are now included in WINSOCK2.H file. WS2TCPIP.H
    file includes only the definitions  introduced in the
    "WinSock 2 Protocol-Specific Annex" document.
  
    Rev 0.3 Nov 13, 1995
        Rev 0.4 Dec 15, 1996

Environment:

    user mode or kernel mode

--*/

#ifndef _WS2IPDEF_
#define _WS2IPDEF_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#pragma warning(push)
#pragma warning(disable:4201)
#pragma warning(disable:4127) // conditional expression is constant

#ifdef _PREFAST_    
#pragma prefast(push)
#pragma prefast(disable: 24002, "This code requires explicit usage of IPv4 address types.")
#endif    
    
#ifndef WS2IPDEF_ASSERT
#define WS2IPDEF_ASSERT(exp) ((VOID) 0)
#endif

#ifdef _MSC_VER
#define WS2TCPIP_INLINE __inline
#else
#define WS2TCPIP_INLINE extern inline /* GNU style */
#endif
    
#include <in6addr.h>

//
// Old IPv6 socket address structure (retained for sockaddr_gen definition).
//

struct sockaddr_in6_old {
    SHORT sin6_family;          // AF_INET6.
    USHORT sin6_port;           // Transport level port number.
    ULONG sin6_flowinfo;        // IPv6 flow information.
    IN6_ADDR sin6_addr;         // IPv6 address.
};

typedef union sockaddr_gen {
    struct sockaddr Address;
    struct sockaddr_in AddressIn;
    struct sockaddr_in6_old AddressIn6;
} sockaddr_gen;

//
// Structure to keep interface specific information
//
    
typedef struct _INTERFACE_INFO {
    ULONG iiFlags;              // Interface flags.
    sockaddr_gen iiAddress;     // Interface address.
    sockaddr_gen iiBroadcastAddress; // Broadcast address.
    sockaddr_gen iiNetmask;     // Network mask.
} INTERFACE_INFO, FAR *LPINTERFACE_INFO;

//
// New structure that does not have dependency on the address size.
//

typedef struct _INTERFACE_INFO_EX {
    ULONG iiFlags;              // Interface flags.
    SOCKET_ADDRESS iiAddress;   // Interface address.
    SOCKET_ADDRESS iiBroadcastAddress; // Broadcast address.
    SOCKET_ADDRESS iiNetmask;   // Network mask.
} INTERFACE_INFO_EX, FAR *LPINTERFACE_INFO_EX;

//
// Possible flags for the  iiFlags - bitmask.
//
    
#define IFF_UP              0x00000001 // Interface is up.
#define IFF_BROADCAST       0x00000002 // Broadcast is  supported.
#define IFF_LOOPBACK        0x00000004 // This is loopback interface.
#define IFF_POINTTOPOINT    0x00000008 // This is point-to-point interface.
#define IFF_MULTICAST       0x00000010 // Multicast is supported.

    
//
// Options to use with [gs]etsockopt at the IPPROTO_IP level.
// The values should be consistent with the IPv6 equivalents.
//
#define IP_OPTIONS                 1 // Set/get IP options.

#ifdef UNDER_CE
#define IP_MULTICAST_IF            2 // IP multicast interface.
#define IP_MULTICAST_TTL           3 // IP multicast TTL (hop limit).
#define IP_MULTICAST_LOOP          4 // IP multicast loopback.
#define IP_ADD_MEMBERSHIP          5 // Add an IP group membership.
#define IP_DROP_MEMBERSHIP         6 // Drop an IP group membership.
#define IP_TTL                     7 // IP TTL (hop limit).
#define IP_TOS                     8 // IP type of service.
#define IP_HDRINCL                 9 // Header is included with data.
#define IP_DONTFRAGMENT           14 // Don't fragment IP datagrams.

#else
#define IP_HDRINCL                 2 // Header is included with data.
#define IP_TOS                     3 // IP type of service.
#define IP_TTL                     4 // IP TTL (hop limit).

#define IP_MULTICAST_IF            9 // IP multicast interface.
#define IP_MULTICAST_TTL          10 // IP multicast TTL (hop limit).
#define IP_MULTICAST_LOOP         11 // IP multicast loopback.
#define IP_ADD_MEMBERSHIP         12 // Add an IP group membership.
#define IP_DROP_MEMBERSHIP        13 // Drop an IP group membership.
#define IP_DONTFRAGMENT           14 // Don't fragment IP datagrams.

#endif

#if 0
#define IP_HDRINCL                 2 // Header is included with data.
#define IP_TOS                     3 // IP type of service.
#define IP_TTL                     4 // IP TTL (hop limit).
#define IP_MULTICAST_IF            9 // IP multicast interface.
#define IP_MULTICAST_TTL          10 // IP multicast TTL (hop limit).
#define IP_MULTICAST_LOOP         11 // IP multicast loopback.
#define IP_ADD_MEMBERSHIP         12 // Add an IP group membership.
#define IP_DROP_MEMBERSHIP        13 // Drop an IP group membership.
#define IP_DONTFRAGMENT           14 // Don't fragment IP datagrams.
#endif
#define IP_ADD_SOURCE_MEMBERSHIP  15 // Join IP group/source.
#define IP_DROP_SOURCE_MEMBERSHIP 16 // Leave IP group/source.
#define IP_BLOCK_SOURCE           17 // Block IP group/source.
#define IP_UNBLOCK_SOURCE         18 // Unblock IP group/source.
#define IP_PKTINFO                19 // Receive packet information.
#define IP_HOPLIMIT               21 // Receive packet hop limit.
#define IP_RECEIVE_BROADCAST      22 // Allow/block broadcast reception.
#define IP_RECVIF                 24 // Receive arrival interface.
#define IP_RECVDSTADDR            25 // Receive destination address.
#define IP_IFLIST                 28 // Enable/Disable an interface list.
#define IP_ADD_IFLIST             29 // Add an interface list entry.
#define IP_DEL_IFLIST             30 // Delete an interface list entry.
#define IP_UNICAST_IF             31 // IP unicast interface.
#define IP_RTHDR                  32 // Set/get IPv6 routing header.
#define IP_RECVRTHDR              38 // Receive the routing header.


#define IP_UNSPECIFIED_TYPE_OF_SERVICE -1

#define IPV6_ADDRESS_BITS RTL_BITS_OF(IN6_ADDR)

//
// IPv6 socket address structure, RFC 3493.
//

//
// NB: The LH version of sockaddr_in6 has the struct tag sockaddr_in6 rather
// than sockaddr_in6_lh.  This is to make sure that standard sockets apps
// that conform to RFC 2553 (Basic Socket Interface Extensions for IPv6).
//
typedef struct sockaddr_in6 {
    ADDRESS_FAMILY sin6_family; // AF_INET6.
    USHORT sin6_port;           // Transport level port number.
    ULONG  sin6_flowinfo;       // IPv6 flow information.
    IN6_ADDR sin6_addr;         // IPv6 address.
    union {
        ULONG sin6_scope_id;     // Set of interfaces for a scope.
        SCOPE_ID sin6_scope_struct; 
    };
} SOCKADDR_IN6_LH, *PSOCKADDR_IN6_LH, FAR *LPSOCKADDR_IN6_LH;

typedef struct sockaddr_in6_w2ksp1 {
    short   sin6_family;        /* AF_INET6 */
    USHORT sin6_port;          /* Transport level port number */
    ULONG  sin6_flowinfo;      /* IPv6 flow information */
    struct in6_addr sin6_addr;  /* IPv6 address */
    ULONG sin6_scope_id;       /* set of interfaces for a scope */
} SOCKADDR_IN6_W2KSP1, *PSOCKADDR_IN6_W2KSP1, FAR *LPSOCKADDR_IN6_W2KSP1;

#if (NTDDI_VERSION >= NTDDI_LONGHORN)
typedef SOCKADDR_IN6_LH SOCKADDR_IN6;
typedef SOCKADDR_IN6_LH *PSOCKADDR_IN6;
typedef SOCKADDR_IN6_LH FAR *LPSOCKADDR_IN6;
#elif(NTDDI_VERSION >= NTDDI_WIN2KSP1)
typedef SOCKADDR_IN6_W2KSP1 SOCKADDR_IN6;
typedef SOCKADDR_IN6_W2KSP1 *PSOCKADDR_IN6;
typedef SOCKADDR_IN6_W2KSP1 FAR *LPSOCKADDR_IN6;
#else
typedef SOCKADDR_IN6_LH SOCKADDR_IN6;
typedef SOCKADDR_IN6_LH *PSOCKADDR_IN6;
typedef SOCKADDR_IN6_LH FAR *LPSOCKADDR_IN6;
#endif

typedef union _SOCKADDR_INET {
    SOCKADDR_IN Ipv4;
    SOCKADDR_IN6 Ipv6;
    ADDRESS_FAMILY si_family;    
} SOCKADDR_INET, *PSOCKADDR_INET;

//
// Structure to hold a pair of source, destination addresses.
//
typedef struct _sockaddr_in6_pair
{
    PSOCKADDR_IN6 SourceAddress;
    PSOCKADDR_IN6 DestinationAddress;
} SOCKADDR_IN6_PAIR, *PSOCKADDR_IN6_PAIR;

//
// Macro that works for both IPv4 and IPv6
//
#define SS_PORT(ssp) (((PSOCKADDR_IN)(ssp))->sin_port)

#if defined(UNDER_CE) || (NTDDI_VERSION >= NTDDI_WIN2KSP1)
//
// N.B. These addresses are in network byte order.
//

#define IN6ADDR_ANY_INIT { 0 }

#define IN6ADDR_LOOPBACK_INIT { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 }

#define IN6ADDR_ALLNODESONNODE_INIT { \
    0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 \
}

#define IN6ADDR_ALLNODESONLINK_INIT { \
    0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 \
}

#define IN6ADDR_ALLROUTERSONLINK_INIT { \
    0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02 \
}

#define IN6ADDR_ALLMLDV2ROUTERSONLINK_INIT { \
    0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16 \
}

#define IN6ADDR_TEREDOINITIALLINKLOCALADDRESS_INIT { \
    0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
    0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe \
}

#define IN6ADDR_LINKLOCALPREFIX_INIT { 0xfe, 0x80, }

#define IN6ADDR_MULTICASTPREFIX_INIT { 0xff, 0x00, }

#define IN6ADDR_SOLICITEDNODEMULTICASTPREFIX_INIT { \
    0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
    0x00, 0x00, 0x00, 0x01, 0xff, \
}

#define IN6ADDR_V4MAPPEDPREFIX_INIT { \
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
    0x00, 0x00, 0xff, 0xff, \
}

#define IN6ADDR_6TO4PREFIX_INIT { 0x20, 0x02, }

#define IN6ADDR_TEREDOPREFIX_INIT { 0x20, 0x01, 0x00, 0x00, }

#define IN6ADDR_LINKLOCALPREFIX_LENGTH 64

#define IN6ADDR_MULTICASTPREFIX_LENGTH 8

#define IN6ADDR_SOLICITEDNODEMULTICASTPREFIX_LENGTH 104

#define IN6ADDR_V4MAPPEDPREFIX_LENGTH 96

#define IN6ADDR_6TO4PREFIX_LENGTH 16

#define IN6ADDR_TEREDOPREFIX_LENGTH 32

#ifdef __cplusplus
extern "C" {
#endif

//
// N.B. These addresses are in network byte order.
//
extern CONST SCOPE_ID scopeid_unspecified;

extern CONST IN_ADDR in4addr_any;
extern CONST IN_ADDR in4addr_loopback;
extern CONST IN_ADDR in4addr_broadcast;
extern CONST IN_ADDR in4addr_allnodesonlink;
extern CONST IN_ADDR in4addr_allroutersonlink;
extern CONST IN_ADDR in4addr_alligmpv3routersonlink;
extern CONST IN_ADDR in4addr_allteredohostsonlink;
extern CONST IN_ADDR in4addr_linklocalprefix;
extern CONST IN_ADDR in4addr_multicastprefix;

extern CONST IN6_ADDR in6addr_any;
extern CONST IN6_ADDR in6addr_loopback;
extern CONST IN6_ADDR in6addr_allnodesonnode;
extern CONST IN6_ADDR in6addr_allnodesonlink;
extern CONST IN6_ADDR in6addr_allroutersonlink;
extern CONST IN6_ADDR in6addr_allmldv2routersonlink;
extern CONST IN6_ADDR in6addr_teredoinitiallinklocaladdress;
extern CONST IN6_ADDR in6addr_linklocalprefix;
extern CONST IN6_ADDR in6addr_multicastprefix;
extern CONST IN6_ADDR in6addr_solicitednodemulticastprefix;
extern CONST IN6_ADDR in6addr_v4mappedprefix;
extern CONST IN6_ADDR in6addr_6to4prefix;
extern CONST IN6_ADDR in6addr_teredoprefix;

    

#ifdef __cplusplus
}
#endif

#ifndef __midl

WS2TCPIP_INLINE
BOOLEAN
IN6_ADDR_EQUAL(CONST IN6_ADDR *x, CONST IN6_ADDR *y)
{
    __int64 UNALIGNED *a;
    __int64 UNALIGNED *b;

    a = (__int64 UNALIGNED *)x;
    b = (__int64 UNALIGNED *)y;

    return (BOOLEAN)((a[1] == b[1]) && (a[0] == b[0]));
}

//
// RFC 3542 uses IN6_ARE_ADDR_EQUAL().
//
#define IN6_ARE_ADDR_EQUAL IN6_ADDR_EQUAL

WS2TCPIP_INLINE
BOOLEAN
IN6_IS_ADDR_UNSPECIFIED(CONST IN6_ADDR *a)
{
    //
    // We can't use the in6addr_any variable, since that would
    // require existing callers to link with a specific library.
    //
    return (BOOLEAN)((a->s6_words[0] == 0) &&
                     (a->s6_words[1] == 0) &&
                     (a->s6_words[2] == 0) &&
                     (a->s6_words[3] == 0) &&
                     (a->s6_words[4] == 0) &&
                     (a->s6_words[5] == 0) &&
                     (a->s6_words[6] == 0) &&
                     (a->s6_words[7] == 0));
}

WS2TCPIP_INLINE
BOOLEAN
IN6_IS_ADDR_LOOPBACK(CONST IN6_ADDR *a)
{
    //
    // We can't use the in6addr_loopback variable, since that would
    // require existing callers to link with a specific library.
    //
    return (BOOLEAN)((a->s6_words[0] == 0) &&
                     (a->s6_words[1] == 0) &&
                     (a->s6_words[2] == 0) &&
                     (a->s6_words[3] == 0) &&
                     (a->s6_words[4] == 0) &&
                     (a->s6_words[5] == 0) &&
                     (a->s6_words[6] == 0) &&
                     (a->s6_words[7] == 0x0100));
}

WS2TCPIP_INLINE
BOOLEAN
IN6_IS_ADDR_MULTICAST(CONST IN6_ADDR *a)
{
    return (BOOLEAN)(a->s6_bytes[0] == 0xff);
}

//
//  Does the address have a format prefix
//  that indicates it uses EUI-64 interface identifiers?
//
WS2TCPIP_INLINE
BOOLEAN
IN6_IS_ADDR_EUI64(CONST IN6_ADDR *a)
{
    //
    // Format prefixes 001 through 111, except for multicast.
    //
    return (BOOLEAN)(((a->s6_bytes[0] & 0xe0) != 0) &&
                     !IN6_IS_ADDR_MULTICAST(a));
}

//
//  Is this the subnet router anycast address?
//  See RFC 2373.
//
WS2TCPIP_INLINE
BOOLEAN
IN6_IS_ADDR_SUBNET_ROUTER_ANYCAST(CONST IN6_ADDR *a)
{
    return (BOOLEAN)(IN6_IS_ADDR_EUI64(a) &&
                     (a->s6_words[4] == 0) &&
                     (a->s6_words[5] == 0) &&
                     (a->s6_words[6] == 0) &&
                     (a->s6_words[7] == 0));
}

//
//  Is this a subnet reserved anycast address?
//  See RFC 2526. It talks about non-EUI-64
//  addresses as well, but IMHO that part
//  of the RFC doesn't make sense. For example,
//  it shouldn't apply to multicast or v4-compatible
//  addresses.
//
WS2TCPIP_INLINE
BOOLEAN
IN6_IS_ADDR_SUBNET_RESERVED_ANYCAST(CONST IN6_ADDR *a)
{
    return (BOOLEAN)(IN6_IS_ADDR_EUI64(a) &&
                     (a->s6_words[4] == 0xfffd) &&
                     (a->s6_words[5] == 0xffff) &&
                     (a->s6_words[6] == 0xffff) &&
                     ((a->s6_words[7] & 0x80ff) == 0x80ff));
}

//
//  As best we can tell from simple inspection,
//  is this an anycast address?
//
WS2TCPIP_INLINE
BOOLEAN
IN6_IS_ADDR_ANYCAST(CONST IN6_ADDR *a)
{
    return (IN6_IS_ADDR_SUBNET_RESERVED_ANYCAST(a) || 
            IN6_IS_ADDR_SUBNET_ROUTER_ANYCAST(a));
}

WS2TCPIP_INLINE
BOOLEAN
IN6_IS_ADDR_LINKLOCAL(CONST IN6_ADDR *a)
{
    return (BOOLEAN)((a->s6_bytes[0] == 0xfe) && 
                     ((a->s6_bytes[1] & 0xc0) == 0x80));
}

WS2TCPIP_INLINE
BOOLEAN
IN6_IS_ADDR_SITELOCAL(CONST IN6_ADDR *a)
{
    return (BOOLEAN)((a->s6_bytes[0] == 0xfe) && 
                     ((a->s6_bytes[1] & 0xc0) == 0xc0));
}

WS2TCPIP_INLINE
BOOLEAN
IN6_IS_ADDR_GLOBAL(CONST IN6_ADDR *a)
{
    //
    // Check the format prefix and exclude addresses
    // whose high 4 bits are all zero or all one.
    // This is a cheap way of excluding v4-compatible,
    // v4-mapped, loopback, multicast, link-local, site-local.
    //
    ULONG High = (a->s6_bytes[0] & 0xf0);
    return (BOOLEAN)((High != 0) && (High != 0xf0));
}

WS2TCPIP_INLINE
BOOLEAN
IN6_IS_ADDR_V4MAPPED(CONST IN6_ADDR *a)
{
    return (BOOLEAN)((a->s6_words[0] == 0) &&
                     (a->s6_words[1] == 0) &&
                     (a->s6_words[2] == 0) &&
                     (a->s6_words[3] == 0) &&
                     (a->s6_words[4] == 0) &&
                     (a->s6_words[5] == 0xffff));
}

WS2TCPIP_INLINE
BOOLEAN
IN6_IS_ADDR_V4COMPAT(CONST IN6_ADDR *a)
{
    return (BOOLEAN)((a->s6_words[0] == 0) &&
                     (a->s6_words[1] == 0) &&
                     (a->s6_words[2] == 0) &&
                     (a->s6_words[3] == 0) &&
                     (a->s6_words[4] == 0) &&
                     (a->s6_words[5] == 0) &&
                     !((a->s6_words[6] == 0) &&
                       (a->s6_addr[14] == 0) &&
                       ((a->s6_addr[15] == 0) || (a->s6_addr[15] == 1))));
}

WS2TCPIP_INLINE
BOOLEAN
IN6_IS_ADDR_V4TRANSLATED(CONST IN6_ADDR *a)
{
    return (BOOLEAN)((a->s6_words[0] == 0) &&
                     (a->s6_words[1] == 0) &&
                     (a->s6_words[2] == 0) &&
                     (a->s6_words[3] == 0) &&
                     (a->s6_words[4] == 0xffff) &&
                     (a->s6_words[5] == 0));
}

WS2TCPIP_INLINE
BOOLEAN
IN6_IS_ADDR_MC_NODELOCAL(CONST IN6_ADDR *a)
{
    return (BOOLEAN)(IN6_IS_ADDR_MULTICAST(a) &&
                     ((a->s6_bytes[1] & 0xf) == 1));
}

WS2TCPIP_INLINE
BOOLEAN
IN6_IS_ADDR_MC_LINKLOCAL(CONST IN6_ADDR *a)
{
    return (BOOLEAN)(IN6_IS_ADDR_MULTICAST(a) &&
                     ((a->s6_bytes[1] & 0xf) == 2));
}

WS2TCPIP_INLINE
BOOLEAN
IN6_IS_ADDR_MC_SITELOCAL(CONST IN6_ADDR *a)
{
    return (BOOLEAN)(IN6_IS_ADDR_MULTICAST(a) &&
                     ((a->s6_bytes[1] & 0xf) == 5));
}

WS2TCPIP_INLINE
BOOLEAN
IN6_IS_ADDR_MC_ORGLOCAL(CONST IN6_ADDR *a)
{
    return (BOOLEAN)(IN6_IS_ADDR_MULTICAST(a) &&
                     ((a->s6_bytes[1] & 0xf) == 8));
}

WS2TCPIP_INLINE
BOOLEAN
IN6_IS_ADDR_MC_GLOBAL(CONST IN6_ADDR *a)
{
    return (BOOLEAN)(IN6_IS_ADDR_MULTICAST(a) &&
                     ((a->s6_bytes[1] & 0xf) == 0xe));
}

WS2TCPIP_INLINE 
VOID
IN6_SET_ADDR_UNSPECIFIED(PIN6_ADDR a)
{
    //
    // We can't use the in6addr_any variable, since that would
    // require existing callers to link with a specific library.
    //
    memset(a->s6_bytes, 0, sizeof(IN6_ADDR));
}

WS2TCPIP_INLINE 
VOID
IN6_SET_ADDR_LOOPBACK(PIN6_ADDR a)
{
    //
    // We can't use the in6addr_loopback variable, since that would
    // require existing callers to link with a specific library.
    //
    memset(a->s6_bytes, 0, sizeof(IN6_ADDR));
    a->s6_bytes[15] = 1;
}

WS2TCPIP_INLINE
VOID
IN6ADDR_SETANY(PSOCKADDR_IN6 a)
{
    a->sin6_family = AF_INET6;
    a->sin6_port = 0;
    a->sin6_flowinfo = 0;
    IN6_SET_ADDR_UNSPECIFIED(&a->sin6_addr);
    a->sin6_scope_id = 0;
}

WS2TCPIP_INLINE
VOID
IN6ADDR_SETLOOPBACK(PSOCKADDR_IN6 a)
{
    a->sin6_family = AF_INET6;
    a->sin6_port = 0;
    a->sin6_flowinfo = 0;
    IN6_SET_ADDR_LOOPBACK(&a->sin6_addr);
    a->sin6_scope_id = 0;
}

WS2TCPIP_INLINE
BOOLEAN
IN6ADDR_ISANY(CONST SOCKADDR_IN6 *a)
{
    WS2IPDEF_ASSERT(a->sin6_family == AF_INET6);
    return IN6_IS_ADDR_UNSPECIFIED(&a->sin6_addr);
}

WS2TCPIP_INLINE
BOOLEAN
IN6ADDR_ISLOOPBACK(CONST SOCKADDR_IN6 *a)
{
    WS2IPDEF_ASSERT(a->sin6_family == AF_INET6);
    return IN6_IS_ADDR_LOOPBACK(&a->sin6_addr);
}

WS2TCPIP_INLINE
BOOLEAN
IN6ADDR_ISEQUAL(CONST SOCKADDR_IN6 *a, CONST SOCKADDR_IN6 *b)
{
    WS2IPDEF_ASSERT(a->sin6_family == AF_INET6);
    return (BOOLEAN)(a->sin6_scope_id == b->sin6_scope_id &&
                     IN6_ADDR_EQUAL(&a->sin6_addr, &b->sin6_addr));
}

WS2TCPIP_INLINE
BOOLEAN
IN6ADDR_ISUNSPECIFIED(CONST SOCKADDR_IN6 *a)
{
    WS2IPDEF_ASSERT(a->sin6_family == AF_INET6);
    return (BOOLEAN)(a->sin6_scope_id == 0 &&
                     IN6_IS_ADDR_UNSPECIFIED(&a->sin6_addr));
}

#endif // __midl

#endif // (NTDDI_VERSION >= NTDDI_WIN2KSP1) 

//
// TCP/IP specific Ioctl codes.
//
#define SIO_GET_INTERFACE_LIST     _IOR('t', 127, ULONG)
#define SIO_GET_INTERFACE_LIST_EX  _IOR('t', 126, ULONG)
#define SIO_SET_MULTICAST_FILTER   _IOW('t', 125, ULONG)
#define SIO_GET_MULTICAST_FILTER   _IOW('t', 124 | IOC_IN, ULONG)
#define SIOCSIPMSFILTER            SIO_SET_MULTICAST_FILTER
#define SIOCGIPMSFILTER            SIO_GET_MULTICAST_FILTER

//
// Protocol independent ioctls for setting and retrieving multicast filters. 
//
#define SIOCSMSFILTER     _IOW('t', 126, ULONG)
#define SIOCGMSFILTER     _IOW('t', 127 | IOC_IN, ULONG)

//
// Protocol independent multicast source filter options.
//
#define MCAST_JOIN_GROUP            41	// Join all sources for a group.
#define MCAST_LEAVE_GROUP           42  // Drop all sources for a group.
#define MCAST_BLOCK_SOURCE          43	// Block IP group/source.
#define MCAST_UNBLOCK_SOURCE        44	// Unblock IP group/source.
#define MCAST_JOIN_SOURCE_GROUP     45	// Join IP group/source.
#define MCAST_LEAVE_SOURCE_GROUP    46	// Leave IP group/source.

//
// Definitions of MCAST_INCLUDE and MCAST_EXCLUDE for multicast source filter. 
//
typedef enum {
    MCAST_INCLUDE = 0,
    MCAST_EXCLUDE 
} MULTICAST_MODE_TYPE;

//
// Structure for IP_MREQ (used by IP_ADD_MEMBERSHIP and IP_DROP_MEMBERSHIP). 
//
typedef struct ip_mreq {
    IN_ADDR imr_multiaddr;  // IP multicast address of group.
    IN_ADDR imr_interface;  // Local IP address of interface.
} IP_MREQ, *PIP_MREQ;

//
// Structure for IP_MREQ_SOURCE (used by IP_BLOCK_SOURCE, IP_UNBLOCK_SOURCE
// etc.). 
//
typedef struct ip_mreq_source {
    IN_ADDR imr_multiaddr;  // IP multicast address of group.
    IN_ADDR imr_sourceaddr; // IP address of source.
    IN_ADDR imr_interface;  // Local IP address of interface.
} IP_MREQ_SOURCE, *PIP_MREQ_SOURCE;

//
// Structure for IP_MSFILTER (used by SIOCSIPMSFILTER and SIOCGIPMSFILTER). 
// 
typedef struct ip_msfilter {
    IN_ADDR imsf_multiaddr;  // IP multicast address of group.
    IN_ADDR imsf_interface;  // Local IP address of interface.
    MULTICAST_MODE_TYPE imsf_fmode;        // Filter mode.
    ULONG imsf_numsrc;       // Number of sources in src_list.
    IN_ADDR imsf_slist[1];   // Start of source list.
} IP_MSFILTER, *PIP_MSFILTER;

#define IP_MSFILTER_SIZE(NumSources) \
    (sizeof(IP_MSFILTER) - sizeof(IN_ADDR) + (NumSources) * sizeof(IN_ADDR))

//
// Options to use with [gs]etsockopt at the IPPROTO_IPV6 level.
// These are specified in RFCs 3493 and 3542.
// The values should be consistent with the IPv6 equivalents.
//
#define IPV6_HOPOPTS           1 // Set/get IPv6 hop-by-hop options.
#define IPV6_HDRINCL           2 // Header is included with data.
#define IPV6_UNICAST_HOPS      4 // IP unicast hop limit.
#define IPV6_MULTICAST_IF      9 // IP multicast interface.
#define IPV6_MULTICAST_HOPS   10 // IP multicast hop limit.
#define IPV6_MULTICAST_LOOP   11 // IP multicast loopback.
#define IPV6_ADD_MEMBERSHIP   12 // Add an IP group membership.
#define IPV6_JOIN_GROUP       IPV6_ADD_MEMBERSHIP
#define IPV6_DROP_MEMBERSHIP  13 // Drop an IP group membership.
#define IPV6_LEAVE_GROUP      IPV6_DROP_MEMBERSHIP
#define IPV6_DONTFRAG         14 // Don't fragment IP datagrams.
#define IPV6_PKTINFO          19 // Receive packet information.
#define IPV6_HOPLIMIT         21 // Receive packet hop limit.
#define IPV6_PROTECTION_LEVEL 23 // Set/get IPv6 protection level.
#define IPV6_RECVIF           24 // Receive arrival interface.
#define IPV6_RECVDSTADDR      25 // Receive destination address.
#define IPV6_CHECKSUM         26 // Offset to checksum for raw IP socket send.
#define IPV6_V6ONLY           27 // Treat wildcard bind as AF_INET6-only.
#define IPV6_IFLIST           28 // Enable/Disable an interface list.
#define IPV6_ADD_IFLIST       29 // Add an interface list entry.
#define IPV6_DEL_IFLIST       30 // Delete an interface list entry.
#define IPV6_UNICAST_IF       31 // IP unicast interface.
#define IPV6_RTHDR            32 // Set/get IPv6 routing header.
#define IPV6_RECVRTHDR        38 // Receive the routing header.

#define IP_UNSPECIFIED_HOP_LIMIT -1

#ifdef UNDER_CE

/* differential service traffic types */
typedef enum _DSCP_TRAFFIC_TYPE 
{
    DSCPTypeNotSet        = 0,
    DSCPBestEffort        = 1,
    DSCPBackground        = 2,
    DSCPExcellentEffort   = 3,
    DSCPVideo             = 4,
    DSCPAudio             = 5,
    DSCPControl           = 6,
    NumDSCPTrafficTypes   = 6
} DSCP_TRAFFIC_TYPE;

#define IP_DSCP_TRAFFIC_TYPE    100 /* differential services */
#define IP_RELOAD_DSCP_MAPPINGS 101
#endif

//
// Values of IPV6_PROTECTION_LEVEL.
//
#define PROTECTION_LEVEL_UNRESTRICTED   10 // For peer-to-peer apps. 
#define PROTECTION_LEVEL_EDGERESTRICTED 20 // Same as unrestricted. Except for
                                           // Teredo.
#define PROTECTION_LEVEL_RESTRICTED     30 // For Intranet apps.

#if (NTDDI_VERSION < NTDDI_LONGHORN)
#define PROTECTION_LEVEL_DEFAULT        PROTECTION_LEVEL_EDGERESTRICTED
#else
#define PROTECTION_LEVEL_DEFAULT        ((UINT)-1)
#endif
//
// Structure for IPV6_JOIN_GROUP and IPV6_LEAVE_GROUP (also,
// IPV6_ADD_MEMBERSHIP and IPV6_DROP_MEMBERSHIP).
//
typedef struct ipv6_mreq {
    IN6_ADDR ipv6mr_multiaddr;  // IPv6 multicast address.
    ULONG ipv6mr_interface;     // Interface index.
} IPV6_MREQ, *PIPV6_MREQ;

#if (NTDDI_VERSION >= NTDDI_WINXP)
//
// Structure for GROUP_REQ used by protocol independent source filters
// (MCAST_JOIN_GROUP and MCAST_LEAVE_GROUP). 
//
typedef struct group_req {
    ULONG gr_interface;         // Interface index.
    SOCKADDR_STORAGE gr_group;  // Multicast address.
} GROUP_REQ, *PGROUP_REQ;

//
// Structure for GROUP_SOURCE_REQ used by protocol independent source filters
// (MCAST_JOIN_SOURCE_GROUP, MCAST_LEAVE_SOURCE_GROUP etc.).
//
typedef struct group_source_req {
    ULONG gsr_interface;        // Interface index.
    SOCKADDR_STORAGE gsr_group; // Group address.
    SOCKADDR_STORAGE gsr_source; // Source address.
} GROUP_SOURCE_REQ, *PGROUP_SOURCE_REQ;

//
// Structure for GROUP_FILTER used by protocol independent source filters
// (SIOCSMSFILTER and SIOCGMSFILTER).
//
typedef struct group_filter {
    ULONG gf_interface;         // Interface index.
    SOCKADDR_STORAGE gf_group;  // Multicast address.
    MULTICAST_MODE_TYPE gf_fmode; // Filter mode.
    ULONG gf_numsrc;            // Number of sources.
    SOCKADDR_STORAGE gf_slist[1]; // Source address.
} GROUP_FILTER, *PGROUP_FILTER;

#define GROUP_FILTER_SIZE(numsrc) \
   (sizeof(GROUP_FILTER) - sizeof(SOCKADDR_STORAGE) \
   + (numsrc) * sizeof(SOCKADDR_STORAGE))
#endif

//
// Structure for IP_PKTINFO option.
//
typedef struct in_pktinfo {
    IN_ADDR ipi_addr;     // Source/destination IPv4 address.
    ULONG ipi_ifindex;    // Send/receive interface index.
} IN_PKTINFO, *PIN_PKTINFO;

C_ASSERT(sizeof(IN_PKTINFO) == 8);

//
// Structure for IPV6_PKTINFO option.
//
typedef struct in6_pktinfo {
    IN6_ADDR ipi6_addr;    // Source/destination IPv6 address.
    ULONG ipi6_ifindex;    // Send/receive interface index.
} IN6_PKTINFO, *PIN6_PKTINFO;

C_ASSERT(sizeof(IN6_PKTINFO) == 20);

//
// Maximum length of address literals (potentially including a port number)
// generated by any address-to-string conversion routine.  This length can
// be used when declaring buffers used with getnameinfo, WSAAddressToString,
// inet_ntoa, etc.  We just provide one define, rather than one per api,
// to avoid confusion.
//
// The totals are derived from the following data:
//  15: IPv4 address
//  45: IPv6 address including embedded IPv4 address
//  11: Scope Id
//   2: Brackets around IPv6 address when port is present
//   6: Port (including colon)
//   1: Terminating null byte
//
#define INET_ADDRSTRLEN  22
#define INET6_ADDRSTRLEN 65



//
// Options to use with [gs]etsockopt at the IPPROTO_TCP level.
// TCP_NODELAY is defined in ws2def.h for historical reasons.
//

//
// Offload preferences supported.
//
#define TCP_OFFLOAD_NO_PREFERENCE	0
#define	TCP_OFFLOAD_NOT_PREFERRED	1
#define TCP_OFFLOAD_PREFERRED		2

//      TCP_NODELAY         	 0x0001
#define TCP_EXPEDITED_1122  	 0x0002
#define TCP_KEEPALIVE       	 3
#define TCP_MAXSEG          	 4
#define TCP_MAXRT           	 5
#define TCP_STDURG          	 6
#define TCP_NOURG           	 7
#define TCP_ATMARK          	 8
#define TCP_NOSYNRETRIES    	 9
#define TCP_TIMESTAMPS      	 10
#define TCP_OFFLOAD_PREFERENCE	 11
#define TCP_CONGESTION_ALGORITHM 12
#define TCP_DELAY_FIN_ACK        13

#ifdef _PREFAST_
#pragma prefast(pop)
#endif

#pragma warning(pop)

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\ws2def.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ws2def.h

Abstract:
 
    This file contains the core definitions for the Winsock2
    specification that can be used by both user-mode and 
    kernel mode modules.

    This file is included in WINSOCK2.H. User mode applications
    should include WINSOCK2.H rather than including this file
    directly. This file can not be included by a module that also
    includes WINSOCK.H.
 
Environment:

    user mode or kernel mode

--*/

#ifndef _WS2DEF_
#define _WS2DEF_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if !defined(_WINSOCK2API_) && defined(_WINSOCKAPI_)    
#error Do not include winsock.h and ws2def.h in the same module. Instead include only winsock2.h.
#endif

#pragma warning(push)
#pragma warning(disable:4201)
#pragma warning(disable:4214) // bit field types other than int

//
// Allow Winsock components to disable PREfast errors.
//

#if defined(_PREFAST_) && defined(IPV6_PREFAST_SAFE)
#include <ipv6prefast.h>
#endif // _PREFAST_

#if(_WIN32_WINNT >= 0x0600)

#ifdef _MSC_VER
#define WS2DEF_INLINE __inline
#else
#define WS2DEF_INLINE extern inline /* GNU style */
#endif

#endif//(_WIN32_WINNT >= 0x0600)

#include <inaddr.h>

//#if(_WIN32_WINNT >= 0x0600)

//
// Address families.
//

typedef USHORT ADDRESS_FAMILY;

//#endif//(_WIN32_WINNT >= 0x0600)

//
// Although AF_UNSPEC is defined for backwards compatibility, using
// AF_UNSPEC for the "af" parameter when creating a socket is STRONGLY
// DISCOURAGED.  The interpretation of the "protocol" parameter
// depends on the actual address family chosen.  As environments grow
// to include more and more address families that use overlapping
// protocol values there is more and more chance of choosing an
// undesired address family when AF_UNSPEC is used.
//
#define AF_UNSPEC       0               // unspecified
#define AF_UNIX         1               // local to host (pipes, portals)
#define AF_INET         2               // internetwork: UDP, TCP, etc.
#define AF_IMPLINK      3               // arpanet imp addresses
#define AF_PUP          4               // pup protocols: e.g. BSP
#define AF_CHAOS        5               // mit CHAOS protocols
#define AF_NS           6               // XEROX NS protocols
#define AF_IPX          AF_NS           // IPX protocols: IPX, SPX, etc.
#define AF_ISO          7               // ISO protocols
#define AF_OSI          AF_ISO          // OSI is ISO
#define AF_ECMA         8               // european computer manufacturers
#define AF_DATAKIT      9               // datakit protocols
#define AF_CCITT        10              // CCITT protocols, X.25 etc
#define AF_SNA          11              // IBM SNA
#define AF_DECnet       12              // DECnet
#define AF_DLI          13              // Direct data link interface
#define AF_LAT          14              // LAT
#define AF_HYLINK       15              // NSC Hyperchannel
#define AF_APPLETALK    16              // AppleTalk
#define AF_NETBIOS      17              // NetBios-style addresses
#define AF_VOICEVIEW    18              // VoiceView
#define AF_FIREFOX      19              // Protocols from Firefox
#define AF_UNKNOWN1     20              // Somebody is using this!
#define AF_BAN          21              // Banyan
#define AF_ATM          22              // Native ATM Services
#define AF_INET6        23              // Internetwork Version 6
#define AF_CLUSTER      24              // Microsoft Wolfpack
#define AF_12844        25              // IEEE 1284.4 WG AF
#define AF_IRDA         26              // IrDA
#define AF_NETDES       28              // Network Designers OSI & gateway

#if(_WIN32_WINNT < 0x0501) && !defined (UNDER_CE)
#define AF_MAX          29
#else //(_WIN32_WINNT < 0x0501)

#define AF_TCNPROCESS   29
#define AF_TCNMESSAGE   30
#define AF_ICLFXBM      31

#if(_WIN32_WINNT < 0x0600) && !defined (UNDER_CE)
#define AF_MAX          32
#else //(_WIN32_WINNT < 0x0600)
#define AF_BTH          32              // Bluetooth RFCOMM/L2CAP protocols
#define AF_MAX          33
#endif //(_WIN32_WINNT < 0x0600)

#endif //(_WIN32_WINNT < 0x0501)

//
// Socket types.
//

#define SOCK_STREAM     1
#define SOCK_DGRAM      2
#define SOCK_RAW        3
#define SOCK_RDM        4
#define SOCK_SEQPACKET  5

//
// Define a level for socket I/O controls in the same numbering space as
// IPPROTO_TCP, IPPROTO_IP, etc.
//

#define SOL_SOCKET 0xffff

//
// Define socket-level options.
//

#define SO_DEBUG        0x0001      // turn on debugging info recording 
#define SO_ACCEPTCONN   0x0002      // socket has had listen()
#define SO_REUSEADDR    0x0004      // allow local address reuse
#define SO_KEEPALIVE    0x0008      // keep connections alive
#define SO_DONTROUTE    0x0010      // just use interface addresses
#define SO_BROADCAST    0x0020      // permit sending of broadcast msgs
#define SO_USELOOPBACK  0x0040      // bypass hardware when possible
#define SO_LINGER       0x0080      // linger on close if data present
#define SO_OOBINLINE    0x0100      // leave received OOB data in line

#define SO_DONTLINGER   (int)(~SO_LINGER)
#define SO_EXCLUSIVEADDRUSE \
    ((int)(~SO_REUSEADDR))          // disallow local address reuse

#define SO_SNDBUF       0x1001      // send buffer size
#define SO_RCVBUF       0x1002      // receive buffer size
#define SO_SNDLOWAT     0x1003      // send low-water mark
#define SO_RCVLOWAT     0x1004      // receive low-water mark
#define SO_SNDTIMEO     0x1005      // send timeout
#define SO_RCVTIMEO     0x1006      // receive timeout
#define SO_ERROR        0x1007      // get error status and clear
#define SO_TYPE         0x1008      // get socket type
#define SO_BSP_STATE    0x1009      // get socket 5-tuple state

#define SO_GROUP_ID     0x2001      // ID of a socket group
#define SO_GROUP_PRIORITY 0x2002    // the relative priority within a group
#define SO_MAX_MSG_SIZE 0x2003      // maximum message size

#define SO_CONDITIONAL_ACCEPT 0x3002 // enable true conditional accept:
                                    // connection is not ack-ed to the
                                    // other side until conditional
                                    // function returns CF_ACCEPT
#define SO_PAUSE_ACCEPT 0x3003      // pause accepting new connections
#define SO_COMPARTMENT_ID 0x3004    // get/set the compartment for a socket
#if (_WIN32_WINNT >= 0x0600)
#define SO_RANDOMIZE_PORT 0x3005    // randomize assignment of wildcard ports
#define SO_PORT_SCALABILITY 0x3006  // enable port scalability
#endif //(_WIN32_WINNT >= 0x0600)

//
// Base constant used for defining WSK-specific options.
//

#define WSK_SO_BASE  0x4000

//
// Options to use with [gs]etsockopt at the IPPROTO_TCP level.
//

#define TCP_NODELAY         0x0001

//
// Structure used to store most addresses.
//
typedef struct sockaddr {

#if (_WIN32_WINNT < 0x0600)
    u_short sa_family;
#else 
    ADDRESS_FAMILY sa_family;           // Address family.
#endif //(_WIN32_WINNT < 0x0600)

    CHAR sa_data[14];                   // Up to 14 bytes of direct address.
} SOCKADDR, *PSOCKADDR, FAR *LPSOCKADDR;

#ifndef __CSADDR_DEFINED__
#define __CSADDR_DEFINED__


/*
 * SockAddr Information
 */
typedef struct _SOCKET_ADDRESS {
    __field_bcount(iSockaddrLength) LPSOCKADDR lpSockaddr;
    INT iSockaddrLength;
} SOCKET_ADDRESS, *PSOCKET_ADDRESS, *LPSOCKET_ADDRESS;

/*
 * Address list returned via SIO_ADDRESS_LIST_QUERY
 */
typedef struct _SOCKET_ADDRESS_LIST {
    INT             iAddressCount;
    SOCKET_ADDRESS  Address[1];
} SOCKET_ADDRESS_LIST, *PSOCKET_ADDRESS_LIST, FAR *LPSOCKET_ADDRESS_LIST;

#if (_WIN32_WINNT >= 0x0600)

#define SIZEOF_SOCKET_ADDRESS_LIST(AddressCount) \
    (FIELD_OFFSET(SOCKET_ADDRESS_LIST, Address) + \
     AddressCount * sizeof(SOCKET_ADDRESS))

#endif //(_WIN32_WINNT >= 0x0600)

/*
 * CSAddr Information
 */
typedef struct _CSADDR_INFO {
    SOCKET_ADDRESS LocalAddr ;
    SOCKET_ADDRESS RemoteAddr ;
    INT iSocketType ;
    INT iProtocol ;
} CSADDR_INFO, *PCSADDR_INFO, FAR * LPCSADDR_INFO ;
#endif /* __CSADDR_DEFINED__ */

//
// Portable socket structure (RFC 2553).
//

//
// Desired design of maximum size and alignment.
// These are implementation specific.
//
#define _SS_MAXSIZE 128                 // Maximum size
#define _SS_ALIGNSIZE (sizeof(__int64)) // Desired alignment

//
// Definitions used for sockaddr_storage structure paddings design.
//

#if(_WIN32_WINNT >= 0x0600)
#define _SS_PAD1SIZE (_SS_ALIGNSIZE - sizeof(USHORT))
#define _SS_PAD2SIZE (_SS_MAXSIZE - (sizeof(USHORT) + _SS_PAD1SIZE + _SS_ALIGNSIZE))
#else 
#define _SS_PAD1SIZE (_SS_ALIGNSIZE - sizeof (short))
#define _SS_PAD2SIZE (_SS_MAXSIZE - (sizeof (short) + _SS_PAD1SIZE \
                                                    + _SS_ALIGNSIZE))
#endif //(_WIN32_WINNT >= 0x0600)

typedef struct sockaddr_storage {
    ADDRESS_FAMILY ss_family;      // address family

    CHAR __ss_pad1[_SS_PAD1SIZE];  // 6 byte pad, this is to make
                                   //   implementation specific pad up to
                                   //   alignment field that follows explicit
                                   //   in the data structure
    __int64 __ss_align;            // Field to force desired structure
    CHAR __ss_pad2[_SS_PAD2SIZE];  // 112 byte pad to achieve desired size;
                                   //   _SS_MAXSIZE value minus size of
                                   //   ss_family, __ss_pad1, and
                                   //   __ss_align fields is 112
} SOCKADDR_STORAGE_LH, *PSOCKADDR_STORAGE_LH, FAR *LPSOCKADDR_STORAGE_LH;

typedef struct sockaddr_storage_xp {
    short ss_family;               // Address family.

    CHAR __ss_pad1[_SS_PAD1SIZE];  // 6 byte pad, this is to make
                                   //   implementation specific pad up to
                                   //   alignment field that follows explicit
                                   //   in the data structure
    __int64 __ss_align;            // Field to force desired structure
    CHAR __ss_pad2[_SS_PAD2SIZE];  // 112 byte pad to achieve desired size;
                                   //   _SS_MAXSIZE value minus size of
                                   //   ss_family, __ss_pad1, and
                                   //   __ss_align fields is 112
} SOCKADDR_STORAGE_XP, *PSOCKADDR_STORAGE_XP, FAR *LPSOCKADDR_STORAGE_XP;


#if(_WIN32_WINNT >= 0x0600)
typedef SOCKADDR_STORAGE_LH SOCKADDR_STORAGE;
typedef SOCKADDR_STORAGE *PSOCKADDR_STORAGE, FAR *LPSOCKADDR_STORAGE;
#elif (_WIN32_WINNT >= 0x0501)
typedef SOCKADDR_STORAGE_XP SOCKADDR_STORAGE;
typedef SOCKADDR_STORAGE *PSOCKADDR_STORAGE, FAR *LPSOCKADDR_STORAGE;
#elif (UNDER_CE)
typedef SOCKADDR_STORAGE_XP SOCKADDR_STORAGE;
typedef SOCKADDR_STORAGE *PSOCKADDR_STORAGE, FAR *LPSOCKADDR_STORAGE;
#endif


/*
 * WinSock 2 extension -- manifest constants for WSAIoctl()
 */
#define IOC_UNIX                      0x00000000
#define IOC_WS2                       0x08000000
#define IOC_PROTOCOL                  0x10000000
#define IOC_VENDOR                    0x18000000

#if (_WIN32_WINNT >= 0x0600)
/*
 * WSK-specific IO control codes are Winsock2 codes with the highest-order
 * 3 bits of the Vendor/AddressFamily-specific field set to 1.
 */
#define IOC_WSK                       (IOC_WS2|0x07000000)
#endif //(_WIN32_WINNT >= 0x0600)

#define _WSAIO(x,y)                   (IOC_VOID|(x)|(y))
#define _WSAIOR(x,y)                  (IOC_OUT|(x)|(y))
#define _WSAIOW(x,y)                  (IOC_IN|(x)|(y))
#define _WSAIORW(x,y)                 (IOC_INOUT|(x)|(y))

#define SIO_ASSOCIATE_HANDLE          _WSAIOW(IOC_WS2,1)
#define SIO_ENABLE_CIRCULAR_QUEUEING  _WSAIO(IOC_WS2,2)
#define SIO_FIND_ROUTE                _WSAIOR(IOC_WS2,3)
#define SIO_FLUSH                     _WSAIO(IOC_WS2,4)
#define SIO_GET_BROADCAST_ADDRESS     _WSAIOR(IOC_WS2,5)
#define SIO_GET_EXTENSION_FUNCTION_POINTER  _WSAIORW(IOC_WS2,6)
#define SIO_GET_QOS                   _WSAIORW(IOC_WS2,7)
#define SIO_GET_GROUP_QOS             _WSAIORW(IOC_WS2,8)
#define SIO_MULTIPOINT_LOOPBACK       _WSAIOW(IOC_WS2,9)
#define SIO_MULTICAST_SCOPE           _WSAIOW(IOC_WS2,10)
#define SIO_SET_QOS                   _WSAIOW(IOC_WS2,11)
#define SIO_SET_GROUP_QOS             _WSAIOW(IOC_WS2,12)
#define SIO_TRANSLATE_HANDLE          _WSAIORW(IOC_WS2,13)
#define SIO_ROUTING_INTERFACE_QUERY   _WSAIORW(IOC_WS2,20)
#define SIO_ROUTING_INTERFACE_CHANGE  _WSAIOW(IOC_WS2,21)
#define SIO_ADDRESS_LIST_QUERY        _WSAIOR(IOC_WS2,22)
#define SIO_ADDRESS_LIST_CHANGE       _WSAIO(IOC_WS2,23)
#define SIO_QUERY_TARGET_PNP_HANDLE   _WSAIOR(IOC_WS2,24)

#if(_WIN32_WINNT >= 0x0501) || defined(UNDER_CE)
#define SIO_ADDRESS_LIST_SORT         _WSAIORW(IOC_WS2,25)
#endif //(_WIN32_WINNT >= 0x0501)

#if (_WIN32_WINNT >= 0x0600)
#define SIO_RESERVED_1                _WSAIOW(IOC_WS2,26)
#define SIO_RESERVED_2                _WSAIOW(IOC_WS2,33)
#endif //(_WIN32_WINNT >= 0x0600)

//
// Constants and structures defined by the internet system (RFC 790)
//

//
// N.B. required for backwards compatability to support 0 = IP for the
// level argument to get/setsockopt.
//
#define IPPROTO_IP              0

//
// Protocols.  The IPv6 defines are specified in RFC 2292.
//
typedef enum {
#if(_WIN32_WINNT >= 0x0501)
    IPPROTO_HOPOPTS       = 0,  // IPv6 Hop-by-Hop options
#endif//(_WIN32_WINNT >= 0x0501)
    IPPROTO_ICMP          = 1,
    IPPROTO_IGMP          = 2,
    IPPROTO_GGP           = 3,
#if(_WIN32_WINNT >= 0x0501)
    IPPROTO_IPV4          = 4,
#endif//(_WIN32_WINNT >= 0x0501)
#if(_WIN32_WINNT >= 0x0600)
    IPPROTO_ST            = 5,
#endif//(_WIN32_WINNT >= 0x0600)
    IPPROTO_TCP           = 6,
#if(_WIN32_WINNT >= 0x0600)
    IPPROTO_CBT           = 7,
    IPPROTO_EGP           = 8,
    IPPROTO_IGP           = 9,
#endif//(_WIN32_WINNT >= 0x0600)    
    IPPROTO_PUP           = 12,
    IPPROTO_UDP           = 17,
    IPPROTO_IDP           = 22,
#if(_WIN32_WINNT >= 0x0600)    
    IPPROTO_RDP           = 27,
#endif//(_WIN32_WINNT >= 0x0600)    


#if (_WIN32_WINNT >= 0x0501) || defined (UNDER_CE)
    IPPROTO_IPV6          = 41, // IPv6 header
    IPPROTO_ROUTING       = 43, // IPv6 Routing header
    IPPROTO_FRAGMENT      = 44, // IPv6 fragmentation header
    IPPROTO_ESP           = 50, // encapsulating security payload
    IPPROTO_AH            = 51, // authentication header
    IPPROTO_ICMPV6        = 58, // ICMPv6
    IPPROTO_NONE          = 59, // IPv6 no next header
    IPPROTO_DSTOPTS       = 60, // IPv6 Destination options
#endif//(_WIN32_WINNT >= 0x0501)

    IPPROTO_ND            = 77,
#if(_WIN32_WINNT >= 0x0501) || defined (UNDER_CE)
    IPPROTO_ICLFXBM       = 78,
#endif//(_WIN32_WINNT >= 0x0501)
#if(_WIN32_WINNT >= 0x0600)    
    IPPROTO_PIM           = 103,
    IPPROTO_PGM           = 113,
    IPPROTO_L2TP          = 115,
    IPPROTO_SCTP          = 132,
#endif//(_WIN32_WINNT >= 0x0600)    
    IPPROTO_RAW           = 255,

    IPPROTO_MAX           = 256,
//
//  These are reserved for internal use by Windows.
//
    IPPROTO_RESERVED_RAW  = 257,
    IPPROTO_RESERVED_IPSEC  = 258,
    IPPROTO_RESERVED_IPSECOFFLOAD  = 259,
    IPPROTO_RESERVED_MAX  = 260
} IPPROTO, *PIPROTO;

//
// Port/socket numbers: network standard functions
//
#define IPPORT_TCPMUX           1
#define IPPORT_ECHO             7
#define IPPORT_DISCARD          9
#define IPPORT_SYSTAT           11
#define IPPORT_DAYTIME          13
#define IPPORT_NETSTAT          15
#define IPPORT_QOTD             17
#define IPPORT_MSP              18
#define IPPORT_CHARGEN          19
#define IPPORT_FTP_DATA         20
#define IPPORT_FTP              21
#define IPPORT_TELNET           23
#define IPPORT_SMTP             25
#define IPPORT_TIMESERVER       37
#define IPPORT_NAMESERVER       42
#define IPPORT_WHOIS            43
#define IPPORT_MTP              57

/*
 * Port/socket numbers: host specific functions
 */
#define IPPORT_TFTP             69
#define IPPORT_RJE              77
#define IPPORT_FINGER           79
#define IPPORT_TTYLINK          87
#define IPPORT_SUPDUP           95

/*
 * UNIX TCP sockets
 */
#define IPPORT_POP3             110
#define IPPORT_NTP              123
#define IPPORT_EPMAP            135
#define IPPORT_NETBIOS_NS       137
#define IPPORT_NETBIOS_DGM      138
#define IPPORT_NETBIOS_SSN      139
#define IPPORT_IMAP             143
#define IPPORT_SNMP             161
#define IPPORT_SNMP_TRAP        162
#define IPPORT_IMAP3            220
#define IPPORT_LDAP             389
#define IPPORT_HTTPS            443
#define IPPORT_MICROSOFT_DS     445
#define IPPORT_EXECSERVER       512
#define IPPORT_LOGINSERVER      513
#define IPPORT_CMDSERVER        514
#define IPPORT_EFSSERVER        520

/*
 * UNIX UDP sockets
 */
#define IPPORT_BIFFUDP          512
#define IPPORT_WHOSERVER        513
#define IPPORT_ROUTESERVER      520
                                        /* 520+1 also used */

/*
 * Ports < IPPORT_RESERVED are reserved for
 * privileged processes (e.g. root).
 */
#define IPPORT_RESERVED         1024
#if (_WIN32_WINNT >= 0x0600)
#define IPPORT_REGISTERED_MIN   IPPORT_RESERVED
#define IPPORT_REGISTERED_MAX   0xbfff
#define IPPORT_DYNAMIC_MIN      0xc000
#define IPPORT_DYNAMIC_MAX      0xffff
#endif //(_WIN32_WINNT >= 0x0600)

/*
 * Definitions of bits in internet address integers.
 * On subnets, the decomposition of addresses to host and net parts
 * is done according to subnet mask, not the masks here.
 *
 * N.B. RFC-compliant definitions for host-order elements are named IN_xxx,
 * while network-order elements are named IN4_xxx.
 */
#define IN_CLASSA(i)            (((LONG)(i) & 0x80000000) == 0)
#define IN_CLASSA_NET           0xff000000
#define IN_CLASSA_NSHIFT        24
#define IN_CLASSA_HOST          0x00ffffff
#define IN_CLASSA_MAX           128

#define IN_CLASSB(i)            (((LONG)(i) & 0xc0000000) == 0x80000000)
#define IN_CLASSB_NET           0xffff0000
#define IN_CLASSB_NSHIFT        16
#define IN_CLASSB_HOST          0x0000ffff
#define IN_CLASSB_MAX           65536

#define IN_CLASSC(i)            (((LONG)(i) & 0xe0000000) == 0xc0000000)
#define IN_CLASSC_NET           0xffffff00
#define IN_CLASSC_NSHIFT        8
#define IN_CLASSC_HOST          0x000000ff

#define IN_CLASSD(i)            (((long)(i) & 0xf0000000) == 0xe0000000)
#define IN_CLASSD_NET           0xf0000000       /* These ones aren't really */
#define IN_CLASSD_NSHIFT        28               /* net and host fields, but */
#define IN_CLASSD_HOST          0x0fffffff       /* routing needn't know.    */
#define IN_MULTICAST(i)         IN_CLASSD(i)

#define INADDR_ANY              (ULONG)0x00000000
#define INADDR_LOOPBACK         0x7f000001
#define INADDR_BROADCAST        (ULONG)0xffffffff
#define INADDR_NONE             0xffffffff


//
// Scope ID definition
//
typedef enum {
    ScopeLevelInterface    = 1,
    ScopeLevelLink         = 2,
    ScopeLevelSubnet       = 3,
    ScopeLevelAdmin        = 4,
    ScopeLevelSite         = 5,
    ScopeLevelOrganization = 8,
    ScopeLevelGlobal       = 14,
    ScopeLevelCount        = 16
} SCOPE_LEVEL;

typedef struct {
    union {
        struct {
            ULONG Zone : 28;
            ULONG Level : 4;
        };
        ULONG Value;
    };
} SCOPE_ID, *PSCOPE_ID;

#define SCOPEID_UNSPECIFIED_INIT    { 0 }

//
// IPv4 Socket address, Internet style
//

typedef struct sockaddr_in {

#if(_WIN32_WINNT < 0x0600)
    short   sin_family;    
#else //(_WIN32_WINNT < 0x0600)
    ADDRESS_FAMILY sin_family;
#endif //(_WIN32_WINNT < 0x0600)

    USHORT sin_port;
    IN_ADDR sin_addr;
    CHAR sin_zero[8];
} SOCKADDR_IN, *PSOCKADDR_IN;

#define IOCPARM_MASK    0x7f            /* parameters must be < 128 bytes */
#define IOC_VOID        0x20000000      /* no parameters */
#define IOC_OUT         0x40000000      /* copy out parameters */
#define IOC_IN          0x80000000      /* copy in parameters */
#define IOC_INOUT       (IOC_IN|IOC_OUT)
                                        /* 0x20000000 distinguishes new &
                                           old ioctl's */
#define _IO(x,y)        (IOC_VOID|((x)<<8)|(y))

#define _IOR(x,y,t)     (IOC_OUT|(((long)sizeof(t)&IOCPARM_MASK)<<16)|((x)<<8)|(y))

#define _IOW(x,y,t)     (IOC_IN|(((long)sizeof(t)&IOCPARM_MASK)<<16)|((x)<<8)|(y))

/*
 * WinSock 2 extension -- WSABUF and QOS struct, include qos.h
 * to pull in FLOWSPEC and related definitions
 */

typedef struct _WSABUF {
    ULONG len;     /* the length of the buffer */
    __field_bcount(len) CHAR FAR *buf; /* the pointer to the buffer */
} WSABUF, FAR * LPWSABUF;


#include <wsamsg.h>


#pragma warning(pop)

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\ws2spi.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/* WS2SPI.H -- definitions to be used with the WinSock service provider.
 *
 *
 * This header file corresponds to version 2.2.x of the WinSock SPI
 * specification.
 *
 * This file includes parts which are Copyright (c) 1982-1986 Regents
 * of the University of California.  All rights reserved.  The
 * Berkeley Software License Agreement specifies the terms and
 * conditions for redistribution.
 */

#ifndef _WINSOCK2SPI_
#define _WINSOCK2SPI_

#if _MSC_VER > 1000
#pragma once
#endif

/*
 * Ensure structures are packed consistently.
 */

#if !defined(_WIN64)
#include <pshpack4.h>
#endif

/*
 * Pull in WINSOCK2.H if necessary
 */

#ifndef _WINSOCK2API_
#include <winsock2.h>
#endif /* _WINSOCK2API_ */

#define WSPDESCRIPTION_LEN 255

#define WSS_OPERATION_IN_PROGRESS 0x00000103L

typedef struct WSPData {
    WORD         wVersion;
    WORD         wHighVersion;
    WCHAR        szDescription[WSPDESCRIPTION_LEN+1];
} WSPDATA, FAR * LPWSPDATA;

typedef struct _WSATHREADID {
    HANDLE      ThreadHandle;
    DWORD_PTR    Reserved;
} WSATHREADID, FAR * LPWSATHREADID;

/*
 * SPI function linkage.
 */

#define WSPAPI WSAAPI


#ifdef __cplusplus
extern "C" {
#endif

/*
 * Pointer to a blocking callback. A pointer to a blocking callback is
 * returned from the WPUQueryBlockingCallback() upcall. Note that this
 * function's signature is not identical to an application's blocking
 * hook function.
 */

typedef
BOOL
(CALLBACK FAR * LPBLOCKINGCALLBACK)(
    DWORD_PTR dwContext
    );

/*
 * Pointer to a user APC function. This is used as a parameter to the
 * WPUQueueUserApc() upcall. Note that this function's signature is not
 * identical to an application's completion routine.
 */

typedef
VOID
(CALLBACK FAR * LPWSAUSERAPC)(
    DWORD_PTR dwContext
    );

/*
 * Pointers to the individual entries in a service provider's proc table.
 */

typedef
SOCKET
(WSPAPI * LPWSPACCEPT)(
    SOCKET s,
    struct sockaddr FAR * addr,
    LPINT addrlen,
    LPCONDITIONPROC lpfnCondition,
    DWORD_PTR dwCallbackData,
    LPINT lpErrno
    );

typedef
INT
(WSPAPI * LPWSPADDRESSTOSTRING)(
    LPSOCKADDR lpsaAddress,
    DWORD dwAddressLength,
    LPWSAPROTOCOL_INFOW lpProtocolInfo,
    LPWSTR lpszAddressString,
    LPDWORD lpdwAddressStringLength,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPASYNCSELECT)(
    SOCKET s,
    HWND hWnd,
    unsigned int wMsg,
    long lEvent,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPBIND)(
    SOCKET s,
    const struct sockaddr FAR * name,
    int namelen,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPCANCELBLOCKINGCALL)(
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPCLEANUP)(
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPCLOSESOCKET)(
    SOCKET s,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPCONNECT)(
    SOCKET s,
    const struct sockaddr FAR * name,
    int namelen,
    LPWSABUF lpCallerData,
    LPWSABUF lpCalleeData,
    LPQOS lpSQOS,
    LPQOS lpGQOS,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPDUPLICATESOCKET)(
    SOCKET s,
    DWORD dwProcessId,
    LPWSAPROTOCOL_INFOW lpProtocolInfo,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPENUMNETWORKEVENTS)(
    SOCKET s,
    WSAEVENT hEventObject,
    LPWSANETWORKEVENTS lpNetworkEvents,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPEVENTSELECT)(
    SOCKET s,
    WSAEVENT hEventObject,
    long lNetworkEvents,
    LPINT lpErrno
    );

typedef
BOOL
(WSPAPI * LPWSPGETOVERLAPPEDRESULT)(
    SOCKET s,
    LPWSAOVERLAPPED lpOverlapped,
    LPDWORD lpcbTransfer,
    BOOL fWait,
    LPDWORD lpdwFlags,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPGETPEERNAME)(
    SOCKET s,
    struct sockaddr FAR * name,
    LPINT namelen,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPGETSOCKNAME)(
    SOCKET s,
    struct sockaddr FAR * name,
    LPINT namelen,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPGETSOCKOPT)(
    SOCKET s,
    int level,
    int optname,
    char FAR * optval,
    LPINT optlen,
    LPINT lpErrno
    );

typedef
BOOL
(WSPAPI * LPWSPGETQOSBYNAME)(
    SOCKET s,
    LPWSABUF lpQOSName,
    LPQOS lpQOS,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPIOCTL)(
    SOCKET s,
    DWORD dwIoControlCode,
    LPVOID lpvInBuffer,
    DWORD cbInBuffer,
    LPVOID lpvOutBuffer,
    DWORD cbOutBuffer,
    LPDWORD lpcbBytesReturned,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine,
    LPWSATHREADID lpThreadId,
    LPINT lpErrno
    );

typedef
SOCKET
(WSPAPI * LPWSPJOINLEAF)(
    SOCKET s,
    const struct sockaddr FAR * name,
    int namelen,
    LPWSABUF lpCallerData,
    LPWSABUF lpCalleeData,
    LPQOS lpSQOS,
    LPQOS lpGQOS,
    DWORD dwFlags,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPLISTEN)(
    SOCKET s,
    int backlog,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPRECV)(
    SOCKET s,
    LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesRecvd,
    LPDWORD lpFlags,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine,
    LPWSATHREADID lpThreadId,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPRECVDISCONNECT)(
    SOCKET s,
    LPWSABUF lpInboundDisconnectData,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPRECVFROM)(
    SOCKET s,
    LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesRecvd,
    LPDWORD lpFlags,
    struct sockaddr FAR * lpFrom,
    LPINT lpFromlen,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine,
    LPWSATHREADID lpThreadId,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPSELECT)(
    int nfds,
    fd_set FAR * readfds,
    fd_set FAR * writefds,
    fd_set FAR * exceptfds,
    const struct timeval FAR * timeout,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPSEND)(
    SOCKET s,
    LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesSent,
    DWORD dwFlags,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine,
    LPWSATHREADID lpThreadId,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPSENDDISCONNECT)(
    SOCKET s,
    LPWSABUF lpOutboundDisconnectData,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPSENDTO)(
    SOCKET s,
    LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesSent,
    DWORD dwFlags,
    const struct sockaddr FAR * lpTo,
    int iTolen,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine,
    LPWSATHREADID lpThreadId,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPSETSOCKOPT)(
    SOCKET s,
    int level,
    int optname,
    const char FAR * optval,
    int optlen,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSPSHUTDOWN)(
    SOCKET s,
    int how,
    LPINT lpErrno
    );

typedef
SOCKET
(WSPAPI * LPWSPSOCKET)(
    int af,
    int type,
    int protocol,
    LPWSAPROTOCOL_INFOW lpProtocolInfo,
    GROUP g,
    DWORD dwFlags,
    LPINT lpErrno
    );

typedef
INT
(WSPAPI * LPWSPSTRINGTOADDRESS)(
    LPWSTR AddressString,
    INT AddressFamily,
    LPWSAPROTOCOL_INFOW lpProtocolInfo,
    LPSOCKADDR lpAddress,
    LPINT lpAddressLength,
    LPINT lpErrno
    );

/*
 * A service provider proc table. This structure is returned by value
 * from the service provider's WSPStartup() entrypoint.
 */

typedef struct _WSPPROC_TABLE {

    LPWSPACCEPT              lpWSPAccept;
    LPWSPADDRESSTOSTRING     lpWSPAddressToString;
    LPWSPASYNCSELECT         lpWSPAsyncSelect;
    LPWSPBIND                lpWSPBind;
    LPWSPCANCELBLOCKINGCALL  lpWSPCancelBlockingCall;
    LPWSPCLEANUP             lpWSPCleanup;
    LPWSPCLOSESOCKET         lpWSPCloseSocket;
    LPWSPCONNECT             lpWSPConnect;
    LPWSPDUPLICATESOCKET     lpWSPDuplicateSocket;
    LPWSPENUMNETWORKEVENTS   lpWSPEnumNetworkEvents;
    LPWSPEVENTSELECT         lpWSPEventSelect;
    LPWSPGETOVERLAPPEDRESULT lpWSPGetOverlappedResult;
    LPWSPGETPEERNAME         lpWSPGetPeerName;
    LPWSPGETSOCKNAME         lpWSPGetSockName;
    LPWSPGETSOCKOPT          lpWSPGetSockOpt;
    LPWSPGETQOSBYNAME        lpWSPGetQOSByName;
    LPWSPIOCTL               lpWSPIoctl;
    LPWSPJOINLEAF            lpWSPJoinLeaf;
    LPWSPLISTEN              lpWSPListen;
    LPWSPRECV                lpWSPRecv;
    LPWSPRECVDISCONNECT      lpWSPRecvDisconnect;
    LPWSPRECVFROM            lpWSPRecvFrom;
    LPWSPSELECT              lpWSPSelect;
    LPWSPSEND                lpWSPSend;
    LPWSPSENDDISCONNECT      lpWSPSendDisconnect;
    LPWSPSENDTO              lpWSPSendTo;
    LPWSPSETSOCKOPT          lpWSPSetSockOpt;
    LPWSPSHUTDOWN            lpWSPShutdown;
    LPWSPSOCKET              lpWSPSocket;
    LPWSPSTRINGTOADDRESS     lpWSPStringToAddress;

} WSPPROC_TABLE, FAR * LPWSPPROC_TABLE;

/*
 * Pointers to the individual entries in the upcall table.
 */

typedef
BOOL
(WSPAPI * LPWPUCLOSEEVENT)(
    WSAEVENT hEvent,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWPUCLOSESOCKETHANDLE)(
    SOCKET s,
    LPINT lpErrno
    );

typedef
WSAEVENT
(WSPAPI * LPWPUCREATEEVENT)(
    LPINT lpErrno
    );

typedef
SOCKET
(WSPAPI * LPWPUCREATESOCKETHANDLE)(
    DWORD dwCatalogEntryId,
    DWORD_PTR dwContext,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWPUFDISSET)(
    SOCKET s,
    fd_set FAR * fdset
    );

typedef
int
(WSPAPI * LPWPUGETPROVIDERPATH)(
    LPGUID lpProviderId,
    WCHAR FAR * lpszProviderDllPath,
    LPINT lpProviderDllPathLen,
    LPINT lpErrno
    );

typedef
SOCKET
(WSPAPI * LPWPUMODIFYIFSHANDLE)(
    DWORD dwCatalogEntryId,
    SOCKET ProposedHandle,
    LPINT lpErrno
    );

typedef
BOOL
(WSPAPI * LPWPUPOSTMESSAGE)(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam
    );

typedef
int
(WSPAPI * LPWPUQUERYBLOCKINGCALLBACK)(
    DWORD dwCatalogEntryId,
    LPBLOCKINGCALLBACK FAR * lplpfnCallback,
    PDWORD_PTR lpdwContext,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWPUQUERYSOCKETHANDLECONTEXT)(
    SOCKET s,
    PDWORD_PTR lpContext,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWPUQUEUEAPC)(
    LPWSATHREADID lpThreadId,
    LPWSAUSERAPC lpfnUserApc,
    DWORD_PTR dwContext,
    LPINT lpErrno
    );

typedef
BOOL
(WSPAPI * LPWPURESETEVENT)(
    WSAEVENT hEvent,
    LPINT lpErrno
    );

typedef
BOOL
(WSPAPI * LPWPUSETEVENT)(
    WSAEVENT hEvent,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWPUOPENCURRENTTHREAD)(
    LPWSATHREADID lpThreadId,
    LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWPUCLOSETHREAD)(
    LPWSATHREADID lpThreadId,
    LPINT lpErrno
    );


// Available only directly from ws2_32.dll
typedef
int
(WSPAPI * LPWPUCOMPLETEOVERLAPPEDREQUEST) (
    IN SOCKET s, 	
    LPWSAOVERLAPPED lpOverlapped, 	
    DWORD dwError, 	
    DWORD cbTransferred, 	
    LPINT lpErrno
);

/*
 * The upcall table. This structure is passed by value to the service
 * provider's WSPStartup() entrypoint.
 */

typedef struct _WSPUPCALLTABLE {

    LPWPUCLOSEEVENT               lpWPUCloseEvent;
    LPWPUCLOSESOCKETHANDLE        lpWPUCloseSocketHandle;
    LPWPUCREATEEVENT              lpWPUCreateEvent;
    LPWPUCREATESOCKETHANDLE       lpWPUCreateSocketHandle;
    LPWPUFDISSET                  lpWPUFDIsSet;
    LPWPUGETPROVIDERPATH          lpWPUGetProviderPath;
    LPWPUMODIFYIFSHANDLE          lpWPUModifyIFSHandle;
    LPWPUPOSTMESSAGE              lpWPUPostMessage;
    LPWPUQUERYBLOCKINGCALLBACK    lpWPUQueryBlockingCallback;
    LPWPUQUERYSOCKETHANDLECONTEXT lpWPUQuerySocketHandleContext;
    LPWPUQUEUEAPC                 lpWPUQueueApc;
    LPWPURESETEVENT               lpWPUResetEvent;
    LPWPUSETEVENT                 lpWPUSetEvent;
    LPWPUOPENCURRENTTHREAD        lpWPUOpenCurrentThread;
    LPWPUCLOSETHREAD              lpWPUCloseThread;

} WSPUPCALLTABLE, FAR * LPWSPUPCALLTABLE;

/*
 *  WinSock 2 SPI socket function prototypes
 */

int
WSPAPI
WSPStartup(
    IN WORD wVersionRequested,
    OUT LPWSPDATA lpWSPData,
    IN LPWSAPROTOCOL_INFOW lpProtocolInfo,
    IN WSPUPCALLTABLE UpcallTable,
    OUT LPWSPPROC_TABLE lpProcTable
    );

typedef
int
(WSPAPI * LPWSPSTARTUP)(
    WORD wVersionRequested,
    LPWSPDATA lpWSPData,
    LPWSAPROTOCOL_INFOW lpProtocolInfo,
    WSPUPCALLTABLE UpcallTable,
    LPWSPPROC_TABLE lpProcTable
    );

/*
 * Installation and configuration entrypoints.
 */

int
WSPAPI
WSCEnumProtocols(
    IN LPINT lpiProtocols,
    OUT LPWSAPROTOCOL_INFOW lpProtocolBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    OUT LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSCENUMPROTOCOLS)(
    LPINT lpiProtocols,
    LPWSAPROTOCOL_INFOW lpProtocolBuffer,
    LPDWORD lpdwBufferLength,
    LPINT lpErrno
    );

int
WSPAPI
WSCDeinstallProvider(
    IN LPGUID lpProviderId,
    OUT LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSCDEINSTALLPROVIDER)(
    LPGUID lpProviderId,
    LPINT lpErrno
    );

int
WSPAPI
WSCInstallProvider(
    IN LPGUID lpProviderId,
    IN const WCHAR FAR * lpszProviderDllPath,
    IN const LPWSAPROTOCOL_INFOW lpProtocolInfoList,
    IN DWORD dwNumberOfEntries,
    OUT LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSCINSTALLPROVIDER)(
    LPGUID lpProviderId,
    const WCHAR FAR * lpszProviderDllPath,
    const LPWSAPROTOCOL_INFOW lpProtocolInfoList,
    DWORD dwNumberOfEntries,
    LPINT lpErrno
    );

int
WSPAPI
WSCGetProviderPath(
    IN LPGUID lpProviderId,
    OUT WCHAR FAR * lpszProviderDllPath,
    IN OUT LPINT lpProviderDllPathLen,
    OUT LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSCGETPROVIDERPATH)(
    LPGUID lpProviderId,
    WCHAR FAR * lpszProviderDllPath,
    LPINT lpProviderDllPathLen,
    LPINT lpErrno
    );

int
WSPAPI
WSCUpdateProvider(
    IN  LPGUID lpProviderId,
    IN  const WCHAR FAR * lpszProviderDllPath,
    IN  const LPWSAPROTOCOL_INFOW lpProtocolInfoList,
    IN  DWORD dwNumberOfEntries,
    OUT LPINT lpErrno
    );

typedef
int
(WSPAPI * LPWSCUPDATEPROVIDER)(
    LPGUID lpProviderId,
    const WCHAR FAR * lpszProviderDllPath,
    const LPWSAPROTOCOL_INFOW lpProtocolInfoList,
    DWORD dwNumberOfEntries,
    LPINT lpErrno
    );

int
WSPAPI
WSCInstallQOSTemplate (
    IN  const LPGUID    Guid,
    IN  LPWSABUF        QosName,
    IN  LPQOS           Qos
    );

typedef
int
(WSPAPI * LPWSCINSTALLQOSTEMPLATE)(
    const LPGUID    Guid,
    LPWSABUF        QosName,
    LPQOS           Qos
    );

int
WSPAPI
WSCRemoveQOSTemplate (
    IN  const LPGUID    Guid,
    IN  LPWSABUF        QosName
    );

typedef
int
(WSPAPI * LPWSCREMOVEQOSTEMPLATE)(
    const LPGUID    Guid,
    LPWSABUF        QosName
    );

/*
 *  The following upcall function prototypes are only used by WinSock 2 DLL and
 *  should not be used by any service providers.
 */

BOOL
WSPAPI
WPUCloseEvent(
    IN WSAEVENT hEvent,
    OUT LPINT lpErrno
    );

int
WSPAPI
WPUCloseSocketHandle(
    IN SOCKET s,
    OUT LPINT lpErrno
    );

WSAEVENT
WSPAPI
WPUCreateEvent(
    OUT LPINT lpErrno
    );

SOCKET
WSPAPI
WPUCreateSocketHandle(
    IN DWORD dwCatalogEntryId,
    IN DWORD_PTR dwContext,
    OUT LPINT lpErrno
    );

int
WSPAPI
WPUFDIsSet(
    IN SOCKET s,
    IN fd_set FAR * fdset
    );

int
WSPAPI
WPUGetProviderPath(
    IN LPGUID lpProviderId,
    OUT WCHAR FAR * lpszProviderDllPath,
    IN OUT LPINT lpProviderDllPathLen,
    OUT LPINT lpErrno
    );

SOCKET
WSPAPI
WPUModifyIFSHandle(
    IN DWORD dwCatalogEntryId,
    IN SOCKET ProposedHandle,
    OUT LPINT lpErrno
    );

BOOL
WSPAPI
WPUPostMessage(
    IN HWND hWnd,
    IN UINT Msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

int
WSPAPI
WPUQueryBlockingCallback(
    IN DWORD dwCatalogEntryId,
    OUT LPBLOCKINGCALLBACK FAR * lplpfnCallback,
    OUT PDWORD_PTR lpdwContext,
    OUT LPINT lpErrno
    );

int
WSPAPI
WPUQuerySocketHandleContext(
    IN SOCKET s,
    OUT PDWORD_PTR lpContext,
    OUT LPINT lpErrno
    );

int
WSPAPI
WPUQueueApc(
    IN LPWSATHREADID lpThreadId,
    IN LPWSAUSERAPC lpfnUserApc,
    IN DWORD_PTR dwContext,
    OUT LPINT lpErrno
    );

BOOL
WSPAPI
WPUResetEvent(
    IN WSAEVENT hEvent,
    OUT LPINT lpErrno
    );

BOOL
WSPAPI
WPUSetEvent(
    IN WSAEVENT hEvent,
    OUT LPINT lpErrno
    );

int
WSPAPI
WPUCompleteOverlappedRequest (
    SOCKET s, 	
    LPWSAOVERLAPPED lpOverlapped, 	
    DWORD dwError, 	
    DWORD cbTransferred, 	
    LPINT lpErrno
);

int
WSPAPI
WPUOpenCurrentThread(
    LPWSATHREADID lpThreadId,
    LPINT lpErrno
    );

int
WSPAPI
WPUCloseThread(
    LPWSATHREADID lpThreadId,
    LPINT lpErrno
    );

/*
 * Installing and uninstalling name space providers.
 */

INT
WSPAPI
WSCInstallNameSpace (
    IN LPWSTR lpszIdentifier,
    IN LPWSTR lpszPathName,
    IN DWORD dwNameSpace,
    IN DWORD dwVersion,
    IN LPGUID lpProviderId
    );

typedef
INT
(WSPAPI * LPWSCINSTALLNAMESPACE)(
    LPWSTR lpszIdentifier,
    LPWSTR lpszPathName,
    DWORD dwNameSpace,
    DWORD dwVersion,
    LPGUID lpProviderId
    );

INT
WSPAPI
WSCUnInstallNameSpace (
    IN LPGUID lpProviderId
    );

typedef
INT
(WSPAPI * LPWSCUNINSTALLNAMESPACE)(
    LPGUID lpProviderId
    );

INT
WSPAPI
WSCEnableNSProvider (
    IN LPGUID lpProviderId,
    IN BOOL fEnable
    );

typedef
INT
(WSPAPI * LPWSCENABLENSPROVIDER)(
    LPGUID lpProviderId,
    BOOL fEnable
    );

/*
 * Pointers to the individual entries in the namespace proc table.
 */

typedef
INT
(WSAAPI * LPNSPCLEANUP)(
    LPGUID lpProviderId
    );

typedef
INT
(WSAAPI * LPNSPLOOKUPSERVICEBEGIN)(
    LPGUID lpProviderId,
    LPWSAQUERYSETW lpqsRestrictions,
    LPWSASERVICECLASSINFOW lpServiceClassInfo,
    DWORD dwControlFlags,
    LPHANDLE lphLookup
    );

typedef
INT
(WSAAPI * LPNSPLOOKUPSERVICENEXT)(
    HANDLE hLookup,
    DWORD dwControlFlags,
    LPDWORD lpdwBufferLength,
    LPWSAQUERYSETW lpqsResults
    );

typedef
INT
(WSAAPI * LPNSPIOCTL)(
    HANDLE          hLookup,
    DWORD           dwControlCode,
    LPVOID          lpvInBuffer,
    DWORD           cbInBuffer,
    LPVOID          lpvOutBuffer,
    DWORD           cbOutBuffer,
    LPDWORD         lpcbBytesReturned,
    LPWSACOMPLETION lpCompletion,
    LPWSATHREADID   lpThreadId
    );

typedef
INT
(WSAAPI * LPNSPLOOKUPSERVICEEND)(
    HANDLE hLookup
    );

typedef
INT
(WSAAPI * LPNSPSETSERVICE)(
    LPGUID lpProviderId,
    LPWSASERVICECLASSINFOW lpServiceClassInfo,
    LPWSAQUERYSETW lpqsRegInfo,
    WSAESETSERVICEOP essOperation,
    DWORD dwControlFlags
    );

typedef
INT
(WSAAPI * LPNSPINSTALLSERVICECLASS)(
    LPGUID lpProviderId,
    LPWSASERVICECLASSINFOW lpServiceClassInfo
    );

typedef
INT
(WSAAPI * LPNSPREMOVESERVICECLASS)(
    LPGUID lpProviderId,
    LPGUID lpServiceClassId
    );

typedef
INT
(WSAAPI * LPNSPGETSERVICECLASSINFO)(
    LPGUID lpProviderId,
    LPDWORD lpdwBufSize,
    LPWSASERVICECLASSINFOW lpServiceClassInfo
    );

/*
 * The name space service provider procedure table.
 */

typedef struct _NSP_ROUTINE {

    /* Structure version information: */
    DWORD           cbSize;
    DWORD           dwMajorVersion;
    DWORD           dwMinorVersion;

    /* Procedure-pointer table: */

    LPNSPCLEANUP             NSPCleanup;
    LPNSPLOOKUPSERVICEBEGIN  NSPLookupServiceBegin;
    LPNSPLOOKUPSERVICENEXT   NSPLookupServiceNext;
    LPNSPLOOKUPSERVICEEND    NSPLookupServiceEnd;
    LPNSPSETSERVICE          NSPSetService;
    LPNSPINSTALLSERVICECLASS NSPInstallServiceClass;
    LPNSPREMOVESERVICECLASS  NSPRemoveServiceClass;
    LPNSPGETSERVICECLASSINFO NSPGetServiceClassInfo;

    // These APIs were added later, so must appear here
    // to keep the pointers in the structure in order.
    // Namespaces unaware of these APIs will set cbSize
    // to match the size of FIELD_OFFSET(NSP_ROUTINE, NSPIoctl).
    LPNSPIOCTL               NSPIoctl;

} NSP_ROUTINE, FAR * LPNSP_ROUTINE;

/*
 * Startup procedures.
 */

INT
WSAAPI
NSPStartup(
    LPGUID lpProviderId,
    LPNSP_ROUTINE lpnspRoutines
    );

typedef
INT
(WSAAPI * LPNSPSTARTUP)(
    LPGUID lpProviderId,
    LPNSP_ROUTINE lpnspRoutines
    );


#ifdef __cplusplus
}
#endif

#if !defined(_WIN64)
#include <poppack.h>
#endif

#endif  /* _WINSOCK2SPI_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\wsamsg.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    wsamsg.h

Abstract:
 
    This file contains the core definitions for the Winsock2
    specification that can be used by both user-mode and 
    kernel mode modules.

    This file is included in WINSOCK2.H. User mode applications
    should include WINSOCK2.H rather than including this file
    directly. This file can not be included by a module that also
    includes WINSOCK.H.
 
Environment:

    user mode or kernel mode

--*/

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

/*
 * WSAMSG -- for WSASendMsg 
 */

typedef struct _WSAMSG {
    __field_bcount(namelen) LPSOCKADDR       name;              /* Remote address */
    INT              namelen;           /* Remote address length */
    LPWSABUF         lpBuffers;         /* Data buffer array */

#if(_WIN32_WINNT >= 0x0600)
    ULONG            dwBufferCount;     /* Number of elements in the array */
#else
    DWORD            dwBufferCount;     /* Number of elements in the array */
#endif //(_WIN32_WINNT>=0x0600)

    WSABUF           Control;           /* Control buffer */

#if(_WIN32_WINNT >= 0x0600)
    ULONG            dwFlags;           /* Flags */
#else
    DWORD            dwFlags;           /* Flags */
#endif //(_WIN32_WINNT>=0x0600)

} WSAMSG, *PWSAMSG, * FAR LPWSAMSG;

/*
 * Layout of ancillary data objects in the control buffer (RFC 2292).
 */
#if(_WIN32_WINNT >= 0x0600) 
#define _WSACMSGHDR cmsghdr
#endif //(_WIN32_WINNT>=0x0600)

typedef struct _WSACMSGHDR {
    SIZE_T      cmsg_len;
    INT         cmsg_level;
    INT         cmsg_type;
    /* followed by UCHAR cmsg_data[] */
} WSACMSGHDR, *PWSACMSGHDR, FAR *LPWSACMSGHDR;

#if(_WIN32_WINNT >= 0x0600)
typedef WSACMSGHDR CMSGHDR, *PCMSGHDR;
#endif //(_WIN32_WINNT>=0x0600)

/*
 * Alignment macros for header and data members of
 * the control buffer.
 */
#define WSA_CMSGHDR_ALIGN(length)                           \
            ( ((length) + TYPE_ALIGNMENT(WSACMSGHDR)-1) &   \
                (~(TYPE_ALIGNMENT(WSACMSGHDR)-1)) )         \

#define WSA_CMSGDATA_ALIGN(length)                          \
            ( ((length) + MAX_NATURAL_ALIGNMENT-1) &        \
                (~(MAX_NATURAL_ALIGNMENT-1)) )

#if(_WIN32_WINNT >= 0x0600)
#define CMSGHDR_ALIGN WSA_CMSGHDR_ALIGN
#define CMSGDATA_ALIGN WSA_CMSGDATA_ALIGN
#endif //(_WIN32_WINNT>=0x0600)

/*
 *  WSA_CMSG_FIRSTHDR
 *
 *  Returns a pointer to the first ancillary data object, 
 *  or a null pointer if there is no ancillary data in the 
 *  control buffer of the WSAMSG structure.
 *
 *  LPCMSGHDR 
 *  WSA_CMSG_FIRSTHDR (
 *      LPWSAMSG    msg
 *      );
 */
#define WSA_CMSG_FIRSTHDR(msg) \
    ( ((msg)->Control.len >= sizeof(WSACMSGHDR))            \
        ? (LPWSACMSGHDR)(msg)->Control.buf                  \
        : (LPWSACMSGHDR)NULL )

#if(_WIN32_WINNT >= 0x0600)
#define CMSG_FIRSTHDR WSA_CMSG_FIRSTHDR
#endif //(_WIN32_WINNT>=0x0600)

/* 
 *  WSA_CMSG_NXTHDR
 *
 *  Returns a pointer to the next ancillary data object,
 *  or a null if there are no more data objects.
 *
 *  LPCMSGHDR 
 *  WSA_CMSG_NEXTHDR (
 *      LPWSAMSG        msg,
 *      LPWSACMSGHDR    cmsg
 *      );
 */
#define WSA_CMSG_NXTHDR(msg, cmsg)                          \
    ( ((cmsg) == NULL)                                      \
        ? WSA_CMSG_FIRSTHDR(msg)                            \
        : ( ( ((PUCHAR)(cmsg) +                             \
                    WSA_CMSGHDR_ALIGN((cmsg)->cmsg_len) +   \
                    sizeof(WSACMSGHDR) ) >                  \
                (PUCHAR)((msg)->Control.buf) +              \
                    (msg)->Control.len )                    \
            ? (LPWSACMSGHDR)NULL                            \
            : (LPWSACMSGHDR)((PUCHAR)(cmsg) +               \
                WSA_CMSGHDR_ALIGN((cmsg)->cmsg_len)) ) )

#if(_WIN32_WINNT >= 0x0600)
#define CMSG_NXTHDR WSA_CMSG_NXTHDR
#endif //(_WIN32_WINNT>=0x0600)

/* 
 *  WSA_CMSG_DATA
 *
 *  Returns a pointer to the first byte of data (what is referred 
 *  to as the cmsg_data member though it is not defined in 
 *  the structure).
 *
 *  Note that RFC 2292 defines this as CMSG_DATA, but that name
 *  is already used by wincrypt.h, and so Windows has used WSA_CMSG_DATA.
 *
 *  PUCHAR
 *  WSA_CMSG_DATA (
 *      LPWSACMSGHDR   pcmsg
 *      );
 */
#define WSA_CMSG_DATA(cmsg)             \
            ( (PUCHAR)(cmsg) + WSA_CMSGDATA_ALIGN(sizeof(WSACMSGHDR)) )

/*
 *  WSA_CMSG_SPACE
 *
 *  Returns total size of an ancillary data object given 
 *  the amount of data. Used to allocate the correct amount 
 *  of space.
 *
 *  SIZE_T
 *  WSA_CMSG_SPACE (
 *      SIZE_T length
 *      );
 */
#define WSA_CMSG_SPACE(length)  \
        (WSA_CMSGDATA_ALIGN(sizeof(WSACMSGHDR) + WSA_CMSGHDR_ALIGN(length)))

#if(_WIN32_WINNT >= 0x0600)
#define CMSG_SPACE WSA_CMSG_SPACE
#endif //(_WIN32_WINNT>=0x0600)

/*
 *  WSA_CMSG_LEN
 *
 *  Returns the value to store in cmsg_len given the amount of data.
 *
 *  SIZE_T
 *  WSA_CMSG_LEN (
 *      SIZE_T length
 *  );
 */
#define WSA_CMSG_LEN(length)    \
         (WSA_CMSGDATA_ALIGN(sizeof(WSACMSGHDR)) + length)

#if(_WIN32_WINNT >= 0x0600)
#define CMSG_LEN WSA_CMSG_LEN
#endif //(_WIN32_WINNT>=0x0600)

/*
 * Definition for flags member of the WSAMSG structure
 * This is in addition to other MSG_xxx flags defined
 * for recv/recvfrom/send/sendto.
 */
#define MSG_TRUNC       0x0100
#define MSG_CTRUNC      0x0200
#define MSG_BCAST       0x0400
#define MSG_MCAST       0x0800

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\wtypes.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* at Mon Jan 29 15:16:04 2007
 */
/* Compiler settings for .\wtypes.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __wtypes_h__
#define __wtypes_h__

/* Forward Declarations */ 

/* header files for imported files */
#include "basetsd.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_wtypes_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//--------------------------------------------------------------------------


extern RPC_IF_HANDLE __MIDL_itf_wtypes_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wtypes_0000_v0_0_s_ifspec;

#ifndef __IWinTypes_INTERFACE_DEFINED__
#define __IWinTypes_INTERFACE_DEFINED__

/* interface IWinTypes */
/* [auto_handle][unique][version][uuid] */ 

typedef struct tagRemHGLOBAL
    {
    long fNullHGlobal;
    unsigned long cbData;
    /* [size_is] */ byte data[ 1 ];
    }	RemHGLOBAL;

typedef struct tagRemHMETAFILEPICT
    {
    long mm;
    long xExt;
    long yExt;
    unsigned long cbData;
    /* [size_is] */ byte data[ 1 ];
    }	RemHMETAFILEPICT;

typedef struct tagRemHENHMETAFILE
    {
    unsigned long cbData;
    /* [size_is] */ byte data[ 1 ];
    }	RemHENHMETAFILE;

typedef struct tagRemHBITMAP
    {
    unsigned long cbData;
    /* [size_is] */ byte data[ 1 ];
    }	RemHBITMAP;

typedef struct tagRemHPALETTE
    {
    unsigned long cbData;
    /* [size_is] */ byte data[ 1 ];
    }	RemHPALETTE;

typedef struct tagRemBRUSH
    {
    unsigned long cbData;
    /* [size_is] */ byte data[ 1 ];
    }	RemHBRUSH;

#if !defined(_WIN32) && !defined(_MPPC_)
// The following code is for Win16 only
#ifndef WINAPI          // If not included with 3.1 headers...
#define FAR             _far
#define PASCAL          _pascal
#define CDECL           _cdecl
#define VOID            void
#define WINAPI      FAR PASCAL
#define CALLBACK    FAR PASCAL
#ifndef FALSE
#define FALSE 0
#define TRUE 1
#endif // !FALSE
#ifndef _BYTE_DEFINED
#define _BYTE_DEFINED
typedef byte BYTE;

#endif // !_BYTE_DEFINED
#ifndef _WORD_DEFINED
#define _WORD_DEFINED
typedef unsigned short WORD;

#endif // !_WORD_DEFINED
typedef unsigned int UINT;

typedef int INT;

typedef long BOOL;

#ifndef _LONG_DEFINED
#define _LONG_DEFINED
typedef long LONG;

#endif // !_LONG_DEFINED
#ifndef _WPARAM_DEFINED
#define _WPARAM_DEFINED
typedef UINT WPARAM;

#endif // _WPARAM_DEFINED
#ifndef _DWORD_DEFINED
#define _DWORD_DEFINED
typedef unsigned long DWORD;

#endif // !_DWORD_DEFINED
#ifndef _LPARAM_DEFINED
#define _LPARAM_DEFINED
typedef LONG LPARAM;

#endif // !_LPARAM_DEFINED
#ifndef _LRESULT_DEFINED
#define _LRESULT_DEFINED
typedef LONG LRESULT;

#endif // !_LRESULT_DEFINED
#ifndef _LSTATUS_DEFINED
#define _LSTATUS_DEFINED
typedef LONG LSTATUS;

#endif // !_LSTATUS_DEFINED
typedef void __RPC_FAR *HANDLE;

typedef void __RPC_FAR *HMODULE;

typedef void __RPC_FAR *HINSTANCE;

typedef void __RPC_FAR *HRGN;

typedef void __RPC_FAR *HTASK;

typedef void __RPC_FAR *HKEY;

typedef void __RPC_FAR *HDESK;

typedef void __RPC_FAR *HMF;

typedef void __RPC_FAR *HEMF;

typedef void __RPC_FAR *HPEN;

typedef void __RPC_FAR *HRSRC;

typedef void __RPC_FAR *HSTR;

typedef void __RPC_FAR *HWINSTA;

typedef void __RPC_FAR *HKL;

typedef void __RPC_FAR *HGDIOBJ;

typedef HANDLE HDWP;

#ifndef _HFILE_DEFINED
#define _HFILE_DEFINED
typedef INT HFILE;

#endif // !_HFILE_DEFINED
#ifndef _LPWORD_DEFINED
#define _LPWORD_DEFINED
typedef WORD __RPC_FAR *LPWORD;

#endif // !_LPWORD_DEFINED
#ifndef _LPDWORD_DEFINED
#define _LPDWORD_DEFINED
typedef DWORD __RPC_FAR *LPDWORD;

#endif // !_LPDWORD_DEFINED
typedef char CHAR;

typedef /* [string] */ CHAR __RPC_FAR *LPSTR;

typedef /* [string] */ const CHAR __RPC_FAR *LPCSTR;

#ifndef _WCHAR_DEFINED
#define _WCHAR_DEFINED
typedef wchar_t WCHAR;

typedef WCHAR TCHAR;

#endif // !_WCHAR_DEFINED
typedef /* [string] */ WCHAR __RPC_FAR *LPWSTR;

typedef /* [string] */ TCHAR __RPC_FAR *LPTSTR;

typedef /* [string] */ const WCHAR __RPC_FAR *LPCWSTR;

typedef /* [string] */ const TCHAR __RPC_FAR *LPCTSTR;

typedef struct tagPALETTEENTRY
    {
    BYTE peRed;
    BYTE peGreen;
    BYTE peBlue;
    BYTE peFlags;
    }	PALETTEENTRY;

typedef struct tagPALETTEENTRY __RPC_FAR *PPALETTEENTRY;

typedef struct tagPALETTEENTRY __RPC_FAR *LPPALETTEENTRY;

#if 0
typedef struct tagLOGPALETTE
    {
    WORD palVersion;
    WORD palNumEntries;
    /* [size_is] */ PALETTEENTRY palPalEntry[ 1 ];
    }	LOGPALETTE;

typedef struct tagLOGPALETTE __RPC_FAR *PLOGPALETTE;

typedef struct tagLOGPALETTE __RPC_FAR *LPLOGPALETTE;

#else
typedef struct tagLOGPALETTE {
    WORD        palVersion;
    WORD        palNumEntries;
    PALETTEENTRY        palPalEntry[1];
} LOGPALETTE, *PLOGPALETTE, *LPLOGPALETTE;
#endif
#ifndef _COLORREF_DEFINED
#define _COLORREF_DEFINED
typedef DWORD COLORREF;

#endif // !_COLORREF_DEFINED
#ifndef _LPCOLORREF_DEFINED
#define _LPCOLORREF_DEFINED
typedef DWORD __RPC_FAR *LPCOLORREF;

#endif // !_LPCOLORREF_DEFINED
typedef HANDLE __RPC_FAR *LPHANDLE;

typedef struct _RECTL
    {
    LONG left;
    LONG top;
    LONG right;
    LONG bottom;
    }	RECTL;

typedef struct _RECTL __RPC_FAR *PRECTL;

typedef struct _RECTL __RPC_FAR *LPRECTL;

typedef struct tagPOINT
    {
    LONG x;
    LONG y;
    }	POINT;

typedef struct tagPOINT __RPC_FAR *PPOINT;

typedef struct tagPOINT __RPC_FAR *LPPOINT;

typedef struct _POINTL
    {
    LONG x;
    LONG y;
    }	POINTL;

typedef struct _POINTL __RPC_FAR *PPOINTL;

#ifndef WIN16
typedef struct tagSIZE
    {
    LONG cx;
    LONG cy;
    }	SIZE;

typedef struct tagSIZE __RPC_FAR *PSIZE;

typedef struct tagSIZE __RPC_FAR *LPSIZE;

#else // WIN16
typedef struct tagSIZE
{
    INT cx;
    INT cy;
} SIZE, *PSIZE, *LPSIZE;
#endif // WIN16
typedef struct tagSIZEL
    {
    LONG cx;
    LONG cy;
    }	SIZEL;

typedef struct tagSIZEL __RPC_FAR *PSIZEL;

typedef struct tagSIZEL __RPC_FAR *LPSIZEL;

#endif  //WINAPI
#endif  //!WIN32 && !MPPC
#if defined(_WIN32) && !defined(OLE2ANSI)
typedef WCHAR OLECHAR;

typedef /* [string] */ OLECHAR __RPC_FAR *LPOLESTR;

typedef /* [string] */ const OLECHAR __RPC_FAR *LPCOLESTR;

#define OLESTR(str) L##str

#else

typedef char      OLECHAR;
typedef LPSTR     LPOLESTR;
typedef LPCSTR    LPCOLESTR;
#define OLESTR(str) str
#endif
#ifndef _WINDEF_
typedef const RECTL __RPC_FAR *LPCRECTL;

typedef void __RPC_FAR *PVOID;

typedef void __RPC_FAR *LPVOID;

typedef float FLOAT;

typedef struct tagRECT
    {
    LONG left;
    LONG top;
    LONG right;
    LONG bottom;
    }	RECT;

typedef struct tagRECT __RPC_FAR *PRECT;

typedef struct tagRECT __RPC_FAR *LPRECT;

typedef const RECT __RPC_FAR *LPCRECT;

#endif  //_WINDEF_
typedef unsigned char UCHAR;

typedef short SHORT;

typedef unsigned short USHORT;

typedef DWORD ULONG;

typedef double DOUBLE;

#ifndef _DWORDLONG_
typedef unsigned __int64 DWORDLONG;

typedef DWORDLONG __RPC_FAR *PDWORDLONG;

#endif // !_DWORDLONG_
#ifndef _ULONGLONG_
typedef __int64 LONGLONG;

typedef unsigned __int64 ULONGLONG;

typedef LONGLONG __RPC_FAR *PLONGLONG;

typedef ULONGLONG __RPC_FAR *PULONGLONG;

#endif // _ULONGLONG_
#if 0
typedef struct _LARGE_INTEGER
    {
    LONGLONG QuadPart;
    }	LARGE_INTEGER;

typedef LARGE_INTEGER __RPC_FAR *PLARGE_INTEGER;

typedef struct _ULARGE_INTEGER
    {
    ULONGLONG QuadPart;
    }	ULARGE_INTEGER;

#endif // 0
#ifndef _WINBASE_
#ifndef _FILETIME_
#define _FILETIME_
typedef struct _FILETIME
    {
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
    }	FILETIME;

typedef struct _FILETIME __RPC_FAR *PFILETIME;

typedef struct _FILETIME __RPC_FAR *LPFILETIME;

#endif // !_FILETIME
#ifndef _SYSTEMTIME_
#define _SYSTEMTIME_
typedef struct _SYSTEMTIME
    {
    WORD wYear;
    WORD wMonth;
    WORD wDayOfWeek;
    WORD wDay;
    WORD wHour;
    WORD wMinute;
    WORD wSecond;
    WORD wMilliseconds;
    }	SYSTEMTIME;

typedef struct _SYSTEMTIME __RPC_FAR *PSYSTEMTIME;

typedef struct _SYSTEMTIME __RPC_FAR *LPSYSTEMTIME;

#endif // !_SYSTEMTIME
#ifndef _SECURITY_ATTRIBUTES_
#define _SECURITY_ATTRIBUTES_
typedef struct _SECURITY_ATTRIBUTES
    {
    DWORD nLength;
    /* [size_is] */ LPVOID lpSecurityDescriptor;
    BOOL bInheritHandle;
    }	SECURITY_ATTRIBUTES;

typedef struct _SECURITY_ATTRIBUTES __RPC_FAR *PSECURITY_ATTRIBUTES;

typedef struct _SECURITY_ATTRIBUTES __RPC_FAR *LPSECURITY_ATTRIBUTES;

#endif // !_SECURITY_ATTRIBUTES_
#ifndef SECURITY_DESCRIPTOR_REVISION
typedef USHORT SECURITY_DESCRIPTOR_CONTROL;

typedef USHORT __RPC_FAR *PSECURITY_DESCRIPTOR_CONTROL;

typedef PVOID PSID;

typedef struct _ACL
    {
    UCHAR AclRevision;
    UCHAR Sbz1;
    USHORT AclSize;
    USHORT AceCount;
    USHORT Sbz2;
    }	ACL;

typedef ACL __RPC_FAR *PACL;

typedef struct _SECURITY_DESCRIPTOR
    {
    UCHAR Revision;
    UCHAR Sbz1;
    SECURITY_DESCRIPTOR_CONTROL Control;
    PSID Owner;
    PSID Group;
    PACL Sacl;
    PACL Dacl;
    }	SECURITY_DESCRIPTOR;

typedef struct _SECURITY_DESCRIPTOR __RPC_FAR *PISECURITY_DESCRIPTOR;

#endif // !SECURITY_DESCRIPTOR_REVISION
#endif //_WINBASE_
typedef struct _COAUTHIDENTITY
    {
    /* [size_is] */ USHORT __RPC_FAR *User;
    ULONG UserLength;
    /* [size_is] */ USHORT __RPC_FAR *Domain;
    ULONG DomainLength;
    /* [size_is] */ USHORT __RPC_FAR *Password;
    ULONG PasswordLength;
    ULONG Flags;
    }	COAUTHIDENTITY;

typedef struct _COAUTHINFO
    {
    DWORD dwAuthnSvc;
    DWORD dwAuthzSvc;
    LPWSTR pwszServerPrincName;
    DWORD dwAuthnLevel;
    DWORD dwImpersonationLevel;
    COAUTHIDENTITY __RPC_FAR *pAuthIdentityData;
    DWORD dwCapabilities;
    }	COAUTHINFO;

typedef struct _COSERVERINFO
    {
    DWORD dwReserved1;
    LPWSTR pwszName;
    COAUTHINFO __RPC_FAR *pAuthInfo;
    DWORD dwReserved2;
    }	COSERVERINFO;

typedef LONG SCODE;

#ifndef _HRESULT_DEFINED
#define _HRESULT_DEFINED
typedef LONG HRESULT;

#endif // !_HRESULT_DEFINED
typedef SCODE __RPC_FAR *PSCODE;

#ifndef GUID_DEFINED
#define GUID_DEFINED
typedef struct _GUID
    {
    DWORD Data1;
    WORD Data2;
    WORD Data3;
    BYTE Data4[ 8 ];
    }	GUID;

#endif // !GUID_DEFINED
#if !defined( __LPGUID_DEFINED__ )
#define __LPGUID_DEFINED__
typedef GUID __RPC_FAR *LPGUID;

#endif // !__LPGUID_DEFINED__
#ifndef __OBJECTID_DEFINED
#define __OBJECTID_DEFINED
#define _OBJECTID_DEFINED
typedef struct _OBJECTID
    {
    GUID Lineage;
    unsigned long Uniquifier;
    }	OBJECTID;

#endif // !_OBJECTID_DEFINED
#if !defined( __IID_DEFINED__ )
#define __IID_DEFINED__
typedef GUID IID;

typedef IID __RPC_FAR *LPIID;

#define IID_NULL            GUID_NULL
#define IsEqualIID(riid1, riid2) IsEqualGUID(riid1, riid2)
typedef GUID CLSID;

typedef CLSID __RPC_FAR *LPCLSID;

#define CLSID_NULL          GUID_NULL
#define IsEqualCLSID(rclsid1, rclsid2) IsEqualGUID(rclsid1, rclsid2)
typedef GUID FMTID;

typedef FMTID __RPC_FAR *LPFMTID;

#define FMTID_NULL          GUID_NULL
#define IsEqualFMTID(rfmtid1, rfmtid2) IsEqualGUID(rfmtid1, rfmtid2)
#if 0
typedef GUID __RPC_FAR *REFGUID;

typedef IID __RPC_FAR *REFIID;

typedef CLSID __RPC_FAR *REFCLSID;

typedef FMTID __RPC_FAR *REFFMTID;

#endif // 0
#if defined(__cplusplus)
#ifndef _REFGUID_DEFINED
#define _REFGUID_DEFINED
#define REFGUID             const GUID &
#endif // !_REFGUID_DEFINED
#ifndef _REFIID_DEFINED
#define _REFIID_DEFINED
#define REFIID              const IID &
#endif // !_REFIID_DEFINED
#ifndef _REFCLSID_DEFINED
#define _REFCLSID_DEFINED
#define REFCLSID            const CLSID &
#endif // !_REFCLSID_DEFINED
#ifndef _REFFMTID_DEFINED
#define _REFFMTID_DEFINED
#define REFFMTID            const FMTID &
#endif // !_REFFMTID_DEFINED
#else // !__cplusplus
#ifndef _REFGUID_DEFINED
#define _REFGUID_DEFINED
#define REFGUID             const GUID * const
#endif // !_REFGUID_DEFINED
#ifndef _REFIID_DEFINED
#define _REFIID_DEFINED
#define REFIID              const IID * const
#endif // !_REFIID_DEFINED
#ifndef _REFCLSID_DEFINED
#define _REFCLSID_DEFINED
#define REFCLSID            const CLSID * const
#endif // !_REFCLSID_DEFINED
#ifndef _REFFMTID_DEFINED
#define _REFFMTID_DEFINED
#define REFFMTID            const FMTID * const
#endif // !_REFFMTID_DEFINED
#endif // !__cplusplus
#endif // !__IID_DEFINED__
typedef 
enum tagMEMCTX
    {	MEMCTX_TASK	= 1,
	MEMCTX_SHARED	= 2,
	MEMCTX_MACSYSTEM	= 3,
	MEMCTX_UNKNOWN	= -1,
	MEMCTX_SAME	= -2
    }	MEMCTX;

#ifndef _ROTFLAGS_DEFINED
#define _ROTFLAGS_DEFINED
#define ROTFLAGS_REGISTRATIONKEEPSALIVE 0x1
#define ROTFLAGS_ALLOWANYCLIENT 0x2
#endif // !_ROTFLAGS_DEFINED
#ifndef _ROT_COMPARE_MAX_DEFINED
#define _ROT_COMPARE_MAX_DEFINED
#define ROT_COMPARE_MAX 2048
#endif // !_ROT_COMPARE_MAX_DEFINED
typedef 
enum tagCLSCTX
    {	CLSCTX_INPROC_SERVER	= 0x1,
	CLSCTX_INPROC_HANDLER	= 0x2,
	CLSCTX_LOCAL_SERVER	= 0x4,
	CLSCTX_INPROC_SERVER16	= 0x8,
	CLSCTX_REMOTE_SERVER	= 0x10,
	CLSCTX_INPROC_HANDLER16	= 0x20,
	CLSCTX_INPROC_SERVERX86	= 0x40,
	CLSCTX_INPROC_HANDLERX86	= 0x80,
	CLSCTX_RESERVED3	= 0x100,
	CLSCTX_RESERVED4	= 0x200,
	CLSCTX_NO_CODE_DOWNLOAD	= 0x400,
	CLSCTX_RESERVED5	= 0x800,
	CLSCTX_NO_CUSTOM_MARSHAL	= 0x1000,
	CLSCTX_ENABLE_CODE_DOWNLOAD	= 0x2000,
	CLSCTX_NO_FAILURE_LOG	= 0x4000,
	CLSCTX_DISABLE_AAA	= 0x8000,
	CLSCTX_ENABLE_AAA	= 0x10000,
	CLSCTX_FROM_DEFAULT_CONTEXT	= 0x20000,
	CLSCTX_ACTIVATE_32_BIT_SERVER	= 0x40000,
	CLSCTX_ACTIVATE_64_BIT_SERVER	= 0x80000,
	CLSCTX_ENABLE_CLOAKING	= 0x100000,
	CLSCTX_PS_DLL	= 0x80000000
    }	CLSCTX;

#define CLSCTX_VALID_MASK \
   (CLSCTX_INPROC_SERVER | \
    CLSCTX_INPROC_HANDLER | \
    CLSCTX_LOCAL_SERVER | \
    CLSCTX_INPROC_SERVER16 | \
    CLSCTX_REMOTE_SERVER | \
    CLSCTX_NO_CODE_DOWNLOAD | \
    CLSCTX_NO_CUSTOM_MARSHAL | \
    CLSCTX_ENABLE_CODE_DOWNLOAD | \
    CLSCTX_NO_FAILURE_LOG | \
    CLSCTX_DISABLE_AAA | \
    CLSCTX_ENABLE_AAA | \
    CLSCTX_FROM_DEFAULT_CONTEXT | \
    CLSCTX_ACTIVATE_32_BIT_SERVER | \
    CLSCTX_ACTIVATE_64_BIT_SERVER | \
    CLSCTX_ENABLE_CLOAKING | \
    CLSCTX_PS_DLL)
typedef 
enum tagMSHLFLAGS
    {	MSHLFLAGS_NORMAL	= 0,
	MSHLFLAGS_TABLESTRONG	= 1,
	MSHLFLAGS_TABLEWEAK	= 2,
	MSHLFLAGS_NOPING	= 4
    }	MSHLFLAGS;

typedef 
enum tagMSHCTX
    {	MSHCTX_LOCAL	= 0,
	MSHCTX_NOSHAREDMEM	= 1,
	MSHCTX_DIFFERENTMACHINE	= 2,
	MSHCTX_INPROC	= 3
    }	MSHCTX;

typedef 
enum tagDVASPECT
    {	DVASPECT_CONTENT	= 1,
	DVASPECT_THUMBNAIL	= 2,
	DVASPECT_ICON	= 4,
	DVASPECT_DOCPRINT	= 8
    }	DVASPECT;

typedef 
enum tagSTGC
    {	STGC_DEFAULT	= 0,
	STGC_OVERWRITE	= 1,
	STGC_ONLYIFCURRENT	= 2,
	STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE	= 4
    }	STGC;

typedef 
enum tagSTGMOVE
    {	STGMOVE_MOVE	= 0,
	STGMOVE_COPY	= 1,
	STGMOVE_SHALLOWCOPY	= 2
    }	STGMOVE;

typedef 
enum tagSTATFLAG
    {	STATFLAG_DEFAULT	= 0,
	STATFLAG_NONAME	= 1,
	STATFLAG_NOOPEN	= 2
    }	STATFLAG;

typedef /* [context_handle] */ void __RPC_FAR *HCONTEXT;

#ifndef _LCID_DEFINED
#define _LCID_DEFINED
typedef DWORD LCID;

#endif // !_LCID_DEFINED
#ifndef _LANGID_DEFINED
#define _LANGID_DEFINED
typedef WORD LANGID;

#endif // !_LANGID_DEFINED
typedef struct _BYTE_BLOB
    {
    unsigned long clSize;
    /* [size_is] */ byte abData[ 1 ];
    }	BYTE_BLOB;

typedef /* [unique] */ BYTE_BLOB __RPC_FAR *UP_BYTE_BLOB;

typedef struct _WORD_BLOB
    {
    unsigned long clSize;
    /* [size_is] */ unsigned short asData[ 1 ];
    }	WORD_BLOB;

typedef /* [unique] */ WORD_BLOB __RPC_FAR *UP_WORD_BLOB;

typedef struct _DWORD_BLOB
    {
    unsigned long clSize;
    /* [size_is] */ unsigned long alData[ 1 ];
    }	DWORD_BLOB;

typedef /* [unique] */ DWORD_BLOB __RPC_FAR *UP_DWORD_BLOB;

typedef struct _FLAGGED_BYTE_BLOB
    {
    unsigned long fFlags;
    unsigned long clSize;
    /* [size_is] */ byte abData[ 1 ];
    }	FLAGGED_BYTE_BLOB;

typedef /* [unique] */ FLAGGED_BYTE_BLOB __RPC_FAR *UP_FLAGGED_BYTE_BLOB;

typedef struct _FLAGGED_WORD_BLOB
    {
    unsigned long fFlags;
    unsigned long clSize;
    /* [size_is] */ unsigned short asData[ 1 ];
    }	FLAGGED_WORD_BLOB;

typedef /* [unique] */ FLAGGED_WORD_BLOB __RPC_FAR *UP_FLAGGED_WORD_BLOB;

typedef struct _BYTE_SIZEDARR
    {
    unsigned long clSize;
    /* [size_is] */ byte __RPC_FAR *pData;
    }	BYTE_SIZEDARR;

typedef struct _SHORT_SIZEDARR
    {
    unsigned long clSize;
    /* [size_is] */ unsigned short __RPC_FAR *pData;
    }	WORD_SIZEDARR;

typedef struct _LONG_SIZEDARR
    {
    unsigned long clSize;
    /* [size_is] */ unsigned long __RPC_FAR *pData;
    }	DWORD_SIZEDARR;

typedef struct _HYPER_SIZEDARR
    {
    unsigned long clSize;
    /* [size_is] */ hyper __RPC_FAR *pData;
    }	HYPER_SIZEDARR;

#define	WDT_INPROC_CALL	( 0x48746457 )

#define	WDT_REMOTE_CALL	( 0x52746457 )

typedef struct _userCLIPFORMAT
    {
    long fContext;
    /* [switch_is] */ /* [switch_type] */ union __MIDL_IWinTypes_0001
        {
        /* [case()] */ DWORD dwValue;
        /* [case()][string] */ wchar_t __RPC_FAR *pwszName;
        }	u;
    }	userCLIPFORMAT;

typedef /* [unique] */ userCLIPFORMAT __RPC_FAR *wireCLIPFORMAT;

typedef /* [wire_marshal] */ WORD CLIPFORMAT;

typedef struct _GDI_NONREMOTE
    {
    long fContext;
    /* [switch_is] */ /* [switch_type] */ union __MIDL_IWinTypes_0002
        {
        /* [case()] */ long hInproc;
        /* [case()] */ DWORD_BLOB __RPC_FAR *hRemote;
        }	u;
    }	GDI_NONREMOTE;

typedef struct _userHGLOBAL
    {
    long fContext;
    /* [switch_is] */ /* [switch_type] */ union __MIDL_IWinTypes_0003
        {
        /* [case()] */ long hInproc;
        /* [case()] */ FLAGGED_BYTE_BLOB __RPC_FAR *hRemote;
        /* [default] */ long hGlobal;
        }	u;
    }	userHGLOBAL;

typedef /* [unique] */ userHGLOBAL __RPC_FAR *wireHGLOBAL;

typedef struct _userHMETAFILE
    {
    long fContext;
    /* [switch_is] */ /* [switch_type] */ union __MIDL_IWinTypes_0004
        {
        /* [case()] */ long hInproc;
        /* [case()] */ BYTE_BLOB __RPC_FAR *hRemote;
        /* [default] */ long hGlobal;
        }	u;
    }	userHMETAFILE;

typedef struct _remoteMETAFILEPICT
    {
    long mm;
    long xExt;
    long yExt;
    userHMETAFILE __RPC_FAR *hMF;
    }	remoteMETAFILEPICT;

typedef struct _userHMETAFILEPICT
    {
    long fContext;
    /* [switch_is] */ /* [switch_type] */ union __MIDL_IWinTypes_0005
        {
        /* [case()] */ long hInproc;
        /* [case()] */ remoteMETAFILEPICT __RPC_FAR *hRemote;
        /* [default] */ long hGlobal;
        }	u;
    }	userHMETAFILEPICT;

typedef struct _userHENHMETAFILE
    {
    long fContext;
    /* [switch_is] */ /* [switch_type] */ union __MIDL_IWinTypes_0006
        {
        /* [case()] */ long hInproc;
        /* [case()] */ BYTE_BLOB __RPC_FAR *hRemote;
        /* [default] */ long hGlobal;
        }	u;
    }	userHENHMETAFILE;

typedef struct _userBITMAP
    {
    LONG bmType;
    LONG bmWidth;
    LONG bmHeight;
    LONG bmWidthBytes;
    WORD bmPlanes;
    WORD bmBitsPixel;
    ULONG cbSize;
    /* [size_is] */ byte pBuffer[ 1 ];
    }	userBITMAP;

typedef struct _userHBITMAP
    {
    long fContext;
    /* [switch_is] */ /* [switch_type] */ union __MIDL_IWinTypes_0007
        {
        /* [case()] */ long hInproc;
        /* [case()] */ userBITMAP __RPC_FAR *hRemote;
        /* [default] */ long hGlobal;
        }	u;
    }	userHBITMAP;

typedef struct tagrpcLOGPALETTE
    {
    WORD palVersion;
    WORD palNumEntries;
    /* [size_is] */ PALETTEENTRY palPalEntry[ 1 ];
    }	rpcLOGPALETTE;

typedef struct _userHPALETTE
    {
    long fContext;
    /* [switch_is] */ /* [switch_type] */ union __MIDL_IWinTypes_0008
        {
        /* [case()] */ long hInproc;
        /* [case()] */ rpcLOGPALETTE __RPC_FAR *hRemote;
        /* [default] */ long hGlobal;
        }	u;
    }	userHPALETTE;

typedef struct _RemotableHandle
    {
    long fContext;
    /* [switch_is] */ /* [switch_type] */ union __MIDL_IWinTypes_0009
        {
        /* [case()] */ long hInproc;
        /* [case()] */ long hRemote;
        }	u;
    }	RemotableHandle;

typedef /* [unique] */ RemotableHandle __RPC_FAR *wireHWND;

typedef /* [unique] */ RemotableHandle __RPC_FAR *wireHMENU;

typedef /* [unique] */ RemotableHandle __RPC_FAR *wireHACCEL;

typedef /* [unique] */ RemotableHandle __RPC_FAR *wireHBRUSH;

typedef /* [unique] */ RemotableHandle __RPC_FAR *wireHFONT;

typedef /* [unique] */ RemotableHandle __RPC_FAR *wireHDC;

typedef /* [unique] */ RemotableHandle __RPC_FAR *wireHICON;

#if 0
typedef /* [wire_marshal] */ void __RPC_FAR *HWND;

typedef /* [wire_marshal] */ void __RPC_FAR *HMENU;

typedef /* [wire_marshal] */ void __RPC_FAR *HACCEL;

typedef /* [wire_marshal] */ void __RPC_FAR *HBRUSH;

typedef /* [wire_marshal] */ void __RPC_FAR *HFONT;

typedef /* [wire_marshal] */ void __RPC_FAR *HDC;

typedef /* [wire_marshal] */ void __RPC_FAR *HICON;

#ifndef _HCURSOR_DEFINED
#define _HCURSOR_DEFINED
typedef HICON HCURSOR;

#endif // !_HCURSOR_DEFINED
/* tagTEXTMETRICW was copied from wingdi.h for MIDL */
typedef struct tagTEXTMETRICW
    {
    LONG tmHeight;
    LONG tmAscent;
    LONG tmDescent;
    LONG tmInternalLeading;
    LONG tmExternalLeading;
    LONG tmAveCharWidth;
    LONG tmMaxCharWidth;
    LONG tmWeight;
    LONG tmOverhang;
    LONG tmDigitizedAspectX;
    LONG tmDigitizedAspectY;
    WCHAR tmFirstChar;
    WCHAR tmLastChar;
    WCHAR tmDefaultChar;
    WCHAR tmBreakChar;
    BYTE tmItalic;
    BYTE tmUnderlined;
    BYTE tmStruckOut;
    BYTE tmPitchAndFamily;
    BYTE tmCharSet;
    }	TEXTMETRICW;

#endif //0
#ifndef _WIN32           // The following code is for Win16 only
#ifndef WINAPI          // If not included with 3.1 headers...
typedef struct tagMSG
    {
    HWND hwnd;
    UINT message;
    WPARAM wParam;
    LPARAM lParam;
    DWORD time;
    POINT pt;
    }	MSG;

typedef struct tagMSG __RPC_FAR *PMSG;

typedef struct tagMSG __RPC_FAR *NPMSG;

typedef struct tagMSG __RPC_FAR *LPMSG;

#endif // _WIN32
#endif // WINAPI
typedef /* [unique] */ userHBITMAP __RPC_FAR *wireHBITMAP;

typedef /* [unique] */ userHPALETTE __RPC_FAR *wireHPALETTE;

typedef /* [unique] */ userHENHMETAFILE __RPC_FAR *wireHENHMETAFILE;

typedef /* [unique] */ userHMETAFILE __RPC_FAR *wireHMETAFILE;

typedef /* [unique] */ userHMETAFILEPICT __RPC_FAR *wireHMETAFILEPICT;

#if 0
typedef /* [wire_marshal] */ void __RPC_FAR *HGLOBAL;

typedef HGLOBAL HLOCAL;

typedef /* [wire_marshal] */ void __RPC_FAR *HBITMAP;

typedef /* [wire_marshal] */ void __RPC_FAR *HPALETTE;

typedef /* [wire_marshal] */ void __RPC_FAR *HENHMETAFILE;

typedef /* [wire_marshal] */ void __RPC_FAR *HMETAFILE;

#endif //0
typedef /* [wire_marshal] */ void __RPC_FAR *HMETAFILEPICT;



extern RPC_IF_HANDLE IWinTypes_v0_1_c_ifspec;
extern RPC_IF_HANDLE IWinTypes_v0_1_s_ifspec;
#endif /* __IWinTypes_INTERFACE_DEFINED__ */

/* interface __MIDL_itf_wtypes_0002 */
/* [local] */ 

typedef double DATE;

#ifndef _tagCY_DEFINED
#define _tagCY_DEFINED
#define _CY_DEFINED
#if 0
/* the following isn't the real definition of CY, but it is */
/* what RPC knows how to remote */
typedef struct tagCY
    {
    LONGLONG int64;
    }	CY;

#else /* 0 */
/* real definition that makes the C++ compiler happy */
typedef union tagCY {
    struct {
#ifdef _MAC
        long      Hi;
        long Lo;
#else
        unsigned long Lo;
        long      Hi;
#endif
    };
    LONGLONG int64;
} CY;
#endif /* 0 */
#endif /* _tagCY_DEFINED */
typedef CY __RPC_FAR *LPCY;

#if 0 /* _tagDEC_DEFINED */
/* The following isn't the real definition of Decimal type, */
/* but it is what RPC knows how to remote */
typedef struct tagDEC
    {
    USHORT wReserved;
    BYTE scale;
    BYTE sign;
    ULONG Hi32;
    ULONGLONG Lo64;
    }	DECIMAL;

#else /* _tagDEC_DEFINED */
/* real definition that makes the C++ compiler happy */
typedef struct tagDEC {
    USHORT wReserved;
    union {
        struct {
            BYTE scale;
            BYTE sign;
        };
        USHORT signscale;
    };
    ULONG Hi32;
    union {
        struct {
#ifdef _MAC
            ULONG Mid32;
            ULONG Lo32;
#else
            ULONG Lo32;
            ULONG Mid32;
#endif
        };
        ULONGLONG Lo64;
    };
} DECIMAL;
#define DECIMAL_NEG ((BYTE)0x80)
#define DECIMAL_SETZERO(dec) \
        {(dec).Lo64 = 0; (dec).Hi32 = 0; (dec).signscale = 0;}
#endif /* _tagDEC_DEFINED */
typedef DECIMAL __RPC_FAR *LPDECIMAL;

typedef /* [unique] */ FLAGGED_WORD_BLOB __RPC_FAR *wireBSTR;

typedef /* [wire_marshal] */ OLECHAR __RPC_FAR *BSTR;

typedef BSTR __RPC_FAR *LPBSTR;

/* 0 == FALSE, -1 == TRUE */
typedef short VARIANT_BOOL;

#if !__STDC__ && (_MSC_VER <= 1000)
/* For backward compatibility */
typedef VARIANT_BOOL _VARIANT_BOOL;

#else
/* ANSI C/C++ reserve bool as keyword */
#define _VARIANT_BOOL    /##/
#endif
typedef boolean BOOLEAN;

/* The BSTRBLOB structure is used by some implementations */
/* of the IPropertyStorage interface when marshaling BSTRs */
/* on systems which don't support BSTR marshaling. */
#ifndef _tagBSTRBLOB_DEFINED
#define _tagBSTRBLOB_DEFINED
typedef struct tagBSTRBLOB
    {
    ULONG cbSize;
    /* [size_is] */ BYTE __RPC_FAR *pData;
    }	BSTRBLOB;

typedef struct tagBSTRBLOB __RPC_FAR *LPBSTRBLOB;

#endif
#define VARIANT_TRUE ((VARIANT_BOOL)-1)
#define VARIANT_FALSE ((VARIANT_BOOL)0)
#ifndef _tagBLOB_DEFINED
#define _tagBLOB_DEFINED
#define _BLOB_DEFINED
#define _LPBLOB_DEFINED
typedef struct tagBLOB
    {
    ULONG cbSize;
    /* [size_is] */ BYTE __RPC_FAR *pBlobData;
    }	BLOB;

typedef struct tagBLOB __RPC_FAR *LPBLOB;

#endif
typedef struct tagCLIPDATA
    {
    ULONG cbSize;
    long ulClipFmt;
    /* [size_is] */ BYTE __RPC_FAR *pClipData;
    }	CLIPDATA;

// Macro to calculate the size of the above pClipData
#define CBPCLIPDATA(clipdata)    ( (clipdata).cbSize - sizeof((clipdata).ulClipFmt) )
typedef unsigned short VARTYPE;

/*
 * VARENUM usage key,
 *
 * * [V] - may appear in a VARIANT
 * * [T] - may appear in a TYPEDESC
 * * [P] - may appear in an OLE property set
 * * [S] - may appear in a Safe Array
 *
 *
 *  VT_EMPTY            [V]   [P]     nothing
 *  VT_NULL             [V]   [P]     SQL style Null
 *  VT_I2               [V][T][P][S]  2 byte signed int
 *  VT_I4               [V][T][P][S]  4 byte signed int
 *  VT_R4               [V][T][P][S]  4 byte real
 *  VT_R8               [V][T][P][S]  8 byte real
 *  VT_CY               [V][T][P][S]  currency
 *  VT_DATE             [V][T][P][S]  date
 *  VT_BSTR             [V][T][P][S]  OLE Automation string
 *  VT_DISPATCH         [V][T][P][S]  IDispatch *
 *  VT_ERROR            [V][T][P][S]  SCODE
 *  VT_BOOL             [V][T][P][S]  True=-1, False=0
 *  VT_VARIANT          [V][T][P][S]  VARIANT *
 *  VT_UNKNOWN          [V][T]   [S]  IUnknown *
 *  VT_DECIMAL          [V][T]   [S]  16 byte fixed point
 *  VT_RECORD           [V]   [P][S]  user defined type
 *  VT_I1               [V][T][P][s]  signed char
 *  VT_UI1              [V][T][P][S]  unsigned char
 *  VT_UI2              [V][T][P][S]  unsigned short
 *  VT_UI4              [V][T][P][S]  unsigned short
 *  VT_I8                  [T][P]     signed 64-bit int
 *  VT_UI8                 [T][P]     unsigned 64-bit int
 *  VT_INT              [V][T][P][S]  signed machine int
 *  VT_UINT             [V][T]   [S]  unsigned machine int
 *  VT_INT_PTR             [T]        signed machine register size width
 *  VT_UINT_PTR            [T]        unsigned machine register size width
 *  VT_VOID                [T]        C style void
 *  VT_HRESULT             [T]        Standard return type
 *  VT_PTR                 [T]        pointer type
 *  VT_SAFEARRAY           [T]        (use VT_ARRAY in VARIANT)
 *  VT_CARRAY              [T]        C style array
 *  VT_USERDEFINED         [T]        user defined type
 *  VT_LPSTR               [T][P]     null terminated string
 *  VT_LPWSTR              [T][P]     wide null terminated string
 *  VT_FILETIME               [P]     FILETIME
 *  VT_BLOB                   [P]     Length prefixed bytes
 *  VT_STREAM                 [P]     Name of the stream follows
 *  VT_STORAGE                [P]     Name of the storage follows
 *  VT_STREAMED_OBJECT        [P]     Stream contains an object
 *  VT_STORED_OBJECT          [P]     Storage contains an object
 *  VT_VERSIONED_STREAM       [P]     Stream with a GUID version
 *  VT_BLOB_OBJECT            [P]     Blob contains an object 
 *  VT_CF                     [P]     Clipboard format
 *  VT_CLSID                  [P]     A Class ID
 *  VT_VECTOR                 [P]     simple counted array
 *  VT_ARRAY            [V]           SAFEARRAY*
 *  VT_BYREF            [V]           void* for local use
 *  VT_BSTR_BLOB                      Reserved for system use
 */

enum VARENUM
    {	VT_EMPTY	= 0,
	VT_NULL	= 1,
	VT_I2	= 2,
	VT_I4	= 3,
	VT_R4	= 4,
	VT_R8	= 5,
	VT_CY	= 6,
	VT_DATE	= 7,
	VT_BSTR	= 8,
	VT_DISPATCH	= 9,
	VT_ERROR	= 10,
	VT_BOOL	= 11,
	VT_VARIANT	= 12,
	VT_UNKNOWN	= 13,
	VT_DECIMAL	= 14,
	VT_I1	= 16,
	VT_UI1	= 17,
	VT_UI2	= 18,
	VT_UI4	= 19,
	VT_I8	= 20,
	VT_UI8	= 21,
	VT_INT	= 22,
	VT_UINT	= 23,
	VT_VOID	= 24,
	VT_HRESULT	= 25,
	VT_PTR	= 26,
	VT_SAFEARRAY	= 27,
	VT_CARRAY	= 28,
	VT_USERDEFINED	= 29,
	VT_LPSTR	= 30,
	VT_LPWSTR	= 31,
	VT_RECORD	= 36,
        VT_INT_PTR	= 37,
        VT_UINT_PTR     = 38,
	VT_FILETIME	= 64,
	VT_BLOB	= 65,
	VT_STREAM	= 66,
	VT_STORAGE	= 67,
	VT_STREAMED_OBJECT	= 68,
	VT_STORED_OBJECT	= 69,
	VT_BLOB_OBJECT	= 70,
	VT_CF	= 71,
	VT_CLSID	= 72,
	VT_VERSIONED_STREAM	= 73,
	VT_BSTR_BLOB	= 0xfff,
	VT_VECTOR	= 0x1000,
	VT_ARRAY	= 0x2000,
	VT_BYREF	= 0x4000,
	VT_RESERVED	= 0x8000,
	VT_ILLEGAL	= 0xffff,
	VT_ILLEGALMASKED	= 0xfff,
	VT_TYPEMASK	= 0xfff
    };
typedef ULONG PROPID;

#ifndef PROPERTYKEY_DEFINED
#define PROPERTYKEY_DEFINED
typedef struct _tagpropertykey
    {
    GUID fmtid;
    DWORD pid;
    }	PROPERTYKEY;

#endif
#ifndef SID_IDENTIFIER_AUTHORITY_DEFINED
#define SID_IDENTIFIER_AUTHORITY_DEFINED
typedef struct _SID_IDENTIFIER_AUTHORITY
    {
    UCHAR Value[ 6 ];
    }	SID_IDENTIFIER_AUTHORITY;

typedef struct _SID_IDENTIFIER_AUTHORITY __RPC_FAR *PSID_IDENTIFIER_AUTHORITY;

#endif
#ifndef SID_DEFINED
#define SID_DEFINED
typedef struct _SID
    {
    UCHAR Revision;
    UCHAR SubAuthorityCount;
    SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
    /* [size_is] */ ULONG SubAuthority[ 1 ];
    }	SID;

typedef struct _SID __RPC_FAR *PISID;

#endif
typedef struct tagCSPLATFORM
    {
    DWORD dwPlatformId;
    DWORD dwVersionHi;
    DWORD dwVersionLo;
    DWORD dwProcessorArch;
    }	CSPLATFORM;

typedef struct tagQUERYCONTEXT
    {
    DWORD dwContext;
    CSPLATFORM Platform;
    LCID Locale;
    DWORD dwVersionHi;
    DWORD dwVersionLo;
    }	QUERYCONTEXT;

typedef /* [v1_enum] */ 
enum tagTYSPEC
    {	TYSPEC_CLSID	= 0,
	TYSPEC_FILEEXT	= TYSPEC_CLSID + 1,
	TYSPEC_MIMETYPE	= TYSPEC_FILEEXT + 1,
	TYSPEC_FILENAME	= TYSPEC_MIMETYPE + 1,
	TYSPEC_PROGID	= TYSPEC_FILENAME + 1,
	TYSPEC_PACKAGENAME	= TYSPEC_PROGID + 1,
	TYSPEC_OBJECTID	= TYSPEC_PACKAGENAME + 1
    }	TYSPEC;

typedef /* [public] */ struct __MIDL___MIDL_itf_wtypes_0002_0001
    {
    DWORD tyspec;
    /* [switch_is] */ /* [switch_type] */ union __MIDL___MIDL_itf_wtypes_0002_0005
        {
        /* [case()] */ CLSID clsid;
        /* [case()] */ LPOLESTR pFileExt;
        /* [case()] */ LPOLESTR pMimeType;
        /* [case()] */ LPOLESTR pProgId;
        /* [case()] */ LPOLESTR pFileName;
        /* [case()] */ struct 
            {
            LPOLESTR pPackageName;
            GUID PolicyId;
            }	ByName;
        /* [case()] */ struct 
            {
            GUID ObjectId;
            GUID PolicyId;
            }	ByObjectId;
        }	tagged_union;
    }	uCLSSPEC;



extern RPC_IF_HANDLE __MIDL_itf_wtypes_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wtypes_0002_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\wxdebug.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft end-user
// license agreement (EULA) under which you licensed this SOFTWARE PRODUCT.
// If you did not accept the terms of the EULA, you are not authorized to use
// this source code. For a copy of the EULA, please see the LICENSE.RTF on your
// install media.
//
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//
//--------------------------------------------------------------------------;

// Debugging facilities, January 1995

#ifndef __WXDEBUG__
#define __WXDEBUG__

#define MAX_DEBUG_STR 384

//
// The original debugging mechanism (explained below) has been superseeded to
// use winCE Debug Zones mechanism. The DShow code still references the original
// macros, that in turn use Debug Zones ones.
//
// The DbgLog & DbgLogInfo functionality is maintained for compatibility. For
// new code, please use DebugZones' DEBUGMSG instead.
//

#define DBG_BIT(bitno) (1<<(bitno))

#define ZONE_ERROR      DEBUGZONE(0)
#define ZONE_WARNING    DEBUGZONE(1)
#define ZONE_INFO_MIN   DEBUGZONE(2)
#define ZONE_INFO_MAX   DEBUGZONE(3)
#define ZONE_INIT       DEBUGZONE(4)
#define ZONE_ENTER      DEBUGZONE(5)
#define ZONE_TIMING     DEBUGZONE(6)
#define ZONE_MEMORY     DEBUGZONE(7)
#define ZONE_LOCKING    DEBUGZONE(8)
#define ZONE_MTYPES     DEBUGZONE(9)
#define ZONE_REFCOUNT   DEBUGZONE(10)
#define ZONE_PERF       DEBUGZONE(11)
#define ZONE_TEMP       DEBUGZONE(12)

#define ZONE_NAMES          \
    TEXT("Errors"),         \
    TEXT("Warnings"),       \
    TEXT("Info (min)"),     \
    TEXT("Info (max)"),     \
    TEXT("Initialize"),     \
    TEXT("Enter,Exit"),     \
    TEXT("Timing"),         \
    TEXT("Memory"),         \
    TEXT("Locking"),        \
    TEXT("Media Types"),    \
    TEXT("RefCount"),       \
    TEXT("Performance"),    \
    TEXT("Temporary tests")

#include <celog.h>
#include <dshowwmi.h>

// This library provides fairly straight forward debugging functionality, this
// is split into two main sections. The first is assertion handling, there are
// three types of assertions provided here. The most commonly used one is the
// ASSERT(condition) macro which will pop up a message box including the file
// and line number if the condition evaluates to FALSE. Then there is the
// EXECUTE_ASSERT macro which is the same as ASSERT except the condition will
// still be executed in NON debug builds. The final type of assertion is the
// KASSERT macro which is more suitable for pure (perhaps kernel) filters as
// the condition is printed onto the debugger rather than in a message box.
//
// The other part of the debug module facilties is general purpose logging.
// This is accessed by calling DbgLog(). The function takes a type and level
// field which define the type of informational string you are presenting and
// it's relative importance. The type field can be a combination (one or more)
// of LOG_TIMING, LOG_TRACE, LOG_MEMORY, LOG_LOCKING and LOG_ERROR. The level
// is a DWORD value where zero defines highest important. Use of zero as the
// debug logging level is to be encouraged ONLY for major errors or events as
// they will ALWAYS be displayed on the debugger. Other debug output has it's
// level matched against the current debug output level stored in the registry
// for this module and if less than the current setting it will be displayed.
//
// Each module or executable has it's own debug output level for each of the
// five types. These are read in when the DbgInitialise function is called
// for DLLs linking to STRMBASE.LIB this is done automatically when the DLL
// is loaded, executables must call it explicitely with the module instance
// handle given to them through the WINMAIN entry point. An executable must
// also call DbgTerminate when they have finished to clean up the resources
// the debug library uses, once again this is done automatically for DLLs

// These are the five different categories of logging information

#define LOG_TIMING  ZONE_TIMING   // Timing and performance measurements
#define LOG_TRACE   ZONE_INFO_MIN // General step point call tracing
#define LOG_MEMORY  ZONE_MEMORY   // Memory and object allocation/destruction
#define LOG_LOCKING ZONE_LOCKING  // Locking/unlocking of critical sections
#define LOG_ERROR   ZONE_ERROR    // Debug error notification
#define LOG_WARNING ZONE_WARNING
#define LOG_MTYPES  ZONE_MTYPES
#define LOG_CUSTOM1 ZONE_TEMP
#define LOG_CUSTOM2 ZONE_TEMP
#define LOG_CUSTOM3 ZONE_TEMP
#define LOG_CUSTOM4 ZONE_TEMP
#define LOG_CUSTOM5 ZONE_TEMP

enum {  CDISP_HEX = 0x01,
        CDISP_DEC = 0x02};

// For each object created derived from CBaseObject (in debug builds) we
// create a descriptor that holds it's name (statically allocated memory)
// and a cookie we assign it. We keep a list of all the active objects
// we have registered so that we can dump a list of remaining objects

typedef struct tag_ObjectDesc {
    const TCHAR *m_pName;
    DWORD m_dwCookie;
    tag_ObjectDesc *m_pNext;
} ObjectDesc;

#define DLLIMPORT __declspec(dllimport)
#define DLLEXPORT __declspec(dllexport)

#ifdef DEBUG

    #define NAME(x) TEXT(x)

    // These are used internally by the debug library (PRIVATE)

    void WINAPI DbgInitModuleName();
    DWORD WINAPI DbgRegisterObjectCreation(const TCHAR *pObjectName);
    BOOL WINAPI DbgRegisterObjectDestruction(DWORD dwCookie);

    // Registry settings not used anymore for debugging, instead use Debug Zones.
    void WINAPI DbgInitKeyLevels(HKEY hKey);
    void WINAPI DbgInitGlobalSettings();
    void WINAPI DbgInitModuleSettings();

    // Initialise the library with the module handle

    void WINAPI DbgInitialise(HINSTANCE hInst);
    void WINAPI DbgTerminate();

    void WINAPI DbgDumpObjectRegister();


    /* Level ignored */
    #define DbgCheckModuleLevel(Type,Level) ((Type) ? TRUE : FALSE) // Type is in fact a DEBUGZONE(x), so it is true if the debug zone is turned on...

    /* Level ignored */
    #define DbgSetModuleLevel(Type,Level) ((void) 0)

    // Display error and logging to the user

    void WINAPI DbgAssert(const TCHAR *pCondition,const TCHAR *pFileName,INT iLine);
    void WINAPI DbgBreakPoint(const TCHAR *pCondition,const TCHAR *pFileName,INT iLine);
    void WINAPI DbgKernelAssert(const TCHAR *pCondition,const TCHAR *pFileName,INT iLine);
    void WINAPI DbgLogInfo(DWORD Type,DWORD Level,const TCHAR *pFormat,...);
    void WINAPI DbgLogInfo(DWORD Type,const char *pFormat,...);  // same DbgLogInfo, no Level parameter
    void WINAPI DbgOutString(LPCTSTR psz);

    //  Debug infinite wait stuff
    DWORD WINAPI DbgWaitForSingleObject(HANDLE h);
    DWORD WINAPI DbgWaitForMultipleObjects(DWORD nCount,
                                    CONST HANDLE *lpHandles,
                                    BOOL bWaitAll);
    void WINAPI DbgSetWaitTimeout(DWORD dwTimeout);

#ifdef __strmif_h__
    // Display a media type: Terse at level 2, verbose at level 5
    void WINAPI DisplayType(LPSTR label, const AM_MEDIA_TYPE *pmtIn, LPSTR sublabel="");

    // Dump lots of information about a filter
    void WINAPI DumpFilter(IBaseFilter *pFilter, DWORD dwLevel);

    // Dump lots of information about a filter graph
    void WINAPI DumpGraph(IFilterGraph *pGraph, DWORD dwLevel);
#endif

    #define KASSERT(_x_) if (!(_x_))         \
        DbgKernelAssert(TEXT(#_x_),TEXT(__FILE__),__LINE__)

    //  Break on the debugger without putting up a message box
    //  message goes to debugger instead

    #define KDbgBreak(_x_)                   \
        DbgKernelAssert(TEXT(#_x_),TEXT(__FILE__),__LINE__)

    // We chose a common name for our ASSERT macro, MFC also uses this name
    // So long as the implementation evaluates the condition and handles it
    // then we will be ok. Rather than override the behaviour expected we
    // will leave whatever first defines ASSERT as the handler (i.e. MFC)
    #ifndef ASSERT
        #define ASSERT(_x_) if (!(_x_))         \
            DbgAssert(TEXT(#_x_),TEXT(__FILE__),__LINE__)
    #endif

    #define DbgAssertAligned( _ptr_, _alignment_ ) ASSERT( ((DWORD_PTR) (_ptr_)) % (_alignment_) == 0)

    //  Put up a message box informing the user of a halt
    //  condition in the program

    #define DbgBreak(_x_)                   \
        DbgBreakPoint(TEXT(#_x_),TEXT(__FILE__),__LINE__)

    #define EXECUTE_ASSERT(_x_) ASSERT(_x_)
    #define DbgLog(_x_) DbgLogInfo _x_

    // MFC style trace macros

    #define NOTE(_x_)             DbgLog((LOG_TRACE,5,TEXT(_x_)))
    #define NOTE1(_x_,a)          DbgLog((LOG_TRACE,5,TEXT(_x_),a))
    #define NOTE2(_x_,a,b)        DbgLog((LOG_TRACE,5,TEXT(_x_),a,b))
    #define NOTE3(_x_,a,b,c)      DbgLog((LOG_TRACE,5,TEXT(_x_),a,b,c))
    #define NOTE4(_x_,a,b,c,d)    DbgLog((LOG_TRACE,5,TEXT(_x_),a,b,c,d))
    #define NOTE5(_x_,a,b,c,d,e)  DbgLog((LOG_TRACE,5,TEXT(_x_),a,b,c,d,e))

#else

    // Retail builds make public debug functions inert  - WARNING the source
    // files do not define or build any of the entry points in debug builds
    // (public entry points compile to nothing) so if you go trying to call
    // any of the private entry points in your source they won't compile

    #define NAME(_x_) NULL

#ifdef SHIP_BUILD
    #define DbgInitialise(hInst) 
#else
    #define DbgInitialise(hInst) RegisterDbgZones(hInst,&dpCurSettings);
#endif
    #define DbgTerminate()
    #define DbgLog(_x_) 0
    #define DbgOutString(psz)
    #define DbgAssertAligned( _ptr_, _alignment_ ) 0


    #define DbgRegisterObjectCreation(pObjectName)
    #define DbgRegisterObjectDestruction(dwCookie)
    #define DbgDumpObjectRegister()

    #define DbgCheckModuleLevel(Type,Level)
    #define DbgSetModuleLevel(Type,Level)

    #define DbgWaitForSingleObject(h)  WaitForSingleObject(h, INFINITE)
    #define DbgWaitForMultipleObjects(nCount, lpHandles, bWaitAll)     \
               WaitForMultipleObjects(nCount, lpHandles, bWaitAll, INFINITE)
    #define DbgSetWaitTimeout(dwTimeout)

    #define KDbgBreak(_x_)
    #define DbgBreak(_x_)

    #define KASSERT(_x_) ((void)0)
    #ifndef ASSERT
    #define ASSERT(_x_) ((void)0)
    #endif
    #define EXECUTE_ASSERT(_x_) ((void)(_x_))

    // MFC style trace macros

    #define NOTE(_x_) ((void)0)
    #define NOTE1(_x_,a) ((void)0)
    #define NOTE2(_x_,a,b) ((void)0)
    #define NOTE3(_x_,a,b,c) ((void)0)
    #define NOTE4(_x_,a,b,c,d) ((void)0)
    #define NOTE5(_x_,a,b,c,d,e) ((void)0)

    #define DisplayType(label, pmtIn) ((void)0)
    #define DumpFilter(pFilter, label) ((void)0)
    #define DumpGraph(pGraph, label) ((void)0)
#endif


// Checks a pointer which should be non NULL - can be used as follows.

#define CheckPointer(p,ret) {if((p)==NULL) return (ret);}

//   HRESULT Foo(VOID *pBar)
//   {
//       CheckPointer(pBar,E_INVALIDARG)
//   }
//
//   Or if the function returns a boolean
//
//   BOOL Foo(VOID *pBar)
//   {
//       CheckPointer(pBar,FALSE)
//   }

// These validate pointers when symbol VFWROBUST is defined
// This will normally be defined in debug not retail builds

#ifdef DEBUG
    #define VFWROBUST
#endif

#ifdef VFWROBUST

    #define ValidateReadPtr(p,cb) \
        {if(IsBadReadPtr((PVOID)p,cb) == TRUE) \
            DbgBreak("Invalid read pointer");}

    #define ValidateWritePtr(p,cb) \
        {if(IsBadWritePtr((PVOID)p,cb) == TRUE) \
            DbgBreak("Invalid write pointer");}

    #define ValidateReadWritePtr(p,cb) \
        {ValidateReadPtr(p,cb) ValidateWritePtr(p,cb)}

    #define ValidateStringPtr(p) \
        {if(IsBadStringPtr((LPCTSTR)p,INFINITE) == TRUE) \
            DbgBreak("Invalid string pointer");}

    #define ValidateStringPtrA(p) \
        {if(IsBadStringPtrA((LPCSTR)p,INFINITE) == TRUE) \
            DbgBreak("Invalid ANSII string pointer");}

    #define ValidateStringPtrW(p) \
        {if(IsBadStringPtrW((LPCWSTR)p,INFINITE) == TRUE) \
            DbgBreak("Invalid UNICODE string pointer");}

#else
    #define ValidateReadPtr(p,cb) 0
    #define ValidateWritePtr(p,cb) 0
    #define ValidateReadWritePtr(p,cb) 0
    #define ValidateStringPtr(p) 0
    #define ValidateStringPtrA(p) 0
    #define ValidateStringPtrW(p) 0
#endif


// Converts a GUID to a string
TCHAR *GuidtoString(GUID gInput, TCHAR *pStr);

#ifdef _OBJBASE_H_

    //  Outputting GUID names.  If you want to include the name
    //  associated with a GUID (eg CLSID_...) then
    //
    //      GuidNames[yourGUID]
    //
    //  Returns the name defined in uuids.h as a string

    typedef struct {
        TCHAR   *szName;
        GUID    guid;
    } GUID_STRING_ENTRY;

    class CGuidNameList {
    public:
        TCHAR *operator [] (const GUID& guid);
    };

    extern CGuidNameList GuidNames;

#endif

#ifndef REMIND
    //  REMIND macro - generates warning as reminder to complete coding
    //  (eg) usage:
    //
    //  #pragma message (REMIND("Add automation support"))


    #define QUOTE(x) #x
    #define QQUOTE(y) QUOTE(y)
    #define REMIND(str) __FILE__ "(" QQUOTE(__LINE__) ") :  " str
#endif

//  How to display objects in a useful format
//
//  eg If you want to display a LONGLONG ll in a debug string do (eg)
//
//  DbgLog((LOG_TRACE, n, TEXT("Value is %s"), (LPCTSTR)CDisp(ll, CDISP_HEX)));


class CDispBasic
{
public:
    CDispBasic() { m_pString = m_String; m_String[0] = '\0'; };
    ~CDispBasic();
protected:
    PTCHAR m_pString;  // normally points to m_String... unless too much data
    TCHAR m_String[50];
};
class CDisp : public CDispBasic
{
public:
    CDisp(LONGLONG ll, int Format = CDISP_HEX); // Display a LONGLONG in CDISP_HEX or CDISP_DEC form
    CDisp(REFCLSID clsid);      // Display a GUID
    CDisp(double d);            // Display a floating point number
#ifdef __strmif_h__
#ifdef __STREAMS__
    CDisp(CRefTime t);          // Display a Reference Time
#endif
    CDisp(IPin *pPin);          // Display a pin as {filter clsid}(pin name)
    CDisp(IBaseFilter* pFilter);// Display a filter as (<Filter address>) '<filter name>'
#endif // __strmif_h__
    ~CDisp();

    //  Implement cast to (LPCTSTR) as parameter to logger
    operator LPCTSTR()
    {
        return (LPCTSTR)m_pString;
    };
};


#ifdef DEBUG

#define DSHOW_TRACE_ENTER_HELPER(func)      DEBUGMSG(ZONE_ENTER, (L"%s: Entering\n", func));
#define DSHOW_TRACE_EXIT_HELPER(func)       DEBUGMSG(ZONE_ENTER, (L"%s: Exiting\n", func));
#define DSHOW_TRACE_EXIT_HR_HELPER(func,hr) DEBUGMSG(SUCCEEDED(hr) ? ZONE_ENTER : ZONE_ERROR, (L"%s: Exiting, hr = 0x%x\n", func, hr));

class DShowTrace
{
public:
    
    inline DShowTrace(WCHAR *func)
    {
        m_szFunctionName = func;
        m_phResult = NULL;
        DSHOW_TRACE_ENTER_HELPER(m_szFunctionName);
    }

    inline DShowTrace(WCHAR *func, HRESULT *phr)
    {
        m_szFunctionName = func;
        m_phResult = phr;
        DSHOW_TRACE_ENTER_HELPER(m_szFunctionName);
    }

    inline ~DShowTrace()
    {
        if (m_phResult)
        {
            DSHOW_TRACE_EXIT_HR_HELPER(m_szFunctionName, *m_phResult);
        }
        else
        {
            DSHOW_TRACE_EXIT_HELPER(m_szFunctionName);
        }
    }

private:
    WCHAR *m_szFunctionName;
    HRESULT *m_phResult;
};

#define DSHOW_TRACE()  \
        DShowTrace __dshowTrace__(TEXT(__FUNCTION__));
        
#define DSHOW_TRACE_HR(phResult)  \
        DShowTrace __dshowTrace__(TEXT(__FUNCTION__), phResult);
        
#define DSHOW_TRACE_ENTER()     DSHOW_TRACE_ENTER_HELPER(TEXT(__FUNCTION__))
#define DSHOW_TRACE_EXIT()      DSHOW_TRACE_EXIT_HELPER(TEXT(__FUNCTION__))
#define DSHOW_TRACE_EXIT_HR(hr) DSHOW_TRACE_EXIT_HR_HELPER(TEXT(__FUNCTION__), hr)

#else   // DEBUG

#define DSHOW_TRACE()

#define DSHOW_TRACE_HR(phResult)

#define DSHOW_TRACE_ENTER()

#define DSHOW_TRACE_EXIT()

#define DSHOW_TRACE_EXIT_HR(hr)

#endif  // DEBUG

#endif // __WXDEBUG__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\xmldomdid.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996-1997               **
//*********************************************************************

//;begin_internal
/***********************************************************************************************

  This is a distributed SDK component - do not put any #includes or other directives that rely
  upon files not dropped. If in doubt - build iedev

  If you add comments please include either ;BUGBUG at the beginning of a single line OR
  enclose in a ;begin_internal, ;end_internal block - such as this one!

 ***********************************************************************************************/
//;end_internal

//;begin_internal
#ifndef __XMLDOMDID_H__
#define __XMLDOMDID_H__
//;end_internal

// Our dispids need to be mapped into the range 1..9999 to kep Trident happy
// specifically, to make the XML tag more efficient. (simonb, 09-18-1998)
#define DISPID_DOM_BASE                 0x00000001

#define DISPID_DOM_COLLECTION_BASE	1000000
#define DISPID_DOM_COLLECTION_MAX	2999999

#define DISPID_DOM_NODE                             (DISPID_DOM_BASE)
#define DISPID_DOM_NODE_NODENAME                    (DISPID_DOM_NODE + 1)
#define DISPID_DOM_NODE_NODEVALUE                   (DISPID_DOM_NODE + 2)
#define DISPID_DOM_NODE_NODETYPE                    (DISPID_DOM_NODE + 3)
#define DISPID_DOM_NODE_NODETYPEENUM                (DISPID_DOM_NODE + 4)
#define DISPID_DOM_NODE_PARENTNODE                  (DISPID_DOM_NODE + 5)
#define DISPID_DOM_NODE_CHILDNODES                  (DISPID_DOM_NODE + 6)
#define DISPID_DOM_NODE_FIRSTCHILD                  (DISPID_DOM_NODE + 7)
#define DISPID_DOM_NODE_LASTCHILD                   (DISPID_DOM_NODE + 8)
#define DISPID_DOM_NODE_PREVIOUSSIBLING             (DISPID_DOM_NODE + 9)
#define DISPID_DOM_NODE_NEXTSIBLING                 (DISPID_DOM_NODE + 10)
#define DISPID_DOM_NODE_ATTRIBUTES                  (DISPID_DOM_NODE + 11)
#define DISPID_DOM_NODE_INSERTBEFORE                (DISPID_DOM_NODE + 12)
#define DISPID_DOM_NODE_REPLACECHILD                (DISPID_DOM_NODE + 13)
#define DISPID_DOM_NODE_REMOVECHILD                 (DISPID_DOM_NODE + 14)
#define DISPID_DOM_NODE_APPENDCHILD                 (DISPID_DOM_NODE + 15)
#define DISPID_DOM_NODE_HASCHILDNODES               (DISPID_DOM_NODE + 16)
#define DISPID_DOM_NODE_OWNERDOC                    (DISPID_DOM_NODE + 17)
#define DISPID_DOM_NODE_CLONENODE                   (DISPID_DOM_NODE + 18)
#define DISPID_XMLDOM_NODE                          (DISPID_DOM_NODE + 19)
#define DISPID_XMLDOM_NODE_STRINGTYPE               (DISPID_XMLDOM_NODE + 1)
#define DISPID_XMLDOM_NODE_SPECIFIED                (DISPID_XMLDOM_NODE + 2)
#define DISPID_XMLDOM_NODE_DEFINITION               (DISPID_XMLDOM_NODE + 3)
#define DISPID_XMLDOM_NODE_TEXT                     (DISPID_XMLDOM_NODE + 4)
#define DISPID_XMLDOM_NODE_NODETYPEDVALUE           (DISPID_XMLDOM_NODE + 5)
#define DISPID_XMLDOM_NODE_DATATYPE                 (DISPID_XMLDOM_NODE + 6)
#define DISPID_XMLDOM_NODE_XML                      (DISPID_XMLDOM_NODE + 7)
#define DISPID_XMLDOM_NODE_TRANSFORMNODE            (DISPID_XMLDOM_NODE + 8)
#define DISPID_XMLDOM_NODE_SELECTNODES              (DISPID_XMLDOM_NODE + 9)
#define DISPID_XMLDOM_NODE_SELECTSINGLENODE         (DISPID_XMLDOM_NODE + 10)
#define DISPID_XMLDOM_NODE_PARSED                   (DISPID_XMLDOM_NODE + 11)
#define DISPID_XMLDOM_NODE_NAMESPACE                (DISPID_XMLDOM_NODE + 12)
#define DISPID_XMLDOM_NODE_PREFIX                   (DISPID_XMLDOM_NODE + 13)
#define DISPID_XMLDOM_NODE_BASENAME                 (DISPID_XMLDOM_NODE + 14)
#define DISPID_XMLDOM_NODE_TRANSFORMNODETOOBJECT    (DISPID_XMLDOM_NODE + 15)
#define DISPID_XMLDOM_NODE__TOP                     (DISPID_XMLDOM_NODE + 16)

#define DISPID_DOM_DOCUMENT                        (DISPID_XMLDOM_NODE__TOP + 1)
#define DISPID_DOM_DOCUMENT_DOCTYPE                (DISPID_DOM_DOCUMENT + 1)
#define DISPID_DOM_DOCUMENT_IMPLEMENTATION         (DISPID_DOM_DOCUMENT + 2)
#define DISPID_DOM_DOCUMENT_DOCUMENTELEMENT        (DISPID_DOM_DOCUMENT + 3)
#define DISPID_DOM_DOCUMENT_CREATEELEMENT          (DISPID_DOM_DOCUMENT + 4)
#define DISPID_DOM_DOCUMENT_CREATEDOCUMENTFRAGMENT (DISPID_DOM_DOCUMENT + 5)
#define DISPID_DOM_DOCUMENT_CREATETEXTNODE         (DISPID_DOM_DOCUMENT + 6)
#define DISPID_DOM_DOCUMENT_CREATECOMMENT          (DISPID_DOM_DOCUMENT + 7)
#define DISPID_DOM_DOCUMENT_CREATECDATASECTION     (DISPID_DOM_DOCUMENT + 8)
#define DISPID_DOM_DOCUMENT_CREATEPROCESSINGINSTRUCTION (DISPID_DOM_DOCUMENT + 9)
#define DISPID_DOM_DOCUMENT_CREATEATTRIBUTE        (DISPID_DOM_DOCUMENT + 10)
#define DISPID_DOM_DOCUMENT_CREATEENTITY           (DISPID_DOM_DOCUMENT + 11)
#define DISPID_DOM_DOCUMENT_CREATEENTITYREFERENCE  (DISPID_DOM_DOCUMENT + 12)
#define DISPID_DOM_DOCUMENT_GETELEMENTSBYTAGNAME   (DISPID_DOM_DOCUMENT + 13)
#define DISPID_DOM_DOCUMENT_TOP                    (DISPID_DOM_DOCUMENT + 14)
#define DISPID_XMLDOM_DOCUMENT                     (DISPID_DOM_DOCUMENT + 15)
#define DISPID_XMLDOM_DOCUMENT_DOCUMENTNODE        (DISPID_XMLDOM_DOCUMENT + 1)
#define DISPID_XMLDOM_DOCUMENT_CREATENODE          (DISPID_XMLDOM_DOCUMENT + 2)
#define DISPID_XMLDOM_DOCUMENT_CREATENODEEX        (DISPID_XMLDOM_DOCUMENT + 3)
#define DISPID_XMLDOM_DOCUMENT_NODEFROMID          (DISPID_XMLDOM_DOCUMENT + 4)
#define DISPID_XMLDOM_DOCUMENT_DOCUMENTNAMESPACES  (DISPID_XMLDOM_DOCUMENT + 5)
#define DISPID_XMLDOM_DOCUMENT_LOAD                (DISPID_XMLDOM_DOCUMENT + 6)
#define DISPID_XMLDOM_DOCUMENT_PARSEERROR          (DISPID_XMLDOM_DOCUMENT + 7)
#define DISPID_XMLDOM_DOCUMENT_URL                 (DISPID_XMLDOM_DOCUMENT + 8)
#define DISPID_XMLDOM_DOCUMENT_ASYNC               (DISPID_XMLDOM_DOCUMENT + 9)
#define DISPID_XMLDOM_DOCUMENT_ABORT               (DISPID_XMLDOM_DOCUMENT + 10)
#define DISPID_XMLDOM_DOCUMENT_LOADXML             (DISPID_XMLDOM_DOCUMENT + 11)
#define DISPID_XMLDOM_DOCUMENT_SAVE                (DISPID_XMLDOM_DOCUMENT + 12)
#define DISPID_XMLDOM_DOCUMENT_VALIDATE            (DISPID_XMLDOM_DOCUMENT + 13)
#define DISPID_XMLDOM_DOCUMENT_RESOLVENAMESPACE    (DISPID_XMLDOM_DOCUMENT + 14)
#define DISPID_XMLDOM_DOCUMENT_PRESERVEWHITESPACE  (DISPID_XMLDOM_DOCUMENT + 15)
#define DISPID_XMLDOM_DOCUMENT_ONREADYSTATECHANGE  (DISPID_XMLDOM_DOCUMENT + 16)
#define DISPID_XMLDOM_DOCUMENT_ONDATAAVAILABLE     (DISPID_XMLDOM_DOCUMENT + 17)
#define DISPID_XMLDOM_DOCUMENT_ONTRANSFORMNODE     (DISPID_XMLDOM_DOCUMENT + 18)
#define DISPID_XMLDOM_DOCUMENT__TOP                (DISPID_XMLDOM_DOCUMENT + 19)

#define DISPID_DOM_NODELIST             (DISPID_XMLDOM_DOCUMENT__TOP + 1)
#define DISPID_DOM_NODELIST_ITEM        (DISPID_DOM_NODELIST + 1)
#define DISPID_DOM_NODELIST_LENGTH      (DISPID_DOM_NODELIST + 2)
#define DISPID_XMLDOM_NODELIST          (DISPID_DOM_NODELIST + 3)
#define DISPID_XMLDOM_NODELIST_NEXTNODE (DISPID_XMLDOM_NODELIST + 1)
#define DISPID_XMLDOM_NODELIST_RESET    (DISPID_XMLDOM_NODELIST + 2)
#define DISPID_XMLDOM_NODELIST_NEWENUM  (DISPID_XMLDOM_NODELIST + 3)
#define DISPID_XMLDOM_NODELIST__TOP     (DISPID_XMLDOM_NODELIST + 4)


#define DISPID_DOM_NAMEDNODEMAP                         (DISPID_XMLDOM_NODELIST__TOP + 1)
#define DISPID_DOM_NAMEDNODEMAP_GETNAMEDITEM            (DISPID_DOM_NAMEDNODEMAP + 3)
#define DISPID_DOM_NAMEDNODEMAP_SETNAMEDITEM            (DISPID_DOM_NAMEDNODEMAP + 4)
#define DISPID_DOM_NAMEDNODEMAP_REMOVENAMEDITEM         (DISPID_DOM_NAMEDNODEMAP + 5)
#define DISPID_XMLDOM_NAMEDNODEMAP                      (DISPID_DOM_NAMEDNODEMAP + 6)
#define DISPID_XMLDOM_NAMEDNODEMAP_GETQUALIFIEDITEM     (DISPID_XMLDOM_NAMEDNODEMAP + 1)
#define DISPID_XMLDOM_NAMEDNODEMAP_REMOVEQUALIFIEDITEM  (DISPID_XMLDOM_NAMEDNODEMAP + 2)
#define DISPID_XMLDOM_NAMEDNODEMAP_NEXTNODE             (DISPID_XMLDOM_NAMEDNODEMAP + 3)
#define DISPID_XMLDOM_NAMEDNODEMAP_RESET                (DISPID_XMLDOM_NAMEDNODEMAP + 4)
#define DISPID_XMLDOM_NAMEDNODEMAP_NEWENUM              (DISPID_XMLDOM_NAMEDNODEMAP + 5)
#define DISPID_XMLDOM_NAMEDNODEMAP__TOP                 (DISPID_XMLDOM_NAMEDNODEMAP + 6)


#define DISPID_DOM_W3CWRAPPERS                 (DISPID_XMLDOM_NAMEDNODEMAP__TOP + 1)

#define DISPID_DOM_DOCUMENTFRAGMENT            (DISPID_DOM_W3CWRAPPERS + 1)
#define DISPID_DOM_DOCUMENTFRAGMENT__TOP       (DISPID_DOM_DOCUMENTFRAGMENT + 1)

#define DISPID_DOM_ELEMENT                         (DISPID_DOM_DOCUMENTFRAGMENT__TOP + 1)
#define DISPID_DOM_ELEMENT_GETTAGNAME              (DISPID_DOM_ELEMENT + 1)
#define DISPID_DOM_ELEMENT_GETATTRIBUTES           (DISPID_DOM_ELEMENT + 2)
#define DISPID_DOM_ELEMENT_GETATTRIBUTE            (DISPID_DOM_ELEMENT + 3)
#define DISPID_DOM_ELEMENT_SETATTRIBUTE            (DISPID_DOM_ELEMENT + 4)
#define DISPID_DOM_ELEMENT_REMOVEATTRIBUTE         (DISPID_DOM_ELEMENT + 5)
#define DISPID_DOM_ELEMENT_GETATTRIBUTENODE        (DISPID_DOM_ELEMENT + 6)
#define DISPID_DOM_ELEMENT_SETATTRIBUTENODE        (DISPID_DOM_ELEMENT + 7)
#define DISPID_DOM_ELEMENT_REMOVEATTRIBUTENODE     (DISPID_DOM_ELEMENT + 8)
#define DISPID_DOM_ELEMENT_GETELEMENTSBYTAGNAME    (DISPID_DOM_ELEMENT + 9)
#define DISPID_DOM_ELEMENT_NORMALIZE               (DISPID_DOM_ELEMENT + 10)
#define DISPID_DOM_ELEMENT__TOP                    (DISPID_DOM_ELEMENT + 11)

#define DISPID_DOM_DATA                        (DISPID_DOM_ELEMENT__TOP + 1)
#define DISPID_DOM_DATA_DATA                   (DISPID_DOM_DATA + 1)
#define DISPID_DOM_DATA_LENGTH                 (DISPID_DOM_DATA + 2)
#define DISPID_DOM_DATA_SUBSTRING              (DISPID_DOM_DATA + 3)
#define DISPID_DOM_DATA_APPEND                 (DISPID_DOM_DATA + 4)
#define DISPID_DOM_DATA_INSERT                 (DISPID_DOM_DATA + 5)
#define DISPID_DOM_DATA_DELETE                 (DISPID_DOM_DATA + 6)
#define DISPID_DOM_DATA_REPLACE                (DISPID_DOM_DATA + 7)
#define DISPID_DOM_DATA__TOP                   (DISPID_DOM_DATA + 8)

#define DISPID_DOM_ATTRIBUTE                   (DISPID_DOM_DATA__TOP + 1)
#define DISPID_DOM_ATTRIBUTE_GETNAME           (DISPID_DOM_ATTRIBUTE + 1)
#define DISPID_DOM_ATTRIBUTE_SPECIFIED         (DISPID_DOM_ATTRIBUTE + 2)
#define DISPID_DOM_ATTRIBUTE_VALUE             (DISPID_DOM_ATTRIBUTE + 3)
#define DISPID_DOM_ATTRIBUTE__TOP              (DISPID_DOM_ATTRIBUTE + 4)

#define DISPID_DOM_TEXT                (DISPID_DOM_ATTRIBUTE__TOP + 1)
#define DISPID_DOM_TEXT_SPLITTEXT      (DISPID_DOM_TEXT + 1)
#define DISPID_DOM_TEXT_JOINTEXT       (DISPID_DOM_TEXT + 2)
#define DISPID_DOM_TEXT__TOP           (DISPID_DOM_TEXT + 3)

#define DISPID_DOM_PI           (DISPID_DOM_TEXT__TOP + 1)
#define DISPID_DOM_PI_TARGET    (DISPID_DOM_PI + 1)
#define DISPID_DOM_PI_DATA      (DISPID_DOM_PI + 2)
#define DISPID_DOM_PI__TOP      (DISPID_DOM_PI + 3)

#define DISPID_DOM_DOCUMENTTYPE            (DISPID_DOM_PI__TOP + 1)
#define DISPID_DOM_DOCUMENTTYPE_NAME       (DISPID_DOM_DOCUMENTTYPE + 1)
#define DISPID_DOM_DOCUMENTTYPE_ENTITIES   (DISPID_DOM_DOCUMENTTYPE + 2)
#define DISPID_DOM_DOCUMENTTYPE_NOTATIONS  (DISPID_DOM_DOCUMENTTYPE + 3)
#define DISPID_DOM_DOCUMENTTYPE__TOP       (DISPID_DOM_DOCUMENTTYPE + 4)

#define DISPID_DOM_NOTATION                (DISPID_DOM_DOCUMENTTYPE__TOP + 1)
#define DISPID_DOM_NOTATION_PUBLICID       (DISPID_DOM_NOTATION + 1)
#define DISPID_DOM_NOTATION_SYSTEMID       (DISPID_DOM_NOTATION + 2)
#define DISPID_DOM_NOTATION__TOP           (DISPID_DOM_NOTATION + 3)

#define DISPID_DOM_ENTITY                  (DISPID_DOM_NOTATION__TOP + 1)
#define DISPID_DOM_ENTITY_PUBLICID         (DISPID_DOM_ENTITY + 1)
#define DISPID_DOM_ENTITY_SYSTEMID         (DISPID_DOM_ENTITY + 2)
#define DISPID_DOM_ENTITY_NOTATIONNAME     (DISPID_DOM_ENTITY + 3)
#define DISPID_DOM_ENTITY__TOP             (DISPID_DOM_ENTITY + 4)

//define DISPID_DOM_COMMENT         
//define DISPID_DOM_CDATASECTION
//define DISPID_DOM_ENTITYREFERENCE

#define DISPID_DOM_W3CWRAPPERS_TOP         (DISPID_DOM_ENTITY__TOP)


#define DISPID_DOM_IMPLEMENTATION              (DISPID_DOM_W3CWRAPPERS_TOP + 1)
#define DISPID_DOM_IMPLEMENTATION_HASFEATURE   (DISPID_DOM_IMPLEMENTATION + 1)
#define DISPID_DOM_IMPLEMENTATION__TOP         (DISPID_DOM_IMPLEMENTATION + 2)

#define DISPID_DOM__TOP         (DISPID_DOM_IMPLEMENTATION + 0x20)


#define  DISPID_DOM_ERROR                      (DISPID_DOM__TOP  + 1)
#define  DISPID_DOM_ERROR_ERRORCODE            (DISPID_DOM_ERROR  +  1)
#define  DISPID_DOM_ERROR_URL                  (DISPID_DOM_ERROR  +  2)
#define  DISPID_DOM_ERROR_REASON               (DISPID_DOM_ERROR  +  3)
#define  DISPID_DOM_ERROR_SRCTEXT              (DISPID_DOM_ERROR  +  4)
#define  DISPID_DOM_ERROR_LINE                 (DISPID_DOM_ERROR  +  5)
#define  DISPID_DOM_ERROR_LINEPOS              (DISPID_DOM_ERROR  +  6)
#define  DISPID_DOM_ERROR_FILEPOS              (DISPID_DOM_ERROR  +  7)
#define  DISPID_DOM_ERROR__TOP                 (DISPID_DOM_ERROR  +  8)

#define  DISPID_XTLRUNTIME                         (DISPID_DOM_ERROR__TOP + 1)
#define  DISPID_XTLRUNTIME_UNIQUEID                (DISPID_XTLRUNTIME + 1)
#define  DISPID_XTLRUNTIME_DEPTH                   (DISPID_XTLRUNTIME + 2)
#define  DISPID_XTLRUNTIME_CHILDNUMBER             (DISPID_XTLRUNTIME + 3)
#define  DISPID_XTLRUNTIME_ANCESTORCHILDNUMBER     (DISPID_XTLRUNTIME + 4)
#define  DISPID_XTLRUNTIME_ABSOLUTECHILDNUMBER     (DISPID_XTLRUNTIME + 5)
#define  DISPID_XTLRUNTIME_FORMATINDEX             (DISPID_XTLRUNTIME + 6)
#define  DISPID_XTLRUNTIME_FORMATNUMBER            (DISPID_XTLRUNTIME + 7)
#define  DISPID_XTLRUNTIME_FORMATDATE              (DISPID_XTLRUNTIME + 8)
#define  DISPID_XTLRUNTIME_FORMATTIME              (DISPID_XTLRUNTIME + 9)
#define  DISPID_XTLRUNTIME__TOP                    (DISPID_XTLRUNTIME + 10)

#define  DISPID_XMLDOMEVENT                        (DISPID_XTLRUNTIME__TOP + 1)
#define  DISPID_XMLDOMEVENT_ONREADYSTATECHANGE     (DISPID_READYSTATECHANGE)
#define  DISPID_XMLDOMEVENT_ONDATAAVAILABLE        (DISPID_XMLDOMEVENT + 1)
#define  DISPID_XMLDOMEVENT__TOP                   (DISPID_XMLDOMEVENT + 2)

//;begin_internal
#endif // __XMLDOMDID_H__
//;end_internal
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\xfilter.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    xfilter.h

Abstract:

    Header file for the address filtering library for NDIS MAC's.

Author:

Environment:

Notes:

    None.

Revision History:

--*/

#pragma once

#ifndef _X_FILTER_DEFS_
#define _X_FILTER_DEFS_

#define ETH_LENGTH_OF_ADDRESS 6


//
// ZZZ This is a little-endian specific check.
//
#define ETH_IS_MULTICAST(Address) \
    (BOOLEAN)(((PUCHAR)(Address))[0] & ((UCHAR)0x01))


//
// Check whether an address is broadcast.
//
#define ETH_IS_BROADCAST(Address)               \
    ((((PUCHAR)(Address))[0] == ((UCHAR)0xff)) && (((PUCHAR)(Address))[1] == ((UCHAR)0xff)) && (((PUCHAR)(Address))[2] == ((UCHAR)0xff)) && (((PUCHAR)(Address))[3] == ((UCHAR)0xff)) && (((PUCHAR)(Address))[4] == ((UCHAR)0xff)) && (((PUCHAR)(Address))[5] == ((UCHAR)0xff)))


//
// This macro will compare network addresses.
//
//  A - Is a network address.
//
//  B - Is a network address.
//
//  Result - The result of comparing two network address.
//
//  Result < 0 Implies the B address is greater.
//  Result > 0 Implies the A element is greater.
//  Result = 0 Implies equality.
//
// Note that this is an arbitrary ordering.  There is not
// defined relation on network addresses.  This is ad-hoc!
//
//
#define ETH_COMPARE_NETWORK_ADDRESSES(_A, _B, _Result)          \
{                                                               \
    if (*(ULONG UNALIGNED *)&(_A)[2] >                          \
         *(ULONG UNALIGNED *)&(_B)[2])                          \
    {                                                           \
        *(_Result) = 1;                                         \
    }                                                           \
    else if (*(ULONG UNALIGNED *)&(_A)[2] <                     \
                *(ULONG UNALIGNED *)&(_B)[2])                   \
    {                                                           \
        *(_Result) = (UINT)-1;                                  \
    }                                                           \
    else if (*(USHORT UNALIGNED *)(_A) >                        \
                *(USHORT UNALIGNED *)(_B))                      \
    {                                                           \
        *(_Result) = 1;                                         \
    }                                                           \
    else if (*(USHORT UNALIGNED *)(_A) <                        \
                *(USHORT UNALIGNED *)(_B))                      \
    {                                                           \
        *(_Result) = (UINT)-1;                                  \
    }                                                           \
    else                                                        \
    {                                                           \
        *(_Result) = 0;                                         \
    }                                                           \
}

//
// This macro will compare network addresses.
//
//  A - Is a network address.
//
//  B - Is a network address.
//
//  Result - The result of comparing two network address.
//
//  Result != 0 Implies inequality.
//  Result == 0 Implies equality.
//
//
#define ETH_COMPARE_NETWORK_ADDRESSES_EQ(_A,_B, _Result)        \
{                                                               \
    if ((*(ULONG UNALIGNED *)&(_A)[2] ==                        \
            *(ULONG UNALIGNED *)&(_B)[2]) &&                    \
         (*(USHORT UNALIGNED *)(_A) ==                          \
            *(USHORT UNALIGNED *)(_B)))                         \
    {                                                           \
        *(_Result) = 0;                                         \
    }                                                           \
    else                                                        \
    {                                                           \
        *(_Result) = 1;                                         \
    }                                                           \
}


//
// This macro is used to copy from one network address to
// another.
//
#define ETH_COPY_NETWORK_ADDRESS(_D, _S) \
{ \
    *((ULONG UNALIGNED *)(_D)) = *((ULONG UNALIGNED *)(_S)); \
    *((USHORT UNALIGNED *)((UCHAR *)(_D)+4)) = *((USHORT UNALIGNED *)((UCHAR *)(_S)+4)); \
}

#define TR_LENGTH_OF_FUNCTIONAL     4
#define TR_LENGTH_OF_ADDRESS        6


//
// Only the low 32 bits of the functional/group address
// are needed since the upper 16 bits is always c0-00.
//
typedef ULONG TR_FUNCTIONAL_ADDRESS;
typedef ULONG TR_GROUP_ADDRESS;


#define TR_IS_NOT_DIRECTED(_Address, _Result)                               \
{                                                                           \
    *(_Result) = (BOOLEAN)((_Address)[0] & 0x80);                           \
}

#define TR_IS_FUNCTIONAL(_Address, _Result)                                 \
{                                                                           \
    *(_Result) = (BOOLEAN)(((_Address)[0] & 0x80) &&                        \
                          !((_Address)[2] & 0x80));                         \
}

//
//
#define TR_IS_GROUP(_Address, _Result)                                      \
{                                                                           \
    *(_Result) = (BOOLEAN)((_Address)[0] & (_Address)[2] & 0x80);           \
}

//
//
#define TR_IS_SOURCE_ROUTING(_Address, _Result)                             \
{                                                                           \
    *(_Result) = (BOOLEAN)((_Address)[0] & 0x80);                           \
}

//
//  Check for NDIS_PACKET_TYPE_MAC_FRAME
//
#define TR_IS_MAC_FRAME(_PacketHeader)  ((((PUCHAR)_PacketHeader)[1] & 0xFC) == 0)


//
// Check whether an address is broadcast. This is a little-endian check.
//
#define TR_IS_BROADCAST(_Address, _Result)                                      \
{                                                                               \
    *(_Result) = (BOOLEAN)(((*(UNALIGNED USHORT *)&(_Address)[0] == 0xFFFF) ||  \
                            (*(UNALIGNED USHORT *)&(_Address)[0] == 0x00C0)) && \
                            (*(UNALIGNED ULONG  *)&(_Address)[2] == 0xFFFFFFFF));\
}


//
// This macro will compare network addresses.
//
//  A - Is a network address.
//
//  B - Is a network address.
//
//  Result - The result of comparing two network address.
//
//  Result < 0 Implies the B address is greater.
//  Result > 0 Implies the A element is greater.
//  Result = 0 Implies equality.
//
// Note that this is an arbitrary ordering.  There is not
// defined relation on network addresses.  This is ad-hoc!
//
//
#define TR_COMPARE_NETWORK_ADDRESSES(_A, _B, _Result)           \
{                                                               \
    if (*(ULONG UNALIGNED *)&(_A)[2] >                          \
        *(ULONG UNALIGNED *)&(_B)[2])                           \
    {                                                           \
        *(_Result) = 1;                                         \
    }                                                           \
    else if (*(ULONG UNALIGNED *)&(_A)[2] <                     \
             *(ULONG UNALIGNED *)&(_B)[2])                      \
    {                                                           \
        *(_Result) = (UINT)-1;                                  \
    }                                                           \
    else if (*(USHORT UNALIGNED *)(_A) >                        \
             *(USHORT UNALIGNED *)(_B))                         \
    {                                                           \
        *(_Result) = 1;                                         \
    }                                                           \
    else if (*(USHORT UNALIGNED *)(_A) <                        \
             *(USHORT UNALIGNED *)(_B))                         \
    {                                                           \
        *(_Result) = (UINT)-1;                                  \
    }                                                           \
    else                                                        \
    {                                                           \
        *(_Result) = 0;                                         \
    }                                                           \
}

//
// This macro will compare network addresses.
//
//  A - Is a network address.
//
//  B - Is a network address.
//
//  Result - The result of comparing two network address.
//
//  Result != 0 Implies inequality.
//  Result == 0 Implies equality.
//
//
#define TR_COMPARE_NETWORK_ADDRESSES_EQ(_A, _B, _Result)                    \
{                                                                           \
    if ((*(ULONG UNALIGNED  *)&(_A)[2] == *(ULONG UNALIGNED  *)&(_B)[2]) && \
        (*(USHORT UNALIGNED *)&(_A)[0] == *(USHORT UNALIGNED *)&(_B)[0]))   \
    {                                                                       \
        *(_Result) = 0;                                                     \
    }                                                                       \
    else                                                                    \
    {                                                                       \
        *(_Result) = 1;                                                     \
    }                                                                       \
}


//
// This macro is used to copy from one network address to
// another.
//
#define TR_COPY_NETWORK_ADDRESS(_D, _S)                                     \
{                                                                           \
    *((ULONG UNALIGNED *)(_D)) = *((ULONG UNALIGNED *)(_S));                \
    *((USHORT UNALIGNED *)((UCHAR *)(_D)+4)) =                              \
                            *((USHORT UNALIGNED *)((UCHAR *)(_S)+4));       \
}

#endif // _X_FILTER_DEFS_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\wxutil.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//
//--------------------------------------------------------------------------;

//
// helper classes and functions for building multimedia filters
//

#ifndef __WXUTIL__
#define __WXUTIL__

// eliminate spurious "statement has no effect" warnings.
#pragma warning(disable: 4705)

// wrapper for whatever critical section we have
class CCritSec {

    // make copy constructor and assignment operator inaccessible

    CCritSec(const CCritSec &refCritSec);
    CCritSec &operator=(const CCritSec &refCritSec);

    CRITICAL_SECTION m_CritSec;

#ifdef DEBUG
public:
    DWORD   m_currentOwner;
    DWORD   m_lockCount;
    BOOL    m_fTrace;        // Trace this one
public:
    CCritSec();
    ~CCritSec();
    void Lock();
    void Unlock();
    BOOL TryAndLock();
#else

public:
    CCritSec() {
        InitializeCriticalSection(&m_CritSec);
    };

    ~CCritSec() {
        DeleteCriticalSection(&m_CritSec);
    };

    void Lock() {
        EnterCriticalSection(&m_CritSec);
    };

    void Unlock() {
        LeaveCriticalSection(&m_CritSec);
    };

    BOOL TryAndLock() {
        return TryEnterCriticalSection(&m_CritSec);
    }
#endif
};

//
// To make deadlocks easier to track it is useful to insert in the
// code an assertion that says whether we own a critical section or
// not.  We make the routines that do the checking globals to avoid
// having different numbers of member functions in the debug and
// retail class implementations of CCritSec.  In addition we provide
// a routine that allows usage of specific critical sections to be
// traced.  This is NOT on by default - there are far too many.
//

#ifdef DEBUG
    BOOL WINAPI CritCheckIn(CCritSec * pcCrit);
    BOOL WINAPI CritCheckIn(const CCritSec * pcCrit);
    BOOL WINAPI CritCheckOut(CCritSec * pcCrit);
    BOOL WINAPI CritCheckOut(const CCritSec * pcCrit);
    void WINAPI DbgLockTrace(CCritSec * pcCrit, BOOL fTrace);
#else
    #define CritCheckIn(x) TRUE
    #define CritCheckOut(x) TRUE
    #define DbgLockTrace(pc, fT)
#endif


// locks a critical section, and unlocks it automatically
// when the lock goes out of scope
class CAutoLock {

    // make copy constructor and assignment operator inaccessible

    CAutoLock(const CAutoLock &refAutoLock);
    CAutoLock &operator=(const CAutoLock &refAutoLock);

protected:
    CCritSec * m_pLock;

public:
    CAutoLock(CCritSec * plock)
    {
        m_pLock = plock;
        m_pLock->Lock();
    };

    ~CAutoLock() {
        m_pLock->Unlock();
    };
};



// wrapper for event objects
class CAMEvent
{

    // make copy constructor and assignment operator inaccessible

    CAMEvent(const CAMEvent &refEvent);
    CAMEvent &operator=(const CAMEvent &refEvent);

protected:
    HANDLE m_hEvent;
public:
    CAMEvent(BOOL fManualReset = FALSE, __inout_opt HRESULT *phr = NULL);
    CAMEvent(__inout_opt HRESULT *phr);
    ~CAMEvent();

    // Cast to HANDLE - we don't support this as an lvalue
    operator HANDLE () const { return m_hEvent; };

    void Set() {EXECUTE_ASSERT(SetEvent(m_hEvent));};
    BOOL Wait(DWORD dwTimeout = INFINITE) {
        return (WaitForSingleObject(m_hEvent, dwTimeout) == WAIT_OBJECT_0);
    };
    void Reset() { ResetEvent(m_hEvent); };
    BOOL Check() { return Wait(0); };
};


// wrapper for event objects that do message processing
// This adds ONE method to the CAMEvent object to allow sent
// messages to be processed while waiting

class CAMMsgEvent : public CAMEvent
{

public:

    CAMMsgEvent(__inout_opt HRESULT *phr = NULL);

    // Allow SEND messages to be processed while waiting
    BOOL WaitMsg(DWORD dwTimeout = INFINITE);
};

// old name supported for the time being
#define CTimeoutEvent CAMEvent

// support for a worker thread

// simple thread class supports creation of worker thread, synchronization
// and communication. Can be derived to simplify parameter passing
class AM_NOVTABLE CAMThread {

    // make copy constructor and assignment operator inaccessible

    CAMThread(const CAMThread &refThread);
    CAMThread &operator=(const CAMThread &refThread);

    CAMEvent m_EventSend;
    CAMEvent m_EventComplete;

    DWORD m_dwParam;
    DWORD m_dwReturnVal;

protected:
    HANDLE m_hThread;

    // thread will run this function on startup
    // must be supplied by derived class
    virtual DWORD ThreadProc() = 0;

public:
    CAMThread(__inout_opt HRESULT *phr = NULL);
    virtual ~CAMThread();

    CCritSec m_AccessLock;  // locks access by client threads
    CCritSec m_WorkerLock;  // locks access to shared objects

    // thread initially runs this. param is actually 'this'. function
    // just gets this and calls ThreadProc
    static DWORD WINAPI InitialThreadProc(__inout LPVOID pv);

    // start thread running  - error if already running
    BOOL Create();

    // signal the thread, and block for a response
    //
    DWORD CallWorker(DWORD);

    // accessor thread calls this when done with thread (having told thread
    // to exit)
    void Close() {
        HANDLE hThread = (HANDLE)InterlockedExchangePointer(&m_hThread, 0);
        if (hThread) {
            WaitForSingleObject(hThread, INFINITE);
            CloseHandle(hThread);
        }
    };

    // ThreadExists
    // Return TRUE if the thread exists. FALSE otherwise
    BOOL ThreadExists(void)
    {
        if (m_hThread == 0)
        {
            return FALSE;
        }
        else
        {
            if (GetThreadId(m_hThread) == 0)
            {
                // Unexpected ... apparently the thread has died
                Close();
                return FALSE;
            }

            return TRUE;
        }
    }

    // wait for the next request
    DWORD GetRequest();

    // is there a request?
    BOOL CheckRequest(__out_opt DWORD * pParam);

    // reply to the request
    void Reply(DWORD);

    // If you want to do WaitForMultipleObjects you'll need to include
    // this handle in your wait list or you won't be responsive
    HANDLE GetRequestHandle() const { return m_EventSend; };

    // Find out what the request was
    DWORD GetRequestParam() const { return m_dwParam; };

    // call CoInitializeEx (COINIT_DISABLE_OLE1DDE) if
    // available. S_FALSE means it's not available.
    static HRESULT CoInitializeHelper();
};


// CQueue
//
// Implements a simple Queue ADT.  The queue contains a finite number of
// objects, access to which is controlled by a semaphore.  The semaphore
// is created with an initial count (N).  Each time an object is added
// a call to WaitForSingleObject is made on the semaphore's handle.  When
// this function returns a slot has been reserved in the queue for the new
// object.  If no slots are available the function blocks until one becomes
// available.  Each time an object is removed from the queue ReleaseSemaphore
// is called on the semaphore's handle, thus freeing a slot in the queue.
// If no objects are present in the queue the function blocks until an
// object has been added.

#define DEFAULT_QUEUESIZE   2

template <class T> class CQueue {
private:
    HANDLE          hSemPut;        // Semaphore controlling queue "putting"
    HANDLE          hSemGet;        // Semaphore controlling queue "getting"
    CRITICAL_SECTION CritSect;      // Thread seriallization
    int             nMax;           // Max objects allowed in queue
    int             iNextPut;       // Array index of next "PutMsg"
    int             iNextGet;       // Array index of next "GetMsg"
    T              *QueueObjects;   // Array of objects (ptr's to void)

    void Initialize(int n) {
        iNextPut = iNextGet = 0;
        nMax = n;
        InitializeCriticalSection(&CritSect);
        hSemPut = CreateSemaphore(NULL, n, n, NULL);
        hSemGet = CreateSemaphore(NULL, 0, n, NULL);
        QueueObjects = new T[n];
    }


public:
    CQueue(int n) {
        Initialize(n);
    }

    CQueue() {
        Initialize(DEFAULT_QUEUESIZE);
    }

    ~CQueue() {
        delete [] QueueObjects;
        DeleteCriticalSection(&CritSect);
        CloseHandle(hSemPut);
        CloseHandle(hSemGet);
    }

    T GetQueueObject() {
        int iSlot;
        T Object;
        LONG lPrevious;

        // Wait for someone to put something on our queue, returns straight
        // away is there is already an object on the queue.
        //
        WaitForSingleObject(hSemGet, INFINITE);

        EnterCriticalSection(&CritSect);
        iSlot = iNextGet++ % nMax;
        Object = QueueObjects[iSlot];
        LeaveCriticalSection(&CritSect);

        // Release anyone waiting to put an object onto our queue as there
        // is now space available in the queue.
        //
        ReleaseSemaphore(hSemPut, 1L, &lPrevious);
        return Object;
    }

    void PutQueueObject(T Object) {
        int iSlot;
        LONG lPrevious;

        // Wait for someone to get something from our queue, returns straight
        // away is there is already an empty slot on the queue.
        //
        WaitForSingleObject(hSemPut, INFINITE);

        EnterCriticalSection(&CritSect);
        iSlot = iNextPut++ % nMax;
        QueueObjects[iSlot] = Object;
        LeaveCriticalSection(&CritSect);

        // Release anyone waiting to remove an object from our queue as there
        // is now an object available to be removed.
        //
        ReleaseSemaphore(hSemGet, 1L, &lPrevious);
    }
};

// miscellaneous string conversion functions
#ifdef UNDER_CE
#define lstrcpynW lstrcpynWInternal
LPWSTR
WINAPI
lstrcpynWInternal(
    LPWSTR lpString1,
    LPCWSTR lpString2,
    int     iMaxLength
    );
#endif // UNDER_CE

extern "C"
void * __stdcall memmoveInternal(void *, const void *, size_t);

inline void * __cdecl memchrInternal(const void *buf, int chr, size_t cnt)
{
#ifdef _X86_
    void *pRet = NULL;

    _asm {
        cld                 // make sure we get the direction right
        mov     ecx, cnt    // num of bytes to scan
        mov     edi, buf    // pointer byte stream
        mov     eax, chr    // byte to scan for
        repne   scasb       // look for the byte in the byte stream
        jnz     exit_memchr // Z flag set if byte found
        dec     edi         // scasb always increments edi even when it
                            // finds the required byte
        mov     pRet, edi
exit_memchr:
    }
    return pRet;

#else
    while ( cnt && (*(unsigned char *)buf != (unsigned char)chr) ) {
        buf = (unsigned char *)buf + 1;
        cnt--;
    }

    return(cnt ? (void *)buf : NULL);
#endif
}

void WINAPI IntToWstr(int i, int cch, LPWSTR wstr);

#define WstrToInt(sz) _wtoi(sz)
#define atoiW(sz) _wtoi(sz)
#define atoiA(sz) atoi(sz)

// These are available to help managing bitmap VIDEOINFOHEADER media structures

extern const DWORD bits555[3];
extern const DWORD bits565[3];
extern const DWORD bits888[3];

// These help convert between VIDEOINFOHEADER/VIDEOINFOHEADER2 and BITMAPINFO structures

STDAPI_(const GUID) GetTrueColorType(const BITMAPINFOHEADER *pbmiHeader);
STDAPI_(const GUID) GetBitmapSubtype(const BITMAPINFOHEADER *pbmiHeader);
STDAPI_(WORD) GetBitCount(const GUID *pSubtype);
STDAPI_(TCHAR *) GetSubtypeName(const GUID *pSubtype);
STDAPI_(LONG) GetBitmapFormatSize(const BITMAPINFOHEADER *pHeader);
STDAPI_(DWORD) GetBitmapSize(const BITMAPINFOHEADER *pHeader);
STDAPI_(BOOL) ContainsPalette(const BITMAPINFOHEADER *pHeader);
STDAPI_(const RGBQUAD *) GetBitmapPalette(const VIDEOINFOHEADER *pVideoInfo);

// Compares two interfaces and returns TRUE if they are on the same object
BOOL WINAPI IsEqualObject(IUnknown *pFirst, IUnknown *pSecond);

// This is for comparing pins
#define EqualPins(pPin1, pPin2) IsEqualObject(pPin1, pPin2)


// Arithmetic helper functions

// Compute (a * b + rnd) / c
LONGLONG WINAPI llMulDiv(LONGLONG a, LONGLONG b, LONGLONG c, LONGLONG rnd);
LONGLONG WINAPI Int64x32Div32(LONGLONG a, LONG b, LONG c, LONG rnd);


// Avoids us dyna-linking to SysAllocString to copy BSTR strings
STDAPI WriteBSTR(__deref_out BSTR * pstrDest, LPCWSTR szSrc);
STDAPI FreeBSTR(__deref_in BSTR* pstr);

// Return a wide string - allocating memory for it
// Returns:
//    S_OK          - no error
//    E_POINTER     - ppszReturn == NULL
//    E_OUTOFMEMORY - can't allocate memory for returned string
STDAPI AMGetWideString(LPCWSTR pszString, __deref_out LPWSTR *ppszReturn);

// Special wait for objects owning windows
DWORD WINAPI WaitDispatchingMessages(
    HANDLE hObject,
    DWORD dwWait,
    HWND hwnd = NULL,
    UINT uMsg = 0,
    HANDLE hEvent = NULL);

// HRESULT_FROM_WIN32 converts ERROR_SUCCESS to a success code, but in
// our use of HRESULT_FROM_WIN32, it typically means a function failed
// to call SetLastError(), and we still want a failure code.
//
#define AmHresultFromWin32(x) (MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, x))

// call GetLastError and return an HRESULT value that will fail the
// SUCCEEDED() macro.
HRESULT AmGetLastErrorToHResult(void);

//
// Corrects the video size using the picture aspect ratio and the screen aspect ratio
//
HRESULT GetAspectCorrectedVideoSize(__in LONG ScreenAspectX, __in LONG ScreenAspectY, __in LONG PictureAspectRatioX, __in LONG PictureAspectRatioY, __inout LONG *pVideoSizeX, __inout LONG *pVideoSizeY);

#endif /* __WXUTIL__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\wxlist.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//
//--------------------------------------------------------------------------;

// Non MFC based generic template list class, December 1994

/* A generic list of pointers to objects.
   No storage management or copying is done on the objects pointed to.
   Objectives: avoid using MFC libraries in ndm kernel mode and
   provide a really useful list type.

   The class is thread safe in that separate threads may add and
   delete items in the list concurrently although the application
   must ensure that constructor and destructor access is suitably
   synchronised. An application can cause deadlock with operations
   which use two lists by simultaneously calling
   list1->Operation(list2) and list2->Operation(list1).  So don't!

   The names must not conflict with MFC classes as an application
   may use both.
   */

#ifndef __WXLIST__
#define __WXLIST__

   /* A POSITION represents (in some fashion that's opaque) a cursor
      on the list that can be set to identify any element.  NULL is
      a valid value and several operations regard NULL as the position
      "one step off the end of the list".  (In an n element list there
      are n+1 places to insert and NULL is that "n+1-th" value).
      The POSITION of an element in the list is only invalidated if
      that element is deleted.  Move operations may mean that what
      was a valid POSITION in one list is now a valid POSITION in
      a different list.

      Some operations which at first sight are illegal are allowed as
      harmless no-ops.  For instance RemoveHead is legal on an empty
      list and it returns NULL.  This allows an atomic way to test if
      there is an element there, and if so, get it.  The two operations
      AddTail and RemoveHead thus implement a MONITOR (See Hoare's paper).

      Single element operations return POSITIONs, non-NULL means it worked.
      whole list operations return a BOOL.  TRUE means it all worked.

      This definition is the same as the POSITION type for MFCs, so we must
      avoid defining it twice.
   */
#ifndef __AFX_H__
struct __POSITION { int unused; };
typedef __POSITION* POSITION;
#endif

const int DEFAULTCACHE = 10;    /* Default node object cache size */

/* A class representing one node in a list.
   Each node knows a pointer to it's adjacent nodes and also a pointer
   to the object that it looks after.
   All of these pointers can be retrieved or set through member functions.
*/
class CBaseList 
#ifdef DEBUG
    : public CBaseObject
#endif
{
    /* Making these classes inherit from CBaseObject does nothing
       functionally but it allows us to check there are no memory
       leaks in debug builds. 
    */

public:

#ifdef DEBUG
    class CNode : public CBaseObject {
#else
    class CNode {
#endif

        CNode *m_pPrev;         /* Previous node in the list */
        CNode *m_pNext;         /* Next node in the list */
        void *m_pObject;      /* Pointer to the object */

    public:

        /* Constructor - initialise the object's pointers */
        CNode()
#ifdef DEBUG
            : CBaseObject(NAME("List node"))
#endif
        {
        };


        /* Return the previous node before this one */
        CNode *Prev() const { return m_pPrev; };


        /* Return the next node after this one */
        CNode *Next() const { return m_pNext; };


        /* Set the previous node before this one */
        void SetPrev(CNode *p) { m_pPrev = p; };


        /* Set the next node after this one */
        void SetNext(CNode *p) { m_pNext = p; };


        /* Get the pointer to the object for this node */
        void *GetData() const { return m_pObject; };


        /* Set the pointer to the object for this node */
        void SetData(void *p) { m_pObject = p; };
    };

    class CNodeCache
    {
    public:
        CNodeCache(INT iCacheSize) : m_iCacheSize(iCacheSize),
                                     m_pHead(NULL),
                                     m_iUsed(0)
                                     {};
        ~CNodeCache() {
            CNode *pNode = m_pHead;
            while (pNode) {
                CNode *pCurrent = pNode;
                pNode = pNode->Next();
                delete pCurrent;
            }
        };
        void AddToCache(CNode *pNode)
        {
            if (m_iUsed < m_iCacheSize) {
                pNode->SetNext(m_pHead);
                m_pHead = pNode;
                m_iUsed++;
            } else {
                delete pNode;
            }
        };
        CNode *RemoveFromCache()
        {
            CNode *pNode = m_pHead;
            if (pNode != NULL) {
                m_pHead = pNode->Next();
                m_iUsed--;
                ASSERT(m_iUsed >= 0);
            } else {
                ASSERT(m_iUsed == 0);
            }
            return pNode;
        };
    private:
        INT m_iCacheSize;
        INT m_iUsed;
        CNode *m_pHead;
    };

protected:

    CNode* m_pFirst;    /* Pointer to first node in the list */
    CNode* m_pLast;     /* Pointer to the last node in the list */
    LONG m_Count;       /* Number of nodes currently in the list */

private:

    CNodeCache m_Cache; /* Cache of unused node pointers */

private:

    /* These override the default copy constructor and assignment
       operator for all list classes. They are in the private class
       declaration section so that anybody trying to pass a list
       object by value will generate a compile time error of
       "cannot access the private member function". If these were
       not here then the compiler will create default constructors
       and assignment operators which when executed first take a
       copy of all member variables and then during destruction
       delete them all. This must not be done for any heap
       allocated data.
    */
    CBaseList(const CBaseList &refList);
    CBaseList &operator=(const CBaseList &refList);

public:

    CBaseList(TCHAR *pName,
              INT iItems);

    CBaseList(TCHAR *pName);

    ~CBaseList();

    /* Remove all the nodes from *this i.e. make the list empty */
    void RemoveAll();


    /* Return a cursor which identifies the first element of *this */
    POSITION GetHeadPositionI() const;


    /* Return a cursor which identifies the last element of *this */
    POSITION GetTailPositionI() const;


    /* Return the number of objects in *this */
    int GetCountI() const;

protected:
    /* Return the pointer to the object at rp,
       Update rp to the next node in *this
       but make it NULL if it was at the end of *this.
       This is a wart retained for backwards compatibility.
       GetPrev is not implemented.
       Use Next, Prev and Get separately.
    */
    void *GetNextI(POSITION& rp) const;


    /* Return a pointer to the object at p
       Asking for the object at NULL will return NULL harmlessly.
    */
    void *GetI(POSITION p) const;

public:
    /* return the next / prev position in *this
       return NULL when going past the end/start.
       Next(NULL) is same as GetHeadPosition()
       Prev(NULL) is same as GetTailPosition()
       An n element list therefore behaves like a n+1 element
       cycle with NULL at the start/end.

       !!WARNING!! - This handling of NULL is DIFFERENT from GetNext.

       Some reasons are:
       1. For a list of n items there are n+1 positions to insert
          These are conveniently encoded as the n POSITIONs and NULL.
       2. If you are keeping a list sorted (fairly common) and you
          search forward for an element to insert before and don't
          find it you finish up with NULL as the element before which
          to insert.  You then want that NULL to be a valid POSITION
          so that you can insert before it and you want that insertion
          point to mean the (n+1)-th one that doesn't have a POSITION.
          (symmetrically if you are working backwards through the list).
       3. It simplifies the algebra which the methods generate.
          e.g. AddBefore(p,x) is identical to AddAfter(Prev(p),x)
          in ALL cases.  All the other arguments probably are reflections
          of the algebraic point.
    */
    POSITION Next(POSITION pos) const
    {
        if (pos == NULL) {
            return (POSITION) m_pFirst;
        }
        CNode *pn = (CNode *) pos;
        return (POSITION) pn->Next();
    } //Next

    // See Next
    POSITION Prev(POSITION pos) const
    {
        if (pos == NULL) {
            return (POSITION) m_pLast;
        }
        CNode *pn = (CNode *) pos;
        return (POSITION) pn->Prev();
    } //Prev


    /* Return the first position in *this which holds the given
       pointer.  Return NULL if the pointer was not not found.
    */
protected:
    POSITION FindI( void * pObj) const;

    // ??? Should there be (or even should there be only)
    // ??? POSITION FindNextAfter(void * pObj, POSITION p)
    // ??? And of course FindPrevBefore too.
    // ??? List.Find(&Obj) then becomes List.FindNextAfter(&Obj, NULL)


    /* Remove the first node in *this (deletes the pointer to its
       object from the list, does not free the object itself).
       Return the pointer to its object.
       If *this was already empty it will harmlessly return NULL.
    */
    void *RemoveHeadI();


    /* Remove the last node in *this (deletes the pointer to its
       object from the list, does not free the object itself).
       Return the pointer to its object.
       If *this was already empty it will harmlessly return NULL.
    */
    void *RemoveTailI();


    /* Remove the node identified by p from the list (deletes the pointer
       to its object from the list, does not free the object itself).
       Asking to Remove the object at NULL will harmlessly return NULL.
       Return the pointer to the object removed.
    */
    void *RemoveI(POSITION p);

    /* Add single object *pObj to become a new last element of the list.
       Return the new tail position, NULL if it fails.
       If you are adding a COM objects, you might want AddRef it first.
       Other existing POSITIONs in *this are still valid
    */
    POSITION AddTailI(void * pObj);
public:


    /* Add all the elements in *pList to the tail of *this.
       This duplicates all the nodes in *pList (i.e. duplicates
       all its pointers to objects).  It does not duplicate the objects.
       If you are adding a list of pointers to a COM object into the list
       it's a good idea to AddRef them all  it when you AddTail it.
       Return TRUE if it all worked, FALSE if it didn't.
       If it fails some elements may have been added.
       Existing POSITIONs in *this are still valid

       If you actually want to MOVE the elements, use MoveToTail instead.
    */
    BOOL AddTail(CBaseList *pList);


    /* Mirror images of AddHead: */

    /* Add single object to become a new first element of the list.
       Return the new head position, NULL if it fails.
       Existing POSITIONs in *this are still valid
    */
protected:
    POSITION AddHeadI(void * pObj);
public:

    /* Add all the elements in *pList to the head of *this.
       Same warnings apply as for AddTail.
       Return TRUE if it all worked, FALSE if it didn't.
       If it fails some of the objects may have been added.

       If you actually want to MOVE the elements, use MoveToHead instead.
    */
    BOOL AddHead(CBaseList *pList);


    /* Add the object *pObj to *this after position p in *this.
       AddAfter(NULL,x) adds x to the start - equivalent to AddHead
       Return the position of the object added, NULL if it failed.
       Existing POSITIONs in *this are undisturbed, including p.
    */
protected:
    POSITION AddAfterI(POSITION p, void * pObj);
public:

    /* Add the list *pList to *this after position p in *this
       AddAfter(NULL,x) adds x to the start - equivalent to AddHead
       Return TRUE if it all worked, FALSE if it didn't.
       If it fails, some of the objects may be added
       Existing POSITIONs in *this are undisturbed, including p.
    */
    BOOL AddAfter(POSITION p, CBaseList *pList);


    /* Mirror images:
       Add the object *pObj to this-List after position p in *this.
       AddBefore(NULL,x) adds x to the end - equivalent to AddTail
       Return the position of the new object, NULL if it fails
       Existing POSITIONs in *this are undisturbed, including p.
    */
    protected:
    POSITION AddBeforeI(POSITION p, void * pObj);
    public:

    /* Add the list *pList to *this before position p in *this
       AddAfter(NULL,x) adds x to the start - equivalent to AddHead
       Return TRUE if it all worked, FALSE if it didn't.
       If it fails, some of the objects may be added
       Existing POSITIONs in *this are undisturbed, including p.
    */
    BOOL AddBefore(POSITION p, CBaseList *pList);


    /* Note that AddAfter(p,x) is equivalent to AddBefore(Next(p),x)
       even in cases where p is NULL or Next(p) is NULL.
       Similarly for mirror images etc.
       This may make it easier to argue about programs.
    */



    /* The following operations do not copy any elements.
       They move existing blocks of elements around by switching pointers.
       They are fairly efficient for long lists as for short lists.
       (Alas, the Count slows things down).

       They split the list into two parts.
       One part remains as the original list, the other part
       is appended to the second list.  There are eight possible
       variations:
       Split the list {after/before} a given element
       keep the {head/tail} portion in the original list
       append the rest to the {head/tail} of the new list.

       Since After is strictly equivalent to Before Next
       we are not in serious need of the Before/After variants.
       That leaves only four.

       If you are processing a list left to right and dumping
       the bits that you have processed into another list as
       you go, the Tail/Tail variant gives the most natural result.
       If you are processing in reverse order, Head/Head is best.

       By using NULL positions and empty lists judiciously either
       of the other two can be built up in two operations.

       The definition of NULL (see Next/Prev etc) means that
       degenerate cases include
          "move all elements to new list"
          "Split a list into two lists"
          "Concatenate two lists"
          (and quite a few no-ops)

       !!WARNING!! The type checking won't buy you much if you get list
       positions muddled up - e.g. use a POSITION that's in a different
       list and see what a mess you get!
    */

    /* Split *this after position p in *this
       Retain as *this the tail portion of the original *this
       Add the head portion to the tail end of *pList
       Return TRUE if it all worked, FALSE if it didn't.

       e.g.
          foo->MoveToTail(foo->GetHeadPosition(), bar);
              moves one element from the head of foo to the tail of bar
          foo->MoveToTail(NULL, bar);
              is a no-op, returns NULL
          foo->MoveToTail(foo->GetTailPosition, bar);
              concatenates foo onto the end of bar and empties foo.

       A better, except excessively long name might be
           MoveElementsFromHeadThroughPositionToOtherTail
    */
    BOOL MoveToTail(POSITION pos, CBaseList *pList);


    /* Mirror image:
       Split *this before position p in *this.
       Retain in *this the head portion of the original *this
       Add the tail portion to the start (i.e. head) of *pList

       e.g.
          foo->MoveToHead(foo->GetTailPosition(), bar);
              moves one element from the tail of foo to the head of bar
          foo->MoveToHead(NULL, bar);
              is a no-op, returns NULL
          foo->MoveToHead(foo->GetHeadPosition, bar);
              concatenates foo onto the start of bar and empties foo.
    */
    BOOL MoveToHead(POSITION pos, CBaseList *pList);


    /* Reverse the order of the [pointers to] objects in *this
    */
    void Reverse();


    /* set cursor to the position of each element of list in turn  */
    #define TRAVERSELIST(list, cursor)               \
    for ( cursor = (list).GetHeadPosition()           \
        ; cursor!=NULL                               \
        ; cursor = (list).Next(cursor)                \
        )


    /* set cursor to the position of each element of list in turn
       in reverse order
    */
    #define REVERSETRAVERSELIST(list, cursor)        \
    for ( cursor = (list).GetTailPosition()           \
        ; cursor!=NULL                               \
        ; cursor = (list).Prev(cursor)                \
        )

}; // end of class declaration

template<class OBJECT> class CGenericList : public CBaseList
{
public:
    CGenericList(TCHAR *pName,
                 INT iItems,
                 BOOL bLock = TRUE,
                 BOOL bAlert = FALSE) :
                     CBaseList(pName, iItems) {
        UNREFERENCED_PARAMETER(bAlert);
        UNREFERENCED_PARAMETER(bLock);
    };
    CGenericList(TCHAR *pName) :
                     CBaseList(pName) {
    };

    POSITION GetHeadPosition() const { return (POSITION)m_pFirst; }
    POSITION GetTailPosition() const { return (POSITION)m_pLast; }
    int GetCount() const { return m_Count; }

    OBJECT *GetNext(POSITION& rp) const { return (OBJECT *) GetNextI(rp); }

    OBJECT *Get(POSITION p) const { return (OBJECT *) GetI(p); }
    OBJECT *GetHead() const  { return Get(GetHeadPosition()); }

    OBJECT *RemoveHead() { return (OBJECT *) RemoveHeadI(); }

    OBJECT *RemoveTail() { return (OBJECT *) RemoveTailI(); }

    OBJECT *Remove(POSITION p) { return (OBJECT *) RemoveI(p); }
    POSITION AddBefore(POSITION p, OBJECT * pObj) { return AddBeforeI(p, pObj); }
    POSITION AddAfter(POSITION p, OBJECT * pObj)  { return AddAfterI(p, pObj); }
    POSITION AddHead(OBJECT * pObj) { return AddHeadI(pObj); }
    POSITION AddTail(OBJECT * pObj)  { return AddTailI(pObj); }
    BOOL AddTail(CGenericList<OBJECT> *pList)
            { return CBaseList::AddTail((CBaseList *) pList); }
    BOOL AddHead(CGenericList<OBJECT> *pList)
            { return CBaseList::AddHead((CBaseList *) pList); }
    BOOL AddAfter(POSITION p, CGenericList<OBJECT> *pList)
            { return CBaseList::AddAfter(p, (CBaseList *) pList); };
    BOOL AddBefore(POSITION p, CGenericList<OBJECT> *pList)
            { return CBaseList::AddBefore(p, (CBaseList *) pList); };
    POSITION Find( OBJECT * pObj) const { return FindI(pObj); }
}; // end of class declaration



/* These define the standard list types */

typedef CGenericList<CBaseObject> CBaseObjectList;
typedef CGenericList<IUnknown> CBaseInterfaceList;

#endif /* __WXLIST__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\wzcmsq.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++


Module Name:

    wzcmsq.h

Abstract:

    Data structures, defines and function prototypes for event logging
    posted by zero config.

Environment:

    

--*/

#ifndef __WZCMSQ_H__
#define __WZCMSQ_H__


//
//  Number that we increase everytime the LOG_ENTRY is
//  modified.   This is to make sure that the client is up to 
//  date with the lates struct entries..
//

#define CURRENT_LOGGING_VERSION     4

//
//  Recommended maximum messages per queue..
//

#define DEFAULT_MAX_MESSAGES        16


//
//  Queue name
//

#define WZC_MSGQUEUE_NAME       TEXT("WzcEventLoggingQueue")

typedef struct 
{  
    DWORD       dwLogId;                    //  WZC_XXX defined below..
    DWORD       dwCurrentLogVersion;        //  To make we are using the correct client..
    UCHAR       pucSSID[33];                //  SSID is 32 byte string, add 1 byte for NULL termination.
    UCHAR       pucBSSID[6];                //  MAC address of the AP we are associated with. 
    DWORD       dwArg;                      //  Misc..
    DWORD       dwInfrastructureMode;       //  Value should be read as NDIS_802_11_NETWORK_INFRASTRUCTURE.
    FILETIME    ftTimeStamp;                //  Time stamp of when log is created.
    TCHAR       ptcAdapterName[MAX_PATH];   //  Adapter name..

}   LOG_ENTRY, *PLOG_ENTRY;



//
//  The dwInfrastructureMode is valid bit for all IDs except
//  WZC_STARTED, WZC_PREFERRED_LIST_EXHAUSTED, WZC_VISIBLE_NETWORK
//
                                                                                                        
//
//  The LogID posted by zero config..
//  For all IDs, ptcAdapterName is always valid.
//

#define WZC_STARTED                     0xffffffff      //  Other args invalid.
#define WZC_ASSOCIATING                 0x00000001      //  Valid pucSSID 
#define WZC_FAILED_ASSOCIATION          0x00000002      //  Valid pucSSID
#define WZC_SUCCESSFUL_ASSOCIATION      0x00000003      //  Valid pucSSID : Valid pucBSSID (for infrastructure only)
#define WZC_CLOSE_EAPOL_SESSION         0x00000004      //  Valid pucSSID
#define WZC_AUTHENTICATING              0x00000005      //  Valid pucSSID : Valid pucBSSID : dwArg1 == Retry number
#define WZC_AUTHENTICATED               0x00000006      //  Valid pucSSID : Valid pucBSSID
#define WZC_CANCEL_AUTH                 0x00000007      //  Valid pucSSID
#define WZC_FAILED_AUTH_NO_RETRY        0x00000008      //  Valid pucSSID : dwArs is always ERROR_CANCELLED.
#define WZC_FAILED_AUTH_WILL_RETRY      0x00000009      //  Valid pucSSID : dwArg == Failure reason.
#define WZC_PREFERED_LIST_EXHAUSTED     0x0000000a      //  None valid.
#define WZC_REAUTHENTICATING            0x0000000b      //  Valid pucSSID ; Valid pucBSSID
#define WZC_VISIBLE_NETWORK             0x0000000c      //  None valid. (this is sent only in WZC_PREFERED_LIST_EXHAUSTED case).
                                                        //      as indication that there is at least one visible network out there.
#define WZC_ASSOCIATED_NO_8021X         WZC_SUCCESSFUL_ASSOCIATION
                                                        //  Valid pucSSID : Valid pucBSSID (for infrastructure only)
                                                    
#define WZC_ASSOCIATED_REQUIRES_8021X   0x0000000d      //  Valid pucSSID : Valid pucBSSID (for infrastructure only) 
#define WZC_CONFIGURED                  0x0000000e      //  Valid pucSSID


#endif  //  __WZCMSQ_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\xmldsodid.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996-1997               **
//*********************************************************************

//;begin_internal
/***********************************************************************************************

  This is a distributed SDK component - do not put any #includes or other directives that rely
  upon files not dropped. If in doubt - build iedev

  If you add comments please include either ;BUGBUG at the beginning of a single line OR
  enclose in a ;begin_internal, ;end_internal block - such as this one!

 ***********************************************************************************************/
//;end_internal

//;begin_internal
#ifndef __XMLDSODID_H__
#define __XMLDSODID_H__
//;end_internal

#define  DISPID_XMLDSO                       0x00010000
#define  DISPID_XMLDSO_DOCUMENT              DISPID_XMLDSO  +  1
#define  DISPID_XMLDSO_JAVADSOCOMPATIBLE     DISPID_XMLDSO_DOCUMENT  +  1

//;begin_internal
#endif // __XMLDSODID_H__
//;end_internal
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\xmlparser.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0543 */
/* Compiler settings for xmlparser.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __xmlparser_h__
#define __xmlparser_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IXMLNodeSource_FWD_DEFINED__
#define __IXMLNodeSource_FWD_DEFINED__
typedef interface IXMLNodeSource IXMLNodeSource;
#endif 	/* __IXMLNodeSource_FWD_DEFINED__ */


#ifndef __IXMLParser_FWD_DEFINED__
#define __IXMLParser_FWD_DEFINED__
typedef interface IXMLParser IXMLParser;
#endif 	/* __IXMLParser_FWD_DEFINED__ */


#ifndef __IXMLParser2_FWD_DEFINED__
#define __IXMLParser2_FWD_DEFINED__
typedef interface IXMLParser2 IXMLParser2;
#endif 	/* __IXMLParser2_FWD_DEFINED__ */


#ifndef __IXMLNodeFactory_FWD_DEFINED__
#define __IXMLNodeFactory_FWD_DEFINED__
typedef interface IXMLNodeFactory IXMLNodeFactory;
#endif 	/* __IXMLNodeFactory_FWD_DEFINED__ */


#ifndef __XMLParser_FWD_DEFINED__
#define __XMLParser_FWD_DEFINED__

#ifdef __cplusplus
typedef class XMLParser XMLParser;
#else
typedef struct XMLParser XMLParser;
#endif /* __cplusplus */

#endif 	/* __XMLParser_FWD_DEFINED__ */


#ifndef __XMLParser26_FWD_DEFINED__
#define __XMLParser26_FWD_DEFINED__

#ifdef __cplusplus
typedef class XMLParser26 XMLParser26;
#else
typedef struct XMLParser26 XMLParser26;
#endif /* __cplusplus */

#endif 	/* __XMLParser26_FWD_DEFINED__ */


#ifndef __XMLParser30_FWD_DEFINED__
#define __XMLParser30_FWD_DEFINED__

#ifdef __cplusplus
typedef class XMLParser30 XMLParser30;
#else
typedef struct XMLParser30 XMLParser30;
#endif /* __cplusplus */

#endif 	/* __XMLParser30_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "objidl.h"
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_xmlparser_0000_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//--------------------------------------------------------------------------




typedef /* [public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0000_0001
    {	XML_ELEMENT	= 1,
	XML_ATTRIBUTE	= ( XML_ELEMENT + 1 ) ,
	XML_PI	= ( XML_ATTRIBUTE + 1 ) ,
	XML_XMLDECL	= ( XML_PI + 1 ) ,
	XML_DOCTYPE	= ( XML_XMLDECL + 1 ) ,
	XML_DTDATTRIBUTE	= ( XML_DOCTYPE + 1 ) ,
	XML_ENTITYDECL	= ( XML_DTDATTRIBUTE + 1 ) ,
	XML_ELEMENTDECL	= ( XML_ENTITYDECL + 1 ) ,
	XML_ATTLISTDECL	= ( XML_ELEMENTDECL + 1 ) ,
	XML_NOTATION	= ( XML_ATTLISTDECL + 1 ) ,
	XML_GROUP	= ( XML_NOTATION + 1 ) ,
	XML_INCLUDESECT	= ( XML_GROUP + 1 ) ,
	XML_PCDATA	= ( XML_INCLUDESECT + 1 ) ,
	XML_CDATA	= ( XML_PCDATA + 1 ) ,
	XML_IGNORESECT	= ( XML_CDATA + 1 ) ,
	XML_COMMENT	= ( XML_IGNORESECT + 1 ) ,
	XML_ENTITYREF	= ( XML_COMMENT + 1 ) ,
	XML_WHITESPACE	= ( XML_ENTITYREF + 1 ) ,
	XML_NAME	= ( XML_WHITESPACE + 1 ) ,
	XML_NMTOKEN	= ( XML_NAME + 1 ) ,
	XML_STRING	= ( XML_NMTOKEN + 1 ) ,
	XML_PEREF	= ( XML_STRING + 1 ) ,
	XML_MODEL	= ( XML_PEREF + 1 ) ,
	XML_ATTDEF	= ( XML_MODEL + 1 ) ,
	XML_ATTTYPE	= ( XML_ATTDEF + 1 ) ,
	XML_ATTPRESENCE	= ( XML_ATTTYPE + 1 ) ,
	XML_DTDSUBSET	= ( XML_ATTPRESENCE + 1 ) ,
	XML_LASTNODETYPE	= ( XML_DTDSUBSET + 1 ) 
    } 	XML_NODE_TYPE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0000_0002
    {	XML_VERSION	= XML_LASTNODETYPE,
	XML_ENCODING	= ( XML_VERSION + 1 ) ,
	XML_STANDALONE	= ( XML_ENCODING + 1 ) ,
	XML_NS	= ( XML_STANDALONE + 1 ) ,
	XML_XMLSPACE	= ( XML_NS + 1 ) ,
	XML_XMLLANG	= ( XML_XMLSPACE + 1 ) ,
	XML_SYSTEM	= ( XML_XMLLANG + 1 ) ,
	XML_PUBLIC	= ( XML_SYSTEM + 1 ) ,
	XML_NDATA	= ( XML_PUBLIC + 1 ) ,
	XML_AT_CDATA	= ( XML_NDATA + 1 ) ,
	XML_AT_ID	= ( XML_AT_CDATA + 1 ) ,
	XML_AT_IDREF	= ( XML_AT_ID + 1 ) ,
	XML_AT_IDREFS	= ( XML_AT_IDREF + 1 ) ,
	XML_AT_ENTITY	= ( XML_AT_IDREFS + 1 ) ,
	XML_AT_ENTITIES	= ( XML_AT_ENTITY + 1 ) ,
	XML_AT_NMTOKEN	= ( XML_AT_ENTITIES + 1 ) ,
	XML_AT_NMTOKENS	= ( XML_AT_NMTOKEN + 1 ) ,
	XML_AT_NOTATION	= ( XML_AT_NMTOKENS + 1 ) ,
	XML_AT_REQUIRED	= ( XML_AT_NOTATION + 1 ) ,
	XML_AT_IMPLIED	= ( XML_AT_REQUIRED + 1 ) ,
	XML_AT_FIXED	= ( XML_AT_IMPLIED + 1 ) ,
	XML_PENTITYDECL	= ( XML_AT_FIXED + 1 ) ,
	XML_EMPTY	= ( XML_PENTITYDECL + 1 ) ,
	XML_ANY	= ( XML_EMPTY + 1 ) ,
	XML_MIXED	= ( XML_ANY + 1 ) ,
	XML_SEQUENCE	= ( XML_MIXED + 1 ) ,
	XML_CHOICE	= ( XML_SEQUENCE + 1 ) ,
	XML_STAR	= ( XML_CHOICE + 1 ) ,
	XML_PLUS	= ( XML_STAR + 1 ) ,
	XML_QUESTIONMARK	= ( XML_PLUS + 1 ) ,
	XML_LASTSUBNODETYPE	= ( XML_QUESTIONMARK + 1 ) 
    } 	XML_NODE_SUBTYPE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0000_0003
    {	XML_E_PARSEERRORBASE	= 0xc00ce500L,
	XML_E_ENDOFINPUT	= XML_E_PARSEERRORBASE,
	XML_E_MISSINGEQUALS	= ( XML_E_ENDOFINPUT + 1 ) ,
	XML_E_MISSINGQUOTE	= ( XML_E_MISSINGEQUALS + 1 ) ,
	XML_E_COMMENTSYNTAX	= ( XML_E_MISSINGQUOTE + 1 ) ,
	XML_E_BADSTARTNAMECHAR	= ( XML_E_COMMENTSYNTAX + 1 ) ,
	XML_E_BADNAMECHAR	= ( XML_E_BADSTARTNAMECHAR + 1 ) ,
	XML_E_BADCHARINSTRING	= ( XML_E_BADNAMECHAR + 1 ) ,
	XML_E_XMLDECLSYNTAX	= ( XML_E_BADCHARINSTRING + 1 ) ,
	XML_E_BADCHARDATA	= ( XML_E_XMLDECLSYNTAX + 1 ) ,
	XML_E_MISSINGWHITESPACE	= ( XML_E_BADCHARDATA + 1 ) ,
	XML_E_EXPECTINGTAGEND	= ( XML_E_MISSINGWHITESPACE + 1 ) ,
	XML_E_BADCHARINDTD	= ( XML_E_EXPECTINGTAGEND + 1 ) ,
	XML_E_BADCHARINDECL	= ( XML_E_BADCHARINDTD + 1 ) ,
	XML_E_MISSINGSEMICOLON	= ( XML_E_BADCHARINDECL + 1 ) ,
	XML_E_BADCHARINENTREF	= ( XML_E_MISSINGSEMICOLON + 1 ) ,
	XML_E_UNBALANCEDPAREN	= ( XML_E_BADCHARINENTREF + 1 ) ,
	XML_E_EXPECTINGOPENBRACKET	= ( XML_E_UNBALANCEDPAREN + 1 ) ,
	XML_E_BADENDCONDSECT	= ( XML_E_EXPECTINGOPENBRACKET + 1 ) ,
	XML_E_INTERNALERROR	= ( XML_E_BADENDCONDSECT + 1 ) ,
	XML_E_UNEXPECTED_WHITESPACE	= ( XML_E_INTERNALERROR + 1 ) ,
	XML_E_INCOMPLETE_ENCODING	= ( XML_E_UNEXPECTED_WHITESPACE + 1 ) ,
	XML_E_BADCHARINMIXEDMODEL	= ( XML_E_INCOMPLETE_ENCODING + 1 ) ,
	XML_E_MISSING_STAR	= ( XML_E_BADCHARINMIXEDMODEL + 1 ) ,
	XML_E_BADCHARINMODEL	= ( XML_E_MISSING_STAR + 1 ) ,
	XML_E_MISSING_PAREN	= ( XML_E_BADCHARINMODEL + 1 ) ,
	XML_E_BADCHARINENUMERATION	= ( XML_E_MISSING_PAREN + 1 ) ,
	XML_E_PIDECLSYNTAX	= ( XML_E_BADCHARINENUMERATION + 1 ) ,
	XML_E_EXPECTINGCLOSEQUOTE	= ( XML_E_PIDECLSYNTAX + 1 ) ,
	XML_E_MULTIPLE_COLONS	= ( XML_E_EXPECTINGCLOSEQUOTE + 1 ) ,
	XML_E_INVALID_DECIMAL	= ( XML_E_MULTIPLE_COLONS + 1 ) ,
	XML_E_INVALID_HEXIDECIMAL	= ( XML_E_INVALID_DECIMAL + 1 ) ,
	XML_E_INVALID_UNICODE	= ( XML_E_INVALID_HEXIDECIMAL + 1 ) ,
	XML_E_WHITESPACEORQUESTIONMARK	= ( XML_E_INVALID_UNICODE + 1 ) ,
	XML_E_ENDOFPE	= ( XML_E_WHITESPACEORQUESTIONMARK + 1 ) ,
	XML_E_TOKEN_ERROR	= ( XML_E_PARSEERRORBASE + 0x50 ) ,
	XML_E_SUSPENDED	= XML_E_TOKEN_ERROR,
	XML_E_STOPPED	= ( XML_E_SUSPENDED + 1 ) ,
	XML_E_UNEXPECTEDENDTAG	= ( XML_E_STOPPED + 1 ) ,
	XML_E_UNCLOSEDTAG	= ( XML_E_UNEXPECTEDENDTAG + 1 ) ,
	XML_E_DUPLICATEATTRIBUTE	= ( XML_E_UNCLOSEDTAG + 1 ) ,
	XML_E_MULTIPLEROOTS	= ( XML_E_DUPLICATEATTRIBUTE + 1 ) ,
	XML_E_INVALIDATROOTLEVEL	= ( XML_E_MULTIPLEROOTS + 1 ) ,
	XML_E_BADXMLDECL	= ( XML_E_INVALIDATROOTLEVEL + 1 ) ,
	XML_E_MISSINGROOT	= ( XML_E_BADXMLDECL + 1 ) ,
	XML_E_UNEXPECTEDEOF	= ( XML_E_MISSINGROOT + 1 ) ,
	XML_E_BADPEREFINSUBSET	= ( XML_E_UNEXPECTEDEOF + 1 ) ,
	XML_E_PE_NESTING	= ( XML_E_BADPEREFINSUBSET + 1 ) ,
	XML_E_INVALID_CDATACLOSINGTAG	= ( XML_E_PE_NESTING + 1 ) ,
	XML_E_UNCLOSEDPI	= ( XML_E_INVALID_CDATACLOSINGTAG + 1 ) ,
	XML_E_UNCLOSEDSTARTTAG	= ( XML_E_UNCLOSEDPI + 1 ) ,
	XML_E_UNCLOSEDENDTAG	= ( XML_E_UNCLOSEDSTARTTAG + 1 ) ,
	XML_E_UNCLOSEDSTRING	= ( XML_E_UNCLOSEDENDTAG + 1 ) ,
	XML_E_UNCLOSEDCOMMENT	= ( XML_E_UNCLOSEDSTRING + 1 ) ,
	XML_E_UNCLOSEDDECL	= ( XML_E_UNCLOSEDCOMMENT + 1 ) ,
	XML_E_UNCLOSEDMARKUPDECL	= ( XML_E_UNCLOSEDDECL + 1 ) ,
	XML_E_UNCLOSEDCDATA	= ( XML_E_UNCLOSEDMARKUPDECL + 1 ) ,
	XML_E_BADDECLNAME	= ( XML_E_UNCLOSEDCDATA + 1 ) ,
	XML_E_BADEXTERNALID	= ( XML_E_BADDECLNAME + 1 ) ,
	XML_E_BADELEMENTINDTD	= ( XML_E_BADEXTERNALID + 1 ) ,
	XML_E_RESERVEDNAMESPACE	= ( XML_E_BADELEMENTINDTD + 1 ) ,
	XML_E_EXPECTING_VERSION	= ( XML_E_RESERVEDNAMESPACE + 1 ) ,
	XML_E_EXPECTING_ENCODING	= ( XML_E_EXPECTING_VERSION + 1 ) ,
	XML_E_EXPECTING_NAME	= ( XML_E_EXPECTING_ENCODING + 1 ) ,
	XML_E_UNEXPECTED_ATTRIBUTE	= ( XML_E_EXPECTING_NAME + 1 ) ,
	XML_E_ENDTAGMISMATCH	= ( XML_E_UNEXPECTED_ATTRIBUTE + 1 ) ,
	XML_E_INVALIDENCODING	= ( XML_E_ENDTAGMISMATCH + 1 ) ,
	XML_E_INVALIDSWITCH	= ( XML_E_INVALIDENCODING + 1 ) ,
	XML_E_EXPECTING_NDATA	= ( XML_E_INVALIDSWITCH + 1 ) ,
	XML_E_INVALID_MODEL	= ( XML_E_EXPECTING_NDATA + 1 ) ,
	XML_E_INVALID_TYPE	= ( XML_E_INVALID_MODEL + 1 ) ,
	XML_E_INVALIDXMLSPACE	= ( XML_E_INVALID_TYPE + 1 ) ,
	XML_E_MULTI_ATTR_VALUE	= ( XML_E_INVALIDXMLSPACE + 1 ) ,
	XML_E_INVALID_PRESENCE	= ( XML_E_MULTI_ATTR_VALUE + 1 ) ,
	XML_E_BADXMLCASE	= ( XML_E_INVALID_PRESENCE + 1 ) ,
	XML_E_CONDSECTINSUBSET	= ( XML_E_BADXMLCASE + 1 ) ,
	XML_E_CDATAINVALID	= ( XML_E_CONDSECTINSUBSET + 1 ) ,
	XML_E_INVALID_STANDALONE	= ( XML_E_CDATAINVALID + 1 ) ,
	XML_E_UNEXPECTED_STANDALONE	= ( XML_E_INVALID_STANDALONE + 1 ) ,
	XML_E_DOCTYPE_IN_DTD	= ( XML_E_UNEXPECTED_STANDALONE + 1 ) ,
	XML_E_MISSING_ENTITY	= ( XML_E_DOCTYPE_IN_DTD + 1 ) ,
	XML_E_ENTITYREF_INNAME	= ( XML_E_MISSING_ENTITY + 1 ) ,
	XML_E_DOCTYPE_OUTSIDE_PROLOG	= ( XML_E_ENTITYREF_INNAME + 1 ) ,
	XML_E_INVALID_VERSION	= ( XML_E_DOCTYPE_OUTSIDE_PROLOG + 1 ) ,
	XML_E_DTDELEMENT_OUTSIDE_DTD	= ( XML_E_INVALID_VERSION + 1 ) ,
	XML_E_DUPLICATEDOCTYPE	= ( XML_E_DTDELEMENT_OUTSIDE_DTD + 1 ) ,
	XML_E_RESOURCE	= ( XML_E_DUPLICATEDOCTYPE + 1 ) ,
	XML_E_MISSINGNAME	= ( XML_E_RESOURCE + 1 ) ,
	XML_E_LASTERROR	= ( XML_E_MISSINGNAME + 1 ) 
    } 	XML_ERROR_CODE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0000_0004
    {	XMLPARSER_IDLE	= 0,
	XMLPARSER_WAITING	= ( XMLPARSER_IDLE + 1 ) ,
	XMLPARSER_BUSY	= ( XMLPARSER_WAITING + 1 ) ,
	XMLPARSER_ERROR	= ( XMLPARSER_BUSY + 1 ) ,
	XMLPARSER_STOPPED	= ( XMLPARSER_ERROR + 1 ) ,
	XMLPARSER_SUSPENDED	= ( XMLPARSER_STOPPED + 1 ) 
    } 	XML_PARSER_STATE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0000_0005
    {	XMLFLAG_FLOATINGAMP	= 0x1,
	XMLFLAG_SHORTENDTAGS	= 0x2,
	XMLFLAG_CASEINSENSITIVE	= 0x4,
	XMLFLAG_NONAMESPACES	= 0x8,
	XMLFLAG_NOWHITESPACE	= 0x10,
	XMLFLAG_IE4QUIRKS	= 0x20,
	XMLFLAG_NODTDNODES	= 0x40,
	XMLFLAG_IE4COMPATIBILITY	= 0xff,
	XMLFLAG_IE5COMPATIBILITY	= 0x100,
	XMLFLAG_SAX	= 0x200,
	XMLFLAG_NORMALIZELB	= 0x400,
	XMLFLAG_IGNOREENCODING	= 0x800,
	XMLFLAG_USEWINHTTP	= 0x1000,
	XMLFLAG_RUNBUFFERONLY	= 0x2000,
	XMLFLAG_PROHIBIT_DTD	= 0x8000
    } 	XML_PARSER_FLAGS;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0000_0006
    {	XMLNF_STARTDOCUMENT	= 0,
	XMLNF_STARTDTD	= ( XMLNF_STARTDOCUMENT + 1 ) ,
	XMLNF_ENDDTD	= ( XMLNF_STARTDTD + 1 ) ,
	XMLNF_STARTDTDSUBSET	= ( XMLNF_ENDDTD + 1 ) ,
	XMLNF_ENDDTDSUBSET	= ( XMLNF_STARTDTDSUBSET + 1 ) ,
	XMLNF_ENDPROLOG	= ( XMLNF_ENDDTDSUBSET + 1 ) ,
	XMLNF_STARTENTITY	= ( XMLNF_ENDPROLOG + 1 ) ,
	XMLNF_ENDENTITY	= ( XMLNF_STARTENTITY + 1 ) ,
	XMLNF_ENDDOCUMENT	= ( XMLNF_ENDENTITY + 1 ) ,
	XMLNF_DATAAVAILABLE	= ( XMLNF_ENDDOCUMENT + 1 ) ,
	XMLNF_LASTEVENT	= XMLNF_DATAAVAILABLE
    } 	XML_NODEFACTORY_EVENT;

typedef struct _XML_NODE_INFO
    {
    DWORD dwSize;
    DWORD dwType;
    DWORD dwSubType;
    BOOL fTerminal;
    const WCHAR *pwcText;
    ULONG ulLen;
    ULONG ulNsPrefixLen;
    PVOID pNode;
    PVOID pReserved;
    } 	XML_NODE_INFO;



extern RPC_IF_HANDLE __MIDL_itf_xmlparser_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_xmlparser_0000_0000_v0_0_s_ifspec;


#ifndef __XMLPSR_LIBRARY_DEFINED__
#define __XMLPSR_LIBRARY_DEFINED__

/* library XMLPSR */
/* [version][lcid][helpstring][uuid] */ 


EXTERN_C const IID LIBID_XMLPSR;

#ifndef __IXMLNodeSource_INTERFACE_DEFINED__
#define __IXMLNodeSource_INTERFACE_DEFINED__

/* interface IXMLNodeSource */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IXMLNodeSource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d242361d-51a0-11d2-9caf-0060b0ec3d39")
    IXMLNodeSource : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFactory( 
            /* [in] */ IXMLNodeFactory *pNodeFactory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFactory( 
            /* [out] */ IXMLNodeFactory **ppNodeFactory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Abort( 
            /* [in] */ BSTR bstrErrorInfo) = 0;
        
        virtual ULONG STDMETHODCALLTYPE GetLineNumber( void) = 0;
        
        virtual ULONG STDMETHODCALLTYPE GetLinePosition( void) = 0;
        
        virtual ULONG STDMETHODCALLTYPE GetAbsolutePosition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLineBuffer( 
            /* [out] */ const WCHAR **ppwcBuf,
            /* [out] */ ULONG *pulLen,
            /* [out] */ ULONG *pulStartPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLastError( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetErrorInfo( 
            /* [out] */ BSTR *pbstrErrorInfo) = 0;
        
        virtual ULONG STDMETHODCALLTYPE GetFlags( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetURL( 
            /* [out] */ const WCHAR **ppwcBuf) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLNodeSourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLNodeSource * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLNodeSource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLNodeSource * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFactory )( 
            IXMLNodeSource * This,
            /* [in] */ IXMLNodeFactory *pNodeFactory);
        
        HRESULT ( STDMETHODCALLTYPE *GetFactory )( 
            IXMLNodeSource * This,
            /* [out] */ IXMLNodeFactory **ppNodeFactory);
        
        HRESULT ( STDMETHODCALLTYPE *Abort )( 
            IXMLNodeSource * This,
            /* [in] */ BSTR bstrErrorInfo);
        
        ULONG ( STDMETHODCALLTYPE *GetLineNumber )( 
            IXMLNodeSource * This);
        
        ULONG ( STDMETHODCALLTYPE *GetLinePosition )( 
            IXMLNodeSource * This);
        
        ULONG ( STDMETHODCALLTYPE *GetAbsolutePosition )( 
            IXMLNodeSource * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetLineBuffer )( 
            IXMLNodeSource * This,
            /* [out] */ const WCHAR **ppwcBuf,
            /* [out] */ ULONG *pulLen,
            /* [out] */ ULONG *pulStartPos);
        
        HRESULT ( STDMETHODCALLTYPE *GetLastError )( 
            IXMLNodeSource * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetErrorInfo )( 
            IXMLNodeSource * This,
            /* [out] */ BSTR *pbstrErrorInfo);
        
        ULONG ( STDMETHODCALLTYPE *GetFlags )( 
            IXMLNodeSource * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetURL )( 
            IXMLNodeSource * This,
            /* [out] */ const WCHAR **ppwcBuf);
        
        END_INTERFACE
    } IXMLNodeSourceVtbl;

    interface IXMLNodeSource
    {
        CONST_VTBL struct IXMLNodeSourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLNodeSource_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXMLNodeSource_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXMLNodeSource_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXMLNodeSource_SetFactory(This,pNodeFactory)	\
    ( (This)->lpVtbl -> SetFactory(This,pNodeFactory) ) 

#define IXMLNodeSource_GetFactory(This,ppNodeFactory)	\
    ( (This)->lpVtbl -> GetFactory(This,ppNodeFactory) ) 

#define IXMLNodeSource_Abort(This,bstrErrorInfo)	\
    ( (This)->lpVtbl -> Abort(This,bstrErrorInfo) ) 

#define IXMLNodeSource_GetLineNumber(This)	\
    ( (This)->lpVtbl -> GetLineNumber(This) ) 

#define IXMLNodeSource_GetLinePosition(This)	\
    ( (This)->lpVtbl -> GetLinePosition(This) ) 

#define IXMLNodeSource_GetAbsolutePosition(This)	\
    ( (This)->lpVtbl -> GetAbsolutePosition(This) ) 

#define IXMLNodeSource_GetLineBuffer(This,ppwcBuf,pulLen,pulStartPos)	\
    ( (This)->lpVtbl -> GetLineBuffer(This,ppwcBuf,pulLen,pulStartPos) ) 

#define IXMLNodeSource_GetLastError(This)	\
    ( (This)->lpVtbl -> GetLastError(This) ) 

#define IXMLNodeSource_GetErrorInfo(This,pbstrErrorInfo)	\
    ( (This)->lpVtbl -> GetErrorInfo(This,pbstrErrorInfo) ) 

#define IXMLNodeSource_GetFlags(This)	\
    ( (This)->lpVtbl -> GetFlags(This) ) 

#define IXMLNodeSource_GetURL(This,ppwcBuf)	\
    ( (This)->lpVtbl -> GetURL(This,ppwcBuf) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXMLNodeSource_INTERFACE_DEFINED__ */


#ifndef __IXMLParser_INTERFACE_DEFINED__
#define __IXMLParser_INTERFACE_DEFINED__

/* interface IXMLParser */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IXMLParser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d242361e-51a0-11d2-9caf-0060b0ec3d39")
    IXMLParser : public IXMLNodeSource
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetURL( 
            /* [in] */ const WCHAR *pszBaseUrl,
            /* [in] */ const WCHAR *pszRelativeUrl,
            /* [in] */ BOOL fAsync) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Load( 
            /* [in] */ BOOL fFullyAvailable,
            /* [in] */ IMoniker *pimkName,
            /* [in] */ LPBC pibc,
            /* [in] */ DWORD grfMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInput( 
            /* [in] */ IUnknown *pStm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PushData( 
            /* [in] */ const char *pData,
            /* [in] */ ULONG ulChars,
            /* [in] */ BOOL fLastBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadDTD( 
            /* [in] */ const WCHAR *pszBaseUrl,
            /* [in] */ const WCHAR *pszRelativeUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadEntity( 
            /* [in] */ const WCHAR *pszBaseUrl,
            /* [in] */ const WCHAR *pszRelativeUrl,
            /* [in] */ BOOL fpe) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ParseEntity( 
            /* [in] */ const WCHAR *pwcText,
            /* [in] */ ULONG ulLen,
            /* [in] */ BOOL fpe) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExpandEntity( 
            /* [in] */ const WCHAR *pwcText,
            /* [in] */ ULONG ulLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRoot( 
            /* [in] */ PVOID pRoot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRoot( 
            /* [in] */ PVOID *ppRoot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Run( 
            /* [in] */ long lChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParserState( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Suspend( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFlags( 
            /* [in] */ ULONG iFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSecureBaseURL( 
            /* [in] */ const WCHAR *pszBaseUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSecureBaseURL( 
            /* [out] */ const WCHAR **ppwcBuf) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLParserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLParser * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLParser * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLParser * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFactory )( 
            IXMLParser * This,
            /* [in] */ IXMLNodeFactory *pNodeFactory);
        
        HRESULT ( STDMETHODCALLTYPE *GetFactory )( 
            IXMLParser * This,
            /* [out] */ IXMLNodeFactory **ppNodeFactory);
        
        HRESULT ( STDMETHODCALLTYPE *Abort )( 
            IXMLParser * This,
            /* [in] */ BSTR bstrErrorInfo);
        
        ULONG ( STDMETHODCALLTYPE *GetLineNumber )( 
            IXMLParser * This);
        
        ULONG ( STDMETHODCALLTYPE *GetLinePosition )( 
            IXMLParser * This);
        
        ULONG ( STDMETHODCALLTYPE *GetAbsolutePosition )( 
            IXMLParser * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetLineBuffer )( 
            IXMLParser * This,
            /* [out] */ const WCHAR **ppwcBuf,
            /* [out] */ ULONG *pulLen,
            /* [out] */ ULONG *pulStartPos);
        
        HRESULT ( STDMETHODCALLTYPE *GetLastError )( 
            IXMLParser * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetErrorInfo )( 
            IXMLParser * This,
            /* [out] */ BSTR *pbstrErrorInfo);
        
        ULONG ( STDMETHODCALLTYPE *GetFlags )( 
            IXMLParser * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetURL )( 
            IXMLParser * This,
            /* [out] */ const WCHAR **ppwcBuf);
        
        HRESULT ( STDMETHODCALLTYPE *SetURL )( 
            IXMLParser * This,
            /* [in] */ const WCHAR *pszBaseUrl,
            /* [in] */ const WCHAR *pszRelativeUrl,
            /* [in] */ BOOL fAsync);
        
        HRESULT ( STDMETHODCALLTYPE *Load )( 
            IXMLParser * This,
            /* [in] */ BOOL fFullyAvailable,
            /* [in] */ IMoniker *pimkName,
            /* [in] */ LPBC pibc,
            /* [in] */ DWORD grfMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetInput )( 
            IXMLParser * This,
            /* [in] */ IUnknown *pStm);
        
        HRESULT ( STDMETHODCALLTYPE *PushData )( 
            IXMLParser * This,
            /* [in] */ const char *pData,
            /* [in] */ ULONG ulChars,
            /* [in] */ BOOL fLastBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *LoadDTD )( 
            IXMLParser * This,
            /* [in] */ const WCHAR *pszBaseUrl,
            /* [in] */ const WCHAR *pszRelativeUrl);
        
        HRESULT ( STDMETHODCALLTYPE *LoadEntity )( 
            IXMLParser * This,
            /* [in] */ const WCHAR *pszBaseUrl,
            /* [in] */ const WCHAR *pszRelativeUrl,
            /* [in] */ BOOL fpe);
        
        HRESULT ( STDMETHODCALLTYPE *ParseEntity )( 
            IXMLParser * This,
            /* [in] */ const WCHAR *pwcText,
            /* [in] */ ULONG ulLen,
            /* [in] */ BOOL fpe);
        
        HRESULT ( STDMETHODCALLTYPE *ExpandEntity )( 
            IXMLParser * This,
            /* [in] */ const WCHAR *pwcText,
            /* [in] */ ULONG ulLen);
        
        HRESULT ( STDMETHODCALLTYPE *SetRoot )( 
            IXMLParser * This,
            /* [in] */ PVOID pRoot);
        
        HRESULT ( STDMETHODCALLTYPE *GetRoot )( 
            IXMLParser * This,
            /* [in] */ PVOID *ppRoot);
        
        HRESULT ( STDMETHODCALLTYPE *Run )( 
            IXMLParser * This,
            /* [in] */ long lChars);
        
        HRESULT ( STDMETHODCALLTYPE *GetParserState )( 
            IXMLParser * This);
        
        HRESULT ( STDMETHODCALLTYPE *Suspend )( 
            IXMLParser * This);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IXMLParser * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFlags )( 
            IXMLParser * This,
            /* [in] */ ULONG iFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetSecureBaseURL )( 
            IXMLParser * This,
            /* [in] */ const WCHAR *pszBaseUrl);
        
        HRESULT ( STDMETHODCALLTYPE *GetSecureBaseURL )( 
            IXMLParser * This,
            /* [out] */ const WCHAR **ppwcBuf);
        
        END_INTERFACE
    } IXMLParserVtbl;

    interface IXMLParser
    {
        CONST_VTBL struct IXMLParserVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLParser_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXMLParser_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXMLParser_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXMLParser_SetFactory(This,pNodeFactory)	\
    ( (This)->lpVtbl -> SetFactory(This,pNodeFactory) ) 

#define IXMLParser_GetFactory(This,ppNodeFactory)	\
    ( (This)->lpVtbl -> GetFactory(This,ppNodeFactory) ) 

#define IXMLParser_Abort(This,bstrErrorInfo)	\
    ( (This)->lpVtbl -> Abort(This,bstrErrorInfo) ) 

#define IXMLParser_GetLineNumber(This)	\
    ( (This)->lpVtbl -> GetLineNumber(This) ) 

#define IXMLParser_GetLinePosition(This)	\
    ( (This)->lpVtbl -> GetLinePosition(This) ) 

#define IXMLParser_GetAbsolutePosition(This)	\
    ( (This)->lpVtbl -> GetAbsolutePosition(This) ) 

#define IXMLParser_GetLineBuffer(This,ppwcBuf,pulLen,pulStartPos)	\
    ( (This)->lpVtbl -> GetLineBuffer(This,ppwcBuf,pulLen,pulStartPos) ) 

#define IXMLParser_GetLastError(This)	\
    ( (This)->lpVtbl -> GetLastError(This) ) 

#define IXMLParser_GetErrorInfo(This,pbstrErrorInfo)	\
    ( (This)->lpVtbl -> GetErrorInfo(This,pbstrErrorInfo) ) 

#define IXMLParser_GetFlags(This)	\
    ( (This)->lpVtbl -> GetFlags(This) ) 

#define IXMLParser_GetURL(This,ppwcBuf)	\
    ( (This)->lpVtbl -> GetURL(This,ppwcBuf) ) 


#define IXMLParser_SetURL(This,pszBaseUrl,pszRelativeUrl,fAsync)	\
    ( (This)->lpVtbl -> SetURL(This,pszBaseUrl,pszRelativeUrl,fAsync) ) 

#define IXMLParser_Load(This,fFullyAvailable,pimkName,pibc,grfMode)	\
    ( (This)->lpVtbl -> Load(This,fFullyAvailable,pimkName,pibc,grfMode) ) 

#define IXMLParser_SetInput(This,pStm)	\
    ( (This)->lpVtbl -> SetInput(This,pStm) ) 

#define IXMLParser_PushData(This,pData,ulChars,fLastBuffer)	\
    ( (This)->lpVtbl -> PushData(This,pData,ulChars,fLastBuffer) ) 

#define IXMLParser_LoadDTD(This,pszBaseUrl,pszRelativeUrl)	\
    ( (This)->lpVtbl -> LoadDTD(This,pszBaseUrl,pszRelativeUrl) ) 

#define IXMLParser_LoadEntity(This,pszBaseUrl,pszRelativeUrl,fpe)	\
    ( (This)->lpVtbl -> LoadEntity(This,pszBaseUrl,pszRelativeUrl,fpe) ) 

#define IXMLParser_ParseEntity(This,pwcText,ulLen,fpe)	\
    ( (This)->lpVtbl -> ParseEntity(This,pwcText,ulLen,fpe) ) 

#define IXMLParser_ExpandEntity(This,pwcText,ulLen)	\
    ( (This)->lpVtbl -> ExpandEntity(This,pwcText,ulLen) ) 

#define IXMLParser_SetRoot(This,pRoot)	\
    ( (This)->lpVtbl -> SetRoot(This,pRoot) ) 

#define IXMLParser_GetRoot(This,ppRoot)	\
    ( (This)->lpVtbl -> GetRoot(This,ppRoot) ) 

#define IXMLParser_Run(This,lChars)	\
    ( (This)->lpVtbl -> Run(This,lChars) ) 

#define IXMLParser_GetParserState(This)	\
    ( (This)->lpVtbl -> GetParserState(This) ) 

#define IXMLParser_Suspend(This)	\
    ( (This)->lpVtbl -> Suspend(This) ) 

#define IXMLParser_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IXMLParser_SetFlags(This,iFlags)	\
    ( (This)->lpVtbl -> SetFlags(This,iFlags) ) 

#define IXMLParser_SetSecureBaseURL(This,pszBaseUrl)	\
    ( (This)->lpVtbl -> SetSecureBaseURL(This,pszBaseUrl) ) 

#define IXMLParser_GetSecureBaseURL(This,ppwcBuf)	\
    ( (This)->lpVtbl -> GetSecureBaseURL(This,ppwcBuf) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXMLParser_INTERFACE_DEFINED__ */


#ifndef __IXMLParser2_INTERFACE_DEFINED__
#define __IXMLParser2_INTERFACE_DEFINED__

/* interface IXMLParser2 */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IXMLParser2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("50fb5b1a-a75c-4ff4-86b2-14c62189e2cc")
    IXMLParser2 : public IXMLParser
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetMaxXmlSize( 
            /* [in] */ ULONG MaxSizeCch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxXmlSize( 
            /* [out] */ ULONG *MaxSizeCch) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLParser2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLParser2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLParser2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLParser2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFactory )( 
            IXMLParser2 * This,
            /* [in] */ IXMLNodeFactory *pNodeFactory);
        
        HRESULT ( STDMETHODCALLTYPE *GetFactory )( 
            IXMLParser2 * This,
            /* [out] */ IXMLNodeFactory **ppNodeFactory);
        
        HRESULT ( STDMETHODCALLTYPE *Abort )( 
            IXMLParser2 * This,
            /* [in] */ BSTR bstrErrorInfo);
        
        ULONG ( STDMETHODCALLTYPE *GetLineNumber )( 
            IXMLParser2 * This);
        
        ULONG ( STDMETHODCALLTYPE *GetLinePosition )( 
            IXMLParser2 * This);
        
        ULONG ( STDMETHODCALLTYPE *GetAbsolutePosition )( 
            IXMLParser2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetLineBuffer )( 
            IXMLParser2 * This,
            /* [out] */ const WCHAR **ppwcBuf,
            /* [out] */ ULONG *pulLen,
            /* [out] */ ULONG *pulStartPos);
        
        HRESULT ( STDMETHODCALLTYPE *GetLastError )( 
            IXMLParser2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetErrorInfo )( 
            IXMLParser2 * This,
            /* [out] */ BSTR *pbstrErrorInfo);
        
        ULONG ( STDMETHODCALLTYPE *GetFlags )( 
            IXMLParser2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetURL )( 
            IXMLParser2 * This,
            /* [out] */ const WCHAR **ppwcBuf);
        
        HRESULT ( STDMETHODCALLTYPE *SetURL )( 
            IXMLParser2 * This,
            /* [in] */ const WCHAR *pszBaseUrl,
            /* [in] */ const WCHAR *pszRelativeUrl,
            /* [in] */ BOOL fAsync);
        
        HRESULT ( STDMETHODCALLTYPE *Load )( 
            IXMLParser2 * This,
            /* [in] */ BOOL fFullyAvailable,
            /* [in] */ IMoniker *pimkName,
            /* [in] */ LPBC pibc,
            /* [in] */ DWORD grfMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetInput )( 
            IXMLParser2 * This,
            /* [in] */ IUnknown *pStm);
        
        HRESULT ( STDMETHODCALLTYPE *PushData )( 
            IXMLParser2 * This,
            /* [in] */ const char *pData,
            /* [in] */ ULONG ulChars,
            /* [in] */ BOOL fLastBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *LoadDTD )( 
            IXMLParser2 * This,
            /* [in] */ const WCHAR *pszBaseUrl,
            /* [in] */ const WCHAR *pszRelativeUrl);
        
        HRESULT ( STDMETHODCALLTYPE *LoadEntity )( 
            IXMLParser2 * This,
            /* [in] */ const WCHAR *pszBaseUrl,
            /* [in] */ const WCHAR *pszRelativeUrl,
            /* [in] */ BOOL fpe);
        
        HRESULT ( STDMETHODCALLTYPE *ParseEntity )( 
            IXMLParser2 * This,
            /* [in] */ const WCHAR *pwcText,
            /* [in] */ ULONG ulLen,
            /* [in] */ BOOL fpe);
        
        HRESULT ( STDMETHODCALLTYPE *ExpandEntity )( 
            IXMLParser2 * This,
            /* [in] */ const WCHAR *pwcText,
            /* [in] */ ULONG ulLen);
        
        HRESULT ( STDMETHODCALLTYPE *SetRoot )( 
            IXMLParser2 * This,
            /* [in] */ PVOID pRoot);
        
        HRESULT ( STDMETHODCALLTYPE *GetRoot )( 
            IXMLParser2 * This,
            /* [in] */ PVOID *ppRoot);
        
        HRESULT ( STDMETHODCALLTYPE *Run )( 
            IXMLParser2 * This,
            /* [in] */ long lChars);
        
        HRESULT ( STDMETHODCALLTYPE *GetParserState )( 
            IXMLParser2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Suspend )( 
            IXMLParser2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IXMLParser2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFlags )( 
            IXMLParser2 * This,
            /* [in] */ ULONG iFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetSecureBaseURL )( 
            IXMLParser2 * This,
            /* [in] */ const WCHAR *pszBaseUrl);
        
        HRESULT ( STDMETHODCALLTYPE *GetSecureBaseURL )( 
            IXMLParser2 * This,
            /* [out] */ const WCHAR **ppwcBuf);
        
        HRESULT ( STDMETHODCALLTYPE *SetMaxXmlSize )( 
            IXMLParser2 * This,
            /* [in] */ ULONG MaxSizeCch);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxXmlSize )( 
            IXMLParser2 * This,
            /* [out] */ ULONG *MaxSizeCch);
        
        END_INTERFACE
    } IXMLParser2Vtbl;

    interface IXMLParser2
    {
        CONST_VTBL struct IXMLParser2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLParser2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXMLParser2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXMLParser2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXMLParser2_SetFactory(This,pNodeFactory)	\
    ( (This)->lpVtbl -> SetFactory(This,pNodeFactory) ) 

#define IXMLParser2_GetFactory(This,ppNodeFactory)	\
    ( (This)->lpVtbl -> GetFactory(This,ppNodeFactory) ) 

#define IXMLParser2_Abort(This,bstrErrorInfo)	\
    ( (This)->lpVtbl -> Abort(This,bstrErrorInfo) ) 

#define IXMLParser2_GetLineNumber(This)	\
    ( (This)->lpVtbl -> GetLineNumber(This) ) 

#define IXMLParser2_GetLinePosition(This)	\
    ( (This)->lpVtbl -> GetLinePosition(This) ) 

#define IXMLParser2_GetAbsolutePosition(This)	\
    ( (This)->lpVtbl -> GetAbsolutePosition(This) ) 

#define IXMLParser2_GetLineBuffer(This,ppwcBuf,pulLen,pulStartPos)	\
    ( (This)->lpVtbl -> GetLineBuffer(This,ppwcBuf,pulLen,pulStartPos) ) 

#define IXMLParser2_GetLastError(This)	\
    ( (This)->lpVtbl -> GetLastError(This) ) 

#define IXMLParser2_GetErrorInfo(This,pbstrErrorInfo)	\
    ( (This)->lpVtbl -> GetErrorInfo(This,pbstrErrorInfo) ) 

#define IXMLParser2_GetFlags(This)	\
    ( (This)->lpVtbl -> GetFlags(This) ) 

#define IXMLParser2_GetURL(This,ppwcBuf)	\
    ( (This)->lpVtbl -> GetURL(This,ppwcBuf) ) 


#define IXMLParser2_SetURL(This,pszBaseUrl,pszRelativeUrl,fAsync)	\
    ( (This)->lpVtbl -> SetURL(This,pszBaseUrl,pszRelativeUrl,fAsync) ) 

#define IXMLParser2_Load(This,fFullyAvailable,pimkName,pibc,grfMode)	\
    ( (This)->lpVtbl -> Load(This,fFullyAvailable,pimkName,pibc,grfMode) ) 

#define IXMLParser2_SetInput(This,pStm)	\
    ( (This)->lpVtbl -> SetInput(This,pStm) ) 

#define IXMLParser2_PushData(This,pData,ulChars,fLastBuffer)	\
    ( (This)->lpVtbl -> PushData(This,pData,ulChars,fLastBuffer) ) 

#define IXMLParser2_LoadDTD(This,pszBaseUrl,pszRelativeUrl)	\
    ( (This)->lpVtbl -> LoadDTD(This,pszBaseUrl,pszRelativeUrl) ) 

#define IXMLParser2_LoadEntity(This,pszBaseUrl,pszRelativeUrl,fpe)	\
    ( (This)->lpVtbl -> LoadEntity(This,pszBaseUrl,pszRelativeUrl,fpe) ) 

#define IXMLParser2_ParseEntity(This,pwcText,ulLen,fpe)	\
    ( (This)->lpVtbl -> ParseEntity(This,pwcText,ulLen,fpe) ) 

#define IXMLParser2_ExpandEntity(This,pwcText,ulLen)	\
    ( (This)->lpVtbl -> ExpandEntity(This,pwcText,ulLen) ) 

#define IXMLParser2_SetRoot(This,pRoot)	\
    ( (This)->lpVtbl -> SetRoot(This,pRoot) ) 

#define IXMLParser2_GetRoot(This,ppRoot)	\
    ( (This)->lpVtbl -> GetRoot(This,ppRoot) ) 

#define IXMLParser2_Run(This,lChars)	\
    ( (This)->lpVtbl -> Run(This,lChars) ) 

#define IXMLParser2_GetParserState(This)	\
    ( (This)->lpVtbl -> GetParserState(This) ) 

#define IXMLParser2_Suspend(This)	\
    ( (This)->lpVtbl -> Suspend(This) ) 

#define IXMLParser2_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IXMLParser2_SetFlags(This,iFlags)	\
    ( (This)->lpVtbl -> SetFlags(This,iFlags) ) 

#define IXMLParser2_SetSecureBaseURL(This,pszBaseUrl)	\
    ( (This)->lpVtbl -> SetSecureBaseURL(This,pszBaseUrl) ) 

#define IXMLParser2_GetSecureBaseURL(This,ppwcBuf)	\
    ( (This)->lpVtbl -> GetSecureBaseURL(This,ppwcBuf) ) 


#define IXMLParser2_SetMaxXmlSize(This,MaxSizeCch)	\
    ( (This)->lpVtbl -> SetMaxXmlSize(This,MaxSizeCch) ) 

#define IXMLParser2_GetMaxXmlSize(This,MaxSizeCch)	\
    ( (This)->lpVtbl -> GetMaxXmlSize(This,MaxSizeCch) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXMLParser2_INTERFACE_DEFINED__ */


#ifndef __IXMLNodeFactory_INTERFACE_DEFINED__
#define __IXMLNodeFactory_INTERFACE_DEFINED__

/* interface IXMLNodeFactory */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IXMLNodeFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d242361f-51a0-11d2-9caf-0060b0ec3d39")
    IXMLNodeFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE NotifyEvent( 
            /* [in] */ IXMLNodeSource *pSource,
            /* [in] */ XML_NODEFACTORY_EVENT iEvt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginChildren( 
            /* [in] */ IXMLNodeSource *pSource,
            /* [in] */ XML_NODE_INFO *pNodeInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndChildren( 
            /* [in] */ IXMLNodeSource *pSource,
            /* [in] */ BOOL fEmpty,
            /* [in] */ XML_NODE_INFO *pNodeInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Error( 
            /* [in] */ IXMLNodeSource *pSource,
            /* [in] */ HRESULT hrErrorCode,
            /* [in] */ USHORT cNumRecs,
            /* [in] */ XML_NODE_INFO **apNodeInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateNode( 
            /* [in] */ IXMLNodeSource *pSource,
            /* [in] */ PVOID pNodeParent,
            /* [in] */ USHORT cNumRecs,
            /* [in] */ XML_NODE_INFO **apNodeInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLNodeFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXMLNodeFactory * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXMLNodeFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXMLNodeFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyEvent )( 
            IXMLNodeFactory * This,
            /* [in] */ IXMLNodeSource *pSource,
            /* [in] */ XML_NODEFACTORY_EVENT iEvt);
        
        HRESULT ( STDMETHODCALLTYPE *BeginChildren )( 
            IXMLNodeFactory * This,
            /* [in] */ IXMLNodeSource *pSource,
            /* [in] */ XML_NODE_INFO *pNodeInfo);
        
        HRESULT ( STDMETHODCALLTYPE *EndChildren )( 
            IXMLNodeFactory * This,
            /* [in] */ IXMLNodeSource *pSource,
            /* [in] */ BOOL fEmpty,
            /* [in] */ XML_NODE_INFO *pNodeInfo);
        
        HRESULT ( STDMETHODCALLTYPE *Error )( 
            IXMLNodeFactory * This,
            /* [in] */ IXMLNodeSource *pSource,
            /* [in] */ HRESULT hrErrorCode,
            /* [in] */ USHORT cNumRecs,
            /* [in] */ XML_NODE_INFO **apNodeInfo);
        
        HRESULT ( STDMETHODCALLTYPE *CreateNode )( 
            IXMLNodeFactory * This,
            /* [in] */ IXMLNodeSource *pSource,
            /* [in] */ PVOID pNodeParent,
            /* [in] */ USHORT cNumRecs,
            /* [in] */ XML_NODE_INFO **apNodeInfo);
        
        END_INTERFACE
    } IXMLNodeFactoryVtbl;

    interface IXMLNodeFactory
    {
        CONST_VTBL struct IXMLNodeFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLNodeFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXMLNodeFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXMLNodeFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXMLNodeFactory_NotifyEvent(This,pSource,iEvt)	\
    ( (This)->lpVtbl -> NotifyEvent(This,pSource,iEvt) ) 

#define IXMLNodeFactory_BeginChildren(This,pSource,pNodeInfo)	\
    ( (This)->lpVtbl -> BeginChildren(This,pSource,pNodeInfo) ) 

#define IXMLNodeFactory_EndChildren(This,pSource,fEmpty,pNodeInfo)	\
    ( (This)->lpVtbl -> EndChildren(This,pSource,fEmpty,pNodeInfo) ) 

#define IXMLNodeFactory_Error(This,pSource,hrErrorCode,cNumRecs,apNodeInfo)	\
    ( (This)->lpVtbl -> Error(This,pSource,hrErrorCode,cNumRecs,apNodeInfo) ) 

#define IXMLNodeFactory_CreateNode(This,pSource,pNodeParent,cNumRecs,apNodeInfo)	\
    ( (This)->lpVtbl -> CreateNode(This,pSource,pNodeParent,cNumRecs,apNodeInfo) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXMLNodeFactory_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_XMLParser;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f19-c551-11d3-89b9-0000f81fe221")
XMLParser;
#endif

EXTERN_C const CLSID CLSID_XMLParser26;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f20-c551-11d3-89b9-0000f81fe221")
XMLParser26;
#endif

EXTERN_C const CLSID CLSID_XMLParser30;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f31-c551-11d3-89b9-0000f81fe221")
XMLParser30;
#endif
#endif /* __XMLPSR_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\yvals.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/* yvals.h values header for Microsoft C/C++ */

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _YVALS
#define _YVALS

#include <libdefs>

#ifdef  _MSC_VER
#pragma pack(push,_CRT_PACKING)
#endif  /* _MSC_VER */

#pragma warning(4: 4018 4114 4146 4244 4245)
#pragma warning(disable: 4237 4284 4290 4514)
        /* NAMESPACE */
#if defined(__cplusplus)
#define _STD          std::
#define _STD_BEGIN    namespace std {
#define _STD_END      };
#define _STD_USING
#else
#define _STD          ::
#define _STD_BEGIN
#define _STD_END
#endif /* __cplusplus */
_STD_BEGIN
        /* TYPE bool */
#if defined(__cplusplus)
typedef bool _Bool;
#endif /* __cplusplus */
        /* INTEGER PROPERTIES */
#define _MAX_EXP_DIG    8   /* for parsing numerics */
#define _MAX_INT_DIG    32
#define _MAX_SIG_DIG    36
        /* STDIO PROPERTIES */
#define _Filet FILEX

#ifndef _FPOS_T_DEFINED
#define _FPOSOFF(fp)    ((long)(fp))
#endif /* _FPOS_T_DEFINED */

        /* NAMING PROPERTIES */
#if defined(__cplusplus)
#define _C_LIB_DECL extern "C" {
#define _END_C_LIB_DECL }
#else
#define _C_LIB_DECL
#define _END_C_LIB_DECL
#endif /* __cplusplus */
#define _CDECL
        // CLASS _Lockit
#if defined(__cplusplus)
class _CRTIMP _Lockit
    {   // lock while object in existence
public:
#ifdef _MT
#define _LOCKIT(x)   lockit x
    _Lockit();
    ~_Lockit();
#else
#define _LOCKIT(x)
    _Lockit()
        {}
    ~_Lockit()
        {}
#endif /* _MT */
    };
#endif /* __cplusplus */
        /* MISCELLANEOUS MACROS */
#define _L(c)   L##c
#define _MAX    _cpp_max
#define _MIN    _cpp_min
_STD_END
#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _YVALS */

/*
 * Copyright (c) 1996 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\ymath.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/* ymath.h internal header */
#ifndef _YMATH
#define _YMATH

#include <math.h>

#ifndef _YVALS
#include <yvals.h>
#endif

        /* MACROS */
#define _FINITE     -1
#define _INFCODE    1
#define _NANCODE    2

        /* TYPE DEFINITIONS */
typedef union {
    unsigned __int16 _W[4];
    float _F;
    double _D;
    long double _L;
    } _Dconst;


// QNAN and SNAN have architecture-specific values

#if defined(_M_IX86) || defined(_M_ARM)

// float NaNs
#define __FNAN_INIT     {1, 0x7fc0, 0, 0}
#define __FSNAN_INIT    {1, 0x7f80, 0, 0}
// double NaNs
#define __NAN_INIT      {1, 0, 0, 0x7ff8}
#define __SNAN_INIT     {1, 0, 0, 0x7ff0}

#elif  defined(_M_MRX000) || defined(_M_SH)

// float NaNs
#define __FNAN_INIT     {1, 0x7f80, 0, 0}
#define __FSNAN_INIT    {1, 0x7fc0, 0, 0}
// double NaNs
#define __NAN_INIT      {1, 0, 0, 0x7ff0}
#define __SNAN_INIT     {1, 0, 0, 0x7ff8}

#else
#error Unknown target architecture
#endif

#define _CRTCONST __declspec(selectany) extern const


_C_LIB_DECL

        /* float DECLARATIONS */
_CRTIMP float __cdecl _FCosh(float, float);
_CRTIMP short __cdecl _FDtest(float *);
_CRTIMP short __cdecl _FExp(float *, float, short);
_CRTIMP float __cdecl _FSinh(float, float);

_CRTCONST _Dconst _FDenorm  = {1, 0, 0, 0};
_CRTCONST _Dconst _FInf     = {0, 0x7f80, 0, 0};
_CRTCONST _Dconst _FNan     = __FNAN_INIT;
_CRTCONST _Dconst _FSnan    = __FSNAN_INIT;

        /* double DECLARATIONS */
_CRTIMP double __cdecl _Cosh(double, double);
_CRTIMP short __cdecl _Dtest(double *);
_CRTIMP short __cdecl _Exp(double *, double, short);
_CRTIMP double __cdecl _Sinh(double, double);

_CRTCONST _Dconst _Denorm   = {1, 0, 0, 0};
_CRTCONST _Dconst _Inf      = {0, 0, 0, 0x7ff0};
_CRTCONST _Dconst _Nan      = __NAN_INIT;
_CRTCONST _Dconst _Snan     = __SNAN_INIT;

        /* long double DECLARATIONS */
_CRTIMP long double __cdecl _LCosh(long double, long double);
_CRTIMP short __cdecl _LDtest(long double *);
_CRTIMP short __cdecl _LExp(long double *, long double, short);
_CRTIMP long double __cdecl _LSinh(long double, long double);

// 'long double' is identical with 'double'
_CRTCONST _Dconst _LDenorm  = {1, 0, 0, 0};
_CRTCONST _Dconst _LInf     = {0, 0, 0, 0x7ff0};
_CRTCONST _Dconst _LNan     = __NAN_INIT;
_CRTCONST _Dconst _LSnan    = __SNAN_INIT;

_END_C_LIB_DECL


#undef __FNAN_INIT
#undef __FSNAN_INIT
#undef __NAN_INIT
#undef __SNAN_INIT
#undef _CRTCONST

#endif /* _YMATH */

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\codeanalysis\Warnings.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
#pragma once
#define ALL_CODE_ANALYSIS_WARNINGS 6001 6011 6029 6031 6053 6054 6057 6059 6063 6064 6066 6067 6200 6201 6202 6203 6204 6209 6211 6214 6215 6216 6217 6219 6220 6221 6225 6226 6230 6235 6236 6237 6239 6240 6242 6244 6246 6248 6250 6255 6258 6259 6260 6262 6263 6268 6269 6270 6271 6272 6273 6274 6276 6277 6278 6279 6280 6281 6282 6283 6284 6285 6286 6287 6288 6289 6290 6291 6292 6293 6294 6295 6296 6297 6298 6299 6302 6303 6305 6306 6308 6309 6310 6312 6313 6314 6315 6316 6317 6318 6319 6320 6322 6323 6324 6326 6327 6328 6329 6331 6332 6333 6334 6335 6336 6381 6383 6384 6385 6386 6387 6388 6400 6401 6500 6501 6503 6504 6505 6506 6507 6508 6509 6510 6511 6512 6513 6514 6515 6516 6517 6518 6521 6522 6523 6525 6526 6530 6535 6540 6990 6991 6992 6993 6994 6995
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\codeanalysis\sourceannotations.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
#if _MSC_VER >= 1400

#pragma once

#ifndef _M_CEE_SAFE  // Source annotation attributes don't work with /clr:safe

#if !defined(_W64)
#if !defined(__midl) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


#pragma push_macro( "SA" )
#pragma push_macro( "REPEATABLE" )

#ifdef __cplusplus
#define SA( id ) id
#define REPEATABLE [repeatable]
#else  // !__cplusplus
#define SA( id ) SA_##id
#define REPEATABLE
#endif  // !__cplusplus

#ifdef __cplusplus
namespace vc_attributes
{
#endif  // __cplusplus

enum SA( YesNoMaybe )
{
	// Choose values that we can detect as invalid if they are or'd together
	SA( No ) = 0x0fff0001,
	SA( Maybe ) = 0x0fff0010,
	SA( Yes ) = 0x0fff0100
};

typedef enum SA( YesNoMaybe ) SA( YesNoMaybe );

enum SA( AccessType )
{
	SA( NoAccess ) = 0,
	SA( Read ) = 1,
	SA( Write ) = 2,
	SA( ReadWrite ) = 3
};

typedef enum SA( AccessType ) SA( AccessType );

#ifndef SAL_NO_ATTRIBUTE_DECLARATIONS

REPEATABLE
[source_annotation_attribute( SA( Parameter ) )]
struct PreAttribute
{
#ifdef __cplusplus
	PreAttribute();
#endif

	unsigned int Deref;
	SA( YesNoMaybe ) Valid;
	SA( YesNoMaybe ) Null;
	SA( YesNoMaybe ) Tainted;
	SA( AccessType ) Access;
	size_t ValidElementsConst;
	size_t ValidBytesConst;
	const wchar_t* ValidElements;
	const wchar_t* ValidBytes;
	const wchar_t* ValidElementsLength;
	const wchar_t* ValidBytesLength;
	size_t WritableElementsConst;
	size_t WritableBytesConst;
	const wchar_t* WritableElements;
	const wchar_t* WritableBytes;
	const wchar_t* WritableElementsLength;
	const wchar_t* WritableBytesLength;
	size_t ElementSizeConst;
	const wchar_t* ElementSize;
	SA( YesNoMaybe ) NullTerminated;
	const wchar_t* Condition;
};

REPEATABLE
[source_annotation_attribute( SA( Parameter )|SA( ReturnValue ) )]
struct PostAttribute
{
#ifdef __cplusplus
	PostAttribute();
#endif

	unsigned int Deref;
	SA( YesNoMaybe ) Valid;
	SA( YesNoMaybe ) Null;
	SA( YesNoMaybe ) Tainted;
	SA( AccessType ) Access;
	size_t ValidElementsConst;
	size_t ValidBytesConst;
	const wchar_t* ValidElements;
	const wchar_t* ValidBytes;
	const wchar_t* ValidElementsLength;
	const wchar_t* ValidBytesLength;
	size_t WritableElementsConst;
	size_t WritableBytesConst;
	const wchar_t* WritableElements;
	const wchar_t* WritableBytes;
	const wchar_t* WritableElementsLength;
	const wchar_t* WritableBytesLength;
	size_t ElementSizeConst;
	const wchar_t* ElementSize;
	SA( YesNoMaybe ) NullTerminated;
	SA( YesNoMaybe ) MustCheck;
	const wchar_t* Condition;
};

[source_annotation_attribute( SA( Parameter ) )]
struct FormatStringAttribute
{
#ifdef __cplusplus
	FormatStringAttribute();
#endif

	const wchar_t* Style;
	const wchar_t* UnformattedAlternative;
};

REPEATABLE
[source_annotation_attribute( SA( ReturnValue ) )]
struct InvalidCheckAttribute
{
#ifdef __cplusplus
	InvalidCheckAttribute();
#endif

	long Value;
};

[source_annotation_attribute( SA( Method ) )]
struct SuccessAttribute
{
#ifdef __cplusplus
	SuccessAttribute();
#endif

	const wchar_t* Condition;
};

REPEATABLE
[source_annotation_attribute( SA( Parameter ) )]
struct PreBoundAttribute
{
#ifdef __cplusplus
	PreBoundAttribute();
#endif
	unsigned int Deref;
};

REPEATABLE
[source_annotation_attribute( SA( Parameter )|SA( ReturnValue ) )]
struct PostBoundAttribute
{
#ifdef __cplusplus
	PostBoundAttribute();
#endif
	unsigned int Deref;
};

REPEATABLE
[source_annotation_attribute( SA( Parameter ) )]
struct PreRangeAttribute
{
#ifdef __cplusplus
	PreRangeAttribute();
#endif
	unsigned int Deref;
	const char* MinVal;
	const char* MaxVal;
};

REPEATABLE
[source_annotation_attribute( SA( Parameter )|SA( ReturnValue ) )]
struct PostRangeAttribute
{
#ifdef __cplusplus
	PostRangeAttribute();
#endif
	unsigned int Deref;
	const char* MinVal;
	const char* MaxVal;
};

#endif  // !SAL_NO_ATTRIBUTE_DECLARATIONS

#ifdef __cplusplus
};  // namespace vc_attributes
#endif  // __cplusplus

#pragma pop_macro( "REPEATABLE" )
#pragma pop_macro( "SA" )

#ifdef __cplusplus

#define SA_All All
#define SA_Class Class
#define SA_Constructor Constructor
#define SA_Delegate Delegate
#define SA_Enum Enum
#define SA_Event Event
#define SA_Field Field
#define SA_GenericParameter GenericParameter
#define SA_Interface Interface
#define SA_Method Method
#define SA_Module Module
#define SA_Parameter Parameter
#define SA_Property Property
#define SA_ReturnValue ReturnValue
#define SA_Struct Struct

typedef ::vc_attributes::YesNoMaybe SA_YesNoMaybe;
const ::vc_attributes::YesNoMaybe SA_Yes = ::vc_attributes::Yes;
const ::vc_attributes::YesNoMaybe SA_No = ::vc_attributes::No;
const ::vc_attributes::YesNoMaybe SA_Maybe = ::vc_attributes::Maybe;

typedef ::vc_attributes::AccessType SA_AccessType;
const ::vc_attributes::AccessType SA_NoAccess = ::vc_attributes::NoAccess;
const ::vc_attributes::AccessType SA_Read = ::vc_attributes::Read;
const ::vc_attributes::AccessType SA_Write = ::vc_attributes::Write;
const ::vc_attributes::AccessType SA_ReadWrite = ::vc_attributes::ReadWrite;

#ifndef SAL_NO_ATTRIBUTE_DECLARATIONS
typedef ::vc_attributes::PreAttribute          SA_Pre;
typedef ::vc_attributes::PostAttribute         SA_Post;
typedef ::vc_attributes::FormatStringAttribute SA_FormatString;
typedef ::vc_attributes::InvalidCheckAttribute SA_InvalidCheck; /*???*/
typedef ::vc_attributes::SuccessAttribute      SA_Success;
typedef ::vc_attributes::PreBoundAttribute     SA_PreBound;
typedef ::vc_attributes::PostBoundAttribute    SA_PostBound;
typedef ::vc_attributes::PreRangeAttribute     SA_PreRange;
typedef ::vc_attributes::PostRangeAttribute    SA_PostRange;
#endif //!SAL_NO_ATTRIBUTE_DECLARATIONS

#else  // !__cplusplus

typedef struct PreAttribute SA_Pre;
typedef struct PreAttribute PreAttribute;
typedef struct PostAttribute SA_Post;
typedef struct PostAttribute PostAttribute;
typedef struct FormatStringAttribute SA_FormatString;
typedef struct InvalidCheckAttribute SA_InvalidCheck; /*???*/
typedef struct SuccessAttribute      SA_Success;
typedef struct PreBoundAttribute     SA_PreBound;
typedef struct PostBoundAttribute    SA_PostBound;
typedef struct PreRangeAttribute     SA_PreRange;
typedef struct PostRangeAttribute    SA_PostRange;

#endif  // __cplusplus

#endif  // !_M_CEE_SAFE

#ifdef _MANAGED

#ifdef CODE_ANALYSIS
#define SA_SUPPRESS_MESSAGE( category, id, ... ) [::System::Diagnostics::CodeAnalysis::SuppressMessage( category, id, __VA_ARGS__ )]
#define CA_SUPPRESS_MESSAGE( ... ) [System::Diagnostics::CodeAnalysis::SuppressMessage( __VA_ARGS__ )]
#define CA_GLOBAL_SUPPRESS_MESSAGE( ... ) [assembly:System::Diagnostics::CodeAnalysis::SuppressMessage( __VA_ARGS__ )]
#else  // !CODE_ANALYSIS
#define SA_SUPPRESS_MESSAGE( category, id, ... )
#define CA_SUPPRESS_MESSAGE( ... )
#define CA_GLOBAL_SUPPRESS_MESSAGE( ... ) 
#endif  // !CODE_ANALYSIS

#endif  // _MANAGED

// Windows SDK Update Vista Beta2 (June 2006): __analysis_assume defined by specstrings.h
#ifdef _PREFAST_
// #define __analysis_assume(expr) __assume(expr)
#else  // !_PREFAST_
// #define __analysis_assume(expr) 
#endif  // _PREFAST_


#endif  // _MSC_VER >= 1400
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\tux\Include\cmdline.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
// --------------------------------------------------------------------
//                                                                     
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A      
// PARTICULAR PURPOSE.                                                 
//                                                                     
// --------------------------------------------------------------------
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
@doc LIBRARY


Module Name:
    cmdline.h

Abstract:
    Declaration of command line parsing helper functions

-------------------------------------------------------------------*/
#ifndef __COMMAND_LINE_H__
#define __COMMAND_LINE_H__

#include <windows.h>
#include <tchar.h>

#ifdef __cplusplus
extern "C" {
#endif

//
//  @func extern "C" void | SetOptionChars |  
//  Sets the characters interpreted as option characters (e.g. '-', '/', etc.)
//
//  @rdesc None.
//
//  @parm  IN int                    | NumChars  |  Number of arguments.
//  @parm  IN TCHAR *                | CharArray |  An array of characters
//
//  @comm:(LIBRARY)
//  This function sets the option characters interpreted by the option parsing functions (e.g. WasOption).
//  By default, the option characters are '-' and '/'.  A maximum of 5 option characters can be specified.
//	To enable parsing of every argument with the option functions, set NumChars to 0.
//
//  For example:
//  Command Line: testexe -svr 157.59.28.250 /thrd 2 :Cycle100 -f -x -h
//  
//  int i;
//	TCHAR OptionChars[3] = {'-', '/', ':'}; 
//
//  SetOptionChars(3, OptionChars);
//  if( (i = WasOption(argc, argv, TEXT("x"))) >= 0 )
//		printf("'x' was specified in argument %d\n", i);
//  if( (i = WasOption(argc, argv, TEXT("thrd"))) >= 0 )
//		printf("'thrd' was specified in argument %d\n", i);
//  if( (i = WasOption(argc, argv, TEXT("cycle"))) >= 0 )
//		printf("'cycle' was specified in argument %d\n", i);
//
//  Ouput:
//  'x' was specified in argument 7
//  'thrd' was specified in argument 3
//  'cycle' was specified in argument 5
//
//  <f WasOption> <f GetOption> <f GetOptonAsInt> <f CommandLineToArgs>
// 
//  @comm:(INTERNAL)
//  KNOWN ISSUES<nl>
//  None.

void SetOptionChars(int NumChars, TCHAR *CharArray);

//
//  @func extern "C" int | WasOption |  
//  Returns whether or not the option specified was given on the command line. 
//
//  @rdesc The argument index of the last specified option if it was given
//	on the command line (case insensitive).  -1 if the option was
//	not specified.  A larger negative return value indicates an error occurred.
//
//  @parm  IN int                    | argc      |  Number of arguments.
//  @parm  IN LPTSTR *               | argv      |  An array of pointers to the null-terminated arguments.
//  @parm  IN LPCTSTR                | pszOption |  A pointer to the desired option.
//
//  @comm:(LIBRARY)
//  This function parses through the given command line (in argc/argv format) looking for the desired 
//  option.  It returns the index of the last instance of the option in the given argv array.
//
//  For example:
//  Command Line: testexe -svr 157.59.28.250 -thrd 2 -Cycle100 -f -x -h
//  
//  int i;
//  if( (i = WasOption(argc, argv, TEXT("x"))) >= 0 )
//		printf("'x' was specified in argument %d\n", i);
//  if( (i = WasOption(argc, argv, TEXT("thrd"))) >= 0 )
//		printf("'thrd' was specified in argument %d\n", i);
//
//  Ouput:
//  'x' was specified in argument 7
//  'thrd' was specified in argument 3
//
//  <f GetOption> <f GetOptonAsInt> <f CommandLineToArgs>

int WasOption(int argc, LPTSTR argv[], LPCTSTR pszOption);

//
//  @func extern "C" void | StrictOptionsOnly |  
//  Forces the use of only strict options on the command line.
//
//  @rdesc None.
//
//  @parm  IN BOOL                    |      bStrict    |  TRUE for using strict options only.
//
//  @comm:(LIBRARY)
//  If bStrict is TRUE, future calls to the GetOption and GetOptionAsInt will only
//  recognize options of the form "<option flag><option code> <option>" instead of both those and
//  those of the form "<option flag><option code> <option>".  
//
//  Set this option if you want to have option code which are sub-strings of other option codes.
//  Otherwise the GetOption functions cannot tell the difference between -srv and -sRV (in the
//  first case the option code is "srv" and there is no option, in the second the option code is
//  "s" and the option is "RV")
//
//  For example:
//  Command Line: testexe -svr 157.59.28.250 -thrd 2 -Cycle100 -f -x -h
//  
//  LPTSTR szArg = NULL;
//  if(GetOption(argc, argv, TEXT("cycle"), &szArg) >= 0)
//  	_tprintf(L"cycle = %s\n", szArg);
//  else
//      _tprintf(L"No cycle option found.\n");
//
//	StrictOptionsOnly(TRUE);
//  
//  if(GetOption(argc, argv, TEXT("cycle"), &szArg) >= 0)
//		_tprintf(L"cycle = %s\n", szArg);
//  else
//      _tprintf(L"No cycle option found.\n");
//
//  Ouput:
//  cycle = 100
//  No cycle option found.
//
//  <f WasOption> <f GetOpton> <f GetOptonAsInt> <f CommandLineToArgs>
// 
//  @comm:(INTERNAL)
//  KNOWN ISSUES<nl>
//  None.

void StrictOptionsOnly(BOOL bStrict);

//
//  @func extern "C" int | GetOption |  
//  Returns the argument of a specified option.
//
//  @rdesc A non-negative number for SUCCESS.  -1 if the option/argument was
//	not specified.  A larger negative return value indicates an error occurred.
//
//  @parm  IN int                    | argc         |  Number of arguments.
//  @parm  IN LPTSTR *               | argv         |  An array of pointers to the null-terminated arguments.
//  @parm  IN LPCTSTR                | pszOption    |  A pointer to the desired option.
//  @parm  OUT LPTSTR *              | ppszArgument |  Address of the pointer that will point to the argument of the desired option.
//
//  @comm:(LIBRARY)
//  This function parses through the given command line (in argc/argv format) looking for the desired 
//  option.  It returns (via the OUT parameter) a pointer to the argument of the specified option.
//
//  For example:
//  Command Line: testexe -svr 157.59.28.250 -thrd 2 -Cycle100 -f -x -h
//  
//  LPTSTR szArg = NULL;
//  if(GetOption(argc, argv, TEXT("svr"), &szArg) >= 0)
//  	_tprintf(L"svr = %s\n", szArg);
//  if(GetOption(argc, argv, TEXT("cycle"), &szArg) >= 0)
//		_tprintf(L"cycle = %s\n", szArg);
//
//  Ouput:
//  svr = 157.59.28.250
//  cycle = 100
//
//  <f WasOption> <f GetOptonAsInt> <f GetOptionAsDWORD> <f CommandLineToArgs>
// 
//  @comm:(INTERNAL)
//  KNOWN ISSUES<nl>
//  None.

int GetOption(int argc, LPTSTR argv[], LPCTSTR pszOption, LPTSTR *ppszArgument);

//
//  @func extern "C" BOOL | IsStringInt |  
//  Checks to see if the given string is an integer.
//
//  @rdesc TRUE if the given string is an integer.  FALSE if it is not, or if
//	an error occurred.
//
//  @parm  IN LPCTSTR                | pszNum   |  A pointer to the string.
//
//  @comm:(LIBRARY)
//  This function checks to see if the string passed in is a valid integer ( Ok to pass to _ttoi ).
//
//  For example:
//  
//  LPTSTR szNum1 = _T("1000");
//  LPTSTR szNum2 = _T("-2000");
//  LPTSTR szNum3 = _T("1a");
//  if(IsStringInt(szNum1))
//  	_tprintf(L"%s\n", szNum1);
//  if(IsStringInt(szNum2))
//		_tprintf(L"%s\n", szNum2);
//  if(IsStringInt(szNum3))
//		_tprintf(L"%s\n", szNum3);
//
//  Ouput:
//  1000
//  -2000
// 
//  @comm:(INTERNAL)
//  KNOWN ISSUES<nl>
//  None.

BOOL IsStringInt( LPCTSTR szNum );

//
//  @func extern "C" int | GetOptionAsInt |  
//  Returns the argument of a specified option.
//
//  @rdesc A non-negative number for SUCCESS.  -1 if the option/argument was
//	not specified.  A larger negative return value indicates an error occurred.
//
//  @parm  IN int                    | argc       |  Number of arguments.
//  @parm  IN LPTSTR *               | argv       |  An array of pointers to the null-terminated arguments.
//  @parm  IN LPCTSTR                | pszOption  |  A pointer to the desired option.
//  @parm  OUT int *                 | piArgument |  Pointer to an integer that will take the argument of the desired option.
//
//  @comm:(LIBRARY)
//  This function parses through the given command line (in argc/argv format) looking for the desired 
//  option.  It returns (via the OUT parameter) the value of the option's argument as an integer.
//
//  For example:
//  Command Line: testexe -svr 157.59.28.250 -thrd 2 -Cycle100 -f -x -h
//  
//  int iValue = 0;
//  if(GetOptionAsInt(argc, argv, TEXT("thrd"), &iValue) >= 0)
//		_tprintf(L"thrd = %d\n", iValue);
//  if(GetOptionAsInt(argc, argv, TEXT("cycle"), &iValue) >= 0)
//		_tprintf(L"cycle = %d\n", iValue);
//
//  Ouput:
//  thrd = 2
//  cycle = 100
//
//  <f IsStringInt> <f WasOption> <f GetOption> <f GetOptionAsDWORD> <f CommandLineToArgs>
// 
//  @comm:(INTERNAL)
//  KNOWN ISSUES<nl>
//  None.

int GetOptionAsInt(int argc, LPTSTR argv[], LPCTSTR pszOption, int *piArgument);

//
//  @func extern "C" int | GetOptionAsDWORD |  
//  Returns the argument of a specified option.
//
//  @rdesc A non-negative number for SUCCESS.  -1 if the option/argument was
//	not specified.  A larger negative return value indicates an error occurred.
//
//  @parm  IN int                    | argc        |  Number of arguments.
//  @parm  IN LPTSTR *               | argv        |  An array of pointers to the null-terminated arguments.
//  @parm  IN LPCTSTR                | pszOption   |  A pointer to the desired option.
//  @parm  OUT DWORD *               | pdwArgument |  Pointer to a DWORD that will take the argument of the desired option.
//
//  @comm:(LIBRARY)
//  This function parses through the given command line (in argc/argv format) looking for the desired 
//  option.  It returns (via the OUT parameter) the value of the option's argument as a DWORD.
//
//  For example:
//  Command Line: testexe -svr 157.59.28.250 -thrd 2 -Cycle0xFFFFFFFF -f -x -h
//  
//  DWORD dwValue = 0;
//  if(GetOptionAsDWORD(argc, argv, TEXT("thrd"), &dwValue) >= 0)
//		_tprintf(L"thrd = %u\n", dwValue);
//  if(GetOptionAsDWORD(argc, argv, TEXT("cycle"), &dwValue) >= 0)
//		_tprintf(L"cycle = %u\n", dwValue);
//
//  Ouput:
//  thrd = 2
//  cycle = 4294967295
//
//  <f IsStringInt> <f WasOption> <f GetOption> <f GetOptionAsInt> <f CommandLineToArgs>
// 
//  @comm:(INTERNAL)
//  KNOWN ISSUES<nl>
//  None.

extern "C" int GetOptionAsDWORD(int argc, LPTSTR argv[], LPCTSTR pszOption, DWORD *pdwArgument);

//
//  @func extern "C" void | CommandLineToArgs |  
//  Parses the given command line into an arc/argv format.
//
//  @rdesc None.
//
//  @parm  IN TCHAR *                | szCommandLine |  The command line.
//  @parm  IN OUT int *              | argc          |  Number of arguments.
//  @parm  OUT LPTSTR *              | argv          |  An array of string pointers.
//
//  @comm:(LIBRARY)
//  This function parses through the given command line and breaks it up (in place)
//  into an argc/argv format.  The argc parameter should be initially set to the number
//  of pointers in the argv array.
//
//  For example:
//  
//  int argc;
//  LPTSTR argv[64];
//  argc = 64;
//  CommandLineToArgs(lpszCommandline, &argc, argv);
//
//  <f WasOption> <f GetOption> <f GetOptionAsInt> <f GetOptionAsDWORD>
// 
//  @comm:(INTERNAL)
//  KNOWN ISSUES<nl>
//  None.

void CommandLineToArgs(TCHAR szCommandLine[], int *argc, LPTSTR argv[]);

#ifdef __cplusplus
}
#endif

#endif // __COMMAND_LINE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\tux\Include\dbptags.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
// --------------------------------------------------------------------
//                                                                     
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A      
// PARTICULAR PURPOSE.                                                 
//                                                                     
// --------------------------------------------------------------------
//******************************************************************************
//
// DBPTAGS.H
//
// Definition module for the DB Parse Tags emitting functions
//
//******************************************************************************

#ifndef __DBPTAGS_H__
#define __DBPTAGS_H__
#include "kato.h"

//******************************************************************************
// Define EXTERN_C
//******************************************************************************

#ifndef EXTERN_C
   #ifdef __cplusplus
      #define EXTERN_C extern "C"
   #else
      #define EXTERN_C
   #endif
#endif

//******************************************************************************
// Constants
//******************************************************************************

#define DBPRESULT_SKIP      2
#define DBPRESULT_PASS      3
#define DBPRESULT_FAIL      4
#define DBPRESULT_ABORT     5

//******************************************************************************
// APIs for C and C++ interfaces
//******************************************************************************

EXTERN_C VOID   DBPTSetKatoObject(HKATO hKato);
EXTERN_C VOID   DBPTClearKatoObject();
EXTERN_C VOID   DBPTBeginTestGroup(LONG lTestGroupID);
EXTERN_C VOID   DBPTBeginTestCase(LONG lTestCaseID);
EXTERN_C VOID   DBPTEndTestCase(INT nResult);
EXTERN_C VOID   DBPTEndTestGroup(VOID);

#endif // __DBPTAGS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\tux\Include\ft.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft end-user
// license agreement (EULA) under which you licensed this SOFTWARE PRODUCT.
// If you did not accept the terms of the EULA, you are not authorized to use
// this source code. For a copy of the EULA, please see the LICENSE.RTF on your
// install media.
//
////////////////////////////////////////////////////////////////////////////////
//
//  TUXTEST TUX DLL
//
//  Module: ft.h
//          Declares the TUX function table and test function prototypes EXCEPT
//          when included by globals.cpp, in which case it DEFINES the function
//          table.
//
//  Revision History:
//
////////////////////////////////////////////////////////////////////////////////

#if (!defined(__FT_H__) || defined(__GLOBALS_CPP__))
#ifndef __FT_H__
#define __FT_H__
#endif

////////////////////////////////////////////////////////////////////////////////
// Local macros

#ifdef __DEFINE_FTE__
#undef BEGIN_FTE
#undef FTE
#undef FTH
#undef END_FTE
#define BEGIN_FTE FUNCTION_TABLE_ENTRY g_lpFTE[] = {
#define FTH(a, b) { TEXT(b), a, 0, 0, NULL },
#define FTE(a, b, c, d, e) { TEXT(b), a, d, c, e },
#define END_FTE { NULL, 0, 0, 0, NULL } };
#else // __DEFINE_FTE__
#ifdef __GLOBALS_CPP__
#define BEGIN_FTE
#else // __GLOBALS_CPP__
//#define BEGIN_FTE extern FUNCTION_TABLE_ENTRY g_lpFTE[];
extern FUNCTION_TABLE_ENTRY g_lpFTE[];
#endif // __GLOBALS_CPP__
#define FTH(a, b)
#define FTE(a, b, c, d, e) TESTPROCAPI e(UINT, TPPARAM, LPFUNCTION_TABLE_ENTRY);
#define END_FTE
#endif // __DEFINE_FTE__

////////////////////////////////////////////////////////////////////////////////

#endif // !__FT_H__ || __GLOBALS_CPP__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\tux\Include\globals.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft end-user
// license agreement (EULA) under which you licensed this SOFTWARE PRODUCT.
// If you did not accept the terms of the EULA, you are not authorized to use
// this source code. For a copy of the EULA, please see the LICENSE.RTF on your
// install media.
//
////////////////////////////////////////////////////////////////////////////////
//
//  TUXTEST TUX DLL
//
//  Module: globals.h
//          Declares all global variables and test function prototypes EXCEPT
//          when included by globals.cpp, in which case it DEFINES global
//          variables, including the function table.
//
//  Revision History:
//
////////////////////////////////////////////////////////////////////////////////
#pragma once
#ifndef __GLOBALS_H__
#define __GLOBALS_H__

////////////////////////////////////////////////////////////////////////////////
// Local macros

#ifdef __GLOBALS_CPP__
#define GLOBAL
#define INIT(x) = x
#else // __GLOBALS_CPP__
#define GLOBAL  extern
#define INIT(x)
#endif // __GLOBALS_CPP__

////////////////////////////////////////////////////////////////////////////////
// Global macros

#define countof(x)  (sizeof(x)/sizeof(*(x)))

////////////////////////////////////////////////////////////////////////////////
// Global function prototypes

void            Debug(LPCTSTR, ...);
SHELLPROCAPI    ShellProc(UINT, SPPARAM);

////////////////////////////////////////////////////////////////////////////////
// TUX Function table

#include "ft.h"

////////////////////////////////////////////////////////////////////////////////
// Globals

// Global CKato logging object. Set while processing SPM_LOAD_DLL message.
GLOBAL CKato            *g_pKato INIT(NULL);

// Global shell info structure. Set while processing SPM_SHELL_INFO message.
GLOBAL SPS_SHELL_INFO   *g_pShellInfo;

// Add more globals of your own here. There are two macros available for this:
//  GLOBAL  Precede each declaration/definition with this macro.
//  INIT    Use this macro to initialize globals, instead of typing "= ..."
//
// For example, to declare two DWORDs, one uninitialized and the other
// initialized to 0x80000000, you could enter the following code:
//
//  GLOBAL DWORD        g_dwUninit,
//                      g_dwInit INIT(0x80000000);
////////////////////////////////////////////////////////////////////////////////

#endif // __GLOBALS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\tux\Include\kato.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//******************************************************************************
//
// KATO.H
//
// Definition module for the Kato constants and CKato interface
//
//******************************************************************************

#ifndef __KATO_H__
#define __KATO_H__

//******************************************************************************
// Define EXTERN_C
//******************************************************************************

#ifndef EXTERN_C
   #ifdef __cplusplus
      #define EXTERN_C extern "C"
   #else
      #define EXTERN_C
   #endif
#endif

//******************************************************************************
// Specify 32 bit pack size to ensure everyone creates the correct size objects
//******************************************************************************

#pragma pack(4)

//******************************************************************************
// Constants
//******************************************************************************

#define KATO_MAX_LEVEL            31
#define KATO_MAX_VERBOSITY        15
#define KATO_MAX_STRING_LENGTH  1024
#define KATO_MAX_DATA_SIZE      1024

//******************************************************************************
// Types
//******************************************************************************

typedef HANDLE HKATO;

typedef struct _KATOCALLBACKSTRUCTW {
   LPARAM  lParam;
   HKATO   hKato;
   DWORD   dwThreadID;
   DWORD   dwTickCount;
   DWORD   dwLevel;
   DWORD   dwLevelID;
   DWORD   dwVerbosity;
   LPCWSTR wszLog;
} KATOCALLBACKSTRUCTW, *LPKATOCALLBACKSTRUCTW;

typedef struct _KATOCALLBACKSTRUCTA {
   LPARAM  lParam;
   HKATO   hKato;
   DWORD   dwThreadID;
   DWORD   dwTickCount;
   DWORD   dwLevel;
   DWORD   dwLevelID;
   DWORD   dwVerbosity;
   LPCSTR  szLog;
} KATOCALLBACKSTRUCTA, *LPKATOCALLBACKSTRUCTA;

typedef BOOL (CALLBACK *LPKATOCALLBACKW)(LPKATOCALLBACKSTRUCTW);
typedef BOOL (CALLBACK *LPKATOCALLBACKA)(LPKATOCALLBACKSTRUCTA);

typedef enum _KATO_FLUSH_TYPE {
   KATO_FLUSH_ON,
   KATO_FLUSH_OFF,
   KATO_FLUSH_NOW,
} KATO_FLUSH_TYPE, *LPKATO_FLUSH_TYPE;

//******************************************************************************
// Common APIs for C and C++ interfaces
//******************************************************************************

EXTERN_C BOOL  WINAPI KatoSetServerW(LPCWSTR wszServer);
EXTERN_C BOOL  WINAPI KatoSetServerA(LPCSTR szServer);
EXTERN_C BOOL  WINAPI KatoGetServerW(LPWSTR wszServer, INT nCount);
EXTERN_C BOOL  WINAPI KatoGetServerA(LPSTR szServer, INT nCount);
EXTERN_C BOOL  WINAPI KatoSetCallbackW(LPKATOCALLBACKW lpCallbackW, LPARAM lParam);
EXTERN_C BOOL  WINAPI KatoSetCallbackA(LPKATOCALLBACKA lpCallbackA, LPARAM lParam);
EXTERN_C BOOL  WINAPI KatoRemoveCallbackW(LPKATOCALLBACKW lpCallbackW, LPARAM lParam);
EXTERN_C BOOL  WINAPI KatoRemoveCallbackA(LPKATOCALLBACKA lpCallbackA, LPARAM lParam);
EXTERN_C BOOL  WINAPI KatoFlush(KATO_FLUSH_TYPE flushType);
EXTERN_C BOOL  WINAPI KatoDebug(BOOL fODSEnabled, DWORD dwMaxLogVersbosity,
                                DWORD dwMaxCommentVersbosity, DWORD dwMaxLevel);
EXTERN_C BOOL  WINAPI KatoDebugEx(BOOL fODSEnabled, BOOL fConsoleEnabled, DWORD dwMaxLogVersbosity,
                                DWORD dwMaxCommentVersbosity, DWORD dwMaxLevel);

EXTERN_C HKATO WINAPI KatoGetDefaultObjectEx(DWORD dwFlags);

// Legacy support: allow older code to compile with new interface.
#define KatoGetDefaultObject() KatoGetDefaultObjectEx(0)


//******************************************************************************
// APIs for C interface (C++ applications should use the CKato class)
//******************************************************************************

// Construction and destruction
EXTERN_C HKATO WINAPI  KatoCreateExW(DWORD dwFlags, LPCWSTR wszName);
EXTERN_C HKATO WINAPI  KatoCreateExA(DWORD dwFlags, LPCSTR szName);
EXTERN_C BOOL  WINAPI  KatoDestroy(HKATO hKato);

// Unicode functions
EXTERN_C INT   WINAPIV KatoBeginLevelW(HKATO hKato, DWORD dwLevelID, LPCWSTR wszFormat, ...);
EXTERN_C INT   WINAPIV KatoBeginLevelVW(HKATO hKato, DWORD dwLevelID, LPCWSTR wszFormat, va_list pArgs);
EXTERN_C INT   WINAPIV KatoEndLevelW(HKATO hKato, LPCWSTR wszFormat, ...);
EXTERN_C INT   WINAPIV KatoEndLevelVW(HKATO hKato, LPCWSTR wszFormat, va_list pArgs);
EXTERN_C BOOL  WINAPIV KatoLogW(HKATO hKato, DWORD dwVerbosity, LPCWSTR wszFormat, ...);
EXTERN_C BOOL  WINAPIV KatoLogVW(HKATO hKato, DWORD dwVerbosity, LPCWSTR wszFormat, va_list pArgs);
EXTERN_C BOOL  WINAPIV KatoCommentW(HKATO hKato, DWORD dwVerbosity, LPCWSTR wszFormat, ...);
EXTERN_C BOOL  WINAPIV KatoCommentVW(HKATO hKato, DWORD dwVerbosity, LPCWSTR wszFormat, va_list pArgs);

// ASCII functions
EXTERN_C INT   WINAPIV KatoBeginLevelA(HKATO hKato, DWORD dwLevelID, LPCSTR szFormat, ...);
EXTERN_C INT   WINAPIV KatoBeginLevelVA(HKATO hKato, DWORD dwLevelID, LPCSTR szFormat, va_list pArgs);
EXTERN_C INT   WINAPIV KatoEndLevelA(HKATO hKato, LPCSTR szFormat, ...);
EXTERN_C INT   WINAPIV KatoEndLevelVA(HKATO hKato, LPCSTR szFormat, va_list pArgs);
EXTERN_C BOOL  WINAPIV KatoLogA(HKATO hKato, DWORD dwVerbosity, LPCSTR szFormat, ...);
EXTERN_C BOOL  WINAPIV KatoLogVA(HKATO hKato, DWORD dwVerbosity, LPCSTR szFormat, va_list pArgs);
EXTERN_C BOOL  WINAPIV KatoCommentA(HKATO hKato, DWORD dwVerbosity, LPCSTR szFormat, ...);
EXTERN_C BOOL  WINAPIV KatoCommentVA(HKATO hKato, DWORD dwVerbosity, LPCSTR szFormat, va_list pArgs);

// Non-string functions
EXTERN_C BOOL  WINAPI  KatoSetItemData(HKATO hKato, DWORD dwItemData);
EXTERN_C DWORD WINAPI  KatoGetItemData(HKATO hKato);
EXTERN_C BOOL  WINAPI  KatoSendSystemData(HKATO hKato, DWORD dwSystemID, LPCVOID lpcvBuffer, DWORD dwSize);
EXTERN_C DWORD WINAPI  KatoGetCurrentLevel(HKATO hKato);
EXTERN_C INT   WINAPI  KatoGetVerbosityCount(HKATO hKato, DWORD dwVerbosity, DWORD dwLevel);
EXTERN_C BOOL  WINAPI  KatoSetXML(HKATO hKato, BOOL bXML);
EXTERN_C BOOL  WINAPI  KatoSetLogsAreComments(HKATO hKato, BOOL bLogsAreComments);

//******************************************************************************
// Map function names to the correct APIs based on the UNICODE flag
//******************************************************************************

#ifdef UNICODE
   #define KATOCALLBACKSTRUCT   KATOCALLBACKSTRUCTW
   #define LPKATOCALLBACKSTRUCT LPKATOCALLBACKSTRUCTW
   #define LPKATOCALLBACK       LPKATOCALLBACKW
   #define KatoCreate(x)        KatoCreateExW(0,x)
   #define KatoSetCallback      KatoSetCallbackW
   #define KatoRemoveCallback   KatoRemoveCallbackW
   #define KatoSetServer        KatoSetServerW
   #define KatoGetServer        KatoGetServerW
   #define KatoBeginLevel       KatoBeginLevelW
   #define KatoBeginLevelV      KatoBeginLevelVW
   #define KatoEndLevel         KatoEndLevelW
   #define KatoEndLevelV        KatoEndLevelVW
   #define KatoLog              KatoLogW
   #define KatoLogV             KatoLogVW
   #define KatoComment          KatoCommentW
   #define KatoCommentV         KatoCommentVW
#else
   #define KATOCALLBACKSTRUCT   KATOCALLBACKSTRUCTA
   #define LPKATOCALLBACKSTRUCT LPKATOCALLBACKSTRUCTA
   #define LPKATOCALLBACK       LPKATOCALLBACKA
   #define KatoCreate(x)        KatoCreateExA(0,x)
   #define KatoSetCallback      KatoSetCallbackA
   #define KatoRemoveCallback   KatoRemoveCallbackA
   #define KatoSetServer        KatoSetServerA
   #define KatoGetServer        KatoGetServerA
   #define KatoBeginLevel       KatoBeginLevelA
   #define KatoBeginLevelV      KatoBeginLevelVA
   #define KatoEndLevel         KatoEndLevelA
   #define KatoEndLevelV        KatoEndLevelVA
   #define KatoLog              KatoLogA
   #define KatoLogV             KatoLogVA
   #define KatoComment          KatoCommentA
   #define KatoCommentV         KatoCommentVA
#endif

//******************************************************************************
// CKato - Interface for C++ applications
//******************************************************************************

#ifdef __cplusplus

class CKato {
public:
   // Unicode functions
   virtual INT  WINAPIV BeginLevel (DWORD dwLevelID, LPCWSTR wszFormat, ...) = 0;
   virtual INT  WINAPI  BeginLevelV(DWORD dwLevelID, LPCWSTR wszFormat, va_list pArgs) = 0;
   virtual INT  WINAPIV EndLevel (LPCWSTR wszFormat, ...) = 0;
   virtual INT  WINAPI  EndLevelV(LPCWSTR wszFormat, va_list pArgs) = 0;
   virtual BOOL WINAPIV Log (DWORD dwVerbosity, LPCWSTR wszFormat, ...) = 0;
   virtual BOOL WINAPI  LogV(DWORD dwVerbosity, LPCWSTR wszFormat, va_list pArgs) = 0;
   virtual BOOL WINAPIV Comment (DWORD dwVerbosity, LPCWSTR wszFormat, ...) = 0;
   virtual BOOL WINAPI  CommentV(DWORD dwVerbosity, LPCWSTR wszFormat, va_list pArgs) = 0;

   // ASCII functions
   virtual INT  WINAPIV BeginLevel (DWORD dwLevelID, LPCSTR szFormat, ...) = 0;
   virtual INT  WINAPI  BeginLevelV(DWORD dwLevelID, LPCSTR szFormat, va_list pArgs) = 0;
   virtual INT  WINAPIV EndLevel (LPCSTR szFormat, ...) = 0;
   virtual INT  WINAPI  EndLevelV(LPCSTR szFormat, va_list pArgs) = 0;
   virtual BOOL WINAPIV Log (DWORD dwVerbosity, LPCSTR szFormat, ...) = 0;
   virtual BOOL WINAPI  LogV(DWORD dwVerbosity, LPCSTR szFormat, va_list pArgs) = 0;
   virtual BOOL WINAPIV Comment (DWORD dwVerbosity, LPCSTR szFormat, ...) = 0;
   virtual BOOL WINAPI  CommentV(DWORD dwVerbosity, LPCSTR szFormat, va_list pArgs) = 0;

   // Non-string functions
   virtual BOOL  WINAPI SetItemData(DWORD dwItemData) = 0;
   virtual DWORD WINAPI GetItemData(VOID) = 0;
   virtual BOOL  WINAPI SendSystemData(DWORD dwSystemID, LPCVOID lpcvBuffer, DWORD dwSize) = 0;
   virtual DWORD WINAPI GetCurrentLevel(VOID) = 0;
   virtual INT   WINAPI GetVerbosityCount(DWORD dwVerbosity, DWORD dwLevel = -1) = 0;
   virtual BOOL  WINAPI SetXML(BOOL bXML) = 0;
   virtual BOOL  WINAPI SetLogsAreComments(BOOL bLogsAreComments) = 0;
};

#endif // __cplusplus

#pragma pack() // restore packing size to previous state

#endif // __KATO_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\tux\Include\katoex.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
// --------------------------------------------------------------------
//                                                                     
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A      
// PARTICULAR PURPOSE.                                                 
//                                                                     
// --------------------------------------------------------------------
//******************************************************************************
//
// KATOEX.H
//
// Definition of constants to be used with Kato
//
//******************************************************************************

#ifndef __KATOEX_H__
#define __KATOEX_H__

#include <kato.h>

#define LOG_EXCEPTION          0
#define LOG_FAIL               2
#define LOG_ABORT              4
#define LOG_SKIP               6
#define LOG_NOT_IMPLEMENTED    8
#define LOG_PASS              10
#define LOG_DETAIL            12
#define LOG_COMMENT           14

#endif // __KATOEX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\tux\Include\main.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft end-user
// license agreement (EULA) under which you licensed this SOFTWARE PRODUCT.
// If you did not accept the terms of the EULA, you are not authorized to use
// this source code. For a copy of the EULA, please see the LICENSE.RTF on your
// install media.
//
////////////////////////////////////////////////////////////////////////////////
//
//  TUXTEST TUX DLL
//
//  Module: main.h
//          Header for all files in the project.
//
//  Revision History:
//
////////////////////////////////////////////////////////////////////////////////

#pragma once
#ifndef __MAIN_H__
#define __MAIN_H__

////////////////////////////////////////////////////////////////////////////////
// Included files

#include <windows.h>
#include <stdlib.h>
#include <tchar.h>
#ifndef UT_SKEL_VERSION_2
#include "tux.h"
#endif
#include "kato.h"

////////////////////////////////////////////////////////////////////////////////
// Suggested log verbosities

#define LOG_EXCEPTION          0
#define LOG_FAIL               2
#define LOG_ABORT              4
#define LOG_SKIP               6
#define LOG_NOT_IMPLEMENTED    8
#define LOG_PASS              10
#define LOG_DETAIL            12
#define LOG_COMMENT           14

////////////////////////////////////////////////////////////////////////////////

#endif // __MAIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\tux\Include\ktux.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
// ----------------------------------------------------------------------------
//******************************************************************************
//
// KTUX.H
//
// Definitions of KTux types, structures, and messages.
//
//******************************************************************************

#ifndef __KTUX_H__
#define __KTUX_H__

#include "tux.h"
#include "kato.h"


#ifdef KTUX

#define KTUX_DLL  TEXT("KTux.DLL")
//
// InKernelMode -- check if we are running in k-mode or not
//
__inline BOOL InKernelMode() {
      return (int) InKernelMode < 0;
}

#define KTUX_IOCTL_NOACTION      0
#define KTUX_IOCTL_PING          1
#define KTUX_IOCTL_SHELLMSG      2
#define KTUX_IOCTL_TESTMSG       3
#define KTUX_IOCTL_KATOINIT      4
#define KTUX_IOCTL_SETDEBUG      5
#define KTUX_IOCTL_INIT          6
#define KTUX_IOCTL_DEINIT        7

#define KTUX_PING                0xABABABAB
#define KTUX_PONG                0xEFEFEFEF
#define KTUX_PINGFAIL            0xFFFFFFFF

#define MSG_TYPE_SPM             0x1
#define MSG_TYPE_TPM             0x2

typedef struct _LIST {
    LPVOID  addr;
    struct _LIST *next;
} LIST, *PLIST;

typedef union {
   SPS_LOAD_DLL                  spsldll;
   SPS_SHELL_INFO                spssinfo;
   SPS_REGISTER                  spsreg;
   SPS_EXCEPTION                 spsexcept;
   SPS_BEGIN_TEST                spsbegin;
   SPS_END_TEST                  spsend;
   SPS_STABILITY_INFO            spsstab;
   TPS_EXECUTE                   tpsexec;
   TPS_QUERY_THREAD_COUNT        tpsqthrdcnt;
} KTUX_MSG_STRUCT_ALL; 

typedef struct _KTUXMSG {
   DWORD                         type;
   UINT                          uMsg;
   KTUX_MSG_STRUCT_ALL           param;
   DWORD                         paramSize;
   LPFUNCTION_TABLE_ENTRY        lpFTE;
} KTUXMSG, *PKTUXMSG;

typedef struct _KATOARGS {
    TCHAR                        szKatoServer[ 32 ];
    DWORD                        nListing;
    HANDLE                       hFileLog;
    BOOL                         fLogToDebugger;
    BOOL                         fConsoleEnabled;
    BOOL                         fEnableODS;
    LPKATOCALLBACKA              pfnKatoCallback;
} KATOARGS, *PKATOARGS;

#endif // KTUX
#endif // __KTUX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\tux\Include\utlog.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
// ----------------------------------------------------------------------------
//
//******************************************************************************
//
// UTLog.H
//
//  A wrapper for logging messages via UTLogService to Kato, Console,
//  file and debug.
//
//******************************************************************************

#ifndef __UTLog_H__
#define __UTLog_H__

#include <windows.h>

//******************************************************************************
// Constants
//******************************************************************************

// Log verbosity flags:
//
#ifdef _PLEASE_INCLUDE_KATOEX_H_
#define LOG_EXCEPTION          0
#define LOG_FAIL               2
#define LOG_WARNING            3  // missing from katoex.h - must be defined manually
#define LOG_ABORT              4
#define LOG_SKIP               6
#define LOG_NOT_IMPLEMENTED    8
#define LOG_PASS              10
#define LOG_DETAIL            12
#define LOG_COMMENT           14
#endif
#ifndef LOG_DEFAULT
#define LOG_DEFAULT           13
#endif

// Log-output stream types:
//
#define UTLOG_DEBUG_OP 0x0000001  // Optional Debug output
#define UTLOG_DEBUG_RQ 0x0000003  // Required Debug output
#define UTLOG_KATO_OP  0x0000004  // Optional Kato output
#define UTLOG_KATO_RQ  0x000000C  // Required Kato output
#define UTLOG_FILE_OP  0x0000040  // Optional file output
#define UTLOG_FILE_RQ  0x00000C0  // Required file output
#define UTLOG_CON_OP   0x0000100  // Optional console logging
#define UTLOG_CON_RQ   0x0000300  // Required console logging

// Default: debug (required), console (optional) and Kato (optional):
//
#define UTLOG_DEF_STREAMS (UTLOG_DEBUG_RQ | UTLOG_CON_OP | UTLOG_KATO_OP)

//******************************************************************************
// Macros
//******************************************************************************

#ifndef UNDER_CE
    #include <stdio.h>
    #include <tchar.h>
    #ifndef DEBUGMSG
    #define DEBUGMSG(_expr,_printf_expr) ((_expr)? _tprintf _printf_expr, 1 : 0)
    #endif
    #ifndef RETAILMSG
    #define RETAILMSG(_expr,_printf_expr) ((_expr)? _tprintf _printf_expr, 1 : 0)
    #endif
#endif

#ifndef EXTERN_C
    #ifdef __cplusplus
        #define EXTERN_C extern "C"
    #else
        #define EXTERN_C
    #endif
#endif

// Define functions as export when building UTLog, and import when this
// file is included by all other applications. We only use UTLOGAPI on C++
// classes. Our DEF file will take care of exporting C functions.
//
#ifndef UTLOGAPI
#define UTLOGAPI __declspec(dllimport)
#endif

// Translate procedure names into the appropriate type for each OS
//
#ifndef CE_PROCNAME
    #ifdef UNDER_CE
        #define CE_PROCNAME(txt) L##txt
    #else
        #define CE_PROCNAME(txt) txt
    #endif
#endif

// Retrieve the number of items in a fixed-length array
//
#ifndef COUNTOF
#define COUNTOF(arr)  (sizeof(arr) / sizeof((arr)[0]))
#endif

//******************************************************************************
// Types
//******************************************************************************

typedef HANDLE HUTLOG;  // Handle to CUTLog object

//******************************************************************************
// Object-interface
//******************************************************************************

// Returns a handle to the logging context (CUTLog) if wrapping has been
// initialized, NULL otherwise.
//
EXTERN_C HUTLOG WINAPI
UTLogGetLogger(
    void);

// Replaces the current logging context (if any) with that specified.
// Returns TRUE if the context-transfer succeeds, FALSE otherwise.
//
EXTERN_C BOOL WINAPI
UTLogSetLogger(
    HUTLOG hWrapper);

typedef HUTLOG (*PFUTLogGetLogger_t)(void);
typedef BOOL   (*PFUTLogSetLogger_t)(HUTLOG);

#define UTLOG_PROCNAME_GetLogger  CE_PROCNAME("UTLogGetLogger")
#define UTLOG_PROCNAME_SetLogger  CE_PROCNAME("UTLogSetLogger")

//******************************************************************************
// Construction, destruction and configuration
//******************************************************************************

// Initializes the log-wrapping context and the logging functions.
//   pTestName  - Unique name of the test.
//                Used to determine output file names.
//                The final file name will be something like
//                   "%pTestName%_%processor%_%build#%_%config%_%pass/fail%.log"
//   LogLevel   - The level of logging desired, see katoex.h.
//                LOG_PASS is typical for retail builds. LOG_DETAIL for debug builds. 
//   LogStreams - The desired output streams. See CUTLOG_XXX_RQ, etc. above.
//   fUseMultiThread - Use a different output log file for each thread.
//
EXTERN_C BOOL WINAPI
UTLogCreateW(
    LPCWSTR pTestName,
    DWORD   LogLevel,
    DWORD   LogStreams,
    BOOL    fUseMultiThread);

EXTERN_C BOOL WINAPI
UTLogCreateA(
    LPCSTR pTestName,
    DWORD  LogLevel,
    DWORD  LogStreams,
    BOOL   fUseMultiThread);

// Cleans up logging resources.
// All logging functions will fail after this.
//
EXTERN_C BOOL WINAPI
UTLogDestroy(
    void);

// Gets or sets the verbosity level required to log a message.
//
EXTERN_C DWORD WINAPI
UTLogGetLogLevel(
    void);

EXTERN_C BOOL WINAPI
UTLogSetLogLevel(
    DWORD NewLevel);

// Gets or sets the log-wrapping into a state where it outputs the
// 6 @ signs to tell the automation server that the test is done.
// This is used when we want to batch tests together.
//
EXTERN_C BOOL WINAPI
UTLogGetWATTOutput(
    void);

EXTERN_C BOOL WINAPI
UTLogSetWATTOutput(
    BOOL fWattOutput);

typedef BOOL  (*PFUTLogCreateW_t)      (LPCWSTR, DWORD, DWORD, BOOL);
typedef BOOL  (*PFUTLogCreateA_t)      (LPCSTR, DWORD, DWORD, BOOL);
typedef BOOL  (*PFUTLogDestroy_t)      (void);
typedef DWORD (*PFUTLogGetLogLevel_t)  (void);
typedef void  (*PFUTLogSetLogLevel_t)  (DWORD);
typedef BOOL  (*PFUTLogGetWATTOutput_t)(void);
typedef void  (*PFUTLogSetWATTOutput_t)(BOOL);

#define UTLOG_PROCNAME_CreateW        CE_PROCNAME("UTLogCreateW")
#define UTLOG_PROCNAME_CreateA        CE_PROCNAME("UTLogCreateA")
#define UTLOG_PROCNAME_Cleanup        CE_PROCNAME("UTLogDestroy")
#define UTLOG_PROCNAME_GetLogLevel    CE_PROCNAME("UTLogGetLogLevel")
#define UTLOG_PROCNAME_SetLogLevel    CE_PROCNAME("UTLogSetLogLevel")
#define UTLOG_PROCNAME_GetWATTOutput  CE_PROCNAME("UTLogGetWATTOutput")
#define UTLOG_PROCNAME_SetWATTOutput  CE_PROCNAME("UTLogSetWATTOutput")

//******************************************************************************
// Output Routines
//******************************************************************************

// Logs a message at the specified verbosity level and increments the
// corresponding message count.
// Concatenates the user message to the specified header.
//
EXTERN_C BOOL WINAPIV
UTLogVW(
    DWORD   Verbosity,
    LPCWSTR pHeader,
    LPCWSTR pFormat,
    va_list pArgs);

EXTERN_C BOOL WINAPIV
UTLogVA(
    DWORD   Verbosity,
    LPCSTR  pHeader,
    LPCSTR  pFormat,
    va_list pArgs);

// Logs a message at verbosity level LOG_FAIL and increments the error count.
// Concatenates the user message to the string "Error: ".
//
EXTERN_C BOOL WINAPIV
UTLogErrorW(
    LPCWSTR pFormat,
    ...);

EXTERN_C BOOL WINAPIV
UTLogErrorA(
    LPCSTR pFormat,
    ...);

// Logs a message at verbosity level LOG_WARNING and increments the
// warning count.
// Concatenates the user message to the string "Warning: ".
//
EXTERN_C BOOL WINAPIV
UTLogWarningW(
    LPCWSTR pFormat,
    ...);

EXTERN_C BOOL WINAPIV
UTLogWarningA(
    LPCSTR pFormat,
    ...);

// Logs a message at verbosity level LOG_PASS.
// Concatenates the user message to the string "Message: ".
//
EXTERN_C BOOL WINAPIV
UTLogMessageW(
    LPCWSTR pFormat,
    ...);

EXTERN_C BOOL WINAPIV
UTLogMessageA(
    LPCSTR pFormat,
    ...);

// Logs a message at verbosity level LOG_DETAIL, which is higher than the
// default and is not normally written.
// Concatenates the user message to the string "Debug: ".
//
EXTERN_C BOOL WINAPIV
UTLogDebugW(
    LPCWSTR pFormat,
    ...);

EXTERN_C BOOL WINAPIV
UTLogDebugA(
    LPCSTR pFormat,
    ...);

// Logs a message at verbosity level of LOG_COMMENT, which is higher than
// default and is not normally written.
// Concatenate the user message to the string "Verbose: ".
//
EXTERN_C BOOL WINAPIV
UTLogVerboseW(
    LPCWSTR pFormat,
    ...);

EXTERN_C BOOL WINAPIV
UTLogVerboseA(
    LPCSTR pFormat,
    ...);

typedef BOOL (*PFUTLogVW_t)      (DWORD, LPCWSTR, LPCWSTR, va_list);
typedef BOOL (*PFUTLogVA_t)      (DWORD, LPCSTR, LPCSTR, va_list);
typedef BOOL (*PFUTLogErrorW_t)  (LPCWSTR, ...);
typedef BOOL (*PFUTLogErrorA_t)  (LPCSTR,  ...);
typedef BOOL (*PFUTLogWarningW_t)(LPCWSTR, ...);
typedef BOOL (*PFUTLogWarningA_t)(LPCSTR,  ...);
typedef BOOL (*PFUTLogMessageW_t)(LPCWSTR, ...);
typedef BOOL (*PFUTLogMessageA_t)(LPCSTR,  ...);
typedef BOOL (*PFUTLogDebugW_t)  (LPCWSTR, ...);
typedef BOOL (*PFUTLogDebugA_t)  (LPCSTR,  ...);
typedef BOOL (*PFUTLogVerboseW_t)(LPCWSTR, ...);
typedef BOOL (*PFUTLogVerboseA_t)(LPCSTR,  ...);

#define UTLOG_PROCNAME_LogVW        CE_PROCNAME("UTLogVW")
#define UTLOG_PROCNAME_LogVA        CE_PROCNAME("UTLogVA")
#define UTLOG_PROCNAME_LogErrorW    CE_PROCNAME("UTLogErrorW")
#define UTLOG_PROCNAME_LogErrorA    CE_PROCNAME("UTLogErrorA")
#define UTLOG_PROCNAME_LogWarningW  CE_PROCNAME("UTLogWarningW")
#define UTLOG_PROCNAME_LogWarningA  CE_PROCNAME("UTLogWarningA")
#define UTLOG_PROCNAME_LogMessageW  CE_PROCNAME("UTLogMessageW")
#define UTLOG_PROCNAME_LogMessageA  CE_PROCNAME("UTLogMessageA")
#define UTLOG_PROCNAME_LogDebugW    CE_PROCNAME("UTLogDebugW")
#define UTLOG_PROCNAME_LogDebugA    CE_PROCNAME("UTLogDebugA")
#define UTLOG_PROCNAME_LogVerboseW  CE_PROCNAME("UTLogVerboseW")
#define UTLOG_PROCNAME_LogVerboseA  CE_PROCNAME("UTLogVerboseA")

//******************************************************************************
// Statistics Routines
//******************************************************************************

// Returns the total number of errors currently counted by the logging tool.
//
EXTERN_C LONG WINAPI
UTLogGetErrorCount(void);

// Returns the total number of warnings currently counted by the logging tool.
//
EXTERN_C LONG WINAPI
UTLogGetWarningCount(void);

// Retrieves the message counts into the specified array:
//
EXTERN_C BOOL WINAPI 
UTLogGetMessageCounts(
  __out_ecount(NumberCounts) LONG * pMsgCounts,
                             DWORD  NumberCounts);

// Zeroes the message counts:
//
EXTERN_C BOOL WINAPI
UTLogResetMessageCounts(void);

// Returns the number of errors counted on this thread.
// If there is only one thread or multi-threaded logging is disabled,
// the result will be the same amount as UTLogGetErrorCount.
//
EXTERN_C LONG WINAPI
UTLogGetThreadErrorCount(void);

// Returns the number of warnings counted on this thread.
// If there is only one thread or multi-threaded logging is disabled,
// the result will be the same amount as UTLogGetWarningCount.
//
EXTERN_C LONG WINAPI
UTLogGetThreadWarningCount(void);

// Retrieves the message counts for this thread:
// If there is only one thread or multi-threaded logging is disabled,
// this will retrieve the same counts as UTLogGetMessageCounts.
//
EXTERN_C BOOL WINAPI 
UTLogGetThreadMessageCounts(
  __out_ecount(NumberCounts) LONG * pMsgCounts,
                             DWORD  NumberCounts);

// Zeroes the message counts for this thread:
//
EXTERN_C BOOL WINAPI
UTLogResetThreadMessageCounts(void);

typedef LONG (*PFUTLogGetErrorCount_t)         (void);
typedef LONG (*PFUTLogGetWarningCount_t)       (void);
typedef BOOL (*PFUTLogGetMessageCounts)        (LONG *, DWORD);
typedef BOOL (*PFUTLogResetMessageCounts)      (void);
typedef LONG (*PFUTLogGetThreadErrorCount_t)   (void);
typedef LONG (*PFUTLogGetThreadWarningCount_t) (void);
typedef BOOL (*PFUTLogGetThreadMessageCounts)  (LONG *, DWORD);
typedef BOOL (*PFUTLogResetThreadMessageCounts)(void);

#define UTLOG_PROCNAME_GetErrorCount            CE_PROCNAME("UTLogGetErrorCount")
#define UTLOG_PROCNAME_GetWarningCount          CE_PROCNAME("UTLogGetWarningCount")
#define UTLOG_PROCNAME_GetMessageCounts         CE_PROCNAME("UTLogGetMessageCounts")
#define UTLOG_PROCNAME_ResetMessageCounts       CE_PROCNAME("UTLogResetMessageCounts")
#define UTLOG_PROCNAME_GetThreadErrorCount      CE_PROCNAME("UTLogGetThreadErrorCount")
#define UTLOG_PROCNAME_GetThreadWarningCount    CE_PROCNAME("UTLogGetThreadWarningCount")
#define UTLOG_PROCNAME_GetThreadMessageCounts   CE_PROCNAME("UTLogGetThreadMessageCounts")
#define UTLOG_PROCNAME_ResetThreadMessageCounts CE_PROCNAME("UTLogResetThreadMessageCounts")

//******************************************************************************
// Map function names to the correct APIs based on the UNICODE flag
//******************************************************************************

#ifdef UNICODE
    #define UTLogCreate             UTLogCreateW
    #define UTLogV                  UTLogVW
    #define UTLogError              UTLogErrorW
    #define UTLogWarning            UTLogWarningW
    #define UTLogMessage            UTLogMessageW
    #define UTLogDebug              UTLogDebugW
    #define UTLogVerbose            UTLogVerboseW
    #define PFUTLogCreate_t         PFUTLogCreateW_t
    #define PFUTLogV_t              PFUTLogVW_t
    #define PFUTLogError_t          PFUTLogErrorW_t
    #define PFUTLogWarning_t        PFUTLogWarningW_t
    #define PFUTLogMessage_t        PFUTLogMessageW_t
    #define PFUTLogDebug_t          PFUTLogDebugW_t
    #define PFUTLogVerbose_t        PFUTLogVerboseW_t
    #define UTLOG_PROCNAME_Create   UTLOG_PROCNAME_CreateW
    #define UTLOG_PROCNAME_LogV     UTLOG_PROCNAME_LogVW
    #define UTLOG_PROCNAME_Error    UTLOG_PROCNAME_LogErrorW
    #define UTLOG_PROCNAME_Warning  UTLOG_PROCNAME_LogWarningW
    #define UTLOG_PROCNAME_Message  UTLOG_PROCNAME_LogMessageW
    #define UTLOG_PROCNAME_Debug    UTLOG_PROCNAME_LogDebugW
    #define UTLOG_PROCNAME_Verbose  UTLOG_PROCNAME_LogVerboseW
#else
    #define UTLogCreate             UTLogCreateA
    #define UTLogV                  UTLogVA
    #define UTLogError              UTLogErrorA
    #define UTLogWarning            UTLogWarningA
    #define UTLogMessage            UTLogMessageA
    #define UTLogDebug              UTLogDebugA
    #define UTLogVerbose            UTLogVerboseA
    #define PFUTLogCreate_t         PFUTLogCreateA_t
    #define PFUTLogV_t              PFUTLogVA_t
    #define PFUTLogError_t          PFUTLogErrorA_t
    #define PFUTLogWarning_t        PFUTLogWarningA_t
    #define PFUTLogMessage_t        PFUTLogMessageA_t
    #define PFUTLogDebug_t          PFUTLogDebugA_t
    #define PFUTLogVerbose_t        PFUTLogVerboseA_t
    #define UTLOG_PROCNAME_Create   UTLOG_PROCNAME_CreateA
    #define UTLOG_PROCNAME_LogV     UTLOG_PROCNAME_LogVA
    #define UTLOG_PROCNAME_Error    UTLOG_PROCNAME_LogErrorA
    #define UTLOG_PROCNAME_Warning  UTLOG_PROCNAME_LogWarningA
    #define UTLOG_PROCNAME_Message  UTLOG_PROCNAME_LogMessageA
    #define UTLOG_PROCNAME_Debug    UTLOG_PROCNAME_LogDebugA
    #define UTLOG_PROCNAME_Verbose  UTLOG_PROCNAME_LogVerboseA
#endif

#endif // __UTLog_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\tux\Include\utassert.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

#ifndef __UTASSERT_H_INCLUDED__
#define __UTASSERT_H_INCLUDED__

#if _MSC_VER > 1000
#pragma once
#endif

#include <windows.h>
#include <utlog.h>

//
// Macro wrappers for the __UTAssertEqual and __UTAssertNotEqual functions.
//

#if !defined(__cplusplus) || defined(UTASSERT_NO_CPPEH)

//
// These versions of the UTASSERT_ macros will goto an exit label on error.
//

// Define the UTASSERT_FAILURE_EXIT_LABEL macro prior to including this file to
// override the default exit label.
#ifndef UTASSERT_FAILURE_EXIT_LABEL
#define UTASSERT_FAILURE_EXIT_LABEL     Error
#endif // UTASSERT_FAILURE_EXIT_LABEL

// Define the UTASSERT_HRESULT_VARIABLE_NAME macro prior to including this file
// to override the default HRESULT variable name returned by tests.
#ifndef UTASSERT_HRESULT_VARIABLE_NAME
#define UTASSERT_HRESULT_VARIABLE_NAME  hr
#endif // UTASSERT_HRESULT_VARIABLE_NAME

// Assert that two values are equal.
//
// Example:
//
//      int value = AddTwoIntegers(4, 5);
//      UTASSERT_EQUAL(4 + 5, value);
//
#define UTASSERT_EQUAL(expected, actual) \
    do { \
        if(!__UTAssertEqual((DWORD)(expected), (DWORD)(actual), TEXT(__FILE__), __LINE__, TEXT("(") TEXT(#actual) TEXT(") != (") TEXT(#expected) TEXT(")"))) { \
            UTASSERT_HRESULT_VARIABLE_NAME = E_FAIL; \
            goto UTASSERT_FAILURE_EXIT_LABEL; \
        } \
    } while(0)

// Assert that two values are not equal.
//
// Example:
//
//      int count = Database.GetRecordCount();
//      UTASSERT_NOT_EQUAL(0, count);
//
#define UTASSERT_NOT_EQUAL(unexpected, actual) \
    do { \
        if(!__UTAssertNotEqual((DWORD)(unexpected), (DWORD)(actual), TEXT(__FILE__), __LINE__, TEXT("(") TEXT(#actual) TEXT(") == (") TEXT(#unexpected) TEXT(")"))) { \
            UTASSERT_HRESULT_VARIABLE_NAME = E_FAIL; \
            goto UTASSERT_FAILURE_EXIT_LABEL; \
        } \
    } while(0)

// Assert that the result is not FALSE.
//
// Example:
//
//      BOOL result = DeleteFile(fileName);
//      UTASSERT_BOOL(result);
//
#define UTASSERT_BOOL(result) \
    do { \
        if(!__UTAssertNotEqual((DWORD)(result), (DWORD)FALSE, TEXT(__FILE__), __LINE__, TEXT("(") TEXT(#result) TEXT(") != TRUE"))) { \
            UTASSERT_HRESULT_VARIABLE_NAME = E_FAIL; \
            goto UTASSERT_FAILURE_EXIT_LABEL; \
        } \
    } while(0)

// Assert that the result is NO_ERROR (ERROR_SUCCESS).
//
// Example:
//
//      LRESULT result = GetLastError();
//      UTASSERT_LRESULT(result);
//
#define UTASSERT_LRESULT(result) \
    do { \
        if(!__UTAssertEqual((DWORD)(result), (DWORD)NO_ERROR, TEXT(__FILE__), __LINE__, TEXT("(") TEXT(#result) TEXT(") != NO_ERROR"))) { \
            UTASSERT_HRESULT_VARIABLE_NAME = E_FAIL; \
            goto UTASSERT_FAILURE_EXIT_LABEL; \
        } \
    } while(0)

// Assert that the value of the pointer is not NULL.
//
// Example:
//
//      LPVOID ptr = malloc(size);
//      UTASSERT_PTR(ptr);
//
#define UTASSERT_PTR(ptr) \
    do { \
        if(!__UTAssertNotEqual((DWORD)(ptr), (DWORD)NULL, TEXT(__FILE__), __LINE__, TEXT("(") TEXT(#ptr) TEXT(") == NULL"))) { \
            UTASSERT_HRESULT_VARIABLE_NAME = E_FAIL; \
            goto UTASSERT_FAILURE_EXIT_LABEL; \
        } \
    } while(0)

// Assert that the value of FAILED(hr) is FALSE.
//
// Example:
//
//      HRESULT hr = CoInitialize();
//      UTASSERT_HRESULT(hr);
//
#define UTASSERT_HRESULT(hr) \
    do { \
        if(!__UTAssertEqual((DWORD)(FAILED(hr)), (DWORD)FALSE, TEXT(__FILE__), __LINE__, TEXT("FAILED(") TEXT(#hr) TEXT(") != FALSE"))) { \
            UTASSERT_HRESULT_VARIABLE_NAME = E_FAIL; \
            goto UTASSERT_FAILURE_EXIT_LABEL; \
        } \
    } while(0)

// Assert that the value of the handle is not NULL or INVALID_HANDLE_VALUE.
//
// Example:
//
//      HANDLE h = CreateEvent(NULL, FALSE, FALSE, NULL);
//      UTASSERT_HANDLE(h);
//
#define UTASSERT_HANDLE(h) \
    do { \
        if(!__UTAssertNotEqual((DWORD)(h), (DWORD)NULL, TEXT(__FILE__), __LINE__, TEXT("(") TEXT(#h) TEXT(") == NULL")) || \
           !__UTAssertNotEqual((DWORD)(h), (DWORD)INVALID_HANDLE_VALUE, TEXT(__FILE__), __LINE__, TEXT("(") TEXT(#h) TEXT(") == INVALID_HANDLE_VALUE"))) { \
            UTASSERT_HRESULT_VARIABLE_NAME = E_FAIL; \
            goto UTASSERT_FAILURE_EXIT_LABEL; \
        } \
    } while(0)
//
// Macro wrappers for the __UTAssertCompareStringA and __UTAssertCompareStringW functions.
//

// Assert that two C-style NULL-terminated strings are equal (case-sensitive).
//
// Example:
//
//      TCHAR szResource[100];
//      LoadString(GetModuleHandle(NULL), dwResourceId, szResource, _countof(szResource));
//      UTASSERT_COMPARE_STRING(wstrResource, L"ExpectedString");
//
#define UTASSERT_COMPARE_STRINGA(szExpected, szActual) \
    do { \
        if(!__UTAssertCompareStringA(szExpected, szActual, TEXT(__FILE__), __LINE__, TEXT("(") TEXT(#szExpected) TEXT(") != (") TEXT(#szActual) TEXT(")"))) { \
            UTASSERT_HRESULT_VARIABLE_NAME = E_FAIL; \
            goto UTASSERT_FAILURE_EXIT_LABEL; \
        } \
    } while(0)

#define UTASSERT_COMPARE_STRINGW(szExpected, szActual) \
    do { \
        if(!__UTAssertCompareStringW(szExpected, szActual, TEXT(__FILE__), __LINE__, TEXT("(") TEXT(#szExpected) TEXT(") != (") TEXT(#szActual) TEXT(")"))) { \
            UTASSERT_HRESULT_VARIABLE_NAME = E_FAIL; \
            goto UTASSERT_FAILURE_EXIT_LABEL; \
        } \
    } while(0)

#define __UTASSERT_DO_ON_FAILURE return FALSE
#define __UTASSERT_DO_ON_SUCCESS return TRUE

#else // defined(__cplusplus) && !defined(UTASSERT_NO_CPPEH)

//
// These versions of the UTASSERT_ macros will throw a C++ exception on error.
//

// Assert that two values are equal.
//
// Example:
//
//      int value = AddTwoIntegers(4, 5);
//      UTASSERT_EQUAL(4 + 5, value);
//
#define UTASSERT_EQUAL(expected, actual) \
    __UTAssertEqual((DWORD)(expected), (DWORD)(actual), TEXT(__FILE__), __LINE__, TEXT("(") TEXT(#actual) TEXT(") != (") TEXT(#expected) TEXT(")"))

// Assert that two values are not equal.
//
// Example:
//
//      int count = Database.GetRecordCount();
//      UTASSERT_NOT_EQUAL(0, count);
//
#define UTASSERT_NOT_EQUAL(unexpected, actual) \
    __UTAssertNotEqual((DWORD)(unexpected), (DWORD)(actual), TEXT(__FILE__), __LINE__, TEXT("(") TEXT(#actual) TEXT(") == (") TEXT(#unexpected) TEXT(")"))

// Assert that the result is not FALSE.
//
// Example:
//
//      BOOL result = DeleteFile(fileName);
//      UTASSERT_BOOL(result);
//
#define UTASSERT_BOOL(result) \
    __UTAssertNotEqual((DWORD)(result), (DWORD)FALSE, TEXT(__FILE__), __LINE__, TEXT("(") TEXT(#result) TEXT(") != TRUE"))

// Assert that the result is NO_ERROR (ERROR_SUCCESS).
//
// Example:
//
//      LRESULT result = GetLastError();
//      UTASSERT_LRESULT(result);
//
#define UTASSERT_LRESULT(result) \
    __UTAssertEqual((DWORD)(result), (DWORD)NO_ERROR, TEXT(__FILE__), __LINE__, TEXT("(") TEXT(#result) TEXT(") != NO_ERROR"))

// Assert that the value of the pointer is not NULL.
//
// Example:
//
//      LPVOID ptr = malloc(size);
//      UTASSERT_PTR(ptr);
//
#define UTASSERT_PTR(ptr) \
    __UTAssertNotEqual((DWORD)(ptr), (DWORD)NULL, TEXT(__FILE__), __LINE__, TEXT("(") TEXT(#ptr) TEXT(") == NULL"))

// Assert that the value of FAILED(hr) is FALSE.
//
// Example:
//
//      HRESULT hr = CoInitialize();
//      UTASSERT_HRESULT(hr);
//
#define UTASSERT_HRESULT(hr) \
    __UTAssertEqual((DWORD)(FAILED(hr)), (DWORD)FALSE, TEXT(__FILE__), __LINE__, TEXT("FAILED(") TEXT(#hr) TEXT(") != FALSE"))

// Assert that the value of the handle is not NULL or INVALID_HANDLE_VALUE.
//
// Example:
//
//      HANDLE h = CreateEvent(NULL, FALSE, FALSE, NULL);
//      UTASSERT_HANDLE(h);
//
#define UTASSERT_HANDLE(h) \
    (   __UTAssertNotEqual((DWORD)(h), (DWORD)NULL, TEXT(__FILE__), __LINE__, TEXT("(") TEXT(#h) TEXT(") == NULL")) && \
        __UTAssertNotEqual((DWORD)(h), (DWORD)INVALID_HANDLE_VALUE, TEXT(__FILE__), __LINE__, TEXT("(") TEXT(#h) TEXT(") == INVALID_HANDLE_VALUE"))    )
//
// Macro wrappers for the __UTAssertCompareStringA and __UTAssertCompareStringW functions.
//

// Assert that two C-style NULL-terminated strings are equal (case-sensitive).
//
// Example:
//
//      TCHAR szResource[100];
//      LoadString(GetModuleHandle(NULL), dwResourceId, szResource, _countof(szResource));
//      UTASSERT_COMPARE_STRING(wstrResource, L"ExpectedString");
//
#define UTASSERT_COMPARE_STRINGW(szExpected, szActual) \
    __UTAssertCompareStringW(szExpected, szActual, TEXT(__FILE__), __LINE__, TEXT("(") TEXT(#szExpected) TEXT(") != (") TEXT(#szActual) TEXT(")"))

#define UTASSERT_COMPARE_STRINGA(szExpected, szActual) \
    __UTAssertCompareStringA(szExpected, szActual, TEXT(__FILE__), __LINE__, TEXT("(") TEXT(#szExpected) TEXT(") != (") TEXT(#szActual) TEXT(")"))

#define __UTASSERT_DO_ON_FAILURE throw
#define __UTASSERT_DO_ON_SUCCESS return TRUE

#endif // defined(__cplusplus) && !defined(UTASSERT_NO_CPPEH)

#ifdef UNICODE
#define UTASSERT_COMPARE_STRING UTASSERT_COMPARE_STRINGW
#else // !UNICODE
#define UTASSERT_COMPARE_STRING UTASSERT_COMPARE_STRINGA
#endif // !UNICODE

//
// Do not use these functions directly; use the UTASSERT_ macros defined above
// instead.
//
static __inline
BOOL
__UTAssertEqual(
    DWORD dwExpected,
    DWORD dwActual,
    LPCTSTR pszFileName,
    DWORD dwLineNumber,
    LPCTSTR pszFailureDescription = NULL
    )
{
    if(dwExpected != dwActual)
    {
        UTLogError(
            TEXT("%s (%u) : %s"),
            pszFileName,
            dwLineNumber,
            pszFailureDescription
            );

        __UTASSERT_DO_ON_FAILURE;
    }

    __UTASSERT_DO_ON_SUCCESS;
}

static __inline 
BOOL 
__UTAssertNotEqual(
    DWORD dwUnexpected,
    DWORD dwActual,
    LPCTSTR pszFileName,
    DWORD dwLineNumber,
    LPCTSTR pszFailureDescription = NULL
    )
{
    if(dwUnexpected == dwActual)
    {
        UTLogError(
            TEXT("%s (%u) : %s"),
            pszFileName,
            dwLineNumber,
            pszFailureDescription
            );

        __UTASSERT_DO_ON_FAILURE;
    }

    __UTASSERT_DO_ON_SUCCESS;
}

static __inline
BOOL
__UTAssertCompareStringA(
    LPCSTR pszExpected,
    LPCSTR pszActual,
    LPCTSTR pszFileName,
    DWORD dwLineNumber,
    LPCTSTR pszFailureDescription = NULL
    )
{
    if(0 != strcmp(pszExpected, pszActual))
    {
        UTLogError(
            TEXT("%s (%u) : \"%S\" != \"%S\" \"%s\""),
            pszFileName,
            dwLineNumber,
            pszActual,
            pszExpected,
            pszFailureDescription
            );

        __UTASSERT_DO_ON_FAILURE;
    }

    __UTASSERT_DO_ON_SUCCESS;
}

static __inline
BOOL
__UTAssertCompareStringW(
    LPCWSTR pszExpected,
    LPCWSTR pszActual,
    LPCTSTR pszFileName,
    DWORD dwLineNumber,
    LPCWSTR pszFailureDescription = NULL
    )
{
    if(0 != wcscmp(pszExpected, pszActual))
    {
        UTLogError(
            TEXT("%s (%u) : \"%s\" != \"%s\" \"%s\""),
            pszFileName,
            dwLineNumber,
            pszActual,
            pszExpected,
            pszFailureDescription
            );

        __UTASSERT_DO_ON_FAILURE;
    }

    __UTASSERT_DO_ON_SUCCESS;
}

#endif // __UTASSERT_HPP_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\tux\Include\utbase.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
#pragma once

#include <windows.h>

#include "utlog.h"

extern "C" {
#include <katoex.h>
#include <tux.h>
#include <cmdline.h>
}

// Return E_CONTINUE if a test should be skipped
#define E_CONTINUE  HRESULT_FROM_WIN32(ERROR_CONTINUE)

typedef HRESULT (*PFN_TESTFUNCTION)(void);

// Unit test structure
struct UnitTest{
    WCHAR* szTestName;
    PFN_TESTFUNCTION pfnTest;
    WCHAR* pszGroups;
    UINT numThreads;
    DWORD dwTestParam;
};

enum GroupFunctionType
{
    GroupFunctionType_GroupSetup,
    GroupFunctionType_GroupTeardown,
    GroupFunctionType_TestSetup,
    GroupFunctionType_TestTeardown
};

struct GroupFunction
{
    WCHAR* szGroupName;
    PFN_TESTFUNCTION pfnGroup;
    GroupFunctionType type;    
};

// Functions implemented in utbase and called from the UT DLL
DWORD GetCurrentTestParam(void);
DWORD GetCurrentTestThreadIndex(void);

// Functions implemented in the UT DLL
HRESULT SuiteSetup(void);
HRESULT SuiteTeardown(void);
void ParseCommandLine(int argc, WCHAR* argv[]);

// Global shell info structure.  Set while processing SPM_SHELL_INFO message.
__declspec(selectany) SPS_SHELL_INFO *g_pShellInfo;

// Global logging object
__declspec(selectany) CKato *g_pLogger = NULL;
extern "C" {
   __declspec(dllexport) inline CKato* GetKato(void){return g_pLogger;}
}

// This class builds up the linked list of unit test functions.
class BuiltUTTable 
{
public:
    BuiltUTTable(UnitTest* tests, UINT numTests, GroupFunction* groups, UINT numGroups, const char* szFileName, UINT TestIndexBase);    
};

// ShellProc lives in utbase
extern "C" int InternalShellProc(UINT uMsg, SPPARAM spParam);
extern "C" extern inline INT WINAPI ShellProc(UINT uMsg, SPPARAM spParam)
{
#ifdef USE_WPP_LOGGING
    switch (uMsg)
    {
    case SPM_LOAD_DLL:
        UT_WPP_INIT_TRACING(L"Tux");
        break;
    case SPM_UNLOAD_DLL:
        UT_WPP_CLEANP();
        break;
    }
#endif
    return InternalShellProc(uMsg, spParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\tux\Include\xmltags.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
// --------------------------------------------------------------------
//                                                                     
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A      
// PARTICULAR PURPOSE.                                                 
//                                                                     
// --------------------------------------------------------------------

#ifndef __XMLTAGS_H__
#define __XMLTAGS_H__

#define MAXLOGMARKUPLENGTH	56

#define	XMLRAW				0x00000002
#define XMLPURE				0x00000004

//******************************************************************************
// Define EXTERN_C
//******************************************************************************

#ifndef EXTERN_C
   #ifdef __cplusplus
      #define EXTERN_C extern "C"
   #else
      #define EXTERN_C
   #endif
#endif

//******************************************************************************
// APIs for C and C++ interfaces
//******************************************************************************
EXTERN_C
void
XMLSetKatoObject(
	HKATO	hKato
);

EXTERN_C
void
XMLClearKatoObject();

EXTERN_C
void
XMLSetLogType(
	DWORD	dwLogType
);

EXTERN_C
void
XMLFileHeader(
);

EXTERN_C
void
XMLTestSuiteHeader(
	LPCTSTR		lpszSuiteName	= NULL,
	LPCTSTR		lpszSuiteDescr	= NULL,
	int			nTests			= 0
);

EXTERN_C
void
XMLTestCaseHeaderWTest(
	DWORD		dwTestID		= 0,
	LPCWSTR		lpszTestName	= NULL,
	LPCTSTR		lpszTestPath	= NULL,
	LPCTSTR		lpszTestCmdLine	= NULL,
	DWORD		dwTestRandomSeed	= 0,
	DWORD		dwTestThreadCount	= 0
);

EXTERN_C
void
XMLTestCaseHeaderATest(
	DWORD		dwTestID		= 0,
	LPCSTR		lpszTestName	= NULL,
	LPCTSTR		lpszTestPath	= NULL,
	LPCTSTR		lpszTestCmdLine	= NULL,
	DWORD		dwTestRandomSeed	= 0,
	DWORD		dwTestThreadCount	= 0
);

EXTERN_C
void
XMLTestCaseFooterWTest(
	DWORD		dwResult		= 0,
	DWORD		dwExecutionTime	= 0,
	DWORD		dwTestID		= 0,
	LPCWSTR		lpszTestName	= NULL,
	LPCTSTR		lpszTestPath	= NULL,
	LPCTSTR		lpszTestCmdLine	= NULL,
	DWORD		dwTestRandomSeed	= 0,
	DWORD		dwTestThreadCount	= 0
);

EXTERN_C
void
XMLTestCaseFooterATest(
	DWORD		dwResult		= 0,
	DWORD		dwExecutionTime	= 0,
	DWORD		dwTestID		= 0,
	LPCSTR		lpszTestName	= NULL,
	LPCTSTR		lpszTestPath	= NULL,
	LPCTSTR		lpszTestCmdLine	= NULL,
	DWORD		dwTestRandomSeed	= 0,
	DWORD		dwTestThreadCount	= 0
);

EXTERN_C
void
XMLTestSuiteFooter(
	DWORD		dwPassed	= 0,
	DWORD		dwFailed	= 0,
	DWORD		dwSkipped	= 0,
	DWORD		dwAborted	= 0,
	DWORD		dwSuiteTime	= 0,
	DWORD		dwTestsTime	= 0
);

EXTERN_C
LPWSTR
XMLGetLogStringW(
	LPCWSTR	lpwszString,
	LPWSTR	lpwszBuff,
	DWORD	dwBuffSize,
	LPVOID	id			= 0,
	DWORD	dwLevel		= 0,
	DWORD	dwLevelID	= 0,
	DWORD	dwVerbosity	= 0
);

EXTERN_C
LPSTR
XMLGetLogStringA(
	LPCSTR	lpszString,
	LPSTR	lpszBuff,
	DWORD	dwBuffSize,
	LPVOID	id			= 0,
	DWORD	dwLevel		= 0,
	DWORD	dwLevelID	= 0,
	DWORD	dwVerbosity	= 0
);

EXTERN_C
LPWSTR
XMLGetCommentStringW(
	LPCWSTR	lpwszString,
	LPWSTR	lpwszBuff,
	DWORD	dwBuffSize,
	LPVOID	id			= 0,
	DWORD	dwLevel		= 0,
	DWORD	dwLevelID	= 0,
	DWORD	dwVerbosity	= 0
);

EXTERN_C
LPSTR
XMLGetCommentStringA(
	LPCSTR	lpszString,
	LPSTR	lpszBuff,
	DWORD	dwBuffSize,
	LPVOID	id			= 0,
	DWORD	dwLevel		= 0,
	DWORD	dwLevelID	= 0,
	DWORD	dwVerbosity	= 0
);

EXTERN_C
LPWSTR
XMLizeStringW(
	LPCWSTR	lpwszString,
	LPWSTR	lpwszBuff,
	DWORD	dwBuffSize
);

EXTERN_C
LPSTR
XMLizeStringA(
	LPCSTR	lpszString,
	LPSTR	lpszBuff,
	DWORD	dwBuffSize
);

#ifdef UNICODE
	#define XMLTestCaseHeader	XMLTestCaseHeaderWTest
	#define XMLTestCaseFooter	XMLTestCaseFooterWTest
	#define XMLGetLogString		XMLGetLogStringW
	#define XMLizeString		XMLizeStringW
#else
	#define XMLTestCaseHeader	XMLTestCaseHeaderATest
	#define XMLTestCaseFooter	XMLTestCaseFooterATest
	#define XMLGetLogString		XMLGetLogStringA
	#define XMLizeString		XMLizeStringA
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\tux\Include\xtux.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
// --------------------------------------------------------------------
//                                                                     
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A      
// PARTICULAR PURPOSE.                                                 
//                                                                     
// --------------------------------------------------------------------
//
//  XTUX.H
//  Declares all types and methods for the extended TUX interface.
//
// --------------------------------------------------------------------

#ifndef __XTUX_H__
#define __XTUX_H__
#include "tux.h"
#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

////////////////////////////////////////////////////////////////////////////////
// Local macros

#ifndef XTAPI
    #define XTAPI __declspec(dllimport) WINAPI
#endif // XTAPI

////////////////////////////////////////////////////////////////////////////////
// Global macros

#define TPR_REPEAT  -1

////////////////////////////////////////////////////////////////////////////////
// Types

// Enumerations
typedef enum _tagXTMESSAGE
{
    XTM_TESTSETUP,
    XTM_TESTRESULT,
    XTM_E_CREATEPROCESS_FAILED,
    XTM_E_CREATEPROCESS_EXCEPTED
} XTMESSAGE;

// Forward declarations
typedef struct _tagXTTEA *LPXTTEA;
typedef struct _tagXTTEW *LPXTTEW;

// Function types
typedef INT (WINAPI *XTPROCA)(XTMESSAGE, LPXTTEA);
typedef INT (WINAPI *XTPROCW)(XTMESSAGE, LPXTTEW);

#define XTPROCAPI INT WINAPI

// Structures
typedef struct _tagXTTEA
{
    UINT        m_nLevel;
    LPCSTR      m_pszDescription;
    DWORD       m_dwUniqueID;
    LPCSTR      m_pszCommand;
    LPCSTR      m_pszArguments;
    XTPROCA     m_pfnTestProc;
    DWORD       m_dwUserData;
    DWORD       m_dwExitCode;
} XTTEA, *LPXTTEA;
typedef const XTTEA *LPCXTTEA;

typedef struct _tagXTTEW
{
    UINT        m_nLevel;
    LPCWSTR     m_pszDescription;
    DWORD       m_dwUniqueID;
    LPCWSTR     m_pszCommand;
    LPCWSTR     m_pszArguments;
    XTPROCW     m_pfnTestProc;
    DWORD       m_dwUserData;
    DWORD       m_dwExitCode;
} XTTEW, *LPXTTEW;
typedef const XTTEW *LPCXTTEW;

// Handles
typedef struct {} *HXTINSTANCE;

////////////////////////////////////////////////////////////////////////////////
// APIs

INT         XTAPI XTShellProc(HXTINSTANCE, UINT, SPPARAM);
HXTINSTANCE XTAPI XTRegisterTestsA(LPCSTR, LPCXTTEA);
HXTINSTANCE XTAPI XTRegisterTestsW(LPCWSTR, LPCXTTEW);

////////////////////////////////////////////////////////////////////////////////
// TCHAR handling

#if defined(UNICODE) || defined(_UNICODE)
    #define XTUNICODE           1
    #define XTTE                XTTEW
    #define LPXTTE              LPXTTEW
    #define LPCXTTE             LPCXTTEW
    #define XTPROC              XTPROCW
    #define XTRegisterTests     XTRegisterTestsW
#else // UNICODE
    #define XTUNICODE           0
    #define XTTE                XTTEA
    #define LPXTTE              LPXTTEA
    #define LPCXTTE             LPCXTTEA
    #define XTPROC              XTPROCA
    #define XTRegisterTests     XTRegisterTestsA
#endif // UNICODE
////////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus
#endif // __XTUX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\tux\Include\tux.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
//******************************************************************************
//
// TUX.H
//
// Definitions of Tux types, structures, and messages.
//
//******************************************************************************

#ifndef __TUX_H__
#define __TUX_H__

#include <windows.h>

// #define KTUX to support in-kernel testing with TUX.
// Requires Windows CE 6.0 +
#if defined(UNDER_CE) && ( CE_MAJOR_VER > 5 )
#define KTUX
#endif

//******************************************************************************
//***** Function Types
//******************************************************************************

// Forward declaration of LPFUNCTION_TABLE_ENTRY
typedef struct _FUNCTION_TABLE_ENTRY *LPFUNCTION_TABLE_ENTRY;

// Define our ShellProc Param and TestProc Param types
typedef LPARAM  SPPARAM;
typedef LPDWORD TPPARAM;

// Shell and Test message handling procs
typedef INT (WINAPI *SHELLPROC)(UINT uMsg, SPPARAM spParam);
typedef INT (WINAPI *TESTPROC )(UINT uMsg, TPPARAM tpParam, LPFUNCTION_TABLE_ENTRY lpFTE);

// SHELLPROCAPI and TESTPROCAPI
#ifdef __cplusplus
#define SHELLPROCAPI extern "C" INT __declspec(dllexport) WINAPI
#else
#define SHELLPROCAPI INT __declspec(dllexport) WINAPI
#endif
#define TESTPROCAPI  INT WINAPI

//******************************************************************************
//***** Function Table Entry Structure
//******************************************************************************

typedef struct _FUNCTION_TABLE_ENTRY {
   LPCTSTR  lpDescription; // description of test
   UINT     uDepth;        // depth of item in tree hierarchy
   DWORD    dwUserData;    // user defined data that will be passed to TestProc at runtime
   DWORD    dwUniqueID;    // uniquely identifies the test - used in loading/saving scripts
   TESTPROC lpTestProc;    // pointer to TestProc function to be called for this test
} FUNCTION_TABLE_ENTRY, *LPFUNCTION_TABLE_ENTRY;

//******************************************************************************
//***** ShellProc() Message values
//******************************************************************************

#define SPM_LOAD_DLL			   1
#define SPM_UNLOAD_DLL			   2
#define SPM_START_SCRIPT		   3
#define SPM_STOP_SCRIPT 		   4
#define SPM_BEGIN_DLL 			   5
#define SPM_END_DLL			       6
#define SPM_SHELL_INFO			   7
#define SPM_REGISTER			   8
#define SPM_EXCEPTION			   9
#define SPM_BEGIN_TEST			  10
#define SPM_END_TEST			  11
#define	SPM_STABILITY_INIT		  12
#define SPM_SETUP_GROUP			  13
#define SPM_TEARDOWN_GROUP		  14

//******************************************************************************
//***** ShellProc() Return values
//******************************************************************************

#define SPR_NOT_HANDLED            0
#define SPR_HANDLED                1
#define SPR_SKIP                   2
#define SPR_FAIL                   3

//******************************************************************************
//***** TestProc() Message values
//******************************************************************************

#define TPM_EXECUTE              101
#define TPM_QUERY_THREAD_COUNT   102

//******************************************************************************
//***** TestProc() Return values
//******************************************************************************

#define TPR_SKIP                   2
#define TPR_PASS                   3
#define TPR_FAIL                   4
#define TPR_ABORT                  5


//******************************************************************************
//***** Tux Exe process exit code
//******************************************************************************

#define	TXEC_GET_FAILS(exitCode)			((int) (HIWORD((DWORD) exitCode)))
#define	TXEC_GET_SKIPS(exitCode)			((int) (HIBYTE(LOWORD((DWORD) exitCode))))
#define	TXEC_GET_ABORTS(exitCode)			((int) (LOBYTE(LOWORD((DWORD) exitCode))))

// Note: we always nuke the high bit so that the
// exit code will not be mistaken for an exception (0xC000....)
// by GetExitCodeProcess().

#define	TXEC_SET_FAILS(exitCode, fails)		((int) ((exitCode & 0x0000FFFF) | ((fails & 0x7FFF) << 16)))
#define	TXEC_SET_SKIPS(exitCode, skips)		((int) ((exitCode & 0x7FFF00FF) | ((skips & 0xFF) << 8)))
#define	TXEC_SET_ABORTS(exitCode, aborts)	((int) ((exitCode & 0x7FFFFF00) | (aborts & 0xFF)))

#define	MAKE_TXEC(f, s, a)					((int) (0x7FFFFFFF & MAKELONG(MAKEWORD(a,s),f)))


//******************************************************************************
//***** ShellProc() Structures
//******************************************************************************

// ShellProc() Structure for SPM_LOAD_DLL message
typedef struct _SPS_LOAD_DLL {
   BOOL fUnicode;  // Set to true if your Dll is UNICODE
#ifdef KTUX
   TCHAR szPathName[MAX_PATH];
   TCHAR szFileName[MAX_PATH];
#endif //KTUX
} SPS_LOAD_DLL, *LPSPS_LOAD_DLL;


// ShellProc() Structure for SPM_STABILITY_INIT message
typedef struct _SPS_STABILITY_INFO
{
	DWORD	dwSize;		// size of the structure in bytes
	HINSTANCE hInstance;
	LPCTSTR	lpszCmd;  		// Command line arguments for stability harness
}
SPS_STABILITY_INFO, *LPSPS_STABILITY_INFO;


// ShellProc() Structure for SPM_SHELL_INFO message
typedef struct _SPS_SHELL_INFO {
   HINSTANCE hInstance;     // Instance handle of shell.
   HWND      hWnd;          // Main window handle of shell (currently set to NULL).
   HINSTANCE hLib;          // Test Dll instance handle.
   HANDLE    hevmTerminate; // Manual event that is set by Tux to inform all
                            // tests to shutdown (currently not used).
   BOOL      fUsingServer;  // Set if Tux is connected to Tux Server.
   LPCTSTR   szDllCmdLine;  // Command line arguments for test DLL.
   BOOL		 fXML;
} SPS_SHELL_INFO, *LPSPS_SHELL_INFO;

// ShellProc() Structure for SPM_REGISTER message
typedef struct _SPS_REGISTER {
   LPFUNCTION_TABLE_ENTRY lpFunctionTable;
} SPS_REGISTER, *LPSPS_REGISTER;

// ShellProc() Structure for SPM_SETUP_GROUP message
typedef struct _SPS_SETUP_GROUP {
   LPFUNCTION_TABLE_ENTRY lpFTE;
} SPS_SETUP_GROUP, *LPSPS_SETUP_GROUP;

// ShellProc() Structure for SPM_TEARDOWN_GROUP message
typedef struct _SPS_TEARDOWN_GROUP {
   LPFUNCTION_TABLE_ENTRY lpFTE;
   DWORD                  dwGroupTestsSkipped;
   DWORD                  dwGroupTestsPassed;
   DWORD                  dwGroupTestsFailed;
   DWORD                  dwGroupTestsAborted;
   DWORD                  dwGroupExecutionTime;
} SPS_TEARDOWN_GROUP, *LPSPS_TEARDOWN_GROUP;

// ShellProc() Structure for SPM_BEGIN_TEST message
typedef struct _SPS_BEGIN_TEST {
   LPFUNCTION_TABLE_ENTRY lpFTE;
   DWORD                  dwRandomSeed;
   DWORD                  dwThreadCount;
} SPS_BEGIN_TEST, *LPSPS_BEGIN_TEST;

// ShellProc() Structure for SPM_END_TEST message
typedef struct _SPS_END_TEST {
   LPFUNCTION_TABLE_ENTRY lpFTE;
   DWORD                  dwResult;
   DWORD                  dwRandomSeed;
   DWORD                  dwThreadCount;
   DWORD                  dwExecutionTime;
} SPS_END_TEST, *LPSPS_END_TEST;

// ShellProc() Structure for SPM_EXCEPTION message
typedef struct _SPS_EXCEPTION {
   LPFUNCTION_TABLE_ENTRY lpFTE;
   DWORD                  dwExceptionCode;
   EXCEPTION_POINTERS    *lpExceptionPointers;
   DWORD                  dwExceptionFilter;
   UINT                   uMsg;
} SPS_EXCEPTION, *LPSPS_EXCEPTION;


//******************************************************************************
//***** TestProc() Structures
//******************************************************************************

// TestProc() Structure for TPM_EXECUTE message
typedef struct _TPS_EXECUTE {
   DWORD dwRandomSeed;
   DWORD dwThreadCount;
   DWORD dwThreadNumber;
} TPS_EXECUTE, *LPTPS_EXECUTE;

// TestProc() Structure for TPM_QUERY_THREAD_COUNT message
typedef struct _TPS_QUERY_THREAD_COUNT {
   DWORD dwThreadCount;
} TPS_QUERY_THREAD_COUNT, *LPTPS_QUERY_THREAD_COUNT;

//******************************************************************************
//***** Old constants defined for compatibility - DO NOT USE THESE CONSTANTS!!!
//******************************************************************************

#define TPR_NOT_HANDLED   0
#define TPR_HANDLED       1
#define SPM_START_TESTS   SPM_BEGIN_GROUP
#define SPM_STOP_TESTS    SPM_END_GROUP
#define SHELLINFO         SPS_SHELL_INFO
#define LPSHELLINFO       LPSPS_SHELL_INFO
#define SPF_UNICODE       0x00010000

// These have been re-named SPM_BEGIN_DLL and SPM_END_DLL.
#define SPM_BEGIN_GROUP 		   5
#define SPM_END_GROUP			   6

#endif //__TUX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\App.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Windows;
using System.Collections.Generic;
using System.Linq;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// System.Windows.Controls samples application.
    /// </summary>
    public partial class App : Application
    {
        /// <summary>
        /// Initializes a new instance of the App class.
        /// </summary>
        public App()
        {
            Startup += delegate
            {
                RootVisual = new SampleBrowser(this.GetType().Assembly, SampleTreeItems);
            };
            InitializeComponent();
        }

        /// <summary>
        /// Gets a collection of SampleTreeItems to populate the SampleBrowser TreeView.
        /// </summary>
        public static IEnumerable<SampleTreeItem> SampleTreeItems
        {
            get
            {
                IEnumerable<object> data = Application.Current.Resources["SampleTreeView"] as IEnumerable<object>;
                return (data != null) ?
                    data.OfType<SampleTreeItem>() :
                    Enumerable.Empty<SampleTreeItem>();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\GlobalSuppressions.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.Diagnostics.CodeAnalysis;

[assembly: SuppressMessage("Microsoft.Design", "CA1014:MarkAssembliesWithClsCompliant", Justification = "Silverlight requires the use of types that are not CLS compliant.")]
/* Temporary */ [assembly: SuppressMessage("Microsoft.Design", "CA1020:AvoidNamespacesWithFewTypes", Scope = "namespace", Target = "System.Windows.Controls.Samples")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.DataGridGroupingSample.#dataGrid")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.DataGridSample.#dataGrid")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.DataPagerSample.#autoEllipsis")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.DataPagerSample.#numericButtonCount")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.DescriptionViewerSample.#city")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.DescriptionViewerSample.#email")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.DescriptionViewerSample.#firstName")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.DescriptionViewerSample.#lastName")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.DescriptionViewerSample.#phone")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.DescriptionViewerSample.#state")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.DescriptionViewerSample.#street1")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.DescriptionViewerSample.#street2")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.DescriptionViewerSample.#zip")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.ValidationSummarySample.#city")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.ValidationSummarySample.#email")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.ValidationSummarySample.#firstName")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.ValidationSummarySample.#lastName")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.ValidationSummarySample.#phone")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.ValidationSummarySample.#state")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.ValidationSummarySample.#street1")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.ValidationSummarySample.#street2")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.ValidationSummarySample.#zip")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.LabelSample.#city")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.LabelSample.#email")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.LabelSample.#firstName")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.LabelSample.#lastName")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.LabelSample.#phone")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.LabelSample.#state")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.LabelSample.#street1")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.LabelSample.#street2")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.LabelSample.#zip")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.DataFormFieldsSample.#dataForm")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.DataFormHeterogeneousDataSample.#dataForm")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.DataFormSample.#dataForm")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.DataFormTemplateSample.#dataForm")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.DataPagerSample.#totalItemCountFixed")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1020:AvoidNamespacesWithFewTypes", Scope = "namespace", Target = "System.Windows.Controls.Samples.Navigation")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.RatingSample.#rating")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.RatingSample.#RatingItemStyle")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\SampleHelpers.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.Windows.Media;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Helper class for general sample-related utility methods.
    /// </summary>
    internal static class SampleHelpers
    {
        /// <summary>
        /// Changes the alignment of a sample to Stretch so that its contents
        /// will automatically fill the available area.
        /// </summary>
        /// <param name="sample">Sample control to modify.</param>
        public static void ChangeSampleAlignmentToStretch(UserControl sample)
        {
            // Set sample to stretch
            sample.HorizontalAlignment = HorizontalAlignment.Stretch;
            sample.VerticalAlignment = VerticalAlignment.Stretch;

            // Find ContentPresenter parent (i.e., TabItem in Silverlight world)...
            FrameworkElement parent = sample;
            while (parent != null)
            {
                ContentPresenter tabItem = parent as ContentPresenter;
                if (tabItem != null)
                {
                    // Set to stretch as well
                    tabItem.HorizontalAlignment = HorizontalAlignment.Stretch;
                    tabItem.VerticalAlignment = VerticalAlignment.Stretch;
                    break;
                }

                // Move up a level
                parent = VisualTreeHelper.GetParent(parent) as FrameworkElement;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\ParseUtility.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Linq;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Media;
using System.Reflection;
using TypeConverterAttribute = System.ComponentModel.TypeConverterAttribute;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Utiilty class contains common helper functions.
    /// </summary>
    internal static class ParseUtility
    {
        /// <summary>
        /// Try to read a value of type T from passed in TextBox. 
        /// If succeeded, return the value; 
        /// If failed, return passed in default value, and highlighted the text in red.
        /// </summary>
        /// <typeparam name="T">Value type.</typeparam>
        /// <param name="tb">The TextBox whose Text value is to be parsed.</param>
        /// <param name="defaultValue">Default value to return in case of failure.</param>
        /// <returns>Value parsed from TextBox.Text or the passed in default value.</returns>
        [SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Justification = "No other common base class for all those exceptions.")]
        public static T ReadValue<T>(TextBox tb, T defaultValue)
        {
            T value = defaultValue;
            bool success = false;

            try
            {
                Type t = typeof(T);

                // first, try Convert.
                try
                {
                    value = (T)Convert.ChangeType(tb.Text, typeof(T), CultureInfo.CurrentCulture);
                    success = true;
                }
                catch (InvalidCastException)
                {
                }

                // second, try TypeConverter.
                if (!success)
                {
                    IEnumerable<TypeConverterAttribute> tcas;
                    TypeConverterAttribute tca;
                    Type tct;
                    TypeConverter tc;

                    if ((tcas = t.GetCustomAttributes(typeof(TypeConverterAttribute), true).Cast<TypeConverterAttribute>()) != null &&
                        (tca = tcas.FirstOrDefault()) != null &&
                        (tct = Type.GetType(tca.ConverterTypeName)) != null &&
                        (tc = Activator.CreateInstance(tct) as TypeConverter) != null &&
                        tc.CanConvertFrom(typeof(string)))
                    {
                        value = (T)tc.ConvertFromString(tb.Text);
                        success = true;
                    }
                }

                if (!success)
                {
                    // last, try Parse method.
                    MethodInfo mi = t.GetMethod("Parse", new Type[] { typeof(string) });
                    if (mi != null)
                    {
                        value = (T)mi.Invoke(null, new object[] { tb.Text });
                        success = true;
                    }
                }
            }
            catch (Exception)
            {
                // don't want to throw any exception.
            }

            if (success)
            {
                tb.Foreground = new SolidColorBrush(Colors.Black);
                return value;
            }
            else
            {
                tb.Foreground = new SolidColorBrush(Colors.Red);
                return defaultValue;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\Accordion\AccordionShowcase.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Two samples that completely restyles accordion.
    /// </summary>
    [Sample("Accordion Showcase", DifficultyLevel.Basic)]
    [Category("Accordion")]
    public partial class AccordionShowcase : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the 
        /// <see cref="AccordionShowcase"/> class.
        /// </summary>
        public AccordionShowcase()
        {
            InitializeComponent();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\Welcome.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.Reflection;
using System.Windows;
using System.Windows.Controls;
using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// The Welcome page is placed at the top of the samples list and is shown 
    /// when the page initially loads.
    /// </summary>
    /// <remarks>The SampleAttribute value is prefixed with a period to enable 
    /// it to show up at the top of the samples list. The period is removed in 
    /// the sample browser control.</remarks>
    [Sample("Welcome", DifficultyLevel.None)]
    [Category("Controls")]
    public partial class Welcome : UserControl
    {
        /// <summary>
        /// A token used for replacement of the assembly name.
        /// </summary>
        private const string AssemblyToken = "{ASSEMBLY}";

        /// <summary>
        /// A token used for replacement of the sample assembly name.
        /// </summary>
        private const string SampleAssemblyToken = "{SAMPLE_ASSEMBLY}";

        /// <summary>
        /// Initializes a new instance of the Welcome sample page.
        /// </summary>
        public Welcome()
        {
            InitializeComponent();

            // Replace the text tokens if the sample assembly token is found
            Loaded += new RoutedEventHandler(Welcome_Loaded);
        }

        /// <summary>
        /// The loaded event.
        /// </summary>
        /// <param name="sender">The source object.</param>
        /// <param name="e">The event data.</param>
        private void Welcome_Loaded(object sender, RoutedEventArgs e)
        {
            string welcome = WelcomeText.Text;
            if (welcome.Contains(SampleAssemblyToken))
            {
                // Extract the sample assembly name
                Assembly me = typeof(Welcome).Assembly;
                string friendlyAssembly = me.FullName;
                int comma = friendlyAssembly.IndexOf(',');
                if (comma >= 0)
                {
                    friendlyAssembly = friendlyAssembly.Substring(0, comma);
                }

                // Update the text value
                welcome = welcome.Replace(SampleAssemblyToken, friendlyAssembly);

                // Extract and set the sample assembly name
                if (welcome.Contains(AssemblyToken))
                {
                    string assembly = friendlyAssembly.Replace(".Samples", "");
                    welcome = welcome.Replace(AssemblyToken, assembly);
                }

                WelcomeText.Text = welcome;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\AutoCompleteBox\AutoCompleteBoxSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Diagnostics.CodeAnalysis;
using System.Windows;
using System.Windows.Controls;
using System.ComponentModel;

// Global suppressions for this sample
[assembly: SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.AutoCompleteBoxSample.#Value1")]
[assembly: SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.AutoCompleteBoxSample.#Value2")]
[assembly: SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.AutoCompleteBoxSample.#Value3")]
[assembly: SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.AutoCompleteBoxSample.#Value4")]
[assembly: SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.AutoCompleteBoxSample.#Value5")]
[assembly: SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.AutoCompleteBoxSample.#Value6")]
[assembly: SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.AutoCompleteBoxSample.#Value7")]
[assembly: SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.AutoCompleteBoxSample.#Value8")]
[assembly: SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.AutoCompleteBoxSample.#Value9")]

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// The AutoCompleteGettingStarted sample page shows several common uses 
    /// of the AutoCompleteBox control.
    /// </summary>
    [Sample("(0)AutoCompleteBox", DifficultyLevel.Basic)]
    [Category("AutoCompleteBox")]
    public partial class AutoCompleteBoxSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the AutoCompleteGettingStarted class.
        /// </summary>
        public AutoCompleteBoxSample()
        {
            InitializeComponent();
            Loaded += OnLoaded;
        }

        /// <summary>
        /// Hook up to the Loaded event.
        /// </summary>
        /// <param name="sender">The source object.</param>
        /// <param name="e">The event data.</param>
        private void OnLoaded(object sender, System.Windows.RoutedEventArgs e)
        {
            // Words
            WordComplete.ItemsSource = Words.GetAliceInWonderland();

            // Sliders
            SetDelay.ValueChanged += (s, args) => DynamicDelayAutoCompleteBox.MinimumPopulateDelay = (int)Math.Floor(SetDelay.Value);
            SetPrefixLength.ValueChanged += (s, args) => WordComplete.MinimumPrefixLength = (int)Math.Floor(SetPrefixLength.Value);
        }

        /// <summary>
        /// Called when an AutoCompleteBox's selected value changes. Uses the 
        /// Tag property to identify the content presenter to be updated.
        /// </summary>
        /// <param name="sender">The source AutoCompleteBox control.</param>
        /// <param name="e">The event data.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Event is wired up in XAML.")]
        private void OnSelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            AutoCompleteBox acb = (AutoCompleteBox)sender;

            // In these sample scenarios, the Tag is the name of the content 
            // presenter to use to display the value.
            string contentPresenterName = (string)acb.Tag;
            ContentPresenter cp = FindName(contentPresenterName) as ContentPresenter;
            if (cp != null)
            {
                cp.Content = acb.SelectedItem;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\Accordion\AccordionSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Windows.Data;
using System.Globalization;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample application for Accordion.
    /// </summary>
    [Sample("Accordion Playaround sample", DifficultyLevel.Basic)]
    [Category("Accordion")]
    public partial class AccordionSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="AccordionSample"/> class.
        /// </summary>
        public AccordionSample()
        {
            InitializeComponent();

            icSelectedIndices.SetBinding(
                ItemsControl.ItemsSourceProperty,
                new Binding("SelectedIndices") { Source = acc, Mode = BindingMode.OneWay });

            tbSelectedIndex.SetBinding(
                TextBox.TextProperty,
                new Binding("SelectedIndex") { Source = acc, Mode = BindingMode.TwoWay });

            acc.SetBinding(
                Accordion.SelectedIndexProperty,
                new Binding("Index") { Source = this, Mode = BindingMode.TwoWay });

            cbSelectionMode.SelectedItem = cbSelectionMode.Items
                .OfType<ComboBoxItem>()
                .FirstOrDefault(item => item.Content.Equals(acc.SelectionMode.ToString()));

            cbExpandDirection.SelectedItem = cbExpandDirection.Items
                .OfType<ComboBoxItem>()
                .FirstOrDefault(item => item.Content.Equals(acc.ExpandDirection.ToString()));

            cbSelectionSequence.SelectedItem = cbSelectionSequence.Items
                .OfType<ComboBoxItem>()
                .FirstOrDefault(item => item.Content.Equals(acc.SelectionSequence.ToString()));
        }

        /// <summary>
        /// Gets or sets the index.
        /// </summary>
        /// <value>The index.</value>
        public int Index
        {
            get { return index; }
            set
            {
                index = value;
                tbSelectedIndex.Text = value.ToString(CultureInfo.InvariantCulture);
            }
        }

        /// <summary>
        /// Backingfield for Index.
        /// </summary>
        private int index;

        /// <summary>
        /// Expands the direction changed.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="System.Windows.Controls.SelectionChangedEventArgs"/> instance containing the event data.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Hooked up in Xaml.")]
        private void ExpandDirectionChanged(object sender, SelectionChangedEventArgs e)
        {
            acc.ExpandDirection = (ExpandDirection)Enum.Parse(
                typeof(ExpandDirection),
                ((ComboBoxItem)cbExpandDirection.SelectedItem).Content.ToString(),
                true);
        }

        /// <summary>
        /// Sets the height.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="System.Windows.RoutedEventArgs"/> instance containing the event data.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Hooked up in Xaml.")]
        private void SetHeight(object sender, System.Windows.RoutedEventArgs e)
        {
            acc.Height = 500;
        }

        /// <summary>
        /// Removes the height.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="System.Windows.RoutedEventArgs"/> instance containing the event data.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Hooked up in Xaml.")]
        private void RemoveHeight(object sender, System.Windows.RoutedEventArgs e)
        {
            acc.ClearValue(Control.HeightProperty);
        }

        /// <summary>
        /// Selections the mode changed.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="System.Windows.Controls.SelectionChangedEventArgs"/> instance containing the event data.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Hooked up in Xaml.")]
        private void SelectionModeChanged(object sender, SelectionChangedEventArgs e)
        {
            acc.SelectionMode = (AccordionSelectionMode)Enum.Parse(
                typeof(AccordionSelectionMode),
                ((ComboBoxItem)cbSelectionMode.SelectedItem).Content.ToString(),
                true);
        }

        /// <summary>
        /// Selects all.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="System.Windows.RoutedEventArgs"/> instance containing the event data.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Hooked up in Xaml.")]
        private void SelectAll(object sender, RoutedEventArgs e)
        {
            acc.SelectAll();
        }

        /// <summary>
        /// Unselects all.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="System.Windows.RoutedEventArgs"/> instance containing the event data.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Hooked up in Xaml.")]
        private void UnselectAll(object sender, RoutedEventArgs e)
        {
            acc.UnselectAll();
        }

        /// <summary>
        /// React to selectionSequence event.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="System.Windows.Controls.SelectionChangedEventArgs"/> instance containing the event data.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Hooked up in Xaml.")]
        private void SelectionSequenceChanged(object sender, SelectionChangedEventArgs e)
        {
            acc.SelectionSequence = (SelectionSequence)Enum.Parse(
                typeof(SelectionSequence),
                ((ComboBoxItem)cbSelectionSequence.SelectedItem).Content.ToString(),
                true);
        }

        /// <summary>
        /// Removes the width.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="System.Windows.RoutedEventArgs"/> instance containing the event data.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Called by Xaml.")]
        private void RemoveWidth(object sender, RoutedEventArgs e)
        {
            acc.ClearValue(Control.WidthProperty);
        }

        /// <summary>
        /// Sets the width.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="System.Windows.RoutedEventArgs"/> instance containing the event data.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Called by Xaml.")]
        private void SetWidth(object sender, RoutedEventArgs e)
        {
            acc.Width = 300;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\Accordion\AccordionUsage.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Net;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Animation;
using System.Windows.Shapes;
using System.Globalization;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample page for Accordion, showing usages.
    /// </summary>
    [Sample("Accordion Usage samples", DifficultyLevel.Basic)]
    [Category("Accordion")]
    public partial class AccordionUsage : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="AccordionUsage"/> class.
        /// </summary>
        public AccordionUsage()
        {
            InitializeComponent();

            KeyValuePair<string, string>[] data = new KeyValuePair<string, string>[]
            {
                new KeyValuePair<string, string>("Hello", "World"),
                new KeyValuePair<string, string>("foo", "bar"),
                new KeyValuePair<string, string>("Silverlight", "Toolkit"),
            };

            // initialize accordions
            accordionGeneratedContent.ItemsSource = data;
            accordionDefaultHeaderTemplate.ItemsSource = data;
            accordionCLRTypes.ItemsSource = data;
            accordionAccordionItem.ItemsSource = data;
        }

        /// <summary>
        /// Handles the SelectionChanged event of the accordion control.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">The <see cref="System.Windows.Controls.SelectionChangedEventArgs"/> instance containing the event data.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Hooked up in Xaml")]
        private void Accordion_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            foreach (AccordionItem SelectedAccordionItem in e.AddedItems)
            {
                Debug.WriteLine(string.Format(
                    CultureInfo.InvariantCulture, 
                    "AccordionItem {0} has been selected.",
                    SelectedAccordionItem.Header));
            }
        }
        
        /// <summary>
        /// Handles the Click event of the btnExpandAll control.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">The <see cref="System.Windows.RoutedEventArgs"/> instance containing the event data.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Hooked up in Xaml")]
        private void ExpandAll_Click(object sender, RoutedEventArgs e)
        {
            accordionExpandCollapse.SelectAll();
        }

        /// <summary>
        /// Handles the Click event of the btnCollapseAll control.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">The <see cref="System.Windows.RoutedEventArgs"/> instance containing the event data.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Hooked up in Xaml")]
        private void CollapseAll_Click(object sender, RoutedEventArgs e)
        {
            accordionExpandCollapse.UnselectAll();
        }

        /// <summary>
        /// Handles the SelectionChanged event for the CLRTypes sample.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="System.Windows.Controls.SelectionChangedEventArgs"/> instance containing the event data.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Hooked up in Xaml")]
        private void CLRTypesSelectedItemsChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
                    foreach (
                        KeyValuePair<string, string> keyValuePair in
                            accordionCLRTypes.SelectedItems)
                    {
                        Debug.WriteLine("Interesting, people like seeing details on " +
                                        keyValuePair.Key);
                    }
        }

        /// <summary>
        /// Hooks up events for the MouseOver sample.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="System.Windows.RoutedEventArgs"/> instance containing the event data.</param>
        [SuppressMessage("Microsoft.Performance", "CA1804:RemoveUnusedLocals", MessageId = "keyValuePair", Justification = "TODO: THIS WILL BE REMOVED ONCE ITEM CONTAINER GENERATOR STUFF IS TAKEN CARE OF. TODO.")]
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Hooked up in Xaml")]
        private void SetMouseEvents(object sender, RoutedEventArgs e)
        {
            foreach (KeyValuePair<string, string> keyValuePair in accordionAccordionItem.Items)
            {
                AccordionItem container = accordionAccordionItem.ItemContainerGenerator.ContainerFromItem(keyValuePair) as AccordionItem;
                if (container != null)
                {
                    container.MouseEnter += (s, args) =>
                    {
                        if (!container.IsLocked)
                        {
                            container.IsSelected = true;
                        }
                    };

                    container.MouseLeave += (s, args) =>
                    {
                        if (!container.IsLocked)
                        {
                            container.IsSelected = false;
                        }
                    };
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\AutoCompleteBox\AutoCompleteComboBox.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Reflection;
using System.Windows.Controls.DataVisualization.Charting;
using System.Windows.Data;
using System.Windows.Media;

[assembly: SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.AutoCompleteComboBox.#ComboToggleButton", Justification = "Artifact of using a name inside the custom control template.")]

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// The AutoCompleteComboBox sample page shows the use of custom data
    /// objects, data templates, and a completely custom control template that 
    /// acts and looks much like a ComboBox with AutoCompleteBox capabilities.
    /// </summary>
    [Sample("(3)Styling", DifficultyLevel.Intermediate)]
    [Category("AutoCompleteBox")]
    public partial class AutoCompleteComboBox : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the AutoCompleteComboBox class.
        /// </summary>
        public AutoCompleteComboBox()
        {
            InitializeComponent();
            Loaded += OnLoaded;
        }

        /// <summary>
        /// Handle the Loaded event of the page.
        /// </summary>
        /// <param name="sender">The source object.</param>
        /// <param name="rea">The event arguments.</param>
        private void OnLoaded(object sender, RoutedEventArgs rea)
        {
            ControlApi.ItemFilter = (prefix, item) =>
            {
                if (string.IsNullOrEmpty(prefix))
                { 
                    return true; 
                }
                MemberInfoData pme = item as MemberInfoData;
                if (pme == null)
                {
                    return false; 
                }
                return (pme.Name.ToUpper(CultureInfo.InvariantCulture).Contains(prefix.ToUpper(CultureInfo.InvariantCulture)));
            };

            // Reflect and load data
            ControlApi.ItemsSource = MemberInfoData.GetSetForType(typeof(AutoCompleteBox));
            ControlPicker.ItemsSource = InitializeTypeList();

            // Set the changed handlers
            ControlApi.SelectionChanged += OnApiChanged;
            ControlPicker.SelectionChanged += OnPickerChanged;
            
            // Setup the dictionary converter
            ControlPicker.ValueMemberBinding = new Binding
            {
                Converter = new DictionaryKeyValueConverter<string, Type>()
            };
        }

        /// <summary>
        /// Update the API system.
        /// </summary>
        /// <param name="sender">The source object.</param>
        /// <param name="e">The selection changed event data.</param>
        private void OnPickerChanged(object sender, SelectionChangedEventArgs e)
        {
            if (ControlPicker.SelectedItem == null)
            {
                ControlApi.ItemsSource = null;
                ControlApi.Text = null;
                IntelliSenseIcon.Content = null;
                ControlApi.IsEnabled = false;
            }
            else
            {
                KeyValuePair<string, Type> pair = (KeyValuePair<string, Type>)ControlPicker.SelectedItem;
                ControlApi.ItemsSource = MemberInfoData.GetSetForType(pair.Value);
                ControlApi.IsEnabled = true;
            }
        }

        /// <summary>
        /// Update the visible content.
        /// </summary>
        /// <param name="sender">The source object.</param>
        /// <param name="e">The selection changed event data.</param>
        private void OnApiChanged(object sender, SelectionChangedEventArgs e)
        {
            MemberInfoData mim = ControlApi.SelectedItem as MemberInfoData;
            IntelliSenseIcon.Content = ControlApi.SelectedItem == null ? null : mim.Icon;
            SelectedInformation.Text = mim == null ? string.Empty : mim.MemberInfo.Name;
        }

        /// <summary>
        /// Initializes the type list.
        /// </summary>
        /// <returns>Returns a dictionary of string to Type values.</returns>
        private static Dictionary<string, Type> InitializeTypeList()
        {
            Dictionary<string, Type> typeList = new Dictionary<string, Type>();
            Assembly[] assemblies = 
            { 
                typeof(Button).Assembly,
                typeof(TreeView).Assembly,
                typeof(AutoCompleteBox).Assembly,
                typeof(Chart).Assembly,
            };
            foreach (Assembly assembly in assemblies)
            {
                foreach (Type type in assembly.GetExportedTypes())
                {
                    if (type.IsSubclassOf(typeof(Control)))
                    {
                        typeList.Add(type.FullName, type);
                    }
                }
            }
            return typeList;
        }

        /// <summary>
        /// Toggle the drop down for the control, part of the custom template.
        /// </summary>
        /// <param name="sender">The source object.</param>
        /// <param name="e">The event arguments.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Wired up in markup.")]
        private void DropDownToggle_Click(object sender, RoutedEventArgs e)
        {
            FrameworkElement fe = sender as FrameworkElement;
            AutoCompleteBox acb = null;
            while (fe != null && acb == null)
            {
                fe = VisualTreeHelper.GetParent(fe) as FrameworkElement;
                acb = fe as AutoCompleteBox;
            }
            if (acb != null)
            {
                if (string.IsNullOrEmpty(acb.SearchText))
                {
                    acb.Text = string.Empty;
                }
                acb.IsDropDownOpen = !acb.IsDropDownOpen;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\AutoCompleteBox\AutoCompleteLambda.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Globalization;
using System.Windows;
using System.Windows.Browser;
using System.Windows.Controls;
using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// The AutoCompleteLambda sample page demonstrates using a custom data 
    /// template, binding to elements in a rich CLR type, and using a lambda 
    /// expression to provide custom search filtering capabilities to the 
    /// AutoCompleteBox control.
    /// </summary>
    [Sample("(1)ItemFilter lambda", DifficultyLevel.Basic)]
    [Category("AutoCompleteBox")]
    public partial class AutoCompleteLambda : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the AutoCompleteLambda class.
        /// </summary>
        public AutoCompleteLambda()
        {
            InitializeComponent();
            Loaded += new RoutedEventHandler(Airports_Loaded);
        }

        /// <summary>
        /// Handle the Loaded event of the page.
        /// </summary>
        /// <param name="sender">The source object.</param>
        /// <param name="e">The event arguments.</param>
        private void Airports_Loaded(object sender, RoutedEventArgs e)
        {
            // Provide airport data and a custom filter
            ObjectCollection airports = Airport.SampleAirports;
            DepartureAirport.ItemsSource = airports;
            ArrivalAirport.ItemsSource = airports;
            DepartureAirport.ItemFilter = (search, item) =>
            {
                Airport airport = item as Airport;
                if (airport != null)
                {
                    // Interested in: Name, City, FAA code
                    string filter = search.ToUpper(CultureInfo.InvariantCulture);
                    return (airport.CodeFaa.ToUpper(CultureInfo.InvariantCulture).Contains(filter)
                        || airport.City.ToUpper(CultureInfo.InvariantCulture).Contains(filter)
                        || airport.Name.ToUpper(CultureInfo.InvariantCulture).Contains(filter));
                }

                return false;
            };
            ArrivalAirport.ItemFilter = DepartureAirport.ItemFilter;

            // Look for changes
            DepartureAirport.SelectionChanged += SelectedItemsChanged;
            ArrivalAirport.SelectionChanged += SelectedItemsChanged;
            DepartureDate.SelectedDateChanged += SelectedItemsChanged;
            ArrivalDate.SelectedDateChanged += SelectedItemsChanged;

            // Set the date defaults in code
            DepartureDate.SelectedDate = DateTime.UtcNow + TimeSpan.FromDays(7);
            ArrivalDate.SelectedDate = DateTime.UtcNow + TimeSpan.FromDays(14);

            // Navigate to Farecast
            BookFlight.Click += BookFlight_Click;
        }

        /// <summary>
        /// The button to book the flight has been clicked.
        /// </summary>
        /// <param name="sender">The source object.</param>
        /// <param name="e">The event data.</param>
        private void BookFlight_Click(object sender, RoutedEventArgs e)
        {
            Airport d = (Airport)DepartureAirport.SelectedItem;
            Airport a = (Airport)ArrivalAirport.SelectedItem;
            DateTime dd = (DateTime)DepartureDate.SelectedDate;
            DateTime ad = (DateTime)ArrivalDate.SelectedDate;
            int p = (int)Passengers.Value;

            Uri farecast = WebServiceHelper.CreateAirfareSearchUri(d, a, dd, ad, p);
            HtmlPage.Window.Navigate(farecast, "_new");
        }

        /// <summary>
        /// Update the form when valid values are present in the controls.
        /// </summary>
        /// <param name="sender">The source object.</param>
        /// <param name="e">The event data.</param>
        private void SelectedItemsChanged(object sender, SelectionChangedEventArgs e)
        {
            BookFlight.IsEnabled = DepartureAirport.SelectedItem != null
                && ArrivalAirport.SelectedItem != null
                && DepartureDate.SelectedDate != null
                && ArrivalDate.SelectedDate != null
                && Passengers.Value > 0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\AutoCompleteBox\DataGridAutoCompleteBox.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Globalization;
using System.Windows;
using System.Windows.Controls;
using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// A sample AutoCompleteBox with a DataGrid selection adapter.
    /// </summary>
    [Sample("DataGrid", DifficultyLevel.Advanced)]
    [Category("AutoCompleteBox")]
    public partial class DataGridAutoCompleteBox : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the type.
        /// </summary>
        public DataGridAutoCompleteBox()
        {
            InitializeComponent();
            Loaded += OnLoaded;
        }

        /// <summary>
        /// Handle the loaded event.
        /// </summary>
        /// <param name="sender">The source object.</param>
        /// <param name="e">The event data.</param>
        private void OnLoaded(object sender, RoutedEventArgs e)
        {
            // Bind to the sample airport data
            MyAutoCompleteBox.ItemsSource = Airport.SampleAirports;
            
            // A custom search, the same that is used in the basic lambda file
            MyAutoCompleteBox.FilterMode = AutoCompleteFilterMode.Custom;
            MyAutoCompleteBox.ItemFilter = (search, item) =>
            {
                Airport airport = item as Airport;
                if (airport != null)
                {
                    // Interested in: Name, City, FAA code
                    string filter = search.ToUpper(CultureInfo.InvariantCulture);
                    return (airport.CodeFaa.ToUpper(CultureInfo.InvariantCulture).Contains(filter)
                        || airport.City.ToUpper(CultureInfo.InvariantCulture).Contains(filter)
                        || airport.Name.ToUpper(CultureInfo.InvariantCulture).Contains(filter));
                }

                return false;
            };
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\AutoCompleteBox\CustomEvents.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Diagnostics.CodeAnalysis;
using System.Windows;
using System.Windows.Controls;
using System.ComponentModel;

// Global suppressions for this sample
[assembly: SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.CustomEvents.#Value1")]
[assembly: SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.CustomEvents.#Value2")]
[assembly: SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.CustomEvents.#Value3")]
[assembly: SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.CustomEvents.#Value4")]

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// The PopulationEvents class shows how a developer might hook into the 
    /// population events to provide custom data.
    /// </summary>
    [Sample("(2)Custom Events", DifficultyLevel.Basic)]
    [Category("AutoCompleteBox")]
    public partial class CustomEvents : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the type.
        /// </summary>
        public CustomEvents()
        {
            InitializeComponent();
            Loaded += OnLoaded;
        }

        /// <summary>
        /// Handle the Loaded event of the page.
        /// </summary>
        /// <param name="sender">The source object.</param>
        /// <param name="e">The event arguments.</param>
        private void OnLoaded(object sender, RoutedEventArgs e)
        {
            NowAutoComplete.Populating += OnPopulatingSynchronous;
            NowAutoComplete2.Populating += OnPopulatingSynchronous;
            LaterAutoComplete.Populating += OnPopulatingAsynchronous;
            LaterAutoComplete2.Populating += OnPopulatingAsynchronous;
        }

        /// <summary>
        /// The Populating event handler.
        /// </summary>
        /// <param name="sender">The source object.</param>
        /// <param name="e">The event data.</param>
        private void OnPopulatingSynchronous(object sender, PopulatingEventArgs e)
        {
            AutoCompleteBox source = (AutoCompleteBox)sender;

            source.ItemsSource = new string[]
            {
                e.Parameter + "1",
                e.Parameter + "2",
                e.Parameter + "3",
            };
        }

        /// <summary>
        /// The populating handler.
        /// </summary>
        /// <param name="sender">The source object.</param>
        /// <param name="e">The event data.</param>
        private void OnPopulatingAsynchronous(object sender, PopulatingEventArgs e)
        {
            AutoCompleteBox source = (AutoCompleteBox)sender;

            // Cancel the populating value: this will allow us to call 
            // PopulateComplete as necessary.
            e.Cancel = true;
            
            // Use the dispatcher to simulate an asynchronous callback when 
            // data becomes available
            Dispatcher.BeginInvoke(
                delegate
                {
                    source.ItemsSource = new string[]
                    {
                        e.Parameter + "1",
                        e.Parameter + "2",
                        e.Parameter + "3",
                    };

                    // Population is complete
                    source.PopulateComplete();
                });
        }

        /// <summary>
        /// Called when an AutoCompleteBox's selected value changes. Uses the 
        /// Tag property to identify the content presenter to be updated.
        /// </summary>
        /// <param name="sender">The source AutoCompleteBox control.</param>
        /// <param name="e">The event data.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Event handler is wired up in XAML.")]
        private void OnSelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            AutoCompleteBox acb = (AutoCompleteBox)sender;

            // In these sample scenarios, the Tag is the name of the content 
            // presenter to use to display the value.
            string contentPresenterName = (string)acb.Tag;
            ContentPresenter cp = FindName(contentPresenterName) as ContentPresenter;
            if (cp != null)
            {
                cp.Content = acb.SelectedItem;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\AutoCompleteBox\SampleEmployeeCollection.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Collections;
using System.Windows.Controls;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// A collection type that makes it easy to place sample employee data into 
    /// XAML.
    /// </summary>
    public class SampleEmployeeCollection : ObjectCollection
    {
        /// <summary>
        /// Initializes a new instance of the SampleEmployeeCollection class.
        /// </summary>
        public SampleEmployeeCollection()
            : base(Employee.AllExecutives)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\AutoCompleteBox\RandomEmployeeDetails.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Collections;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// RandomEmployeeDetails is a sample type that contains mostly random data 
    /// for use in DataGrid sample scenarios.
    /// </summary>
    public class RandomEmployeeDetails
    {
        /// <summary>
        /// A random number generator.
        /// </summary>
        private static Random RandomGenerator = new Random();

        /// <summary>
        /// Initializes a new instance of the RandomEmployeeDetails type. A 
        /// random number and bool value will be generated in the constructor.
        /// </summary>
        public RandomEmployeeDetails()
        {
            RandomNumber = RandomGenerator.Next();
            RandomTrueFalse = RandomGenerator.Next(0, 2) == 1;
        }

        /// <summary>
        /// Initializes a new instance of the RandomEmployeeDetails type.
        /// </summary>
        /// <param name="employee">An Employee object to read the Name from.</param>
        public RandomEmployeeDetails(Employee employee) : this()
        {
            Name = employee.DisplayName;
        }

        /// <summary>
        /// Gets or sets a name.
        /// </summary>
        public string Name { get; set; }

        /// <summary>
        /// Gets or sets a random number.
        /// </summary>
        public int RandomNumber { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether the value is true or false.
        /// </summary>
        public bool RandomTrueFalse { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\AutoCompleteBox\DataGridSelectionAdapter.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Collections;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.Windows;
using System.Windows.Automation.Peers;
using System.Windows.Controls;
using System.Windows.Input;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// An implementation of ISelectionAdapter for the DataGrid control. This 
    /// adapter, unlike the standard SelectorSelectionAdapter, actually derives 
    /// directly from DataGrid.
    /// </summary>
    public class DataGridSelectionAdapter : DataGrid, ISelectionAdapter
    {
        /// <summary>
        /// Gets or sets a value indicating whether the selection should be 
        /// ignored. Since the DataGrid automatically selects the first row 
        /// whenever the data changes, this simple implementation only works 
        /// with key navigation and mouse clicks. This prevents the text box 
        /// of the AutoCompleteBox control from being updated continuously.
        /// </summary>
        private bool IgnoreAnySelection { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether the selection change event 
        /// should not be fired.
        /// </summary>
        private bool IgnoringSelectionChanged { get; set; }

        /// <summary>
        /// Occurs when the currently selected item changes.
        /// </summary>
        public new event SelectionChangedEventHandler SelectionChanged;

        /// <summary>
        /// An event that indicates that a selection is complete and has been 
        /// made, effectively a commit action.
        /// </summary>
        public event RoutedEventHandler Commit;

        /// <summary>
        /// An event that indicates that the selection operation has been 
        /// canceled.
        /// </summary>
        public event RoutedEventHandler Cancel;

        /// <summary>
        /// Initializes a new instance of the SelectorSelectionAdapter class.
        /// </summary>
        public DataGridSelectionAdapter()
        {
            base.SelectionChanged += OnSelectionChanged;
            MouseLeftButtonUp += OnSelectorMouseLeftButtonUp;
        }

        /// <summary>
        /// Gets or sets the selected item through the adapter.
        /// </summary>
        public new object SelectedItem
        {
            get
            {
                return base.SelectedItem;
            }

            set
            {
                IgnoringSelectionChanged = true;
                base.SelectedItem = value;
                IgnoringSelectionChanged = false;
            }
        }

        /// <summary>
        /// Handles the mouse left button up event on the selector control.
        /// </summary>
        /// <param name="sender">The source object.</param>
        /// <param name="e">The event data.</param>
        private void OnSelectorMouseLeftButtonUp(object sender, MouseButtonEventArgs e)
        {
            IgnoreAnySelection = false;

            OnSelectionChanged(this, null);
            OnCommit(this, new RoutedEventArgs());
        }

        /// <summary>
        /// Handles the SelectionChanged event on the Selector control.
        /// </summary>
        /// <param name="sender">The source object.</param>
        /// <param name="e">The selection changed event data.</param>
        private void OnSelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (IgnoringSelectionChanged)
            {
                return;
            }

            if (IgnoreAnySelection)
            {
                return;
            }

            SelectionChangedEventHandler handler = this.SelectionChanged;
            if (handler != null)
            {
                handler(sender, e);
            }
        }

        /// <summary>
        /// Gets or sets the items source.
        /// </summary>
        public new IEnumerable ItemsSource
        {
            get { return base.ItemsSource; }
            
            set
            {
                if (base.ItemsSource != null)
                {
                    INotifyCollectionChanged notify = base.ItemsSource as INotifyCollectionChanged;
                    if (notify != null)
                    {
                        notify.CollectionChanged -= OnCollectionChanged;
                    }
                }

                base.ItemsSource = value;

                if (base.ItemsSource != null)
                {
                    INotifyCollectionChanged notify = base.ItemsSource as INotifyCollectionChanged;
                    if (notify != null)
                    {
                        notify.CollectionChanged += OnCollectionChanged;
                    }
                }
            }
        }

        /// <summary>
        /// Handles the CollectionChanged event, resetting the selection 
        /// ignore flag.
        /// </summary>
        /// <param name="sender">The source object.</param>
        /// <param name="e">The event data.</param>
        private void OnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            IgnoreAnySelection = true;
        }

        /// <summary>
        /// Gets the observable collection set by AutoCompleteBox.
        /// </summary>
        private ObservableCollection<object> Items
        {
            get { return ItemsSource as ObservableCollection<object>; }
        }

        /// <summary>
        /// Increment the selected index, or wrap.
        /// </summary>
        private void SelectedIndexIncrement()
        {
            SelectedIndex = SelectedIndex + 1 >= Items.Count ? -1 : SelectedIndex + 1;
            ScrollIntoView(SelectedItem, this.Columns[0]);
        }

        /// <summary>
        /// Decrement the SelectedIndex, or wrap around, inside the nested 
        /// SelectionAdapter's control.
        /// </summary>
        private void SelectedIndexDecrement()
        {
            int index = SelectedIndex;
            if (index >= 0)
            {
                SelectedIndex--;
            }
            else if (index == -1)
            {
                SelectedIndex = Items.Count - 1;
            }

            ScrollIntoView(SelectedItem, this.Columns[0]);
        }

        /// <summary>
        /// Process a key down event.
        /// </summary>
        /// <param name="e">The key event arguments object.</param>
        public void HandleKeyDown(KeyEventArgs e)
        {
            switch (e.Key)
            {
                case Key.Enter:
                    OnCommit(this, e);
                    e.Handled = true;
                    break;

                case Key.Up:
                    IgnoreAnySelection = false; 
                    SelectedIndexDecrement();
                    e.Handled = true;
                    break;

                case Key.Down:
                    if ((ModifierKeys.Alt & Keyboard.Modifiers) == ModifierKeys.None)
                    {
                        IgnoreAnySelection = false;
                        SelectedIndexIncrement();
                        e.Handled = true;
                    }
                    break;

                case Key.Escape:
                    OnCancel(this, e);
                    e.Handled = true;
                    break;

                default:
                    break;
            }
        }

        /// <summary>
        /// Fires the Commit event.
        /// </summary>
        /// <param name="sender">The source object.</param>
        /// <param name="e">The event data.</param>
        private void OnCommit(object sender, RoutedEventArgs e)
        {
            RoutedEventHandler handler = Commit;
            if (handler != null)
            {
                handler(sender, e);
            }

            AfterAdapterAction();
        }

        /// <summary>
        /// Fires the Cancel event.
        /// </summary>
        /// <param name="sender">The source object.</param>
        /// <param name="e">The event data.</param>
        private void OnCancel(object sender, RoutedEventArgs e)
        {
            RoutedEventHandler handler = Cancel;
            if (handler != null)
            {
                handler(sender, e);
            }

            AfterAdapterAction();
        }

        /// <summary>
        /// Change the selection after the actions are complete.
        /// </summary>
        private void AfterAdapterAction()
        {
            IgnoringSelectionChanged = true;
            SelectedItem = null;
            SelectedIndex = -1;
            IgnoringSelectionChanged = false;

            // Reset, to ignore any future changes
            IgnoreAnySelection = true;
        }

        /// <summary>
        /// Initializes a new instance of a DataGridAutomationPeer.
        /// </summary>
        /// <returns>Returns a new DataGridAutomationPeer.</returns>
        public AutomationPeer CreateAutomationPeer()
        {
            return new DataGridAutomationPeer(this);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\AutoCompleteBox\DataGridAutoCompleteBoxEdit.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Windows;
using System.Windows.Controls;
using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// The DataGridAutoCompleteBoxEdit class selects a small set of data to 
    /// display in the DataGrid. The XAML file contains the custom editing 
    /// template for AutoCompleteBox.
    /// </summary>
    [Sample("DataGrid Editing", DifficultyLevel.Advanced)]
    [Category("AutoCompleteBox")]
    public partial class DataGridAutoCompleteBoxEdit : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the DataGridAutoCompleteBoxEdit type.
        /// </summary>
        public DataGridAutoCompleteBoxEdit()
        {
            InitializeComponent();
            Loaded += OnLoaded;
        }

        /// <summary>
        /// Handle the Loaded event of the page. This creates a small, random 
        /// set of data to display in the grid.
        /// </summary>
        /// <param name="sender">The source object.</param>
        /// <param name="e">The event arguments.</param>
        private void OnLoaded(object sender, RoutedEventArgs e)
        {
            List<RandomEmployeeDetails> data = new List<RandomEmployeeDetails>();
            Random random = new Random();

            // Select up to 8 random employees
            foreach (Employee employee in 
                new SampleEmployeeCollection()
                    .Where(item => random.Next(2) == 0)
                    .Distinct()
                    .Take(8))
            {
                data.Add(new RandomEmployeeDetails(employee));
            }
            MyDataGrid.ItemsSource = data;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\AutoCompleteBox\DictionaryKeyValueConverter.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Diagnostics;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Reflection;
using System.IO;
using System.Linq;
using System.Windows;
using System.Windows.Data;
using System.Windows.Media.Imaging;
using System.Windows.Controls;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// A simple value converter.
    /// </summary>
    /// <typeparam name="TKey">The key type.</typeparam>
    /// <typeparam name="TValue">The value type.</typeparam>
    public class DictionaryKeyValueConverter<TKey, TValue> : IValueConverter
    {
        /// <summary>
        /// Converts the value back.
        /// </summary>
        /// <param name="value">The object reference.</param>
        /// <param name="targetType">The type object.</param>
        /// <param name="parameter">The optional parameter.</param>
        /// <param name="culture">The optional culture.</param>
        /// <returns>Returns an object or null.</returns>
        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            return null;
        }

        /// <summary>
        /// Convert the object to a string.
        /// </summary>
        /// <param name="value">The object reference.</param>
        /// <param name="targetType">The type object.</param>
        /// <param name="parameter">The optional parameter.</param>
        /// <param name="culture">The optional culture.</param>
        /// <returns>Returns an object or null.</returns>
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is KeyValuePair<TKey, TValue>)
            {
                KeyValuePair<TKey, TValue> pair = (KeyValuePair<TKey, TValue>)value;
                return pair.Key.ToString();
            }

            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\Calendar\CalendarSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.Windows;
using System.Windows.Controls;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample page demonstrating the Calendar.
    /// </summary>
    [Sample("Calendar", DifficultyLevel.Basic)]
    [Category("Calendar")]
    public partial class CalendarSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the CalendarSample class.
        /// </summary>
        public CalendarSample()
        {
            InitializeComponent();

            // Setting the DatePickers
            txtDisplayDate.Text = sampleCalendar.DisplayDate.ToShortDateString();
            txtSelectedDate.Text = sampleCalendar.SelectedDate.ToString();
        }

        /// <summary>
        /// Inherited code: Requires comment.
        /// </summary>
        /// <param name="sender">Inherited code: Requires comment 1.</param>
        /// <param name="e">Inherited code: Requires comment 2.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Event handler attached in XAML.")]
        [SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Justification = "Simplifies sample.")]
        private void OnPastDatesChanged(object sender, RoutedEventArgs e)
        {
            if (sampleCalendar == null)
            {
                return;
            }

            if ((bool)chkPastDateSelection.IsChecked)
            {
                sampleCalendar.BlackoutDates.Clear();
            }
            else
            {
                try
                {
                    sampleCalendar.BlackoutDates.AddDatesInPast();
                }
                catch
                {
                    chkPastDateSelection.IsChecked = true;
                }                
            }
        }
        
        /// <summary>
        /// Inherited code: Requires comment.
        /// </summary>
        /// <param name="sender">Inherited code: Requires comment 1.</param>
        /// <param name="e">Inherited code: Requires comment 2.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Event handler attached in XAML.")]
        [SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Justification = "Simplifies sample.")]
        private void OnDisplayDateStartSelected(object sender, SelectionChangedEventArgs e)
        {
            if (sampleCalendar == null)
            {
                return;
            }

            try
            {
                sampleCalendar.DisplayDateStart = e.AddedItems[0] as DateTime?;
            }
            catch
            {
                sampleCalendar.DisplayDateStart = null;
                dateStart.Text = "";
            }
        }

        /// <summary>
        /// Inherited code: Requires comment.
        /// </summary>
        /// <param name="sender">Inherited code: Requires comment 1.</param>
        /// <param name="e">Inherited code: Requires comment 2.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Event handler attached in XAML.")]
        [SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Justification = "Simplifies sample.")]
        private void OnDisplayDateEndSelected(object sender, SelectionChangedEventArgs e)
        {
            if (sampleCalendar == null)
            {
                return;
            }

            try
            {
                sampleCalendar.DisplayDateEnd = e.AddedItems[0] as DateTime?;
            }
            catch
            {
                sampleCalendar.DisplayDateEnd = null;
                dateEnd.Text = "";
            }
        }

        /// <summary>
        /// Inherited code: Requires comment.
        /// </summary>
        /// <param name="sender">Inherited code: Requires comment 1.</param>
        /// <param name="e">Inherited code: Requires comment 2.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Event handler attached in XAML.")]
        private void OnDisplayDateChanged(object sender, CalendarDateChangedEventArgs e)
        {
            if (sampleCalendar != null)
            {
                txtDisplayDate.Text = sampleCalendar.DisplayDate.ToShortDateString();
            }
        }

        /// <summary>
        /// Inherited code: Requires comment.
        /// </summary>
        /// <param name="sender">Inherited code: Requires comment 1.</param>
        /// <param name="e">Inherited code: Requires comment 2.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Event handler attached in XAML.")]
        private void OnSelectedDateChanged(object sender, SelectionChangedEventArgs e)
        {
            if (sampleCalendar != null && sampleCalendar.SelectedDate != null)
            {
                txtSelectedDate.Text = sampleCalendar.SelectedDate.ToString();
            }
        }

        /// <summary>
        /// Inherited code: Requires comment.
        /// </summary>
        /// <param name="sender">Inherited code: Requires comment 1.</param>
        /// <param name="e">Inherited code: Requires comment 2.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Event handler attached in XAML.")]
        private void OnSelectionModeChanged(object sender, RoutedEventArgs e)
        {
            if (sampleCalendar != null)
            {
                sampleCalendar.SelectionMode =
                    (sender == radioNone) ? CalendarSelectionMode.None :
                    (sender == radioSingleRange) ? CalendarSelectionMode.SingleRange :
                    (sender == radioMultiRange) ? CalendarSelectionMode.MultipleRange :
                    CalendarSelectionMode.SingleDate;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\AutoCompleteBox\SearchSuggestionSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Json;
using System.Linq;
using System.Net;
using System.Windows;
using System.Windows.Browser;
using System.Windows.Controls;
using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// A simple auto complete search suggestions sample that connects to a 
    /// real web service.
    /// </summary>
    [Sample("Search Suggestions", DifficultyLevel.Scenario)]
    [Category("AutoCompleteBox")]
    public partial class SearchSuggestionSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the SearchSuggestionSample class.
        /// </summary>
        public SearchSuggestionSample()
        {
            InitializeComponent();
            Loaded += OnLoaded;
        }

        /// <summary>
        /// Handles the Loaded event by initializing the control for live web 
        /// service use if the stack is available.
        /// </summary>
        /// <param name="sender">The source object.</param>
        /// <param name="e">The event data.</param>
        private void OnLoaded(object sender, RoutedEventArgs e)
        {
            if (WebServiceHelper.CanMakeHttpRequests)
            {
                HostingWarning.Visibility = Visibility.Collapsed;
                Go.IsEnabled = true;
                Search.IsEnabled = true;

                Search.Populating += Search_Populating;
                Action go = () => HtmlPage.Window.Navigate(WebServiceHelper.CreateWebSearchUri(Search.Text), "_blank");
                Search.KeyUp += (s, args) =>
                    {
                        if (args.Key == System.Windows.Input.Key.Enter)
                        {
                            go();
                        }
                    };
                Go.Click += (s, args) => go();
            }
        }

        /// <summary>
        /// Handle and cancel the Populating event, and kick off the web service
        /// request.
        /// </summary>
        /// <param name="sender">The source object.</param>
        /// <param name="e">The event data.</param>
        private void Search_Populating(object sender, PopulatingEventArgs e)
        {
            AutoCompleteBox autoComplete = (AutoCompleteBox)sender;

            // Allow us to wait for the response
            e.Cancel = true;

            // Create a request for suggestion
            WebClient wc = new WebClient();
            wc.DownloadStringCompleted += OnDownloadStringCompleted;
            wc.DownloadStringAsync(WebServiceHelper.CreateWebSearchSuggestionsUri(autoComplete.SearchText), autoComplete);
        }

        /// <summary>
        /// Handle the string download completed event of WebClient.
        /// </summary>
        /// <param name="sender">The source object.</param>
        /// <param name="e">The event data.</param>
        [SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Justification = "Any failure in the Json or request parsing should not be surfaced.")]
        private void OnDownloadStringCompleted(object sender, DownloadStringCompletedEventArgs e)
        {
            AutoCompleteBox autoComplete = e.UserState as AutoCompleteBox;
            if (autoComplete != null && e.Error == null && !e.Cancelled && !string.IsNullOrEmpty(e.Result))
            {
                List<string> data = new List<string>();
                try
                {
                    JsonObject jso = ((JsonObject)JsonObject.Parse(e.Result))["SearchSuggestion"] as JsonObject;
                    string originalSearchString = jso["Query"];
                    if (originalSearchString == autoComplete.SearchText)
                    {
                        foreach (JsonObject suggestion in (JsonArray)jso["Section"])
                        {
                            data.Add(suggestion.Values.First());
                        }

                        // Diplay the AutoCompleteBox drop down with any suggestions
                        autoComplete.ItemsSource = data;
                        autoComplete.PopulateComplete();
                    }
                }
                catch
                {
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\Charting\BubbleSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.Windows.Controls;
using System.Windows.Controls.DataVisualization.Charting;
using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample page demonstrating ScatterSeries.
    /// </summary>
    [Sample("Bubble", DifficultyLevel.Basic)]
    [Category("Bubble Series")]
    public partial class BubbleSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the ScatterSample class.
        /// </summary>
        public BubbleSample()
        {
            InitializeComponent();

            SampleGenerators.GenerateNumericSeriesSamples(GeneratedChartsPanel, () => new BubbleSeries(), true);
            SampleGenerators.GenerateDateTimeValueSeriesSamples(GeneratedChartsPanel, () => new BubbleSeries());
            SampleGenerators.GenerateMultipleValueSeriesSamples(GeneratedChartsPanel, () => new BubbleSeries(), true);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\Charting\AreaSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.Windows.Controls;
using System.Windows.Controls.DataVisualization.Charting;
using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample page demonstrating AreaSeries.
    /// </summary>
    [Sample("Area Series", DifficultyLevel.Basic)]
    [Category("Area Series")]
    public partial class AreaSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the AreaSample class.
        /// </summary>
        public AreaSample()
        {
            InitializeComponent();

            SampleGenerators.GenerateNumericSeriesSamples(GeneratedChartsPanel, () => new AreaSeries(), true);
            SampleGenerators.GenerateDateTimeValueSeriesSamples(GeneratedChartsPanel, () => new AreaSeries());
            SampleGenerators.GenerateMultipleValueSeriesSamples(GeneratedChartsPanel, () => new AreaSeries(), true);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\Charting\ColumnAnimationSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Controls.DataVisualization.Charting;
using System.Collections;
using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample page demonstrating Animations.
    /// </summary>
    [Sample("(2)Animation", DifficultyLevel.Advanced)]
    [Category("Column Series")]
    public partial class ColumnAnimationSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the AnimationSample class.
        /// </summary>
        public ColumnAnimationSample()
        {
            InitializeComponent();
        }

        /// <summary>
        /// Called when the Chart is clicked.
        /// </summary>
        /// <param name="sender">The object that raised the event.</param>
        /// <param name="e">Information about the event.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Attached to event handler in XAML.")]
        private void OnMouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            Chart chart = sender as Chart;

            if (null != chart)
            {
                // Toggle each Series ItemsSource so the reveal/hide animations can be seen
                foreach (DataPointSeries series in chart.Series)
                {
                    if (null == series.Tag)
                    {
                        series.Tag = series.ItemsSource;
                        series.ItemsSource = null;
                    }
                    else
                    {
                        series.ItemsSource = series.Tag as IEnumerable;
                        series.Tag = null;
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\Charting\BarSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.Windows.Controls;
using System.Windows.Controls.DataVisualization.Charting;
using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample page demonstrating BarSeries.
    /// </summary>
    [Sample("Bar Series", DifficultyLevel.Basic)]
    [Category("Bar Series")]
    public partial class BarSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the BarSample class.
        /// </summary>
        public BarSample()
        {
            InitializeComponent();

            SampleGenerators.GenerateNumericSeriesSamples(GeneratedChartsPanel, () => new BarSeries(), false);
            SampleGenerators.GenerateValueSeriesSamples(GeneratedChartsPanel, () => new BarSeries());
            SampleGenerators.GenerateCategoryValueSeriesSamples(GeneratedChartsPanel, () => new BarSeries());
            SampleGenerators.GenerateMultipleValueSeriesSamples(GeneratedChartsPanel, () => new BarSeries(), false);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\Charting\Overview.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Controls.DataVisualization.Charting;
using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample page demonstrating the Chart.
    /// </summary>
    [Sample("(1)Overview", DifficultyLevel.Basic)]
    [Category("DataVisualization")]
    public partial class OverviewSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the OverviewSample class.
        /// </summary>
        public OverviewSample()
        {
            InitializeComponent();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\Charting\PieAnimationSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Controls.DataVisualization.Charting;
using System.Collections;
using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample page demonstrating Animations.
    /// </summary>
    [Sample("(2)Animation", DifficultyLevel.Advanced)]
    [Category("Pie Series")]
    public partial class PieAnimationSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the AnimationSample class.
        /// </summary>
        public PieAnimationSample()
        {
            InitializeComponent();
        }

        /// <summary>
        /// Called when the Chart is clicked.
        /// </summary>
        /// <param name="sender">The object that raised the event.</param>
        /// <param name="e">Information about the event.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Attached to event handler in XAML.")]
        private void OnMouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            Chart chart = sender as Chart;

            if (null != chart)
            {
                // Toggle each Series ItemsSource so the reveal/hide animations can be seen
                foreach (DataPointSeries series in chart.Series)
                {
                    if (null == series.Tag)
                    {
                        series.Tag = series.ItemsSource;
                        series.ItemsSource = null;
                    }
                    else
                    {
                        series.ItemsSource = series.Tag as IEnumerable;
                        series.Tag = null;
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\Charting\ColumnSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.Windows.Controls;
using System.Windows.Controls.DataVisualization.Charting;
using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample page demonstrating ColumnSeries.
    /// </summary>
    [Sample("(1)Column", DifficultyLevel.Basic)]
    [Category("Column Series")]
    public partial class ColumnSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the ColumnSample class.
        /// </summary>
        public ColumnSample()
        {
            InitializeComponent();

            SampleGenerators.GenerateNumericSeriesSamples(GeneratedChartsPanel, () => new ColumnSeries(), false);
            SampleGenerators.GenerateValueSeriesSamples(GeneratedChartsPanel, () => new ColumnSeries());
            SampleGenerators.GenerateCategoryValueSeriesSamples(GeneratedChartsPanel, () => new ColumnSeries());
            SampleGenerators.GenerateMultipleValueSeriesSamples(GeneratedChartsPanel, () => new ColumnSeries(), false);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\Charting\LineSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.Windows.Controls;
using System.Windows.Controls.DataVisualization.Charting;
using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample page demonstrating ScatterSeries.
    /// </summary>
    [Sample("Line Series", DifficultyLevel.Basic)]
    [Category("Line Series")]
    public partial class LineSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the ScatterSample class.
        /// </summary>
        public LineSample()
        {
            InitializeComponent();

            SampleGenerators.GenerateNumericSeriesSamples(GeneratedChartsPanel, () => new LineSeries(), true);
            SampleGenerators.GenerateDateTimeValueSeriesSamples(GeneratedChartsPanel, () => new LineSeries());
            SampleGenerators.GenerateMultipleValueSeriesSamples(GeneratedChartsPanel, () => new LineSeries(), true);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\Charting\PieSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.Windows.Controls;
using System.Windows.Controls.DataVisualization.Charting;
using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample page demonstrating the Pie Chart.
    /// </summary>
    [Sample("(1)Pie", DifficultyLevel.Basic)]
    [Category("Pie Series")]
    public partial class PieSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the PieSample class.
        /// </summary>
        public PieSample()
        {
            InitializeComponent();

            SampleGenerators.GenerateNumericSeriesSamples(GeneratedChartsPanel, () => new PieSeries(), false);
            SampleGenerators.GenerateValueSeriesSamples(GeneratedChartsPanel, () => new PieSeries());
            SampleGenerators.GenerateCategoryValueSeriesSamples(GeneratedChartsPanel, () => new PieSeries());
            SampleGenerators.GenerateMultipleValueSeriesSamples(GeneratedChartsPanel, () => new PieSeries(), false);
        }

        /// <summary>
        /// Handles the SelectionChanged event of the "Drill-Down" sample Chart.
        /// </summary>
        /// <param name="sender">Event source.</param>
        /// <param name="e">Event arguments.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Attached to event handler in XAML.")]
        private void DrillDown_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            InformationPanel.DataContext = (1 <= e.AddedItems.Count) ? e.AddedItems[0] : null;
        }

        /// <summary>
        /// Handles the Click event of the "Unselect" button for the "Drill-Down" sample Chart.
        /// </summary>
        /// <param name="sender">Event source.</param>
        /// <param name="e">Event arguments.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Attached to event handler in XAML.")]
        private void Unselect_Click(object sender, System.Windows.RoutedEventArgs e)
        {
            (DrillDownChart.Series[0] as PieSeries).SelectedItem = null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\Charting\SampleGenerators.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Threading;
using System.Windows.Controls.DataVisualization.Charting;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Contains methods that generate sample Charts for any Series type.
    /// </summary>
    public static class SampleGenerators
    {
        /// <summary>
        /// Stores a shared ObservableCollection for use by the dynamic collection scenario.
        /// </summary>
        private static ObservableCollection<int> _dynamicCollectionItemsSource = new ObservableCollection<int>();

        /// <summary>
        /// Stores a shared List for use by the dynamic data items scenario.
        /// </summary>
        private static List<Pet> _dynamicDataItemsSource = new List<Pet>
        {
            new Pet { Species = "Dogs" },
            new Pet { Species = "Cats" },
            new Pet { Species = "Birds" },
            new Pet { Species = "Fish" },
        };

        /// <summary>
        /// Stores a shared List for use by the dynamic date items scenario.
        /// </summary>
        private static List<Pair> _dynamicDateItemsSource = new List<Pair>
        {
            new Pair { First = new DateTime(2008, 10, 11), Second = 0.0 },
            new Pair { First = new DateTime(2008, 10, 12), Second = 0.0 },
            new Pair { First = new DateTime(2008, 10, 13), Second = 0.0 },
            new Pair { First = new DateTime(2008, 10, 14), Second = 0.0 },
            new Pair { First = new DateTime(2008, 10, 15), Second = 0.0 },
            new Pair { First = new DateTime(2008, 10, 16), Second = 0.0 },
        };

        /// <summary>
        /// Stores a shared random number generator.
        /// </summary>
        private static Random _random = new Random();

        /// <summary>
        /// Initializes static members of the SampleGenerators class.
        /// </summary>
        [SuppressMessage("Microsoft.Performance", "CA1810:InitializeReferenceTypeStaticFieldsInline", Justification = "Need to do additional initialization.")]
        static SampleGenerators()
        {
            // Create a timer to update the dynamic data regularly
            DispatcherTimer dispatcherTimer = new DispatcherTimer();
            dispatcherTimer.Interval = TimeSpan.FromSeconds(2);
            dispatcherTimer.Tick += delegate
            {
                // Update _dynamicCollectionItemsSource
                _dynamicCollectionItemsSource.Add(_random.Next(1, 11));
                if (10 < _dynamicCollectionItemsSource.Count)
                {
                    _dynamicCollectionItemsSource.RemoveAt(0);
                }

                // Update _dynamicDataItemsSource
                foreach (Pet pet in _dynamicDataItemsSource)
                {
                    pet.Count = _random.Next(1, 20);
                }

                // Update _dynamicDateItemsSource
                foreach (Pair pair in _dynamicDateItemsSource)
                {
                    pair.Second = _random.NextDouble() * 20;
                }
            };
            dispatcherTimer.Start();
        }

        /// <summary>
        /// Generates numeric Series samples.
        /// </summary>
        /// <param name="panel">Panel to add the generated Charts to.</param>
        /// <param name="seriesConstructor">Function that returns a Series instance for each sample.</param>
        /// <param name="includeIndependentValueBinding">True if an IndependentValueBinding should be created.</param>
        public static void GenerateNumericSeriesSamples(Panel panel, Func<Series> seriesConstructor, bool includeIndependentValueBinding)
        {
            Binding independentValueBinding = includeIndependentValueBinding ? new Binding() : null;
            Scenario[] scenarios = new Scenario[]
            {
                new Scenario { Title = "One Int", ItemsSource = new int[] { 3 }, IndependentValueBinding = independentValueBinding },
                new Scenario { Title = "Three Ints", ItemsSource = new int[] { 4, 2, 7 }, IndependentValueBinding = independentValueBinding },
                new Scenario { Title = "Seven Doubles", ItemsSource = new double[] { 4.4, 6.2, 9.7, 7.0, 2.1, 8.3, 5.5 }, IndependentValueBinding = independentValueBinding },
                new Scenario { Title = "No Points", ItemsSource = new int[0], IndependentValueBinding = independentValueBinding },
                new Scenario { Title = "Some Points with Value 0", ItemsSource = new int[] { 0, 1, 0, 2, 0 }, IndependentValueBinding = independentValueBinding },
                new Scenario { Title = "Some Negative-Value Points", ItemsSource = new double[] { 2.1, 3.7, -2.5, -4.6, 1.0 }, IndependentValueBinding = independentValueBinding },
                new Scenario { Title = "High-Value Points", ItemsSource = new int[] { 2000000000, 1200000000, 2100000000, 1000000000, 2000000000 }, IndependentValueBinding = independentValueBinding },
                // new Scenario { Title = "100 Points", ItemsSource = Enumerable.Range(1, 100), IndependentValueBinding = independentValueBinding },
                new Scenario { Title = "Dynamic Collection", ItemsSource = _dynamicCollectionItemsSource, IndependentValueBinding = independentValueBinding },
            };
            GenerateSeriesSamples(panel, seriesConstructor, scenarios, null);
        }

        /// <summary>
        /// Generates value Series samples.
        /// </summary>
        /// <param name="panel">Panel to add the generated Charts to.</param>
        /// <param name="seriesConstructor">Function that returns a Series instance for each sample.</param>
        public static void GenerateValueSeriesSamples(Panel panel, Func<Series> seriesConstructor)
        {
            Scenario[] scenarios = new Scenario[]
            {
                new Scenario { Title = "Pet Counts (No Names)", ItemsSource = pets, DependentValueBinding = new Binding("Count") },
                new Scenario { Title = "Dynamic Data Items (No Names)", ItemsSource = _dynamicDataItemsSource, DependentValueBinding = new Binding("Count") },
            };
            GenerateSeriesSamples(panel, seriesConstructor, scenarios, null);
        }

        /// <summary>
        /// Generates category/value Series samples.
        /// </summary>
        /// <param name="panel">Panel to add the generated Charts to.</param>
        /// <param name="seriesConstructor">Function that returns a Series instance for each sample.</param>
        public static void GenerateCategoryValueSeriesSamples(Panel panel, Func<Series> seriesConstructor)
        {
            Scenario[] scenarios = new Scenario[]
            {
                new Scenario { Title = "Pet Counts (Names)", ItemsSource = pets, DependentValueBinding = new Binding("Count"), IndependentValueBinding = new Binding("Species") },
                new Scenario { Title = "Dynamic Data Items (Names)", ItemsSource = _dynamicDataItemsSource, DependentValueBinding = new Binding("Count"), IndependentValueBinding = new Binding("Species") },
            };
            GenerateSeriesSamples(panel, seriesConstructor, scenarios, null);
        }

        /// <summary>
        /// Generates value/value Series samples.
        /// </summary>
        /// <param name="panel">Panel to add the generated Charts to.</param>
        /// <param name="seriesConstructor">Function that returns a Series instance for each sample.</param>
        public static void GenerateValueValueSeriesSamples(Panel panel, Func<Series> seriesConstructor)
        {
            List<Point> circle = new List<Point>();
            for (double i = 0; i < 2 * Math.PI; i += 0.1)
            {
                circle.Add(new Point(Math.Sin(i), Math.Cos(i)));
            }
            Scenario[] scenarios = new Scenario[]
            {
                new Scenario { Title = "Circle", ItemsSource = circle, DependentValueBinding = new Binding("X"), IndependentValueBinding = new Binding("Y") },
            };
            GenerateSeriesSamples(panel, seriesConstructor, scenarios, null);
        }

        /// <summary>
        /// Generates value/value Series samples.
        /// </summary>
        /// <param name="panel">Panel to add the generated Charts to.</param>
        /// <param name="seriesConstructor">Function that returns a Series instance for each sample.</param>
        public static void GenerateDateTimeValueSeriesSamples(Panel panel, Func<Series> seriesConstructor)
        {
            Scenario[] scenarios = new Scenario[]
            {
                new Scenario { Title = "Value by Date", ItemsSource = _dynamicDateItemsSource, DependentValueBinding = new Binding("Second"), IndependentValueBinding = new Binding("First") },
            };
            Action<Chart> chartModifier = (chart) =>
            {
                IAxis dateAxis = new DateTimeAxis { Orientation = AxisOrientation.X };
                chart.Axes.Add(dateAxis);
                IAxis valueAxis = new LinearAxis { Orientation = AxisOrientation.Y, Minimum = 0, Maximum = 20, ShowGridLines = true };
                chart.Axes.Add(valueAxis);
            };
            GenerateSeriesSamples(panel, seriesConstructor, scenarios, chartModifier);
        }

        /// <summary>
        /// Generates multiple value Series samples.
        /// </summary>
        /// <param name="panel">Panel to add the generated Charts to.</param>
        /// <param name="seriesConstructor">Function that returns a Series instance for each sample.</param>
        /// <param name="includeIndependentValueBinding">True if an IndependentValueBinding should be created.</param>
        public static void GenerateMultipleValueSeriesSamples(Panel panel, Func<Series> seriesConstructor, bool includeIndependentValueBinding)
        {
            Binding independentValueBinding = includeIndependentValueBinding ? new Binding() : null;
            double[] items = new double[] { 3.1, 1.6, 4.9, 0.8, 2.2 };
            List<IEnumerable> itemsRepeated = new List<IEnumerable>();
            for (int i = 0; i < 30; i++)
            {
                itemsRepeated.Add(items);
            }
            Scenario[] scenarios = new Scenario[]
            {
                new Scenario { Title = "Three Series", ItemsSources = new IEnumerable[] { new int[] { 1, 2, 3 }, new int[] { 4, 5, 6 }, new int[] { 7, 8, 9 } }, IndependentValueBinding = independentValueBinding },
                // new Scenario { Title = "Thirty Series", ItemsSources = itemsRepeated, IndependentValueBinding = independentValueBinding },
            };
            GenerateSeriesSamples(panel, seriesConstructor, scenarios, null);
        }

        /// <summary>
        /// Generates various Series samples.
        /// </summary>
        /// <param name="panel">Panel to add the generated Charts to.</param>
        /// <param name="seriesConstructor">Function that returns a Series instance for each sample.</param>
        /// <param name="scenarios">Collection of scenarios to generate.</param>
        /// <param name="chartModifier">Function that applies any necessary modifications to the Chart.</param>
        private static void GenerateSeriesSamples(Panel panel, Func<Series> seriesConstructor, IEnumerable<Scenario> scenarios, Action<Chart> chartModifier)
        {
            Style wrapperStyle = Application.Current.Resources["WrapperStyle"] as Style;

            // For each scenario...
            foreach (Scenario scenario in scenarios)
            {
                // Create the sample Chart
                Chart chart = new Chart { Title = scenario.Title, MaxWidth = 500, MaxHeight = 270 };
                foreach (IEnumerable itemsSource in scenario.ItemsSources)
                {
                    DataPointSeries series = seriesConstructor() as DataPointSeries;
                    series.ItemsSource = itemsSource;
                    series.DependentValueBinding = scenario.DependentValueBinding;
                    series.IndependentValueBinding = scenario.IndependentValueBinding;
                    chart.Series.Add(series);
                }
                if (null != chartModifier)
                {
                    chartModifier(chart);
                }

                // Wrap the Chart in a suitably formatted Grid
                Grid grid = new Grid { Style = wrapperStyle };
                grid.Children.Add(chart);
                panel.Children.Add(grid);
            }
        }

        /// <summary>
        /// Collection of Pet objects for use by Chart samples.
        /// </summary>
        private static Pet[] pets = new Pet[]
        {
            new Pet { Species = "Dogs", Count = 5 },
            new Pet { Species = "Cats", Count = 4 },
            new Pet { Species = "Birds", Count = 6 },
            new Pet { Species = "Fish", Count = 9 }
        };

        /// <summary>
        /// Class representing an automatically generated Chart sample.
        /// </summary>
        private class Scenario
        {
            /// <summary>
            /// Gets or sets the title of the scenario.
            /// </summary>
            public string Title { get; set; }

            /// <summary>
            /// Sets the ItemsSource for the Chart's Series.
            /// </summary>
            public IEnumerable ItemsSource
            {
                set
                {
                    ItemsSources = new IEnumerable[] { value };
                }
            }

            /// <summary>
            /// Gets or sets the ItemsSources for the Chart's Series.
            /// </summary>
            public IEnumerable<IEnumerable> ItemsSources { get; set; }

            /// <summary>
            /// Gets or sets the DependentValueBinding for the Chart's Series.
            /// </summary>
            public Binding DependentValueBinding { get; set; }

            /// <summary>
            /// Gets or sets the IndependentValueBinding for the Chart's Series.
            /// </summary>
            public Binding IndependentValueBinding { get; set; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\Charting\ScatterSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.Windows.Controls;
using System.Windows.Controls.DataVisualization.Charting;
using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample page demonstrating ScatterSeries.
    /// </summary>
    [Sample("(1)Scatter Series", DifficultyLevel.Basic)]
    [Category("Scatter Series")]
    public partial class ScatterSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the ScatterSample class.
        /// </summary>
        public ScatterSample()
        {
            InitializeComponent();

            SampleGenerators.GenerateNumericSeriesSamples(GeneratedChartsPanel, () => new ScatterSeries(), true);
            SampleGenerators.GenerateDateTimeValueSeriesSamples(GeneratedChartsPanel, () => new ScatterSeries());
            SampleGenerators.GenerateValueValueSeriesSamples(GeneratedChartsPanel, () => new ScatterSeries());
            SampleGenerators.GenerateMultipleValueSeriesSamples(GeneratedChartsPanel, () => new ScatterSeries(), true);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\Charting\Scenarios\CustomSeries\CustomSeriesSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Linq;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Media;
using System.Windows.Controls.DataVisualization.Charting;
using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Charting sample demonstrating how to create a custom series.
    /// </summary>
    [Sample("(2)Custom Series", DifficultyLevel.Advanced)]
    [Category("DataVisualization")]
    public partial class CustomSeriesSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the CustomSeriesSample class.
        /// </summary>
        public CustomSeriesSample()
        {
            InitializeComponent();

            // Use a custom function for a series
            FunctionSeries series = CustomFunctionChart.Series[1] as FunctionSeries;
            series.Function = x => 110 + 3 * Math.Sin(x);
        }

        /// <summary>
        /// Perform a regression against the particulate levels data.
        /// </summary>
        /// <param name="sender">The regression ComboBox.</param>
        /// <param name="e">Event arguments.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Called by an event handler in XAML.")]
        [SuppressMessage("Microsoft.Performance", "CA1814:PreferJaggedArraysOverMultidimensional", MessageId = "Body", Justification = "Simplifies the sample.")]
        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Simplifies the sample.")]
        private void OnRegressionTypeChanged(object sender, SelectionChangedEventArgs e)
        {
            // Get the options and the series
            ComboBox combo = sender as ComboBox;
            if (combo == null || ParticulateAnalysis == null)
            {
                return;
            }
            ScatterSeries dataSeries = ParticulateAnalysis.Series[0] as ScatterSeries;
            FunctionSeries regressionSeries = ParticulateAnalysis.Series[1] as FunctionSeries;
            if (dataSeries == null || regressionSeries == null)
            {
                return;
            }

            // Get the active DataPoints (this assumes the default template for
            // ScatterSeries)
            Canvas plotArea = VisualTreeHelper.GetChild(dataSeries, 0) as Canvas;
            if (plotArea == null)
            {
                return;
            }
            List<DataPoint> activePoints =
                plotArea
                .Children
                .OfType<DataPoint>()
                .ToList();

            // The dimensions were added linearly to the ComboBox
            int dimension = combo.SelectedIndex + 1;

            // Initialize a simple least squares analysis
            int i = 0;
            int j = 0;
            int k = 0;
            double[] y = new double[activePoints.Count];
            double[,] x = new double[activePoints.Count, dimension + 1];
            for (i = 0; i < activePoints.Count; i++)
            {
                DataPoint point = activePoints[i];
                double independentValue = Convert.ToDouble(point.IndependentValue, CultureInfo.InvariantCulture);

                for (j = 0; j <= dimension; j++)
                {
                    x[i, j] = Math.Pow(independentValue, j);
                }

                y[i] = Convert.ToDouble(point.DependentValue, CultureInfo.InvariantCulture);
            }

            // Create the equations
            double[][] matrix = new double[dimension + 1][];
            for (i = 0; i <= dimension; i++)
            {
                // Create the row
                matrix[i] = new double[dimension + 2];

                // indeterminate coefficients
                for (j = 0; j <= dimension; j++)
                {
                    matrix[i][j] = 0.0;
                    for (k = 0; k < activePoints.Count; k++)
                    {
                        matrix[i][j] += x[k, i] * x[k, j];
                    }
                }

                // determinate values
                for (k = 0; k < activePoints.Count; k++)
                {
                    matrix[i][dimension + 1] += x[k, i] * y[k];
                }
            }

            // Convert to row-echelon form
            i = 0;
            j = 0;
            while (i <= dimension && j <= dimension)
            {
                // Get the pivot in column j starting at row i
                int pivotRow = i;
                for (k = i; k <= dimension; k++)
                {
                    if (Math.Abs(matrix[k][j]) > Math.Abs(matrix[pivotRow][j]))
                    {
                        pivotRow = k;
                    }
                }
                double pivot = matrix[pivotRow][j];

                // If we have a pivot element
                if (pivot != 0)
                {
                    // Swap the current row with the pivot row
                    double[] temp = matrix[i];
                    matrix[i] = matrix[pivotRow];
                    matrix[pivotRow] = temp;
                    pivotRow = i;

                    // Normalize the pivot row to the pivot
                    double c = matrix[i][j];
                    for (k = 0; k <= dimension + 1; k++)
                    {
                        matrix[i][k] /= c;
                    }

                    // Clear out the pivot position from the remaining rows
                    for (k = i + 1; k <= dimension; k++)
                    {
                        c = matrix[k][j];
                        for (int m = i; m <= dimension + 1; m++)
                        {
                            matrix[k][m] -= c * matrix[i][m];
                        }
                    }

                    i++;
                }

                j++;
            }

            // Solve using substitution
            for (i = dimension - 1; i >= 0; i--)
            {
                for (j = dimension; j > i; j--)
                {
                    matrix[i][dimension + 1] -= matrix[i][j] * matrix[j][dimension + 1];
                    matrix[i][j] = 0;
                }
            }

            // Capture the coefficients
            double a0 = matrix[0][dimension + 1];
            double a1 = matrix[1][dimension + 1];
            double a2 = (dimension >= 2) ? matrix[2][dimension + 1] : double.NaN;
            double a3 = (dimension >= 3) ? matrix[3][dimension + 1] : double.NaN;
            double a4 = (dimension == 4) ? matrix[4][dimension + 1] : double.NaN;

            // Create the function
            Func<double, double> function = null;
            switch (dimension)
            {
                case 1:
                    function = z => a1 * z + a0;
                    break;
                case 2:
                    function = z => a2 * z * z + a1 * z + a0;
                    break;
                case 3:
                    function = z => a3 * z * z * z + a2 * z * z + a1 * z + a0;
                    break;
                case 4:
                    function = z => a4 * z * z * z * z + a3 * z * z * z + a2 * z * z + a1 * z + a0;
                    break;
            }

            // Create the title
            StackPanel title = new StackPanel { Orientation = Orientation.Horizontal };
            title.Children.Add(
                new TextBlock
                {
                    Text = "f(x) = ",
                    Margin = new Thickness(0, 4, 0, 0)
                });

            title.Children.Add(
                new TextBlock
                {
                    Text = a0.ToString("N3", CultureInfo.InvariantCulture),
                    Margin = new Thickness(0, 4, 0, 0)
                });
            AddTitleTerm(title, a1, 1);
            if (dimension >= 2)
            {
                AddTitleTerm(title, a2, 2);
            }
            if (dimension >= 3)
            {
                AddTitleTerm(title, a3, 3);
            }
            if (dimension == 4)
            {
                AddTitleTerm(title, a4, 4);
            }

            // Set the function and the title
            regressionSeries.Function = function;
            regressionSeries.Title = title;
        }

        /// <summary>
        /// Add a term to the title.
        /// </summary>
        /// <param name="title">The title container.</param>
        /// <param name="value">The value of the term.</param>
        /// <param name="exponent">The exponent of the term.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Called by a method called by an event handler in XAML.")]
        private static void AddTitleTerm(StackPanel title, double value, int exponent)
        {
            if (value == 0)
            {
                return;
            }

            title.Children.Add(
                new TextBlock
                {
                    Text = value >= 0 ? " + " : " - ",
                    Margin = new Thickness(0, 4, 0, 0)
                });
            title.Children.Add(
                new TextBlock
                {
                    Text = string.Format(CultureInfo.InvariantCulture, "{0:N3}x", Math.Abs(value)),
                    Margin = new Thickness(0, 4, 0, 0)
                });

            if (exponent > 1)
            {
                title.Children.Add(
                    new TextBlock
                    {
                        Text = exponent.ToString(CultureInfo.InvariantCulture),
                        FontSize = 8
                    });
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\Charting\Data\Pair.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Class representing an untyped pair of values.
    /// </summary>
    public class Pair : INotifyPropertyChanged
    {
        /// <summary>
        /// Gets or sets the first value.
        /// </summary>
        public object First
        {
            get
            {
                return _first;
            }
            set
            {
                _first = value;
                OnPropertyChanged("First");
            }
        }

        /// <summary>
        /// Stores the value of the First property.
        /// </summary>
        private object _first;

        /// <summary>
        /// Gets or sets the second value.
        /// </summary>
        public object Second
        {
            get
            {
                return _second;
            }
            set
            {
                _second = value;
                OnPropertyChanged("Second");
            }
        }

        /// <summary>
        /// Stores the value of the Second property.
        /// </summary>
        private object _second;

        /// <summary>
        /// Implements the INotifyPropertyChanged interface.
        /// </summary>
        public event PropertyChangedEventHandler PropertyChanged;

        /// <summary>
        /// Fires the PropertyChanged event.
        /// </summary>
        /// <param name="propertyName">Name of the property that changed.</param>
        private void OnPropertyChanged(string propertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (null != handler)
            {
                handler.Invoke(this, new PropertyChangedEventArgs(propertyName));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\Charting\Data\Pet.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Class representing a species of pet for use by Chart samples.
    /// </summary>
    public class Pet : INotifyPropertyChanged
    {
        /// <summary>
        /// Gets or sets the species of the Pet.
        /// </summary>
        public string Species { get; set; }

        /// <summary>
        /// Gets or sets the number of Pets.
        /// </summary>
        public int Count
        {
            get
            {
                return _count;
            }
            set
            {
                _count = value;
                OnPropertyChanged("Count");
            }
        }

        /// <summary>
        /// Stores the pet count.
        /// </summary>
        private int _count;

        /// <summary>
        /// Fires the PropertyChanged event.
        /// </summary>
        /// <param name="propertyName">Property that changed.</param>
        private void OnPropertyChanged(string propertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (null != handler)
            {
                handler.Invoke(this, new PropertyChangedEventArgs(propertyName));
            }
        }

        /// <summary>
        /// Implements the INotifyPropertyChanged interface.
        /// </summary>
        public event PropertyChangedEventHandler PropertyChanged;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\Charting\Scenarios\CustomSeries\SimpleFunctionTypeConverter.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using Sle = System.Linq.Expressions;
using System.Text;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// TypeConverter used for creating single variable functions from simple
    /// arithmetic expressions.
    /// </summary>
    public class SimpleFunctionTypeConverter : TypeConverter
    {
        /// <summary>
        /// Initializes a new instance of the SimpleFunctionTypeConverter class.
        /// </summary>
        public SimpleFunctionTypeConverter()
        {
        }

        /// <summary>
        /// Determine whether the sourceType can be converted to a single
        /// variable function.
        /// </summary>
        /// <param name="context">Conversion context.</param>
        /// <param name="sourceType">The type to convert from.</param>
        /// <returns>
        /// A value indicating whether the type can be converted.
        /// </returns>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
        {
            return sourceType == typeof(string);
        }

        /// <summary>
        /// Convert the value into a single variable function.
        /// </summary>
        /// <param name="context">Conversion context.</param>
        /// <param name="culture">Conversion culture.</param>
        /// <param name="value">The value to convert.</param>
        /// <returns>A single variable function.</returns>
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
        {
            Func<double, double> function = null;

            string text = value as string;
            if (!string.IsNullOrEmpty(text))
            {
                function = new Parser(text).Function;
            }

            return function;
        }

        /// <summary>
        /// Defines the type of a token.
        /// </summary>
        private enum TokenType
        {
            /// <summary>
            /// A numeric value..
            /// </summary>
            Number,

            /// <summary>
            /// An identifier.
            /// </summary>
            Identifier,

            /// <summary>
            /// The addition operator.
            /// </summary>
            Addition,

            /// <summary>
            /// The substraction operator.
            /// </summary>
            Subtraction,

            /// <summary>
            /// The exponentiation operator.
            /// </summary>
            Multiplication,

            /// <summary>
            /// The division operator.
            /// </summary>
            Division,

            /// <summary>
            /// The exponentiation operator.
            /// </summary>
            Exponentiation,

            /// <summary>
            /// A left parenthesis.
            /// </summary>
            LeftParenthesis,

            /// <summary>
            /// A right parenthesis.
            /// </summary>
            RightParenthesis
        }

        /// <summary>
        /// Represents a lexical token.
        /// </summary>
        private class Token
        {
            /// <summary>
            /// Gets or sets the type of the token.
            /// </summary>
            public TokenType TokenType { get; set; }

            /// <summary>
            /// Gets or sets the value of a token (for numbers and identifiers).
            /// </summary>
            public object Value { get; set; }

            /// <summary>
            /// Initializes a new instance of the Token class.
            /// </summary>
            public Token()
            {
            }
        }

        /// <summary>
        /// Perform lexical analysis of simple expressions.
        /// </summary>
        private class Lexer
        {
            /// <summary>
            /// Gets or sets the input string to scan.
            /// </summary>
            internal string Input { get; set; }

            /// <summary>
            /// Gets or sets the current position of the lexer.
            /// </summary>
            internal int Position { get; set; }

            /// <summary>
            /// Gets a value indicating whether the lexer has room to advance
            /// through the input.
            /// </summary>
            internal bool CanAdvance
            {
                get { return Position < Input.Length; }
            }

            /// <summary>
            /// Gets the character at the current input position.
            /// </summary>
            private char Current
            {
                get { return Input[Position]; }
            }

            /// <summary>
            /// Gets or sets the lookahead token.
            /// </summary>
            private Token Lookahead { get; set; }

            /// <summary>
            /// Initializes a new instance of the Lexer class.
            /// </summary>
            /// <param name="input">The input to analyze.</param>
            public Lexer(string input)
            {
                Debug.Assert(!string.IsNullOrEmpty(input), "input shuould not be null or empty!");
                Input = input;
            }

            /// <summary>
            /// Advance the token to the next input.
            /// </summary>
            /// <returns>The token that was read.</returns>
            private Token ReadNext()
            {
                // Eat as much whitespace as possible
                while (CanAdvance && char.IsWhiteSpace(Current))
                {
                    Position++;
                }

                // Match a literal token
                Token token =
                    MatchLiteral('(', TokenType.LeftParenthesis) ??
                    MatchLiteral(')', TokenType.RightParenthesis) ??
                    MatchLiteral('+', TokenType.Addition) ??
                    MatchLiteral('-', TokenType.Subtraction) ??
                    MatchLiteral('*', TokenType.Multiplication) ??
                    MatchLiteral('/', TokenType.Division) ??
                    MatchLiteral('^', TokenType.Exponentiation);

                // Match identifier or number tokens
                if (token == null)
                {
                    int start = Position;
                    
                    // Try and match identifiers
                    while (CanAdvance && char.IsLetter(Current))
                    {
                        Position++;
                    }
                    if (start != Position)
                    {
                        token = new Token { TokenType = TokenType.Identifier };
                        token.Value = Input.Substring(start, Position - start);
                    }
                    else
                    {
                        // Try and match numbers
                        while (CanAdvance && char.IsDigit(Current))
                        {
                            Position++;
                        }
                        if (CanAdvance && Current == '.')
                        {
                            Position++;
                        }
                        while (CanAdvance && char.IsDigit(Current))
                        {
                            Position++;
                        }

                        if (start != Position)
                        {
                            token = new Token { TokenType = TokenType.Number };
                            token.Value = double.Parse(Input.Substring(start, Position - start), CultureInfo.InvariantCulture);
                        }
                    }
                }

                if (token != null)
                {
                    return token;
                }
                else if (CanAdvance)
                {
                    throw new FormatException(string.Format(CultureInfo.InvariantCulture, "Unknown token at position {0}!", Position));
                }
                else
                {
                    return null;
                }
            }

            /// <summary>
            /// Match a literal token.
            /// </summary>
            /// <param name="tokenChar">Character of the token.</param>
            /// <param name="tokenType">The type of the token.</param>
            /// <returns>The literal token, if matched.</returns>
            private Token MatchLiteral(char tokenChar, TokenType tokenType)
            {
                if (CanAdvance && Current == tokenChar)
                {
                    Position++;
                    return new Token { TokenType = tokenType };
                }

                return null;
            }

            /// <summary>
            /// Get the next input token.
            /// </summary>
            /// <returns>The next input token.</returns>
            public Token Get()
            {
                Token token = null;
                if (Lookahead != null)
                {
                    token = Lookahead;
                    Lookahead = null;
                }
                else
                {
                    token = ReadNext();
                }
                return token;
            }

            /// <summary>
            /// Peek at the lookahead token.
            /// </summary>
            /// <returns>The lookahead token.</returns>
            public Token Peek()
            {
                if (Lookahead == null)
                {
                    Lookahead = ReadNext();
                }
                return Lookahead;
            }
        }

        /// <summary>
        /// Perform syntactic analysis of simple expressions.
        /// </summary>
        /// <remarks>
        /// The parser uses the following grammar:
        ///    {Expression}
        ///         := {Term} '+' {Expression}
        ///         |  {Term} '-' {Expression}
        ///         |  {Term}
        ///    {Term}
        ///         := {Exponent} '*' {Term}
        ///         |  {Exponent} '/' {Term}
        ///         |  {Exponent}
        ///    {Exponent}
        ///         := {Factor} '^' {Exponent}
        ///         |  {Factor}
        ///    {Factor}
        ///         := {Number}
        ///         |  {Identifier}
        ///         | '(' {Expression} ')'
        /// </remarks>
        private class Parser
        {
            /// <summary>
            /// Gets or sets the lexer used for lexical analysis.
            /// </summary>
            private Lexer Lexer { get; set; }

            /// <summary>
            /// Gets or sets the single variable of the function.
            /// </summary>
            private Sle.ParameterExpression Parameter { get; set; }

            /// <summary>
            /// Gets the function created from the input.
            /// </summary>
            public Func<double, double> Function { get; private set; }

            /// <summary>
            /// Initializes a new instance of the Parser class.
            /// </summary>
            /// <param name="input">The input to analyze.</param>
            public Parser(string input)
            {
                Lexer = new Lexer(input);
                Parse();
            }

            /// <summary>
            /// Parse the input and create a function.
            /// </summary>
            private void Parse()
            {
                // Build the expression
                Sle.Expression expression = GetExpression();

                // Ensure we exhausted the input
                int finalPosition = Lexer.Position;
                Token finalToken = Lexer.Get();
                if (finalToken != null)
                {
                    throw new FormatException(string.Format(CultureInfo.InvariantCulture, "Unexpected token {0} at position {1}!", finalToken.TokenType, finalPosition));
                }

                // Wrap the expression in a function
                Sle.Expression<Func<double, double>> functionExpression =
                    Sle.Expression.Lambda<Func<double, double>>(
                        expression,
                        Parameter ?? Sle.Expression.Parameter(typeof(double), "x"));

                // Compile the expression into a function
                Function = functionExpression.Compile();
            }

            /// <summary>
            /// Read an expression.
            /// </summary>
            /// <returns>The parsed expression.</returns>
            private Sle.Expression GetExpression()
            {
                Sle.Expression term = GetTerm();
                if (TryMatch(TokenType.Addition))
                {
                    Sle.Expression expr = GetExpression();
                    return Sle.Expression.Add(term, expr);
                }
                else if (TryMatch(TokenType.Subtraction))
                {
                    Sle.Expression expr = GetExpression();
                    return Sle.Expression.Subtract(term, expr);
                }
                return term;
            }

            /// <summary>
            /// Read a term.
            /// </summary>
            /// <returns>The parsed term.</returns>
            private Sle.Expression GetTerm()
            {
                Sle.Expression exponent = GetExponent();
                if (TryMatch(TokenType.Multiplication))
                {
                    Sle.Expression term = GetTerm();
                    return Sle.Expression.Multiply(exponent, term);
                }
                else if (TryMatch(TokenType.Division))
                {
                    Sle.Expression term = GetTerm();
                    return Sle.Expression.Divide(exponent, term);
                }
                return exponent;
            }

            /// <summary>
            /// Read an exponent.
            /// </summary>
            /// <returns>The parsed exponent.</returns>
            private Sle.Expression GetExponent()
            {
                Sle.Expression factor = GetFactor();
                if (TryMatch(TokenType.Exponentiation))
                {
                    Sle.Expression power = GetExponent();
                    return Sle.Expression.Power(factor, power);
                }
                else
                {
                    return factor;
                }
            }

            /// <summary>
            /// Read a factor.
            /// </summary>
            /// <returns>The parsed factor.</returns>
            private Sle.Expression GetFactor()
            {
                Token token = Lexer.Get();
                if (token != null)
                {
                    if (token.TokenType == TokenType.Number)
                    {
                        return Sle.Expression.Constant(token.Value, typeof(double));
                    }
                    else if (token.TokenType == TokenType.Identifier)
                    {
                        string name = token.Value as string;

                        // Linq expressions use referential equality on
                        // parameters, so we need to use the same instance
                        if (Parameter != null && Parameter.Name != name)
                        {
                            throw new FormatException("Only single variable functions are supported!");
                        }
                        else if (Parameter == null)
                        {
                            Parameter = Sle.Expression.Parameter(typeof(double), name);
                        }
                        return Parameter;
                    }
                    else if (token.TokenType == TokenType.LeftParenthesis)
                    {
                        Sle.Expression nested = GetExpression();
                        if (TryMatch(TokenType.RightParenthesis))
                        {
                            return nested;
                        }
                    }
                }

                throw new FormatException(string.Format(CultureInfo.InvariantCulture, "Unexpected token type at position {0}!", Lexer.Position));
            }
            
            /// <summary>
            /// Try to match a token.
            /// </summary>
            /// <param name="tokenType">The type of token to match.</param>
            /// <returns>
            /// A value indicating whether the token was matched.
            /// </returns>
            private bool TryMatch(TokenType tokenType)
            {
                Token token = Lexer.Peek();
                if (token != null && token.TokenType == tokenType)
                {
                    Lexer.Get();
                    return true;
                }

                return false;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\Charting\Scenarios\CustomSeries\FunctionSeries.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Markup;
using System.Windows.Media;
using System.Windows.Controls.DataVisualization;
using System.Windows.Controls.DataVisualization.Charting;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// FunctionSeries is used to single variable functions on a chart.
    /// </summary>
    [TemplatePart(Name = FunctionSeries.PlotAreaName, Type = typeof(Canvas))]
    public sealed partial class FunctionSeries : Series, IRangeProvider, IAxisListener
    {
        /// <summary>
        /// The default control template would normally reside in generic.xaml,
        /// but the sample project is an application and doesn't have that file.
        /// We're just putting it here, but a real control project wouldn't.
        /// </summary>
        private const string DefaultTemplate =
@"<ControlTemplate
  xmlns='http://schemas.microsoft.com/client/2007'
  xmlns:x='http://schemas.microsoft.com/winfx/2006/xaml'
  xmlns:samples='clr-namespace:System.Windows.Controls.Samples;assembly=System.Windows.Controls.Samples'
  TargetType='samples:FunctionSeries'>
    <Canvas x:Name='PlotArea'>
        <Path
          Stroke='{TemplateBinding LineBrush}'
          StrokeThickness='{TemplateBinding LineThickness}'
          Data='{TemplateBinding Geometry}' />
    </Canvas>
</ControlTemplate>";

        #region Template Parts
        /// <summary>
        /// Name of the plot area canvas.
        /// </summary>
        private const string PlotAreaName = "PlotArea";

        /// <summary>
        /// Gets or sets the plot area canvas.
        /// </summary>
        private Canvas PlotArea { get; set; }
        #endregion Template Parts

        #region public Func<double, double> Function
        /// <summary>
        /// Gets or sets the function to plot.
        /// </summary>
        [TypeConverter(typeof(SimpleFunctionTypeConverter))]
        public Func<double, double> Function
        {
            get { return GetValue(FunctionProperty) as Func<double, double>; }
            set { SetValue(FunctionProperty, value); }
        }

        /// <summary>
        /// Identifies the Function dependency property.
        /// </summary>
        public static readonly DependencyProperty FunctionProperty =
            DependencyProperty.Register(
                "Function",
                typeof(Func<double, double>),
                typeof(FunctionSeries),
                new PropertyMetadata(null, OnFunctionPropertyChanged));

        /// <summary>
        /// FunctionProperty property changed handler.
        /// </summary>
        /// <param name="d">FunctionSeries that changed its Function.</param>
        /// <param name="e">Event arguments.</param>
        private static void OnFunctionPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            FunctionSeries source = d as FunctionSeries;
            source.Refresh();
        }
        #endregion public Func<double, double> Function

        #region public Geometry Geometry
        /// <summary>
        /// Gets or sets the geometry of the line object rendering the function.
        /// </summary>
        public Geometry Geometry
        {
            get { return GetValue(GeometryProperty) as Geometry; }
            set { SetValue(GeometryProperty, value); }
        }

        /// <summary>
        /// Identifies the Geometry dependency property.
        /// </summary>
        public static readonly DependencyProperty GeometryProperty =
            DependencyProperty.Register(
                "Geometry",
                typeof(Geometry),
                typeof(FunctionSeries),
                new PropertyMetadata(null));
        #endregion public Geometry Geometry

        #region public Brush LineBrush
        /// <summary>
        /// Gets or sets the brush used to plot the function.
        /// </summary>
        public Brush LineBrush
        {
            get { return GetValue(LineBrushProperty) as Brush; }
            set { SetValue(LineBrushProperty, value); }
        }

        /// <summary>
        /// Identifies the LineBrush dependency property.
        /// </summary>
        public static readonly DependencyProperty LineBrushProperty =
            DependencyProperty.Register(
                "LineBrush",
                typeof(Brush),
                typeof(FunctionSeries),
                new PropertyMetadata(null, OnLineBrushPropertyChanged));

        /// <summary>
        /// LineBrushProperty property changed handler.
        /// </summary>
        /// <param name="d">FunctionSeries that changed its LineBrush.</param>
        /// <param name="e">Event arguments.</param>
        private static void OnLineBrushPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            FunctionSeries source = d as FunctionSeries;
            Brush value = e.NewValue as Brush;
            source.LegendItem.DataContext = new ContentControl { Background = value };
        }
        #endregion public Brush LineBrush

        #region public double LineThickness
        /// <summary>
        /// Gets or sets the thickness of the line used to plot the function.
        /// </summary>
        public double LineThickness
        {
            get { return (double) GetValue(LineThicknessProperty); }
            set { SetValue(LineThicknessProperty, value); }
        }

        /// <summary>
        /// Identifies the LineThickness dependency property.
        /// </summary>
        public static readonly DependencyProperty LineThicknessProperty =
            DependencyProperty.Register(
                "LineThickness",
                typeof(double),
                typeof(FunctionSeries),
                new PropertyMetadata(1.0));
        #endregion public double LineThickness

        #region private IRangeAxis IndependentAxis
        /// <summary>
        /// Gets or sets the value of the independent axis.
        /// </summary>
        private IRangeAxis IndependentAxis
        {
            get { return GetValue(IndependentAxisProperty) as IRangeAxis; }
            set { SetValue(IndependentAxisProperty, value); }
        }

        /// <summary>
        /// Identifies the IndependentAxis dependency property.
        /// </summary>
        private static readonly DependencyProperty IndependentAxisProperty =
            DependencyProperty.Register(
                "IndependentAxis",
                typeof(IRangeAxis),
                typeof(FunctionSeries),
                null);
        #endregion protected IRangeAxis IndependentAxis

        #region private IRangeAxis DependentAxis
        /// <summary>
        /// Gets or sets the value of the dependent axis.
        /// </summary>
        private IRangeAxis DependentAxis
        {
            get { return GetValue(DependentAxisProperty) as IRangeAxis; }
            set { SetValue(DependentAxisProperty, value); }
        }

        /// <summary>
        /// Identifies the DependentAxis dependency property.
        /// </summary>
        private static readonly DependencyProperty DependentAxisProperty =
            DependencyProperty.Register(
                "DependentAxis",
                typeof(IRangeAxis),
                typeof(FunctionSeries),
                null);
        #endregion protected IRangeAxis DependentAxis

        /// <summary>
        /// Gets or sets the single chart legend item associated with the
        /// series.
        /// </summary>
        private LegendItem LegendItem { get; set; }

        /// <summary>
        /// Gets or sets the Geometry used to clip the line to the PlotArea
        /// bounds.
        /// </summary>
        private RectangleGeometry ClipGeometry { get; set; }

        /// <summary>
        /// Initializes a new instance of the FunctionSeries class.
        /// </summary>
        public FunctionSeries()
        {
            LegendItem = new LegendItem();
            LegendItems.Add(LegendItem);
            Clip = ClipGeometry = new RectangleGeometry();
            SizeChanged += OnSizeChanged;

            // Explicitly load the default template since the samples project
            // is an application and does not have a generic.xaml file.
            Template = XamlReader.Load(DefaultTemplate) as ControlTemplate;
            LineBrush = new SolidColorBrush(Colors.Purple);
        }

        /// <summary>
        /// Refreshes data from data source and renders the series.
        /// </summary>
        public override void Refresh()
        {
            if (SeriesHost == null || ActualWidth == 0)
            {
                return;
            }

            // Ensure we have a function to plot
            Func<double, double> function = Function;
            if (function == null)
            {
                return;
            }

            // Ensure we have axes
            IRangeAxis independent = GetAxis(AxisOrientation.X, IndependentAxis);
            IndependentAxis = independent;
            IRangeAxis dependent = GetAxis(AxisOrientation.Y, DependentAxis);
            DependentAxis = dependent;
            if (!independent.Range.HasData)
            {
                return;
            }

            // Create a geometry that matches the function to plot
            PathGeometry path = new PathGeometry();
            PathFigure figure = new PathFigure();

            // Get the range over which we will 
            double start = (double) independent.Range.Minimum;
            double end = (double) independent.Range.Maximum;

            // Adjust the line at each pixel
            double delta = (end - start) / ActualWidth;
            
            // We'll only add a new line segment when the slope is changing
            // between points
            Point last = GetPoint(start, function, independent, dependent);
            figure.StartPoint = last;
            double slope = double.NaN;
            for (double x = start + delta; x <= end; x += delta)
            {
                Point next = GetPoint(x, function, independent, dependent);
                double newSlope = (next.Y - last.Y) / (next.X - last.X);

                if (slope != newSlope)
                {
                    figure.Segments.Add(new LineSegment { Point = last });
                }

                slope = newSlope;
                last = next;
            }
            figure.Segments.Add(new LineSegment { Point = last });

            path.Figures.Add(figure);
            Geometry = path;
        }

        /// <summary>
        /// Get a point in screen coordinates.
        /// </summary>
        /// <param name="x">Independent value.</param>
        /// <param name="function">The function.</param>
        /// <param name="independent">The independent axis.</param>
        /// <param name="dependent">The dependent axis.</param>
        /// <returns>The point in screen coordinates.</returns>
        private Point GetPoint(double x, Func<double, double> function, IRangeAxis independent, IRangeAxis dependent)
        {
            // Get the dependent value
            double y = double.NaN;
            try
            {
                y = function(x);
            }
            catch (DivideByZeroException)
            {
            }

            // Map the actual values into coordinate values
            return new Point(
                independent.GetPlotAreaCoordinate(x).Value.Value,
                Math.Min(
                    Math.Max(
                        ActualHeight - dependent.GetPlotAreaCoordinate(y).Value.Value,
                        -1),
                    ActualHeight + 1));
        }

        /// <summary>
        /// Get the plot area after loading it from XAML.
        /// </summary>
        public override void OnApplyTemplate()
        {
            base.OnApplyTemplate();
            PlotArea = GetTemplateChild("PlotArea") as Canvas;
        }

        /// <summary>
        /// Updates the visual appearance of all the data points when the size
        /// changes. 
        /// </summary>
        /// <param name="sender">The series.</param>
        /// <param name="e">Event arguments.</param>
        private void OnSizeChanged(object sender, SizeChangedEventArgs e)
        {
            // Update the clip geometry
            ClipGeometry.Rect = new Rect(0.0, 0.0, e.NewSize.Width, e.NewSize.Height);

            // Update the PlotArea size and refresh.
            if (PlotArea != null)
            {
                PlotArea.Width = e.NewSize.Width;
                PlotArea.Height = e.NewSize.Height;
                Refresh();
            }
        }

        /// <summary>
        /// Sets all the text the legend items to the title.
        /// </summary>
        /// <param name="oldValue">The old title.</param>
        /// <param name="newValue">The new title.</param>
        protected override void OnTitleChanged(object oldValue, object newValue)
        {
            base.OnTitleChanged(oldValue, newValue);
            LegendItem.Content = Title;
        }

        /// <summary>
        /// Get or create a linear numeric axis in the correct dimension.
        /// </summary>
        /// <param name="orientation">Dimension of the axis to create.</param>
        /// <param name="oldAxis">
        /// Old value of the axis in this dimension.
        /// </param>
        /// <returns>New value of the axis in this dimension.</returns>
        private IRangeAxis GetAxis(AxisOrientation orientation, IRangeAxis oldAxis)
        {
            // Check the existing axes for a potential axis
            IRangeAxis axis =
                (from IRangeAxis a in SeriesHost.Axes.OfType<IRangeAxis>()
                 where a.Orientation == orientation
                 select a)
                .FirstOrDefault();

            if (axis == null)
            {
                // Create a new axis if not found
                axis = new LinearAxis
                {
                    Orientation = orientation,
                };
            }

            if (oldAxis != axis)
            {
                // Unregister any existing axis
                if (oldAxis != null)
                {
                    oldAxis.RegisteredListeners.Remove(this);
                }
                
                // Register the new axis
                if (!axis.RegisteredListeners.Contains(this))
                {
                    axis.RegisteredListeners.Add(this);
                }
            }

            return axis;
        }

        /// <summary>
        /// Updates the series when the axis is invalidated.
        /// </summary>
        /// <param name="axis">The axis that was invalidated.</param>
        public void AxisInvalidated(IAxis axis)
        {
            if (DependentAxis != null && IndependentAxis != null)
            {
                Refresh();
            }
        }

        /// <summary>
        /// Ensures that chart and series are kept in a consistent state when a
        /// series is added or removed from a chart. 
        /// </summary>
        /// <param name="oldValue">Old chart.</param>
        /// <param name="newValue">New chart.</param>
        protected override void OnSeriesHostPropertyChanged(ISeriesHost oldValue, ISeriesHost newValue)
        {
            IRangeAxis axis = null;

            // Unregister the axes from the old chart
            if (oldValue != null)
            {
                axis = IndependentAxis;
                if (axis != null)
                {
                    axis.RegisteredListeners.Remove(this);
                    IndependentAxis = null;
                }

                axis = DependentAxis;
                if (axis != null)
                {
                    axis.RegisteredListeners.Remove(this);
                    DependentAxis = null;
                }
            }

            // Register the axes with new chart
            if (newValue != null)
            {
                axis = IndependentAxis;
                if (axis != null)
                {
                    axis.RegisteredListeners.Add(this);
                }

                axis = DependentAxis;
                if (axis != null)
                {
                    axis.RegisteredListeners.Add(this);
                }
            }

            base.OnSeriesHostPropertyChanged(oldValue, newValue);
        }

        /// <summary>
        /// If data is found returns the minimum and maximum dependent numeric
        /// values. 
        /// </summary>
        /// <param name="rangeConsumer">IRangeConsumer that needs the data.</param>
        /// <returns>
        /// The range of values or empty if no data is present.
        /// </returns>
        public Range<IComparable> GetRange(IRangeConsumer rangeConsumer)
        {
            // Use an empty range so we only plot over the area used by other
            // axes.
            return new Range<IComparable>();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\Charting\Scenarios\SeriesZoom\SeriesZoomSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Collections.Generic;
using System.Windows;
using System.Windows.Controls;
using System.Linq;
using System.Diagnostics;
using System.Windows.Media;
using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Charting sample that demonstrates zooming.
    /// </summary>
    [Sample("Zoom", DifficultyLevel.Scenario)]
    [Category("DataVisualization")]
    public partial class SeriesZoomSample : UserControl
    {
        /// <summary>
        /// Caching of the ChartArea template part.
        /// </summary>
        private Panel chartArea;

        /// <summary>
        /// Gets the ChartArea.
        /// </summary>
        /// <returns>TemplatePart ChartArea</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Called by ZoomChanged.")]
        private Panel ChartArea
        {
            get
            {
                if (chartArea == null)
                {
                    chartArea = GetLogicalChildrenBreadthFirst(ZoomChart).Where(element => element.Name.Equals("ChartArea")).FirstOrDefault() as Panel;
                }

                return chartArea;
            }
        }

        /// <summary>
        /// Caching of the ScrollArea template part.
        /// </summary>
        private ScrollViewer scrollArea;

        /// <summary>
        /// Gets the ScrollArea.
        /// </summary>
        /// <returns>TemplatePart ScrollArea</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Called by an event handler in XAML.")]
        private ScrollViewer ScrollArea
        {
            get
            {
                if (scrollArea == null)
                {
                    scrollArea = GetLogicalChildrenBreadthFirst(ZoomChart).Where(element => element.Name.Equals("ScrollArea")).FirstOrDefault() as ScrollViewer;
                }
                return scrollArea;
            }
        } 

        /// <summary>
        /// Initializes a new instance of the ZoomIntoChartSample class.
        /// </summary>
        public SeriesZoomSample()
        {
            InitializeComponent();

            this.Loaded += ZoomIntoChartSample_Loaded;
        }

        /// <summary>
        /// Force an update of the chart.
        /// </summary>
        /// <param name="sender">The ZoomIntoChartSample instance.</param>
        /// <param name="e">Event arguments.</param>
        private void ZoomIntoChartSample_Loaded(object sender, RoutedEventArgs e)
        {
            // force synchronous layout pass
            ZoomChart.UpdateLayout();

            // and force initial zoom 
            UpdateChart(0);
        }
        
        /// <summary>
        /// Handles the changing of the zoomlevel.
        /// </summary>
        /// <param name="sender">The zoom slider.</param>
        /// <param name="e">Event arguments.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Called by an event handler in XAML.")]
        private void ZoomChanged(object sender, RoutedPropertyChangedEventArgs<double> e)
        {
            Debug.Assert(ChartArea != null && ScrollArea != null, "Zoom should not be called before layout has occurred");

            double zoom = e.NewValue;

            UpdateChart(zoom);
        }

        /// <summary>
        /// Updates the chart to zoom with the correct zoom factor.
        /// </summary>
        /// <param name="zoom">The percentage of zoom we wish to apply.</param>
        private void UpdateChart(double zoom)
        {
            ChartArea.Width = ScrollArea.ViewportWidth + (ScrollArea.ViewportWidth * zoom / 100.0);
        }

        /// <summary>
        /// Helper function that returns a list of the visual children.
        /// </summary>
        /// <param name="parent">Element whose visual children will be returned.</param>
        /// <returns>A collection of visualchildren.</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Called by ChartArea and ScrollArea.")]
        private IEnumerable<FrameworkElement> GetLogicalChildrenBreadthFirst(FrameworkElement parent)
        {
            Debug.Assert(parent != null, "The parent cannot be null.");

            Queue<FrameworkElement> queue =
                new Queue<FrameworkElement>(GetVisualChildren(parent).OfType<FrameworkElement>());

            while (queue.Count > 0)
            {
                FrameworkElement element = queue.Dequeue();
                yield return element;

                foreach (FrameworkElement visualChild in GetVisualChildren(element).OfType<FrameworkElement>())
                {
                    queue.Enqueue(visualChild);
                }
            }
        }

        /// <summary>
        /// Helper function that returns the direct visual children of an element.
        /// </summary>
        /// <param name="parent">The element whose visual children will be returned.</param>
        /// <returns>A collection of visualchildren.</returns>
        private IEnumerable<DependencyObject> GetVisualChildren(DependencyObject parent)
        {
            Debug.Assert(parent != null, "The parent cannot be null.");

            int childCount = VisualTreeHelper.GetChildrenCount(parent);
            for (int counter = 0; counter < childCount; counter++)
            {
                yield return VisualTreeHelper.GetChild(parent, counter);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\ChildWindow\ChildWindowStyleSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.ComponentModel;
using System.Linq;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample page demonstrating styling of the ChildWindow.
    /// </summary>
    [Sample("Styling", DifficultyLevel.Intermediate)]
    [Category("ChildWindow")]
    public partial class ChildWindowStyleSample : UserControl
    {
        /// <summary>
        /// Keeps an instance of a ChildWindow that will be shown when a button is clicked.
        /// </summary>
        private StyledChildWindow scw;

        /// <summary>
        /// Initializes a new instance of the ChildWindowStyleSample class.
        /// </summary>
        public ChildWindowStyleSample()
        {
            InitializeComponent();
            scw = new StyledChildWindow();
            scw.Closed += new EventHandler(Scw_Closed);
            thumbs.ItemsSource = from p in Photograph.GetPhotographs()
                                 orderby p.Name
                                 select p;
            thumbs.SelectedIndex = 0;
        }

        /// <summary>
        /// Handles the "Closed" event of the ChildWindow.
        /// </summary>
        /// <param name="sender">Child Window.</param>
        /// <param name="e">Event Arguments.</param>
        private void Scw_Closed(object sender, EventArgs e)
        {
            dialogResult.Text = scw.DialogResult.ToString();
        }

        /// <summary>
        /// Handles clicking the "Show" button.
        /// </summary>
        /// <param name="sender">Clicked Button.</param>
        /// <param name="e">Event Arguments.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Used by event defined in Xaml.")]
        private void Button_Click(object sender, RoutedEventArgs e)
        {
            scw.Title = titleText.Text;
            scw.DataContext = (from p in Photograph.GetPhotographs()
                               where p.Name.Equals((thumbs.SelectedItem as Photograph).Name)
                               select p).First().Image;
            scw.Show();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\ChildWindow\ChildWindowSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.ComponentModel;
using System.Linq;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample page demonstrating the ChildWindow.
    /// </summary>
    [Sample("ChildWindow", DifficultyLevel.Basic)]
    [Category("ChildWindow")]
    public partial class ChildWindowSample : UserControl
    {
        /// <summary>
        /// Keeps an instance of a ChildWindow that will be shown when a button is clicked.
        /// </summary>
        private DemoChildWindow dcw;

        /// <summary>
        /// Initializes a new instance of the ChildWindowSample class.
        /// </summary>
        public ChildWindowSample()
        {
            InitializeComponent();
            dcw = new DemoChildWindow();
            dcw.Closed += new EventHandler(Dcw_Closed);
            thumbs.ItemsSource = from p in Photograph.GetPhotographs()
                                 orderby p.Name
                                 select p;
            thumbs.SelectedIndex = 0;
        }

        /// <summary>
        /// Handles the "Closed" event of the ChildWindow.
        /// </summary>
        /// <param name="sender">Child Window.</param>
        /// <param name="e">Event Arguments.</param>
        private void Dcw_Closed(object sender, EventArgs e)
        {
            dialogResult.Text = dcw.DialogResult.ToString();
        }

        /// <summary>
        /// Handles clicking the "Show" button.
        /// </summary>
        /// <param name="sender">Clicked Button.</param>
        /// <param name="e">Event Arguments.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Used by event defined in Xaml.")]
        private void Button_Click(object sender, RoutedEventArgs e)
        {
            dcw.Title = titleText.Text;
            dcw.DataContext = (from p in Photograph.GetPhotographs()
                               where p.Name.Equals((thumbs.SelectedItem as Photograph).Name)
                               select p).First().Image;
            dcw.Show();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\ChildWindow\DemoChildWindow.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample ChildWindow for demonstration purposes.
    /// </summary>
    public partial class DemoChildWindow : ChildWindow
    {
        /// <summary>
        /// Initializes a DemoChildWindow.
        /// </summary>
        public DemoChildWindow()
        {
            InitializeComponent();
            optionsStack.DataContext = this;
        }

        /// <summary>
        /// Handles the Click event of the OK button.
        /// </summary>
        /// <param name="sender">OK Button.</param>
        /// <param name="e">Event arguments.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Used by event defined in Xaml.")]
        private void OKButton_Click(object sender, RoutedEventArgs e)
        {
            this.DialogResult = true;
        }

        /// <summary>
        /// Handles the Click event of the Cancel button.
        /// </summary>
        /// <param name="sender">Cancel button.</param>
        /// <param name="e">Event arguments.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Used by event defined in Xaml.")]
        private void CancelButton_Click(object sender, RoutedEventArgs e)
        {
            this.DialogResult = false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\DataForm\DataFormFieldsSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample page demonstrating the DataForm with fields set explicitly.
    /// </summary>
    [Sample("Custom Field Selection", DifficultyLevel.Intermediate)]
    [Category("DataForm")]
    public partial class DataFormFieldsSample : UserControl
    {
        /// <summary>
        /// Initializes a DataFormFieldsSample.
        /// </summary>
        public DataFormFieldsSample()
        {
            InitializeComponent();
            DataContext = Contact.People;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\DataForm\DataFormHeterogeneousDataSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Windows.Data;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample page demonstrating the DataForm control with heterogeneous data.
    /// </summary>
    [Sample("DataForm with heterogeneous data", DifficultyLevel.Intermediate)]
    [Category("DataForm")]
    public partial class DataFormHeterogeneousDataSample : UserControl
    {
        /// <summary>
        /// Initializes a DataFormHeterogeneousDataSample.
        /// </summary>
        public DataFormHeterogeneousDataSample()
        {
            InitializeComponent();
            ObservableCollection<object> objects = new ObservableCollection<object>();
            foreach (object obj in Contact.People)
            {
                objects.Add(obj);
            }
            Random r = new Random();
            foreach (object obj in Airport.SampleAirports)
            {
                objects.Insert(r.Next(objects.Count), obj);
            }
            DataContext = new ReadOnlyObservableCollection<object>(objects);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\DataForm\ContactEditor.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// A UserControl for working with and editing contacts.
    /// </summary>
    public partial class ContactEditor : UserControl
    {
        /// <summary>
        /// Initializes a new ContactEditor.
        /// </summary>
        public ContactEditor()
        {
            InitializeComponent();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\ChildWindow\StyledChildWindow.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Styled ChildWindow for demonstration purposes.
    /// </summary>
    public partial class StyledChildWindow : ChildWindow
    {
        /// <summary>
        /// Initializes a StyledChildWindow.
        /// </summary>
        public StyledChildWindow()
        {
            InitializeComponent();
        }

        /// <summary>
        /// Handles the Click event of the OK button.
        /// </summary>
        /// <param name="sender">OK Button.</param>
        /// <param name="e">Event arguments.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Used by event defined in Xaml.")]
        private void OKButton_Click(object sender, RoutedEventArgs e)
        {
            this.DialogResult = true;
        }

        /// <summary>
        /// Handles the Click event of the Cancel button.
        /// </summary>
        /// <param name="sender">Cancel button.</param>
        /// <param name="e">Event arguments.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Used by event defined in Xaml.")]
        private void CancelButton_Click(object sender, RoutedEventArgs e)
        {
            this.DialogResult = false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\DataForm\DataFormSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample page demonstrating the DataForm.
    /// </summary>
    [Sample("(0)DataForm", DifficultyLevel.Basic)]
    [Category("DataForm")]
    public partial class DataFormSample : UserControl
    {
        /// <summary>
        /// Initializes the DataFormSample.
        /// </summary>
        public DataFormSample()
        {
            InitializeComponent();
            DataContext = Contact.People;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\DataGrid\DataGridMasterDetailSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.ComponentModel;
using System.Windows.Data;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample page that demonstrates using a DataGrid, DataForm, and DataPager
    /// to create a paged Master-Details view.
    /// </summary>
    [Sample("Master-Details with DataGrid and DataForm", DifficultyLevel.Scenario)]
    [Category("DataGrid")]
    public partial class DataGridMasterDetailSample : UserControl
    {
        /// <summary>
        /// Initializes a DataGridMasterDetailsSample.
        /// </summary>
        public DataGridMasterDetailSample()
        {
            InitializeComponent();
            PagedCollectionView pcv = new PagedCollectionView(Contact.People);
            DataContext = pcv;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\DataForm\DataFormTemplateSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample page demonstrating the DataForm with templates.
    /// </summary>
    [Sample("Template-driven DataForm", DifficultyLevel.Intermediate)]
    [Category("DataForm")]
    public partial class DataFormTemplateSample : UserControl
    {
        /// <summary>
        /// Initializes a DataFormTemplateSample.
        /// </summary>
        public DataFormTemplateSample()
        {
            InitializeComponent();
            DataContext = Contact.People;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\DataGrid\DataGridGroupingSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.ComponentModel;
using System.Windows.Data;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample page demonstrating the DataGrid with grouping enabled.
    /// </summary>
    [Sample("DataGrid with Grouping", DifficultyLevel.Intermediate)]
    [Category("DataGrid")]
    public partial class DataGridGroupingSample : UserControl
    {
        /// <summary>
        /// Initializes a DataGridGroupingSample.
        /// </summary>
        public DataGridGroupingSample()
        {
            InitializeComponent();
            PagedCollectionView pcv = new PagedCollectionView(Contact.People);
            pcv.GroupDescriptions.Add(new PropertyGroupDescription("State"));
            pcv.GroupDescriptions.Add(new PropertyGroupDescription("City"));
            DataContext = pcv;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\DataPager\DataPagerSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.ComponentModel;
using System.Linq;
using System.Windows.Data;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample page demonstrating the DataPager.
    /// </summary>
    [Sample("DataPager", DifficultyLevel.Basic)]
    [Category("DataPager")]
    public partial class DataPagerSample : UserControl
    {
        /// <summary>
        /// Initializes a DataPagerSample.
        /// </summary>
        public DataPagerSample()
        {
            InitializeComponent();
            PagedCollectionView pcv = new PagedCollectionView(Airport.SampleAirports.ToArray());
            pcv.PageSize = 6;
            DataContext = pcv;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\DataGrid\DataGridSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample page demonstrating the DataGrid.
    /// </summary>
    [Sample("(0)DataGrid", DifficultyLevel.Basic)]
    [Category("DataGrid")]
    public partial class DataGridSample : UserControl
    {
        /// <summary>
        /// Initializes a DataGridSample.
        /// </summary>
        public DataGridSample()
        {
            InitializeComponent();
            DataContext = new CustomerCollection();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\DatePicker\DatePickerSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.Windows;
using System.Windows.Controls;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample page demonstrating the DatePicker.
    /// </summary>
    [Sample("DatePicker", DifficultyLevel.Basic)]
    [Category("DatePicker")]
    public partial class DatePickerSample : UserControl
    {
        /// <summary>
        /// Flag indicating whether to ignore the next DatePicker update.
        /// </summary>
        private bool _ignoreNextUpdate = true;

        /// <summary>
        /// Initializes a new instance of the DatePickerSample class.
        /// </summary>
        public DatePickerSample()
        {
            InitializeComponent();
        }

        /// <summary>
        /// Inherited code: Requires comment.
        /// </summary>
        /// <param name="sender">Inherited code: Requires comment 1.</param>
        /// <param name="e">Inherited code: Requires comment 2.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Event handler attached in XAML.")]
        [SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Justification = "Simplifies sample.")]
        private void OnPastDatesChanged(object sender, RoutedEventArgs e)
        {
            if (sampleDatePicker != null && sampleLongDatePicker != null)
            {
                if (chkPastDateSelection.IsChecked == true)
                {
                    sampleDatePicker.BlackoutDates.Clear();
                    sampleLongDatePicker.BlackoutDates.Clear();
                }
                else
                {
                    try
                    {
                        sampleDatePicker.BlackoutDates.AddDatesInPast();
                        sampleLongDatePicker.BlackoutDates.AddDatesInPast();
                    }
                    catch
                    {
                        chkPastDateSelection.IsChecked = true;
                    }
                }
            }
        }

        /// <summary>
        /// Handle changes to the selected date.
        /// </summary>
        /// <param name="sender">The DatePicker.</param>
        /// <param name="e">Event arguments.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Event handler attached in XAML.")]
        private void OnDateSelected(object sender, SelectionChangedEventArgs e)
        {
            UpdateSelectedDate(sampleDatePicker, sampleLongDatePicker);
        }

        /// <summary>
        /// Handle changes to the selected date.
        /// </summary>
        /// <param name="sender">The long DatePicker.</param>
        /// <param name="e">Event arguments.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Event handler attached in XAML.")]
        private void OnLongDateSelected(object sender, SelectionChangedEventArgs e)
        {
            UpdateSelectedDate(sampleLongDatePicker, sampleDatePicker);
        }

        /// <summary>
        /// Update the selected date.
        /// </summary>
        /// <param name="current">The current DatePicker.</param>
        /// <param name="other">The other DatePicker.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Called via event hanlders attached in XAML.")]
        private void UpdateSelectedDate(DatePicker current, DatePicker other)
        {
            if (_ignoreNextUpdate)
            {
                _ignoreNextUpdate = false;
                other.SelectedDate = current.SelectedDate;

                if (current.SelectedDate != null)
                {
                    txtSelectedDate.Text = current.SelectedDate.ToString();
                }
                else
                {
                    txtSelectedDate.Text = "";
                }
            }
            else
            {
                _ignoreNextUpdate = true;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\DomainUpDown\DomainUpDownAnimationsSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Windows;
using System.Windows.Controls;
using System.ComponentModel;

using System.Diagnostics.CodeAnalysis;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample page demonstrating DomainUpDown.
    /// </summary>
    [Sample("Animations", DifficultyLevel.Advanced)]
    [Category("DomainUpDown")]
    public partial class DomainUpDownAnimationsSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the DomainUpDownSlider class.
        /// </summary>
        public DomainUpDownAnimationsSample()
        {
            InitializeComponent();
            DudSlide.ItemsSource = Tutorial.Tutorials;
            DudSlideReflection.ItemsSource = Tutorial.Tutorials;
            DudSlide.Incremented += DudSlide_Incremented;
            DudSlide.Decremented += DudSlide_Decremented;
        }

        /// <summary>
        /// Responds to TransitioningDomainUpDown Incrementation.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">The <see cref="System.Windows.EventArgs"/> 
        /// instance containing the event data.</param>
        private void DudSlide_Decremented(object sender, EventArgs e)
        {
            DudSlideReflection.Decrement();
        }

        /// <summary>
        /// Responds to TransitioningDomainUpDown Decrementation.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">The <see cref="System.Windows.EventArgs"/> 
        /// instance containing the event data.</param>
        private void DudSlide_Incremented(object sender, EventArgs e)
        {
            DudSlideReflection.Increment();
        }

         /// <summary>
        /// Responds to Animation Setting Changes.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">The <see cref="System.Windows.RoutedPropertyChangedEventArgs"/> 
        /// instance containing the event data.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Used by event defined in Xaml.")]
        private void AnimationSettingsChanged(object sender, RoutedEventArgs e)
        {
            if (Rotation3D.IsChecked == true)
            {
                Style TransitionRotation3D = this.Resources["TransitioningContentRotation3D"] as Style;
                if (TransitionRotation3D != null)
                {
                    DudSlide.TransitioningContentControlStyle = TransitionRotation3D;
                    DudSlideReflection.TransitioningContentControlStyle = TransitionRotation3D;
                    DudSlide.Increment();
                    DudSlideReflection.Increment();
                }
            }
            else if (FadeInOut.IsChecked == true)
            {
                Style TransitioningContentFadeInOut = this.Resources["TransitioningContentFadeInOut"] as Style;

                if (TransitioningContentFadeInOut != null)
                {
                    DudSlide.TransitioningContentControlStyle = TransitioningContentFadeInOut;
                    DudSlideReflection.TransitioningContentControlStyle = TransitioningContentFadeInOut;
                    DudSlide.Increment();
                    DudSlideReflection.Increment();
                }
            }
            else
            {
                Style TransitioningContentTranslation = this.Resources["TransitioningContentTranslation"] as Style;
                if (TransitioningContentTranslation != null)
                {
                    DudSlide.TransitioningContentControlStyle = TransitioningContentTranslation;
                    DudSlideReflection.TransitioningContentControlStyle = TransitioningContentTranslation;
                    DudSlide.Increment();
                    DudSlideReflection.Increment();
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\DockPanel\DockPanelSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Windows;
using System.Windows.Controls;
using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample page demonstrating the DockPanel.
    /// </summary>
    [Sample("DockPanel", DifficultyLevel.Basic)]
    [Category("DockPanel")]
    public partial class DockPanelSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the DockPanelSample class.
        /// </summary>
        public DockPanelSample()
        {
            InitializeComponent();

            // Update the toolbar demo when a button is toggled
            btnBold.Checked += (s, e) => UpdateToolbarDemo();
            btnBold.Unchecked += (s, e) => UpdateToolbarDemo();
            btnItalic.Checked += (s, e) => UpdateToolbarDemo();
            btnItalic.Unchecked += (s, e) => UpdateToolbarDemo();
            btnUnderline.Checked += (s, e) => UpdateToolbarDemo();
            btnUnderline.Unchecked += (s, e) => UpdateToolbarDemo();
        }

        /// <summary>
        /// Update the toolbar demo when a font property changes.
        /// </summary>
        private void UpdateToolbarDemo()
        {
            UsageText.FontWeight = (btnBold.IsChecked == true) ?
                FontWeights.Bold :
                FontWeights.Normal;
            UsageText.FontStyle = (btnItalic.IsChecked == true) ?
                FontStyles.Italic :
                FontStyles.Normal;
            UsageText.TextDecorations = (btnUnderline.IsChecked == true) ?
                TextDecorations.Underline :
                null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\DomainUpDown\BorderToStringConverter.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Globalization;
using System.Linq;
using System.Windows.Controls;
using System.Windows.Media;
using System.Windows.Data;
using System.Reflection;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Converts a border to a friendly name (the color of its background).
    /// </summary>
    /// <remarks>Used in DomainUpDownSample.</remarks>
    public class BorderToStringConverter : IValueConverter
    {
        /// <summary>
        /// Modifies the source data before passing it to the target for display in the UI.
        /// </summary>
        /// <param name="value">The source data being passed to the target.</param>
        /// <param name="targetType">The <see cref="T:System.Type"/> of data expected by the target dependency property.</param>
        /// <param name="parameter">An optional parameter to be used in the converter logic.</param>
        /// <param name="culture">The culture of the conversion.</param>
        /// <returns>
        /// The value to be passed to the target dependency property.
        /// </returns>
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            // expecting a border
            Border element = value as Border;
            if (element != null)
            {
                SolidColorBrush b = element.Background as SolidColorBrush;

                if (b != null)
                {
                    // use the colors class to find a friendly name for this color.
                    string colorname = (from c in typeof(Colors).GetProperties(BindingFlags.Public | BindingFlags.Static)
                                        where c.GetValue(null, new object[] { }).Equals(b.Color)
                                        select c.Name).FirstOrDefault();

                    // no friendly name found, use the rgb code.
                    if (String.IsNullOrEmpty(colorname))
                    {
                        colorname = b.Color.ToString();
                    }
                    return colorname;
                }
            }
            return String.Empty;
        }

        /// <summary>
        /// Modifies the target data before passing it to the source object.  This method is called only in <see cref="F:System.Windows.Data.BindingMode.TwoWay"/> bindings.
        /// </summary>
        /// <param name="value">The target data being passed to the source.</param>
        /// <param name="targetType">The <see cref="T:System.Type"/> of data expected by the source object.</param>
        /// <param name="parameter">An optional parameter to be used in the converter logic.</param>
        /// <param name="culture">The culture of the conversion.</param>
        /// <returns>
        /// The value to be passed to the source object.
        /// </returns>
        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new System.NotImplementedException();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\DomainUpDown\DomainUpDownSpinnerSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample with DomainUpDown, showcasing different ButtonSpinnerStyles.
    /// </summary>
    [Sample("(1)DomainUpDown with ButtonStyles", DifficultyLevel.Basic)]
    [Category("DomainUpDown")]
    public partial class DomainUpDownSpinnerSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DomainUpDownSpinnerSample"/> class.
        /// </summary>
        public DomainUpDownSpinnerSample()
        {
            InitializeComponent();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\DomainUpDown\Month.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Class representing a month, used in the DomainUpDown sample.
    /// </summary>
    public class Month
    {
        /// <summary>
        /// Gets or sets the friendly name representation of this month.
        /// </summary>
        /// <value>The name of the friendly.</value>
        public string FriendlyName { get; set; }

        /// <summary>
        /// Gets or sets the month number.
        /// </summary>
        /// <value>The number.</value>
        public int Number { get; set; }

        /// <summary>
        /// Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
        /// </summary>
        /// <returns>
        /// A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
        /// </returns>
        public override string ToString()
        {
            return FriendlyName;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\DomainUpDown\DomainUpDownSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Linq;
using System.Windows.Media;
using System.Collections;
using System.Reflection;
using System.ComponentModel;
using System.Windows.Data;
using System.Collections.Generic;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample page demonstrating DomainUpDown.
    /// </summary>
    [Sample("(0)DomainUpDown", DifficultyLevel.Basic)]
    [Category("DomainUpDown")]
    public partial class DomainUpDownSample : UserControl
    {
        #region Cultures
        /// <summary>
        /// Cultures that are recognized on most configurations.
        /// </summary>
        private readonly string[] _cultureNames = new[]
                                             {
                                                     "af", "af-ZA", "ar", "ar-AE", "ar-BH", "ar-DZ", "ar-EG", "ar-IQ", "ar-JO", "ar-KW", "ar-LB", "ar-LY",
                                                     "ar-MA", "ar-OM", "ar-QA", "ar-SA", "ar-SY", "ar-TN", "ar-YE", "az", "az-Cyrl-AZ", "az-Latn-AZ", "be",
                                                     "be-BY", "bg", "bg-BG", "ca", "ca-ES", "cs", "cs-CZ", "da", "da-DK", "de", "de-AT", "de-CH", "de-DE",
                                                     "de-LI", "de-LU", "dv", "dv-MV", "el", "el-GR", "en", "en-029", "en-AU", "en-BZ", "en-CA", "en-GB", "en-IE", 
                                                     "en-JM", "en-NZ", "en-PH", "en-TT", "en-US", "en-ZA", "en-ZW", "es", "es-AR", "es-BO", "es-CL", "es-CO",
                                                     "es-CR", "es-DO", "es-EC", "es-ES", "es-GT", "es-HN", "es-MX", "es-NI", "es-PA", "es-PE", "es-PR", "es-PY",
                                                     "es-SV", "es-UY", "es-VE", "et", "et-EE", "eu", "eu-ES", "fa", "fa-IR", "fi", "fi-FI", "fo", "fo-FO", "fr",
                                                     "fr-BE", "fr-CA", "fr-CH", "fr-FR", "fr-LU", "fr-MC", "gl", "gl-ES", "gu", "gu-IN", "he", "he-IL", "hi",
                                                     "hi-IN", "hr", "hr-HR", "hu", "hu-HU", "hy", "hy-AM", "id", "id-ID", "is", "is-IS", "it", "it-CH", "it-IT",
                                                     "ja", "ja-JP", "ka", "ka-GE", "kk", "kk-KZ", "kn", "kn-IN", "ko", "kok", "kok-IN", "ko-KR", "ky", "ky-KG",
                                                     "lt", "lt-LT", "lv", "lv-LV", "mk", "mk-MK", "mn", "mn-MN", "mr", "mr-IN", "ms", "ms-BN", "ms-MY", "nb-NO",
                                                     "nl", "nl-BE", "nl-NL", "nn-NO", "no", "pa", "pa-IN", "pl", "pl-PL", "pt", "pt-BR", "pt-PT", "ro", "ro-RO",
                                                     "ru", "ru-RU", "sa", "sa-IN", "sk", "sk-SK", "sl", "sl-SI", "sq", "sq-AL", "sr", "sr-Cyrl-CS", "sr-Latn-CS", 
                                                     "sv", "sv-FI", "sv-SE", "sw", "sw-KE", "syr", "syr-SY", "ta", "ta-IN", "te", "te-IN", "th", "th-TH", "tr", 
                                                     "tr-TR", "tt", "tt-RU", "uk", "uk-UA", "ur", "ur-PK", "uz", "uz-Cyrl-UZ", "uz-Latn-UZ", "vi", "vi-VN",
                                                     "zh-CHS", "zh-CHT", "zh-CN", "zh-HK", "zh-MO", "zh-SG", "zh-TW"
                                             };
        #endregion

        /// <summary>
        /// Initializes a new instance of the <see cref="DomainUpDownSample"/> class.
        /// </summary>
        public DomainUpDownSample()
        {
            InitializeComponent();

            Loaded += DomainUpDownSample_Loaded;
        }

        /// <summary>
        /// Handles the Loaded event of the DomainUpDownSample control.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">The <see cref="System.Windows.RoutedEventArgs"/> instance containing the event data.</param>
        private void DomainUpDownSample_Loaded(object sender, RoutedEventArgs e)
        {
            IEnumerable airports = Airport.SampleAirports;
            DataContext = airports;

            List<CultureInfo> cultures = new List<CultureInfo>();

            // work through long list of cultures and check if it is actually 
            // allowed in this configuration.
            foreach (string cultureName in _cultureNames)
            {
                try
                {
                    CultureInfo c = new CultureInfo(cultureName);
                    cultures.Add(c);
                }
                catch (ArgumentException)
                {
                }
            }

            cultureList.ItemsSource = cultures;
            // preselect dutch, if allowed.
            cultureList.SelectedItem = cultures.FirstOrDefault(info => info.Name == "nl-NL");
        }

        /// <summary>
        /// Handles the ParseError event of the DomainUpDown control.
        /// If a color can be found to, a new border will be added to our items collection.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">The <see cref="System.Windows.Controls.Branched.UpDownParseErrorEventArgs"/> instance containing the event data.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Used by event defined in Xaml.")]
        private void DomainUpDown_ParseError(object sender, UpDownParseErrorEventArgs e)
        {
            DomainUpDown dud = (DomainUpDown)sender;

            // get the text that was unable to parse.
            string text = e.Text;

            SolidColorBrush backgroundColor = null;

            // is might be a known color string, like "Yellow" 
            // get by looking at the Colors class.
            PropertyInfo colorPropertyInfo = typeof(Colors).GetProperty(text, BindingFlags.Static | BindingFlags.Public);
            if (colorPropertyInfo != null)
            {
                backgroundColor = new SolidColorBrush((Color)colorPropertyInfo.GetValue(null, new object[] { }));
            }
            else
            {
                // it might be rgba code, like #aarrggbb
                if (text.StartsWith("#", StringComparison.OrdinalIgnoreCase) && text.Length == 9)
                {
                    // rrggbbaa
                    text = text.Substring(1);

                    // test to see if it can be parsed to an int
                    int result;
                    if (Int32.TryParse(text, out result))
                    {
                        byte[] rgba = new byte[4];
                        for (int i = 0; i < 4; i++)
                        {
                            rgba[i] = Byte.Parse(text.Substring(i * 2, 2), CultureInfo.CurrentCulture);
                        }
                        backgroundColor = new SolidColorBrush(new Color { A = rgba[0], B = rgba[3], G = rgba[2], R = rgba[1] });
                    }
                }
            }

            if (backgroundColor != null)
            {
                dud.Items.Add(new Border
                {
                    Width = 120,
                    Height = 80,
                    Background = backgroundColor,
                    BorderBrush = new SolidColorBrush(Colors.Yellow),
                    BorderThickness = new Thickness(4)
                });
                dud.CurrentIndex = dud.Items.Count - 1;
            }
        }

        /// <summary>
        /// Handles the SelectionChanged event of the CultureList control.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">The <see cref="System.Windows.Controls.SelectionChangedEventArgs"/> instance containing the event data.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Used by event defined in Xaml.")]
        private void CultureList_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            CultureInfo c = cultureList.SelectedItem as CultureInfo;
            if (c != null)
            {
                Binding copy = new Binding(cultureDependentDUD.ValueMemberPath)
                {
                    Converter = cultureDependentDUD.ValueMemberBinding.Converter,
                    ConverterCulture = c
                };
                cultureDependentDUD.ValueMemberBinding = copy;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\DomainUpDown\MonthToStringConverter.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Windows.Data;
using System.Globalization;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Converts the custom Month class to a string.
    /// </summary>
    public class MonthToStringConverter : IValueConverter
    {
        /// <summary>
        /// Modifies the source data before passing it to the target for display in the UI.
        /// </summary>
        /// <param name="value">The source data being passed to the target.</param>
        /// <param name="targetType">The <see cref="T:System.Type"/> of data expected by the target dependency property.</param>
        /// <param name="parameter">An optional parameter to be used in the converter logic.</param>
        /// <param name="culture">The culture of the conversion.</param>
        /// <returns>
        /// The value to be passed to the target dependency property.
        /// </returns>
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            Month month = value as Month;
            if (month != null)
            {
                if (culture == null)
                {
                    culture = CultureInfo.CurrentCulture;
                }
                return new DateTime(1900, month.Number, 1).ToString("MMMM", culture.DateTimeFormat);
            }
            
            throw new ArgumentException("Expected a Month object.", "value");
        }

        /// <summary>
        /// Modifies the target data before passing it to the source object.  This method is called only in <see cref="F:System.Windows.Data.BindingMode.TwoWay"/> bindings.
        /// </summary>
        /// <param name="value">The target data being passed to the source.</param>
        /// <param name="targetType">The <see cref="T:System.Type"/> of data expected by the source object.</param>
        /// <param name="parameter">An optional parameter to be used in the converter logic.</param>
        /// <param name="culture">The culture of the conversion.</param>
        /// <returns>
        /// The value to be passed to the source object.
        /// </returns>
        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\GlobalCalendar\CalendarDayButtonStyleSelectorSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample page demonstrating the CalendarDayButtonStyleSelector.
    /// </summary>
    [Sample("(2)CalendarDayButtonStyleSelector", DifficultyLevel.Basic)]
    [Category("GlobalCalendar")]
    public partial class CalendarDayButtonStyleSelectorSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the
        /// CalendarDayButtonStyleSelectorSample class.
        /// </summary>
        public CalendarDayButtonStyleSelectorSample()
        {
            InitializeComponent();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\Expander\HeaderedContentControl\HeaderedContentControlSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Diagnostics.CodeAnalysis;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Markup;
using System.Windows.Media;
using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample page demonstrating the HeaderedContentControl.
    /// </summary>
    [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Headered", Justification = "Name of the control")]
    [Sample("HeaderedContentControl", DifficultyLevel.Basic)]
    [Category("Expander")]
    public partial class HeaderedContentControlSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the HeaderedContentControlSample class.
        /// </summary>
        public HeaderedContentControlSample()
        {
            InitializeComponent();

            Loaded += OnLoaded;
        }

        /// <summary>
        /// Load the demonstration.
        /// </summary>
        /// <param name="sender">Sample page.</param>
        /// <param name="e">Event arguments.</param>
        private void OnLoaded(object sender, RoutedEventArgs e)
        {
            btnChange.Click += ChangeSettings;
        }

        /// <summary>
        /// Change ContentControl settings (Header, HeaderTemplate, Content, ContentTemplate).
        /// </summary>
        /// <param name="sender">Sender Button.</param>
        /// <param name="e">Event args.</param>
        private void ChangeSettings(object sender, RoutedEventArgs e)
        {
            HCC.Header = tbHeader.Text;
            HCC.Content = tbContent.Text;

            if (String.IsNullOrEmpty(tbHeaderTemplate.Text))
            {
                HCC.ClearValue(HeaderedContentControl.HeaderTemplateProperty);
            }
            else
            {
                try
                {
                    HCC.HeaderTemplate = (DataTemplate)XamlReader.Load(AddXmlNS(tbHeaderTemplate.Text));
                    tbHeaderTemplate.Foreground = new SolidColorBrush(Colors.Black);
                }
                catch (XamlParseException)
                {
                    tbHeaderTemplate.Foreground = new SolidColorBrush(Colors.Red);
                }
            }

            if (string.IsNullOrEmpty(tbContentTemplate.Text))
            {
                HCC.ClearValue(HeaderedContentControl.ContentTemplateProperty);
            }
            else
            {
                try
                {
                    HCC.ContentTemplate = (DataTemplate)XamlReader.Load(AddXmlNS(tbContentTemplate.Text));
                    tbContentTemplate.Foreground = new SolidColorBrush(Colors.Black);
                }
                catch (XamlParseException)
                {
                    tbContentTemplate.Foreground = new SolidColorBrush(Colors.Red);
                }
            }
        }

        /// <summary>
        /// Utility function to add xmlns to user inputed template string.
        /// </summary>
        /// <param name="s">User input template string.</param>
        /// <returns>Well formated xaml with xmlns added.</returns>
        private static string AddXmlNS(string s)
        {
            string xmlns = @" xmlns=""http://schemas.microsoft.com/client/2007""
                              xmlns:x=""http://schemas.microsoft.com/winfx/2006/xaml""
                              xmlns:controls=""clr-namespace:System.Windows.Controls;assembly=System.Windows.Controls"" ";
            int i = s.IndexOf(">", StringComparison.Ordinal);
            return (i == -1) ? ">/" : s.Substring(0, i) + xmlns + s.Substring(i);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\DomainUpDown\Tutorial.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.Collections.ObjectModel;
namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Class representing a Tutorial. 
    /// </summary>
    public class Tutorial
    {
        /// <summary>
        /// Gets or sets the friendly name representation of this tutorial.
        /// </summary>
        /// <value>The name of the friendly.</value>
        public string TutorialName { get; set; }

        /// <summary>
        /// Gets or sets the description for the tutorial.
        /// </summary>
        public string Description { get; set; }

        /// <summary>
        /// Gets or sets the link to the tutorial on Silverlight.net.
        /// </summary>
        /// <value>The number.</value>
        public string TutorialLink { get; set; }

        /// <summary>
        /// Initializes a new Tutorial class instance. This is a data-entry 
        /// friendly constructor.
        /// </summary>
        /// <param name="tutorialName">Name of the tutorial.</param>
        /// <param name="description">Description of the tutorial.</param>
        /// <param name="tutorialLink">Link to the Tutorial.</param>
        public Tutorial(string tutorialName, string description, string tutorialLink)
        {
            TutorialName = tutorialName;
            Description = description;
            TutorialLink = tutorialLink;
        }

        /// <summary>
        /// Represent the Tutorial Name.
        /// </summary>
        /// <returns>
        /// A <see cref="T:System.String"/> that represents the tutorial name.
        /// </returns>
        public override string ToString()
        {
            return TutorialName;
        }

        /// <summary>
        /// Gets a collection of Tutorials.
        /// </summary>
        public static Collection<Tutorial> Tutorials
        {
            get
            {
                return new Collection<Tutorial> 
                {
                    new Tutorial("Introduction", "Jesse Liberty shows how to install the Silverlight Toolkit and where to find resources on how to use it. ", "http://silverlight.net/learn/learnvideo.aspx?video=146244"),
                    new Tutorial("AutoComplete", "Jesse Liberty introduces the AutoCompleteBox from the Silverlight Toolkit and the infrastructure that he’ll be using in his entire video series on the Silverlight Toolkit. ", "http://silverlight.net/learn/learnvideo.aspx?video=146251"),
                    new Tutorial("Pie Chart", "In this video, Jesse Liberty demonstrates how to build a pie chart from the Silverlight Toolkit with a collection of business objects.", "http://silverlight.net/learn/learnvideo.aspx?video=156998"),
                    new Tutorial("Headers", "In this video Jesse Liberty demonstrates how to create and use the HeaderContentControl and the HeaderItemsControl from the Silverlight Toolkit, demonstrating their use with text and with images.", "http://silverlight.net/learn/learnvideo.aspx?video=164686"),
                    new Tutorial("WrapPanel", "In this video, Jesse Liberty demonstrates how to use the Wrapper Panel from the Silverlight Toolkit to add controls and have them automatically placed one beside another until there is not enough room, at which time the next control will be placed on the next row", "http://silverlight.net/learn/learnvideo.aspx?video=180072"),
                    new Tutorial("Expander", "In this video Jesse Liberty demonstrates how to create and use the Expander control and then how to template the control to cause its contents to fade in and out at a pace you set. ", "http://silverlight.net/learn/learnvideo.aspx?video=183406")
                };
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\Expander\ExpanderSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Markup;
using System.Windows.Media;
using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample page demonstrating the Expander.
    /// </summary>
    [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Expander", Justification = "Name of the control")]
    [Sample("Expander", DifficultyLevel.Basic)]
    [Category("Expander")]
    public partial class ExpanderSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the ExpanderSample class.
        /// </summary>
        public ExpanderSample()
        {
            InitializeComponent();
            Loaded += OnLoaded;
        }

        /// <summary>
        /// Load the demo page.
        /// </summary>
        /// <param name="sender">Sample page.</param>
        /// <param name="e">Event arguments.</param>
        private void OnLoaded(object sender, RoutedEventArgs e)
        {
            // initalize customization area
            lbCustDirection.SelectionChanged += (x, y) =>
                {
                    ExpandDirection d = (ExpandDirection)lbCustDirection.SelectedIndex;
                    expNoButton.ExpandDirection = d;
                    expBRButton.ExpandDirection = d;
                    expFade.ExpandDirection = d;
                    expScale.ExpandDirection = d;
                };

            // initialize interactive usage area
            btnChange.Click += ChangeSettings;

            tbHeader.Text = "Header";
            tbHeaderTemplate.Text = @"<DataTemplate><StackPanel Orientation=""Horizontal""><Ellipse Width=""10"" Height=""10"" Fill=""Red""/><Button Content=""{Binding}""/><Ellipse Width=""10"" Height=""10"" Fill=""Red""/></StackPanel></DataTemplate>";
            tbContent.Text = "Content";
            tbContentTemplate.Text = @"<DataTemplate><Button Content=""{Binding}""/></DataTemplate>";

            expander.Expanded += (x, y) => OutputExpander();
            expander.Collapsed += (x, y) => OutputExpander();
        }

        /// <summary>
        /// Change ContentControl settings (Header, HeaderTemplate, Content, ContentTemplate).
        /// </summary>
        /// <param name="sender">Sender Button.</param>
        /// <param name="e">Event args.</param>
        private void ChangeSettings(object sender, RoutedEventArgs e)
        {
            expander.ExpandDirection = (ExpandDirection) lbExpandDirection.SelectedIndex;
            expander.Header = tbHeader.Text;
            expander.Content = tbContent.Text;
            expander.IsEnabled = cbIsEnabled.IsChecked ?? true;

            if (String.IsNullOrEmpty(tbHeaderTemplate.Text))
            {
                expander.ClearValue(HeaderedContentControl.HeaderTemplateProperty);
            }
            else
            {
                try
                {
                    expander.HeaderTemplate = (DataTemplate) XamlReader.Load(AddXmlNS(tbHeaderTemplate.Text));
                    tbHeaderTemplate.Foreground = new SolidColorBrush(Colors.Black);
                }
                catch (XamlParseException)
                {
                    tbHeaderTemplate.Foreground = new SolidColorBrush(Colors.Red);
                }
            }

            if (string.IsNullOrEmpty(tbContentTemplate.Text))
            {
                expander.ClearValue(HeaderedContentControl.ContentTemplateProperty);
            }
            else
            {
                try
                {
                    expander.ContentTemplate = (DataTemplate) XamlReader.Load(AddXmlNS(tbContentTemplate.Text));
                    tbContentTemplate.Foreground = new SolidColorBrush(Colors.Black);
                }
                catch (XamlParseException)
                {
                    tbContentTemplate.Foreground = new SolidColorBrush(Colors.Red);
                }
            }

            OutputExpander();
        }

        /// <summary>
        /// Utility function to add xmlns to user inputed template string.
        /// </summary>
        /// <param name="s">User input template string.</param>
        /// <returns>Well formated xaml with xmlns added.</returns>
        private static string AddXmlNS(string s)
        {
            string xmlns = @" xmlns=""http://schemas.microsoft.com/client/2007""
                              xmlns:x=""http://schemas.microsoft.com/winfx/2006/xaml""
                              xmlns:controls=""clr-namespace:System.Windows.Controls;assembly=System.Windows.Controls.InternalOnly"" ";
            int i = s.IndexOf(">", StringComparison.Ordinal);
            return (i == -1) ? ">/" : s.Substring(0, i) + xmlns + s.Substring(i);
        }

        /// <summary>
        /// Display the interactive Expander control's properties.
        /// </summary>
        private void OutputExpander()
        {
            string formatString = "\n\n" +
                " ExpandDirection:\t{0}\n" +
                " Header:\t{1}\n" +
                " Content:\t{2}\n" +
                " IsExpanded:\t{3}\n" +
                " IsEnabled:\t{4}\n";

            output.Text = string.Format(
                CultureInfo.InvariantCulture,
                formatString,
                expander.ExpandDirection,
                expander.Header,
                expander.Content,
                expander.IsExpanded,
                expander.IsEnabled);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\GlobalCalendar\GlobalCalendarSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample page demonstrating the GlobalCalendar.
    /// </summary>
    [Sample("(1)GlobalCalendar", DifficultyLevel.Basic)]
    [Category("GlobalCalendar")]
    public partial class GlobalCalendarSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the GlobalCalendarSample class.
        /// </summary>
        public GlobalCalendarSample()
        {
            InitializeComponent();
            CultureOptions.SelectedIndex = 0;
        }

        /// <summary>
        /// Update the culture when the drop down changes.
        /// </summary>
        /// <param name="sender">The culture ComboBox.</param>
        /// <param name="e">Event arguments.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Attached in XAML.")]
        private void OnCultureChanged(object sender, SelectionChangedEventArgs e)
        {
            ComboBoxItem selected = CultureOptions.SelectedItem as ComboBoxItem;
            if (selected == null)
            {
                return;
            }

            CultureInfo culture = new CultureInfo(selected.Tag as string);
            CulturedCalendar.CalendarInfo = new CultureCalendarInfo(culture);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\GlobalCalendar\GlobalCalendarHolidaysSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample page demonstrating the CalendarDayButtonStyleSelector with
    /// holidays.
    /// </summary>
    [Sample("(3)Holidays", DifficultyLevel.Basic)]
    [Category("GlobalCalendar")]
    public partial class GlobalCalendarHolidaysSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the GlobalCalendarHolidaysSample
        /// class.
        /// </summary>
        public GlobalCalendarHolidaysSample()
        {
            InitializeComponent();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\GlobalCalendar\ExactHoliday.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Represents a holiday to be marked on the GlobalCalendar that occurs on
    /// the exact date every year.
    /// </summary>
    public partial class ExactHoliday : Holiday
    {
        /// <summary>
        /// Gets or sets the date of the holiday.
        /// </summary>
        [TypeConverter(typeof(DateTimeTypeConverter))]
        public DateTime Date { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether the holiday occurs annually
        /// on the same date.
        /// </summary>
        public bool IsAnnual { get; set; }

        /// <summary>
        /// Initializes a new instance of the ExactHoliday class.
        /// </summary>
        public ExactHoliday()
        {
            IsAnnual = true;
        }

        /// <summary>
        /// Determine if this holiday falls on a specific date.
        /// </summary>
        /// <param name="day">The date to check.</param>
        /// <returns>
        /// A value indicating whether this holiday falls on a specific date.
        /// </returns>
        public override bool FallsOn(DateTime day)
        {
            return IsAnnual ?
                (day.Day == Date.Day && day.Month == Date.Month) :
                day == Date;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\GlobalCalendar\RelativeHoliday.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Represents a holiday to be marked on the GlobalCalendar that occurs on
    /// the same day of the same week every year (i.e., Thanksgiving in the
    /// United States falls on the fourth Thursday in November).
    /// </summary>
    public partial class RelativeHoliday : Holiday
    {
        /// <summary>
        /// Gets or sets the month of the holiday.
        /// </summary>
        public int Month { get; set; }

        /// <summary>
        /// Gets or sets the day of the holiday.
        /// </summary>
        public DayOfWeek DayOfWeek { get; set; }

        /// <summary>
        /// Gets or sets a value that specifies the nth day of week in the
        /// month.  Negative values start from the end of the month (which is
        /// used to specify relative holidays like the last Monday in May).
        /// </summary>
        public int DayOfWeekNumber { get; set; }

        /// <summary>
        /// Initializes a new instance of the RelativeHoliday class.
        /// </summary>
        public RelativeHoliday()
        {
        }

        /// <summary>
        /// Determine if this holiday falls on a specific date.
        /// </summary>
        /// <param name="day">The date to check.</param>
        /// <returns>
        /// A value indicating whether this holiday falls on a specific date.
        /// </returns>
        public override bool FallsOn(DateTime day)
        {
            // Short circuit on the month or day
            if (day.Month != Month || day.DayOfWeek != DayOfWeek)
            {
                return false;
            }

            // Trim off anything but the date
            day = new DateTime(day.Year, day.Month, day.Day);

            // Loop through all of the dates in the month to count how many days
            // are occurences of DayOfWeek.
            int occurences = 0;
            int dateOccurenceNumber = 0;
            for (DateTime d = new DateTime(day.Year, day.Month, 1); d.Month == day.Month; d = d.AddDays(1))
            {
                if (d.DayOfWeek == DayOfWeek)
                {
                    occurences++;

                    if (d <= day)
                    {
                        dateOccurenceNumber++;
                    }
                }
            }

            return DayOfWeekNumber >= 0 ?
                (DayOfWeekNumber == dateOccurenceNumber) :
                (occurences + DayOfWeekNumber + 1 == dateOccurenceNumber);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\GlobalCalendar\Holiday.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Represents a holiday to be marked on the GlobalCalendar.
    /// </summary>
    public abstract partial class Holiday
    {
        /// <summary>
        /// Gets or sets the title of the holiday.
        /// </summary>
        public string Title { get; set; }

        /// <summary>
        /// Initializes a new instance of the Holiday class.
        /// </summary>
        protected Holiday()
        {
        }

        /// <summary>
        /// Determine if this holiday falls on a specific date.
        /// </summary>
        /// <param name="day">The date to check.</param>
        /// <returns>
        /// A value indicating whether this holiday falls on a specific date.
        /// </returns>
        public abstract bool FallsOn(DateTime day);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\GlobalCalendar\HolidayDayButtonStyleSelector.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Collections.ObjectModel;
using System.Linq;
using System.Windows.Controls.Primitives;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Provides a way to apply different styles for holidays and normal days.
    /// </summary>
    public class HolidayDayButtonStyleSelector : CalendarDayButtonStyleSelector
    {
        /// <summary>
        /// Gets or sets the style for normal days.
        /// </summary>
        public Style NormalStyle { get; set; }

        /// <summary>
        /// Gets or sets the style for holidays.
        /// </summary>
        public Style HolidayStyle { get; set; }

        /// <summary>
        /// Gets a collection of Holidays.
        /// </summary>
        public Collection<Holiday> Holidays { get; private set; }

        /// <summary>
        /// Initializes a new instance of the HolidayDayButtonStyleSelector
        /// class.
        /// </summary>
        public HolidayDayButtonStyleSelector()
        {
            Holidays = new Collection<Holiday>();
        }

        /// <summary>
        /// Returns a GlobalCalendarDayButton Style based on whether the day is
        /// a holiday.
        /// </summary>
        /// <param name="day">The day to select a Style for.</param>
        /// <param name="container">The GlobalCalendarDayButton.</param>
        /// <returns>A Style for the GlobalCalendarDayButton.</returns>
        public override Style SelectStyle(DateTime day, GlobalCalendarDayButton container)
        {
            Holiday holiday = Holidays.Where(h => h.FallsOn(day)).FirstOrDefault();

            // Use the Holiday.Title as the Tooltip
            string title = holiday != null ? holiday.Title : null;
            ToolTipService.SetToolTip(container, title);

            return (holiday != null) ?
                HolidayStyle :
                NormalStyle;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\GridSplitter\GridSplitterSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample page demonstrating the GridSplitter.
    /// </summary>
    [Sample("GridSplitter", DifficultyLevel.Basic)]
    [Category("GridSplitter")]
    public partial class GridSplitterSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the DatePickerSample class.
        /// </summary>
        public GridSplitterSample()
        {
            InitializeComponent();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\GlobalCalendar\WeekendDayButtonStyleSelector.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Windows.Controls.Primitives;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Provides a way to apply different styles for weekdays and weekends.
    /// </summary>
    public class WeekendDayButtonStyleSelector : CalendarDayButtonStyleSelector
    {
        /// <summary>
        /// Gets or sets the style for weekdays.
        /// </summary>
        public Style WeekdayStyle { get; set; }

        /// <summary>
        /// Gets or sets the style for weekend days.
        /// </summary>
        public Style WeekendStyle { get; set; }

        /// <summary>
        /// Initializes a new instance of the WeekendDayButtonStyleSelector
        /// class.
        /// </summary>
        public WeekendDayButtonStyleSelector()
        {
        }

        /// <summary>
        /// Returns a GlobalCalendarDayButton Style based on whether the day is
        /// a weekday or a weekend.
        /// </summary>
        /// <param name="day">The day to select a Style for.</param>
        /// <param name="container">The GlobalCalendarDayButton.</param>
        /// <returns>A Style for the GlobalCalendarDayButton.</returns>
        public override Style SelectStyle(DateTime day, GlobalCalendarDayButton container)
        {
            DayOfWeek d = day.DayOfWeek;
            return (d == DayOfWeek.Saturday || d == DayOfWeek.Sunday) ?
                WeekendStyle :
                WeekdayStyle;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\Navigation\NavigationSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample page demonstrating navigation using Pages and a Frame.
    /// </summary>
    [Sample("(0)Navigation", DifficultyLevel.Basic)]
    [Category("Navigation")]
    public partial class NavigationSample : UserControl
    {
        /// <summary>
        /// Initializes a NavigationSample.
        /// </summary>
        public NavigationSample()
        {
            InitializeComponent();
        }

        /// <summary>
        /// Causes navigation when a button is clicked.
        /// </summary>
        /// <param name="sender">The clicked button.</param>
        /// <param name="e">Event arguments.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Used by event defined in Xaml.")]
        private void Button_Click(object sender, RoutedEventArgs e)
        {
            navFrame.Navigate(new Uri(((Button)sender).Tag.ToString(), UriKind.Relative));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\Navigation\Page2.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.Windows.Navigation;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// A Page that displays a variety of controls to which a frame can navigate.
    /// </summary>
    public partial class Page2 : Page
    {
        /// <summary>
        /// Initializes a Page2.
        /// </summary>
        public Page2()
        {
            InitializeComponent();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\Navigation\MappingNavigationSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.ComponentModel;
using System.Globalization;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample page demonstrating navigation with mapped URIs.
    /// </summary>
    [Sample("(2)Mapping URIs", DifficultyLevel.Intermediate)]
    [Category("Navigation")]
    public partial class MappingNavigationSample : UserControl
    {
        /// <summary>
        /// Initializes a MappingNavigationSample.
        /// </summary>
        public MappingNavigationSample()
        {
            InitializeComponent();
        }

        /// <summary>
        /// Causes navigation when a button is clicked.
        /// </summary>
        /// <param name="sender">The clicked button.</param>
        /// <param name="e">Event arguments.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Used by event defined in Xaml.")]
        private void Button_Click(object sender, RoutedEventArgs e)
        {
            navFrame.Navigate(new Uri(string.Format(CultureInfo.CurrentCulture, "/Query/{0}/{1}/{2}", Uri.EscapeDataString(x.Text), Uri.EscapeDataString(y.Text), Uri.EscapeDataString(z.Text)), UriKind.Relative));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\Navigation\Page1.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.Linq;
using System.Windows.Navigation;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// A Page that displays an image to which a frame can navigate.
    /// </summary>
    public partial class Page1 : Page
    {
        /// <summary>
        /// Initializes a Page1.
        /// </summary>
        public Page1()
        {
            InitializeComponent();

            DataContext = Photograph.GetPhotographs().First().Image;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\Navigation\QueryNavigationSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.ComponentModel;
using System.Globalization;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample page demonstrating navigation with query strings.
    /// </summary>
    [Sample("(1)Using a Query String", DifficultyLevel.Intermediate)]
    [Category("Navigation")]
    public partial class QueryNavigationSample : UserControl
    {
        /// <summary>
        /// Initializes a QueryNavigationSample.
        /// </summary>
        public QueryNavigationSample()
        {
            InitializeComponent();
        }

        /// <summary>
        /// Causes navigation when a button is clicked.
        /// </summary>
        /// <param name="sender">The clicked button.</param>
        /// <param name="e">Event arguments.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Used by event defined in Xaml.")]
        private void Button_Click(object sender, RoutedEventArgs e)
        {
            navFrame.Navigate(new Uri(string.Format(CultureInfo.CurrentCulture, "/Navigation/QueryPage.xaml?x={0}&y={1}&z={2}", Uri.EscapeDataString(x.Text), Uri.EscapeDataString(y.Text), Uri.EscapeDataString(z.Text)), UriKind.Relative));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\Navigation\QueryPage.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.Windows.Navigation;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// A Page that displays values assigned by query string.
    /// </summary>
    public partial class QueryPage : Page
    {
        /// <summary>
        /// Initializes a QueryPage.
        /// </summary>
        public QueryPage()
        {
            InitializeComponent();
        }

        /// <summary>
        /// Executes when the user navigates to this page.
        /// </summary>
        /// <param name="e">Event arguments.</param>
        protected override void OnNavigatedTo(NavigationEventArgs e)
        {
            x.Text = GetArgument("x");
            y.Text = GetArgument("y");
            z.Text = GetArgument("z");
        }

        /// <summary>
        /// Gets a value passed in through the query if available.
        /// </summary>
        /// <param name="argName">The key to find.</param>
        /// <returns>The value associated with the key if available, otherwise "{Not Specified}".</returns>
        private string GetArgument(string argName)
        {
            if (NavigationContext.QueryString.ContainsKey(argName))
            {
                return NavigationContext.QueryString[argName];
            }
            return "{Not Specified}";
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\Properties\AssemblyInfo.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Reflection;
using System.Resources;
using System.Runtime.InteropServices;

[assembly: AssemblyTitle("System.Windows.Controls.Samples")]
[assembly: AssemblyDescription("Samples for System.Windows.Controls")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft Corporation")]
[assembly: AssemblyProduct("Microsoft® Silverlight™ Toolkit")]
[assembly: AssemblyCopyright("© Microsoft Corporation.  All rights reserved.")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]
[assembly: NeutralResourcesLanguage("en-US")]
[assembly: ComVisible(false)]
[assembly: Guid("931c57f5-d711-4358-93ff-0d98de7bf27d")]
[assembly: AssemblyVersion("2.0.5.0")]
[assembly: AssemblyFileVersion("3.0.30630.2254")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\Rating\RatingSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Windows.Media;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// A class that demonstrates the Rating control.
    /// </summary>
    [Sample("(0)Rating", DifficultyLevel.Basic)]
    [Category("Rating")]
    public partial class RatingSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the RatingSample class.
        /// </summary>
        public RatingSample()
        {
            InitializeComponent();
            netflix.ValueChanged += Netflix_ValueChanged;
        } 

        /// <summary>
        /// Changes the foreground of the rating control to yellow.
        /// </summary>
         /// <param name="sender">Sender Rating.</param>
        /// <param name="e">Event args.</param>
        private void Netflix_ValueChanged(object sender, RoutedPropertyChangedEventArgs<double?> e)
        {
            netflix.Foreground = new SolidColorBrush(Color.FromArgb(255, 255, 203, 0));
        }

        /// <summary>
        ///  Set the value of the rating control to 0.
        /// </summary>
        /// <param name="sender">Sender Button.</param>
        /// <param name="e">Event args.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Method is called in XAML.")]
        private void Button_Click(object sender, RoutedEventArgs e)
        {
            netflix.Value = 0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\Theming\ThemeBrowser\Budget.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Class representing a vacation budget for use by Chart samples.
    /// </summary>
    public class Budget : INotifyPropertyChanged
    {
        /// <summary>
        /// Gets or sets the date on which the expense was spent.
        /// </summary>
        public DateTime Date { get; set; }

        /// <summary>
        /// Gets or sets the the type of expense.
        /// </summary>
        public string ExpenseType { get; set; }

        /// <summary>
        /// Gets or sets the Volume (used for bubble chart).
        /// </summary>
        public double Volume { get; set; }

        /// <summary>
        /// Gets or sets the expense value.
        /// </summary>
        public double ExpenseValue
        {
            get
            {
                return _expenseValue;
            }
            set
            {
                _expenseValue = value;
                OnPropertyChanged("Count");
            }
        }

        /// <summary>
        /// Stores the expense value.
        /// </summary>
        private double _expenseValue;

        /// <summary>
        /// Fires the PropertyChanged event.
        /// </summary>
        /// <param name="propertyName">Property that changed.</param>
        private void OnPropertyChanged(string propertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (null != handler)
            {
                handler.Invoke(this, new PropertyChangedEventArgs(propertyName));
            }
        }

        /// <summary>
        /// Implements the INotifyPropertyChanged interface.
        /// </summary>
        public event PropertyChangedEventHandler PropertyChanged;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\TabControl\TabControlSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample page demonstrating the DatePicker.
    /// </summary>
    [Sample("TabControl", DifficultyLevel.Basic)]
    [Category("TabControl")]
    public partial class TabControlSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the DatePickerSample class.
        /// </summary>
        public TabControlSample()
        {
            InitializeComponent();
        }

        /// <summary>
        /// Handle button clicks to add new tab items.
        /// </summary>
        /// <param name="sender">The Button.</param>
        /// <param name="e">Event arguments.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Event handler attached in XAML.")]
        private void OnAddTabItem(object sender, RoutedEventArgs e)
        {
            sampleTabs.Items.Add(
                new TabItem
                {
                    Header = "Dynamically Created TabItem",
                    Content = "Some Content"
                });
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\Theming\ImplicitStyleManager\ImplicitStyleManagerSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.Windows.Controls;
using System.Windows.Controls.Theming;
using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample page demonstrating StyleHelper control.
    /// </summary>
    [Sample("ImplicitStyleManager", DifficultyLevel.Basic)]
    [Category("ImplicitStyleManager")]
    public partial class ImplicitStyleManagerSample : UserControl
    {
        /// <summary>
        /// Class constructor.
        /// </summary>
        public ImplicitStyleManagerSample()
        {
            InitializeComponent();
        }

        /// <summary>
        /// Applies styles to a container manually.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">Information about the event.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Xaml uses it.")]
        private void ApplyStylesManuallyButton_Click(object sender, System.Windows.RoutedEventArgs e)
        {
            ImplicitStyleManager.Apply(manualContainer);
        }

        /// <summary>
        /// Adds a button to a container to style it.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">Information about the event.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "XAML uses it.")]
        private void AddButtonToContainerButton_Click(object sender, System.Windows.RoutedEventArgs e)
        {
            dynamicContainer.Children.Add(new Button { Content = "New styled button" });
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\Theming\ThemesOverview.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.ComponentModel;
using System.Windows.Controls;
namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Overview Page is placed at the top of the Theming root node in the Sample
    /// TreeView and provide an overview of Theming.
    /// </summary>
    [Sample("Overview", DifficultyLevel.None)]
    [Category("Theming")]
    public partial class ThemesOverview : UserControl
    {
        /// <summary>
        /// Class Constructor.
        /// </summary>
        public ThemesOverview()
        {
            InitializeComponent();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\Theming\ThemeBrowser\Catalog.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Collections.ObjectModel;
using System.Diagnostics.CodeAnalysis;
using System.Windows.Controls;
using System.Windows.Markup;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Represents a Catalog of MediaItems. 
    /// </summary>
    [ContentProperty("MediaItems")]
    public class Catalog
    {
        /// <summary>
        /// Gets or sets the name of the Catalog.
        /// </summary>
        public string CatalogName { get; set; }

        /// <summary>
        /// Gets or sets the Image representing the catalog.
        /// </summary>
        public Image CatalogImage { get; set; }

        /// <summary>
        /// Gets or sets a collection of media items. 
        /// </summary>
        [SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Justification = "Simplifies samples.")]
        public Collection<MediaItem> MediaItems { get; set; }

        /// <summary>
        /// Initializes a new instance of the Catalog class. 
        /// </summary>
        /// <param name="catalogName">Name of the catalog.</param>
        /// <param name="resourceName">
        /// Name of the resource representing the catalog thumbnail.
        /// </param>
        public Catalog(string catalogName, string resourceName)
        {
            CatalogName = catalogName;
            CatalogImage = SharedResources.GetImage(resourceName);
            MediaItems = new Collection<MediaItem>();
        }

        #region Sample Data
        /// <summary>
        /// Gets a Vacation Catalog.
        /// </summary>
        public static Catalog VacationCatalog
        {
            get
            {
                Catalog catalog = new Catalog("My Vacations", "Sunset.jpg");
                catalog.MediaItems = Catalog.VacationMediaItems;
                return catalog;
            }
        }

        /// <summary>
        /// Gets a collection of media items representing a catog of upcoming
        /// vacation trips.
        /// </summary>
        public static Collection<MediaItem> PlannedVacationMediaItems
        {
            get
            {
                return new Collection<MediaItem> 
                {
                    new MediaItem("Mountains.jpg", "Australia", "My Australian Vacation", new DateTime(2006, 3, 1)),
                    new MediaItem("Oryx Antelope.jpg", "Sahara", "Sahara Desert", new DateTime(2007, 3, 12)),
                    new MediaItem("River.jpg", "Italy", "The best days of my life", new DateTime(2008, 4, 11)),
                    new MediaItem("Sunset.jpg", "Los Angeles", "I love LA", new DateTime(2008, 4, 11)),
                    new MediaItem("Desert Landscape.jpg", "Grand Canyon", "A Day in Grand Caniao", new DateTime(2008, 6, 13)),
                    new MediaItem("Mountains.jpg", "Australia", "My Australian Vacation", new DateTime(2006, 3, 1)),
                    new MediaItem("Oryx Antelope.jpg", "Sahara", "Sahara Desert", new DateTime(2007, 3, 12)),
                    new MediaItem("River.jpg", "Italy", "The best days of my life", new DateTime(2008, 4, 11)),
                    new MediaItem("Sunset.jpg", "Los Angeles", "I love LA", new DateTime(2008, 4, 11)),
                    new MediaItem("Desert Landscape.jpg", "Grand Canyon", "A Day in Grand Caniao", new DateTime(2008, 6, 13)),
                    new MediaItem("Mountains.jpg", "Australia", "My Australian Vacation", new DateTime(2006, 3, 1)),
                    new MediaItem("Oryx Antelope.jpg", "Sahara", "Sahara Desert", new DateTime(2007, 3, 12)),
                    new MediaItem("River.jpg", "Italy", "The best days of my life", new DateTime(2008, 4, 11)),
                    new MediaItem("Sunset.jpg", "Los Angeles", "I love LA", new DateTime(2008, 4, 11)),
                    new MediaItem("Desert Landscape.jpg", "Grand Canyon", "A Day in Grand Caniao", new DateTime(2008, 6, 13)) 
                };
            }
        }

        /// <summary>
        /// Gets a collection of media items representing a catog of vacaction
        /// destinations.
        /// </summary>
        public static Collection<MediaItem> VacationMediaItems
        {
            get
            {
                return new Collection<MediaItem> 
                {
                    new MediaItem("Mountains.jpg", "Australia", "My Australian Vacation", new DateTime(2006, 3, 1)),
                    new MediaItem("Oryx Antelope.jpg", "Sahara", "Sahara Desert", new DateTime(2007, 3, 12)),
                    new MediaItem("River.jpg", "Italy", "The best days of my life", new DateTime(2008, 4, 11)),
                    new MediaItem("Sunset.jpg", "Los Angeles", "I love LA", new DateTime(2008, 4, 11)),
                    new MediaItem("Desert Landscape.jpg", "Grand Canyon", "A Day in Grand Caniao", new DateTime(2008, 6, 13)),
                    new MediaItem("Humpback Whale.jpg", "Alaska", "It's Cold in here....", new DateTime(2008, 1, 12)) 
                };
            }
        }
        #endregion Sample Data
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\Theming\ThemeBrowser\MediaItem.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Windows.Controls.Samples;
using System.Collections.ObjectModel;
using System.Windows.Controls;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    ///  Business Object used in the ThemeBrowserSample.
    /// </summary>
    public sealed partial class MediaItem
    {
        /// <summary>
        /// Gets the name of the Media.
        /// </summary>
        public string MediaName { get; private set; }

        /// <summary>
        /// Gets an Image representing the media.
        /// </summary>
        public Image Image { get; private set; }

        /// <summary>
        /// Gets or sets Description of the media.
        /// </summary>
        public string Description { get; set; }

        /// <summary>
        /// Gets or sets Date Stump of the media.
        /// </summary>
        public DateTime Date { get; set; }

        /// <summary>
        /// Initializes a new instance of the Catalog class.
        /// </summary>
        /// <param name="resourceName">Name of the resource defining the Image of the media.</param>
        /// <param name="mediaName">Name of the media.</param>
        /// <param name="description">Description of the media.</param>
        /// <param name="date">Date Stump for the media.</param>
        public MediaItem(string resourceName, string mediaName, string description, DateTime date)
        {
            MediaName = mediaName;
            Description = description;
            Image = SharedResources.GetImage(resourceName);
            Date = date;
        }

        /// <summary>
        /// Overrides the string to return the name.
        /// </summary>
        /// <returns>Returns the photograph name.</returns>
        public override string ToString()
        {
            return MediaName;
        }       
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\Theming\Themes\DefaultThemeSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Windows.Controls;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Demonstrate the default theme.
    /// </summary>
    [Sample("Theming/Themes/Default")]
    public partial class DefaultThemeSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the DefaultThemeSample class.
        /// </summary>
        public DefaultThemeSample()
        {
            InitializeComponent();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\Theming\ThemeBrowser\VacationBudgetCollection.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Collections.Generic;
using System.Globalization;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Tracks vacation budget across a period of time.
    /// </summary>
    public class VacationBudgetCollection : IEnumerable<Budget>
    {
        /// <summary>
        /// Returns a stream of expenses across a period of time.
        /// </summary>
        /// <returns>A stream of expenses for this vacation.</returns>
        public IEnumerator<Budget> GetEnumerator()
        {
            yield return new Budget { Date = DateTime.Parse("9/6/2008", CultureInfo.InvariantCulture), ExpenseValue = 53 };
            yield return new Budget { Date = DateTime.Parse("9/2/2008", CultureInfo.InvariantCulture), ExpenseValue = 42 };
            yield return new Budget { Date = DateTime.Parse("8/31/2008", CultureInfo.InvariantCulture), ExpenseValue = 43 };
            yield return new Budget { Date = DateTime.Parse("8/30/2008", CultureInfo.InvariantCulture), ExpenseValue = 43 };
            yield return new Budget { Date = DateTime.Parse("8/23/2008", CultureInfo.InvariantCulture), ExpenseValue = 47 };
            yield return new Budget { Date = DateTime.Parse("8/22/2008", CultureInfo.InvariantCulture), ExpenseValue = 45 };
            yield return new Budget { Date = DateTime.Parse("8/21/2008", CultureInfo.InvariantCulture), ExpenseValue = 40 };
            yield return new Budget { Date = DateTime.Parse("8/19/2008", CultureInfo.InvariantCulture), ExpenseValue = 39 };
            yield return new Budget { Date = DateTime.Parse("8/17/2008", CultureInfo.InvariantCulture), ExpenseValue = 42 };
            yield return new Budget { Date = DateTime.Parse("8/16/2008", CultureInfo.InvariantCulture), ExpenseValue = 43 };
            yield return new Budget { Date = DateTime.Parse("8/15/2008", CultureInfo.InvariantCulture), ExpenseValue = 42 };
            yield return new Budget { Date = DateTime.Parse("8/12/2008", CultureInfo.InvariantCulture), ExpenseValue = 47 };
            yield return new Budget { Date = DateTime.Parse("8/10/2008", CultureInfo.InvariantCulture), ExpenseValue = 43 };
            yield return new Budget { Date = DateTime.Parse("8/7/2008", CultureInfo.InvariantCulture), ExpenseValue = 38 };
            yield return new Budget { Date = DateTime.Parse("8/3/2008", CultureInfo.InvariantCulture), ExpenseValue = 39 };
            yield return new Budget { Date = DateTime.Parse("8/2/2008", CultureInfo.InvariantCulture), ExpenseValue = 41 };
            yield return new Budget { Date = DateTime.Parse("8/1/2008", CultureInfo.InvariantCulture), ExpenseValue = 41 };
            yield return new Budget { Date = DateTime.Parse("7/28/2008", CultureInfo.InvariantCulture), ExpenseValue = 44 };
            yield return new Budget { Date = DateTime.Parse("7/26/2008", CultureInfo.InvariantCulture), ExpenseValue = 49 };
            yield return new Budget { Date = DateTime.Parse("7/25/2008", CultureInfo.InvariantCulture), ExpenseValue = 42 };
            yield return new Budget { Date = DateTime.Parse("7/22/2008", CultureInfo.InvariantCulture), ExpenseValue = 40 };
            yield return new Budget { Date = DateTime.Parse("7/19/2008", CultureInfo.InvariantCulture), ExpenseValue = 41 };
            yield return new Budget { Date = DateTime.Parse("7/12/2008", CultureInfo.InvariantCulture), ExpenseValue = 46 };
            yield return new Budget { Date = DateTime.Parse("7/11/2008", CultureInfo.InvariantCulture), ExpenseValue = 40 };
            yield return new Budget { Date = DateTime.Parse("7/10/2008", CultureInfo.InvariantCulture), ExpenseValue = 41 };
            yield return new Budget { Date = DateTime.Parse("7/9/2008", CultureInfo.InvariantCulture), ExpenseValue = 39 };
        }

        /// <summary>
        /// Returns a stream of vacation expenses.
        /// </summary>
        /// <returns>A stream of vacation expenses.</returns>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return ((IEnumerable<Budget>)this).GetEnumerator();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\Theming\ThemeBrowser\ThemeBrowserSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Windows.Controls;
using System.Windows.Controls.Theming;
using System.Collections.Generic;
using System.Collections;
using System.Windows.Controls.DataVisualization.Charting;
using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Theme Sample Browser.
    /// </summary>
    [Sample("Theme Browser", DifficultyLevel.Basic)]
    [Category("Theme Browser")]
    public partial class ThemeBrowserSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the ThemeBrowserSample class.
        /// </summary>
        public ThemeBrowserSample()
        {
            InitializeComponent();

            ThemesList.ItemsSource = ThemeCatalogItem.ThemesCatalog;
            ThemesList.SelectionChanged += OnThemeChanged;

            // Show the first theme
            ShowTheme(ThemeCatalogItem.TwilightBlue);
        }

        /// <summary>
        /// Fired when the selected item in the list changes.
        /// </summary>
        /// <param name="sender">The source object.</param>
        /// <param name="e">Event arguments.</param>
        private void OnThemeChanged(object sender, SelectionChangedEventArgs e)
        {
            // Remove the current theme from the end of the DemoControls area
            DemoControls.Children.RemoveAt(1);

            // Show the new theme
            ShowTheme(ThemesList.SelectedItem as ThemeCatalogItem);
        }

        /// <summary>
        /// Show the selected theme.
        /// </summary>
        /// <param name="item">The selected theme.</param>
        private void ShowTheme(ThemeCatalogItem item)
        {
            AllControls demo = new AllControls();
            demo.Loaded += (obj, e) => System.Diagnostics.Debug.WriteLine("Loaded");
            demo.PreferredBackground = item.PreferredBackground;
            DemoControls.Children.Add(demo);

            Uri uri = new Uri(item.ThemeXamlPath, UriKind.Relative);
            demo.ApplyStyle(uri);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\Theming\ThemeBrowser\ThemeCatalogItem.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Windows.Media;
using System.Windows.Controls;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Buisness Object used in the ThemeBrowserSample.
    /// </summary>
    public sealed partial class ThemeCatalogItem
    {
        /// <summary>
        ///  Gets or sets the name of the theme.
        /// </summary>
        public string ThemeName { get; set; }

        /// <summary>
        /// Gets or sets the thumnail Image representing the theme.
        /// </summary>
        public Image ThumbnailImage { get; set; }

        /// <summary>
        /// Gets or sets the prefered background brush for this theme.
        /// </summary>
        public Brush PreferredBackground { get; set; }
        
        /// <summary>
        /// Gets or sets the path of the theme xaml file for this theme.
        /// </summary>
        public string ThemeXamlPath { get; set; }

        /// <summary>
        /// Initializes a new instance of the ThemeCatologItem class.
        /// </summary>
        public ThemeCatalogItem()
        {
        }

        /// <summary>
        /// Initializes a new instance of the ThemeCatologItem class.
        /// </summary>
        /// <param name="themeName">Name of the theme.</param>
        /// <param name="resourceName">
        /// Name of the resource defining the Thumbnail for the theme.
        /// </param>
        /// <param name="themeXamlPath">
        /// Path to the XAML file for this theme.
        /// </param>
        /// <param name="preferredBackground">
        /// Preferred Background for the theme.
        /// </param>
        internal ThemeCatalogItem(string themeName, string resourceName, string themeXamlPath, Brush preferredBackground)
        {
            ThemeName = themeName;
            ThumbnailImage = SharedResources.GetImage(resourceName);
            ThemeXamlPath = themeXamlPath;
            PreferredBackground = preferredBackground;
        }

        #region Sample Data
        /// <summary>
        /// Gets a Theme object that represents Shiny Blue.
        /// </summary>
        public static ThemeCatalogItem ShinyBlue
        {
            get
            {
                LinearGradientBrush brush = GetLinearBrush(Color.FromArgb(255, 132, 150, 170), Color.FromArgb(255, 43, 49, 56));
                return new ThemeCatalogItem(
                    "Shiny Blue",
                    "thumbShinyBlue.png",
                    @"System.Windows.Controls.Samples;component/theming/ThemeBrowser/ShinyBlue.xaml",
                    brush);
            }
        }

        /// <summary>
        /// Gets a Theme object that represents Shiny Red.
        /// </summary>
        public static ThemeCatalogItem ShinyRed
        {
            get
            {
                LinearGradientBrush brush = GetLinearBrush(Color.FromArgb(255, 209, 209, 209), Color.FromArgb(255, 174, 49, 56));
                return new ThemeCatalogItem(
                    "Shiny Red",
                    "thumbShinyRed.png",
                    "System.Windows.Controls.Samples;component/Theming/ThemeBrowser/ShinyRed.xaml",
                    brush);
            }
        }

        /// <summary>
        /// Gets a Theme object that represents RainierOrange Theme.
        /// </summary>
        public static ThemeCatalogItem RainierOrange
        {
            get
            {
                LinearGradientBrush brush = GetLinearBrush(Color.FromArgb(255, 0, 0, 0), Color.FromArgb(255, 7, 15, 19));
                return new ThemeCatalogItem(
                    "Rainier Orange",
                    "thumbRainierOrange.png",
                    @"System.Windows.Controls.Samples;component/theming/ThemeBrowser/RainierOrange.xaml",
                    brush);
            }
        }

        /// <summary>
        /// Gets a Theme object that represents RainierPurple Theme.
        /// </summary>
        public static ThemeCatalogItem RainierPurple
        {
            get
            {
                LinearGradientBrush brush = GetLinearBrush(Color.FromArgb(255, 0, 0, 0), Color.FromArgb(255, 7, 15, 19));
                return new ThemeCatalogItem(
                    "Rainier Purple",
                    "thumbRainierPurple.png",
                    @"System.Windows.Controls.Samples;component/theming/ThemeBrowser/RainierPurple.xaml",
                    brush);
            }
        }

        /// <summary>
        /// Gets a Theme object that represents ExpressionDark.
        /// </summary>
        public static ThemeCatalogItem ExpressionDark
        {
            get
            {
                LinearGradientBrush brush = GetLinearBrush(Color.FromArgb(255, 23, 23, 23), Color.FromArgb(255, 10, 10, 10));
                return new ThemeCatalogItem(
                    "Expression Dark",
                    "thumbExpresssionDark.png",
                    @"System.Windows.Controls.Samples;component/theming/ThemeBrowser/ExpressionDark.xaml",
                    brush);
            }
        }

        /// <summary>
        /// Gets a Theme object that represents ExpressionDark.
        /// </summary>
        public static ThemeCatalogItem ExpressionLight
        {
            get
            {
                LinearGradientBrush brush = GetLinearBrush(Color.FromArgb(255, 189, 189, 189), Color.FromArgb(255, 160, 160, 160));                   
                return new ThemeCatalogItem(
                    "Expression Light",
                    "thumbExpresssionLight.png",
                    @"System.Windows.Controls.Samples;component/theming/ThemeBrowser/ExpressionLight.xaml",
                    brush);
            }
        }

        /// <summary>
        /// Gets a Theme object that represents Bureau Blue.
        /// </summary>
        public static ThemeCatalogItem BureauBlue
        {
            get
            {
                LinearGradientBrush brush = GetLinearBrush(Color.FromArgb(255, 191, 219, 255), Color.FromArgb(255, 166, 194, 229));
                return new ThemeCatalogItem(
                    "Bureau Blue",
                    "BureauBlue.png",
                    @"System.Windows.Controls.Samples;component/theming/ThemeBrowser/BureauBlue.xaml",
                    brush);
            }
        }

        /// <summary>
        /// Gets a Theme object that represents Bureau Black.
        /// </summary>
        public static ThemeCatalogItem BureauBlack
        {
            get
            {
                LinearGradientBrush brush = GetLinearBrush(Color.FromArgb(255, 91, 91, 91), Color.FromArgb(255, 13, 13, 13));
                return new ThemeCatalogItem(
                    "Bureau Black",
                    "BureauBlack.png",
                    @"System.Windows.Controls.Samples;component/theming/ThemeBrowser/BureauBlack.xaml",
                    brush);
            }
        }

        /// <summary>
        /// Gets a Theme object that represents Bureau Black.
        /// </summary>
        public static ThemeCatalogItem WhistlerBlue
        {
            get
            {
                LinearGradientBrush brush = GetLinearBrush(Color.FromArgb(255, 255, 255, 255), Color.FromArgb(255, 255, 255, 255));
                return new ThemeCatalogItem(
                    "Whistler Blue",
                    "WhistlerBlue.png",
                    @"System.Windows.Controls.Samples;component/theming/ThemeBrowser/WhistlerBlue.xaml",
                    brush);
            }
        }

        /// <summary>
        /// Gets a Theme object that represents Twilight Blue.
        /// </summary>
        public static ThemeCatalogItem TwilightBlue
        {
            get
            {
                LinearGradientBrush brush = GetLinearBrush(Color.FromArgb(255, 120, 183, 225), Color.FromArgb(255, 120, 183, 225));
                return new ThemeCatalogItem(
                    "Twilight Blue",
                    "TwilightBlue.png",
                    @"System.Windows.Controls.Samples;component/theming/ThemeBrowser/TwilightBlue.xaml",
                    brush);
            }
        }

        /// <summary>
        /// Gets a Theme object that represents Bubble Creme.
        /// </summary>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Creme", Justification = "Correct Spelling")]
        public static ThemeCatalogItem BubbleCreme
        {
            get
            {
                LinearGradientBrush brush = GetLinearBrush(Color.FromArgb(255, 249, 249, 230), Color.FromArgb(255, 249, 249, 230));
                return new ThemeCatalogItem(
                    "Bubble Creme",
                    "BubbleCreme.png",
                    @"System.Windows.Controls.Samples;component/theming/ThemeBrowser/BubbleCreme.xaml",
                    brush);
            }
        }

        /// <summary>
        /// Gets a collection of theme objects.
        /// </summary>
        public static IEnumerable<ThemeCatalogItem> ThemesCatalog
        {
            get { return new ThemeCatalogItem[] { BubbleCreme, TwilightBlue, ExpressionDark, ExpressionLight, WhistlerBlue, BureauBlack, BureauBlue, ShinyBlue, ShinyRed, RainierOrange, RainierPurple }; }
        }
        
        /// <summary>
        /// Create a Theme background LinearGradientBrush.
        /// </summary>
        /// <param name="startColor">
        /// Represents the start color of the gradient.
        /// </param>
        /// <param name="endColor">
        /// Represents the end color of the gradient.
        /// </param>
        /// <returns>Returns a linear gradient brush.</returns>
        private static LinearGradientBrush GetLinearBrush(Color startColor, Color endColor)
        {
            LinearGradientBrush brush = new LinearGradientBrush();
            GradientStop colorStop1 = new GradientStop();
            colorStop1.Color = startColor;
            GradientStop colorStop2 = new GradientStop();
            colorStop2.Color = endColor;
            colorStop2.Offset = 1;
            brush.StartPoint = new System.Windows.Point(0.5, 1);
            brush.EndPoint = new System.Windows.Point(0.5, 0);
            brush.GradientStops = new GradientStopCollection { colorStop1, colorStop2 };
            return brush;
        }
        #endregion Sample Data
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\Theming\Themes\ExpressionDarkThemeSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Windows.Controls;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Demonstrate the ExpressionDark theme.
    /// </summary>
    [Sample("Theming/Themes/ExpressionDark")]
    public partial class ExpressionDarkThemeSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the ExpressionDarkThemeSample class.
        /// </summary>
        public ExpressionDarkThemeSample()
        {
            InitializeComponent();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\Theming\Themes\AllControls.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Diagnostics.CodeAnalysis;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Media;
using System.Windows.Controls.Theming;
using System.Collections.Generic;
using System.Windows.Controls.DataVisualization.Charting;
using System.Collections;
using System.Linq;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// A user control with examples of every control to demonstrate themes.
    /// </summary>
    public partial class AllControls : UserControl
    {
        /// <summary>
        /// Gets or sets the Background Brush for this user Control.
        /// </summary>
        public Brush PreferredBackground
        {
            get { return Root.Background; }
            set { Root.Background = value; }
        }

        /// <summary>
        /// Initializes a new instance of the AllControls class.
        /// </summary>
        public AllControls()
        {
            InitializeComponent();
            LayoutUpdated += OnLayoutUpdated;

            SampleDataGrid.ItemsSource = Employee.Executives;
            SampleAutoComplete.ItemsSource = Catalog.VacationMediaItems;
        }

        /// <summary>
        /// Initialize ImplicitStyleManager once the visual tree is ready.
        /// </summary>
        /// <param name="sender">The UserControl.</param>
        /// <param name="e">Event arguments.</param>
        private void OnLayoutUpdated(object sender, EventArgs e)
        {
            // Only apply once
            LayoutUpdated -= OnLayoutUpdated;

            // ImplicitStyleManager is design to only style controls in the
            // namescope it was defined in.  Since user controls create new
            // namescopes, the ImplicitStyleManager acting on the Theme controls
            // will not style the controls in the AllControls user control.  By
            // applying ImplicitStyleManager to the root of the user control
            // (without giving it a theme to use), it will walk up the visual
            // tree to the Theme control and use its styles.
            ImplicitStyleManager.SetApplyMode(Root, ImplicitStylesApplyMode.OneTime);
            ImplicitStyleManager.Apply(Root);
        }

        /// <summary>
        /// Applies the style.
        /// </summary>
        /// <param name="uri">The URI of the theme used.</param>
        internal void ApplyStyle(Uri uri)
        {
            ImplicitStyleManager.SetResourceDictionaryUri(this, uri);
            ImplicitStyleManager.SetApplyMode(this, ImplicitStylesApplyMode.OneTime);
            ImplicitStyleManager.Apply(this);

            // explicitly set content of expander.
            ImplicitStyleManager.SetApplyMode(expander.Content as FrameworkElement, ImplicitStylesApplyMode.OneTime);
            ImplicitStyleManager.Apply(expander.Content as FrameworkElement);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\TimeInput\ArabicTimeGlobalizationInfo.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.Collections.Generic;
using System.Globalization;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Overridden TimeGlobalizationInfo for shows mapping of characters to 
    /// Arabic.
    /// </summary>
    public class ArabicTimeGlobalizationInfo : TimeGlobalizationInfo
    {
        /// <summary>
        /// Dictionary helpful for translation.
        /// </summary>
        private readonly Dictionary<int, char> arabicNumbers = new Dictionary<int, char>
                                                                    {
                                                                            { 0, '٠' },
                                                                            { 1, '١' },
                                                                            { 2, '٢' },
                                                                            { 3, '٣' },
                                                                            { 4, '٤' },
                                                                            { 5, '٥' },
                                                                            { 6, '٦' },
                                                                            { 7, '٧' },
                                                                            { 8, '٨' },
                                                                            { 9, '٩' }
                                                                    };

        /// <summary>
        /// Returns the global representation of a character.
        /// </summary>
        /// <param name="input">Character that will be mapped to a different
        /// character.</param>
        /// <returns>
        /// The global version of a character that represents the input.
        /// </returns>
        protected override char MapDigitToCharacter(int input)
        {
            if (arabicNumbers.ContainsKey(input))
            {
                return arabicNumbers[input];
            }
            else
            {
                return base.MapDigitToCharacter(input);
            }
        }

        /// <summary>
        /// Returns the char that is represented by a global character.
        /// </summary>
        /// <param name="input">The global version of the character that needs
        /// to be mapped to a regular character.</param>
        /// <returns>
        /// The character that represents the global version of a character.
        /// </returns>
        protected override char MapCharacterToDigit(char input)
        {
            if (arabicNumbers.ContainsValue(input))
            {
                foreach (var pair in arabicNumbers)
                {
                    if (pair.Value == input)
                    {
                        return pair.Key.ToString(CultureInfo.InvariantCulture)[0];
                    }
                }
            }

            return base.MapCharacterToDigit(input);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\Theming\Themes\ShinyBlueThemeSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Windows.Controls;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Demonstrate the Shiny Blue theme.
    /// </summary>
    [Sample("Theming/Themes/ShinyBlue")]
    public partial class ShinyBlueThemeSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the ShinyBlueThemeSamlple class.
        /// </summary>
        public ShinyBlueThemeSample()
        {
            InitializeComponent();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\TimeInput\TimeInputSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample for TimeInput.
    /// </summary>
    [Sample("(1)TimePicker", DifficultyLevel.Basic)]
    [Category("TimePicker")]
    public partial class TimeInputSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TimeInputSample"/> class.
        /// </summary>
        public TimeInputSample()
        {
            InitializeComponent();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\TimeInput\TimePickerArabicCulture.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample for Arabic culture.
    /// </summary>
    [Sample("With Arabic Globalization", DifficultyLevel.Basic)]
    [Category("TimePicker")]
    public partial class TimePickerArabicCulture : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TimePickerArabicCulture"/> class.
        /// </summary>
        public TimePickerArabicCulture()
        {
            InitializeComponent();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\TimeInput\TimePickerGesturesScenarios.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.ComponentModel;
using System.Threading;
using System.Windows.Input;
using System.Diagnostics.CodeAnalysis;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample page that demonstrates different
    /// interactions that are possible.
    /// </summary>
    [Sample("TimePicker Gestures", DifficultyLevel.Scenario)]
    [Category("TimePicker")]
    public partial class TimePickerGesturesScenarios : UserControl
    {
        /// <summary>
        /// Closing the dropdown will move focus to the ToggleButton, which 
        /// will raise the 'GotFocus' event on the TimePicker, resulting in a
        /// loop. We will ignore the next Focus event after closing the dropdown
        /// to prevent this.
        /// </summary>
        private bool _ignoreNextGain;

        /// <summary>
        /// Initializes a new instance of the <see cref="TimePickerGesturesScenarios"/> class.
        /// </summary>
        public TimePickerGesturesScenarios()
        {
            InitializeComponent();

            tp.GotFocus += GainedFocus;
        }

        #region Focus
        /// <summary>
        /// Called when the picker gains focus.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="System.Windows.RoutedEventArgs"/> instance containing the event data.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Set from Xaml.")]
        private void GainedFocus(object sender, RoutedEventArgs e)
        {
            if (!_ignoreNextGain)
            {
                tp.DropDownClosed += DropDownClosed;
                tp.IsDropDownOpen = true;
            }
            else
            {
                _ignoreNextGain = false;
            }
        }

        /// <summary>
        /// Handles the DropDownClosed event of the control.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">The instance containing the event data.</param>
        private void DropDownClosed(object sender, RoutedPropertyChangedEventArgs<bool> e)
        {
            tp.DropDownClosed -= DropDownClosed;

            // closing dropdown will move focus to button.
            _ignoreNextGain = true;
        }
        #endregion Focus

        #region Hover
        /// <summary>
        /// Called when the mouse enters the Picker.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="System.Windows.Input.MouseEventArgs"/> instance containing the event data.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Called by Xaml.")]
        private void PickerMouseEnter(object sender, MouseEventArgs e)
        {
            tp2.IsDropDownOpen = true;
        }
        #endregion Hover
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\TimeInput\PlusMinusHourTimeParser.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.Globalization;
using System.Text.RegularExpressions;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Custom parser that will parse a plus or minus
    /// symbol and a number to an offset of hours.
    /// </summary>
    /// <example>input: +2h, output DateTime.Now plus 2 hours.</example>
    public class PlusMinusHourTimeParser : TimeParser
    {
        /// <summary>
        /// Expression used to parse.
        /// </summary>
        private static readonly Regex exp = new Regex(@"(?<hours>[+|-]\d{1,2})[h|H]", RegexOptions.CultureInvariant);

        /// <summary>
        /// Tries to parse a string to a DateTime.
        /// </summary>
        /// <param name="text">The text that should be parsed.</param>
        /// <param name="culture">The culture being used.</param>
        /// <param name="result">The parsed DateTime.</param>
        /// <returns>
        /// True if the parse was successful, false if it was not.
        /// </returns>
        public override bool TryParse(string text, CultureInfo culture, out DateTime? result)
        {
            Match match = exp.Match(text);

            if (match.Success)
            {
                int number = int.Parse(match.Groups["hours"].Value, culture);
                result = DateTime.Now.AddHours(number);
                return true;
            }

            result = null;
            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\TimeInput\TimeInputPopupSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample for the different Popups in TimeInput.
    /// </summary>
    [Sample("TimePopup", DifficultyLevel.Basic)]
    [Category("TimePicker")]
    public partial class TimeInputPopupSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TimeInputPopupSample"/> class.
        /// </summary>
        public TimeInputPopupSample()
        {
            InitializeComponent();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\TimeInput\PlusMinusMinuteTimeInputParser.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.Globalization;
using System.Text.RegularExpressions;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Custom parser that will parse a plus or minus
    /// symbol and a number to an offset of minutes.
    /// </summary>
    /// <example>input: +2m, output DateTime.Now plus 2 minutes.</example>
    public class PlusMinusMinuteTimeInputParser : TimeParser
    {
        /// <summary>
        /// Expression used to parse.
        /// </summary>
        private static readonly Regex exp = new Regex(@"(?<minutes>[+|-]\d{1,2})[m|M]", RegexOptions.CultureInvariant);

        /// <summary>
        /// Tries to parse a string to a DateTime.
        /// </summary>
        /// <param name="text">The text that should be parsed.</param>
        /// <param name="culture">The culture being used.</param>
        /// <param name="result">The parsed DateTime.</param>
        /// <returns>
        /// True if the parse was successful, false if it was not.
        /// </returns>
        public override bool TryParse(string text, CultureInfo culture, out DateTime? result)
        {
            Match match = exp.Match(text);

            if (match.Success)
            {
                int number = int.Parse(match.Groups["minutes"].Value, culture);
                result = DateTime.Now.AddMinutes(number);
                return true;
            }
            result = null;
            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\TimeInput\TimeUpDownSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample for TimeUpDown.
    /// </summary>
    [Sample("(2)TimeUpDown", DifficultyLevel.Basic)]
    [Category("TimePicker")]
    public partial class TimeUpDownSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TimeUpDownSample"/> class.
        /// </summary>
        public TimeUpDownSample()
        {
            InitializeComponent();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\TreeMap\InterpolatorsSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;

[assembly: SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.InterpolatorsSample.#itemBorder", Justification = "Artifact of using a name inside the custom control template.")]

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Example showing how to create and use Interpolators with for TreeMap. An interpolator 
    /// calculates the minimum and maximum values for the bound property across the whole tree, and
    /// then projects the value in the specified [From, To] range.
    /// </summary>
    [Sample("(2)Interpolators", DifficultyLevel.Basic)]
    [Category("TreeMap")]
    public partial class InterpolatorsSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the InterpolatorsSample class.
        /// </summary>
        public InterpolatorsSample()
        {
            InitializeComponent();
            Loaded += new RoutedEventHandler(InterpolatorsSample_Loaded);
        }

        /// <summary>
        /// Loads the XML sample data and populates the TreeMap.
        /// </summary>
        /// <param name="sender">The object where the event handler is attached.</param>
        /// <param name="e">The event data.</param>
        private void InterpolatorsSample_Loaded(object sender, RoutedEventArgs e)
        {
            // Sample browser-specific layout change
            SampleHelpers.ChangeSampleAlignmentToStretch(this);

            treeMapControl.ItemsSource = DataHelper.LoadDefaultFile();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\TreeMap\FlexibleTemplateSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample showing how an ItemDefinitionSelector can be used to return a different
    /// template for each level in the tree.
    /// </summary>
    [Sample("(1)ItemDefinitionSelector", DifficultyLevel.Intermediate)]
    [Category("TreeMap")]
    public partial class FlexibleTemplateSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the FlexibleTemplateSample class.
        /// </summary>
        public FlexibleTemplateSample()
        {
            InitializeComponent();
            Loaded += new RoutedEventHandler(FlexibleTemplateSample_Loaded);
        }

        /// <summary>
        /// Loads the XML sample data and populates the TreeMap.
        /// </summary>
        /// <param name="sender">The object where the event handler is attached.</param>
        /// <param name="e">The event data.</param>
        private void FlexibleTemplateSample_Loaded(object sender, RoutedEventArgs e)
        {
            // Sample browser-specific layout change
            SampleHelpers.ChangeSampleAlignmentToStretch(this);

            treeMapControl.ItemsSource = DataHelper.LoadDefaultFile();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\TreeMap\NhlNode.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Text;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Represents the statistics for a team, division, conference, or the league as a whole.
    /// </summary>
    public class NhlNode
    {
        /// <summary>
        /// Gets or sets a value representing the rank of the node in its level (team, division, etc).
        /// </summary>
        public int Rank { get; set; }

        /// <summary>
        /// Gets or sets a value representing the name of the entity (team, division, etc).
        /// </summary>
        public string Name { get; set; }

        /// <summary>
        /// Gets or sets a value representing the number of points either for a single team in the case of a leaf, 
        /// or the aggregate sum of the children for a parent node.
        /// </summary>
        public int Points { get; set; }

        /// <summary>
        /// Gets or sets a value representing the number of wins either for a single team in the case of a leaf, 
        /// or the aggregate sum of the children for a parent node.
        /// </summary>
        public int Wins { get; set; }

        /// <summary>
        /// Gets or sets a value representing the number of losses either for a single team in the case of a leaf, 
        /// or the aggregate sum of the children for a parent node.
        /// </summary>
        public int Losses { get; set; }

        /// <summary>
        /// Gets or sets a value representing the number of goals earned in the season either for a single team in the case of a leaf, 
        /// or the aggregate sum of the children for a parent node.
        /// </summary>
        public int GoalsFor { get; set; }

        /// <summary>
        /// Gets or sets a value representing the number of goals against accrued either for a single team in the case of a leaf, 
        /// or the aggregate sum of the children for a parent node.
        /// </summary>
        public int GoalsAgainst { get; set; }

        /// <summary>
        /// Gets or sets a value representing the number of penalty minutes accrued either for a single team in the case of a leaf, 
        /// or the aggregate sum of the children for a parent node.
        /// </summary>
        public int PenaltyMinutes { get; set; }

        /// <summary>
        /// Gets or sets a value representing the children of this division, conference, or league. Empty for teams.
        /// </summary>
        [SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Justification = "Simplifies samples.")]
        public IList<NhlNode> Children { get; set; }

        /// <summary>
        /// Gets the desired tooltip content.
        /// </summary>
        public string ToolTip
        {
            get
            {
                StringBuilder outStr = new StringBuilder();
                outStr.Append(Name);
                outStr.Append("\nRank: ").Append(Rank);
                outStr.Append("\nPoints: ").Append(Points);
                outStr.Append("\nWins: ").Append(Wins);
                outStr.Append("\nLosses: ").Append(Losses);
                outStr.Append("\nGoals For: ").Append(GoalsFor);
                outStr.Append("\nGoals Against: ").Append(GoalsAgainst);
                outStr.Append("\nPenalty Minutes: ").Append(PenaltyMinutes);

                return outStr.ToString();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\TransitioningContentControl\TransitioningContentControlSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample for the experimental control: TransitioningContentControl.
    /// </summary>
    /// <QualityBand>Experimental</QualityBand>
    [Sample("TransitioningContentControl", DifficultyLevel.Basic)]
    [Category("TransitioningContentControl")]
    public partial class TransitioningContentControlSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TransitioningContentControlSample"/> class.
        /// </summary>
        public TransitioningContentControlSample()
        {
            InitializeComponent();

            Loaded += (sender, e) => dud.ItemsSource = Airport.SampleAirports;
        }

        /// <summary>
        /// Changes the content with the default transition.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="System.Windows.RoutedEventArgs"/> instance containing the event data.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Used by Xaml.")]
        private void ChangeContentSample1(object sender, RoutedEventArgs e)
        {
            defaultTCC.Transition = TransitioningContentControl.DefaultTransitionState;
            defaultTCC.Content = DateTime.Now.Ticks;
        }

        /// <summary>
        /// Changes the content with the down transition.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="System.Windows.RoutedEventArgs"/> instance containing the event data.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Used by Xaml.")]
        private void ChangeContentSample1Down(object sender, RoutedEventArgs e)
        {
            defaultTCC.Transition = "DownTransition";
            defaultTCC.Content = DateTime.Now.Ticks;
        }

        /// <summary>
        /// Changes the content up transition.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="System.Windows.RoutedEventArgs"/> instance containing the event data.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Used by Xaml.")]
        private void ChangeContentSample1Up(object sender, RoutedEventArgs e)
        {
            defaultTCC.Transition = "UpTransition";
            defaultTCC.Content = DateTime.Now.Ticks;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\TreeMap\AlternatingItemDefinitionSelector.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.Collections.ObjectModel;
using System.Windows.Controls.DataVisualization;
using System.Windows.Markup;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Dynamically chooses a TreeMapItemDefintion based on an item's level in the hierarchy.
    /// </summary>
    [ContentProperty("Children")]
    public class AlternatingItemDefinitionSelector : TreeMapItemDefinitionSelector
    {
        /// <summary>
        /// Gets the list of templates that this selector will choose from.
        /// </summary>
        public Collection<TreeMapItemDefinition> Children { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="AlternatingItemDefinitionSelector"/> class. 
        /// </summary>
        public AlternatingItemDefinitionSelector()
        {
            Children = new Collection<TreeMapItemDefinition>();
        }

        /// <summary>
        /// Returns an instance of a TreeMapItemDefinition class used to specify properties for the 
        /// current item. 
        /// </summary>
        /// <param name="treeMap">Reference to the TreeMap class.</param>
        /// <param name="item">One of the nodes in the ItemsSource hierarchy.</param>
        /// <param name="level">The level of the node in the hierarchy.</param>
        /// <returns>The TreeMapItemDefinition to be used for this node. If this method returns null 
        /// the TreeMap will use the value of its ItemDefinition property.</returns>
        public override TreeMapItemDefinition SelectItemDefinition(TreeMap treeMap, object item, int level)
        {
            if (Children.Count > 0)
            {
                int child = level % Children.Count;
                return Children[child];
            }
            else
            {
                return null;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\TransitioningContentControl\TransitioningDomainUpDown.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Implementation of DomainUpDown that uses a TransitioningContentControl
    /// it its template.
    /// </summary>
    /// <QualityBand>Experimental</QualityBand>
    /// <remarks>Implemented in the sample project. The sample page will set
    /// the custom template that this control expects.</remarks>
    public class TransitioningDomainUpDown : DomainUpDown
    {
        /// <summary>
        /// The name of the state that represents a transition effect upwards.
        /// </summary>
        public const string UpTransitionState = "UpTransition";

        /// <summary>
        /// The name of the state that represents a transition effect downwards.
        /// </summary>
        public const string DownTransitionState = "DownTransition";

        /// <summary>
        /// Gets or sets the transition element.
        /// </summary>
        /// <value>The transition element.</value>
        private TransitioningContentControl TransitionElement { get; set; }

        /// <summary>
        /// Occurs when the TransitioningDomainUpDown is incremented.
        /// </summary>
        public event EventHandler Incremented;

        /// <summary>
        /// Occurs when the TransitioningDomainUpDown is decremented.
        /// </summary>
        public event EventHandler Decremented;

        /// <summary>
        /// Gets or sets the Style for the TransitioningContentControl.
        /// </summary>
        public Style TransitioningContentControlStyle
        {
            get { return TransitionElement.Style; }
            set { TransitionElement.Style = value; }
        }

        /// <summary>
        /// Builds the visual tree for the DomainUpDown control when a new
        /// template is applied.
        /// </summary>
        public override void OnApplyTemplate()
        {
            base.OnApplyTemplate();

            TransitionElement = GetTemplateChild("Visualization") as TransitioningContentControl;
        }

        /// <summary>
        /// Called by OnSpin when the spin direction is SpinDirection.Increase.
        /// Will not go beyond the first or last item unless IsCyclic is set.
        /// </summary>
        protected override void OnIncrement()
        {
            if (TransitionElement != null)
            {
                TransitionElement.Transition = UpTransitionState;
            }
            base.OnIncrement();

            EventArgs args = new EventArgs();
            OnIncremented(args);
        }

        /// <summary>
        /// Raised when the spin direction is SpinDirection.Decrease.
        /// </summary>
        /// <param name="e">The <see cref="System.Windows.EventArgs"/> 
        /// instance containing the event data.</param>
        protected virtual void OnIncremented(EventArgs e)
        {
            EventHandler handler = Incremented;
            if (handler != null)
            {
                handler(this, e);
            }
        }

        /// <summary>
        /// Called by OnSpin when the spin direction is SpinDirection.Increase.
        /// Will not go beyond the first or last item unless IsCyclic is set.
        /// </summary>
        protected override void OnDecrement()
        {
            if (TransitionElement != null)
            {
                TransitionElement.Transition = DownTransitionState;
            }
            base.OnDecrement();

            EventArgs args = new EventArgs();
            OnDecremented(args);
        }

        /// <summary>
        /// Raised when the spin direction is SpinDirection.Decrease.
        /// </summary>
        /// <param name="e">The <see cref="System.Windows.EventArgs"/> 
        /// instance containing the event data.</param>
        protected virtual void OnDecremented(EventArgs e)
        {
            EventHandler handler = Decremented;
            if (handler != null)
            {
                handler(this, e);
            }
        }

        /// <summary>
        /// Decrement the TransitioningDomainUpDown.
        /// </summary>
        public void Decrement()
        {
            OnDecrement();
        }

        /// <summary>
        /// Increment the TransitioningDomainUpDown.
        /// </summary>
        public void Increment()
        {
            OnIncrement();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\TimeInput\TimePickerStudio.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Linq;
using System.Collections.Generic;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample that allows setting properties on a TimePicker.
    /// </summary>
    [Sample("(3)TimePicker Studio", DifficultyLevel.Intermediate)]
    [Category("TimePicker")]
    public partial class TimePickerStudio : UserControl
    {
        #region Cultures
        /// <summary>
        /// Cultures that are recognized on most configurations.
        /// </summary>
        private readonly string[] _cultureNames = new[]
                                             {
                                                     "af", "af-ZA", "ar", "ar-AE", "ar-BH", "ar-DZ", "ar-EG", "ar-IQ", "ar-JO", "ar-KW", "ar-LB", "ar-LY",
                                                     "ar-MA", "ar-OM", "ar-QA", "ar-SA", "ar-SY", "ar-TN", "ar-YE", "az", "az-Cyrl-AZ", "az-Latn-AZ", "be",
                                                     "be-BY", "bg", "bg-BG", "ca", "ca-ES", "cs", "cs-CZ", "da", "da-DK", "de", "de-AT", "de-CH", "de-DE",
                                                     "de-LI", "de-LU", "dv", "dv-MV", "el", "el-GR", "en", "en-029", "en-AU", "en-BZ", "en-CA", "en-GB", "en-IE", 
                                                     "en-JM", "en-NZ", "en-PH", "en-TT", "en-US", "en-ZA", "en-ZW", "es", "es-AR", "es-BO", "es-CL", "es-CO",
                                                     "es-CR", "es-DO", "es-EC", "es-ES", "es-GT", "es-HN", "es-MX", "es-NI", "es-PA", "es-PE", "es-PR", "es-PY",
                                                     "es-SV", "es-UY", "es-VE", "et", "et-EE", "eu", "eu-ES", "fa", "fa-IR", "fi", "fi-FI", "fo", "fo-FO", "fr",
                                                     "fr-BE", "fr-CA", "fr-CH", "fr-FR", "fr-LU", "fr-MC", "gl", "gl-ES", "gu", "gu-IN", "he", "he-IL", "hi",
                                                     "hi-IN", "hr", "hr-HR", "hu", "hu-HU", "hy", "hy-AM", "id", "id-ID", "is", "is-IS", "it", "it-CH", "it-IT",
                                                     "ja", "ja-JP", "ka", "ka-GE", "kk", "kk-KZ", "kn", "kn-IN", "ko", "kok", "kok-IN", "ko-KR", "ky", "ky-KG",
                                                     "lt", "lt-LT", "lv", "lv-LV", "mk", "mk-MK", "mn", "mn-MN", "mr", "mr-IN", "ms", "ms-BN", "ms-MY", "nb-NO",
                                                     "nl", "nl-BE", "nl-NL", "nn-NO", "no", "pa", "pa-IN", "pl", "pl-PL", "pt", "pt-BR", "pt-PT", "ro", "ro-RO",
                                                     "ru", "ru-RU", "sa", "sa-IN", "sk", "sk-SK", "sl", "sl-SI", "sq", "sq-AL", "sr", "sr-Cyrl-CS", "sr-Latn-CS", 
                                                     "sv", "sv-FI", "sv-SE", "sw", "sw-KE", "syr", "syr-SY", "ta", "ta-IN", "te", "te-IN", "th", "th-TH", "tr", 
                                                     "tr-TR", "tt", "tt-RU", "uk", "uk-UA", "ur", "ur-PK", "uz", "uz-Cyrl-UZ", "uz-Latn-UZ", "vi", "vi-VN",
                                                     "zh-CHS", "zh-CHT", "zh-CN", "zh-HK", "zh-MO", "zh-SG", "zh-TW"
                                             };
        #endregion
        /// <summary>
        /// Initializes a new instance of the <see cref="TimePickerStudio"/> class.
        /// </summary>
        public TimePickerStudio()
        {
            InitializeComponent();

            Loaded += TimePickerStudio_Loaded;
        }

        /// <summary>
        /// Handles the Loaded event of the TimePickerStudio control.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">The <see cref="System.Windows.RoutedEventArgs"/> instance containing the event data.</param>
        private void TimePickerStudio_Loaded(object sender, RoutedEventArgs e)
        {
            // init
            cmbPopupSelectionMode.ItemsSource = typeof(PopupTimeSelectionMode)
                .GetMembers()
                .ToList()
                .Where(m =>
                    m.DeclaringType.Equals(typeof(PopupTimeSelectionMode)) &&
                    !m.Name.StartsWith("_", StringComparison.Ordinal) &&
                    !m.Name.EndsWith("_", StringComparison.Ordinal))
                .Select(m => m.Name)
                .ToList();

            cmbPopup.ItemsSource = new Dictionary<string, Type>()
                                       {
                                           { "ListTimePicker", typeof(ListTimePickerPopup) },
                                           { "RangeTimePicker", typeof(RangeTimePickerPopup) },
                                       };

            cmbFormat.ItemsSource = new Dictionary<string, ITimeFormat>()
                                        {
                                            { "ShortTimeFormat", new ShortTimeFormat() },
                                            { "LongTimeFormat", new LongTimeFormat() },
                                            { "Custom: hh:mm:ss", new CustomTimeFormat("hh:mm:ss") },
                                            { "Custom: hh.mm", new CustomTimeFormat("hh.mm") },
                                        };

            cmbTimeParser.ItemsSource = new Dictionary<string, TimeParser>()
                                            {
                                                { "+/- hours, try +3h", new PlusMinusHourTimeParser() },
                                                { "+/- minutes, try +3m", new PlusMinusMinuteTimeInputParser() },
                                            };

            // defaults
            cmbFormat.SelectedIndex = 0;
            cmbPopupSecondsInterval.SelectedIndex = 1;
            cmbPopupMinutesInterval.SelectedIndex = 3;
            cmbPopupSelectionMode.SelectedIndex = cmbPopupSelectionMode.Items.ToList().IndexOf(tp.PopupTimeSelectionMode.ToString());
            cmbPopup.SelectedIndex = 0;

            List<CultureInfo> cultures = new List<CultureInfo>();

            // work through long list of cultures and check if it is actually 
            // allowed in this configuration.
            foreach (string cultureName in _cultureNames)
            {
                try
                {
                    CultureInfo c = new CultureInfo(cultureName);
                    cultures.Add(c);
                }
                catch (ArgumentException)
                {
                }
            }

            cmbCultures.ItemsSource = cultures;
            // preselect current culture.
            cmbCultures.SelectedItem = cultures.FirstOrDefault(info => info.Name == tp.ActualCulture.Name);
        }

        /// <summary>
        /// Called when Minimum ComboBox is changed.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The instance containing the event data.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Hooked up in Xaml.")]
        private void MinimumChanged(object sender, RoutedPropertyChangedEventArgs<DateTime?> e)
        {
            tp.Minimum = e.NewValue;
        }

        /// <summary>
        /// Called when Maximum ComboBox is changed.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The instance containing the event data.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Hooked up in Xaml.")]
        private void MaximumChanged(object sender, RoutedPropertyChangedEventArgs<DateTime?> e)
        {
            tp.Maximum = e.NewValue;
        }

        /// <summary>
        /// Called when Popup ComboBox is changed.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="System.Windows.Controls.SelectionChangedEventArgs"/> instance containing the event data.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Hooked up in Xaml.")]
        private void PopupChanged(object sender, SelectionChangedEventArgs e)
        {
            tp.Popup = Activator.CreateInstance(((KeyValuePair<string, Type>)cmbPopup.SelectedItem).Value) as TimePickerPopup;
        }

        /// <summary>
        /// Called when PopupSecondsInterval ComboBox is changed.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="System.Windows.Controls.SelectionChangedEventArgs"/> instance containing the event data.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Hooked up in Xaml.")]
        private void PopupSecondsIntervalChanged(object sender, SelectionChangedEventArgs e)
        {
            tp.PopupSecondsInterval = (int)e.AddedItems[0];
        }

        /// <summary>
        /// Called when PopupMinutesInterval ComboBox is changed.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="System.Windows.Controls.SelectionChangedEventArgs"/> instance containing the event data.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Hooked up in Xaml.")]
        private void PopupMinutesIntervalChanged(object sender, SelectionChangedEventArgs e)
        {
            tp.PopupMinutesInterval = (int)e.AddedItems[0];
        }

        /// <summary>
        /// Called when the PopupSelectionMode ComboBox is changed.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="System.Windows.Controls.SelectionChangedEventArgs"/> instance containing the event data.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Hooked up in Xaml.")]
        private void PopupSelectionModeChanged(object sender, SelectionChangedEventArgs e)
        {
            try
            {
                tp.PopupTimeSelectionMode = (PopupTimeSelectionMode)Enum.Parse(typeof(PopupTimeSelectionMode), e.AddedItems[0].ToString(), false);
            }
            catch (ArgumentOutOfRangeException)
            {
                Dispatcher.BeginInvoke(() =>
                                       cmbPopupSelectionMode.SelectedIndex =
                                       cmbPopupSelectionMode.Items.ToList().IndexOf(e.RemovedItems[0]));
            }
        }

        /// <summary>
        /// Called when Culture ComboBox has changed.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="System.Windows.Controls.SelectionChangedEventArgs"/> 
        /// instance containing the event data.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Justification = "Wish to catch all."), SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Hooked up in Xaml.")]
        private void CultureChanged(object sender, SelectionChangedEventArgs e)
        {
            if (cmbCultures.SelectedItem != null)
            {
                tp.Culture = (CultureInfo)cmbCultures.SelectedItem;
            }
        }

        /// <summary>
        /// Called when Format ComboBox has changed.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="System.Windows.Controls.SelectionChangedEventArgs"/> 
        /// instance containing the event data.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Hooked up in Xaml.")]
        private void FormatChanged(object sender, SelectionChangedEventArgs e)
        {
            tp.Format = ((KeyValuePair<string, ITimeFormat>)cmbFormat.SelectedItem).Value;
        }

        /// <summary>
        /// Called when Timeparsers ComboBox is changed.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="System.Windows.Controls.SelectionChangedEventArgs"/> 
        /// instance containing the event data.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Hooked up in Xaml.")]
        private void TimeparserChanged(object sender, SelectionChangedEventArgs e)
        {
            tp.TimeParsers = new TimeParserCollection
                                 {
                                     ((KeyValuePair<string, TimeParser>)cmbTimeParser.SelectedItem).Value
                                 };
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\TreeMap\SalesData.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Represents product sales data.
    /// </summary>
    public class SalesData
    {
        /// <summary>
        /// Gets or sets the name of the product.
        /// </summary>
        public string Product { set; get; }

        /// <summary>
        /// Gets or sets the quantity of the product sold.
        /// </summary>
        public int Quantity { set; get; }

        /// <summary>
        /// Gets the desired tooltip content.
        /// </summary>
        public string ToolTip
        {
            get
            {
                return Product + ": " + Quantity;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\TreeMap\TreeMapSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Example showing how the TreeMap can be templated and populated with data.
    /// </summary>
    [Sample("(0)TreeMap", DifficultyLevel.Basic)]
    [Category("TreeMap")]
    public partial class TreeMapSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the MinimalSample class.
        /// </summary>
        public TreeMapSample()
        {
            InitializeComponent();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\TreeMap\SegmentedSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.ComponentModel;
using System.Collections.Generic;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample showing how to use different item definitions per branch of a tree.
    /// </summary>
    [Sample("(6) Segmented TreeMap", DifficultyLevel.Advanced)]
    [Category("TreeMap")]
    public partial class SegmentedSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the SegmentedSample class.
        /// </summary>
        public SegmentedSample()
        {
            InitializeComponent();
            Loaded += new RoutedEventHandler(SegmentedSample_Loaded);
        }

        /// <summary>
        /// Generate a tree with a given segment ID.
        /// </summary>
        /// <param name="depth">The depth of the tree.</param>
        /// <param name="maxChildren">The maximum number of children nodes allowed.</param>
        /// <param name="maxValue"> The maximum value allowed for the node's metrics.</param>
        /// <param name="segmentID">The ID to segment to which the leaves belong.</param>
        /// <param name="name">The name of the node (for making node names).</param>
        /// <param name="random">A random number generator for controlling tree generation.</param>
        /// <returns>A SegmentNode representing the root of the tree.</returns>
        private SegmentNode GenerateTree(int depth, int maxChildren, int maxValue, int segmentID, string name, Random random)
        {
            SegmentNode node = new SegmentNode();
            node.Name = name;

            if (depth <= 0)
            {
                node.Value = random.Next(1, maxValue);
                node.Value2 = random.Next(1, maxValue);
                node.Segment = segmentID;
                node.Children = new SegmentNode[0];
            }
            else
            {
                int numChildren = random.Next(2, maxChildren);
                
                node.Children = new List<SegmentNode>();
                for (int i = 0; i < numChildren; i++)
                {
                    node.Children.Add(GenerateTree(depth - 1, maxChildren, maxChildren, segmentID, name + "." + i, random));
                }
            }

            return node;
        }

        /// <summary>
        /// Loads the XML sample data and populates the TreeMap.
        /// </summary>
        /// <param name="sender">The object where the event handler is attached.</param>
        /// <param name="e">The event data.</param>
        private void SegmentedSample_Loaded(object sender, RoutedEventArgs e)
        {
            // Sample browser-specific layout change.
            SampleHelpers.ChangeSampleAlignmentToStretch(this);

            // Construct the tree.
            Random r = new Random();
            treeMapControl.ItemsSource = new List<SegmentNode>()
            {
                GenerateTree(2, 9, 10, 1, "A", r),
                GenerateTree(2, 7, 15, 2, "B", r),
                GenerateTree(2, 5, 20, 3, "C", r),
            };
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\TreeMap\RichSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.Windows.Data;

[assembly: SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Scope = "member", Target = "System.Windows.Controls.Samples.RichSample.#itemContainer")]
namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample showing the TreeMap with richer visuals and functionality.
    /// </summary>
    [Sample("(5)Rich sample", DifficultyLevel.Intermediate)]
    [Category("TreeMap")]
    public partial class RichSample : UserControl
    {
        /// <summary>
        /// Internal cache of the data source, used when refreshing the TreeMap.
        /// </summary>
        private IList<NhlNode> _dataSource;

        /// <summary>
        /// Initializes a new instance of the RichSample class.
        /// </summary>
        public RichSample()
        {
            InitializeComponent();
            Loaded += new RoutedEventHandler(RichSample_Loaded);
        }

        /// <summary>
        /// Loads the XML sample data and populates the TreeMap.
        /// </summary>
        /// <param name="sender">The object where the event handler is attached.</param>
        /// <param name="e">The event data.</param>
        private void RichSample_Loaded(object sender, RoutedEventArgs e)
        {
            // Sample browser-specific layout change
            SampleHelpers.ChangeSampleAlignmentToStretch(this);

            sizeMetric.SelectedIndex = 1;
            colorMetric.SelectedIndex = 0;

            _dataSource = DataHelper.LoadDefaultFile();

            RefreshDataSource();
        }

        /// <summary>
        /// Helper to force the TreeMap to refresh its data.
        /// </summary>
        private void RefreshDataSource()
        {
            treeMapControl.ItemsSource = null;
            treeMapControl.ItemsSource = _dataSource;
        }

        /// <summary>
        /// Changes the property used to generate sizes for rectangles.
        /// </summary>
        /// <param name="sender">The object where the event handler is attached.</param>
        /// <param name="e">The event data.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Attached as an event handler in XAML")]
        private void OnSizeMetricSelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (e.AddedItems.Count > 0)
            {
                ComboBoxItem item = e.AddedItems[0] as ComboBoxItem;
                treeMapControl.ItemDefinition.ValueBinding = new Binding(item.Tag as string);

                RefreshDataSource();
            }
        }

        /// <summary>
        /// Changes the property used to set the background color on rectangles.
        /// </summary>
        /// <param name="sender">The object where the event handler is attached.</param>
        /// <param name="e">The event data.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Attached as an event handler in XAML")]
        private void OnColorMetricSelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (e.AddedItems.Count > 0)
            {
                ComboBoxItem item = e.AddedItems[0] as ComboBoxItem;
                treeMapControl.Interpolators[0].DataRangeBinding = new Binding(item.Tag as string);

                RefreshDataSource();
            }
        }

        /// <summary>
        /// This is a workaround for the ToolTip behavior - when tooltip is a 
        /// nested element, DataContext is not inherited.
        /// It is not a TreeMap specific workaround.
        /// </summary>
        /// <param name="sender">Sending UI element - Border in our case.</param>
        /// <param name="e">Events - irrelevant in our case.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Attached as an event handler in XAML")]
        private void ItemContainer_Loaded(object sender, RoutedEventArgs e)
        {
            Border border = sender as Border;

            // see summary
            if (border != null)
            {
                ((FrameworkElement) ToolTipService.GetToolTip(border)).DataContext = border.DataContext;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\TreeMap\Data\DataHelper.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Xml.Linq;
using System.Globalization;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Holds helper methods to load or generate test data used in the TreeMap samples.
    /// </summary>
    public static class DataHelper
    {
        /// <summary>
        /// A random number generator for generating test trees.
        /// </summary>
        private static Random _random = new Random();

        /// <summary>
        /// Helper to load a tree of NhlNodes from an XML document.
        /// </summary>
        /// <param name="elements">Collection of XElement objects representing the current level of nodes to be loaded.</param>
        /// <returns>A list of NhlNode objects loaded from their XElement counterparts.</returns>
        public static IList<NhlNode> LoadNhlNodes(IEnumerable<XElement> elements)
        {
            IEnumerable<NhlNode> result = 
                from n in elements
                select new NhlNode()
                {
                    Children = LoadNhlNodes(n.Element("Children").Elements("NhlNode")),
                    GoalsAgainst = int.Parse(n.Element("GoalsAgainst").Value, CultureInfo.InvariantCulture),
                    GoalsFor = int.Parse(n.Element("GoalsFor").Value, CultureInfo.InvariantCulture),
                    Losses = int.Parse(n.Element("Losses").Value, CultureInfo.InvariantCulture),
                    Name = n.Element("Name").Value,
                    PenaltyMinutes = int.Parse(n.Element("PenaltyMinutes").Value, CultureInfo.InvariantCulture),
                    Points = int.Parse(n.Element("Points").Value, CultureInfo.InvariantCulture),
                    Rank = int.Parse(n.Element("Rank").Value, CultureInfo.InvariantCulture),
                    Wins = int.Parse(n.Element("Wins").Value, CultureInfo.InvariantCulture)
                };

            return result.ToList();
        }

        /// <summary>
        /// Loads test data from the default XML data file.
        /// </summary>
        /// <returns>A list of NhlNode objects which can be set as the ItemsSource in the TreeMap.</returns>
        public static IList<NhlNode> LoadDefaultFile()
        {
            IList<NhlNode> result = null;
            using (Stream stream = Application.GetResourceStream(new Uri("TreeMap/Data/NHLData.xml", UriKind.RelativeOrAbsolute)).Stream)
            {
                result = LoadNhlNodes(XElement.Load(stream).Elements("NhlNode"));
            }

            return result;
        }

        /// <summary>
        /// Helper to generate a random hierarchy of the specified depth, with the specified number
        /// of children at each level.
        /// </summary>
        /// <param name="depth">Number of levels in the generated tree.</param>
        /// <param name="nodesPerLevel">Number of children of each node.</param>
        /// <returns>The root node of the randomly generated tree.</returns>
        public static NhlNode CreateRandomTree(int depth, int nodesPerLevel)
        {
            NhlNode node = new NhlNode();
            node.Name = "N" + depth;

            if (depth <= 0)
            {
                node.Children = new NhlNode[0];
                node.GoalsAgainst = _random.Next(1, 50);
                node.GoalsFor = _random.Next(1, 50);
                node.Losses = _random.Next(1, 50);
                node.PenaltyMinutes = _random.Next(1, 50);
                node.Points = _random.Next(1, 50);
                node.Rank = _random.Next(1, 50);
                node.Wins = _random.Next(1, 50);
            }
            else
            {
                node.Children = (from index in Enumerable.Range(0, nodesPerLevel)
                                 select CreateRandomTree(depth - 1, nodesPerLevel)).ToArray();
            }

            return node;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\TreeMap\SegmentItemDefinitionSelector.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.Collections.ObjectModel;
using System.Windows.Controls.DataVisualization;
using System.Windows.Markup;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Dynamically chooses a TreeMapItemDefinitionSelector based on segment number in the node.
    /// </summary>
    [ContentProperty("Children")]
    public class SegmentItemDefinitionSelector : TreeMapItemDefinitionSelector
    {
        /// <summary>
        /// Gets the list of templates that this selector will choose from.
        /// </summary>
        public Collection<TreeMapItemDefinition> Children { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="SegmentItemDefinitionSelector"/> class. 
        /// </summary>
        public SegmentItemDefinitionSelector()
        {
            Children = new Collection<TreeMapItemDefinition>();
        }

        /// <summary>
        /// Returns an instance of a SegmentItemDefinitionSelector class used to specify properties for the 
        /// current item. 
        /// </summary>
        /// <param name="treeMap">Reference to the TreeMap class.</param>
        /// <param name="item">One of the nodes in the ItemsSource hierarchy.</param>
        /// <param name="level">The level of the node in the hierarchy.</param>
        /// <returns>The TreeMapItemDefinition to be used for this node. If this method returns null 
        /// the TreeMap will use the value of its ItemDefinition property.</returns>
        public override TreeMapItemDefinition SelectItemDefinition(TreeMap treeMap, object item, int level)
        {
            SegmentNode node = item as SegmentNode;

            if (Children.Count > 0 && node != null && node.Segment >= 0)
            {
                int child = node.Segment % Children.Count;
                return Children[child];
            }
            else
            {
                return null;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\TreeMap\SegmentNode.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Text;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Represents a node within a tree with value, name and belonging to a particular data segment.
    /// </summary>
    public class SegmentNode
    {
        /// <summary>
        /// Gets or sets a value representing the segment to which a node belongs.
        /// </summary>
        public int Segment { get; set; }

        /// <summary>
        /// Gets or sets the primary value associated with the node.
        /// </summary>
        public double Value { get; set; }
        
        /// <summary>
        /// Gets or sets the second value associated with the node.
        /// </summary>
        public double Value2 { get; set; }

        /// <summary>
        /// Gets or sets the name associated with the node.
        /// </summary>
        public string Name { get; set; }

        /// <summary>
        /// Gets or sets a value representing the children of this division, conference, or league. Empty for teams.
        /// </summary>
        [SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly", Justification = "Simplifies samples.")]
        public IList<SegmentNode> Children { get; set; }

        /// <summary>
        /// Gets the desired tooltip content.
        /// </summary>
        public string ToolTip
        {
            get
            {
                StringBuilder outStr = new StringBuilder();
                outStr.Append("Name: ").Append(Name);
                outStr.Append("\nValue: ").Append(Value);
                outStr.Append("\nValue2: ").Append(Value2);
                outStr.Append("\nSegment: ").Append(Segment);
                return outStr.ToString();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\TreeView\Basics\TreeViewDataBindingSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Windows;
using System.Windows.Controls;
using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample demonstrating TreeView data-binding.
    /// </summary>
    [Sample("(4)Data Binding", DifficultyLevel.Basic)]
    [Category("TreeView")]
    public partial class TreeViewDataBindingSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the TreeViewDataBindingSample class.
        /// </summary>
        public TreeViewDataBindingSample()
        {
            InitializeComponent();

            // Fill the tree with data
            TreeOfLife.ItemsSource = Taxonomy.Life;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\TreeView\Basics\TreeViewInteractionSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Diagnostics.CodeAnalysis;
using System.Windows;
using System.Windows.Controls;
using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample demonstrating TreeView user interaction.
    /// </summary>
    [Sample("(1)Interaction", DifficultyLevel.Basic)]
    [Category("TreeView")]
    public partial class TreeViewInteractionSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the TreeViewInteractionSample class.
        /// </summary>
        public TreeViewInteractionSample()
        {
            InitializeComponent();

            // Fill the tree with data
            TreeOfLife.ItemsSource = Taxonomy.Life;
        }

        /// <summary>
        /// Expand all of the TreeOfLife TreeViewItems.
        /// </summary>
        /// <param name="sender">Expand All Button.</param>
        /// <param name="e">Event arguments.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Attached as an event handler in XAML")]
        private void OnExpandAll(object sender, RoutedEventArgs e)
        {
            // Use the TreeViewExtensions.ExpandAll helper
            TreeOfLife.ExpandAll();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\TreeView\Basics\TreeViewEventsSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Windows;
using System.Windows.Controls;
using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample demonstrating TreeView and TreeViewItem events.
    /// </summary>
    [Sample("(3)Events", DifficultyLevel.Basic)]
    [Category("TreeView")]
    public partial class TreeViewEventsSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the TreeViewEventsSample class.
        /// </summary>
        public TreeViewEventsSample()
        {
            InitializeComponent();
        }

        /// <summary>
        /// Handle the TreeView.SelectedItemChanged event.
        /// </summary>
        /// <param name="sender">The TreeView.</param>
        /// <param name="e">Event arguments.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "The event handler is declared in XAML.")]
        private void OnSelectedItemChanged(object sender, RoutedPropertyChangedEventArgs<object> e)
        {
            // Note: Our sample added actual TreeViewItems to the TreeView.Items
            // collection (instead of proding other CLR or business objects
            // directly to the Items or ItemsSource properties).  That means
            // e.OldValue and e.NewValue will be TreeViewItems instead of
            // strings, business objects, etc.
            TreeViewItem oldItem = e.OldValue as TreeViewItem;
            TreeViewItem newItem = e.NewValue as TreeViewItem;
            Log(string.Format(
                CultureInfo.CurrentUICulture,
                "TreeView: SelectedItemChanged from '{0}' to '{1}'",
                oldItem != null ? oldItem.Header as string : "(null)",
                newItem != null ? newItem.Header as string : "(null)"));
        }

        /// <summary>
        /// Handle the TreeViewItem.Selected event.
        /// </summary>
        /// <param name="sender">The TreeViewItem.</param>
        /// <param name="e">Event arguments.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "The event handler is declared in XAML.")]
        private void OnSelected(object sender, RoutedEventArgs e)
        {
            TreeViewItem item = sender as TreeViewItem;
            Log(item, "Selected");
        }

        /// <summary>
        /// Handle the TreeViewItem.Unselected event.
        /// </summary>
        /// <param name="sender">The TreeViewItem.</param>
        /// <param name="e">Event arguments.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "The event handler is declared in XAML.")]
        private void OnUnselected(object sender, RoutedEventArgs e)
        {
            TreeViewItem item = sender as TreeViewItem;
            Log(item, "Unselected");
        }

        /// <summary>
        /// Handle the TreeViewItem.Expanded event.
        /// </summary>
        /// <param name="sender">The TreeViewItem.</param>
        /// <param name="e">Event arguments.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "The event handler is declared in XAML.")]
        private void OnExpanded(object sender, RoutedEventArgs e)
        {
            TreeViewItem item = sender as TreeViewItem;
            Log(item, "Expanded");
        }

        /// <summary>
        /// Handle the TreeViewItem.Collapsed event.
        /// </summary>
        /// <param name="sender">The TreeViewItem.</param>
        /// <param name="e">Event arguments.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "The event handler is declared in XAML.")]
        private void OnCollapsed(object sender, RoutedEventArgs e)
        {
            TreeViewItem item = sender as TreeViewItem;
            Log(item, "Collapsed");
        }

        /// <summary>
        /// Add an event to the list of raised events on the demo.
        /// </summary>
        /// <param name="message">The message to log.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Called by an event handler declared in XAML.")]
        private void Log(string message)
        {
            // Add a new message to the event log
            message = string.Format(CultureInfo.CurrentUICulture, "[{0:hh:mm:ss}]  {1}", DateTime.Now, message);
            EventLog.Children.Add(new TextBlock { Text = message });

            // Scroll to the bottom of the event log
            EventViewer.ScrollToVerticalOffset(EventViewer.ExtentHeight);
        }

        /// <summary>
        /// Add an event to the list of raised events on the demo.
        /// </summary>
        /// <param name="item">The item that raised the event.</param>
        /// <param name="eventName">The name of the event to log.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Called by an event handler declared in XAML.")]
        private void Log(TreeViewItem item, string eventName)
        {
            Log(string.Format(
                CultureInfo.CurrentUICulture,
                "TreeViewItem '{0}': {1}",
                item != null ? item.Header as string : "(null)",
                eventName));
        }

        /// <summary>
        /// Clear the event log.
        /// </summary>
        /// <param name="sender">The Button.</param>
        /// <param name="e">Event arguments.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "The event handler is declared in XAML.")]
        private void OnClearLog(object sender, RoutedEventArgs e)
        {
            EventLog.Children.Clear();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\TreeView\Basics\TreeViewSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Diagnostics.CodeAnalysis;
using System.Windows;
using System.Windows.Controls;
using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample page demonstrating the TreeView.
    /// </summary>
    [Sample("(0)TreeView", DifficultyLevel.Basic)]
    [Category("TreeView")]
    public partial class TreeViewSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the TreeViewSample class.
        /// </summary>
        public TreeViewSample()
        {
            InitializeComponent();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\TreeView\Basics\TreeViewStylingSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Windows;
using System.Windows.Controls;
using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample demonstrating TreeView styling.
    /// </summary>
    [Sample("(5)Styling", DifficultyLevel.Basic)]
    [Category("TreeView")]
    public partial class TreeViewStylingSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the TreeViewStylingSample class.
        /// </summary>
        public TreeViewStylingSample()
        {
            InitializeComponent();

            // Fill the tree with data
            TreeOfLife.ItemsSource = Taxonomy.Life;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\TreeView\HeaderedItemsControl\HeaderedItemsControlSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Diagnostics.CodeAnalysis;
using System.Windows;
using System.Windows.Controls;
using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample page demonstrating the HeaderedItemsControl.
    /// </summary>
    [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Headered", Justification = "Name of the control")]
    [Sample("(4)HeaderedItemsControl", DifficultyLevel.Basic)]
    [Category("TreeView")]
    public partial class HeaderedItemsControlSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the HeaderedItemsControlSample class.
        /// </summary>
        public HeaderedItemsControlSample()
        {
            InitializeComponent();

            Loaded += OnLoaded;
        }

        /// <summary>
        /// Load the demonstration.
        /// </summary>
        /// <param name="sender">Sample page.</param>
        /// <param name="e">Event arguments.</param>
        private void OnLoaded(object sender, RoutedEventArgs e)
        {
            MicrosoftExecutives.ItemsSource = Employee.Executives;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\TreeView\Basics\TreeViewSelectionSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Windows;
using System.Windows.Controls;
using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample demonstrating TreeView selection.
    /// </summary>
    [Sample("(2)Selection", DifficultyLevel.Basic)]
    [Category("TreeView")]
    public partial class TreeViewSelectionSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the TreeViewSelectionSample class.
        /// </summary>
        public TreeViewSelectionSample()
        {
            InitializeComponent();

            // Fill the tree with data
            TreeOfLife.ItemsSource = Taxonomy.Life;
        }

        /// <summary>
        /// Handle the TreeView.SelectedItemChanged event.
        /// </summary>
        /// <param name="sender">The TreeView.</param>
        /// <param name="e">Event arguments.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "The event handler is declared in XAML.")]
        private void OnSelectedItemChanged(object sender, RoutedPropertyChangedEventArgs<object> e)
        {
            TreeView view = sender as TreeView;
            SelectedItem.Content = view.SelectedItem;
            SelectedValue.Content = view.SelectedValue;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\TreeView\Scenarios\OrganizationalChartSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.Windows.Controls;
using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample demonstrating the TreeView restyled as an organizational chart.
    /// </summary>
    [Sample("Organizational Chart", DifficultyLevel.Scenario)]
    [Category("TreeView")]
    public partial class OrganizationalChartSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the OrganizationalChartSample class.
        /// </summary>
        public OrganizationalChartSample()
        {
            InitializeComponent();
            DepartmentTree.ItemsSource = Department.AllDepartments;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\UpDown\InputOverview.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.ComponentModel;
using System.Windows.Controls;
namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Overview Page is placed at the top of the Input root node in the Sample
    /// TreeView and provide an overview of Input.
    /// </summary>
    [Sample("Overview", DifficultyLevel.None)]
    [Category("Input")]
    public partial class InputOverview : UserControl
    {
        /// <summary>
        /// Class Constructor.
        /// </summary>
        public InputOverview()
        {
            InitializeComponent();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\TreeView\Scenarios\NestedHierarchicalDataTemplateSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.Windows.Controls;
using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// The NestedHierarchicalDataTemplate sample page shows how to nest
    /// HierarchicalDataTemplate templates with each HierarchicalDataTemplate
    /// having its own unique template.
    /// </summary>
    [Sample("Nested HierarchicalDataTemplate", DifficultyLevel.Scenario)]
    [Category("TreeView")]
    public partial class NestedHierarchicalDataTemplateSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the
        /// NestedHierarchicalDataTemplateSample class.
        /// </summary>
        public NestedHierarchicalDataTemplateSample()
        {
            InitializeComponent();
            ArtistTree.ItemsSource = Artist.AllArtists;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\TreeView\Scenarios\CheckedTreeViewItemSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Media;
using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample demonstrating CheckBoxes in a TreeView.
    /// </summary>    
    [Sample("(2)Using CheckBoxes", DifficultyLevel.Scenario)]  
    [Category("TreeView")]
    public partial class CheckedTreeViewItemSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the CheckedTreeViewSample class.
        /// </summary>
        public CheckedTreeViewItemSample()
        {
            InitializeComponent();
        }

        /// <summary>
        /// Handle the ItemCheckbox.Click event.
        /// </summary>
        /// <param name="sender">The CheckBox.</param>
        /// <param name="e">Event arguments.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Called from an event declared in XAML")]
        private void ItemCheckbox_Click(object sender, RoutedEventArgs e)
        {
            TreeViewItem item = GetParentTreeViewItem((DependencyObject)sender);
            if (item != null)
            {
                Feature feature = item.DataContext as Feature;
                if (feature != null)
                {
                    UpdateChildrenCheckedState(feature);
                    UpdateParentCheckedState(item);
                }
            }
        }

        /// <summary>
        /// Gets the parent TreeViewItem of the passed in dependancy object.
        /// </summary>
        /// <param name="item">Item whose parent to wish to find.</param>
        /// <returns>
        /// If item is a TreeViewItem then returns its parent TreeViewItem,
        /// else returns the TreeViewItem containing the item.
        /// </returns>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Called from an event declared in XAML")]
        private static TreeViewItem GetParentTreeViewItem(DependencyObject item)
        {
            if (item != null)
            {
                DependencyObject parent = VisualTreeHelper.GetParent(item);
                TreeViewItem parentTreeViewItem = parent as TreeViewItem;
                return (parentTreeViewItem != null) ? parentTreeViewItem : GetParentTreeViewItem(parent);
            }
            return null;
        }

        /// <summary>
        /// Sets the Feature bound to the item's parent to the combined
        /// check state of all the children.
        /// </summary>
        /// <param name="item">Item whose parent should be adjust.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Called from an event declared in XAML")]
        private static void UpdateParentCheckedState(TreeViewItem item)
        {
            TreeViewItem parent = GetParentTreeViewItem(item);
            if (parent != null)
            {
                Feature feature = parent.DataContext as Feature;
                if (feature != null)
                {
                    // Get the combined checked state of all the children,
                    // determing if they're all checked, all unchecked or a
                    // combination.
                    bool? childrenCheckedState = feature.Subcomponents.First<Feature>().ShouldInstall;
                    for (int i = 1; i < feature.Subcomponents.Count(); i++)
                    {
                        if (childrenCheckedState != feature.Subcomponents[i].ShouldInstall)
                        {
                            childrenCheckedState = null;
                            break;
                        }
                    }

                    // Set the parent to the combined state of the children.
                    feature.ShouldInstall = childrenCheckedState;

                    // Continue up the tree updating each parent with the
                    // correct combined state.
                    UpdateParentCheckedState(parent);
                }
            }
        }

        /// <summary>
        /// Sets the feature's children checked states, including subcomponents,
        /// to match the state of feature.
        /// </summary>
        /// <param name="feature">Feature whose children should be set.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Called from an event declared in XAML")]
        private static void UpdateChildrenCheckedState(Feature feature)
        {
            if (feature.ShouldInstall.HasValue)
            {
                foreach (Feature childFeature in feature.Subcomponents)
                {
                    childFeature.ShouldInstall = feature.ShouldInstall;
                    if (childFeature.Subcomponents.Count() > 0)
                    {
                        UpdateChildrenCheckedState(childFeature);
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\TreeView\Scenarios\MasterDetailSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.ComponentModel;

namespace System.Windows.Controls.Samples
{  
    /// <summary>
    /// Sample demonstrating the TreeView used in a Master/Detail scenario.
    /// </summary>
    [Sample("MasterDetail", DifficultyLevel.Scenario)]
    [Category("TreeView")]   
    public partial class MasterDetailSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the MasterDetailSample class.
        /// </summary>
        public MasterDetailSample()
        {
            InitializeComponent();
            MasterTree.ItemsSource = Taxonomy.Life;
        }

        /// <summary>
        /// Handle the TreeView.SelectedItemChanged event.
        /// </summary>
        /// <param name="sender">The TreeView.</param>
        /// <param name="e">Event arguments.</param>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "The event handler is declared in XAML.")]
        private void MasterTree_SelectedItemChanged(object sender, RoutedPropertyChangedEventArgs<object> e)
        {
            // Setting the DataContext on the panel containing all the 
            // detail controls allows setting the Master object once
            // instead of once per control.
            DetailsPanel.DataContext = e.NewValue;

            // Simulate looking up data in another data source.
            if (e.NewValue != null)
            {
                Taxonomy taxonomy = (Taxonomy)e.NewValue;                
                
                StringBuilder information = new StringBuilder();
                information.AppendFormat(CultureInfo.CurrentCulture, "The {0} {1}, represents a signifigant portion of this sample text.\n\n", taxonomy.Rank, taxonomy.Classification);

                switch (taxonomy.Subclasses.Count)
                {
                    case 0:
                        information.Append("Doesn't contain any subclasses.");
                        break;                    

                    case 1:
                        information.Append("This contains only a single subclass.");
                        break;

                    default:
                        information.AppendFormat(CultureInfo.CurrentCulture, "Contains {0} subclasses.", taxonomy.Subclasses.Count);
                        break;
                }

                LookupDetailText.Text = information.ToString();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\UpDown\NumericUpDown\NumericUpDownSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Globalization;
using System.Windows;
using System.Windows.Controls;
using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// NumericUpDown sample page.
    /// </summary>
    [Sample("NumericUpDown", DifficultyLevel.Basic)]
    [Category("NumericUpDown")]
    public partial class NumericUpDownSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the NumericUpDownSample class.
        /// </summary>
        public NumericUpDownSample()
        {
            InitializeComponent();
            Loaded += OnLoaded;
            nud.ValueChanged += (s, e) => { OutputNUD(); };
        }

        /// <summary>
        /// Load the demo page.
        /// </summary>
        /// <param name="sender">Sample page.</param>
        /// <param name="e">Event arguments.</param>
        private void OnLoaded(object sender, RoutedEventArgs e)
        {
            btnChange.Click += ChangeSettings;
        }

        /// <summary>
        /// Change ContentControl settings (Header, HeaderTemplate, Content, ContentTemplate).
        /// </summary>
        /// <param name="sender">Sender Button.</param>
        /// <param name="e">Event args.</param>
        private void ChangeSettings(object sender, RoutedEventArgs e)
        {
            nud.Minimum = ParseUtility.ReadValue(tbMininum, nud.Minimum);
            nud.Maximum = ParseUtility.ReadValue(tbMaximum, nud.Maximum);
            nud.Value = ParseUtility.ReadValue(tbValue, nud.Value);
            nud.Increment = ParseUtility.ReadValue(tbIncrement, nud.Increment);
            nud.DecimalPlaces = ParseUtility.ReadValue(tbDecimalPlaces, nud.DecimalPlaces);
            nud.IsEditable = cbIsEditable.IsChecked ?? false;
            nud.IsEnabled = cbIsEnabled.IsChecked ?? true;

            OutputNUD();
        }

        /// <summary>
        /// Display the interactive NumericUpDown control's properties.
        /// </summary>
        private void OutputNUD()
        {
            string formatString = "\n\n" +
                " Minimum:\t{0}\n Maximum:\t{1}\n Value:\t{2}\n" + 
                " Increment:\t{3}\n DecimalPlaces:\t{4}\n" +
                " IsEditable:\t{5}\n IsEnabled:\t{6}\n";
            output.Text = string.Format(
                CultureInfo.InvariantCulture, 
                formatString, 
                nud.Minimum, 
                nud.Maximum, 
                nud.Value, 
                nud.Increment, 
                nud.DecimalPlaces, 
                nud.IsEditable, 
                nud.IsEnabled);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\UpDown\Spinner\ButtonSpinner\ButtonSpinnerSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Globalization;
using System.Windows.Controls;
using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// ButtonSpinner sample page.
    /// </summary>
    [Sample("ButtonSpinner", DifficultyLevel.Basic)]
    [Category("ButtonSpinner")]
    public partial class ButtonSpinnerSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the ButtonSpinnerSample class.
        /// </summary>
        public ButtonSpinnerSample()
        {
            InitializeComponent();
            spinner1.Spin += (s, e) => { OnSpin(e); };
            spinner2.Spin += (s, e) => { OnSpin(e); };
        }

        /// <summary>
        /// Display the interactive ButtonSpinner control's properties.
        /// </summary>
        /// <param name="e">The SpinEventArgs.</param>
        private void OnSpin(SpinEventArgs e)
        {
            string s = string.Format(CultureInfo.InvariantCulture, "SpinEventArgs.Direction: \t{0}", e.Direction);
            display.Items.Add(s);
            display.SelectedIndex = display.Items.Count - 1;
            Dispatcher.BeginInvoke(() => display.ScrollIntoView(s));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\Validation\ValidationSummarySample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample page demonstrating the ValidationSummary.
    /// </summary>
    [Sample("ValidationSummary", DifficultyLevel.Intermediate)]
    [Category("Validation")]
    public partial class ValidationSummarySample : UserControl
    {
        /// <summary>
        /// Initializes an ValidationSummarySample.
        /// </summary>
        public ValidationSummarySample()
        {
            InitializeComponent();
        }

        /// <summary>
        /// Initializes the data after loading.
        /// </summary>
        /// <param name="sender">This control.</param>
        /// <param name="e">Event arguments.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Used by event defined in Xaml.")]
        private void UserControl_Loaded(object sender, RoutedEventArgs e)
        {
            contactGrid.DataContext = Contact.JohnDoe;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\Validation\LabelSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample page demonstrating the Label.
    /// </summary>
    [Sample("Label", DifficultyLevel.Intermediate)]
    [Category("Validation")]
    public partial class LabelSample : UserControl
    {
        /// <summary>
        /// Initializes a LabelSample.
        /// </summary>
        public LabelSample()
        {
            InitializeComponent();
        }

        /// <summary>
        /// Initializes the data after loading.
        /// </summary>
        /// <param name="sender">This control.</param>
        /// <param name="e">Event arguments.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Used by event defined in Xaml.")]
        private void UserControl_Loaded(object sender, RoutedEventArgs e)
        {
            contactGrid.DataContext = Contact.JohnDoe;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\Validation\DescriptionViewerSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample page demonstrating the DescriptionViewer.
    /// </summary>
    [Sample("DescriptionViewer", DifficultyLevel.Intermediate)]
    [Category("Validation")]
    public partial class DescriptionViewerSample : UserControl
    {
        /// <summary>
        /// Initializes a DescriptionViewerSample.
        /// </summary>
        public DescriptionViewerSample()
        {
            InitializeComponent();
        }

        /// <summary>
        /// Initializes the data after loading.
        /// </summary>
        /// <param name="sender">This control.</param>
        /// <param name="e">Event arguments.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Used by event defined in Xaml.")]
        private void UserControl_Loaded(object sender, RoutedEventArgs e)
        {
            contactGrid.DataContext = Contact.JohnDoe;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\Viewbox\ViewboxSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Diagnostics.CodeAnalysis;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Media;
using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample page demonstrating the Viewbox.
    /// </summary>
    [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Viewbox", Justification = "Name of the control")]
    [Sample("Viewbox", DifficultyLevel.Basic)]
    [Category("Viewbox")]
    public partial class ViewboxSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the ViewboxSample class.
        /// </summary>
        public ViewboxSample()
        {
            InitializeComponent();

            // Add this line to validate namescope works for Viewbox.
            childButton.Content = "Content";

            // Add event handlers to update the interactive demo
            InteractiveHorizontalSlider.ValueChanged += (s, e) => UpdateInteractiveDemo();
            InteractiveVerticalSlider.ValueChanged += (s, e) => UpdateInteractiveDemo();
            StretchNone.Checked += (s, e) => UpdateInteractiveDemo();
            StretchFill.Checked += (s, e) => UpdateInteractiveDemo();
            StretchUniform.Checked += (s, e) => UpdateInteractiveDemo();
            StretchUniformToFill.Checked += (s, e) => UpdateInteractiveDemo();
            StretchDirectionUpOnly.Checked += (s, e) => UpdateInteractiveDemo();
            StretchDirectionDownOnly.Checked += (s, e) => UpdateInteractiveDemo();
            StretchDirectionBoth.Checked += (s, e) => UpdateInteractiveDemo();
        }

        /// <summary>
        /// Update the interactive Viewbox demo when any property changes.
        /// </summary>
        private void UpdateInteractiveDemo()
        {
            InteractiveWidthIndicator.Width = InteractiveViewbox.Width = InteractiveContainer.ActualWidth * InteractiveHorizontalSlider.Value / 100.0;
            InteractiveHeightIndicator.Height = InteractiveViewbox.Height = InteractiveContainer.ActualHeight * InteractiveVerticalSlider.Value / 100.0;
            InteractiveViewbox.Stretch =
                (StretchFill.IsChecked == true) ? Stretch.Fill :
                (StretchUniform.IsChecked == true) ? Stretch.Uniform :
                (StretchUniformToFill.IsChecked == true) ? Stretch.UniformToFill :
                Stretch.None;
            InteractiveViewbox.StretchDirection =
                (StretchDirectionUpOnly.IsChecked == true) ? StretchDirection.UpOnly :
                (StretchDirectionDownOnly.IsChecked == true) ? StretchDirection.DownOnly :
                StretchDirection.Both;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\UpDown\UpDownBase\UpDownBaseSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Windows;
using System.Windows.Controls;
using System.ComponentModel;

[assembly: SuppressMessage("Microsoft.Usage", "CA2214:DoNotCallOverridableMethodsInConstructors", Scope = "member", Target = "System.Windows.Controls.Samples.UpDownBaseSample+SUD.#.ctor()")]
[assembly: SuppressMessage("Microsoft.Usage", "CA2214:DoNotCallOverridableMethodsInConstructors", Scope = "member", Target = "System.Windows.Controls.Samples.UpDownBaseSample+TUD.#.ctor()")]
[assembly: SuppressMessage("Microsoft.Usage", "CA2214:DoNotCallOverridableMethodsInConstructors", Scope = "member", Target = "System.Windows.Controls.Samples.UpDownBaseSample+NUD.#.ctor()")]

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// UpDownBase sample page.
    /// </summary>
    [Sample("UpDownBase", DifficultyLevel.Basic)]
    [Category("UpDownBase")]
    public partial class UpDownBaseSample : UserControl
    {
        /// <summary>
        /// Initializes a new instance of the UpDownBaseSample class.
        /// </summary>
        public UpDownBaseSample()
        {
            InitializeComponent();

            // create instance of the test non generic sub classes
            spNUD.Children.Add(new NUD());
            spTUD.Children.Add(new TUD());
            spSUD.Children.Add(new SUD());

            btnChange.Click += (s, a) => CreateUDB();
        }

        /// <summary>
        /// This function does following three things:
        /// 1. Remove existing interactive UpDownBase control if it exists;
        /// 2. Create a new instance of selected UpDownBase subclass type;
        /// 3. Add the newly created UpDownBase control to visual tree.
        /// </summary>
        private void CreateUDB()
        {
            if (udb != null)
            {
                Debug.Assert(udb == sp.Children[0], "udb should be sp's only child!");
                sp.Children.Remove(udb);
            }

            switch (lbType.SelectedIndex)
            {
                case 0:
                    udb = new NUD();
                    ConfigUDB((UpDownBase<int>)udb);
                    break;
                case 1:
                    udb = new TUD();
                    ConfigUDB((UpDownBase<DateTime>)udb);
                    break;
                case 2:
                    udb = new SUD();
                    ConfigUDB((UpDownBase<string>)udb);
                    break;
            }

            sp.Children.Add(udb);
        }

        /// <summary>
        /// Configure a UpDownBase&lt;T&gt; control.
        /// </summary>
        /// <typeparam name="T">Type parameter.</typeparam>
        /// <param name="udbt">UpDownBase&lt;T&gt; control.</param>
        private void ConfigUDB<T>(UpDownBase<T> udbt)
        {
            Debug.Assert(udbt != null, "udb should not be null!");

            udbt.Value = ParseUtility.ReadValue(tbValue, udbt.Value);
            ////udbt.IsCyclic = (bool)cbIsCyclic.IsChecked;
            udbt.IsEditable = (bool)cbIsEditable.IsChecked;
            udbt.IsEnabled = (bool)cbIsEnabled.IsChecked;
        }

        /// <summary>
        /// The interactive UpDownBase control.
        /// </summary>
        private UpDownBase udb;

        #region Non-generic test classes inheriting from UpDownBase<T>
        /// <summary>
        /// Non-generic test class inheriting from UpDownBase&lt;int&gt;.
        /// </summary>
        /// <remarks>
        /// Value is of type int, in between 0 and 10.
        /// IsCyclic decides whether Value will wrap around 0 and 10.
        /// OnIncrement and OnDecrement change Value by 1.
        /// </remarks>
        [TemplateVisualState(Name = "Normal", GroupName = "CommonStates")]
        [TemplateVisualState(Name = "MouseOver", GroupName = "CommonStates")]
        [TemplateVisualState(Name = "Pressed", GroupName = "CommonStates")]
        [TemplateVisualState(Name = "Disabled", GroupName = "CommonStates")]

        [TemplateVisualState(Name = "Focused", GroupName = "FocusStates")]
        [TemplateVisualState(Name = "Unfocused", GroupName = "FocusStates")]

        [TemplatePart(Name = "TextName", Type = typeof(TextBox))]
        [TemplatePart(Name = "SpinnerName", Type = typeof(Spinner))]
        [StyleTypedProperty(Property = "SpinnerStyle", StyleTargetType = typeof(Spinner))]
        internal class NUD : UpDownBase<int>
        {
            /// <summary>
            /// Private variable to replace IsCyclic property for now removed from UpDownBase&lt;T&gt;.
            /// </summary>
            private bool IsCyclic = true;

            /// <summary>
            /// Internal constructor.
            /// </summary>
            internal NUD()
                : base()
            {
                Value = 0;
            }

            /// <summary>
            /// Called by OnSpin when the spin direction is SpinDirection.Increase.
            /// </summary>
            protected override void OnIncrement()
            {
                Value = IsCyclic ? (Value + 1) % 10 : Math.Min(10, Value + 1);
            }

            /// <summary>
            /// Called by OnSpin when the spin direction is SpinDirection.Increase.
            /// </summary>
            protected override void OnDecrement()
            {
                Value = IsCyclic ? (Value - 1) % 10 : Math.Max(0, Value - 1);
            }

            /// <summary>
            /// Called by ApplyValue to parse user input.
            /// </summary>
            /// <param name="text">User input.</param>
            /// <returns>Value parsed from user input.</returns>
            protected override int ParseValue(string text)
            {
                return int.Parse(text, CultureInfo.CurrentCulture);
            }

            /// <summary>
            /// Called to render Value for Text template part to display.
            /// </summary>
            /// <returns>Formatted Value.</returns>
            protected override string FormatValue()
            {
                return Value.ToString(CultureInfo.CurrentCulture);
            }
        }

        /// <summary>
        /// Non-generic test class inheriting from UpDownBase&lt;DateTime&gt;.
        /// </summary>
        /// <remarks>
        /// Value is of type DateTime. 
        /// IsCyclic decides whether Value will wrap around DateTime.MinValue and DateTime.MaxValue.
        /// OnIncrement and OnDecrement change Value by one hour.
        /// </remarks>
        [TemplateVisualState(Name = "Normal", GroupName = "CommonStates")]
        [TemplateVisualState(Name = "MouseOver", GroupName = "CommonStates")]
        [TemplateVisualState(Name = "Pressed", GroupName = "CommonStates")]
        [TemplateVisualState(Name = "Disabled", GroupName = "CommonStates")]

        [TemplateVisualState(Name = "Focused", GroupName = "FocusStates")]
        [TemplateVisualState(Name = "Unfocused", GroupName = "FocusStates")]

        [TemplatePart(Name = "TextName", Type = typeof(TextBox))]
        [TemplatePart(Name = "SpinnerName", Type = typeof(Spinner))]
        [StyleTypedProperty(Property = "SpinnerStyle", StyleTargetType = typeof(Spinner))]
        internal class TUD : UpDownBase<DateTime>
        {
            /// <summary>
            /// Private variable to replace IsCyclic property for now removed from UpDownBase&lt;T&gt;.
            /// </summary>
            private bool IsCyclic = true;

            /// <summary>
            /// Internal constructor.
            /// </summary>
            internal TUD()
                : base()
            {
                Value = DateTime.Now;
            }

            /// <summary>
            /// Called by OnSpin when the spin direction is SpinDirection.Increase.
            /// </summary>
            protected override void OnIncrement()
            {
                try
                {
                    Value = Value.AddHours(1);
                }
                catch (ArgumentOutOfRangeException)
                {
                    Value = IsCyclic ? DateTime.MinValue : DateTime.MaxValue;
                }
            }

            /// <summary>
            /// Called by OnSpin when the spin direction is SpinDirection.Increase.
            /// </summary>
            protected override void OnDecrement()
            {
                try
                {
                    Value = Value.AddHours(-1);
                }
                catch (ArgumentOutOfRangeException)
                {
                    Value = IsCyclic ? DateTime.MaxValue : DateTime.MinValue;
                }
            }

            /// <summary>
            /// Called by ApplyValue to parse user input.
            /// </summary>
            /// <param name="text">User input.</param>
            /// <returns>Value parsed from user input.</returns>
            protected override DateTime ParseValue(string text)
            {
                return DateTime.Parse(text, CultureInfo.CurrentCulture);
            }

            /// <summary>
            /// Called to render Value for Text template part to display.
            /// </summary>
            /// <returns>Formatted Value.</returns>
            protected override string FormatValue()
            {
                return Value.ToShortTimeString();
            }
        }

        /// <summary>
        /// Non-generic class for UpDownBase&lt;T&gt; testing only.
        /// </summary>
        /// <remarks>
        /// Value is of type string.
        /// OnIncrement and OnDecrement change string length by 1 character.
        /// IsCyclic decides whether Value length will cycle through 0 to 10.
        /// </remarks>
        [TemplateVisualState(Name = "Normal", GroupName = "CommonStates")]
        [TemplateVisualState(Name = "MouseOver", GroupName = "CommonStates")]
        [TemplateVisualState(Name = "Pressed", GroupName = "CommonStates")]
        [TemplateVisualState(Name = "Disabled", GroupName = "CommonStates")]

        [TemplateVisualState(Name = "Focused", GroupName = "FocusStates")]
        [TemplateVisualState(Name = "Unfocused", GroupName = "FocusStates")]

        [TemplatePart(Name = "TextName", Type = typeof(TextBox))]
        [TemplatePart(Name = "SpinnerName", Type = typeof(Spinner))]
        [StyleTypedProperty(Property = "SpinnerStyle", StyleTargetType = typeof(Spinner))]
        internal class SUD : UpDownBase<string>
        {
            /// <summary>
            /// Private variable to replace IsCyclic property for now removed from UpDownBase&lt;T&gt;.
            /// </summary>
            private bool IsCyclic = true;

            /// <summary>
            /// Internal constructor.
            /// </summary>
            internal SUD()
                : base()
            {
                Value = "0";
            }

            /// <summary>
            /// Called by OnSpin when the spin direction is SpinDirection.Increase.
            /// </summary>
            protected override void OnIncrement()
            {
                string value = string.IsNullOrEmpty(Value) ? "0" : Value;
                if (value.Length >= 10)
                {
                    if (IsCyclic)
                    {
                        value = "0";
                    }
                }
                else
                {
                    value = value + value.Length.ToString(CultureInfo.CurrentCulture);
                }
                Value = value;
            }

            /// <summary>
            /// Called by OnSpin when the spin direction is SpinDirection.Increase.
            /// </summary>
            protected override void OnDecrement()
            {
                string value = string.IsNullOrEmpty(Value) ? "0" : Value;
                if (value.Length <= 1)
                {
                    if (IsCyclic)
                    {
                        value = "0123456789";
                    }
                }
                else
                {
                    value = value.Substring(0, value.Length - 1);
                }
                Value = value;
            }

            /// <summary>
            /// Called by ApplyValue to parse user input.
            /// </summary>
            /// <param name="text">User input.</param>
            /// <returns>Value parsed from user input.</returns>
            protected override string ParseValue(string text)
            {
                if (string.IsNullOrEmpty(text))
                {
                    text = "0";
                }

                if (text.Length > 10)
                {
                    text = text.Substring(0, 10);
                }

                return text;
            }

            /// <summary>
            /// Called to render Value for Text template part to display.
            /// </summary>
            /// <returns>Formatted Value.</returns>
            protected override string FormatValue()
            {
                return string.IsNullOrEmpty(Value) ? "0" : Value;
            }
        }
        #endregion 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples\WrapPanel\WrapPanelSample.xaml.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Linq;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Media;
using System.Windows.Shapes;
using System.ComponentModel;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Sample page demonstrating the WrapPanel.
    /// </summary>
    [Sample("WrapPanel", DifficultyLevel.Basic)]
    [Category("WrapPanel")]
    public partial class WrapPanelSample : UserControl
    {
        /// <summary>
        /// Gets or sets a value indicating whether the demonstration has
        /// already been loaded.
        /// </summary>
        private bool IsLoaded { get; set; }

        /// <summary>
        /// Initializes a new instance of the WrapPanelSample class.
        /// </summary>
        public WrapPanelSample()
        {
            InitializeComponent();

            Loaded += OnLoad;

            chkHorizontal.Checked += OnCheckChanged;
            chkHorizontal.Unchecked += OnCheckChanged;
        }

        /// <summary>
        /// Load the demonstration.
        /// </summary>
        /// <param name="sender">Sample page.</param>
        /// <param name="e">Event arguments.</param>
        private void OnLoad(object sender, RoutedEventArgs e)
        {
            // Don't repopulate if the page has already been loaded.
            if (IsLoaded)
            {
                return;
            }
            IsLoaded = true;

            // Generate the text to wrap
            string lorem = "Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Suspendisse sed tellus non sapien laoreet accumsan. Phasellus rhoncus imperdiet pede. Morbi semper ipsum at leo. Nullam elit mi, dignissim et, vestibulum ut, laoreet quis, velit. Nulla aliquet risus sed arcu. Nunc vitae tortor in lectus tristique iaculis. Morbi elit. Quisque euismod mollis orci. Nullam cursus interdum eros. Curabitur tristique mi non nulla. Curabitur non nisi. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Nam aliquet, velit eu pretium placerat, massa lorem sollicitudin dolor, non ultricies nisi lorem bibendum enim. Pellentesque mollis egestas ipsum. Donec odio quam, tempus ut, iaculis molestie, viverra vitae, sapien.";
            for (int i = 0; i < 4; i++)
            {
                foreach (string word in lorem.Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries))
                {
                    ManualTextWrapping.Children.Add(new TextBlock
                    {
                        Text = word,
                        Margin = new Thickness(3)
                    });
                }
            }

            // Generate the color swatch
            int granularity = 50;
            for (int r = 0; r < 255; r += granularity)
            {
                for (int g = 0; g < 255; g += granularity)
                {
                    for (int b = 0; b < 255; b += granularity)
                    {
                        Swatch.Items.Add(new Rectangle
                        {
                            Width = 20,
                            Height = 20,
                            Margin = new Thickness(5),
                            Stroke = new SolidColorBrush(Colors.Black),
                            StrokeThickness = 1,
                            Fill = new SolidColorBrush(Color.FromArgb(255, (byte) r, (byte) g, (byte) b))
                        });
                    }
                }
            }

            // Set the thumbnails
            Thumbnails.ItemsSource = Photograph.GetPhotographs().OrderBy(p => p.Name);
        }

        /// <summary>
        /// Update the manual text layout sample to match the CheckBox.
        /// </summary>
        /// <param name="sender">The CheckBox that was changed.</param>
        /// <param name="e">Event arguments.</param>
        private void OnCheckChanged(object sender, RoutedEventArgs e)
        {
            if (chkHorizontal.IsChecked == true)
            {
                ManualTextWrapping.Height = double.NaN;
                ManualTextWrapping.Orientation = Orientation.Horizontal;
            }
            else
            {
                ManualTextWrapping.Height = 600;
                ManualTextWrapping.Orientation = Orientation.Vertical;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples.Common\GlobalSuppressions.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.Diagnostics.CodeAnalysis;

[assembly: SuppressMessage("Microsoft.Design", "CA1014:MarkAssembliesWithClsCompliant", Justification = "Silverlight requires the use of types that are not CLS compliant.")]
[assembly: SuppressMessage("General", "SWC1001:XmlDocumentationCommentShouldBeSpelledCorrectly", MessageId = "Somasegar")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples.Common\BusinessObjects\Airport.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Windows.Controls;

[assembly: SuppressMessage("General", "SWC1001:XmlDocumentationCommentShouldBeSpelledCorrectly", MessageId = "Farecast", Justification = "Farecast is a Microsoft web site.")]

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// An Airport class.
    /// </summary>
    public class Airport
    {
        /// <summary>
        /// Gets or sets the friendly airport name.
        /// </summary>
        public string Name { get; set; }

        /// <summary>
        /// Gets a sometimes shorter representation of the Name property.
        /// </summary>
        public string LimitedName
        {
            get
            {
                if (Name == null || Name.Length < 30)
                {
                    return Name;
                }

                return Name.Substring(0, 30) + "...";
            }
        }

        /// <summary>
        /// Gets or sets the airport city or cities name.
        /// </summary>
        public string City { get; set; }
        
        /// <summary>
        /// Gets or sets the state, region, or territory name.
        /// </summary>
        public string State { get; set; }
        
        /// <summary>
        /// Gets or sets the Federal Aviation Administration code.
        /// </summary>
        public string CodeFaa { get; set; }
        
        /// <summary>
        /// Gets or sets the International Air Transport Association code.
        /// </summary>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Iata", Justification = "This is a recognized abbreviation for the code.")]
        public string CodeIata { get; set; }
        
        /// <summary>
        /// Gets or sets the four-digit International Civil Aviation 
        /// Organization code.
        /// </summary>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Icao", Justification = "This is a recognized abbreviation for the code.")]
        public string CodeIcao { get; set; }

        /// <summary>
        /// Initializes a new Airport class instance.
        /// </summary>
        public Airport()
        {
        }

        /// <summary>
        /// Initializes a new Airport class instance. This is a data-entry 
        /// friendly constructor.
        /// </summary>
        /// <param name="city">The city or cities name.</param>
        /// <param name="state">The state or region.</param>
        /// <param name="faa">The Federal Aviation Administration code.</param>
        /// <param name="iata">The International Air Transport Association code.</param>
        /// <param name="icao">The four-digit International Civil Aviation
        /// Organization code.</param>
        /// <param name="airport">The friendly airport name.</param>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "icao", Justification = "This is a recognized abbreviation for the code.")]
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "iata", Justification = "This is a recognized abbreviation for the code.")]
        public Airport(string city, string state, string faa, string iata, string icao, string airport)
        {
            City = city;
            State = state;
            CodeFaa = faa;
            CodeIata = iata;
            CodeIcao = icao;
            Name = airport;
        }

        /// <summary>
        /// The code and name together.
        /// </summary>
        /// <returns>Returns a string.</returns>
        public override string ToString()
        {
            return CodeFaa;
        }

        /// <summary>
        /// Gets a collection of sample airports.
        /// </summary>
        public static ObjectCollection SampleAirports
        {
            get
            {
                ObjectCollection airports = new ObjectCollection();
                airports.Add(new Airport("Phoenix", "Arizona", "PHX", "PHX", "KPHX", "Phoenix Sky Harbor International Airport"));
                airports.Add(new Airport("Los Angeles", "California", "LAX", "LAX", "KLAX", "Los Angeles International Airport"));
                airports.Add(new Airport("San Diego", "California", "SAN", "SAN", "KSAN", "San Diego International Airport"));
                airports.Add(new Airport("San Francisco", "California", "SFO", "SFO", "KSFO", "San Francisco International Airport"));
                airports.Add(new Airport("Denver", "Colorado", "DEN", "DEN", "KDEN", "Denver International Airport"));
                airports.Add(new Airport("Fort Lauderdale", "Florida", "FLL", "FLL", "KFLL", "Fort Lauderdale-Hollywood International Airport"));
                airports.Add(new Airport("Miami", "Florida", "MIA", "MIA", "KMIA", "Miami International Airport"));
                airports.Add(new Airport("Orlando", "Florida", "MCO", "MCO", "KMCO", "Orlando International Airport"));
                airports.Add(new Airport("Tampa", "Florida", "TPA", "TPA", "KTPA", "Tampa International Airport"));
                airports.Add(new Airport("Atlanta", "Georgia", "ATL", "ATL", "KATL", "Hartsfield-Jackson Atlanta International Airport"));
                airports.Add(new Airport("Honolulu", "Hawaii", "HNL", "HNL", "PHNL", "Honolulu International Airport / Hickam AFB"));
                airports.Add(new Airport("Boise", "Idaho", "BOI", "BOI", "KBOI", "Boise Air Terminal (Gowen Field)"));
                airports.Add(new Airport("Chicago", "Illinois", "ORD", "ORD", "KORD", "Chicago O'Hare International Airport"));
                airports.Add(new Airport("Chicago", "Illinois", "MDW", "MDW", "KMDW", "Chicago Midway International Airport"));
                airports.Add(new Airport("Indianapolis", "Indiana", "IND", "IND", "KIND", "Indianapolis International Airport"));
                airports.Add(new Airport("Covington", "Kentucky", "CVG", "CVG", "KCVG", "Cincinnati/Northern Kentucky International Airport"));
                airports.Add(new Airport("Louisville", "Kentucky", "SDF", "SDF", "KSDF", "Louisville International Airport (Standiford Field)"));
                airports.Add(new Airport("New Orleans", "Louisiana", "MSY", "MSY", "KMSY", "Louis Armstrong New Orleans International Airport"));
                airports.Add(new Airport("Baltimore / Glen Burnie", "Maryland", "BWI", "BWI", "KBWI", "Baltimore-Washington International Thurgood Marshall Airport"));
                airports.Add(new Airport("Boston", "Massachusetts", "BOS", "BOS", "KBOS", "Gen. Edward Lawrence Logan International Airport"));
                airports.Add(new Airport("Detroit", "Michigan", "DTW", "DTW", "KDTW", "Detroit Metropolitan Wayne County Airport"));
                airports.Add(new Airport("Grand Rapids", "Michigan", "GRR", "GRR", "KGRR", "Gerald R. Ford International Airport"));
                airports.Add(new Airport("Minneapolis", "Minnesota", "MSP", "MSP", "KMSP", "Minneapolis-St. Paul International Airport (Wold-Chamberlain Field)"));
                airports.Add(new Airport("Kansas City", "Missouri", "MCI", "MCI", "KMCI", "Kansas City International Airport"));
                airports.Add(new Airport("St. Louis", "Missouri", "STL", "STL", "KSTL", "Lambert-St. Louis International Airport"));
                airports.Add(new Airport("Omaha", "Nebraska", "OMA", "OMA", "KOMA", "Eppley Airfield"));
                airports.Add(new Airport("Las Vegas", "Nevada", "LAS", "LAS", "KLAS", "McCarran International Airport"));
                airports.Add(new Airport("Reno", "Nevada", "RNO", "RNO", "KRNO", "Reno-Tahoe International Airport"));
                airports.Add(new Airport("Manchester", "New Hampshire", "MHT", "MHT", "KMHT", "Manchester-Boston Regional Airport"));
                airports.Add(new Airport("Newark", "New Jersey", "EWR", "EWR", "KEWR", "Newark Liberty International Airport"));
                airports.Add(new Airport("Albuquerque", "New Mexico", "ABQ", "ABQ", "KABQ", "Albuquerque International Sunport"));
                airports.Add(new Airport("Albany", "New York", "ALB", "ALB", "KALB", "Albany International Airport"));
                airports.Add(new Airport("Buffalo", "New York", "BUF", "BUF", "KBUF", "Buffalo Niagara International Airport"));
                airports.Add(new Airport("Islip", "New York", "ISP", "ISP", "KISP", "Long Island MacArthur Airport"));
                airports.Add(new Airport("New York", "New York", "JFK", "JFK", "KJFK", "John F. Kennedy International Airport"));
                airports.Add(new Airport("New York", "New York", "LGA", "LGA", "KLGA", "LaGuardia Airport"));
                airports.Add(new Airport("Rochester", "New York", "ROC", "ROC", "KROC", "Greater Rochester International Airport"));
                airports.Add(new Airport("Syracuse", "New York", "SYR", "SYR", "KSYR", "Syracuse Hancock International Airport"));
                airports.Add(new Airport("Charlotte", "North Carolina", "CLT", "CLT", "KCLT", "Charlotte/Douglas International Airport"));
                airports.Add(new Airport("Greensboro", "North Carolina", "GSO", "GSO", "KGSO", "Piedmont Triad International Airport"));
                airports.Add(new Airport("Raleigh", "North Carolina", "RDU", "RDU", "KRDU", "Raleigh-Durham International Airport"));
                airports.Add(new Airport("Cleveland", "Ohio", "CLE", "CLE", "KCLE", "Cleveland-Hopkins International Airport"));
                airports.Add(new Airport("Columbus", "Ohio", "CMH", "CMH", "KCMH", "Port Columbus International Airport"));
                airports.Add(new Airport("Dayton", "Ohio", "DAY", "DAY", "KDAY", "James M. Cox Dayton International Airport"));
                airports.Add(new Airport("Oklahoma City", "Oklahoma", "OKC", "OKC", "KOKC", "Will Rogers World Airport"));
                airports.Add(new Airport("Tulsa", "Oklahoma", "TUL", "TUL", "KTUL", "Tulsa International Airport"));
                airports.Add(new Airport("Portland", "Oregon", "PDX", "PDX", "KPDX", "Portland International Airport"));
                airports.Add(new Airport("Philadelphia", "Pennsylvania", "PHL", "PHL", "KPHL", "Philadelphia International Airport"));
                airports.Add(new Airport("Pittsburgh", "Pennsylvania", "PIT", "PIT", "KPIT", "Pittsburgh International Airport"));
                airports.Add(new Airport("Providence", "Rhode Island", "PVD", "PVD", "KPVD", "Theodore Francis Green State Airport"));
                airports.Add(new Airport("Memphis", "Tennessee", "MEM", "MEM", "KMEM", "Memphis International Airport"));
                airports.Add(new Airport("Nashville", "Tennessee", "BNA", "BNA", "KBNA", "Nashville International Airport (Berry Field)"));
                airports.Add(new Airport("Austin", "Texas", "AUS", "AUS", "KAUS", "Austin-Bergstrom International Airport"));
                airports.Add(new Airport("Dallas", "Texas", "DAL", "DAL", "KDAL", "Dallas Love Field"));
                airports.Add(new Airport("Dallas-Fort Worth", "Texas", "DFW", "DFW", "KDFW", "Dallas-Fort Worth International Airport"));
                airports.Add(new Airport("El Paso", "Texas", "ELP", "ELP", "KELP", "El Paso International Airport"));
                airports.Add(new Airport("Houston", "Texas", "IAH", "IAH", "KIAH", "George Bush Intercontinental Airport"));
                airports.Add(new Airport("Houston", "Texas", "HOU", "HOU", "KHOU", "William P. Hobby Airport"));
                airports.Add(new Airport("San Antonio", "Texas", "SAT", "SAT", "KSAT", "San Antonio International Airport"));
                airports.Add(new Airport("Salt Lake City", "Utah", "SLC", "SLC", "KSLC", "Salt Lake City International Airport"));
                airports.Add(new Airport("Norfolk", "Virginia", "ORF", "ORF", "KORF", "Norfolk International Airport"));
                airports.Add(new Airport("Richmond", "Virginia", "RIC", "RIC", "KRIC", "Richmond International Airport"));
                airports.Add(new Airport("Washington, D.C. (Arlington County)", "Virginia", "DCA", "DCA", "KDCA", "Ronald Reagan Washington National Airport"));
                airports.Add(new Airport("Washington, D.C. (Chantilly / Dulles)", "Virginia", "IAD", "IAD", "KIAD", "Washington Dulles International Airport"));
                airports.Add(new Airport("Seattle / Tacoma (SeaTac)", "Washington", "SEA", "SEA", "KSEA", "Seattle-Tacoma International Airport"));
                airports.Add(new Airport("Spokane", "Washington", "GEG", "GEG", "KGEG", "Spokane International Airport (Geiger Field)"));
                airports.Add(new Airport("Milwaukee", "Wisconsin", "MKE", "MKE", "KMKE", "General Mitchell International Airport"));
                airports.Add(new Airport("San Juan", "Puerto Rico", "SJU", "SJU", "TJSJ", "Luis Muñoz Marín International Airport"));
                return airports;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples.Common\BusinessObjects\Customer.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Windows.Media;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Indicates the status of a customer's payment or complaint.
    /// </summary>
    public enum Status
    {
        /// <summary>
        /// Indicates that the item is closed.
        /// </summary>
        Closed,

        /// <summary>
        /// Indicates that the item is active.
        /// </summary>
        Active,

        /// <summary>
        /// Indicates that the item is resolved.
        /// </summary>
        Resolved
    }

    /// <summary>
    /// Represents a customer.
    /// </summary>
    public class Customer : INotifyPropertyChanged, IEditableObject
    {
        /// <summary>
        /// Random number generator.
        /// </summary>
        private static Random random = new Random(DateTime.Now.Millisecond);

        /// <summary>
        /// Holds the data backing a customer.
        /// </summary>
        private struct CustomerData
        {
            /// <summary>
            /// The customer's first name.
            /// </summary>
            internal string FirstName;

            /// <summary>
            /// The customer's last name.
            /// </summary>
            internal string LastName;

            /// <summary>
            /// The customer's preferred color.
            /// </summary>
            internal Color PreferredColor;

            /// <summary>
            /// The customer's rating.
            /// </summary>
            internal int Rating;

            /// <summary>
            /// The customer's renewal date.
            /// </summary>
            internal DateTime RenewalDate;

            /// <summary>
            /// The customer's full address.
            /// </summary>
            internal string FullAddress;

            /// <summary>
            /// The customer's yearly fees.
            /// </summary>
            internal decimal YearlyFees;

            /// <summary>
            /// The customer's registration status.
            /// </summary>
            internal bool IsRegistered;

            /// <summary>
            /// The customer entry's validity.
            /// </summary>
            internal bool? IsValid;

            /// <summary>
            /// The customer's age.
            /// </summary>
            internal int? Age;

            /// <summary>
            /// The customer's payment status.
            /// </summary>
            internal Status Payment;

            /// <summary>
            /// The customer's complaint status.
            /// </summary>
            internal Status? Complaint;
        }

        #region Data

        /// <summary>
        /// Stores the data for the customer.
        /// </summary>
        private CustomerData _data;

        /// <summary>
        /// Stores a backup of the customer's data during edits.
        /// </summary>
        private CustomerData _backupData;

        /// <summary>
        /// Indicates whether the customer is being edited.
        /// </summary>
        private bool _editing;

        /// <summary>
        /// Indicates whether property change notifications should be enabled.
        /// </summary>
        private bool _delayPropertyChangeNotifications;

        #endregion Data

        /// <summary>
        /// Initializes a customer object.
        /// </summary>
        public Customer()
        {
            this._delayPropertyChangeNotifications = true;
            this._data = new CustomerData();
            this._data.RenewalDate = DateTime.Today;
        }

        /// <summary>
        /// Initializes a customer object.
        /// </summary>
        /// <param name="firstName">Customer's first name.</param>
        /// <param name="lastName">Customer's last name.</param>
        /// <param name="preferredColor">Customer's preferred color.</param>
        /// <param name="rating">Customer's rating.</param>
        /// <param name="fullAddress">Customer's full address.</param>
        /// <param name="yearlyFees">Customer's yearly fees.</param>
        /// <param name="isRegistered">Customer's registration status.</param>
        /// <param name="isValid">Customer's validity.</param>
        /// <param name="age">Customer's age.</param>
        /// <param name="payment">Customer's payment status.</param>
        /// <param name="complaint">Customer's complaint status.</param>
        public Customer(
            string firstName,
            string lastName,
            Color preferredColor,
            int rating,
            string fullAddress,
            decimal yearlyFees,
            bool isRegistered,
            bool? isValid,
            int? age,
            Status payment,
            Status? complaint)
            : this()
        {
            this._data.FirstName = firstName;
            this._data.LastName = lastName;
            this._data.PreferredColor = preferredColor;
            this._data.Rating = rating;
            this._data.FullAddress = fullAddress;
            this._data.YearlyFees = yearlyFees;
            this._data.IsRegistered = isRegistered;
            this._data.IsValid = isValid;
            this._data.Age = age;
            this._data.Payment = payment;
            this._data.Complaint = complaint;
        }

        #region INotifyPropertyChanged Members

        /// <summary>
        /// Raised when a property on the customer changes.
        /// </summary>
        public event PropertyChangedEventHandler PropertyChanged;

        #endregion INotifyPropertyChanged Members

        #region IEditableObject Members

        /// <summary>
        /// Indicates that the contact will undergo a cancellable edit.
        /// </summary>
        public void BeginEdit()
        {
            if (!this._editing)
            {
                this._backupData = this._data;
                this._editing = true;
            }
        }

        /// <summary>
        /// Indicates that the edit was cancelled and that the old state should be restored.
        /// </summary>
        public void CancelEdit()
        {
            if (this._editing)
            {
                if (!this._delayPropertyChangeNotifications)
                {
                    if (string.Compare(this._data.FirstName, this._backupData.FirstName, StringComparison.CurrentCulture) != 0)
                    {
                        RaisePropertyChanged("FirstName");
                    }
                    if (string.Compare(this._data.LastName, this._backupData.LastName, StringComparison.CurrentCulture) != 0)
                    {
                        RaisePropertyChanged("LastName");
                    }
                    if (this._data.Rating != this._backupData.Rating)
                    {
                        RaisePropertyChanged("Rating");
                    }
                    if (this._data.RenewalDate != this._backupData.RenewalDate)
                    {
                        RaisePropertyChanged("RenewalDate");
                    }
                    if (string.Compare(this._data.FullAddress, this._backupData.FullAddress, StringComparison.CurrentCulture) != 0)
                    {
                        RaisePropertyChanged("FullAddress");
                    }
                    if (this._data.YearlyFees != this._backupData.YearlyFees)
                    {
                        RaisePropertyChanged("YearlyFees");
                    }
                    if (this._data.IsRegistered != this._backupData.IsRegistered)
                    {
                        RaisePropertyChanged("IsRegistered");
                    }
                    if (this._data.IsValid != this._backupData.IsValid)
                    {
                        RaisePropertyChanged("IsValid");
                    }
                    if (this._data.Payment != this._backupData.Payment)
                    {
                        RaisePropertyChanged("Payment");
                    }
                    if (this._data.Complaint != this._backupData.Complaint)
                    {
                        RaisePropertyChanged("Complaint");
                    }
                }
                this._data = this._backupData;
                this._editing = false;
            }
        }

        /// <summary>
        /// Indicates that the edit completed and that changed fields should be committed.
        /// </summary>
        public void EndEdit()
        {
            if (this._editing)
            {
                if (this._delayPropertyChangeNotifications)
                {
                    if (string.Compare(this._data.FirstName, this._backupData.FirstName, StringComparison.CurrentCulture) != 0)
                    {
                        RaisePropertyChanged("FirstName");
                    }
                    if (string.Compare(this._data.LastName, this._backupData.LastName, StringComparison.CurrentCulture) != 0)
                    {
                        RaisePropertyChanged("LastName");
                    }
                    if (this._data.Rating != this._backupData.Rating)
                    {
                        RaisePropertyChanged("Rating");
                    }
                    if (this._data.RenewalDate != this._backupData.RenewalDate)
                    {
                        RaisePropertyChanged("RenewalDate");
                    }
                    if (string.Compare(this._data.FullAddress, this._backupData.FullAddress, StringComparison.CurrentCulture) != 0)
                    {
                        RaisePropertyChanged("FullAddress");
                    }
                    if (this._data.YearlyFees != this._backupData.YearlyFees)
                    {
                        RaisePropertyChanged("YearlyFees");
                    }
                    if (this._data.IsRegistered != this._backupData.IsRegistered)
                    {
                        RaisePropertyChanged("IsRegistered");
                    }
                    if (this._data.IsValid != this._backupData.IsValid)
                    {
                        RaisePropertyChanged("IsValid");
                    }
                    if (this._data.Payment != this._backupData.Payment)
                    {
                        RaisePropertyChanged("Payment");
                    }
                    if (this._data.Complaint != this._backupData.Complaint)
                    {
                        RaisePropertyChanged("Complaint");
                    }
                }
                this._backupData = new CustomerData();
                this._editing = false;
            }
        }

        #endregion IEditableObject Members

        #region Public Properties

        /// <summary>
        /// Gets or sets the customer's Age.
        /// </summary>
        public int? Age
        {
            get
            {
                return this._data.Age;
            }
            set
            {
                if (this._data.Age != value)
                {
                    this._data.Age = value;
                    if (!this._delayPropertyChangeNotifications || !this._editing)
                    {
                        RaisePropertyChanged("Age");
                    }
                }
            }
        }

        /// <summary>
        /// Gets or sets the customer's complaint status.
        /// </summary>
        public Status? Complaint
        {
            get
            {
                return this._data.Complaint;
            }
            set
            {
                if (this._data.Complaint != value)
                {
                    this._data.Complaint = value;
                    if (!this._delayPropertyChangeNotifications || !this._editing)
                    {
                        RaisePropertyChanged("Complaint");
                    }
                }
            }
        }

        /// <summary>
        /// Gets or sets the customer's first name.
        /// </summary>
        public string FirstName
        {
            get
            {
                return this._data.FirstName;
            }
            set
            {
                if (this._data.FirstName != value)
                {
                    this._data.FirstName = value;
                    if (!this._delayPropertyChangeNotifications || !this._editing)
                    {
                        RaisePropertyChanged("FirstName");
                    }
                }
            }
        }

        /// <summary>
        /// Gets or sets the customer's full address.
        /// </summary>
        public string FullAddress
        {
            get
            {
                return this._data.FullAddress;
            }
            set
            {
                if (this._data.FullAddress != value)
                {
                    this._data.FullAddress = value;
                    if (!this._delayPropertyChangeNotifications || !this._editing)
                    {
                        RaisePropertyChanged("FullAddress");
                    }
                }
            }
        }

        /// <summary>
        /// Gets or sets a value indicating whether the customer is registered.
        /// </summary>
        public bool IsRegistered
        {
            get
            {
                return this._data.IsRegistered;
            }
            set
            {
                if (this._data.IsRegistered != value)
                {
                    this._data.IsRegistered = value;
                    if (!this._delayPropertyChangeNotifications || !this._editing)
                    {
                        RaisePropertyChanged("IsRegistered");
                    }
                }
            }
        }

        /// <summary>
        /// Gets or sets a value indicating whether the customer is valid.
        /// </summary>
        public bool? IsValid
        {
            get
            {
                return this._data.IsValid;
            }
            set
            {
                if (this._data.IsValid != value)
                {
                    this._data.IsValid = value;
                    if (!this._delayPropertyChangeNotifications || !this._editing)
                    {
                        RaisePropertyChanged("IsValid");
                    }
                }
            }
        }

        /// <summary>
        /// Gets or sets the customer's last name.
        /// </summary>
        public string LastName
        {
            get
            {
                return this._data.LastName;
            }
            set
            {
                if (this._data.LastName != value)
                {
                    this._data.LastName = value;
                    if (!this._delayPropertyChangeNotifications || !this._editing)
                    {
                        RaisePropertyChanged("LastName");
                    }
                }
            }
        }

        /// <summary>
        /// Gets or sets the customer's payment status.
        /// </summary>
        public Status Payment
        {
            get
            {
                return this._data.Payment;
            }
            set
            {
                if (this._data.Payment != value)
                {
                    this._data.Payment = value;
                    if (!this._delayPropertyChangeNotifications || !this._editing)
                    {
                        RaisePropertyChanged("Payment");
                    }
                }
            }
        }

        /// <summary>
        /// Gets the customer's preferred color.
        /// </summary>
        public Color PreferredColor
        {
            get
            {
                return this._data.PreferredColor;
            }
        }

        /// <summary>
        /// Gets a random customer.
        /// </summary>
        public static Customer FakeCustomer
        {
            get
            {
                return CreateFakeCustomer(-1);
            }
        }

        /// <summary>
        /// Gets or sets the customer's rating.
        /// </summary>
        public int Rating
        {
            get
            {
                return this._data.Rating;
            }
            set
            {
                if (this._data.Rating != value)
                {
                    this._data.Rating = value;
                    if (!this._delayPropertyChangeNotifications || !this._editing)
                    {
                        RaisePropertyChanged("Rating");
                    }
                }
            }
        }

        /// <summary>
        /// Gets or sets the customer's renewal date.
        /// </summary>
        public DateTime RenewalDate
        {
            get
            {
                return this._data.RenewalDate;
            }
            set
            {
                if (this._data.RenewalDate != value)
                {
                    this._data.RenewalDate = value;
                    if (!this._delayPropertyChangeNotifications || !this._editing)
                    {
                        RaisePropertyChanged("RenewalDate");
                    }
                }
            }
        }

        /// <summary>
        /// Gets or sets the customer's yearly fees.
        /// </summary>
        public decimal YearlyFees
        {
            get
            {
                return this._data.YearlyFees;
            }
            set
            {
                if (this._data.YearlyFees != value)
                {
                    this._data.YearlyFees = value;
                    if (!this._delayPropertyChangeNotifications || !this._editing)
                    {
                        RaisePropertyChanged("YearlyFees");
                    }
                }
            }
        }

        /// <summary>
        /// Gets a collection of the characters in the customer's first name.
        /// </summary>
        public Collection<char> Chars
        {
            get
            {
                return new Collection<char>(this.FirstName.ToCharArray().ToList());
            }
        }
        #endregion Public Properties

        #region Public Methods

        /// <summary>
        /// Gets a random customer.
        /// </summary>
        /// <param name="index">The index of the random customer.</param>
        /// <returns>A customer based upon the index.</returns>
        public static Customer GetRandomCustomer(int index)
        {
            return CreateFakeCustomer(index);
        }

        #endregion Public Methods

        #region Internal Methods

        /// <summary>
        /// Gets a random status.
        /// </summary>
        /// <param name="random">Random number generator.</param>
        /// <returns>A random status.</returns>
        internal static Status GetFakeStatus(Random random)
        {
            switch (random.Next(0, 3000) % 3)
            {
                case 0:
                    return Status.Active;
                case 1:
                    return Status.Closed;
                default:
                    return Status.Resolved;
            }
        }

        /// <summary>
        /// Gets a random string of characters.
        /// </summary>
        /// <param name="random">Random number generator.</param>
        /// <returns>A string of randomly selected characters.</returns>
        internal static string GetFakeString(Random random)
        {
            StringBuilder stringBuilder = new StringBuilder();
            for (int i = 0; i < 8; i++)
            {
                stringBuilder.Append((char)random.Next(65, 90));
            }
            return stringBuilder.ToString();
        }

        /// <summary>
        /// Gets a random bool value.
        /// </summary>
        /// <param name="random">Random number generator.</param>
        /// <returns>A random bool value.</returns>
        internal static bool GetFakeBool(Random random)
        {
            return random.Next(0, 2000) % 2 == 0;
        }

        /// <summary>
        /// Gets a random nullable bool value.
        /// </summary>
        /// <param name="random">Random number generator.</param>
        /// <returns>A random nullable bool value.</returns>
        internal static bool? GetFakeNullableBool(Random random)
        {
            switch (random.Next(0, 3000) % 3)
            {
                case 0:
                    return null;
                case 1:
                    return true;
                default:
                    return false;
            }
        }

        /// <summary>
        /// Gets a random integer with a 1 in 6 chance of being null.
        /// </summary>
        /// <param name="random">Random number generator.</param>
        /// <returns>A random nullable integer.</returns>
        internal static int? GetFakeNullableInteger(Random random)
        {
            int i = random.Next(0, 100);
            return (i % 6 == 0) ? null : (int?)i;
        }

        /// <summary>
        /// Gets a random status, with a 1 in 4 chance of being null.
        /// </summary>
        /// <param name="random">Random number generator.</param>
        /// <returns>A random nullable status.</returns>
        internal static Status? GetFakeNullableStatus(Random random)
        {
            switch (random.Next(0, 4000) % 4)
            {
                case 0:
                    return Status.Active;
                case 1:
                    return Status.Closed;
                case 2:
                    return Status.Resolved;
                default:
                    return null;
            }
        }

        #endregion Internal Methods

        #region Private Methods

        /// <summary>
        /// Creates a customer with random data.
        /// </summary>
        /// <param name="index">Index of the customer to generate.</param>
        /// <returns>A random customer.</returns>
        private static Customer CreateFakeCustomer(int index)
        {
            return new Customer(
                GetFakeString(random) + ((index > -1) ? index.ToString(CultureInfo.CurrentCulture) : string.Empty),
                GetFakeString(random),
                GetFakeColor(random),
                random.Next(5),
                GetFakeString(random),
                (decimal)(random.Next(100, 10000) / 100.0),
                GetFakeBool(random),
                GetFakeNullableBool(random),
                GetFakeNullableInteger(random),
                GetFakeStatus(random),
                GetFakeNullableStatus(random));
        }

        /// <summary>
        /// Randomly chooses a color from {Blue, Brown, Cyan, Gray, Green, Magenta, Orange, Purple, Red, Yellow}.
        /// </summary>
        /// <param name="random">Random number generator.</param>
        /// <returns>A random color.</returns>
        private static Color GetFakeColor(Random random)
        {
            switch (random.Next(0, 9))
            {
                case 0:
                    return Colors.Blue;
                case 1:
                    return Colors.Brown;
                case 2:
                    return Colors.Cyan;
                case 3:
                    return Colors.Gray;
                case 4:
                    return Colors.Green;
                case 5:
                    return Colors.Magenta;
                case 6:
                    return Colors.Orange;
                case 7:
                    return Colors.Purple;
                case 8:
                    return Colors.Red;
                default:
                    return Colors.Yellow;
            }
        }

        /// <summary>
        /// Raises a property changed notification.
        /// </summary>
        /// <param name="propertyName">Name of the property that changed.</param>
        private void RaisePropertyChanged(string propertyName)
        {
            if (this.PropertyChanged != null)
            {
                PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
            }
        }

        #endregion Private Methods
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples.Common\WebServiceHelper.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Globalization;
using System.Diagnostics.CodeAnalysis;
using System.Net;
using System.Windows.Browser;
using System.Windows.Controls;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// A set of simple helpers to enable the creation of more robust web 
    /// service samples. Includes a centralized place to get generic addresses 
    /// for service requests and web pages.
    /// </summary>
    public static class WebServiceHelper
    {
        /// <summary>
        /// The format of the URI for JSON requests to Live Suggestions.
        /// </summary>
        private const string LiveSuggestionsJsonUriFormat = "http://api.search.live.net/qson.aspx?query={0}";

        /// <summary>
        /// Standard Live Search URI.
        /// </summary>
        private const string LiveSearchUriFormat = "http://search.live.com/results.aspx?q={0}";
        
        /// <summary>
        /// A format string for creating a link to look at airline fares online.
        /// </summary>
        private const string AirfareSearchUriFormat = "http://farecast.live.com/flightsearch.do?t=r&o={0}&e={1}&d1={2}&r1={3}&p={4}&b=COACH"; 

        /// <summary>
        /// Gets a value indicating whether the document scheme allows for web 
        /// service access.
        /// </summary>
        /// <returns>Returns true when the scheme should permit web requests.</returns>
        public static bool CanMakeHttpRequests
        {
            get
            {
                if (!HtmlPage.IsEnabled)
                {
                    return false;
                }

                string scheme = HtmlPage.Document.DocumentUri.Scheme ?? string.Empty;
                return string.Compare(scheme, "http", StringComparison.OrdinalIgnoreCase) == 0;
            }
        }

        /// <summary>
        /// Creates a Uri to navigate to a web search service.
        /// </summary>
        /// <param name="searchText">The search string.</param>
        /// <returns>Returns a new Uri instance.</returns>
        public static Uri CreateWebSearchUri(string searchText)
        {
            return new Uri(string.Format(CultureInfo.InvariantCulture, LiveSearchUriFormat, HttpUtility.UrlEncode(searchText)));
        }

        /// <summary>
        /// Creates a Uri for retrieving search suggestion phrases.
        /// </summary>
        /// <param name="searchText">The search string.</param>
        /// <returns>Returns a new Uri instance.</returns>
        public static Uri CreateWebSearchSuggestionsUri(string searchText)
        {
            return new Uri(string.Format(CultureInfo.InvariantCulture, LiveSuggestionsJsonUriFormat, HttpUtility.UrlEncode(searchText)));
        }

        /// <summary>
        /// Creates a Uri to look up flight pricing trends online using the 
        /// Live Farecast service from Microsoft.
        /// </summary>
        /// <param name="departureAirport">The departure airport object.</param>
        /// <param name="arrivalAirport">The arrival airport object.</param>
        /// <param name="departure">The departure date.</param>
        /// <param name="arrival">The arrival date.</param>
        /// <param name="persons">The number of people that will be traveling.</param>
        /// <returns>Returns a new Uri object.</returns>
        public static Uri CreateAirfareSearchUri(Airport departureAirport, Airport arrivalAirport, DateTime departure, DateTime arrival, int persons)
        {
            return new Uri(string.Format(CultureInfo.InvariantCulture, AirfareSearchUriFormat, departureAirport.CodeFaa, arrivalAirport.CodeFaa, HttpUtility.UrlEncode(departure.ToShortDateString()), HttpUtility.UrlEncode(arrival.ToShortDateString()), persons.ToString(CultureInfo.InvariantCulture)));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples.Common\BusinessObjects\City.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Collections;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// City business object used for charting samples.
    /// </summary>
    public class City
    {
        /// <summary>
        /// Gets or sets the name of the city.
        /// </summary>
        public string Name { get; set; }

        /// <summary>
        /// Gets or sets the population of the city.
        /// </summary>
        public int Population { get; set; }

        /// <summary>
        /// Initializes a new instance of the City class.
        /// </summary>
        public City()
        {
        }

        /// <summary>
        /// Returns a string that represents the current object.
        /// </summary>
        /// <returns>A string that represents the current object.</returns>
        public override string ToString()
        {
            return Name;
        }

        /// <summary>
        /// Gets a collection of cities in the Puget Sound area.
        /// </summary>
        public static ObjectCollection PugetSound
        {
            get
            {
                ObjectCollection pugetSound = new ObjectCollection();
                pugetSound.Add(new City { Name = "Bellevue", Population = 112344 });
                pugetSound.Add(new City { Name = "Issaquah", Population = 11212 });
                pugetSound.Add(new City { Name = "Redmond", Population = 46391 });
                pugetSound.Add(new City { Name = "Seattle", Population = 592800 });
                return pugetSound;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples.Common\SharedResources.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Markup;
using System.Windows.Media.Imaging;
using System.Xml.Linq;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Utility to to load shared resources into another ResourceDictionary.
    /// </summary>
    public static class SharedResources
    {
        /// <summary>
        /// Prefix of images loaded as resources.
        /// </summary>
        private const string ResourceImagePrefix = "System.Windows.Controls.Samples.Images.";

        /// <summary>
        /// Prefix of icons loaded as resources.
        /// </summary>
        private const string ResourceIconPrefix = "System.Windows.Controls.Samples.Icons.";

        /// <summary>
        /// Get an embedded resource image from the assembly.
        /// </summary>
        /// <param name="name">Name of the image resource.</param>
        /// <returns>
        /// Desired embedded resource image from the assembly.
        /// </returns>
        public static Image GetImage(string name)
        {
            return CreateImage(ResourceImagePrefix, name);
        }

        /// <summary>
        /// Get an embedded resource icon from the assembly.
        /// </summary>
        /// <param name="name">Name of the icon resource.</param>
        /// <returns>
        /// Desired embedded resource icon from the assembly.
        /// </returns>
        public static Image GetIcon(string name)
        {
            return CreateImage(ResourceIconPrefix, name);
        }

        /// <summary>
        /// A cached dictionary of the bitmap images.
        /// </summary>
        private static IDictionary<string, BitmapImage> cachedBitmapImages = new Dictionary<string, BitmapImage>();

        /// <summary>
        /// Get an embedded resource image from the assembly.
        /// </summary>
        /// <param name="prefix">The prefix of the full name of the resource.</param>
        /// <param name="name">Name of the image resource.</param>
        /// <returns>
        /// Desired embedded resource image from the assembly.
        /// </returns>
        public static Image CreateImage(string prefix, string name)
        {
            Image image = new Image { Tag = name };

            BitmapImage source = null;
            string resourceName = prefix + name;
            if (!cachedBitmapImages.TryGetValue(resourceName, out source))
            {
                Assembly assembly = typeof(SharedResources).Assembly;

                using (Stream resource = assembly.GetManifestResourceStream(resourceName))
                {
                    if (resource != null)
                    {
                        source = new BitmapImage();
                        source.SetSource(resource);
                    }
                }
                cachedBitmapImages[resourceName] = source;
            }
            image.Source = source;
            return image;
        }

        /// <summary>
        /// Get all of the names of embedded resources images in the assembly.
        /// </summary>
        /// <returns>
        /// All of the names of embedded resources images in the assembly.
        /// </returns>
        [SuppressMessage("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate", Justification = "Does more work than a property should.")]
        public static IEnumerable<string> GetImageNames()
        {
            return GetResourceNames(ResourceImagePrefix);
        }

        /// <summary>
        /// Get all of the names of embedded resources icons in the assembly.
        /// </summary>
        /// <returns>
        /// All of the names of embedded resources icons in the assembly.
        /// </returns>
        [SuppressMessage("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate", Justification = "Does more work than a property should.")]
        public static IEnumerable<string> GetIconNames()
        {
            return GetResourceNames(ResourceIconPrefix);
        }

        /// <summary>
        /// Get all of the images in the assembly.
        /// </summary>
        /// <returns>All of the images in the assembly.</returns>
        [SuppressMessage("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate", Justification = "Does more work than a property should")]
        public static IEnumerable<Image> GetImages()
        {
            foreach (string name in GetImageNames())
            {
                yield return GetImage(name);
            }
        }

        /// <summary>
        /// Get all of the icons in the assembly.
        /// </summary>
        /// <returns>All of the icons in the assembly.</returns>
        [SuppressMessage("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate", Justification = "Does more work than a property should")]
        public static IEnumerable<Image> GetIcons()
        {
            foreach (string name in GetIconNames())
            {
                yield return GetImage(name);
            }
        }

        /// <summary>
        /// Get all the names of embedded resources in the assembly with the 
        /// provided prefix value.
        /// </summary>
        /// <param name="prefix">The prefix for the full resource name.</param>
        /// <returns>Returns an enumerable of all the resource names that match.</returns>
        private static IEnumerable<string> GetResourceNames(string prefix)
        {
            Assembly assembly = typeof(SharedResources).Assembly;
            foreach (string name in assembly.GetManifestResourceNames())
            {
                // Ignore resources that don't share the images prefix
                if (!name.StartsWith(prefix, StringComparison.OrdinalIgnoreCase))
                {
                    continue;
                }

                // Trim the prefix off of the name
                yield return name.Substring(prefix.Length, name.Length - prefix.Length);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples.Common\BusinessObjects\Department.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Windows;
using System.Windows.Markup;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Represents a department in an organization.
    /// </summary>
    [ContentProperty("Divisions")]
    public class Department
    {
        /// <summary>
        /// Initializes a new instance of the Department class.
        /// </summary>
        public Department()
        {
            Divisions = new Collection<Department>();
            Employees = new Collection<Employee>();
        }

        /// <summary>
        /// Gets or sets the title of the department.
        /// </summary>
        public string Title { get; set; }

        /// <summary>
        /// Gets a collection of employees in the department.
        /// </summary>
        public Collection<Employee> Employees { get; private set; }

        /// <summary>
        /// Gets a collection of divisions inside the department.
        /// </summary>
        public Collection<Department> Divisions { get; private set; }

        /// <summary>
        /// Gets a sample hierarchy of departments and employees.
        /// </summary>
        public static IEnumerable<Department> AllDepartments
        {
            get
            {
                IEnumerable<object> data = Application.Current.Resources["DepartmentOrganization"] as IEnumerable<object>;
                return (data != null) ?
                    data.Cast<Department>() :
                    Enumerable.Empty<Department>();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples.Common\BusinessObjects\CustomerList.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Windows.Media;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Represents a collection of Customer objects.
    /// </summary>
    public class CustomerCollection : IList<Customer>, IList, INotifyCollectionChanged
    {
        /// <summary>
        /// The underlying list of customers.
        /// </summary>
        private List<Customer> _customers;

        /// <summary>
        /// Notifies of changes to the collection.
        /// </summary>
        public event NotifyCollectionChangedEventHandler CollectionChanged;

        /// <summary>
        /// Initializes a CustomerCollection object with 25 customers.
        /// </summary>
        public CustomerCollection()
            : this(25)
        {
        }

        /// <summary>
        /// Initializes a CustomerCollection.
        /// </summary>
        /// <param name="customerCount">The number of customers to generate.</param>
        public CustomerCollection(int customerCount)
        {
            this._customers = new List<Customer>();

            // Fake Data
            if (customerCount > 0)
            {
                Add(new Customer("John", "Doe", Colors.Orange, 1, "Obere Str. 57, Berlin 12209, Germany", (decimal)12.25, false, null, 35, Status.Active, Status.Closed));
            }
            if (customerCount > 1)
            {
                Add(new Customer("Jane", "Doe", Colors.Purple, 5, "24, place Kléber, 67000 Strasbourg, France", (decimal)15.55, true, null, 57, Status.Resolved, null));
            }
            if (customerCount > 2)
            {
                Add(new Customer("Joe", "Anybody", Colors.Yellow, 1, "Strada Provinciale 124, 42100 Reggio Emilia, Italy", (decimal)11.5, true, false, null, Status.Closed, Status.Closed));
            }
            if (customerCount > 3)
            {
                Add(new Customer("Jill", "Anybody", Colors.Green, 1, "Geislweg 36, Salzburg 5020, Austria", (decimal)9.99, false, true, null, Status.Active, null));
            }
            for (int customer = 4; customer < customerCount; customer++)
            {
                Add(Customer.GetRandomCustomer(customer));
            }
        }

        #region ICollection Members

        /// <summary>
        /// Copies the collection.
        /// </summary>
        /// <param name="array">Destination array.</param>
        /// <param name="index">Index to copy to.</param>
        public void CopyTo(System.Array array, int index)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Gets a value indicating whether the collection supports asynchronous operations.
        /// </summary>
        public bool IsSynchronized
        {
            get
            {
                return false;
            }
        }

        /// <summary>
        /// Gets an object to use for synchronization.
        /// </summary>
        public object SyncRoot
        {
            get
            {
                return this;
            }
        }

        #endregion

        #region IList Members

        /// <summary>
        /// Gets a value indicating whether the collection has a fixed size.
        /// </summary>
        public bool IsFixedSize
        {
            get
            {
                return false;
            }
        }

        /// <summary>
        /// Gets a value indicating whether the collection is read-only.
        /// </summary>
        public bool IsReadOnly
        {
            get
            {
                return false;
            }
        }

        /// <summary>
        /// Returns the customer at an index.
        /// </summary>
        /// <param name="index">Index to retrieve.</param>
        /// <returns>The customer at the given index in the collection.</returns>
        object IList.this[int index]
        {
            get
            {
                return this._customers[index];
            }
            set
            {
                Customer customer = value as Customer;
                if (customer == null)
                {
                    throw new ArgumentNullException("value");
                }
                this._customers[index] = customer;
            }
        }

        /// <summary>
        /// Adds an item to the collection.
        /// </summary>
        /// <param name="value">The value to add to the collection.</param>
        /// <returns>The index at which the value was added.</returns>
        public int Add(object value)
        {
            Customer customer = value as Customer;
            if (customer == null)
            {
                throw new ArgumentException("Invalid argument to Add", "value");
            }
            Add(customer);
            return this.Count - 1;
        }

        /// <summary>
        /// Determines whether the collection contains the given value.
        /// </summary>
        /// <param name="value">The value to search for.</param>
        /// <returns>True if the collection contains the value.  False otherwise.</returns>
        public bool Contains(object value)
        {
            if (value == null)
            {
                throw new ArgumentNullException("value");
            }
            return Contains(value as Customer);
        }

        /// <summary>
        /// Determines the index of the given value.
        /// </summary>
        /// <param name="value">The value to search for.</param>
        /// <returns>The index of the value, or -1 if not found.</returns>
        public int IndexOf(object value)
        {
            return IndexOf(value as Customer);
        }

        /// <summary>
        /// Inserts an object at the given index.
        /// </summary>
        /// <param name="index">Index where the value should be inserted.</param>
        /// <param name="value">The value to insert.</param>
        public void Insert(int index, object value)
        {
            Insert(index, value as Customer);
        }

        /// <summary>
        /// Removes the given value from the collection.
        /// </summary>
        /// <param name="value">Value to remove.</param>
        public void Remove(object value)
        {
            Remove(value as Customer);
        }

        #endregion

        #region IList<Customer> Members

        /// <summary>
        /// Determines the index of the given customer.
        /// </summary>
        /// <param name="item">The customer to search for.</param>
        /// <returns>The index of the customer, or -1 if not found.</returns>
        public int IndexOf(Customer item)
        {
            return this._customers.IndexOf(item);
        }

        /// <summary>
        /// Inserts a customer at the given index.
        /// </summary>
        /// <param name="index">Index where the value should be inserted.</param>
        /// <param name="item">Customer to insert.</param>
        public void Insert(int index, Customer item)
        {
            if (item == null)
            {
                throw new ArgumentNullException("item");
            }
            this._customers.Insert(index, item);
            RaiseCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Add, item, index));
        }

        /// <summary>
        /// Removes the item at the given index.
        /// </summary>
        /// <param name="index">Index at which the item should be removed.</param>
        public void RemoveAt(int index)
        {
            Customer customer = this._customers[index];
            this._customers.RemoveAt(index);
            RaiseCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Remove, customer, index));
        }

        /// <summary>
        /// Gets the customer at the given index.
        /// </summary>
        /// <param name="index">Index of the customer.</param>
        /// <returns>The customer at the given index.</returns>
        public Customer this[int index]
        {
            get
            {
                return this._customers[index];
            }
            set
            {
                if (this._customers[index] != value)
                {
                    if (value == null)
                    {
                        throw new ArgumentNullException("value");
                    }
                    this._customers[index] = value;
                    RaiseCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Replace, value, index));
                }
            }
        }

        #endregion

        #region ICollection<Customer> Members

        /// <summary>
        /// Adds a customer to the collection.
        /// </summary>
        /// <param name="item">Customer to add.</param>
        public void Add(Customer item)
        {
            if (item == null)
            {
                throw new ArgumentNullException("item");
            }
            this._customers.Add(item);
            RaiseCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Add, item, this.Count - 1));
        }

        /// <summary>
        /// Clears the collection.
        /// </summary>
        public void Clear()
        {
            this._customers.Clear();
            RaiseCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Reset));
        }

        /// <summary>
        /// Determines whether the collection contains the given customer.
        /// </summary>
        /// <param name="item">The customer to search for.</param>
        /// <returns>True if the collection contains the customer.  False otherwise.</returns>
        public bool Contains(Customer item)
        {
            if (item == null)
            {
                throw new ArgumentNullException("item");
            }
            return this._customers.Contains(item);
        }

        /// <summary>
        /// Copies customers from this collection into an array.
        /// </summary>
        /// <param name="array">Destination array.</param>
        /// <param name="arrayIndex">Start index in the array into which customers will be copied.</param>
        public void CopyTo(Customer[] array, int arrayIndex)
        {
            this._customers.CopyTo(array, arrayIndex);
        }

        /// <summary>
        /// Gets the number of items in the collection.
        /// </summary>
        public int Count
        {
            get
            {
                return this._customers.Count;
            }
        }

        /// <summary>
        /// Removes a customer from the collection.
        /// </summary>
        /// <param name="item">Customer to remove.</param>
        /// <returns>True if the customer was found and removed.  False otherwise.</returns>
        public bool Remove(Customer item)
        {
            if (item == null)
            {
                throw new ArgumentNullException("item");
            }
            int index = this._customers.IndexOf(item);
            if (index > -1)
            {
                this._customers.RemoveAt(index);
                RaiseCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Remove, item, index));
                return true;
            }
            return false;
        }

        #endregion

        #region IEnumerable<Customer> Members

        /// <summary>
        /// Enumerates over the customers in the collection.
        /// </summary>
        /// <returns>An enumerator for the customers.</returns>
        public IEnumerator<Customer> GetEnumerator()
        {
            return this._customers.GetEnumerator();
        }

        #endregion

        #region IEnumerable Members

        /// <summary>
        /// Enumerates over the customers in the collection.
        /// </summary>
        /// <returns>An enumerator for the customers.</returns>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return this._customers.GetEnumerator();
        }

        #endregion

        #region Private methods

        /// <summary>
        /// Raises the CollectionChanged event.
        /// </summary>
        /// <param name="e">Event arguments.</param>
        private void RaiseCollectionChanged(NotifyCollectionChangedEventArgs e)
        {
            if (CollectionChanged != null)
            {
                CollectionChanged(this, e);
            }
        }

        #endregion Private methods
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples.Common\BusinessObjects\Contact.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

/* 
 * The example companies, organizations, products, domain names,
 * e-mail addresses, logos, people, places, and events depicted
 * herein are fictitious.  No association with any real company,
 * organization, product, domain name, email address, logo, person,
 * places, or events is intended or should be inferred.
*/

using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Represents a person's contact information.
    /// </summary>
    public class Contact : INotifyPropertyChanged, IEditableObject
    {
        /// <summary>
        /// Represents the first name of the contact.
        /// </summary>
        private string firstName;

        /// <summary>
        /// Represents the last name of the contact.
        /// </summary>
        private string lastName;

        /// <summary>
        /// Represents the contact's phone number.
        /// </summary>
        private string phone;

        /// <summary>
        /// Represents the contact's street address.
        /// </summary>
        private string street1;

        /// <summary>
        /// Represents the contact's extended street address (such as an apartment number of P.O. Box).
        /// </summary>
        private string street2;

        /// <summary>
        /// Represents the contact's city.
        /// </summary>
        private string city;

        /// <summary>
        /// Represents the contact's state.
        /// </summary>
        private string state;

        /// <summary>
        /// Represents the contact's e-mail address.
        /// </summary>
        private string email;

        /// <summary>
        /// Represents the contact's zip code.
        /// </summary>
        private int zip;

        /// <summary>
        /// Indicates whether the address for the contact is a business address.
        /// </summary>
        private bool isBusinessAddress;

        /// <summary>
        /// Initializes a new contact.
        /// </summary>
        public Contact()
        {
        }

        /// <summary>
        /// Gets or sets the first name of the contact.
        /// </summary>
        [Required]
        [Display(Name = "First Name", GroupName = "Name")]
        public string FirstName
        {
            get
            {
                return firstName;
            }
            set
            {
                if (value != firstName)
                {
                    firstName = value;
                    OnPropertyChanged("FirstName");
                }
            }
        }

        /// <summary>
        /// Gets or sets the last name of the contact.
        /// </summary>
        [Required]
        [Display(Name = "Last Name", GroupName = "Name")]
        public string LastName
        {
            get
            {
                return lastName;
            }
            set
            {
                if (value != lastName)
                {
                    lastName = value;
                    OnPropertyChanged("LastName");
                }
            }
        }

        /// <summary>
        /// Gets or sets the phone number of the contact in the form (###) ###-####.
        /// </summary>
        [Display(Name = "Phone", Description = "Phone number of the form (###) ###-####")]
        [RegularExpression(@"^\(\d\d\d\) \d\d\d\-\d\d\d\d$", ErrorMessage = "Not a valid phone number.  Please enter a phone number that matches the format (###) ###-####")]
        public string Phone
        {
            get
            {
                return phone;
            }
            set
            {
                if (value != phone)
                {
                    Validator.ValidateProperty(value, new ValidationContext(this, null, null) { MemberName = "Phone" });
                    phone = value;
                    OnPropertyChanged("Phone");
                }
            }
        }

        /// <summary>
        /// Gets or sets the street address of the contact.
        /// </summary>
        [Required]
        [Display(Name = "Street Address", GroupName = "Address")]
        public string Street1
        {
            get
            {
                return street1;
            }
            set
            {
                if (value != street1)
                {
                    street1 = value;
                    OnPropertyChanged("Street1");
                }
            }
        }

        /// <summary>
        /// Gets or sets the secondary street address information for the contact, such as apartment number or P.O. Box.
        /// </summary>
        [Display(Name = "Secondary Street Address", Description = "Additional street address information, such as apartment number or P.O. Box", GroupName = "Address")]
        public string Street2
        {
            get
            {
                return street2;
            }
            set
            {
                if (value != street2)
                {
                    street2 = value;
                    OnPropertyChanged("Street2");
                }
            }
        }

        /// <summary>
        /// Gets or sets the city of the contact.
        /// </summary>
        [Required]
        [Display(Name = "City", Description = "City of residence", GroupName = "Address")]
        public string City
        {
            get
            {
                return city;
            }
            set
            {
                if (value != city)
                {
                    city = value;
                    OnPropertyChanged("City");
                }
            }
        }

        /// <summary>
        /// Gets or sets the abbreviated state name of the contact (e.g. CA or TN).
        /// </summary>
        [Required]
        [RegularExpression(@"^[a-zA-Z][a-zA-Z]$", ErrorMessage = "Not a valid state abbreviation (e.g. CA or TN)")]
        [Display(Name = "State", Description = "State abbreviation", GroupName = "Address")]
        public string State
        {
            get
            {
                return state;
            }
            set
            {
                if (value != state)
                {
                    Validator.ValidateProperty(value, new ValidationContext(this, null, null) { MemberName = "State" });
                    state = value;
                    OnPropertyChanged("State");
                }
            }
        }

        /// <summary>
        /// Gets or sets a value indicating whether this contact's address is a business address.
        /// </summary>
        [Display(Name = "Business Address", Description = "Indicates that the address is a business address.")]
        public bool IsBusinessAddress
        {
            get
            {
                return isBusinessAddress;
            }
            set
            {
                if (value != isBusinessAddress)
                {
                    isBusinessAddress = value;
                    OnPropertyChanged("IsBusinessAddress");
                }
            }
        }

        /// <summary>
        /// Gets or sets the e-mail address (e.g. someone@somewhere.com) for the contact.
        /// </summary>
        [RegularExpression(@"^([a-zA-Z0-9\!\%\$\%\*\/\?\|\^\{\}\`\~\&\'\+\-\=_]\.?)*[a-zA-Z0-9\!\%\$\%\*\/\?\|\^\{\}\`\~\&\'\+\-\=_]@((([a-zA-Z0-9\!\%\$\%\*\/\?\|\^\{\}\`\~\&\'\+\-\=_]\.?)*[a-zA-Z0-9\!\%\$\%\*\/\?\|\^\{\}\`\~\&\'\+\-\=_])|(\[\d+\.\d+\.\d+\.\d+\]))$", ErrorMessage = "Not a valid e-mail address.")]
        [Display(Name = "Email", Description = "An e-mail address of the form <name>@<domain>, such as john@johndoe.com")]
        public string Email
        {
            get
            {
                return email;
            }
            set
            {
                if (value != email)
                {
                    Validator.ValidateProperty(value, new ValidationContext(this, null, null) { MemberName = "Email" });
                    email = value;
                    OnPropertyChanged("Email");
                }
            }
        }

        /// <summary>
        /// Gets or sets the zip code of the contact.
        /// </summary>
        [Required]
        [RegularExpression(@"^\d\d\d\d\d$", ErrorMessage = "Zip codes must be 5-digit numbers.")]
        [Display(Name = "Zip", Description = "Five-digit zip code", GroupName = "Address")]
        public int Zip
        {
            get
            {
                return zip;
            }
            set
            {
                if (value != zip)
                {
                    Validator.ValidateProperty(value, new ValidationContext(this, null, null) { MemberName = "Zip" });
                    zip = value;
                    OnPropertyChanged("Zip");
                }
            }
        }

        /// <summary>
        /// Raises a property changed notification for the specified property name.
        /// </summary>
        /// <param name="propName">The name of the property that changed.</param>
        protected virtual void OnPropertyChanged(string propName)
        {
            if (PropertyChanged != null)
            {
                PropertyChanged(this, new PropertyChangedEventArgs(propName));
            }
        }

        #region INotifyPropertyChanged Members

        /// <summary>
        /// Raised when a property on the contact changes.
        /// </summary>
        public event PropertyChangedEventHandler PropertyChanged;

        #endregion

        /// <summary>
        /// Gets a stock "John Doe" contact.
        /// </summary>
        public static Contact JohnDoe
        {
            get
            {
                return new Contact
                {
                    FirstName = "John",
                    LastName = "Doe",
                    Phone = "(555) 555-5555",
                    Street1 = "1 Anywhere Street",
                    City = "Anytown",
                    State = "WA",
                    Zip = 98000
                };
            }
        }

        /// <summary>
        /// Gets a stock group of contacts with valid contact information.
        /// </summary>
        public static IEnumerable<Contact> People
        {
            get
            {
                return new ObservableCollection<Contact>
                {
                    new Contact
                    {
                        FirstName = "Kim",
                        LastName = "Abercrombie",
                        Phone = "(555) 555-0000",
                        Street1 = "1 Anywhere Street",
                        City = "Anytown",
                        State = "WA",
                        Zip = 12345
                    },
                    new Contact
                    {
                        FirstName = "Hadaya",
                        LastName = "Sagiv",
                        Phone = "(555) 555-0001",
                        Street1 = "2 Anywhere Street",
                        City = "AnotherTown",
                        State = "HI",
                        Zip = 55555
                    },
                    new Contact
                    {
                        FirstName = "Jeff",
                        LastName = "Price",
                        Phone = "(555) 555-0002",
                        Street1 = "3 Somewhere Street",
                        City = "Anytown",
                        State = "OR",
                        Zip = 77777
                    },
                    new Contact
                    {
                        FirstName = "Chris",
                        LastName = "Hill",
                        Phone = "(555) 555-0431",
                        Street1 = "17 Anywhere Lane",
                        City = "AnotherTown",
                        State = "WA",
                        Zip = 28145
                    },
                    new Contact
                    {
                        FirstName = "Prithvi",
                        LastName = "Raj",
                        Phone = "(555) 555-8543",
                        Street1 = "9144 Somewhere Street",
                        City = "Anytown",
                        State = "OR",
                        Zip = 75812
                    },
                    new Contact
                    {
                        FirstName = "Ryan",
                        LastName = "Ihrig",
                        Phone = "(555) 555-1345",
                        Street1 = "19 Anywhere Lane",
                        City = "AnotherTown",
                        State = "OR",
                        Zip = 58104
                    },
                    new Contact
                    {
                        FirstName = "Jim",
                        LastName = "Ptaszynski",
                        Phone = "(555) 555-5832",
                        Street1 = "1 Anywhere Street",
                        City = "Anytown",
                        State = "NH",
                        Zip = 74584
                    },
                    new Contact
                    {
                        FirstName = "Dan",
                        LastName = "Bacon",
                        Phone = "(555) 555-1914",
                        Street1 = "144 Anywhere Lane",
                        City = "Anytown",
                        State = "WA",
                        Zip = 13412
                    },
                    new Contact
                    {
                        FirstName = "Steve",
                        LastName = "Kastner",
                        Phone = "(555) 555-4581",
                        Street1 = "121 Anywhere Street",
                        City = "AnotherTown",
                        State = "WA",
                        Zip = 45828
                    },
                    new Contact
                    {
                        FirstName = "Andy",
                        LastName = "Ruth",
                        Phone = "(555) 555-4258",
                        Street1 = "391 Somewhere Lane",
                        City = "Anytown",
                        State = "WA",
                        Zip = 38447
                    },
                    new Contact
                    {
                        FirstName = "Brian",
                        LastName = "Bredehoeft",
                        Phone = "(555) 555-4853",
                        Street1 = "1234 Anywhere Street",
                        City = "Anytown",
                        State = "WA",
                        Zip = 14834
                    },
                    new Contact
                    {
                        FirstName = "Esko",
                        LastName = "Sario",
                        Phone = "(555) 555-3248",
                        Street1 = "1 Someplace Street",
                        City = "Anytown",
                        State = "CA",
                        Zip = 41834
                    },
                    new Contact
                    {
                        FirstName = "Joel",
                        LastName = "Lachance",
                        Phone = "(555) 555-1482",
                        Street1 = "48 Anywhere Lane",
                        City = "Anytown",
                        State = "NY",
                        Zip = 91934
                    },
                    new Contact
                    {
                        FirstName = "Bonnie",
                        LastName = "Skelly",
                        Phone = "(555) 555-8582",
                        Street1 = "1 Anywhere Street",
                        City = "Anytown",
                        State = "NY",
                        Zip = 95812
                    },
                    new Contact
                    {
                        FirstName = "James",
                        LastName = "Doe",
                        Phone = "(555) 555-5555",
                        Street1 = "1 Anywhere Street",
                        City = "AnotherTown",
                        State = "WA",
                        Zip = 58433
                    },
                    new Contact
                    {
                        FirstName = "John",
                        LastName = "Somebody",
                        Phone = "(555) 555-5555",
                        Street1 = "1 Anywhere Street",
                        City = "Anytown",
                        State = "WA",
                        Zip = 15852
                    },
                    new Contact
                    {
                        FirstName = "Jane",
                        LastName = "Somebody",
                        Phone = "(555) 555-5555",
                        Street1 = "1 Anywhere Street",
                        City = "Anytown",
                        State = "HI",
                        Zip = 18824
                    },
                    new Contact
                    {
                        FirstName = "Andrew",
                        LastName = "Ma",
                        Phone = "(555) 555-2384",
                        Street1 = "1 Anywhere Drive",
                        City = "Anytown",
                        State = "OR",
                        Zip = 12420
                    },
                    new Contact
                    {
                        FirstName = "Shannon",
                        LastName = "Dascher",
                        Phone = "(555) 555-7378",
                        Street1 = "231 Anywhere Lane",
                        City = "Anytown",
                        State = "WA",
                        Zip = 14855
                    },
                    new Contact
                    {
                        FirstName = "William",
                        LastName = "Looney",
                        Phone = "(555) 555-5555",
                        Street1 = "145 Somwhere Street",
                        City = "Anytown",
                        State = "OR",
                        Zip = 19855
                    },
                    new Contact
                    {
                        FirstName = "Louise",
                        LastName = "Toubro",
                        Phone = "(555) 555-4832",
                        Street1 = "123 Somewhere Lane",
                        City = "AnotherTown",
                        State = "OR",
                        Zip = 12842
                    },
                    new Contact
                    {
                        FirstName = "Tim",
                        LastName = "Toyoshima",
                        Phone = "(555) 555-3849",
                        Street1 = "1234 Anywhere Street",
                        City = "Anytown",
                        State = "NH",
                        Zip = 12843
                    },
                    new Contact
                    {
                        FirstName = "Peter",
                        LastName = "Mullen",
                        Phone = "(555) 555-7758",
                        Street1 = "1233 Anywhere Street",
                        City = "Anytown",
                        State = "WA",
                        Zip = 12484
                    },
                    new Contact
                    {
                        FirstName = "Ming-Yang",
                        LastName = "Xie",
                        Phone = "(555) 555-9283",
                        Street1 = "1423 Somewhere Street",
                        City = "Anytown",
                        State = "WA",
                        Zip = 12348
                    },
                    new Contact
                    {
                        FirstName = "Smuel",
                        LastName = "Yair",
                        Phone = "(555) 555-4821",
                        Street1 = "138 Anywhere Street",
                        City = "Anytown",
                        State = "WA",
                        Zip = 48439
                    },
                    new Contact
                    {
                        FirstName = "John",
                        LastName = "Woods",
                        Phone = "(555) 555-5859",
                        Street1 = "9583 Anywhere Street",
                        City = "Anytown",
                        State = "WA",
                        Zip = 93205
                    },
                    new Contact
                    {
                        FirstName = "Pieter",
                        LastName = "Wycoff",
                        Phone = "(555) 555-9292",
                        Street1 = "321 Anywhere Lane",
                        City = "Anytown",
                        State = "CA",
                        Zip = 95839
                    },
                    new Contact
                    {
                        FirstName = "Michiel",
                        LastName = "Wories",
                        Phone = "(555) 555-8584",
                        Street1 = "199 Anywhere Street",
                        City = "AnotherTown",
                        State = "NY",
                        Zip = 39495
                    },
                    new Contact
                    {
                        FirstName = "John",
                        LastName = "Yokim",
                        Phone = "(555) 555-4843",
                        Street1 = "3241 Someplace Street",
                        City = "Anytown",
                        State = "NY",
                        Zip = 93258
                    },
                    new Contact
                    {
                        FirstName = "Yanlai",
                        LastName = "Guo",
                        Phone = "(555) 555-4999",
                        Street1 = "2241 Somewhere Street",
                        City = "Anytown",
                        State = "WA",
                        Zip = 18444
                    }
                };
            }
        }

        #region IEditableObject Members
        /// <summary>
        /// Keeps a copy of the original contact for editing.
        /// </summary>
        private Contact cache;

        /// <summary>
        /// Indicates that the contact will undergo a cancellable edit.
        /// </summary>
        public void BeginEdit()
        {
            cache = new Contact();
            cache.City = this.City;
            cache.Email = this.Email;
            cache.FirstName = this.FirstName;
            cache.LastName = this.LastName;
            cache.Phone = this.Phone;
            cache.State = this.State;
            cache.Street1 = this.Street1;
            cache.Street2 = this.Street2;
            cache.Zip = this.Zip;
        }

        /// <summary>
        /// Indicates that the edit was cancelled and that the old state should be restored.
        /// </summary>
        public void CancelEdit()
        {
            this.City = cache.City;
            this.Email = cache.Email;
            this.FirstName = cache.FirstName;
            this.LastName = cache.LastName;
            this.Phone = cache.Phone;
            this.State = cache.State;
            this.Street1 = cache.Street1;
            this.Street2 = cache.Street2;
            this.Zip = cache.Zip;
            cache = null;
        }

        /// <summary>
        /// Indicates that the edit completed and that changed fields should be committed.
        /// </summary>
        public void EndEdit()
        {
            cache = null;
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples.Common\BusinessObjects\Employee.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Employee business object used in DataTemplate examples.
    /// </summary>
    public sealed partial class Employee
    {
        /// <summary>
        /// Gets or sets the first name of the employee.
        /// </summary>
        public string FirstName { get; set; }

        /// <summary>
        /// Gets or sets the last name of the employee.
        /// </summary>
        public string LastName { get; set; }

        /// <summary>
        /// Gets or sets a Photograph of the employee.
        /// </summary>
        public Photograph Photograph { get; set; }

        /// <summary>
        /// Gets the display name for the employee. Uses simple concatenation 
        /// currently.
        /// </summary>
        public string DisplayName
        {
            get
            {
                return FirstName + " " + LastName;
            }
        }

        /// <summary>
        /// Initializes a new instance of the Employee class.
        /// </summary>
        public Employee()
        {
        }

        /// <summary>
        /// Initializes a new instance of the Employee class.
        /// </summary>
        /// <param name="firstName">First name of the employee.</param>
        /// <param name="lastName">Last name of the employee.</param>
        /// <param name="resourceName">
        /// Name of a resource containing a photograph of the employee.
        /// </param>
        internal Employee(string firstName, string lastName, string resourceName) : this(firstName, lastName)
        {
            Photograph = new Photograph(resourceName);
        }

        /// <summary>
        /// Initializes a new instance of the Employee class.
        /// </summary>
        /// <param name="firstName">First name of the employee.</param>
        /// <param name="lastName">Last name of the employee.</param>
        internal Employee(string firstName, string lastName)
        {
            FirstName = firstName;
            LastName = lastName;
        }

        /// <summary>
        /// Overrides the ToString method to return the DisplayName for the 
        /// Employee.
        /// </summary>
        /// <returns>Returns the full name of the employee.</returns>
        public override string ToString()
        {
            return DisplayName;
        }

        #region Sample data

        /// <summary>
        /// Gets an Employee object that represents Bill Gates.
        /// </summary>
        public static Employee BillGates
        {
            get { return new Employee("Bill", "Gates", "BillGates.jpg"); }
        }

        /// <summary>
        /// Gets an Employee object that represents Steve Ballmer.
        /// </summary>
        public static Employee SteveBallmer
        {
            get { return new Employee("Steve", "Ballmer", "SteveBallmer.jpg"); }
        }

        /// <summary>
        /// Gets an Employee object that represents S. Somasegar.
        /// </summary>
        [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Somasegar", Justification = "It's his name.")]
        public static Employee Somasegar
        {
            get { return new Employee("S.", "Somasegar", "Somasegar.jpg"); }
        }

        /// <summary>
        /// Gets an Employee object that represents Scott Guthrie.
        /// </summary>
        public static Employee ScottGuthrie
        {
            get { return new Employee("Scott", "Guthrie", "ScottGuthrie.jpg"); }
        }

        /// <summary>
        /// Gets a collection of various executives at the company.
        /// </summary>
        public static IEnumerable<Employee> Executives
        {
            get { return new Employee[] { BillGates, SteveBallmer, Somasegar, ScottGuthrie }; }
        }

        /// <summary>
        /// Gets a collection of executive leaders as defined online, as of 
        /// 10/14/08.
        /// </summary>
        public static IEnumerable<Employee> AllExecutives
        {
            get
            {
                yield return new Employee("Walid", "Abu-Hadba");
                yield return new Employee("J", "Allard");
                yield return new Employee("Klaus", "Holse Andersen");
                yield return new Employee("Nancy", "Anderson");
                yield return new Employee("Brian", "Arbogast");
                yield return new Employee("Orlando", "Ayala");
                yield return new Employee("Robert J.", "Bach");
                yield return SteveBallmer;
                yield return new Employee("Martha", "Béjar");
                yield return new Employee("Joe", "Belfiore");
                yield return new Employee("Sue", "Bevington");
                yield return new Employee("Frank H.", "Brod");
                yield return new Employee("Brad", "Brooks");
                yield return new Employee("Lisa", "Brummel");
                yield return new Employee("Tom", "Burt");
                yield return new Employee("Chris", "Capossela");
                yield return new Employee("Scott", "Charney");
                yield return new Employee("Debra", "Chrapaty");
                yield return new Employee("Jean-Philippe", "Courtois");
                yield return new Employee("Alain", "Crozier");
                yield return new Employee("Kurt", "DelBene");
                yield return new Employee("Michael", "Delman");
                yield return new Employee("Joe", "DeVaan");
                yield return new Employee("Gerri", "Elliott");
                yield return new Employee("Stephen", "Elop");
                yield return new Employee("Ben", "Fathi");
                yield return BillGates;
                yield return new Employee("Grant", "George");
                yield return new Employee("Tom", "Gibbons");
                yield return new Employee("L. Michael", "Golden");
                yield return new Employee("Alexander", "Gounares");
                yield return new Employee("Steve", "Guggenheimer");
                yield return new Employee("Anoop", "Gupta");
                yield return ScottGuthrie;
                yield return new Employee("Tony", "Hey");
                yield return new Employee("Yasuyuki", "Higuchi");
                yield return new Employee("Roz", "Ho");
                yield return new Employee("Kathleen", "Hogan");
                yield return new Employee("Frank", "Holland");
                yield return new Employee("Todd", "Holmdahl");
                yield return new Employee("Darren", "Huston");
                yield return new Employee("Rajesh", "Jha");
                yield return new Employee("Chris", "Jones");
                yield return new Employee("Erik", "Jorgensen");
                yield return new Employee("Rich", "Kaplan");
                yield return new Employee("Bob", "Kelly");
                yield return new Employee("Jawad", "Khaki");
                yield return new Employee("Shane", "Kim");
                yield return new Employee("Peter", "Klein");
                yield return new Employee("Mitchell L.", "Koch");
                yield return new Employee("Ted", "Kummert");
                yield return new Employee("Julie", "Larson-Green");
                yield return new Employee("Antoine", "Leblond");
                yield return new Employee("Andrew", "Lees");
                yield return new Employee("John M.", "Lervik");
                yield return new Employee("Lewis", "Levin");
                yield return new Employee("Dan'l", "Lewin");
                yield return new Employee("Moshe", "Lichtman");
                yield return new Employee("Christopher", "Liddell");
                yield return new Employee("Steve", "Liffick");
                yield return new Employee("Brian", "MacDonald");
                yield return new Employee("Ron", "Markezich");
                yield return new Employee("Maria", "Martinez");
                yield return new Employee("Mich", "Mathews");
                yield return new Employee("Don A.", "Mattrick");
                yield return new Employee("Joe", "Matz");
                yield return new Employee("Brian", "McAndrews");
                yield return new Employee("Richard", "McAniff");
                yield return new Employee("Yusuf", "Mehdi");
                yield return new Employee("Jim", "Minervino");
                yield return new Employee("William H.", "Mitchell");
                yield return new Employee("Jens Winther", "Moberg");
                yield return new Employee("Mindy", "Mount");
                yield return new Employee("Bob", "Muglia");
                yield return new Employee("Craig", "Mundie");
                yield return new Employee("Terry", "Myerson");
                yield return new Employee("Satya", "Nadella");
                yield return new Employee("Mike", "Nash");
                yield return new Employee("Peter", "Neupert");
                yield return new Employee("Ray", "Ozzie");
                yield return new Employee("Gurdeep", "Singh Pall");
                yield return new Employee("Michael", "Park");
                yield return new Employee("Umberto", "Paolucci");
                yield return new Employee("Sanjay", "Parthasarathy");
                yield return new Employee("Pamela", "Passman");
                yield return new Employee("Alain", "Peracca");
                yield return new Employee("Todd", "Peters");
                yield return new Employee("Joe", "Peterson");
                yield return new Employee("Marshall C.", "Phelps, Jr.");
                yield return new Employee("Scott", "Pitasky");
                yield return new Employee("Will", "Poole");
                yield return new Employee("Rick", "Rashid");
                yield return new Employee("Tami", "Reller");
                yield return new Employee("J.", "Ritchie");
                yield return new Employee("Enrique", "Rodriguez");
                yield return new Employee("Eduardo", "Rosini");
                yield return new Employee("Jon", "Roskill");
                yield return new Employee("Eric", "Rudder");
                yield return new Employee("John", "Schappert");
                yield return new Employee("Tony", "Scott");
                yield return new Employee("Jeanne", "Sheldon");
                yield return new Employee("Harry", "Shum");
                yield return new Employee("Steven", "Sinofsky");
                yield return new Employee("Brad", "Smith");
                yield return new Employee("Mary E.", "Snapp");
                yield return Somasegar;
                yield return new Employee("Amitabh", "Srivastava");
                yield return new Employee("Kirill", "Tatarinov");
                yield return new Employee("Jeff", "Teper");
                yield return new Employee("David", "Thompson");
                yield return new Employee("Rick", "Thompson");
                yield return new Employee("Brian", "Tobey");
                yield return new Employee("David", "Treadwell");
                yield return new Employee("B. Kevin", "Turner");
                yield return new Employee("David", "Vaskevitch");
                yield return new Employee("Bill", "Veghte");
                yield return new Employee("Henry P.", "Vigil");
                yield return new Employee("Robert", "Wahbe");
                yield return new Employee("Todd", "Warren");
                yield return new Employee("Allison", "Watson");
                yield return new Employee("Blair", "Westlake");
                yield return new Employee("Simon", "Witts");
                yield return new Employee("Robert", "Youngjohns");
                yield return new Employee("Ya-Qin", "Zhang");
                yield return new Employee("George", "Zinn");
            }
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples.Common\BusinessObjects\ParticulateLevel.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Collections;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// ParticulateLevel business object used for charting samples.
    /// </summary>
    public class ParticulateLevel
    {
        /// <summary>
        /// Gets or sets the particulate count.
        /// </summary>
        public int Particulate { get; set; }

        /// <summary>
        /// Gets or sets the daily rainfall.
        /// </summary>
        public double Rainfall { get; set; }

        /// <summary>
        /// Initializes a new instance of the ParticulateLevel class.
        /// </summary>
        public ParticulateLevel()
        {
        }

        /// <summary>
        /// Gets a collection of particulate levels for rainfall.
        /// </summary>
        /// <remarks>
        /// Sample data from http://office.microsoft.com/en-us/help/HA102274781033.aspx.
        /// </remarks>
        public static ObjectCollection LevelsInRainfall
        {
            get
            {
                ObjectCollection levelsInRainfall = new ObjectCollection();
                levelsInRainfall.Add(new ParticulateLevel { Particulate = 122, Rainfall = 4.1 });
                levelsInRainfall.Add(new ParticulateLevel { Particulate = 117, Rainfall = 4.3 });
                levelsInRainfall.Add(new ParticulateLevel { Particulate = 112, Rainfall = 5.7 });
                levelsInRainfall.Add(new ParticulateLevel { Particulate = 114, Rainfall = 5.4 });
                levelsInRainfall.Add(new ParticulateLevel { Particulate = 110, Rainfall = 5.9 });
                levelsInRainfall.Add(new ParticulateLevel { Particulate = 114, Rainfall = 5.0 });
                levelsInRainfall.Add(new ParticulateLevel { Particulate = 128, Rainfall = 3.6 });
                levelsInRainfall.Add(new ParticulateLevel { Particulate = 137, Rainfall = 1.9 });
                levelsInRainfall.Add(new ParticulateLevel { Particulate = 104, Rainfall = 7.3 });
                return levelsInRainfall;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples.Common\BusinessObjects\MemberInfoData.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Reflection;
using System.Windows.Controls;
using System.Windows.Media;
using System.Windows.Media.Imaging;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// A wrapper type that can be used for visually displaying reflected type 
    /// information.
    /// </summary>
    public class MemberInfoData
    {
        /// <summary>
        /// Gets an enumerable set of PME information objects.
        /// </summary>
        /// <param name="type">The type to reflect over.</param>
        /// <returns>Returns the set of MemberInfoData objects.</returns>
        public static IEnumerable<MemberInfoData> GetSetForType(Type type)
        {
            MemberInfo[] members = type.GetMembers();
            if (members.Length > 0)
            {
                foreach (MemberInfo member in members)
                {
                    if (member.Name.Contains("get_") || member.Name.Contains("set_") || member.Name.Contains("add_") || member.Name.Contains("remove_"))
                    {
                        continue;
                    }

                    MemberInfoData pme = new MemberInfoData(member);
                    yield return pme;
                }
            }
            else
            {
                yield break;
            }
        }

        /// <summary>
        /// Initializes a new instance of the MemberInfoData class 
        /// with the provided MemberInfo object's data.
        /// </summary>
        /// <param name="mi">The member info object.</param>
        public MemberInfoData(MemberInfo mi)
        {
            MemberInfo = mi;
            Name = mi.Name;

            if (mi is PropertyInfo)
            {
                IconName = "Property.png";
            }

            MethodInfo methodInfo = mi as MethodInfo;
            if (methodInfo != null)
            {
                IconName = methodInfo.IsStatic ? "Static.png" : "Method.png";
            }

            if (mi is EventInfo)
            {
                IconName = "Event.png";
            }

            FieldInfo field = mi as FieldInfo;
            if (field != null)
            {
                IconName = "Static.png";
            }
        }

        /// <summary>
        /// Gets the member information object.
        /// </summary>
        public MemberInfo MemberInfo { get; private set; }

        /// <summary>
        /// Gets or sets the icon string name.
        /// </summary>
        private string IconName { get; set; }

        /// <summary>
        /// Gets the icon.
        /// </summary>
        public Image Icon
        {
            get
            {
                return IconName == null ? null : SharedResources.GetIcon(IconName);
            }
        }

        /// <summary>
        /// Gets or sets the name.
        /// </summary>
        public string Name { get; set; }

        /// <summary>
        /// Gets the foreground color based on method properties.
        /// </summary>
        public Brush ForegroundColor
        {
            get
            {
                Color c = MemberInfo.DeclaringType == MemberInfo.ReflectedType ? Colors.Black : Colors.DarkGray;
                return new SolidColorBrush(c);
            }
        }

        /// <summary>
        /// Overrides the ToString method to display the name.
        /// </summary>
        /// <returns>Returns the name as a string.</returns>
        public override string ToString()
        {
            return Name;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples.Common\BusinessObjects\PopularityPoll.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// A popularity poll for something, taken on a given date.
    /// </summary>
    public class PopularityPoll
    {
        /// <summary>
        /// Gets or sets the date on which the poll was taken.
        /// </summary>
        public DateTime Date { get; set; }

        /// <summary>
        /// Gets or sets the percentage of support the thing had.
        /// </summary>
        public double Percent { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples.Common\BusinessObjects\Feature.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Windows.Markup;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Represents a feature that can be installed.
    /// </summary>
    [ContentProperty("Subcomponents")]
    public class Feature : INotifyPropertyChanged
    {
        /// <summary>
        /// Initializes a new instance of the Feature class.
        /// </summary>
        public Feature()
        {
            Subcomponents = new Collection<Feature>();
            ShouldInstall = true;
        }

        /// <summary>
        /// Gets or sets the name of the feature.
        /// </summary>
        public string FeatureName { get; set; }

        /// <summary>
        /// Gets or sets the description of the feature.
        /// </summary>
        public string Description { get; set; }

        /// <summary>
        /// Gets a collection of sub-components that make up the feature.
        /// </summary>
        public Collection<Feature> Subcomponents { get; private set; }

        /// <summary>
        /// Gets a value indicating whether the feature has subcomponents.
        /// </summary>
        public bool HasSubcomponents
        {
            get
            {
                return Subcomponents.Count > 0;
            }
        }

        /// <summary>
        /// Backing variable for the ShouldInstall property.
        /// </summary>
        private bool? _shouldInstall;

        /// <summary>
        /// Gets or sets whether the feature should be installed.
        /// </summary>
        public bool? ShouldInstall
        {
            get
            {
                return _shouldInstall;
            }
            set
            {
                if (value != _shouldInstall)
                {
                    _shouldInstall = value;
                    OnPropertyChanged("ShouldInstall");
                }
            }
        }

        /// <summary>
        /// Implements the INotifyPropertyChanged interface.
        /// </summary>
        public event PropertyChangedEventHandler PropertyChanged;

        /// <summary>
        /// Fires the PropertyChanged event.
        /// </summary>
        /// <param name="propertyName">Property that changed.</param>
        private void OnPropertyChanged(string propertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (null != handler)
            {
                handler.Invoke(this, new PropertyChangedEventArgs(propertyName));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples.Common\BusinessObjects\Photograph.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Windows.Controls;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Photograph business object used in examples.
    /// </summary>
    public sealed partial class Photograph
    {
        /// <summary>
        /// Gets the name of the Photograph.
        /// </summary>
        public string Name { get; private set; }

        /// <summary>
        /// Gets an Image control containing the Photograph.
        /// </summary>
        public Image Image { get; private set; }

        /// <summary>
        /// Initializes a new instance of the Photograph class.
        /// </summary>
        /// <param name="resourceName">
        /// Name of the resource defining the photograph.
        /// </param>
        internal Photograph(string resourceName)
        {
            Name = resourceName;
            Image = SharedResources.GetImage(resourceName);
        }

        /// <summary>
        /// Overrides the string to return the name.
        /// </summary>
        /// <returns>Returns the photograph name.</returns>
        public override string ToString()
        {
            return Name;
        }

        /// <summary>
        /// Get all of the photographs defined in the assembly as embedded
        /// resources.
        /// </summary>
        /// <returns>
        /// All of the photographs defined in the assembly as embedded
        /// resources.
        /// </returns>
        [SuppressMessage("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate", Justification = "Doing more work than a property should")]
        public static IEnumerable<Photograph> GetPhotographs()
        {
            foreach (string resourceName in SharedResources.GetImageNames())
            {
                yield return new Photograph(resourceName);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples.Common\BusinessObjects\GizmoPopularityPollCollection.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Collections.Generic;
using System.Globalization;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Tracks the popularity of Gizmos.
    /// </summary>
    public class GizmoPopularityPollCollection : IEnumerable<PopularityPoll>
    {
        /// <summary>
        /// Returns a stream of popularity polls.
        /// </summary>
        /// <returns>A stream of popularity polls.</returns>
        public IEnumerator<PopularityPoll> GetEnumerator()
        {
            yield return new PopularityPoll { Date = DateTime.Parse("9/6/2008", CultureInfo.InvariantCulture), Percent = 44 };
            yield return new PopularityPoll { Date = DateTime.Parse("9/2/2008", CultureInfo.InvariantCulture), Percent = 49 };
            yield return new PopularityPoll { Date = DateTime.Parse("8/31/2008", CultureInfo.InvariantCulture), Percent = 50 };
            yield return new PopularityPoll { Date = DateTime.Parse("8/30/2008", CultureInfo.InvariantCulture), Percent = 48 };
            yield return new PopularityPoll { Date = DateTime.Parse("8/23/2008", CultureInfo.InvariantCulture), Percent = 47 };
            yield return new PopularityPoll { Date = DateTime.Parse("8/22/2008", CultureInfo.InvariantCulture), Percent = 48 };
            yield return new PopularityPoll { Date = DateTime.Parse("8/21/2008", CultureInfo.InvariantCulture), Percent = 49 };
            yield return new PopularityPoll { Date = DateTime.Parse("8/19/2008", CultureInfo.InvariantCulture), Percent = 42 };
            yield return new PopularityPoll { Date = DateTime.Parse("8/17/2008", CultureInfo.InvariantCulture), Percent = 45 };
            yield return new PopularityPoll { Date = DateTime.Parse("8/16/2008", CultureInfo.InvariantCulture), Percent = 45 };
            yield return new PopularityPoll { Date = DateTime.Parse("8/15/2008", CultureInfo.InvariantCulture), Percent = 47 };
            yield return new PopularityPoll { Date = DateTime.Parse("8/12/2008", CultureInfo.InvariantCulture), Percent = 46 };
            yield return new PopularityPoll { Date = DateTime.Parse("8/10/2008", CultureInfo.InvariantCulture), Percent = 46 };
            yield return new PopularityPoll { Date = DateTime.Parse("8/7/2008", CultureInfo.InvariantCulture), Percent = 43 };
            yield return new PopularityPoll { Date = DateTime.Parse("8/3/2008", CultureInfo.InvariantCulture), Percent = 45 };
            yield return new PopularityPoll { Date = DateTime.Parse("8/2/2008", CultureInfo.InvariantCulture), Percent = 47 };
            yield return new PopularityPoll { Date = DateTime.Parse("8/1/2008", CultureInfo.InvariantCulture), Percent = 46 };
            yield return new PopularityPoll { Date = DateTime.Parse("7/28/2008", CultureInfo.InvariantCulture), Percent = 51 };
            yield return new PopularityPoll { Date = DateTime.Parse("7/26/2008", CultureInfo.InvariantCulture), Percent = 45 };
            yield return new PopularityPoll { Date = DateTime.Parse("7/25/2008", CultureInfo.InvariantCulture), Percent = 47 };
            yield return new PopularityPoll { Date = DateTime.Parse("7/22/2008", CultureInfo.InvariantCulture), Percent = 41 };
            yield return new PopularityPoll { Date = DateTime.Parse("7/19/2008", CultureInfo.InvariantCulture), Percent = 47 };
            yield return new PopularityPoll { Date = DateTime.Parse("7/12/2008", CultureInfo.InvariantCulture), Percent = 49 };
            yield return new PopularityPoll { Date = DateTime.Parse("7/11/2008", CultureInfo.InvariantCulture), Percent = 50 };
            yield return new PopularityPoll { Date = DateTime.Parse("7/10/2008", CultureInfo.InvariantCulture), Percent = 44 };
            yield return new PopularityPoll { Date = DateTime.Parse("7/9/2008", CultureInfo.InvariantCulture), Percent = 40 };
        }

        /// <summary>
        /// Returns a stream of popularity polls.
        /// </summary>
        /// <returns>A stream of popularity polls.</returns>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return ((IEnumerable<PopularityPoll>)this).GetEnumerator();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples.Common\BusinessObjects\Music\Song.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.Windows.Controls;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Represents a music song.
    /// </summary>
    public class Song
    {
        /// <summary>
        /// Gets or sets the title of the Song.
        /// </summary>
        public string Title { get; set; }

        /// <summary>
        /// Gets or sets the length of the Song.
        /// </summary>
        public string Length { get; set; }

        /// <summary>
        /// Gets the icon.
        /// </summary>
        public static Image Icon
        {
            get
            {
                return SharedResources.GetIcon("Song.png");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples.Common\BusinessObjects\Taxonomy\Domain.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Represents a Domain in a Linnaean taxonomy.
    /// </summary>
    public sealed class Domain : Taxonomy
    {
        /// <summary>
        /// Initializes a new instance of the Domain class.
        /// </summary>
        public Domain()
            : base()
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples.Common\BusinessObjects\Taxonomy\Family.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Represents a Family in a Linnaean taxonomy.
    /// </summary>
    public sealed class Family : Taxonomy
    {
        /// <summary>
        /// Initializes a new instance of the Family class.
        /// </summary>
        public Family()
            : base()
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples.Common\BusinessObjects\Music\Artist.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Windows.Controls;
using System.Windows.Markup;
using System.Windows;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Represents a musical artist.
    /// </summary>
    [ContentProperty("Albums")]
    public class Artist
    {
        /// <summary>
        /// Gets or sets the name of the Artist.
        /// </summary>
        public string ArtistName { get; set; }

        /// <summary>
        /// Gets or sets the genre of the Artist.
        /// </summary>
        public string Genre { get; set; }

        /// <summary>
        /// Gets a collection of albums released by the Artist.
        /// </summary>
        public Collection<Album> Albums { get; private set; }

        /// <summary>
        /// Initializes a new instance of the Artist class.
        /// </summary>
        public Artist()
        {
            Albums = new Collection<Album>();
        }

        /// <summary>
        /// Gets the icon.
        /// </summary>
        public static Image Icon
        {
            get
            {
                return SharedResources.GetIcon("Artist.png");
            }
        }

        /// <summary>
        /// Gets a collection of artists.
        /// </summary>
        public static IEnumerable<Artist> AllArtists
        {
            get
            {
                IEnumerable<object> data = Application.Current.Resources["MusicCatalog"] as IEnumerable<object>;
                return (data != null) ?
                    data.OfType<Artist>() :
                    Enumerable.Empty<Artist>();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples.Common\BusinessObjects\WidgetPopularityPollCollection.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Collections.Generic;
using System.Globalization;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Tracks the popularity of widgets.
    /// </summary>
    public class WidgetPopularityPollCollection : IEnumerable<PopularityPoll>
    {
        /// <summary>
        /// Returns a stream of popularity polls.
        /// </summary>
        /// <returns>A stream of popularity polls.</returns>
        public IEnumerator<PopularityPoll> GetEnumerator()
        {
            yield return new PopularityPoll { Date = DateTime.Parse("9/6/2008", CultureInfo.InvariantCulture), Percent = 53 };
            yield return new PopularityPoll { Date = DateTime.Parse("9/2/2008", CultureInfo.InvariantCulture), Percent = 42 };
            yield return new PopularityPoll { Date = DateTime.Parse("8/31/2008", CultureInfo.InvariantCulture), Percent = 43 };
            yield return new PopularityPoll { Date = DateTime.Parse("8/30/2008", CultureInfo.InvariantCulture), Percent = 43 };
            yield return new PopularityPoll { Date = DateTime.Parse("8/23/2008", CultureInfo.InvariantCulture), Percent = 47 };
            yield return new PopularityPoll { Date = DateTime.Parse("8/22/2008", CultureInfo.InvariantCulture), Percent = 45 };
            yield return new PopularityPoll { Date = DateTime.Parse("8/21/2008", CultureInfo.InvariantCulture), Percent = 40 };
            yield return new PopularityPoll { Date = DateTime.Parse("8/19/2008", CultureInfo.InvariantCulture), Percent = 39 };
            yield return new PopularityPoll { Date = DateTime.Parse("8/17/2008", CultureInfo.InvariantCulture), Percent = 42 };
            yield return new PopularityPoll { Date = DateTime.Parse("8/16/2008", CultureInfo.InvariantCulture), Percent = 43 };
            yield return new PopularityPoll { Date = DateTime.Parse("8/15/2008", CultureInfo.InvariantCulture), Percent = 42 };
            yield return new PopularityPoll { Date = DateTime.Parse("8/12/2008", CultureInfo.InvariantCulture), Percent = 47 };
            yield return new PopularityPoll { Date = DateTime.Parse("8/10/2008", CultureInfo.InvariantCulture), Percent = 43 };
            yield return new PopularityPoll { Date = DateTime.Parse("8/7/2008", CultureInfo.InvariantCulture), Percent = 38 };
            yield return new PopularityPoll { Date = DateTime.Parse("8/3/2008", CultureInfo.InvariantCulture), Percent = 39 };
            yield return new PopularityPoll { Date = DateTime.Parse("8/2/2008", CultureInfo.InvariantCulture), Percent = 41 };
            yield return new PopularityPoll { Date = DateTime.Parse("8/1/2008", CultureInfo.InvariantCulture), Percent = 41 };
            yield return new PopularityPoll { Date = DateTime.Parse("7/28/2008", CultureInfo.InvariantCulture), Percent = 44 };
            yield return new PopularityPoll { Date = DateTime.Parse("7/26/2008", CultureInfo.InvariantCulture), Percent = 49 };
            yield return new PopularityPoll { Date = DateTime.Parse("7/25/2008", CultureInfo.InvariantCulture), Percent = 42 };
            yield return new PopularityPoll { Date = DateTime.Parse("7/22/2008", CultureInfo.InvariantCulture), Percent = 40 };
            yield return new PopularityPoll { Date = DateTime.Parse("7/19/2008", CultureInfo.InvariantCulture), Percent = 41 };
            yield return new PopularityPoll { Date = DateTime.Parse("7/12/2008", CultureInfo.InvariantCulture), Percent = 46 };
            yield return new PopularityPoll { Date = DateTime.Parse("7/11/2008", CultureInfo.InvariantCulture), Percent = 40 };
            yield return new PopularityPoll { Date = DateTime.Parse("7/10/2008", CultureInfo.InvariantCulture), Percent = 41 };
            yield return new PopularityPoll { Date = DateTime.Parse("7/9/2008", CultureInfo.InvariantCulture), Percent = 39 };
        }

        /// <summary>
        /// Returns a stream of popularity polls.
        /// </summary>
        /// <returns>A stream of popularity polls.</returns>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return ((IEnumerable<PopularityPoll>) this).GetEnumerator();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples.Common\BusinessObjects\Taxonomy\Class.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Diagnostics.CodeAnalysis;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Represents a Class in a Linnaean taxonomy.
    /// </summary>
    [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords", MessageId = "Class", Justification = "Will only be used from a C# sample.")]
    public sealed class Class : Taxonomy
    {
        /// <summary>
        /// Initializes a new instance of the Class class.
        /// </summary>
        public Class()
            : base()
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples.Common\BusinessObjects\Music\Album.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.Collections.ObjectModel;
using System.Windows.Controls;
using System.Windows.Markup;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Represents a music album.
    /// </summary>
    [ContentProperty("Songs")]
    public class Album
    {
        /// <summary>
        /// Gets or sets the title of the Album.
        /// </summary>
        public string Title { get; set; }

        /// <summary>
        /// Gets or sets the year the Album was released.
        /// </summary>
        public string ReleaseYear { get; set; }

        /// <summary>
        /// Gets the icon.
        /// </summary>
        public static Image Icon
        {
            get
            {
                return SharedResources.GetIcon("Album.png");
            }
        }

        /// <summary>
        /// Gets a collection of songs contained in the Album.
        /// </summary>
        public Collection<Song> Songs { get; private set; }

        /// <summary>
        /// Initializes a new instance of the Album class.
        /// </summary>
        public Album()
        {
            Songs = new Collection<Song>();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples.Common\BusinessObjects\Words.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Collections;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// A set of words to use in control samples.
    /// </summary>
    public static class Words
    {
        /// <summary>
        /// Gets a list of words from the book Alice in Wonderland.
        /// </summary>
        /// <returns>Returns a very large string array.</returns>
        public static string[] GetAliceInWonderland()
        {
            return AliceInWonderland;
        }

        /// <summary>
        /// A static string array of words.
        /// </summary>
        private static readonly string[] AliceInWonderland =
        {
            "a", 
            "abide", 
            "able", 
            "about", 
            "above", 
            "absence", 
            "absurd", 
            "accept", 
            "acceptance", 
            "accepted", 
            "accepting", 
            "access", 
            "accessed", 
            "accessible", 
            "accident", 
            "accidentally", 
            "accordance", 
            "account", 
            "accounting", 
            "accounts", 
            "accusation", 
            "accustomed", 
            "ache", 
            "across", 
            "act", 
            "active", 
            "actual", 
            "actually", 
            "ada", 
            "added", 
            "adding", 
            "addition", 
            "additional", 
            "additions", 
            "address", 
            "addressed", 
            "addresses", 
            "addressing", 
            "adjourn", 
            "adoption", 
            "advance", 
            "advantage", 
            "adventures", 
            "advice", 
            "advisable", 
            "advise", 
            "affair", 
            "affectionately", 
            "afford", 
            "afore", 
            "afraid", 
            "after", 
            "afterwards", 
            "again", 
            "against", 
            "age", 
            "aged", 
            "agent", 
            "ago", 
            "agony", 
            "agree", 
            "agreed", 
            "agreement", 
            "ah", 
            "ahem", 
            "air", 
            "airs", 
            "ak", 
            "alarm", 
            "alarmed", 
            "alas", 
            "alice", 
            "alive", 
            "all", 
            "allow", 
            "almost", 
            "alone", 
            "along", 
            "aloud", 
            "already", 
            "also", 
            "alteration", 
            "altered", 
            "alternate", 
            "alternately", 
            "altogether", 
            "always", 
            "am", 
            "ambition", 
            "among", 
            "an", 
            "ancient", 
            "and", 
            "anger", 
            "angrily", 
            "angry", 
            "animal", 
            "animals", 
            "ann", 
            "annoy", 
            "annoyed", 
            "another", 
            "answer", 
            "answered", 
            "answers", 
            "antipathies", 
            "anxious", 
            "anxiously", 
            "any", 
            "anyone", 
            "anything", 
            "anywhere", 
            "appealed", 
            "appear", 
            "appearance", 
            "appeared", 
            "appearing", 
            "appears", 
            "applause", 
            "apple", 
            "apples", 
            "applicable", 
            "apply", 
            "approach", 
            "arch", 
            "archbishop", 
            "arches", 
            "archive", 
            "are", 
            "argue", 
            "argued", 
            "argument", 
            "arguments", 
            "arise", 
            "arithmetic", 
            "arm", 
            "arms", 
            "around", 
            "arranged", 
            "array", 
            "arrived", 
            "arrow", 
            "arrum", 
            "as", 
            "ascii", 
            "ashamed", 
            "ask", 
            "askance", 
            "asked", 
            "asking", 
            "asleep", 
            "assembled", 
            "assistance", 
            "associated", 
            "at", 
            "ate", 
            "atheling", 
            "atom", 
            "attached", 
            "attempt", 
            "attempted", 
            "attempts", 
            "attended", 
            "attending", 
            "attends", 
            "audibly", 
            "australia", 
            "author", 
            "authority", 
            "available", 
            "avoid", 
            "away", 
            "awfully", 
            "axes", 
            "axis", 
            "b", 
            "baby", 
            "back", 
            "backs", 
            "bad", 
            "bag", 
            "baked", 
            "balanced", 
            "bank", 
            "banks", 
            "banquet", 
            "bark", 
            "barking", 
            "barley", 
            "barrowful", 
            "based", 
            "bat", 
            "bathing", 
            "bats", 
            "bawled", 
            "be", 
            "beak", 
            "bear", 
            "beast", 
            "beasts", 
            "beat", 
            "beating", 
            "beau", 
            "beauti", 
            "beautiful", 
            "beautifully", 
            "beautify", 
            "became", 
            "because", 
            "become", 
            "becoming", 
            "bed", 
            "beds", 
            "bee", 
            "been", 
            "before", 
            "beg", 
            "began", 
            "begged", 
            "begin", 
            "beginning", 
            "begins", 
            "begun", 
            "behead", 
            "beheaded", 
            "beheading", 
            "behind", 
            "being", 
            "believe", 
            "believed", 
            "bells", 
            "belong", 
            "belongs", 
            "beloved", 
            "below", 
            "belt", 
            "bend", 
            "bent", 
            "besides", 
            "best", 
            "better", 
            "between", 
            "bill", 
            "binary", 
            "bird", 
            "birds", 
            "birthday", 
            "bit", 
            "bite", 
            "bitter", 
            "blacking", 
            "blades", 
            "blame", 
            "blasts", 
            "bleeds", 
            "blew", 
            "blow", 
            "blown", 
            "blows", 
            "body", 
            "boldly", 
            "bone", 
            "bones", 
            "book", 
            "books", 
            "boon", 
            "boots", 
            "bore", 
            "both", 
            "bother", 
            "bottle", 
            "bottom", 
            "bough", 
            "bound", 
            "bowed", 
            "bowing", 
            "box", 
            "boxed", 
            "boy", 
            "brain", 
            "branch", 
            "branches", 
            "brandy", 
            "brass", 
            "brave", 
            "breach", 
            "bread", 
            "break", 
            "breath", 
            "breathe", 
            "breeze", 
            "bright", 
            "brightened", 
            "bring", 
            "bringing", 
            "bristling", 
            "broke", 
            "broken", 
            "brother", 
            "brought", 
            "brown", 
            "brush", 
            "brushing", 
            "burn", 
            "burning", 
            "burnt", 
            "burst", 
            "bursting", 
            "busily", 
            "business", 
            "business@pglaf", 
            "busy", 
            "but", 
            "butter", 
            "buttercup", 
            "buttered", 
            "butterfly", 
            "buttons", 
            "by", 
            "bye", 
            "c", 
            "cackled", 
            "cake", 
            "cakes", 
            "calculate", 
            "calculated", 
            "call", 
            "called", 
            "calling", 
            "calmly", 
            "came", 
            "camomile", 
            "can", 
            "canary", 
            "candle", 
            "cannot", 
            "canterbury", 
            "canvas", 
            "capering", 
            "capital", 
            "card", 
            "cardboard", 
            "cards", 
            "care", 
            "carefully", 
            "cares", 
            "carried", 
            "carrier", 
            "carroll", 
            "carry", 
            "carrying", 
            "cart", 
            "cartwheels", 
            "case", 
            "cat", 
            "catch", 
            "catching", 
            "caterpillar", 
            "cats", 
            "cattle", 
            "caucus", 
            "caught", 
            "cauldron", 
            "cause", 
            "caused", 
            "cautiously", 
            "cease", 
            "ceiling", 
            "centre", 
            "certain", 
            "certainly", 
            "chain", 
            "chains", 
            "chair", 
            "chance", 
            "chanced", 
            "change", 
            "changed", 
            "changes", 
            "changing", 
            "chapter", 
            "character", 
            "charge", 
            "charges", 
            "charitable", 
            "charities", 
            "chatte", 
            "cheap", 
            "cheated", 
            "check", 
            "checked", 
            "checks", 
            "cheeks", 
            "cheered", 
            "cheerfully", 
            "cherry", 
            "cheshire", 
            "chief", 
            "child", 
            "childhood", 
            "children", 
            "chimney", 
            "chimneys", 
            "chin", 
            "choice", 
            "choke", 
            "choked", 
            "choking", 
            "choose", 
            "choosing", 
            "chop", 
            "chorus", 
            "chose", 
            "christmas", 
            "chrysalis", 
            "chuckled", 
            "circle", 
            "circumstances", 
            "city", 
            "civil", 
            "claim", 
            "clamour", 
            "clapping", 
            "clasped", 
            "classics", 
            "claws", 
            "clean", 
            "clear", 
            "cleared", 
            "clearer", 
            "clearly", 
            "clever", 
            "climb", 
            "clinging", 
            "clock", 
            "close", 
            "closed", 
            "closely", 
            "closer", 
            "clubs", 
            "coast", 
            "coaxing", 
            "codes", 
            "coils", 
            "cold", 
            "collar", 
            "collected", 
            "collection", 
            "come", 
            "comes", 
            "comfits", 
            "comfort", 
            "comfortable", 
            "comfortably", 
            "coming", 
            "commercial", 
            "committed", 
            "common", 
            "commotion", 
            "company", 
            "compilation", 
            "complained", 
            "complaining", 
            "completely", 
            "compliance", 
            "comply", 
            "complying", 
            "compressed", 
            "computer", 
            "computers", 
            "concept", 
            "concerning", 
            "concert", 
            "concluded", 
            "conclusion", 
            "condemn", 
            "conduct", 
            "confirmation", 
            "confirmed", 
            "confused", 
            "confusing", 
            "confusion", 
            "conger", 
            "conqueror", 
            "conquest", 
            "consented", 
            "consequential", 
            "consider", 
            "considerable", 
            "considered", 
            "considering", 
            "constant", 
            "consultation", 
            "contact", 
            "contain", 
            "containing", 
            "contempt", 
            "contemptuous", 
            "contemptuously", 
            "content", 
            "continued", 
            "contract", 
            "contradicted", 
            "contributions", 
            "conversation", 
            "conversations", 
            "convert", 
            "cook", 
            "cool", 
            "copied", 
            "copies", 
            "copy", 
            "copying", 
            "copyright", 
            "corner", 
            "corners", 
            "corporation", 
            "corrupt", 
            "cost", 
            "costs", 
            "could", 
            "couldn", 
            "counting", 
            "countries", 
            "country", 
            "couple", 
            "couples", 
            "courage", 
            "course", 
            "court", 
            "courtiers", 
            "coward", 
            "crab", 
            "crash", 
            "crashed", 
            "crawled", 
            "crawling", 
            "crazy", 
            "created", 
            "creating", 
            "creation", 
            "creature", 
            "creatures", 
            "credit", 
            "creep", 
            "crept", 
            "cried", 
            "cries", 
            "crimson", 
            "critical", 
            "crocodile", 
            "croquet", 
            "croqueted", 
            "croqueting", 
            "cross", 
            "crossed", 
            "crossly", 
            "crouched", 
            "crowd", 
            "crowded", 
            "crown", 
            "crumbs", 
            "crust", 
            "cry", 
            "crying", 
            "cucumber", 
            "cunning", 
            "cup", 
            "cupboards", 
            "cur", 
            "curiosity", 
            "curious", 
            "curiouser", 
            "curled", 
            "curls", 
            "curly", 
            "currants", 
            "current", 
            "curtain", 
            "curtsey", 
            "curtseying", 
            "curving", 
            "cushion", 
            "custard", 
            "custody", 
            "cut", 
            "cutting", 
            "d", 
            "dainties", 
            "daisies", 
            "daisy", 
            "damage", 
            "damaged", 
            "damages", 
            "dance", 
            "dancing", 
            "dare", 
            "daresay", 
            "dark", 
            "darkness", 
            "data", 
            "date", 
            "dates", 
            "daughter", 
            "day", 
            "days", 
            "dead", 
            "deal", 
            "dear", 
            "dears", 
            "death", 
            "decided", 
            "decidedly", 
            "declare", 
            "declared", 
            "deductible", 
            "deep", 
            "deepest", 
            "deeply", 
            "defect", 
            "defective", 
            "defects", 
            "delay", 
            "deletions", 
            "delight", 
            "delighted", 
            "delightful", 
            "demand", 
            "denial", 
            "denied", 
            "denies", 
            "deny", 
            "denying", 
            "depends", 
            "derision", 
            "derivative", 
            "derive", 
            "derived", 
            "described", 
            "deserved", 
            "desk", 
            "desks", 
            "despair", 
            "desperate", 
            "desperately", 
            "despite", 
            "destroy", 
            "detach", 
            "determine", 
            "diamonds", 
            "did", 
            "didn", 
            "die", 
            "died", 
            "different", 
            "difficult", 
            "difficulties", 
            "difficulty", 
            "dig", 
            "digging", 
            "diligently", 
            "dinah", 
            "dinn", 
            "dinner", 
            "dipped", 
            "direct", 
            "directed", 
            "direction", 
            "directions", 
            "directly", 
            "director", 
            "disagree", 
            "disappeared", 
            "disappointment", 
            "disclaim", 
            "disclaimer", 
            "disclaimers", 
            "discontinue", 
            "discover", 
            "discovered", 
            "disgust", 
            "dish", 
            "dishes", 
            "disk", 
            "dismay", 
            "disobey", 
            "display", 
            "displayed", 
            "displaying", 
            "dispute", 
            "distance", 
            "distant", 
            "distraction", 
            "distribute", 
            "distributed", 
            "distributing", 
            "distribution", 
            "distributor", 
            "dive", 
            "do", 
            "dodged", 
            "dodo", 
            "does", 
            "doesn", 
            "dog", 
            "dogs", 
            "doing", 
            "domain", 
            "don", 
            "donate", 
            "donation", 
            "donations", 
            "done", 
            "donors", 
            "door", 
            "doors", 
            "doorway", 
            "dormouse", 
            "doth", 
            "double", 
            "doubled", 
            "doubling", 
            "doubt", 
            "doubtful", 
            "doubtfully", 
            "down", 
            "downloading", 
            "downward", 
            "downwards", 
            "doze", 
            "dozing", 
            "dr", 
            "draggled", 
            "draw", 
            "drawing", 
            "drawling", 
            "dreadful", 
            "dreadfully", 
            "dream", 
            "dreamed", 
            "dreaming", 
            "dreamy", 
            "dressed", 
            "drew", 
            "dried", 
            "driest", 
            "drink", 
            "drinking", 
            "dripping", 
            "drive", 
            "drop", 
            "dropped", 
            "dropping", 
            "drowned", 
            "drunk", 
            "dry", 
            "duchess", 
            "duck", 
            "dull", 
            "dunce", 
            "e", 
            "each", 
            "eager", 
            "eagerly", 
            "eaglet", 
            "ear", 
            "earls", 
            "earnestly", 
            "ears", 
            "earth", 
            "easily", 
            "easy", 
            "eat", 
            "eaten", 
            "eating", 
            "eats", 
            "ebook", 
            "ebooks", 
            "edgar", 
            "edge", 
            "edition", 
            "editions", 
            "educational", 
            "educations", 
            "edwin", 
            "eel", 
            "eels", 
            "effect", 
            "effort", 
            "efforts", 
            "egg", 
            "eggs", 
            "eh", 
            "ein", 
            "either", 
            "elbow", 
            "elbows", 
            "elect", 
            "electronic", 
            "electronically", 
            "elegant", 
            "eleventh", 
            "else", 
            "elsie", 
            "em", 
            "email", 
            "emphasis", 
            "employee", 
            "employees", 
            "empty", 
            "encoding", 
            "encourage", 
            "encouraged", 
            "encouraging", 
            "end", 
            "ending", 
            "energetic", 
            "engaged", 
            "engine", 
            "england", 
            "english", 
            "engraved", 
            "enjoy", 
            "enormous", 
            "enough", 
            "ensuring", 
            "entangled", 
            "entirely", 
            "entity", 
            "entrance", 
            "equipment", 
            "errors", 
            "escape", 
            "especially", 
            "esq", 
            "est", 
            "even", 
            "evening", 
            "ever", 
            "every", 
            "everybody", 
            "everything", 
            "evidence", 
            "evidently", 
            "exact", 
            "exactly", 
            "examine", 
            "examining", 
            "excellent", 
            "except", 
            "exclaimed", 
            "exclamation", 
            "exclusion", 
            "execute", 
            "executed", 
            "executes", 
            "execution", 
            "executioner", 
            "executions", 
            "executive", 
            "exempt", 
            "existence", 
            "exists", 
            "expected", 
            "expecting", 
            "expend", 
            "expense", 
            "expenses", 
            "experiment", 
            "explain", 
            "explained", 
            "explanation", 
            "explanations", 
            "exporting", 
            "express", 
            "expressing", 
            "expression", 
            "extent", 
            "extra", 
            "extraordinary", 
            "extras", 
            "extremely", 
            "eye", 
            "eyed", 
            "eyelids", 
            "eyes", 
            "f", 
            "face", 
            "faces", 
            "facility", 
            "fact", 
            "fading", 
            "failure", 
            "faint", 
            "fainting", 
            "faintly", 
            "fair", 
            "fairbanks", 
            "fairly", 
            "fall", 
            "fallen", 
            "falling", 
            "familiarly", 
            "family", 
            "fan", 
            "fancied", 
            "fancy", 
            "fancying", 
            "fanned", 
            "fanning", 
            "far", 
            "farm", 
            "farmer", 
            "farther", 
            "fashion", 
            "fast", 
            "faster", 
            "fat", 
            "father", 
            "favoured", 
            "favourite", 
            "fear", 
            "feared", 
            "feather", 
            "feathers", 
            "federal", 
            "fee", 
            "feeble", 
            "feebly", 
            "feel", 
            "feeling", 
            "feelings", 
            "fees", 
            "feet", 
            "fell", 
            "fellow", 
            "fellows", 
            "felt", 
            "fender", 
            "ferrets", 
            "fetch", 
            "few", 
            "fidgeted", 
            "field", 
            "fifteen", 
            "fifteenth", 
            "fifth", 
            "fig", 
            "fight", 
            "fighting", 
            "figure", 
            "figures", 
            "file", 
            "files", 
            "filled", 
            "fills", 
            "financial", 
            "find", 
            "finding", 
            "finds", 
            "fine", 
            "finger", 
            "finish", 
            "finished", 
            "finishing", 
            "fire", 
            "fireplace", 
            "first", 
            "fish", 
            "fishes", 
            "fit", 
            "fitness", 
            "fits", 
            "fitted", 
            "five", 
            "fix", 
            "fixed", 
            "flame", 
            "flamingo", 
            "flamingoes", 
            "flapper", 
            "flappers", 
            "flashed", 
            "flat", 
            "flavour", 
            "flew", 
            "flinging", 
            "flock", 
            "floor", 
            "flower", 
            "flowers", 
            "flown", 
            "flung", 
            "flurry", 
            "flustered", 
            "fluttered", 
            "fly", 
            "flying", 
            "folded", 
            "folding", 
            "follow", 
            "followed", 
            "following", 
            "follows", 
            "fond", 
            "foolish", 
            "foot", 
            "footman", 
            "footmen", 
            "footsteps", 
            "for", 
            "forehead", 
            "forepaws", 
            "forget", 
            "forgetting", 
            "forgot", 
            "forgotten", 
            "fork", 
            "form", 
            "format", 
            "formats", 
            "forth", 
            "fortunately", 
            "forty", 
            "forwards", 
            "found", 
            "foundation", 
            "fountains", 
            "four", 
            "fourteenth", 
            "fourth", 
            "frame", 
            "frames", 
            "france", 
            "free", 
            "freely", 
            "french", 
            "friend", 
            "friends", 
            "fright", 
            "frighten", 
            "frightened", 
            "from", 
            "front", 
            "frontispiece", 
            "frowning", 
            "frying", 
            "ful", 
            "fulcrum", 
            "full", 
            "fumbled", 
            "fun", 
            "fundraising", 
            "funny", 
            "fur", 
            "furious", 
            "furiously", 
            "furrow", 
            "furrows", 
            "further", 
            "fury", 
            "future", 
            "gained", 
            "gallons", 
            "game", 
            "games", 
            "garden", 
            "gardeners", 
            "gather", 
            "gave", 
            "gay", 
            "gazing", 
            "gbnewby@pglaf", 
            "general", 
            "generally", 
            "generations", 
            "gently", 
            "geography", 
            "get", 
            "getting", 
            "giddy", 
            "girl", 
            "girls", 
            "give", 
            "given", 
            "giving", 
            "glad", 
            "glanced", 
            "glaring", 
            "glass", 
            "globe", 
            "gloomily", 
            "gloves", 
            "go", 
            "goals", 
            "goes", 
            "going", 
            "golden", 
            "goldfish", 
            "gone", 
            "good", 
            "goose", 
            "got", 
            "govern", 
            "graceful", 
            "grammar", 
            "grand", 
            "grant", 
            "granted", 
            "grass", 
            "gratefully", 
            "grave", 
            "gravely", 
            "gravy", 
            "grazed", 
            "great", 
            "green", 
            "gregory", 
            "grew", 
            "grey", 
            "grief", 
            "grin", 
            "grinned", 
            "grinning", 
            "grins", 
            "gross", 
            "ground", 
            "group", 
            "grow", 
            "growing", 
            "growl", 
            "growled", 
            "growling", 
            "growls", 
            "grown", 
            "grumbled", 
            "grunt", 
            "grunted", 
            "gryphon", 
            "guard", 
            "guess", 
            "guessed", 
            "guests", 
            "guilt", 
            "guinea", 
            "gutenberg", 
            "had", 
            "hadn", 
            "hair", 
            "half", 
            "hall", 
            "hand", 
            "handed", 
            "hands", 
            "handsome", 
            "handwriting", 
            "hanging", 
            "happen", 
            "happened", 
            "happening", 
            "happens", 
            "happy", 
            "hard", 
            "hardly", 
            "hare", 
            "harm", 
            "harmless", 
            "hart", 
            "has", 
            "hasn", 
            "haste", 
            "hastily", 
            "hat", 
            "hatching", 
            "hate", 
            "hated", 
            "hatter", 
            "hatters", 
            "have", 
            "haven", 
            "having", 
            "he", 
            "head", 
            "heads", 
            "heap", 
            "hear", 
            "heard", 
            "hearing", 
            "heart", 
            "hearth", 
            "hearthrug", 
            "hearts", 
            "heavy", 
            "hedge", 
            "hedgehog", 
            "hedgehogs", 
            "hedges", 
            "heels", 
            "height", 
            "held", 
            "help", 
            "helped", 
            "helpless", 
            "her", 
            "herald", 
            "here", 
            "hers", 
            "herself", 
            "hid", 
            "hide", 
            "high", 
            "highest", 
            "him", 
            "himself", 
            "hint", 
            "hippopotamus", 
            "his", 
            "hiss", 
            "histories", 
            "history", 
            "hit", 
            "hjckrrh", 
            "hm", 
            "hoarse", 
            "hoarsely", 
            "hold", 
            "holder", 
            "holding", 
            "hole", 
            "holiday", 
            "hollow", 
            "home", 
            "honest", 
            "honour", 
            "hookah", 
            "hope", 
            "hoped", 
            "hopeful", 
            "hopeless", 
            "hoping", 
            "horse", 
            "hot", 
            "hour", 
            "hours", 
            "house", 
            "housemaid", 
            "houses", 
            "how", 
            "however", 
            "howled", 
            "howling", 
            "http", 
            "humble", 
            "humbly", 
            "hundred", 
            "hundreds", 
            "hung", 
            "hungry", 
            "hunting", 
            "hurried", 
            "hurriedly", 
            "hurry", 
            "hurrying", 
            "hurt", 
            "hush", 
            "hypertext", 
            "i", 
            "idea", 
            "identification", 
            "identify", 
            "idiotic", 
            "if", 
            "ignorant", 
            "ii", 
            "iii", 
            "ill", 
            "imagine", 
            "imitated", 
            "immediate", 
            "immediately", 
            "immense", 
            "impatient", 
            "impatiently", 
            "impertinent", 
            "implied", 
            "important", 
            "imposed", 
            "impossible", 
            "improve", 
            "in", 
            "inaccurate", 
            "incessantly", 
            "inches", 
            "incidental", 
            "inclined", 
            "include", 
            "included", 
            "includes", 
            "including", 
            "incomplete", 
            "increasing", 
            "indeed", 
            "indemnify", 
            "indemnity", 
            "indicate", 
            "indicating", 
            "indignant", 
            "indignantly", 
            "indirect", 
            "indirectly", 
            "individual", 
            "information", 
            "infringement", 
            "injure", 
            "ink", 
            "inkstand", 
            "inquired", 
            "inquisitively", 
            "inside", 
            "insolence", 
            "instance", 
            "instantly", 
            "instead", 
            "insult", 
            "intellectual", 
            "interest", 
            "interesting", 
            "internal", 
            "international", 
            "interpreted", 
            "interrupt", 
            "interrupted", 
            "interrupting", 
            "into", 
            "introduce", 
            "introduced", 
            "invalidity", 
            "invent", 
            "invented", 
            "invitation", 
            "invited", 
            "involved", 
            "inwards", 
            "irons", 
            "irritated", 
            "irs", 
            "is", 
            "isn", 
            "it", 
            "its", 
            "itself", 
            "iv", 
            "ix", 
            "jack", 
            "jar", 
            "jaw", 
            "jaws", 
            "jelly", 
            "jogged", 
            "join", 
            "joined", 
            "journey", 
            "joys", 
            "judge", 
            "judging", 
            "jug", 
            "jumped", 
            "jumping", 
            "june", 
            "juror", 
            "jurors", 
            "jury", 
            "jurymen", 
            "just", 
            "justice", 
            "keep", 
            "keeping", 
            "kept", 
            "kettle", 
            "key", 
            "kick", 
            "kid", 
            "kill", 
            "killing", 
            "kills", 
            "kind", 
            "kindly", 
            "king", 
            "kings", 
            "kiss", 
            "kissed", 
            "kitchen", 
            "knave", 
            "knee", 
            "kneel", 
            "knelt", 
            "knew", 
            "knife", 
            "knock", 
            "knocked", 
            "knocking", 
            "knot", 
            "know", 
            "knowing", 
            "knowledge", 
            "known", 
            "knows", 
            "knuckles", 
            "label", 
            "labelled", 
            "lacie", 
            "lad", 
            "ladder", 
            "lady", 
            "laid", 
            "lake", 
            "lamps", 
            "land", 
            "language", 
            "languid", 
            "lap", 
            "large", 
            "larger", 
            "largest", 
            "lark", 
            "last", 
            "lasted", 
            "lastly", 
            "late", 
            "lately", 
            "later", 
            "latin", 
            "latitude", 
            "laugh", 
            "laughed", 
            "laughing", 
            "laughter", 
            "law", 
            "laws", 
            "lay", 
            "lazily", 
            "lazy", 
            "leaders", 
            "leading", 
            "leaning", 
            "leant", 
            "leap", 
            "learn", 
            "learned", 
            "learning", 
            "learnt", 
            "least", 
            "leave", 
            "leaves", 
            "leaving", 
            "led", 
            "ledge", 
            "left", 
            "lefthand", 
            "legal", 
            "legally", 
            "legged", 
            "legs", 
            "length", 
            "less", 
            "lessen", 
            "lesson", 
            "lessons", 
            "lest", 
            "let", 
            "letter", 
            "letters", 
            "lewis", 
            "liability", 
            "liable", 
            "library", 
            "license", 
            "licensed", 
            "licking", 
            "lie", 
            "lieu", 
            "life", 
            "lifted", 
            "like", 
            "liked", 
            "likely", 
            "likes", 
            "limbs", 
            "limitation", 
            "limited", 
            "line", 
            "lines", 
            "linked", 
            "links", 
            "lips", 
            "list", 
            "listen", 
            "listened", 
            "listeners", 
            "listening", 
            "lit", 
            "literary", 
            "little", 
            "live", 
            "lived", 
            "livery", 
            "lives", 
            "living", 
            "lizard", 
            "ll", 
            "lobster", 
            "lobsters", 
            "located", 
            "locations", 
            "lock", 
            "locked", 
            "locks", 
            "lodging", 
            "london", 
            "lonely", 
            "long", 
            "longed", 
            "longer", 
            "longitude", 
            "look", 
            "looked", 
            "looking", 
            "loose", 
            "lory", 
            "lose", 
            "losing", 
            "lost", 
            "lot", 
            "loud", 
            "louder", 
            "loudly", 
            "love", 
            "loveliest", 
            "lovely", 
            "loving", 
            "low", 
            "lower", 
            "lowing", 
            "luckily", 
            "lullaby", 
            "lying", 
            "m", 
            "ma", 
            "mabel", 
            "machine", 
            "machines", 
            "mad", 
            "made", 
            "magic", 
            "magpie", 
            "mail", 
            "main", 
            "maintaining", 
            "majesty", 
            "make", 
            "makes", 
            "making", 
            "mallets", 
            "man", 
            "manage", 
            "managed", 
            "managing", 
            "manner", 
            "manners", 
            "many", 
            "maps", 
            "march", 
            "marched", 
            "mark", 
            "marked", 
            "marmalade", 
            "mary", 
            "master", 
            "matter", 
            "matters", 
            "maximum", 
            "may", 
            "maybe", 
            "mayn", 
            "me", 
            "meal", 
            "mean", 
            "meaning", 
            "means", 
            "meant", 
            "meanwhile", 
            "measure", 
            "meat", 
            "medium", 
            "meekly", 
            "meet", 
            "meeting", 
            "melan", 
            "melancholy", 
            "memorandum", 
            "memory", 
            "men", 
            "mentioned", 
            "merchantibility", 
            "mercia", 
            "merely", 
            "merrily", 
            "messages", 
            "met", 
            "method", 
            "methods", 
            "mice", 
            "michael", 
            "middle", 
            "might", 
            "mile", 
            "miles", 
            "milk", 
            "millennium", 
            "mind", 
            "minded", 
            "minding", 
            "mine", 
            "mineral", 
            "minute", 
            "minutes", 
            "mischief", 
            "miserable", 
            "miss", 
            "missed", 
            "mission", 
            "mississippi", 
            "mistake", 
            "mixed", 
            "mock", 
            "moderate", 
            "modern", 
            "modification", 
            "modified", 
            "moment", 
            "money", 
            "month", 
            "moon", 
            "moral", 
            "morals", 
            "morcar", 
            "more", 
            "morning", 
            "morsel", 
            "most", 
            "mostly", 
            "mournful", 
            "mournfully", 
            "mouse", 
            "mouth", 
            "mouths", 
            "move", 
            "moved", 
            "moving", 
            "much", 
            "muchness", 
            "muddle", 
            "multiplication", 
            "murder", 
            "murdering", 
            "muscular", 
            "mushroom", 
            "music", 
            "must", 
            "mustard", 
            "muttered", 
            "muttering", 
            "my", 
            "myself", 
            "mystery", 
            "name", 
            "named", 
            "names", 
            "narrow", 
            "nasty", 
            "natural", 
            "natured", 
            "naturedly", 
            "nay", 
            "near", 
            "nearer", 
            "nearly", 
            "neat", 
            "neatly", 
            "necessarily", 
            "neck", 
            "need", 
            "needn", 
            "needs", 
            "negligence", 
            "neighbour", 
            "neighbouring", 
            "neither", 
            "nervous", 
            "nest", 
            "network", 
            "never", 
            "nevertheless", 
            "new", 
            "newby", 
            "newsletter", 
            "newspapers", 
            "next", 
            "nibbled", 
            "nibbling", 
            "nice", 
            "nicely", 
            "night", 
            "nile", 
            "nine", 
            "no", 
            "nobody", 
            "nodded", 
            "noise", 
            "noises", 
            "non", 
            "none", 
            "nonproprietary", 
            "nonsense", 
            "nor", 
            "normans", 
            "north", 
            "northumbria", 
            "nose", 
            "not", 
            "note", 
            "nothing", 
            "notice", 
            "noticed", 
            "noticing", 
            "notifies", 
            "notion", 
            "now", 
            "nowhere", 
            "number", 
            "numerous", 
            "nurse", 
            "nursing", 
            "o", 
            "obliged", 
            "oblong", 
            "obsolete", 
            "obstacle", 
            "obtain", 
            "obtaining", 
            "occasional", 
            "occasionally", 
            "occur", 
            "occurred", 
            "odd", 
            "of", 
            "off", 
            "offend", 
            "offended", 
            "offer", 
            "offers", 
            "office", 
            "officer", 
            "officers", 
            "official", 
            "often", 
            "oh", 
            "ointment", 
            "old", 
            "older", 
            "oldest", 
            "on", 
            "once", 
            "one", 
            "ones", 
            "oneself", 
            "onions", 
            "online", 
            "only", 
            "oop", 
            "ootiful", 
            "open", 
            "opened", 
            "opening", 
            "opinion", 
            "opportunities", 
            "opportunity", 
            "opposite", 
            "or", 
            "orange", 
            "order", 
            "ordered", 
            "ordering", 
            "org", 
            "organized", 
            "original", 
            "originator", 
            "ornamented", 
            "other", 
            "others", 
            "otherwise", 
            "ou", 
            "ought", 
            "our", 
            "ours", 
            "ourselves", 
            "out", 
            "outdated", 
            "outside", 
            "over", 
            "overcome", 
            "overhead", 
            "owed", 
            "owl", 
            "own", 
            "owner", 
            "owns", 
            "oyster", 
            "pace", 
            "pack", 
            "page", 
            "pages", 
            "paid", 
            "paint", 
            "painting", 
            "pair", 
            "pairs", 
            "pale", 
            "pan", 
            "panted", 
            "panther", 
            "panting", 
            "paper", 
            "paperwork", 
            "paragraph", 
            "paragraphs", 
            "parchment", 
            "pardon", 
            "pardoned", 
            "paris", 
            "part", 
            "particular", 
            "particularly", 
            "partner", 
            "partners", 
            "parts", 
            "party", 
            "pass", 
            "passage", 
            "passed", 
            "passing", 
            "passion", 
            "passionate", 
            "past", 
            "pat", 
            "patience", 
            "patiently", 
            "patriotic", 
            "patted", 
            "pattering", 
            "pattern", 
            "pause", 
            "paused", 
            "paw", 
            "paws", 
            "pay", 
            "paying", 
            "payments", 
            "pebbles", 
            "peeped", 
            "peeping", 
            "peering", 
            "pegs", 
            "pence", 
            "pencil", 
            "pencils", 
            "pennyworth", 
            "people", 
            "pepper", 
            "perfectly", 
            "perform", 
            "performances", 
            "performed", 
            "performing", 
            "perhaps", 
            "periodic", 
            "permanent", 
            "permission", 
            "permitted", 
            "persisted", 
            "person", 
            "personal", 
            "persons", 
            "pet", 
            "pg", 
            "pglaf", 
            "phrase", 
            "physical", 
            "picked", 
            "picking", 
            "picture", 
            "pictured", 
            "pictures", 
            "pie", 
            "piece", 
            "pieces", 
            "pig", 
            "pigeon", 
            "pigs", 
            "pinch", 
            "pinched", 
            "pine", 
            "pink", 
            "piteous", 
            "pitied", 
            "pity", 
            "place", 
            "placed", 
            "places", 
            "plain", 
            "plainly", 
            "plan", 
            "planning", 
            "plate", 
            "plates", 
            "play", 
            "played", 
            "players", 
            "playing", 
            "pleaded", 
            "pleasant", 
            "pleasanter", 
            "please", 
            "pleased", 
            "pleases", 
            "pleasing", 
            "pleasure", 
            "plenty", 
            "pocket", 
            "pointed", 
            "pointing", 
            "poison", 
            "poker", 
            "poky", 
            "politely", 
            "pool", 
            "poor", 
            "pop", 
            "pope", 
            "porpoise", 
            "position", 
            "positively", 
            "possessed", 
            "possession", 
            "possibility", 
            "possible", 
            "possibly", 
            "posted", 
            "posting", 
            "pounds", 
            "pour", 
            "poured", 
            "powdered", 
            "practically", 
            "practice", 
            "pray", 
            "precious", 
            "prepare", 
            "present", 
            "presented", 
            "presently", 
            "presents", 
            "preserve", 
            "pressed", 
            "pressing", 
            "pretend", 
            "pretending", 
            "pretexts", 
            "prettier", 
            "pretty", 
            "prevent", 
            "previous", 
            "principal", 
            "print", 
            "printed", 
            "prison", 
            "prisoner", 
            "prize", 
            "prizes", 
            "problem", 
            "proceed", 
            "processing", 
            "procession", 
            "processions", 
            "produce", 
            "produced", 
            "producing", 
            "production", 
            "professor", 
            "profit", 
            "profits", 
            "prohibition", 
            "project", 
            "prominently", 
            "promise", 
            "promised", 
            "promising", 
            "promoting", 
            "promotion", 
            "pronounced", 
            "proofread", 
            "proper", 
            "property", 
            "proposal", 
            "proprietary", 
            "prosecute", 
            "protect", 
            "protection", 
            "proud", 
            "prove", 
            "proved", 
            "proves", 
            "provide", 
            "provided", 
            "providing", 
            "provision", 
            "provisions", 
            "provoking", 
            "public", 
            "puffed", 
            "pulled", 
            "pulling", 
            "pun", 
            "punching", 
            "punished", 
            "punitive", 
            "puppy", 
            "purple", 
            "purpose", 
            "purring", 
            "push", 
            "put", 
            "putting", 
            "puzzle", 
            "puzzled", 
            "puzzling", 
            "quadrille", 
            "quarrel", 
            "quarrelled", 
            "quarrelling", 
            "queen", 
            "queens", 
            "queerest", 
            "question", 
            "questions", 
            "quick", 
            "quicker", 
            "quickly", 
            "quiet", 
            "quietly", 
            "quite", 
            "quiver", 
            "rabbit", 
            "rabbits", 
            "race", 
            "railway", 
            "raised", 
            "raising", 
            "ran", 
            "rapidly", 
            "rapped", 
            "rat", 
            "rate", 
            "rather", 
            "rats", 
            "rattle", 
            "rattling", 
            "raven", 
            "ravens", 
            "raving", 
            "raw", 
            "re", 
            "reach", 
            "reaching", 
            "read", 
            "readable", 
            "readily", 
            "reading", 
            "ready", 
            "real", 
            "reality", 
            "really", 
            "rearing", 
            "reason", 
            "reasonable", 
            "reasons", 
            "receipt", 
            "receive", 
            "received", 
            "receiving", 
            "recognised", 
            "recovered", 
            "red", 
            "redistribute", 
            "redistributing", 
            "redistribution", 
            "reduced", 
            "reeds", 
            "reeling", 
            "references", 
            "refreshments", 
            "refund", 
            "refused", 
            "registered", 
            "regular", 
            "regulating", 
            "release", 
            "relief", 
            "relieved", 
            "remain", 
            "remained", 
            "remaining", 
            "remark", 
            "remarkable", 
            "remarked", 
            "remarking", 
            "remarks", 
            "remedies", 
            "remember", 
            "remembered", 
            "remembering", 
            "reminding", 
            "remove", 
            "removed", 
            "renamed", 
            "repeat", 
            "repeated", 
            "repeating", 
            "replace", 
            "replacement", 
            "replied", 
            "reply", 
            "reported", 
            "reports", 
            "representations", 
            "request", 
            "require", 
            "required", 
            "requirements", 
            "research", 
            "resource", 
            "respect", 
            "respectable", 
            "respectful", 
            "rest", 
            "resting", 
            "restrictions", 
            "result", 
            "retire", 
            "return", 
            "returned", 
            "returning", 
            "returns", 
            "revenue", 
            "rich", 
            "riddle", 
            "riddles", 
            "ridge", 
            "ridges", 
            "ridiculous", 
            "right", 
            "righthand", 
            "rightly", 
            "ring", 
            "ringlets", 
            "riper", 
            "rippling", 
            "rise", 
            "rises", 
            "rising", 
            "roared", 
            "roast", 
            "rock", 
            "rocket", 
            "rome", 
            "roof", 
            "room", 
            "roots", 
            "rope", 
            "rose", 
            "roses", 
            "rosetree", 
            "roughly", 
            "round", 
            "row", 
            "royal", 
            "royalties", 
            "royalty", 
            "rubbed", 
            "rubbing", 
            "rude", 
            "rudeness", 
            "rule", 
            "rules", 
            "rumbling", 
            "run", 
            "running", 
            "rush", 
            "rushed", 
            "rustled", 
            "rustling", 
            "s", 
            "sad", 
            "sadly", 
            "safe", 
            "sage", 
            "said", 
            "salmon", 
            "salt", 
            "same", 
            "sand", 
            "sands", 
            "sang", 
            "sat", 
            "saucepan", 
            "saucepans", 
            "saucer", 
            "savage", 
            "save", 
            "saves", 
            "saw", 
            "say", 
            "saying", 
            "says", 
            "scale", 
            "scaly", 
            "scattered", 
            "school", 
            "schoolroom", 
            "scolded", 
            "scrambling", 
            "scratching", 
            "scream", 
            "screamed", 
            "screaming", 
            "scroll", 
            "sea", 
            "seals", 
            "seaography", 
            "search", 
            "seaside", 
            "seated", 
            "second", 
            "secondly", 
            "secret", 
            "section", 
            "sections", 
            "secure", 
            "see", 
            "seeing", 
            "seem", 
            "seemed", 
            "seems", 
            "seen", 
            "seldom", 
            "sell", 
            "send", 
            "sending", 
            "sends", 
            "sensation", 
            "sense", 
            "sent", 
            "sentence", 
            "sentenced", 
            "series", 
            "seriously", 
            "serpent", 
            "serpents", 
            "service", 
            "set", 
            "setting", 
            "settle", 
            "settled", 
            "settling", 
            "seven", 
            "several", 
            "severely", 
            "severity", 
            "sh", 
            "shade", 
            "shake", 
            "shakespeare", 
            "shaking", 
            "shall", 
            "shan", 
            "shape", 
            "shaped", 
            "share", 
            "shared", 
            "sharing", 
            "shark", 
            "sharks", 
            "sharp", 
            "sharply", 
            "she", 
            "shedding", 
            "sheep", 
            "shelves", 
            "shepherd", 
            "shifting", 
            "shilling", 
            "shillings", 
            "shingle", 
            "shining", 
            "shiny", 
            "shiver", 
            "shock", 
            "shoes", 
            "shook", 
            "shore", 
            "short", 
            "shorter", 
            "should", 
            "shoulder", 
            "shoulders", 
            "shouldn", 
            "shouted", 
            "shouting", 
            "show", 
            "shower", 
            "showing", 
            "shriek", 
            "shrieked", 
            "shrieks", 
            "shrill", 
            "shrimp", 
            "shrink", 
            "shrinking", 
            "shut", 
            "shutting", 
            "shy", 
            "shyly", 
            "side", 
            "sides", 
            "sigh", 
            "sighed", 
            "sighing", 
            "sight", 
            "sign", 
            "signed", 
            "signifies", 
            "signify", 
            "silence", 
            "silent", 
            "simple", 
            "simpleton", 
            "simply", 
            "since", 
            "sing", 
            "singers", 
            "singing", 
            "sink", 
            "sir", 
            "sister", 
            "sisters", 
            "sit", 
            "site", 
            "sits", 
            "sitting", 
            "six", 
            "sixpence", 
            "sixteenth", 
            "size", 
            "sizes", 
            "skimming", 
            "skirt", 
            "skurried", 
            "sky", 
            "slate", 
            "slates", 
            "sleep", 
            "sleepy", 
            "slightest", 
            "slipped", 
            "slippery", 
            "slowly", 
            "sluggard", 
            "small", 
            "smaller", 
            "smallest", 
            "smile", 
            "smiled", 
            "smiling", 
            "smoke", 
            "smoking", 
            "snail", 
            "snappishly", 
            "sneeze", 
            "sneezed", 
            "sneezes", 
            "sneezing", 
            "snorting", 
            "snout", 
            "so", 
            "sobbed", 
            "sobbing", 
            "sobs", 
            "soft", 
            "softly", 
            "soldier", 
            "soldiers", 
            "solemn", 
            "solemnly", 
            "soles", 
            "solicit", 
            "solicitation", 
            "solid", 
            "some", 
            "somebody", 
            "somehow", 
            "someone", 
            "somersault", 
            "something", 
            "sometimes", 
            "somewhere", 
            "son", 
            "song", 
            "soo", 
            "soon", 
            "sooner", 
            "soothing", 
            "sorrow", 
            "sorrowful", 
            "sorrows", 
            "sorry", 
            "sort", 
            "sorts", 
            "sound", 
            "sounded", 
            "sounds", 
            "soup", 
            "sour", 
            "spades", 
            "speak", 
            "speaker", 
            "speaking", 
            "special", 
            "specific", 
            "specified", 
            "spectacles", 
            "speech", 
            "speed", 
            "spell", 
            "spirited", 
            "spite", 
            "splash", 
            "splashed", 
            "splashing", 
            "splendidly", 
            "spoke", 
            "spoken", 
            "spoon", 
            "spot", 
            "sprawling", 
            "spread", 
            "spreading", 
            "squeaked", 
            "squeaking", 
            "squeeze", 
            "squeezed", 
            "staff", 
            "stairs", 
            "stalk", 
            "stamping", 
            "stand", 
            "standing", 
            "star", 
            "staring", 
            "start", 
            "started", 
            "startled", 
            "state", 
            "statements", 
            "states", 
            "station", 
            "status", 
            "stay", 
            "stays", 
            "steady", 
            "steam", 
            "sternly", 
            "stick", 
            "sticks", 
            "stiff", 
            "stigand", 
            "still", 
            "stingy", 
            "stirring", 
            "stockings", 
            "stole", 
            "stolen", 
            "stood", 
            "stool", 
            "stoop", 
            "stop", 
            "stopped", 
            "stopping", 
            "stored", 
            "story", 
            "straight", 
            "straightened", 
            "straightening", 
            "strange", 
            "strength", 
            "stretched", 
            "stretching", 
            "strict", 
            "strings", 
            "struck", 
            "stuff", 
            "stupid", 
            "stupidest", 
            "stupidly", 
            "subdued", 
            "subject", 
            "subjects", 
            "submitted", 
            "subscribe", 
            "succeeded", 
            "such", 
            "sudden", 
            "suddenly", 
            "suet", 
            "sugar", 
            "suit", 
            "sulkily", 
            "sulky", 
            "summer", 
            "sun", 
            "supple", 
            "support", 
            "suppose", 
            "suppress", 
            "suppressed", 
            "sure", 
            "surprise", 
            "surprised", 
            "survive", 
            "swallow", 
            "swallowed", 
            "swallowing", 
            "swam", 
            "swamp", 
            "sweet", 
            "swim", 
            "swimming", 
            "synonymous", 
            "t", 
            "table", 
            "tail", 
            "tails", 
            "take", 
            "taken", 
            "takes", 
            "taking", 
            "tale", 
            "tales", 
            "talk", 
            "talking", 
            "taller", 
            "tart", 
            "tarts", 
            "taste", 
            "tasted", 
            "tastes", 
            "taught", 
            "tax", 
            "taxes", 
            "tea", 
            "teaching", 
            "teacup", 
            "teacups", 
            "teapot", 
            "tears", 
            "teases", 
            "teeth", 
            "telescope", 
            "telescopes", 
            "tell", 
            "telling", 
            "tells", 
            "temper", 
            "tempered", 
            "ten", 
            "terms", 
            "terribly", 
            "terrier", 
            "terror", 
            "than", 
            "thank", 
            "thanked", 
            "that", 
            "thatched", 
            "the", 
            "their", 
            "theirs", 
            "them", 
            "themselves", 
            "then", 
            "there", 
            "therefore", 
            "these", 
            "they", 
            "thick", 
            "thimble", 
            "thin", 
            "thing", 
            "things", 
            "think", 
            "thinking", 
            "thirteen", 
            "thirty", 
            "this", 
            "thistle", 
            "thoroughly", 
            "those", 
            "though", 
            "thought", 
            "thoughtfully", 
            "thoughts", 
            "thousand", 
            "three", 
            "threw", 
            "throat", 
            "throne", 
            "through", 
            "throughout", 
            "throw", 
            "throwing", 
            "thrown", 
            "thump", 
            "thunder", 
            "thunderstorm", 
            "thus", 
            "tide", 
            "tidy", 
            "tie", 
            "tied", 
            "tight", 
            "till", 
            "tillie", 
            "time", 
            "times", 
            "timid", 
            "timidly", 
            "tinkling", 
            "tiny", 
            "tipped", 
            "tiptoe", 
            "tired", 
            "tis", 
            "title", 
            "tittered", 
            "tm", 
            "to", 
            "toast", 
            "today", 
            "toes", 
            "toffee", 
            "together", 
            "told", 
            "tomorrow", 
            "tone", 
            "tones", 
            "tongue", 
            "too", 
            "took", 
            "top", 
            "tops", 
            "tortoise", 
            "toss", 
            "tossing", 
            "touch", 
            "tougher", 
            "towards", 
            "toys", 
            "trademark", 
            "trampled", 
            "transcribe", 
            "transcription", 
            "traps", 
            "tray", 
            "treacle", 
            "treading", 
            "treat", 
            "treated", 
            "treatment", 
            "tree", 
            "trees", 
            "tremble", 
            "trembled", 
            "trembling", 
            "tremulous", 
            "trial", 
            "trials", 
            "trickling", 
            "tricks", 
            "tried", 
            "trims", 
            "triumphantly", 
            "trot", 
            "trotting", 
            "trouble", 
            "true", 
            "trumpet", 
            "trusts", 
            "truth", 
            "truthful", 
            "try", 
            "trying", 
            "tucked", 
            "tulip", 
            "tumbled", 
            "tumbling", 
            "tunnel", 
            "tureen", 
            "turkey", 
            "turn", 
            "turned", 
            "turning", 
            "turns", 
            "turtle", 
            "turtles", 
            "tut", 
            "twelfth", 
            "twelve", 
            "twentieth", 
            "twenty", 
            "twice", 
            "twinkle", 
            "twinkled", 
            "twinkling", 
            "twist", 
            "two", 
            "txt", 
            "types", 
            "u", 
            "ugh", 
            "uglification", 
            "uglify", 
            "uglifying", 
            "ugly", 
            "unable", 
            "uncivil", 
            "uncomfortable", 
            "uncomfortably", 
            "uncommon", 
            "uncommonly", 
            "uncorked", 
            "under", 
            "underneath", 
            "understand", 
            "understood", 
            "undertone", 
            "undo", 
            "undoing", 
            "uneasily", 
            "uneasy", 
            "unenforceability", 
            "unfolded", 
            "unfortunate", 
            "unhappy", 
            "uniform", 
            "unimportant", 
            "united", 
            "unjust", 
            "unless", 
            "unlink", 
            "unlocking", 
            "unpleasant", 
            "unrolled", 
            "unsolicited", 
            "until", 
            "untwist", 
            "unusually", 
            "unwillingly", 
            "up", 
            "updated", 
            "upon", 
            "upright", 
            "upset", 
            "upsetting", 
            "upstairs", 
            "us", 
            "use", 
            "used", 
            "useful", 
            "user", 
            "using", 
            "usual", 
            "usually", 
            "usurpation", 
            "ut", 
            "v", 
            "vague", 
            "vanilla", 
            "vanished", 
            "vanishing", 
            "variations", 
            "variety", 
            "various", 
            "ve", 
            "vegetable", 
            "velvet", 
            "venture", 
            "ventured", 
            "verdict", 
            "verse", 
            "verses", 
            "version", 
            "very", 
            "vi", 
            "viewed", 
            "viewing", 
            "vii", 
            "viii", 
            "vinegar", 
            "violates", 
            "violence", 
            "violent", 
            "violently", 
            "virus", 
            "visit", 
            "voice", 
            "voices", 
            "void", 
            "volunteer", 
            "volunteers", 
            "vote", 
            "vulgar", 
            "w", 
            "wag", 
            "wags", 
            "waist", 
            "waistcoat", 
            "wait", 
            "waited", 
            "waiting", 
            "wake", 
            "walk", 
            "walked", 
            "walking", 
            "walks", 
            "walrus", 
            "wander", 
            "wandered", 
            "wandering", 
            "want", 
            "wanted", 
            "wants", 
            "warning", 
            "warranties", 
            "warranty", 
            "was", 
            "wash", 
            "washing", 
            "wasn", 
            "waste", 
            "wasting", 
            "watch", 
            "watched", 
            "watching", 
            "water", 
            "waters", 
            "waving", 
            "way", 
            "ways", 
            "we", 
            "weak", 
            "wearily", 
            "web", 
            "week", 
            "weeks", 
            "welcome", 
            "well", 
            "went", 
            "wept", 
            "were", 
            "weren", 
            "west", 
            "wet", 
            "what", 
            "whatever", 
            "whatsoever", 
            "when", 
            "whenever", 
            "where", 
            "whereupon", 
            "wherever", 
            "whether", 
            "which", 
            "while", 
            "whiles", 
            "whiskers", 
            "whisper", 
            "whispered", 
            "whispers", 
            "whistle", 
            "whistling", 
            "white", 
            "whiting", 
            "who", 
            "whoever", 
            "whole", 
            "whom", 
            "whose", 
            "why", 
            "wide", 
            "wider", 
            "widest", 
            "wife", 
            "wig", 
            "wild", 
            "wildly", 
            "will", 
            "william", 
            "win", 
            "wind", 
            "window", 
            "wine", 
            "wings", 
            "wink", 
            "winter", 
            "wise", 
            "wish", 
            "with", 
            "within", 
            "without", 
            "witness", 
            "wits", 
            "woke", 
            "woman", 
            "won", 
            "wonder", 
            "wondered", 
            "wonderful", 
            "wondering", 
            "wonderland", 
            "wood", 
            "wooden", 
            "word", 
            "words", 
            "wore", 
            "work", 
            "works", 
            "world", 
            "worm", 
            "worried", 
            "worry", 
            "worse", 
            "worth", 
            "would", 
            "wouldn", 
            "wow", 
            "wrapping", 
            "wretched", 
            "wriggling", 
            "write", 
            "writhing", 
            "writing", 
            "written", 
            "wrong", 
            "wrote", 
            "www", 
            "x", 
            "xi", 
            "xii", 
            "yard", 
            "yards", 
            "yawned", 
            "yawning", 
            "ye", 
            "year", 
            "years", 
            "yelled", 
            "yelp", 
            "yer", 
            "yes", 
            "yesterday", 
            "yet", 
            "you", 
            "young", 
            "your", 
            "yours", 
            "yourself", 
            "youth", 
            "zealand", 
            "zigzag", 
            "zip", 
        };
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples.Common\BusinessObjects\Taxonomy\Phylum.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Represents a Phylum in a Linnaean taxonomy.
    /// </summary>
    public sealed class Phylum : Taxonomy
    {
        /// <summary>
        /// Initializes a new instance of the Phylum class.
        /// </summary>
        public Phylum()
            : base()
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples.Common\BusinessObjects\Taxonomy\Order.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Represents an Order in a Linnaean taxonomy.
    /// </summary>
    public sealed class Order : Taxonomy
    {
        /// <summary>
        /// Initializes a new instance of the Order class.
        /// </summary>
        public Order()
            : base()
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples.Common\BusinessObjects\Taxonomy\Kingdom.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Represents a Kingdom in a Linnaean taxonomy.
    /// </summary>
    public sealed class Kingdom : Taxonomy
    {
        /// <summary>
        /// Initializes a new instance of the Kingdom class.
        /// </summary>
        public Kingdom()
            : base()
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples.Common\BusinessObjects\Taxonomy\Genus.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Represents a Genus in a Linnaean taxonomy.
    /// </summary>
    public sealed class Genus : Taxonomy
    {
        /// <summary>
        /// Initializes a new instance of the Genus class.
        /// </summary>
        public Genus()
            : base()
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples.Common\BusinessObjects\Taxonomy\Species.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Represents a Species in a Linnaean taxonomy.
    /// </summary>
    public sealed class Species : Taxonomy
    {
        /// <summary>
        /// Initializes a new instance of the Species class.
        /// </summary>
        public Species()
            : base()
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples.Common\Properties\AssemblyInfo.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Reflection;
using System.Resources;
using System.Runtime.InteropServices;

[assembly: AssemblyTitle("System.Windows.Controls.Samples.Common")]
[assembly: AssemblyDescription("Shared Silverlight Toolkit Sample Infrastructure")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft Corporation")]
[assembly: AssemblyProduct("Microsoft® Silverlight™ Toolkit")]
[assembly: AssemblyCopyright("© Microsoft Corporation.  All rights reserved.")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]
[assembly: NeutralResourcesLanguage("en-US")]
[assembly: ComVisible(false)]
[assembly: Guid("ab1062a6-2171-4fe1-a417-edc28b13f3a1")]
[assembly: AssemblyVersion("2.0.5.0")]
[assembly: AssemblyFileVersion("3.0.30630.2253")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples.Common\BusinessObjects\Taxonomy\Taxonomy.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Globalization;
using System.Linq;
using System.Windows;
using System.Windows.Markup;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Represents an item contained in a level of a Linnaean taxonomy.
    /// </summary>
    [ContentProperty("Subclasses")]
    public abstract class Taxonomy
    {
        /// <summary>
        /// Gets a subset of all life on the planet.
        /// </summary>
        public static IEnumerable<Taxonomy> Life
        {
            get
            {
                IEnumerable<object> data = Application.Current.Resources["TreeOfLife"] as IEnumerable<object>;
                return (data != null) ?
                    data.Cast<Taxonomy>() :
                    Enumerable.Empty<Taxonomy>();
            }
        }

        /// <summary>
        /// Gets the name of the TaxonomicRank.
        /// </summary>
        public string Rank
        {
            get { return GetType().Name; }
        }

        /// <summary>
        /// Gets or sets the classification of the item being ranked.
        /// </summary>
        public string Classification { get; set; }

        /// <summary>
        /// Gets the subclasses of of the item being ranked.
        /// </summary>
        public Collection<Taxonomy> Subclasses { get; private set; }

        /// <summary>
        /// Initializes a new instance of the TaxonomicItem class.
        /// </summary>
        protected Taxonomy()
        {
            Subclasses = new Collection<Taxonomy>();
        }

        /// <summary>
        /// Get a string representation of the TaxonomicItem.
        /// </summary>
        /// <returns>String representation of the TaxonomicItem.</returns>
        public override string ToString()
        {
            return string.Format(CultureInfo.InvariantCulture, "{0}: {1}", Rank, Classification);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples.Common\SampleBrowser\DifficultyLevel.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Describes the level of difficulty of the sample.
    /// </summary>
    public enum DifficultyLevel 
    {
        /// <summary>
        /// Used when Sample does not need to be categorized.
        /// </summary>
        None = 0,

        /// <summary>
        /// Used for basic samples.
        /// </summary>
        Basic = 1,

        /// <summary>
        /// Used for intermediate samples.
        /// </summary>
        Intermediate = 2,

        /// <summary>
        /// Used for advanced samples.
        /// </summary>
        Advanced = 3,

        /// <summary>
        /// Used for scenario samples.
        /// </summary>
        Scenario = 4
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples.Common\SampleBrowser\SampleBrowserItem.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Collections.Generic;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Media;
using System.Windows.Shapes;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// The SampleBrowserItem class represents an individual sample in tab control
    /// samples. 
    /// </summary>
    public class SampleBrowserItem
    {
        /// <summary>
        /// Gets or sets the name of the sample.
        /// </summary>
        public string Name { get; set; }

        /// <summary>
        /// Gets or sets the name of the sample to use for sorting.
        /// </summary>
        private string OriginalName { get; set; }

        /// <summary>
        /// Gets or sets the sample type that was declared using the SampleAttribute.
        /// </summary>
        public Type SampleType { get; set; }

        /// <summary>
        /// Gets or sets the level difficulty of the sample.
        /// </summary>
        public DifficultyLevel SampleLevel { get; set; }

        /// <summary>
        /// Initializes a new instance of the SampleBrowserItem class.
        /// </summary>
        public SampleBrowserItem()
        {       
        }

        /// <summary>
        /// Overrides the ToString method to return the Name of the Sample.
        /// </summary>
        /// <returns>Returns the Name of the sample.</returns>
        public override string ToString()
        {
            return Name;
        }

        /// <summary>
        /// Gets the sample represented by this item.
        /// </summary>
        /// <returns>The sample represented by this item.</returns>
        [SuppressMessage("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate", Justification = "Creates a new instance each time it is accessed.")]
        public FrameworkElement GetSample()
        {
            if (SampleType != null)
            {
                // Create the sample from the type if we have one
                FrameworkElement sample = Activator.CreateInstance(SampleType) as FrameworkElement;
                sample.VerticalAlignment = VerticalAlignment.Top;
                sample.HorizontalAlignment = HorizontalAlignment.Left;
                sample.Margin = new Thickness(10, 0, 0, 0);
                return sample;
            }
            return null;
        }

        /// <summary>
        /// Create a SampleBrowserItem and inserts into the right location.
        /// </summary>
        /// <param name="Samples">Collections of Samples.</param>
        /// <param name="type">Type of Sample.</param>
        /// <param name="attribute">Attributes for the Sample.</param>
        internal static void AddSample(IList<SampleBrowserItem> Samples, Type type, SampleAttribute attribute)
        {
            string name = attribute.Name;
            // Find any existing item
            SampleBrowserItem item = null;
            if (Samples != null)
            {
                foreach (SampleBrowserItem other in Samples)
                {
                    if (string.Compare(other.OriginalName, name, StringComparison.OrdinalIgnoreCase) == 0)
                    {
                        item = other;
                        break;
                    }
                }
            }
            // Escape any name sorting
            string escapedName = name;
            if (name[0] == '(')
            {
                int index = name.IndexOf(')');
                if (index > 0)
                {
                    escapedName = name.Substring(index + 1, name.Length - index - 1);
                }
            }

            item = new SampleBrowserItem { Name = escapedName, OriginalName = name, SampleType = type, SampleLevel = attribute.DifficultyLevel };

            // Insert the item into the list in sorted order (linearly
            // because no item should have very many children)
            int sortedIndex = 0;
            foreach (SampleBrowserItem other in Samples)
            {
                if (string.Compare(other.OriginalName, name, StringComparison.OrdinalIgnoreCase) > 0)
                {
                    break;
                }
                else
                {
                    sortedIndex++;
                }
            }
            Samples.Insert(sortedIndex, item);       
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples.Common\SampleBrowser\SampleAttribute.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Diagnostics;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// The SampleAttribute identifies sample name and level of difficulty.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class)]
    public sealed partial class SampleAttribute : Attribute
    {
        /// <summary>
        /// Gets the path to the sample in the Sample Browser tree.
        /// </summary>
        public string Name { get; private set; }

        /// <summary>
        /// Gets the difficulty level of the sample.
        /// </summary>
        public DifficultyLevel DifficultyLevel { get; private set; }

        /// <summary>
        /// Initializes a new instance of the SampleAttribute class.
        /// </summary>
        /// <param name="name">
        /// Name of the sample.
        /// </param>
        /// <param name="difficultyLevel">
        /// Difficulty Level of the sample.
        /// </param>
        public SampleAttribute(string name, DifficultyLevel difficultyLevel)
        {
            Debug.Assert(!string.IsNullOrEmpty(name), "name should not be empty!");
            Name = name;
            DifficultyLevel = difficultyLevel;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples.Common\SampleBrowser\EmbeddedImage.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Windows.Media;
using System.Windows.Controls;
using System.Windows;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// ImageLoader is used to load an Embedded Resource Image.
    /// </summary>
    [TemplatePart(Name = EmbeddedImage.ImageLoaderName, Type = typeof(Image))]
    public class EmbeddedImage : Control
    {
        /// <summary>
        /// Name of the Image part.
        /// </summary>
        private const string ImageLoaderName = "Image";

        /// <summary>
        /// Name of the resource to be loaded.
        /// </summary>
        private string _resourceName;

        /// <summary>
        /// Initializes a new instance of the ImageLoader class.
        /// </summary>
        public EmbeddedImage()
        {
            DefaultStyleKey = typeof(EmbeddedImage);
        }

        /// <summary>
        /// Retrieve select elements from a control template.
        /// </summary>
        public override void OnApplyTemplate()
        {
            base.OnApplyTemplate();
            SetEmbeddedImage(_resourceName);
        }

        /// <summary>
        /// Gets or sets the name of the image to be loaded.
        /// </summary>
        public string ResourceName
        {
            get
            {
                return _resourceName;
            }
            set
            {
                 _resourceName = value;
                 SetEmbeddedImage(_resourceName);
            }
        }

        /// <summary>
        /// Helper function to set the embedded image source.
        /// </summary>
        /// <param name="resourceName">Resource name to be loaded.</param>
        private void SetEmbeddedImage(string resourceName)
        {
            Image image = GetTemplateChild(ImageLoaderName) as Image;
            Image embeddedImage = SharedResources.GetIcon(resourceName);
            if (image != null & embeddedImage != null)
            {
                image.Source = embeddedImage.Source;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples.Common\SampleBrowser\SampleTreeItem.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Windows.Markup;
using System.Windows.Controls;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// The SampleTreeItem represents a node in the TreeView.  
    /// </summary>
    [ContentProperty("Items")]
    public class SampleTreeItem
    {
        /// <summary>
        /// Gets or sets the name of the TreeView node.
        /// </summary>
        public string TreeItemName { get; set; }

        /// <summary>
        ///  Gets a collection of SampleTreeItems.
        /// </summary>
        public Collection<SampleTreeItem> Items { get; private set; }

        /// <summary>
        /// Initialize a SampleTreeItem.
        /// </summary>
        public SampleTreeItem()
        {
            Items = new Collection<SampleTreeItem>();
        }

        /// <summary>
        /// Gets or sets the resource name of the Icon representing this 
        /// node.
        /// </summary>
        public string IconResourceName { get; set; }

        /// <summary>
        /// Gets the icon representing this type. 
        /// </summary>
        public Image Icon
        {
            get
            {
                return SharedResources.GetIcon(IconResourceName);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples.Common\SourceViewer\SourceViewer.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Collections.ObjectModel;
using System.Windows.Controls;
using System.Windows.Markup;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// The SourceViewer is used to browse the source for a sample.
    /// </summary>
    [ContentProperty("Files")]
    public class SourceViewer : Control
    {
        /// <summary>
        /// A collection of source files to view.
        /// </summary>
        private Collection<SourceFile> _files = new Collection<SourceFile>();

        /// <summary>
        /// Gets a collection of source files to view.
        /// </summary>
        public Collection<SourceFile> Files
        {
            get { return _files; }
        }

        /// <summary>
        /// Initializes a new instance of the SourceViewer class.
        /// </summary>
        public SourceViewer()
        {
            // Notify the SampleBrowser that we are the current source viewer.
            // This is an odd coupling, but it was done because we're
            // shoe-horning source viewing into the browser even though the
            // source is declared in the sample page.
             Loaded += delegate 
             {
                 if (SampleBrowser.Current != null)
                 {
                     SampleBrowser.Current.SetSourceViewer(this);
                 }
             };
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples.Common\SampleBrowser\SampleBrowser.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Windows;
using System.Windows.Browser;
using System.Windows.Controls;
using System.Windows.Controls.Primitives;
using System.Windows.Controls.Theming;
using System.Windows.Input;
using System.Windows.Markup;
using System.Windows.Media;
using System.Windows.Media.Animation;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// The SampleBrowser is used to display interactive samples of controls,
    /// styles, and scenarios.
    /// </summary>
    [ContentProperty("Samples")]
    [TemplatePart(Name = SampleBrowser.SampleSelectionName, Type = typeof(TreeView))]
    [TemplatePart(Name = SampleBrowser.FullScreenButtonName, Type = typeof(ToggleButton))]
    [TemplatePart(Name = SampleBrowser.SourceListName, Type = typeof(ListBox))]
    [TemplatePart(Name = SampleBrowser.SourceTextName, Type = typeof(TextBox))]
    [TemplatePart(Name = SampleBrowser.SamplesTabName, Type = typeof(TabControl))]
    [TemplatePart(Name = SampleBrowser.SourceExpanderName, Type = typeof(Expander))]
    [TemplatePart(Name = SampleBrowser.SampleGridSplitterName, Type = typeof(GridSplitter))]
    [TemplatePart(Name = SampleBrowser.SampleHeaderName, Type = typeof(TextBlock))]
    [TemplatePart(Name = SampleBrowser.SampleLevelName, Type = typeof(Label))]
    [TemplatePart(Name = SampleBrowser.SampleDisplayAreaName, Type = typeof(Grid))]
    [TemplatePart(Name = SampleBrowser.RootName, Type = typeof(Grid))]
    [SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Samples demonstrate a lot of types.")]
    public sealed class SampleBrowser : Control
    {
        /// <summary>
        /// SampleDisplayArea Grid row number where the source viewer is 
        /// located.
        /// </summary>
        private const int SourceViewerRow = 3;

        /// <summary>
        /// Deep Path Link QueryString Parameter Name.
        /// </summary>
        private const string DeepPathLinkQueryStringParamName = "path";

        #region TemplateParts
        /// <summary>
        /// Name of the sample selection TreeView.
        /// </summary>
        private const string SampleSelectionName = "SampleSelection";

        /// <summary>
        /// Name of the samples TabControl .
        /// </summary>
        private const string SamplesTabName = "SamplesTab";

        /// <summary>
        /// Name of the button that toggles full screen.
        /// </summary>
        private const string FullScreenButtonName = "FullScreenButton";

        /// <summary>
        /// Name of the source list ListBox.
        /// </summary>
        private const string SourceListName = "SourceList";

        /// <summary>
        /// Name of the source text TextBox.
        /// </summary>
        private const string SourceTextName = "SourceText";

        /// <summary>
        /// Name of root layout for the Sample Browser.
        /// </summary>
        private const string RootName = "Root";

        /// <summary>
        /// Name of the grid containing the sample and source file viewer.
        /// </summary>
        private const string SampleDisplayAreaName = "DisplayArea";

        /// <summary>
        /// Name of the expander containing the source file viewer.
        /// </summary>
        private const string SourceExpanderName = "SourceExpander";

        /// <summary>
        /// Name of the GridSplitter that separates the sample from the source
        /// file viewer.
        /// </summary>
        private const string SampleGridSplitterName = "SampleGridSplitter";

        /// <summary>
        /// Name of the TabItem style defined in generic.xaml.
        /// </summary>
        private const string TabItemStyleName = "TabItemStyle";

        /// <summary>
        /// Name of the Sample Header.
        /// </summary>
        private const string SampleHeaderName = "SampleHeader";

        /// <summary>
        /// Name of the Label containing the Sample Level defined in 
        /// generic.xaml.
        /// </summary>
        private const string SampleLevelName = "SampleLevel";

        /// <summary>
        /// The TreeView used for selecting samples.
        /// </summary>
        private TreeView _sampleSelection;

        /// <summary>
        /// Gets or sets the TreeView used for selecting samples.
        /// </summary>
        private TreeView SampleSelection
        {
            get { return _sampleSelection; }
            set
            {
                if (_sampleSelection != null)
                {
                    _sampleSelection.SelectedItemChanged -= OnSelectedSampleChanged;
                }

                _sampleSelection = value;

                if (_sampleSelection != null)
                {
                    _sampleSelection.SelectedItemChanged += OnSelectedSampleChanged;
                    _sampleSelection.LayoutUpdated += OnSampleLayoutUpdated;
                }
            }
        }

        /// <summary>
        /// Gets or sets the root layout.
        /// </summary>
        private Grid SampleRoot { get; set; }

        /// <summary>
        /// Gets or sets the sample display area grid.
        /// </summary>
        private Grid SampleDisplayArea { get; set; }

        /// <summary>
        /// Gets or sets the grid splitter that separates the sample
        /// from the source viewer.
        /// </summary>
        private GridSplitter SampleGridSplitter { get; set; }

        /// <summary>
        /// Gets or sets the style for the sample tab items.
        /// </summary>
        private Style SampleTabItemStyle { get; set; }

        /// <summary>
        /// Gets or sets The expander that holds the list of files and content area where
        /// they are rendered.
        /// </summary>
        private Expander _sourceExpander { get; set; }

        /// <summary>
        /// Gets or sets the Expander that hosts the samples.
        /// </summary>
        private Expander SourceExpander
        {
            get { return _sourceExpander; }
            set
            {
                if (_sourceExpander != null)
                {
                    _sourceExpander.Expanded -= OnSourceExpanded;
                    _sourceExpander.Collapsed -= OnSourceCollapsed;
                }
                _sourceExpander = value;

                if (_sourceExpander != null)
                {
                    _sourceExpander.Expanded += OnSourceExpanded;
                    _sourceExpander.Collapsed += OnSourceCollapsed;
                }
            }
        }

        /// <summary>
        /// Gets or sets the tabControl that hosts the samples.
        /// </summary>
        private TabControl SamplesTab { get; set; }

        /// <summary>
        /// The button that toggles full screen view.
        /// </summary>
        private ToggleButton _fullscreenButton;

        /// <summary>
        /// Gets or sets the button that toggles full screen view.
        /// </summary>
        private ToggleButton FullScreenButton
        {
            get { return _fullscreenButton; }
            set
            {
                if (_fullscreenButton != null)
                {
                    _fullscreenButton.Click -= OnToggleFullScreen;
                }

                _fullscreenButton = value;
                if (_fullscreenButton != null)
                {
                    _fullscreenButton.Click += OnToggleFullScreen;
                }
            }
        }

        /// <summary>
        /// ListBox used to select the sample or source file to view.
        /// </summary>
        private ListBox _sourceList;

        /// <summary>
        /// Gets or sets the ListBox used to select the sample or source file to
        /// view.
        /// </summary>
        private ListBox SourceList
        {
            get { return _sourceList; }
            set
            {
                if (_sourceList != null)
                {
                    _sourceList.SelectionChanged -= OnSourceFileChanged;
                }

                _sourceList = value;

                if (_sourceList != null)
                {
                    _sourceList.SelectionChanged += OnSourceFileChanged;
                }
            }
        }

        /// <summary>
        /// Gets or sets the source text TextBox.
        /// </summary>
        private TextBox SourceText { get; set; }

        /// <summary>
        /// Gets or sets the sample header label.
        /// </summary>
        private TextBlock SampleHeader { get; set; }

        /// <summary>
        /// Gets or sets the sample difficulty level label.
        /// </summary>
        private Label SampleDifficultyLevel { get; set; }

        #endregion

        /// <summary>
        /// Gets or sets a reference to the current SampleBrowser control.
        /// </summary>
        internal static SampleBrowser Current { get; set; }

        /// <summary>
        /// Gets or sets the sample assembly.
        /// </summary>
        private Assembly SampleAssembly { get; set; }

        /// <summary>
        /// Gets or sets the items used to populate the TreeView.
        /// </summary>
        private IEnumerable<SampleTreeItem> SampleTreeItems { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether the SourceView expander 
        /// is collapsed by the user.
        /// </summary>
        private bool IsSourceViewCollapsed { get; set; }

        /// <summary>
        /// Gets or sets a value indicating the current source file displayed.
        /// </summary>
        private SourceFile CurrentSourceFile { get; set; }

        /// <summary>
        /// Initializes a new instance of the SampleBrowser class.
        /// </summary>
        /// <param name="sampleAssembly">Instance from the samples assembly.</param>
        /// <param name="sampleTreeItems">Items used to populate the TreeView.</param>
        public SampleBrowser(Assembly sampleAssembly, IEnumerable<SampleTreeItem> sampleTreeItems)
        {
            if (sampleAssembly == null)
            {
                throw new ArgumentNullException("sampleAssembly");
            }

            SampleAssembly = sampleAssembly;
            SampleTreeItems = sampleTreeItems;
            Current = this;
            DefaultStyleKey = typeof(SampleBrowser);
            IsSourceViewCollapsed = true;

            // Get notifications when full screen mode changes
            if (Application.Current != null)
            {
                Application.Current.Host.Content.FullScreenChanged += OnFullScreenChanged;
            }
        }

        /// <summary>
        /// Populate the Tab with samples name for a given control.
        /// </summary>
        /// <param name="sampleAssembly">Name of the sample assembly.</param>
        /// <param name="controlName">Name of the control.</param>
        private void PopulateSamplesTab(Assembly sampleAssembly, string controlName)
        {
            if (SamplesTab == null)
            {
                return;
            }

            // Unhook this event when dynamically before adding new tabs.
            SamplesTab.SelectionChanged -= OnSamplesTabSelectionChanged;

            if (SamplesTab.Items.Count > 0)
            {
                SamplesTab.Items.Clear();
            }
            
            // Construct a sorted list of samples
            IList<SampleBrowserItem> samples = new List<SampleBrowserItem>();
            foreach (Type type in sampleAssembly.GetTypes())
            {
                SampleAttribute attribute = type.GetCustomAttributes(typeof(SampleAttribute), false).OfType<SampleAttribute>().FirstOrDefault();

                CategoryAttribute categoryAttribute = type.GetCustomAttributes(typeof(CategoryAttribute), false).OfType<CategoryAttribute>().FirstOrDefault();
                if (attribute != null && categoryAttribute != null)
                {
                    if (categoryAttribute.Category.Equals(controlName))
                    {
                        SampleBrowserItem.AddSample(samples, type, attribute);
                    }
                }
            }
            // Populate the Tab Control with the samples.
            foreach (SampleBrowserItem item in samples)
            {
                TabItem tabItem = new TabItem();
                if (SampleTabItemStyle != null)
                {
                    tabItem.Style = SampleTabItemStyle;
                }

                tabItem.Header = item;
                SamplesTab.Items.Add(tabItem);
            }

            // Hook up this event when done creating the Sample tabs.
            SamplesTab.SelectionChanged += OnSamplesTabSelectionChanged;

            // Select first tab
            if (SamplesTab.Items.Count > 0)
            {
                (SamplesTab.Items[0] as TabItem).IsSelected = true;
                LoadSample();
            }
        }

        /// <summary>
        /// Gets a value indicating whether the Deep Path Link query string parameter was specified.
        /// </summary>
        private static bool IsDeepPathLinkSpecified
        {
            get
            {
                if (!HtmlPage.IsEnabled)
                {
                    return false;
                }

                if (HtmlPage.Document == null)
                {
                    return false;
                } 

                return HtmlPage.Document.QueryString.Keys.Contains(DeepPathLinkQueryStringParamName);
            }
        }

        /// <summary>
        /// Returns the Initial Deep Path Link Lookup.
        /// </summary>
        /// <param name="level">Deep path link level.</param>
        /// <returns>The deep path for that level.</returns>
        private static string GetPathForLevel(int level)
        {
            if (!IsDeepPathLinkSpecified)
            {
                return string.Empty;
            }

            string DeepLinkPathRawValue = HtmlPage.Document.QueryString[DeepPathLinkQueryStringParamName];
            string DeepLinkPathDecodedValue = HttpUtility.UrlDecode(DeepLinkPathRawValue);
            string[] deepLinkPath = DeepLinkPathDecodedValue.Split('|');

            if (deepLinkPath.Length - 1 >= level)
            {
                return deepLinkPath[level];
            }
            else
            {
                return string.Empty;
            }
        }

        /// <summary>
        /// Expands the Sample TreeView.
        /// </summary>
        /// <param name="sender">The Sender.</param>
        /// <param name="e">Event arguments.</param>
        private void OnSampleLayoutUpdated(object sender, EventArgs e)
        {
            TreeViewItem item = _sampleSelection.ItemContainerGenerator.ContainerFromIndex(0) as TreeViewItem;
            item.IsSelected = true;
            _sampleSelection.LayoutUpdated -= OnSampleLayoutUpdated;
        }

        /// <summary>
        /// Retrieve select elements from a control template.
        /// </summary>
        public override void OnApplyTemplate()
        {
            base.OnApplyTemplate();
            SampleSelection = GetTemplateChild(SampleSelectionName) as TreeView;
            FullScreenButton = GetTemplateChild(FullScreenButtonName) as ToggleButton;
            SourceList = GetTemplateChild(SourceListName) as ListBox;
            SourceText = GetTemplateChild(SourceTextName) as TextBox;
            SamplesTab = GetTemplateChild(SamplesTabName) as TabControl;
            SampleRoot = GetTemplateChild(RootName) as Grid;
            SampleDisplayArea = GetTemplateChild(SampleDisplayAreaName) as Grid;
            SourceExpander = GetTemplateChild(SourceExpanderName) as Expander;
            SampleGridSplitter = GetTemplateChild(SampleGridSplitterName) as GridSplitter;
            SampleDifficultyLevel = GetTemplateChild(SampleLevelName) as Label;
            SampleHeader = GetTemplateChild(SampleHeaderName) as TextBlock;

            // Get the Style of the Tab Item to be used when generating the tabs
            if (SampleRoot != null)
            {
                SampleTabItemStyle = SampleRoot.Resources[TabItemStyleName] as Style;
            }
            // Populate the samples
            if (SampleSelection != null)
            {
                SampleSelection.ItemsSource = SampleTreeItems;
            }

            SelectNavigationOnDeepLinkPath();

            // Show the TreeView
            Show(SampleSelection);
        }

        /// <summary>
        /// Select a TreeViewItem and a TabItem used for navigation based on the query string
        /// deep link path. 
        /// </summary>
        private void SelectNavigationOnDeepLinkPath()
        {
            // Select a TreeViewItem based on the 1st and 2nd deep path levels
            if (IsDeepPathLinkSpecified)
            {
                if (!string.IsNullOrEmpty(GetPathForLevel(0)))
                {
                    SampleTreeItem firstDeepPathLevelSampleItem =
                        SampleSelection.Items.OfType<SampleTreeItem>().SingleOrDefault(
                            t => t.TreeItemName == GetPathForLevel(0));

                    if (firstDeepPathLevelSampleItem != null)
                    {
                        if (string.IsNullOrEmpty(GetPathForLevel(1)))
                        {
                            SelectTreeViewItemFor(firstDeepPathLevelSampleItem);
                        }
                        else
                        {
                            SampleTreeItem secondDeepPathLevelSampleItem =
                                firstDeepPathLevelSampleItem.Items.OfType<SampleTreeItem>().SingleOrDefault(
                                    t => t.TreeItemName == GetPathForLevel(1));

                            if (secondDeepPathLevelSampleItem != null)
                            {
                                SelectTreeViewItemFor(firstDeepPathLevelSampleItem, secondDeepPathLevelSampleItem);
                            }
                        }
                    }
                }
            }
        }

       /// <summary>
        /// Selects a tree view item based on an item.
       /// </summary>
        /// <param name="firstLevelItem">Item that correlates to a the first level TreeViewItem.</param>
        /// <param name="secondLevelItem">Item that correlates to a the second level TreeViewItem.</param>
        private void SelectTreeViewItemFor(SampleTreeItem firstLevelItem, SampleTreeItem secondLevelItem)
        {
            SampleSelection.Loaded += (s, args) =>
            {
                TreeViewItem firstLevelTreeViewItem = (TreeViewItem)
                    SampleSelection.ItemContainerGenerator.ContainerFromItem(firstLevelItem);
                TreeViewItem secondLevelTreeViewItem = (TreeViewItem)
                    firstLevelTreeViewItem.ItemContainerGenerator.ContainerFromItem(secondLevelItem);
                secondLevelTreeViewItem.IsSelected = true;

                // check if 3rd level deep link path has a correlating TabItem
                if (!string.IsNullOrEmpty(GetPathForLevel(2)))
                {
                    TabItem tabItemToSelect = SamplesTab.Items.OfType<TabItem>().SingleOrDefault(
                    t => ((SampleBrowserItem) t.Header).Name == GetPathForLevel(2));

                    if (tabItemToSelect != null)
                    {
                        tabItemToSelect.IsSelected = true;
                    }
                }
            };
        }

        /// <summary>
        /// Selects a tree view item based on an item.
        /// </summary>
        /// <param name="firstLevelItem">Item that correlates to a the TreeViewItem.</param>
        private void SelectTreeViewItemFor(SampleTreeItem firstLevelItem)
        {
            SampleSelection.Loaded += (s, args) =>
                {
                    ((TreeViewItem)SampleSelection.ItemContainerGenerator.ContainerFromItem(firstLevelItem)).IsSelected = true;
                };
        }

        /// <summary>
        /// Change the selected sample.
        /// </summary>
        /// <param name="sender">The samples TreeView.</param>
        /// <param name="e">Event arguments.</param>
        private void OnSelectedSampleChanged(object sender, RoutedPropertyChangedEventArgs<object> e)
        {
            SampleTreeItem item = SampleSelection.SelectedItem as SampleTreeItem;
            if (item != null)
            {
                PopulateSamplesTab(SampleAssembly, item.TreeItemName);
                if (SampleHeader != null)
                {
                    SampleHeader.Text = item.TreeItemName;
                }
            }

            // Reset the CurrentSourceFile tracker
            CurrentSourceFile = null;
        }

        /// <summary>
        /// Collapse the Source File Viewer.
        /// </summary>
        /// <param name="sender">The Sender.</param>
        /// <param name="e">Event arguments.</param>
        private void OnSourceCollapsed(object sender, RoutedEventArgs e)
        {
            ExpandSampleDisplayArea();
            if (SampleGridSplitter != null)
            {
                SampleGridSplitter.Visibility = Visibility.Collapsed;
            }

            IsSourceViewCollapsed = true;
        }

        /// <summary>
        /// Expands the Source File Viewer.
        /// </summary>
        /// <param name="sender">The Sender.</param>
        /// <param name="e">Event arguments.</param>
        private void OnSourceExpanded(object sender, RoutedEventArgs e)
        {
            ExpandSourceViewerArea();
            if (SampleGridSplitter != null)
            {
                SampleGridSplitter.Visibility = Visibility.Visible;
            }

            IsSourceViewCollapsed = false;
        }

        /// <summary>
        /// SamplesTab selection changed.
        /// </summary>
        /// <param name="sender">The Sender.</param>
        /// <param name="e">Event arguments.</param>
        private void OnSamplesTabSelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            // Clear the previous tab item
            TabItem previousTab = e.RemovedItems[0] as TabItem;
            previousTab.Content = null;
            LoadSample();

            // Reset the CurrentSourceFile tracker
            CurrentSourceFile = null;
        }

        /// <summary>
        /// Toggle the full screen view of the samples.
        /// </summary>
        /// <param name="sender">The ToggleButton.</param>
        /// <param name="e">Event arguments.</param>
        private void OnToggleFullScreen(object sender, RoutedEventArgs e)
        {
            Application.Current.Host.Content.IsFullScreen = (bool)FullScreenButton.IsChecked;
        }

        /// <summary>
        /// Handle full screen changes to the application.
        /// </summary>
        /// <param name="sender">The Sender.</param>
        /// <param name="e">Event arguments.</param>
        private void OnFullScreenChanged(object sender, EventArgs e)
        {
            // Uncheck the ToggleButton if the application quit full screen mode
            if (!Application.Current.Host.Content.IsFullScreen && FullScreenButton != null)
            {
                FullScreenButton.IsChecked = false;
            }
        }

        /// <summary>
        /// Change the selected sample.
        /// </summary>
        private void LoadSample()
        {
            SetSourceViewer(null);
            TabItem currentTab = SamplesTab.SelectedItem as TabItem;

            if (currentTab == null)
            {
                return;
            }
            
            // Get the new sample
            SampleBrowserItem item = currentTab.Header as SampleBrowserItem;
            currentTab.Content = item.GetSample();
            UpdateDifficultyLevel(item);
        }

        /// <summary>
        /// Updates the Sample Name and the Level labels.
        /// </summary>
        /// <param name="item">SampleBrowserItem containing Sample related
        /// information.</param>
        private void UpdateDifficultyLevel(SampleBrowserItem item)
        {
            Color SampleDifficultyLevelColor = Colors.Gray;
            SampleDifficultyLevel.Visibility = Visibility.Visible;
            if (SampleDifficultyLevel != null)
            {
                if (item.SampleLevel == DifficultyLevel.Basic)
                {
                    SampleDifficultyLevelColor = Colors.Green;
                }
                else if (item.SampleLevel == DifficultyLevel.Scenario)
                {
                    SampleDifficultyLevelColor = Colors.Orange;
                }
                else if (item.SampleLevel == DifficultyLevel.Advanced)
                {
                    SampleDifficultyLevelColor = Colors.Red;
                }
                else if (item.SampleLevel == DifficultyLevel.Scenario)
                {
                    SampleDifficultyLevelColor = Colors.DarkGray;
                }
                else if (item.SampleLevel == DifficultyLevel.None)
                {
                    SampleDifficultyLevel.Visibility = Visibility.Collapsed;
                }
                SampleDifficultyLevel.Background = new SolidColorBrush(SampleDifficultyLevelColor);
                SampleDifficultyLevel.Content = item.SampleLevel.ToString();
            }
        }

        /// <summary>
        /// Set the SourceViewer for the current sample.
        /// </summary>
        /// <param name="viewer">The SourceViewer.</param>
        /// <remarks>
        /// This is called by the SourceViewer when loaded as a way to notify
        /// the browser that it has source without resorting to walking the
        /// visual tree, etc.
        /// </remarks>
        public void SetSourceViewer(SourceViewer viewer)
        {
            // Clean up the source viewer components
            if (SourceList != null)
            {
                SourceList.Items.Clear();
            }
            if (SourceText != null)
            {
                SourceText.Text = "";
            }

            // Set up the components
            if (viewer == null)
            {
                SourceExpander.Visibility = Visibility.Collapsed;
                SampleGridSplitter.Visibility = Visibility.Collapsed;
                ExpandSampleDisplayArea();
            }
            else
            {
                if (SourceList != null)
                {
                    SourceExpander.Visibility = Visibility.Visible;
                    SampleGridSplitter.Visibility = Visibility.Visible;

                    // Populate the source files
                    foreach (SourceFile file in viewer.Files)
                    {
                        string name = Path.GetFileName(file.Path);
                        string extention = Path.GetExtension(file.Path);
                        StackPanel menuItem = new StackPanel();

                        if (extention.Equals(".cs"))
                        {
                            menuItem = CreateMenuItem("cslogo.png", name);
                        }
                        else if (extention.Equals(".vb"))
                        {
                            menuItem = CreateMenuItem("vblogo.png", name);
                        }
                        else if (extention.Equals(".xaml"))
                        {
                            menuItem = CreateMenuItem("xamllogo.png", name);
                        }
                        SourceList.Items.Add(new ListBoxItem { Content = menuItem, Tag = file });
                    }

                    if (IsSourceViewCollapsed)
                    {
                        ExpandSampleDisplayArea();
                    }
                    else
                    {
                        ExpandSourceViewerArea();
                        Show(SourceList);
                    }

                    if (SourceList.Items.Count > 0)
                    {
                        SourceList.SelectedIndex = 0;
                    }
                }
            }
        }

        /// <summary>
        /// Expands the Source Viewer Area when there are source files to 
        /// display.
        /// </summary>
        private void ExpandSourceViewerArea()
        {
            if (SampleDisplayArea != null)
            {
                SampleDisplayArea.RowDefinitions[SourceViewerRow].Height = new GridLength(SampleDisplayArea.ActualHeight / 2, GridUnitType.Pixel);
            }
        }

        /// <summary>
        /// Expands the Sample Display Area when there is no Source File to 
        /// display. 
        /// </summary>
        private void ExpandSampleDisplayArea()
        {
            if (SampleDisplayArea != null)
            {
                SampleDisplayArea.RowDefinitions[SourceViewerRow].Height = new GridLength(1, GridUnitType.Auto);
            }
        }

        /// <summary>
        /// Helper method to begin a storyboard associated with a control.
        /// </summary>
        /// <param name="control">Control containing a storyboard to be played.
        /// </param>
        private static void Show(Control control)
        {
            Storyboard storyBoard = control.Resources["Show"] as Storyboard;
            if (storyBoard != null)
            {
                storyBoard.Begin();
            }
        }

        /// <summary>
        /// Helper method to create menu items.
        /// </summary>
        /// <param name="resourceName">Name of the resource to be loaded.</param>
        /// <param name="text">Text representing the menu item.</param>
        /// <returns>Returns a stack panel with Image and Text.</returns>
        private static StackPanel CreateMenuItem(string resourceName, string text)
        {
            StackPanel sampleStackPanel = new StackPanel();
            sampleStackPanel.Orientation = Orientation.Horizontal;
            TextBlock textBlock = CreateTextBlock(text);
            Image icon = SharedResources.GetIcon(resourceName);
            icon.Stretch = Stretch.None;
            sampleStackPanel.Children.Add(icon);
            sampleStackPanel.Children.Add(textBlock);
            return sampleStackPanel;
        }

        /// <summary>
        /// Helper function used to generate TextBlock that share common
        /// properties.
        /// </summary>
        /// <param name="text">Text to be used when creating the TextBlock.
        /// </param>
        /// <returns>TextBlock control with common properties set.</returns>
        private static TextBlock CreateTextBlock(string text)
        {
            TextBlock textBlock = new TextBlock { Text = text, FontSize = 11, Margin = new Thickness(3, 0, 0, 0), VerticalAlignment = VerticalAlignment.Center };
            return textBlock;
        }

        /// <summary>
        /// Choose the source file to view.
        /// </summary>
        /// <param name="sender">The SourceList.</param>
        /// <param name="e">Event arguments.</param>
        private void OnSourceFileChanged(object sender, SelectionChangedEventArgs e)
        {
            if (SourceText == null)
            {
                return;
            }

            // Get the selected source file
            ListBoxItem view = SourceList.SelectedItem as ListBoxItem;

            // Remove any previously displayed Sample 
            SourceText.Text = "";

            if (view != null && view.Tag != null)
            {
                // Get the source file
                SourceFile file = view.Tag as SourceFile;
                if (CurrentSourceFile != file)
                {
                    SourceText.Text = file.Source ?? "";
                    
                    // Persist user source file view across sample selection
                    SourceExpander.IsExpanded = (null != CurrentSourceFile) || !IsSourceViewCollapsed;
                    
                    CurrentSourceFile = file;                    
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\Silverlight\3.0\Toolkit\Aug09\Samples\Source\Controls.Samples.Common\SourceViewer\SourceFile.cs ===
﻿// (c) Copyright Microsoft Corporation.
// This source is subject to the Microsoft Public License (Ms-PL).
// Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
// All other rights reserved.

using System;

namespace System.Windows.Controls.Samples
{
    /// <summary>
    /// Represents a file used by a sample and its source.
    /// </summary>
    public class SourceFile
    {
        /// <summary>
        /// Gets or sets the path to the file.
        /// </summary>
        public string Path { get; set; }
        
        /// <summary>
        /// Gets or sets the source code in the file.
        /// </summary>
        public string Source { get; set; }
        
        /// <summary>
        /// Initializes a new instance of the SourceFile class.
        /// </summary>
        public SourceFile()
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sql\2005\SDK\Include\sqlncli.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0408 */
/* Compiler settings for sqlncli.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __sqlncli_h__
#define __sqlncli_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ICommandWithParameters_FWD_DEFINED__
#define __ICommandWithParameters_FWD_DEFINED__
typedef interface ICommandWithParameters ICommandWithParameters;
#endif 	/* __ICommandWithParameters_FWD_DEFINED__ */


#ifndef __IUMSInitialize_FWD_DEFINED__
#define __IUMSInitialize_FWD_DEFINED__
typedef interface IUMSInitialize IUMSInitialize;
#endif 	/* __IUMSInitialize_FWD_DEFINED__ */


#ifndef __ISQLServerErrorInfo_FWD_DEFINED__
#define __ISQLServerErrorInfo_FWD_DEFINED__
typedef interface ISQLServerErrorInfo ISQLServerErrorInfo;
#endif 	/* __ISQLServerErrorInfo_FWD_DEFINED__ */


#ifndef __IRowsetFastLoad_FWD_DEFINED__
#define __IRowsetFastLoad_FWD_DEFINED__
typedef interface IRowsetFastLoad IRowsetFastLoad;
#endif 	/* __IRowsetFastLoad_FWD_DEFINED__ */


#ifndef __ISchemaLock_FWD_DEFINED__
#define __ISchemaLock_FWD_DEFINED__
typedef interface ISchemaLock ISchemaLock;
#endif 	/* __ISchemaLock_FWD_DEFINED__ */


#ifndef __IBCPSession_FWD_DEFINED__
#define __IBCPSession_FWD_DEFINED__
typedef interface IBCPSession IBCPSession;
#endif 	/* __IBCPSession_FWD_DEFINED__ */


#ifndef __ISSAbort_FWD_DEFINED__
#define __ISSAbort_FWD_DEFINED__
typedef interface ISSAbort ISSAbort;
#endif 	/* __ISSAbort_FWD_DEFINED__ */


#ifndef __ISSCommandWithParameters_FWD_DEFINED__
#define __ISSCommandWithParameters_FWD_DEFINED__
typedef interface ISSCommandWithParameters ISSCommandWithParameters;
#endif 	/* __ISSCommandWithParameters_FWD_DEFINED__ */


#ifndef __IDBAsynchStatus_FWD_DEFINED__
#define __IDBAsynchStatus_FWD_DEFINED__
typedef interface IDBAsynchStatus IDBAsynchStatus;
#endif 	/* __IDBAsynchStatus_FWD_DEFINED__ */


#ifndef __ISSAsynchStatus_FWD_DEFINED__
#define __ISSAsynchStatus_FWD_DEFINED__
typedef interface ISSAsynchStatus ISSAsynchStatus;
#endif 	/* __ISSAsynchStatus_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_sqlncli_0000 */
/* [local] */ 

//-----------------------------------------------------------------------------
// File:        sqlncli.h
//
// Copyright:   Copyright (c) Microsoft Corporation
//
// Contents:    SQL Native Client OLEDB provider and ODBC driver specific
//              definitions.
//
//-----------------------------------------------------------------------------

// OLEDB part of Sql Native Client header - begin here
#if defined(_SQLNCLI_OLEDB_) || !defined(_SQLNCLI_ODBC_)
#ifndef  __oledb_h__
#include <oledb.h>
#endif  /*__oledb_h__*/

#if 0        // This is already defined in oledb.h

#ifdef _WIN64

// Length of a non-character object, size
typedef ULONGLONG			DBLENGTH;

// Offset within a rowset
typedef LONGLONG				DBROWOFFSET;

// Number of rows
typedef LONGLONG				DBROWCOUNT;

typedef ULONGLONG			DBCOUNTITEM;

// Ordinal (column number, etc.)
typedef ULONGLONG			DBORDINAL;

typedef LONGLONG				DB_LORDINAL;

// Bookmarks
typedef ULONGLONG			DBBKMARK;
// Offset in the buffer

typedef ULONGLONG			DBBYTEOFFSET;
// Reference count of each row/accessor  handle

typedef ULONG				DBREFCOUNT;

// Parameters
typedef ULONGLONG			DB_UPARAMS;

typedef LONGLONG				DB_LPARAMS;

// hash values corresponding to the elements (bookmarks)
typedef DWORDLONG			DBHASHVALUE;

// For reserve
typedef DWORDLONG			DB_DWRESERVE;

typedef LONGLONG				DB_LRESERVE;

typedef ULONGLONG			DB_URESERVE;

#else //_WIN64

// Length of a non-character object, size
typedef ULONG DBLENGTH;

// Offset within a rowset
typedef LONG DBROWOFFSET;

// Number of rows
typedef LONG DBROWCOUNT;

typedef ULONG DBCOUNTITEM;

// Ordinal (column number, etc.)
typedef ULONG DBORDINAL;

typedef LONG DB_LORDINAL;

// Bookmarks
typedef ULONG DBBKMARK;

// Offset in the buffer
typedef ULONG DBBYTEOFFSET;

// Reference count of each row handle
typedef ULONG DBREFCOUNT;

// Parameters
typedef ULONG DB_UPARAMS;

typedef LONG DB_LPARAMS;

// hash values corresponding to the elements (bookmarks)
typedef DWORD DBHASHVALUE;

// For reserve
typedef DWORD DB_DWRESERVE;

typedef LONG DB_LRESERVE;

typedef ULONG DB_URESERVE;

#endif	// _WIN64
typedef DWORD DBKIND;


enum DBKINDENUM
    {	DBKIND_GUID_NAME	= 0,
	DBKIND_GUID_PROPID	= ( DBKIND_GUID_NAME + 1 ) ,
	DBKIND_NAME	= ( DBKIND_GUID_PROPID + 1 ) ,
	DBKIND_PGUID_NAME	= ( DBKIND_NAME + 1 ) ,
	DBKIND_PGUID_PROPID	= ( DBKIND_PGUID_NAME + 1 ) ,
	DBKIND_PROPID	= ( DBKIND_PGUID_PROPID + 1 ) ,
	DBKIND_GUID	= ( DBKIND_PROPID + 1 ) 
    } ;
typedef struct tagDBID
    {
    union 
        {
        GUID guid;
        GUID *pguid;
         /* Empty union arm */ 
        } 	uGuid;
    DBKIND eKind;
    union 
        {
        LPOLESTR pwszName;
        ULONG ulPropid;
         /* Empty union arm */ 
        } 	uName;
    } 	DBID;

typedef struct tagDB_NUMERIC
    {
    BYTE precision;
    BYTE scale;
    BYTE sign;
    BYTE val[ 16 ];
    } 	DB_NUMERIC;

typedef struct tagDBDATE
    {
    SHORT year;
    USHORT month;
    USHORT day;
    } 	DBDATE;

typedef struct tagDBTIME
    {
    USHORT hour;
    USHORT minute;
    USHORT second;
    } 	DBTIME;

typedef struct tagDBTIMESTAMP
    {
    SHORT year;
    USHORT month;
    USHORT day;
    USHORT hour;
    USHORT minute;
    USHORT second;
    ULONG fraction;
    } 	DBTIMESTAMP;

typedef struct tagDBOBJECT
    {
    DWORD dwFlags;
    IID iid;
    } 	DBOBJECT;

typedef WORD DBTYPE;

typedef ULONG_PTR HACCESSOR;

typedef ULONG_PTR HCHAPTER;

typedef DWORD DBPARAMFLAGS;

typedef struct tagDBPARAMINFO
    {
    DBPARAMFLAGS dwFlags;
    DBORDINAL iOrdinal;
    LPOLESTR pwszName;
    ITypeInfo *pTypeInfo;
    DBLENGTH ulParamSize;
    DBTYPE wType;
    BYTE bPrecision;
    BYTE bScale;
    } 	DBPARAMINFO;

typedef DWORD DBPROPID;

typedef struct tagDBPROPIDSET
    {
    DBPROPID *rgPropertyIDs;
    ULONG cPropertyIDs;
    GUID guidPropertySet;
    } 	DBPROPIDSET;

typedef DWORD DBPROPFLAGS;

typedef DWORD DBPROPOPTIONS;

typedef DWORD DBPROPSTATUS;

typedef struct tagDBPROP
    {
    DBPROPID dwPropertyID;
    DBPROPOPTIONS dwOptions;
    DBPROPSTATUS dwStatus;
    DBID colid;
    VARIANT vValue;
    } 	DBPROP;

typedef struct tagDBPROPSET
    {
    DBPROP *rgProperties;
    ULONG cProperties;
    GUID guidPropertySet;
    } 	DBPROPSET;



extern RPC_IF_HANDLE __MIDL_itf_sqlncli_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sqlncli_0000_v0_0_s_ifspec;

#ifndef __ICommandWithParameters_INTERFACE_DEFINED__
#define __ICommandWithParameters_INTERFACE_DEFINED__

/* interface ICommandWithParameters */
/* [unique][uuid][object] */ 

typedef struct tagDBPARAMBINDINFO
    {
    LPOLESTR pwszDataSourceType;
    LPOLESTR pwszName;
    DBLENGTH ulParamSize;
    DBPARAMFLAGS dwFlags;
    BYTE bPrecision;
    BYTE bScale;
    } 	DBPARAMBINDINFO;


EXTERN_C const IID IID_ICommandWithParameters;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0c733a64-2a1c-11ce-ade5-00aa0044773d")
    ICommandWithParameters : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetParameterInfo( 
            /* [out][in] */ DB_UPARAMS *pcParams,
            /* [size_is][size_is][out] */ DBPARAMINFO **prgParamInfo,
            /* [out] */ OLECHAR **ppNamesBuffer) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE MapParameterNames( 
            /* [in] */ DB_UPARAMS cParamNames,
            /* [size_is][in] */ const OLECHAR *rgParamNames[  ],
            /* [size_is][out] */ DB_LPARAMS rgParamOrdinals[  ]) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SetParameterInfo( 
            /* [in] */ DB_UPARAMS cParams,
            /* [size_is][unique][in] */ const DB_UPARAMS rgParamOrdinals[  ],
            /* [size_is][unique][in] */ const DBPARAMBINDINFO rgParamBindInfo[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICommandWithParametersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICommandWithParameters * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICommandWithParameters * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICommandWithParameters * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetParameterInfo )( 
            ICommandWithParameters * This,
            /* [out][in] */ DB_UPARAMS *pcParams,
            /* [size_is][size_is][out] */ DBPARAMINFO **prgParamInfo,
            /* [out] */ OLECHAR **ppNamesBuffer);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *MapParameterNames )( 
            ICommandWithParameters * This,
            /* [in] */ DB_UPARAMS cParamNames,
            /* [size_is][in] */ const OLECHAR *rgParamNames[  ],
            /* [size_is][out] */ DB_LPARAMS rgParamOrdinals[  ]);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SetParameterInfo )( 
            ICommandWithParameters * This,
            /* [in] */ DB_UPARAMS cParams,
            /* [size_is][unique][in] */ const DB_UPARAMS rgParamOrdinals[  ],
            /* [size_is][unique][in] */ const DBPARAMBINDINFO rgParamBindInfo[  ]);
        
        END_INTERFACE
    } ICommandWithParametersVtbl;

    interface ICommandWithParameters
    {
        CONST_VTBL struct ICommandWithParametersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICommandWithParameters_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICommandWithParameters_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICommandWithParameters_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICommandWithParameters_GetParameterInfo(This,pcParams,prgParamInfo,ppNamesBuffer)	\
    ( (This)->lpVtbl -> GetParameterInfo(This,pcParams,prgParamInfo,ppNamesBuffer) ) 

#define ICommandWithParameters_MapParameterNames(This,cParamNames,rgParamNames,rgParamOrdinals)	\
    ( (This)->lpVtbl -> MapParameterNames(This,cParamNames,rgParamNames,rgParamOrdinals) ) 

#define ICommandWithParameters_SetParameterInfo(This,cParams,rgParamOrdinals,rgParamBindInfo)	\
    ( (This)->lpVtbl -> SetParameterInfo(This,cParams,rgParamOrdinals,rgParamBindInfo) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE ICommandWithParameters_RemoteGetParameterInfo_Proxy( 
    ICommandWithParameters * This,
    /* [out][in] */ DB_UPARAMS *pcParams,
    /* [size_is][size_is][out] */ DBPARAMINFO **prgParamInfo,
    /* [size_is][size_is][out] */ DBBYTEOFFSET **prgNameOffsets,
    /* [out][in] */ DBLENGTH *pcbNamesBuffer,
    /* [size_is][size_is][unique][out][in] */ OLECHAR **ppNamesBuffer,
    /* [out] */ IErrorInfo **ppErrorInfoRem);


void __RPC_STUB ICommandWithParameters_RemoteGetParameterInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ICommandWithParameters_RemoteMapParameterNames_Proxy( 
    ICommandWithParameters * This,
    /* [in] */ DB_UPARAMS cParamNames,
    /* [size_is][in] */ LPCOLESTR *rgParamNames,
    /* [size_is][out] */ DB_LPARAMS *rgParamOrdinals,
    /* [out] */ IErrorInfo **ppErrorInfoRem);


void __RPC_STUB ICommandWithParameters_RemoteMapParameterNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ICommandWithParameters_RemoteSetParameterInfo_Proxy( 
    ICommandWithParameters * This,
    /* [in] */ DB_UPARAMS cParams,
    /* [size_is][unique][in] */ const DB_UPARAMS *rgParamOrdinals,
    /* [size_is][unique][in] */ const DBPARAMBINDINFO *rgParamBindInfo,
    /* [out] */ IErrorInfo **ppErrorInfoRem);


void __RPC_STUB ICommandWithParameters_RemoteSetParameterInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICommandWithParameters_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_sqlncli_0116 */
/* [local] */ 

typedef DWORD DBASYNCHOP;

typedef DWORD DBASYNCHPHASE;

#endif       // This is already defined in oledb.h

//-------------------------------------------------------------------
// Variant Access macros, similar to ole automation.
//-------------------------------------------------------------------
#define V_SS_VT(X)               ((X)->vt)
#define V_SS_UNION(X, Y)         ((X)->Y)

#define V_SS_UI1(X)              V_SS_UNION(X, bTinyIntVal)
#define V_SS_I2(X)               V_SS_UNION(X, sShortIntVal)
#define V_SS_I4(X)               V_SS_UNION(X, lIntVal)
#define V_SS_I8(X)               V_SS_UNION(X, llBigIntVal)

#define V_SS_R4(X)               V_SS_UNION(X, fltRealVal)
#define V_SS_R8(X)               V_SS_UNION(X, dblFloatVal)
#define V_SS_UI4(X)              V_SS_UNION(X, ulVal)

#define V_SS_MONEY(X)            V_SS_UNION(X, cyMoneyVal)
#define V_SS_SMALLMONEY(X)       V_SS_UNION(X, cyMoneyVal)

#define V_SS_WSTRING(X)          V_SS_UNION(X, NCharVal)
#define V_SS_WVARSTRING(X)       V_SS_UNION(X, NCharVal)

#define V_SS_STRING(X)           V_SS_UNION(X, CharVal)
#define V_SS_VARSTRING(X)        V_SS_UNION(X, CharVal)

#define V_SS_BIT(X)              V_SS_UNION(X, fBitVal)
#define V_SS_GUID(X)             V_SS_UNION(X, rgbGuidVal)

#define V_SS_NUMERIC(X)          V_SS_UNION(X, numNumericVal)
#define V_SS_DECIMAL(X)          V_SS_UNION(X, numNumericVal)

#define V_SS_BINARY(X)           V_SS_UNION(X, BinaryVal)
#define V_SS_VARBINARY(X)        V_SS_UNION(X, BinaryVal)

#define V_SS_DATETIME(X)         V_SS_UNION(X, tsDateTimeVal)
#define V_SS_SMALLDATETIME(X)    V_SS_UNION(X, tsDateTimeVal)

#define V_SS_UNKNOWN(X)          V_SS_UNION(X, UnknownType)

//For next release.
#define V_SS_IMAGE(X)            V_SS_UNION(X, ImageVal)
#define V_SS_TEXT(X)             V_SS_UNION(X, TextVal)
#define V_SS_NTEXT(X)            V_SS_UNION(X, NTextVal)

//-------------------------------------------------------------------
// define SQL Server spefific types...
//-------------------------------------------------------------------
typedef enum DBTYPEENUM EOledbTypes;
#define DBTYPE_XML               ((EOledbTypes) 141) // introduced in SQL 2005
#ifdef  _SQLOLEDB_H_
#undef DBTYPE_SQLVARIANT
#endif //_SQLOLEDB_H_
#define DBTYPE_SQLVARIANT        ((EOledbTypes) 144) // introduced in MDAC 2.5


#ifndef  _SQLOLEDB_H_
enum SQLVARENUM
    {
    VT_SS_EMPTY = DBTYPE_EMPTY,
    VT_SS_NULL = DBTYPE_NULL,
    VT_SS_UI1 = DBTYPE_UI1,
    VT_SS_I2 = DBTYPE_I2,
    VT_SS_I4 = DBTYPE_I4,
    VT_SS_I8 = DBTYPE_I8,

    //Floats
    VT_SS_R4  = DBTYPE_R4,
    VT_SS_R8 = DBTYPE_R8,

    //Money
    VT_SS_MONEY = DBTYPE_CY,
    VT_SS_SMALLMONEY  = 200,

    //Strings
    VT_SS_WSTRING    = 201,
    VT_SS_WVARSTRING = 202,

    VT_SS_STRING     = 203,
    VT_SS_VARSTRING  = 204,

    //Bit
    VT_SS_BIT        = DBTYPE_BOOL,

    //Guid
    VT_SS_GUID       = DBTYPE_GUID,

    //Exact precision
    VT_SS_NUMERIC    = DBTYPE_NUMERIC,
    VT_SS_DECIMAL    = 205,

    //Datetime
    VT_SS_DATETIME      = DBTYPE_DBTIMESTAMP,
    VT_SS_SMALLDATETIME =206,

    //Binary
    VT_SS_BINARY =207,
    VT_SS_VARBINARY = 208,
    //Future
    VT_SS_UNKNOWN   = 209,
    };
typedef unsigned short SSVARTYPE;


//-------------------------------------------------------------------
// Class Factory Interface used to initialize pointer to UMS.
//-------------------------------------------------------------------


extern RPC_IF_HANDLE __MIDL_itf_sqlncli_0116_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sqlncli_0116_v0_0_s_ifspec;

#ifndef __IUMSInitialize_INTERFACE_DEFINED__
#define __IUMSInitialize_INTERFACE_DEFINED__

/* interface IUMSInitialize */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IUMSInitialize;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5cf4ca14-ef21-11d0-97e7-00c04fc2ad98")
    IUMSInitialize : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ void *pUMS) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUMSInitializeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUMSInitialize * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUMSInitialize * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUMSInitialize * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IUMSInitialize * This,
            /* [in] */ void *pUMS);
        
        END_INTERFACE
    } IUMSInitializeVtbl;

    interface IUMSInitialize
    {
        CONST_VTBL struct IUMSInitializeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUMSInitialize_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IUMSInitialize_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IUMSInitialize_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IUMSInitialize_Initialize(This,pUMS)	\
    ( (This)->lpVtbl -> Initialize(This,pUMS) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUMSInitialize_Initialize_Proxy( 
    IUMSInitialize * This,
    /* [in] */ void *pUMS);


void __RPC_STUB IUMSInitialize_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUMSInitialize_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_sqlncli_0117 */
/* [local] */ 


// the structure returned by  ISQLServerErrorInfo::GetSQLServerInfo
typedef struct tagSSErrorInfo
    {
    LPOLESTR pwszMessage;
    LPOLESTR pwszServer;
    LPOLESTR pwszProcedure;
    LONG lNative;
    BYTE bState;
    BYTE bClass;
    WORD wLineNumber;
    } 	SSERRORINFO;



extern RPC_IF_HANDLE __MIDL_itf_sqlncli_0117_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sqlncli_0117_v0_0_s_ifspec;

#ifndef __ISQLServerErrorInfo_INTERFACE_DEFINED__
#define __ISQLServerErrorInfo_INTERFACE_DEFINED__

/* interface ISQLServerErrorInfo */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_ISQLServerErrorInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5CF4CA12-EF21-11d0-97E7-00C04FC2AD98")
    ISQLServerErrorInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetErrorInfo( 
            /* [out] */ SSERRORINFO **ppErrorInfo,
            /* [out] */ OLECHAR **ppStringsBuffer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISQLServerErrorInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISQLServerErrorInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISQLServerErrorInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISQLServerErrorInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetErrorInfo )( 
            ISQLServerErrorInfo * This,
            /* [out] */ SSERRORINFO **ppErrorInfo,
            /* [out] */ OLECHAR **ppStringsBuffer);
        
        END_INTERFACE
    } ISQLServerErrorInfoVtbl;

    interface ISQLServerErrorInfo
    {
        CONST_VTBL struct ISQLServerErrorInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISQLServerErrorInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISQLServerErrorInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISQLServerErrorInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISQLServerErrorInfo_GetErrorInfo(This,ppErrorInfo,ppStringsBuffer)	\
    ( (This)->lpVtbl -> GetErrorInfo(This,ppErrorInfo,ppStringsBuffer) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISQLServerErrorInfo_GetErrorInfo_Proxy( 
    ISQLServerErrorInfo * This,
    /* [out] */ SSERRORINFO **ppErrorInfo,
    /* [out] */ OLECHAR **ppStringsBuffer);


void __RPC_STUB ISQLServerErrorInfo_GetErrorInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISQLServerErrorInfo_INTERFACE_DEFINED__ */


#ifndef __IRowsetFastLoad_INTERFACE_DEFINED__
#define __IRowsetFastLoad_INTERFACE_DEFINED__

/* interface IRowsetFastLoad */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IRowsetFastLoad;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5CF4CA13-EF21-11d0-97E7-00C04FC2AD98")
    IRowsetFastLoad : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InsertRow( 
            /* [in] */ HACCESSOR hAccessor,
            /* [in] */ void *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Commit( 
            /* [in] */ BOOL fDone) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRowsetFastLoadVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRowsetFastLoad * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRowsetFastLoad * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRowsetFastLoad * This);
        
        HRESULT ( STDMETHODCALLTYPE *InsertRow )( 
            IRowsetFastLoad * This,
            /* [in] */ HACCESSOR hAccessor,
            /* [in] */ void *pData);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            IRowsetFastLoad * This,
            /* [in] */ BOOL fDone);
        
        END_INTERFACE
    } IRowsetFastLoadVtbl;

    interface IRowsetFastLoad
    {
        CONST_VTBL struct IRowsetFastLoadVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRowsetFastLoad_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRowsetFastLoad_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRowsetFastLoad_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRowsetFastLoad_InsertRow(This,hAccessor,pData)	\
    ( (This)->lpVtbl -> InsertRow(This,hAccessor,pData) ) 

#define IRowsetFastLoad_Commit(This,fDone)	\
    ( (This)->lpVtbl -> Commit(This,fDone) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRowsetFastLoad_InsertRow_Proxy( 
    IRowsetFastLoad * This,
    /* [in] */ HACCESSOR hAccessor,
    /* [in] */ void *pData);


void __RPC_STUB IRowsetFastLoad_InsertRow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRowsetFastLoad_Commit_Proxy( 
    IRowsetFastLoad * This,
    /* [in] */ BOOL fDone);


void __RPC_STUB IRowsetFastLoad_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRowsetFastLoad_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_sqlncli_0119 */
/* [local] */ 

struct SSVARIANT
    {
    SSVARTYPE vt;
    DWORD dwReserved1;
    DWORD dwReserved2;
    union 
        {
        BYTE bTinyIntVal;
        SHORT sShortIntVal;
        LONG lIntVal;
        LONGLONG llBigIntVal;
        FLOAT fltRealVal;
        DOUBLE dblFloatVal;
        CY cyMoneyVal;
        VARIANT_BOOL fBitVal;
        BYTE rgbGuidVal[ 16 ];
        DB_NUMERIC numNumericVal;
        DBTIMESTAMP tsDateTimeVal;
        struct _NCharVal
            {
            SHORT sActualLength;
            SHORT sMaxLength;
            WCHAR *pwchNCharVal;
            BYTE rgbReserved[ 5 ];
            DWORD dwReserved;
            WCHAR *pwchReserved;
            } 	NCharVal;
        struct _CharVal
            {
            SHORT sActualLength;
            SHORT sMaxLength;
            CHAR *pchCharVal;
            BYTE rgbReserved[ 5 ];
            DWORD dwReserved;
            WCHAR *pwchReserved;
            } 	CharVal;
        struct _BinaryVal
            {
            SHORT sActualLength;
            SHORT sMaxLength;
            BYTE *prgbBinaryVal;
            DWORD dwReserved;
            } 	BinaryVal;
        struct _UnknownType
            {
            DWORD dwActualLength;
            BYTE rgMetadata[ 16 ];
            BYTE *pUnknownData;
            } 	UnknownType;
        struct _BLOBType
            {
            DBOBJECT dbobj;
            IUnknown *pUnk;
            } 	BLOBType;
        } 	;
    } ;
typedef DWORD LOCKMODE;


enum LOCKMODEENUM
    {	LOCKMODE_INVALID	= 0,
	LOCKMODE_EXCLUSIVE	= ( LOCKMODE_INVALID + 1 ) ,
	LOCKMODE_SHARED	= ( LOCKMODE_EXCLUSIVE + 1 ) 
    } ;


extern RPC_IF_HANDLE __MIDL_itf_sqlncli_0119_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sqlncli_0119_v0_0_s_ifspec;

#ifndef __ISchemaLock_INTERFACE_DEFINED__
#define __ISchemaLock_INTERFACE_DEFINED__

/* interface ISchemaLock */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_ISchemaLock;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4C2389FB-2511-11d4-B258-00C04F7971CE")
    ISchemaLock : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSchemaLock( 
            /* [in] */ DBID *pTableID,
            /* [in] */ LOCKMODE lmMode,
            /* [out] */ HANDLE *phLockHandle,
            /* [out] */ ULONGLONG *pTableVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseSchemaLock( 
            /* [in] */ HANDLE hLockHandle) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISchemaLockVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISchemaLock * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISchemaLock * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISchemaLock * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSchemaLock )( 
            ISchemaLock * This,
            /* [in] */ DBID *pTableID,
            /* [in] */ LOCKMODE lmMode,
            /* [out] */ HANDLE *phLockHandle,
            /* [out] */ ULONGLONG *pTableVersion);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseSchemaLock )( 
            ISchemaLock * This,
            /* [in] */ HANDLE hLockHandle);
        
        END_INTERFACE
    } ISchemaLockVtbl;

    interface ISchemaLock
    {
        CONST_VTBL struct ISchemaLockVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISchemaLock_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISchemaLock_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISchemaLock_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISchemaLock_GetSchemaLock(This,pTableID,lmMode,phLockHandle,pTableVersion)	\
    ( (This)->lpVtbl -> GetSchemaLock(This,pTableID,lmMode,phLockHandle,pTableVersion) ) 

#define ISchemaLock_ReleaseSchemaLock(This,hLockHandle)	\
    ( (This)->lpVtbl -> ReleaseSchemaLock(This,hLockHandle) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISchemaLock_GetSchemaLock_Proxy( 
    ISchemaLock * This,
    /* [in] */ DBID *pTableID,
    /* [in] */ LOCKMODE lmMode,
    /* [out] */ HANDLE *phLockHandle,
    /* [out] */ ULONGLONG *pTableVersion);


void __RPC_STUB ISchemaLock_GetSchemaLock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISchemaLock_ReleaseSchemaLock_Proxy( 
    ISchemaLock * This,
    /* [in] */ HANDLE hLockHandle);


void __RPC_STUB ISchemaLock_ReleaseSchemaLock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISchemaLock_INTERFACE_DEFINED__ */


#ifndef __IBCPSession_INTERFACE_DEFINED__
#define __IBCPSession_INTERFACE_DEFINED__

/* interface IBCPSession */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IBCPSession;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("88352D80-42D1-42f0-A170-AB0F8B45B939")
    IBCPSession : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BCPColFmt( 
            /* [in] */ DBORDINAL idxUserDataCol,
            /* [in] */ int eUserDataType,
            /* [in] */ int cbIndicator,
            /* [in] */ int cbUserData,
            /* [size_is][in] */ BYTE *pbUserDataTerm,
            /* [in] */ int cbUserDataTerm,
            /* [in] */ DBORDINAL idxServerCol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BCPColumns( 
            /* [in] */ DBCOUNTITEM nColumns) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BCPControl( 
            /* [in] */ int eOption,
            /* [in] */ void *iValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BCPDone( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BCPExec( 
            /* [out] */ DBROWCOUNT *pRowsCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BCPInit( 
            /* [string][in] */ const wchar_t *pwszTable,
            /* [string][in] */ const wchar_t *pwszDataFile,
            /* [string][in] */ const wchar_t *pwszErrorFile,
            /* [in] */ int eDirection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BCPReadFmt( 
            /* [string][in] */ const wchar_t *pwszFormatFile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BCPWriteFmt( 
            /* [string][in] */ const wchar_t *pwszFormatFile) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBCPSessionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBCPSession * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBCPSession * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBCPSession * This);
        
        HRESULT ( STDMETHODCALLTYPE *BCPColFmt )( 
            IBCPSession * This,
            /* [in] */ DBORDINAL idxUserDataCol,
            /* [in] */ int eUserDataType,
            /* [in] */ int cbIndicator,
            /* [in] */ int cbUserData,
            /* [size_is][in] */ BYTE *pbUserDataTerm,
            /* [in] */ int cbUserDataTerm,
            /* [in] */ DBORDINAL idxServerCol);
        
        HRESULT ( STDMETHODCALLTYPE *BCPColumns )( 
            IBCPSession * This,
            /* [in] */ DBCOUNTITEM nColumns);
        
        HRESULT ( STDMETHODCALLTYPE *BCPControl )( 
            IBCPSession * This,
            /* [in] */ int eOption,
            /* [in] */ void *iValue);
        
        HRESULT ( STDMETHODCALLTYPE *BCPDone )( 
            IBCPSession * This);
        
        HRESULT ( STDMETHODCALLTYPE *BCPExec )( 
            IBCPSession * This,
            /* [out] */ DBROWCOUNT *pRowsCopied);
        
        HRESULT ( STDMETHODCALLTYPE *BCPInit )( 
            IBCPSession * This,
            /* [string][in] */ const wchar_t *pwszTable,
            /* [string][in] */ const wchar_t *pwszDataFile,
            /* [string][in] */ const wchar_t *pwszErrorFile,
            /* [in] */ int eDirection);
        
        HRESULT ( STDMETHODCALLTYPE *BCPReadFmt )( 
            IBCPSession * This,
            /* [string][in] */ const wchar_t *pwszFormatFile);
        
        HRESULT ( STDMETHODCALLTYPE *BCPWriteFmt )( 
            IBCPSession * This,
            /* [string][in] */ const wchar_t *pwszFormatFile);
        
        END_INTERFACE
    } IBCPSessionVtbl;

    interface IBCPSession
    {
        CONST_VTBL struct IBCPSessionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBCPSession_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBCPSession_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBCPSession_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBCPSession_BCPColFmt(This,idxUserDataCol,eUserDataType,cbIndicator,cbUserData,pbUserDataTerm,cbUserDataTerm,idxServerCol)	\
    ( (This)->lpVtbl -> BCPColFmt(This,idxUserDataCol,eUserDataType,cbIndicator,cbUserData,pbUserDataTerm,cbUserDataTerm,idxServerCol) ) 

#define IBCPSession_BCPColumns(This,nColumns)	\
    ( (This)->lpVtbl -> BCPColumns(This,nColumns) ) 

#define IBCPSession_BCPControl(This,eOption,iValue)	\
    ( (This)->lpVtbl -> BCPControl(This,eOption,iValue) ) 

#define IBCPSession_BCPDone(This)	\
    ( (This)->lpVtbl -> BCPDone(This) ) 

#define IBCPSession_BCPExec(This,pRowsCopied)	\
    ( (This)->lpVtbl -> BCPExec(This,pRowsCopied) ) 

#define IBCPSession_BCPInit(This,pwszTable,pwszDataFile,pwszErrorFile,eDirection)	\
    ( (This)->lpVtbl -> BCPInit(This,pwszTable,pwszDataFile,pwszErrorFile,eDirection) ) 

#define IBCPSession_BCPReadFmt(This,pwszFormatFile)	\
    ( (This)->lpVtbl -> BCPReadFmt(This,pwszFormatFile) ) 

#define IBCPSession_BCPWriteFmt(This,pwszFormatFile)	\
    ( (This)->lpVtbl -> BCPWriteFmt(This,pwszFormatFile) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBCPSession_BCPColFmt_Proxy( 
    IBCPSession * This,
    /* [in] */ DBORDINAL idxUserDataCol,
    /* [in] */ int eUserDataType,
    /* [in] */ int cbIndicator,
    /* [in] */ int cbUserData,
    /* [size_is][in] */ BYTE *pbUserDataTerm,
    /* [in] */ int cbUserDataTerm,
    /* [in] */ DBORDINAL idxServerCol);


void __RPC_STUB IBCPSession_BCPColFmt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBCPSession_BCPColumns_Proxy( 
    IBCPSession * This,
    /* [in] */ DBCOUNTITEM nColumns);


void __RPC_STUB IBCPSession_BCPColumns_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBCPSession_BCPControl_Proxy( 
    IBCPSession * This,
    /* [in] */ int eOption,
    /* [in] */ void *iValue);


void __RPC_STUB IBCPSession_BCPControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBCPSession_BCPDone_Proxy( 
    IBCPSession * This);


void __RPC_STUB IBCPSession_BCPDone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBCPSession_BCPExec_Proxy( 
    IBCPSession * This,
    /* [out] */ DBROWCOUNT *pRowsCopied);


void __RPC_STUB IBCPSession_BCPExec_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBCPSession_BCPInit_Proxy( 
    IBCPSession * This,
    /* [string][in] */ const wchar_t *pwszTable,
    /* [string][in] */ const wchar_t *pwszDataFile,
    /* [string][in] */ const wchar_t *pwszErrorFile,
    /* [in] */ int eDirection);


void __RPC_STUB IBCPSession_BCPInit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBCPSession_BCPReadFmt_Proxy( 
    IBCPSession * This,
    /* [string][in] */ const wchar_t *pwszFormatFile);


void __RPC_STUB IBCPSession_BCPReadFmt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBCPSession_BCPWriteFmt_Proxy( 
    IBCPSession * This,
    /* [string][in] */ const wchar_t *pwszFormatFile);


void __RPC_STUB IBCPSession_BCPWriteFmt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBCPSession_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_sqlncli_0121 */
/* [local] */ 


#endif //_SQLOLEDB_H_

#define ISOLATIONLEVEL_SNAPSHOT          ((ISOLATIONLEVEL)(0x01000000)) // Changes made in other transactions can not be seen.

#define DBPROPVAL_TI_SNAPSHOT            0x01000000L



extern RPC_IF_HANDLE __MIDL_itf_sqlncli_0121_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sqlncli_0121_v0_0_s_ifspec;

#ifndef __ISSAbort_INTERFACE_DEFINED__
#define __ISSAbort_INTERFACE_DEFINED__

/* interface ISSAbort */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_ISSAbort;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5CF4CA15-EF21-11d0-97E7-00C04FC2AD98")
    ISSAbort : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Abort( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISSAbortVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISSAbort * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISSAbort * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISSAbort * This);
        
        HRESULT ( STDMETHODCALLTYPE *Abort )( 
            ISSAbort * This);
        
        END_INTERFACE
    } ISSAbortVtbl;

    interface ISSAbort
    {
        CONST_VTBL struct ISSAbortVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISSAbort_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISSAbort_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISSAbort_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISSAbort_Abort(This)	\
    ( (This)->lpVtbl -> Abort(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISSAbort_Abort_Proxy( 
    ISSAbort * This);


void __RPC_STUB ISSAbort_Abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISSAbort_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_sqlncli_0122 */
/* [local] */ 


enum DBBINDFLAGENUM90
    {	DBBINDFLAG_OBJECT	= 0x2
    } ;

enum DBPROPFLAGSENUM90
    {	DBPROPFLAGS_PARAMETER	= 0x10000
    } ;
typedef struct tagSSPARAMPROPS
    {
    DBORDINAL iOrdinal;
    ULONG cPropertySets;
    DBPROPSET *rgPropertySets;
    } 	SSPARAMPROPS;



extern RPC_IF_HANDLE __MIDL_itf_sqlncli_0122_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sqlncli_0122_v0_0_s_ifspec;

#ifndef __ISSCommandWithParameters_INTERFACE_DEFINED__
#define __ISSCommandWithParameters_INTERFACE_DEFINED__

/* interface ISSCommandWithParameters */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISSCommandWithParameters;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("eec30162-6087-467c-b995-7c523ce96561")
    ISSCommandWithParameters : public ICommandWithParameters
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetParameterProperties( 
            /* [out][in] */ DB_UPARAMS *pcParams,
            /* [size_is][size_is][out] */ SSPARAMPROPS **prgParamProperties) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SetParameterProperties( 
            /* [in] */ DB_UPARAMS cParams,
            /* [size_is][unique][in] */ SSPARAMPROPS rgParamProperties[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISSCommandWithParametersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISSCommandWithParameters * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISSCommandWithParameters * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISSCommandWithParameters * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetParameterInfo )( 
            ISSCommandWithParameters * This,
            /* [out][in] */ DB_UPARAMS *pcParams,
            /* [size_is][size_is][out] */ DBPARAMINFO **prgParamInfo,
            /* [out] */ OLECHAR **ppNamesBuffer);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *MapParameterNames )( 
            ISSCommandWithParameters * This,
            /* [in] */ DB_UPARAMS cParamNames,
            /* [size_is][in] */ const OLECHAR *rgParamNames[  ],
            /* [size_is][out] */ DB_LPARAMS rgParamOrdinals[  ]);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SetParameterInfo )( 
            ISSCommandWithParameters * This,
            /* [in] */ DB_UPARAMS cParams,
            /* [size_is][unique][in] */ const DB_UPARAMS rgParamOrdinals[  ],
            /* [size_is][unique][in] */ const DBPARAMBINDINFO rgParamBindInfo[  ]);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetParameterProperties )( 
            ISSCommandWithParameters * This,
            /* [out][in] */ DB_UPARAMS *pcParams,
            /* [size_is][size_is][out] */ SSPARAMPROPS **prgParamProperties);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *SetParameterProperties )( 
            ISSCommandWithParameters * This,
            /* [in] */ DB_UPARAMS cParams,
            /* [size_is][unique][in] */ SSPARAMPROPS rgParamProperties[  ]);
        
        END_INTERFACE
    } ISSCommandWithParametersVtbl;

    interface ISSCommandWithParameters
    {
        CONST_VTBL struct ISSCommandWithParametersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISSCommandWithParameters_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISSCommandWithParameters_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISSCommandWithParameters_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISSCommandWithParameters_GetParameterInfo(This,pcParams,prgParamInfo,ppNamesBuffer)	\
    ( (This)->lpVtbl -> GetParameterInfo(This,pcParams,prgParamInfo,ppNamesBuffer) ) 

#define ISSCommandWithParameters_MapParameterNames(This,cParamNames,rgParamNames,rgParamOrdinals)	\
    ( (This)->lpVtbl -> MapParameterNames(This,cParamNames,rgParamNames,rgParamOrdinals) ) 

#define ISSCommandWithParameters_SetParameterInfo(This,cParams,rgParamOrdinals,rgParamBindInfo)	\
    ( (This)->lpVtbl -> SetParameterInfo(This,cParams,rgParamOrdinals,rgParamBindInfo) ) 


#define ISSCommandWithParameters_GetParameterProperties(This,pcParams,prgParamProperties)	\
    ( (This)->lpVtbl -> GetParameterProperties(This,pcParams,prgParamProperties) ) 

#define ISSCommandWithParameters_SetParameterProperties(This,cParams,rgParamProperties)	\
    ( (This)->lpVtbl -> SetParameterProperties(This,cParams,rgParamProperties) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [local] */ HRESULT STDMETHODCALLTYPE ISSCommandWithParameters_GetParameterProperties_Proxy( 
    ISSCommandWithParameters * This,
    /* [out][in] */ DB_UPARAMS *pcParams,
    /* [size_is][size_is][out] */ SSPARAMPROPS **prgParamProperties);


void __RPC_STUB ISSCommandWithParameters_GetParameterProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ HRESULT STDMETHODCALLTYPE ISSCommandWithParameters_SetParameterProperties_Proxy( 
    ISSCommandWithParameters * This,
    /* [in] */ DB_UPARAMS cParams,
    /* [size_is][unique][in] */ SSPARAMPROPS rgParamProperties[  ]);


void __RPC_STUB ISSCommandWithParameters_SetParameterProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISSCommandWithParameters_INTERFACE_DEFINED__ */


#ifndef __IDBAsynchStatus_INTERFACE_DEFINED__
#define __IDBAsynchStatus_INTERFACE_DEFINED__

/* interface IDBAsynchStatus */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDBAsynchStatus;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0c733a95-2a1c-11ce-ade5-00aa0044773d")
    IDBAsynchStatus : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Abort( 
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ DBASYNCHOP eOperation) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ DBASYNCHOP eOperation,
            /* [out] */ DBCOUNTITEM *pulProgress,
            /* [out] */ DBCOUNTITEM *pulProgressMax,
            /* [out] */ DBASYNCHPHASE *peAsynchPhase,
            /* [out] */ LPOLESTR *ppwszStatusText) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDBAsynchStatusVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDBAsynchStatus * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDBAsynchStatus * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDBAsynchStatus * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Abort )( 
            IDBAsynchStatus * This,
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ DBASYNCHOP eOperation);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            IDBAsynchStatus * This,
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ DBASYNCHOP eOperation,
            /* [out] */ DBCOUNTITEM *pulProgress,
            /* [out] */ DBCOUNTITEM *pulProgressMax,
            /* [out] */ DBASYNCHPHASE *peAsynchPhase,
            /* [out] */ LPOLESTR *ppwszStatusText);
        
        END_INTERFACE
    } IDBAsynchStatusVtbl;

    interface IDBAsynchStatus
    {
        CONST_VTBL struct IDBAsynchStatusVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDBAsynchStatus_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDBAsynchStatus_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDBAsynchStatus_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDBAsynchStatus_Abort(This,hChapter,eOperation)	\
    ( (This)->lpVtbl -> Abort(This,hChapter,eOperation) ) 

#define IDBAsynchStatus_GetStatus(This,hChapter,eOperation,pulProgress,pulProgressMax,peAsynchPhase,ppwszStatusText)	\
    ( (This)->lpVtbl -> GetStatus(This,hChapter,eOperation,pulProgress,pulProgressMax,peAsynchPhase,ppwszStatusText) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IDBAsynchStatus_RemoteAbort_Proxy( 
    IDBAsynchStatus * This,
    /* [in] */ HCHAPTER hChapter,
    /* [in] */ DBASYNCHOP eOperation,
    /* [out] */ IErrorInfo **ppErrorInfoRem);


void __RPC_STUB IDBAsynchStatus_RemoteAbort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDBAsynchStatus_RemoteGetStatus_Proxy( 
    IDBAsynchStatus * This,
    /* [in] */ HCHAPTER hChapter,
    /* [in] */ DBASYNCHOP eOperation,
    /* [unique][out][in] */ DBCOUNTITEM *pulProgress,
    /* [unique][out][in] */ DBCOUNTITEM *pulProgressMax,
    /* [unique][out][in] */ DBASYNCHPHASE *peAsynchPhase,
    /* [unique][out][in] */ LPOLESTR *ppwszStatusText,
    /* [out] */ IErrorInfo **ppErrorInfoRem);


void __RPC_STUB IDBAsynchStatus_RemoteGetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDBAsynchStatus_INTERFACE_DEFINED__ */


#ifndef __ISSAsynchStatus_INTERFACE_DEFINED__
#define __ISSAsynchStatus_INTERFACE_DEFINED__

/* interface ISSAsynchStatus */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISSAsynchStatus;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1FF1F743-8BB0-4c00-ACC4-C10E43B08FC1")
    ISSAsynchStatus : public IDBAsynchStatus
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE WaitForAsynchCompletion( 
            /* [in] */ DWORD dwMillisecTimeOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISSAsynchStatusVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISSAsynchStatus * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISSAsynchStatus * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISSAsynchStatus * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Abort )( 
            ISSAsynchStatus * This,
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ DBASYNCHOP eOperation);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            ISSAsynchStatus * This,
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ DBASYNCHOP eOperation,
            /* [out] */ DBCOUNTITEM *pulProgress,
            /* [out] */ DBCOUNTITEM *pulProgressMax,
            /* [out] */ DBASYNCHPHASE *peAsynchPhase,
            /* [out] */ LPOLESTR *ppwszStatusText);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *WaitForAsynchCompletion )( 
            ISSAsynchStatus * This,
            /* [in] */ DWORD dwMillisecTimeOut);
        
        END_INTERFACE
    } ISSAsynchStatusVtbl;

    interface ISSAsynchStatus
    {
        CONST_VTBL struct ISSAsynchStatusVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISSAsynchStatus_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISSAsynchStatus_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISSAsynchStatus_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISSAsynchStatus_Abort(This,hChapter,eOperation)	\
    ( (This)->lpVtbl -> Abort(This,hChapter,eOperation) ) 

#define ISSAsynchStatus_GetStatus(This,hChapter,eOperation,pulProgress,pulProgressMax,peAsynchPhase,ppwszStatusText)	\
    ( (This)->lpVtbl -> GetStatus(This,hChapter,eOperation,pulProgress,pulProgressMax,peAsynchPhase,ppwszStatusText) ) 


#define ISSAsynchStatus_WaitForAsynchCompletion(This,dwMillisecTimeOut)	\
    ( (This)->lpVtbl -> WaitForAsynchCompletion(This,dwMillisecTimeOut) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [local] */ HRESULT STDMETHODCALLTYPE ISSAsynchStatus_WaitForAsynchCompletion_Proxy( 
    ISSAsynchStatus * This,
    /* [in] */ DWORD dwMillisecTimeOut);


void __RPC_STUB ISSAsynchStatus_WaitForAsynchCompletion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISSAsynchStatus_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_sqlncli_0125 */
/* [local] */ 

//----------------------------------------------------------------------------
// Values for STATUS bitmask for DBSCHEMA_TABLES & DBSCHEMA_TABLES_INFO
#define TABLE_HAS_UPDATE_INSTEAD_OF_TRIGGER     0x00000001 //table has IOT defined
#define TABLE_HAS_DELETE_INSTEAD_OF_TRIGGER     0x00000002 //table has IOT defined
#define TABLE_HAS_INSERT_INSTEAD_OF_TRIGGER     0x00000004 //table has IOT defined
#define TABLE_HAS_AFTER_UPDATE_TRIGGER          0x00000008 //table has update trigger
#define TABLE_HAS_AFTER_DELETE_TRIGGER          0x00000010 //table has delete trigger
#define TABLE_HAS_AFTER_INSERT_TRIGGER          0x00000020 //table has insert trigger
#define TABLE_HAS_CASCADE_UPDATE                0x00000040 //table has cascade update
#define TABLE_HAS_CASCADE_DELETE                0x00000080 //table has cascade delete

//----------------------------------------------------------------------------
// PropIds for DBPROP_INIT_GENERALTIMEOUT
#if (OLEDBVER >= 0x0210)
#define DBPROP_INIT_GENERALTIMEOUT      0x11cL
#endif

//----------------------------------------------------------------------------
// PropIds for DBPROPSET_SQLSERVERDATASOURCE
#define SSPROP_ENABLEFASTLOAD           2
#define SSPROP_ENABLEBULKCOPY           3

//----------------------------------------------------------------------------
// PropIds for DBPROPSET_SQLSERVERDATASOURCEINFO
#define SSPROP_UNICODELCID              2
#define SSPROP_UNICODECOMPARISONSTYLE   3
#define SSPROP_COLUMNLEVELCOLLATION     4
#define SSPROP_CHARACTERSET             5
#define SSPROP_SORTORDER                6
#define SSPROP_CURRENTCOLLATION         7

//----------------------------------------------------------------------------
// PropIds for DBPROPSET_SQLSERVERDBINIT
#define SSPROP_INIT_CURRENTLANGUAGE              4
#define SSPROP_INIT_NETWORKADDRESS               5
#define SSPROP_INIT_NETWORKLIBRARY               6
#define SSPROP_INIT_USEPROCFORPREP               7
#define SSPROP_INIT_AUTOTRANSLATE                8
#define SSPROP_INIT_PACKETSIZE                   9
#define SSPROP_INIT_APPNAME                      10
#define SSPROP_INIT_WSID                         11
#define SSPROP_INIT_FILENAME                     12
#define SSPROP_INIT_ENCRYPT                      13
#define SSPROP_AUTH_REPL_SERVER_NAME             14
#define SSPROP_INIT_TAGCOLUMNCOLLATION           15
#define SSPROP_INIT_MARSCONNECTION               16
#define SSPROP_INIT_ASYNCHCONNECTION             17
#define SSPROP_INIT_FAILOVERPARTNER              18
#define SSPROP_AUTH_OLD_PASSWORD                 19
#define SSPROP_INIT_DATATYPECOMPATIBILITY        20
#define SSPROP_INIT_TRUST_SERVER_CERTIFICATE     21

//-----------------------------------------------------------------------------
// Values for SSPROP_INIT_USEPROCFORPREP
#define SSPROPVAL_USEPROCFORPREP_OFF        0
#define SSPROPVAL_USEPROCFORPREP_ON         1
#define SSPROPVAL_USEPROCFORPREP_ON_DROP    2

//-----------------------------------------------------------------------------
// Values for SSPROP_INIT_DATATYPECOMPATIBILITY
#define SSPROPVAL_DATATYPECOMPATIBILITY_SQL2000  80
#define SSPROPVAL_DATATYPECOMPATIBILITY_DEFAULT  0

//----------------------------------------------------------------------------
// PropIds for DBPROPSET_SQLSERVERSESSION
#define SSPROP_QUOTEDCATALOGNAMES       2
#define SSPROP_ALLOWNATIVEVARIANT       3
#define SSPROP_SQLXMLXPROGID            4
#define SSPROP_ASYNCH_BULKCOPY          5

//----------------------------------------------------------------------------
// PropIds for DBPROPSET_SQLSERVERROWSET
#define SSPROP_MAXBLOBLENGTH            8
#define SSPROP_FASTLOADOPTIONS          9
#define SSPROP_FASTLOADKEEPNULLS        10
#define SSPROP_FASTLOADKEEPIDENTITY     11
#define SSPROP_CURSORAUTOFETCH          12
#define SSPROP_DEFERPREPARE             13
#define SSPROP_IRowsetFastLoad          14
#define SSPROP_QP_NOTIFICATION_TIMEOUT  17
#define SSPROP_QP_NOTIFICATION_MSGTEXT  18
#define SSPROP_QP_NOTIFICATION_OPTIONS  19
#define SSPROP_NOCOUNT_STATUS           20
#define SSPROP_COMPUTE_ID               21
#define SSPROP_COLUMN_ID                22
#define SSPROP_COMPUTE_BYLIST           23
#define SSPROP_ISSAsynchStatus          24

//-----------------------------------------------------------------------------
// Values for SSPROP_QP_NOTIFICATION_TIMEOUT
#define SSPROPVAL_DEFAULT_NOTIFICATION_TIMEOUT  432000 /* in sec */
#define SSPROPVAL_MAX_NOTIFICATION_TIMEOUT      0x7FFFFFFF /* in sec */
#define MAX_NOTIFICATION_LEN                    2000 /* NVARCHAR [2000] for both ID & DELIVERY_QUEUE */

//----------------------------------------------------------------------------
// PropIds for DBPROPSET_SQLSERVERCOLUMN
#define SSPROP_COL_COLLATIONNAME                         14
#define SSPROP_COL_UDT_CATALOGNAME                       31
#define SSPROP_COL_UDT_SCHEMANAME                        32
#define SSPROP_COL_UDT_NAME                              33
#define SSPROP_COL_XML_SCHEMACOLLECTION_CATALOGNAME      34
#define SSPROP_COL_XML_SCHEMACOLLECTION_SCHEMANAME       35
#define SSPROP_COL_XML_SCHEMACOLLECTIONNAME              36


//----------------------------------------------------------------------------
// PropIds for DBPROPSET_SQLSERVERSTREAM
#define SSPROP_STREAM_COMMANDTYPE                        18
#define SSPROP_STREAM_XMLROOT                            19

//----------------------------------------------------------------------------
// PropIds for DBPROPSET_SQLSERVERPARAMETER
#define SSPROP_PARAM_XML_SCHEMACOLLECTION_CATALOGNAME    24
#define SSPROP_PARAM_XML_SCHEMACOLLECTION_SCHEMANAME     25
#define SSPROP_PARAM_XML_SCHEMACOLLECTIONNAME            26
#define SSPROP_PARAM_UDT_CATALOGNAME                     27
#define SSPROP_PARAM_UDT_SCHEMANAME                      28
#define SSPROP_PARAM_UDT_NAME                            29

//----------------------------------------------------------------------------
// Possible values for SSPROP_STREAM_FLAGS
#define STREAM_FLAGS_DISALLOW_URL           0x00000001
#define STREAM_FLAGS_DISALLOW_ABSOLUTE_PATH 0x00000002
#define STREAM_FLAGS_DISALLOW_QUERY         0x00000004
#define STREAM_FLAGS_DONTCACHEMAPPINGSCHEMA 0x00000008
#define STREAM_FLAGS_DONTCACHETEMPLATE      0x00000010
#define STREAM_FLAGS_DONTCACHEXSL           0x00000020
#define STREAM_FLAGS_DISALLOW_UPDATEGRAMS   0x00000040
#define STREAM_FLAGS_RESERVED               0xffff0000

//----------------------------------------------------------------------------
// PropIds for DBPROPSET_SQLSERVERINDEX
#define SSPROP_INDEX_XML                 1

//-----------------------------------------------------------------------------
// Values for SSPROPVAL_COMMANDTYPE
#define SSPROPVAL_COMMANDTYPE_REGULAR   21
#define SSPROPVAL_COMMANDTYPE_BULKLOAD  22

//-----------------------------------------------------------------------------
//
#define BCP_TYPE_DEFAULT         0x00
#define BCP_TYPE_SQLTEXT         0x23
#define BCP_TYPE_SQLVARBINARY    0x25
#define BCP_TYPE_SQLINTN         0x26
#define BCP_TYPE_SQLVARCHAR      0x27
#define BCP_TYPE_SQLBINARY       0x2d
#define BCP_TYPE_SQLIMAGE        0x22
#define BCP_TYPE_SQLCHARACTER    0x2f
#define BCP_TYPE_SQLINT1         0x30
#define BCP_TYPE_SQLBIT          0x32
#define BCP_TYPE_SQLINT2         0x34
#define BCP_TYPE_SQLINT4         0x38
#define BCP_TYPE_SQLMONEY        0x3c
#define BCP_TYPE_SQLDATETIME     0x3d
#define BCP_TYPE_SQLFLT8         0x3e
#define BCP_TYPE_SQLFLTN         0x6d
#define BCP_TYPE_SQLMONEYN       0x6e
#define BCP_TYPE_SQLDATETIMN     0x6f
#define BCP_TYPE_SQLFLT4         0x3b
#define BCP_TYPE_SQLMONEY4       0x7a
#define BCP_TYPE_SQLDATETIM4     0x3a
#define BCP_TYPE_SQLDECIMAL      0x6a
#define BCP_TYPE_SQLNUMERIC      0x6c
#define BCP_TYPE_SQLUNIQUEID     0x24
#define BCP_TYPE_SQLBIGCHAR      0xaf
#define BCP_TYPE_SQLBIGVARCHAR   0xa7
#define BCP_TYPE_SQLBIGBINARY    0xad
#define BCP_TYPE_SQLBIGVARBINARY 0xa5
#define BCP_TYPE_SQLBITN         0x68
#define BCP_TYPE_SQLNCHAR        0xef
#define BCP_TYPE_SQLNVARCHAR     0xe7
#define BCP_TYPE_SQLNTEXT        0x63
#define BCP_TYPE_SQLDECIMALN     0x6a
#define BCP_TYPE_SQLNUMERICN     0x6c
#define BCP_TYPE_SQLINT8         0x7f
#define BCP_TYPE_SQLVARIANT      0x62
#define BCP_TYPE_SQLUDT          0xf0
#define BCP_TYPE_SQLXML          0xf1

#define BCP_DIRECTION_IN            1
#define BCP_DIRECTION_OUT           2

#define BCP_OPTION_MAXERRS          1
#define BCP_OPTION_FIRST            2
#define BCP_OPTION_LAST             3
#define BCP_OPTION_BATCH            4
#define BCP_OPTION_KEEPNULLS        5
#define BCP_OPTION_ABORT            6
#define BCP_OPTION_KEEPIDENTITY     8
#define BCP_OPTION_HINTSA           10
#define BCP_OPTION_HINTSW           11
#define BCP_OPTION_FILECP           12
#define BCP_OPTION_UNICODEFILE      13
#define BCP_OPTION_TEXTFILE         14
#define BCP_OPTION_FILEFMT          15
#define BCP_OPTION_FMTXML           16

#define BCP_FILECP_ACP              0
#define BCP_FILECP_OEMCP            1
#define BCP_FILECP_RAW              (-1)

#ifdef UNICODE
#define BCP_OPTION_HINTS             BCP_OPTION_HINTSW
#else
#define BCP_OPTION_HINTS             BCP_OPTION_HINTSA
#endif

#define BCP_PREFIX_DEFAULT           (-10)

#define BCP_LENGTH_NULL              (-1)
#define BCP_LENGTH_VARIABLE          (-10)
//
//-----------------------------------------------------------------------------


//----------------------------------------------------------------------------
// Provider-specific Class Ids
//
extern const GUID OLEDBDECLSPEC CLSID_SQLNCLI                = {0x85ecafccL,0xbdd9,0x4b03,{0x97,0xa8,0xfa,0x65,0xcb,0xe3,0x85,0x9b}};
extern const GUID OLEDBDECLSPEC CLSID_SQLNCLI_ERROR          = {0xe8bc0a7aL,0xea71,0x4263,{0x8c,0xda,0x94,0xf3,0x88,0xb8,0xed,0x10}};
extern const GUID OLEDBDECLSPEC CLSID_SQLNCLI_ENUMERATOR     = {0x4898ad37L,0xfe05,0x42df,{0x92,0xf9,0xe8,0x57,0xdd,0xfe,0xe7,0x30}};


//----------------------------------------------------------------------------
// Provider-specific Interface Ids
//
#ifndef  _SQLOLEDB_H_
extern const GUID OLEDBDECLSPEC IID_ISQLServerErrorInfo      = {0x5cf4ca12,0xef21,0x11d0,{0x97,0xe7,0x0,0xc0,0x4f,0xc2,0xad,0x98}};
extern const GUID OLEDBDECLSPEC IID_IRowsetFastLoad          = {0x5cf4ca13,0xef21,0x11d0,{0x97,0xe7,0x0,0xc0,0x4f,0xc2,0xad,0x98}};
extern const GUID OLEDBDECLSPEC IID_IUMSInitialize           = {0x5cf4ca14,0xef21,0x11d0,{0x97,0xe7,0x0,0xc0,0x4f,0xc2,0xad,0x98}};
extern const GUID OLEDBDECLSPEC IID_ISchemaLock              = {0x4c2389fb,0x2511,0x11d4,{0xb2,0x58,0x0,0xc0,0x4f,0x79,0x71,0xce}};
extern const GUID OLEDBDECLSPEC IID_ISQLXMLHelper            = {0xd22a7678L,0xf860,0x40cd,{0xa5,0x67,0x15,0x63,0xde,0xb4,0x6d,0x49}};
#endif //_SQLOLEDB_H_
extern const GUID OLEDBDECLSPEC IID_ISSAbort                 = {0x5cf4ca15,0xef21,0x11d0,{0x97,0xe7,0x0,0xc0,0x4f,0xc2,0xad,0x98}};
extern const GUID OLEDBDECLSPEC IID_IBCPSession              = {0x88352D80,0x42D1,0x42f0,{0xA1,0x70,0xAB,0x0F,0x8B,0x45,0xB9,0x39}};
extern const GUID OLEDBDECLSPEC IID_ISSCommandWithParameters = {0xeec30162,0x6087,0x467c,{0xb9,0x95,0x7c,0x52,0x3c,0xe9,0x65,0x61}};
extern const GUID OLEDBDECLSPEC IID_ISSAsynchStatus          = {0x1FF1F743,0x8BB0, 0x4c00,{0xAC,0xC4,0xC1,0x0E,0x43,0xB0,0x8F,0xC1}};


//----------------------------------------------------------------------------
// Provider-specific schema rowsets
//
#ifndef  _SQLOLEDB_H_
extern const GUID OLEDBDECLSPEC DBSCHEMA_LINKEDSERVERS               = {0x9093caf4,0x2eac,0x11d1,{0x98,0x9,0x0,0xc0,0x4f,0xc2,0xad,0x98}};
#endif //_SQLOLEDB_H_
extern const GUID OLEDBDECLSPEC DBSCHEMA_SQL_ASSEMBLIES              = {0x7c1112c8, 0xc2d3, 0x4f6e, {0x94, 0x9a, 0x98, 0x3d, 0x38, 0xa5, 0x8f, 0x46}};
extern const GUID OLEDBDECLSPEC DBSCHEMA_SQL_ASSEMBLY_DEPENDENCIES   = {0xcb0f837b, 0x974c, 0x41b8, {0x90, 0x9d, 0x64, 0x9c, 0xaf, 0x45, 0xad, 0x2f}};
extern const GUID OLEDBDECLSPEC DBSCHEMA_SQL_USER_TYPES              = {0xf1198bd8, 0xa424, 0x4ea3, {0x8d, 0x4c, 0x60, 0x7e, 0xee, 0x2b, 0xab, 0x60}};
extern const GUID OLEDBDECLSPEC DBSCHEMA_XML_COLLECTIONS             = {0x56bfad8c,0x6e8f,0x480d,{0x91,0xde,0x35,0x16,0xd9,0x9a,0x5d,0x10}};


#ifndef CRESTRICTIONS_DBSCHEMA_LINKEDSERVERS
#define CRESTRICTIONS_DBSCHEMA_LINKEDSERVERS    1
#endif

#ifndef CRESTRICTIONS_DBSCHEMA_ASSEMBLIES
#define CRESTRICTIONS_DBSCHEMA_SQL_ASSEMBLIES       4
#endif

#ifndef CRESTRICTIONS_DBSCHEMA_ASSEMBLY_DEPENDENCIES
#define CRESTRICTIONS_DBSCHEMA_SQL_ASSEMBLY_DEPENDENCIES 4
#endif

#ifndef CRESTRICTIONS_DBSCHEMA_USER_TYPES
#define CRESTRICTIONS_DBSCHEMA_SQL_USER_TYPES   3
#endif

#ifndef CRESTRICTIONS_DBSCHEMA_XML_COLLECTIONS
#define CRESTRICTIONS_DBSCHEMA_XML_COLLECTIONS   4
#endif


//----------------------------------------------------------------------------
// Provider-specific property sets
//
#ifndef  _SQLOLEDB_H_
extern const GUID OLEDBDECLSPEC DBPROPSET_SQLSERVERDATASOURCE    = {0x28efaee4,0x2d2c,0x11d1,{0x98,0x7,0x0,0xc0,0x4f,0xc2,0xad,0x98}};
extern const GUID OLEDBDECLSPEC DBPROPSET_SQLSERVERDATASOURCEINFO= {0xdf10cb94,0x35f6,0x11d2,{0x9c,0x54,0x0,0xc0,0x4f,0x79,0x71,0xd3}};
extern const GUID OLEDBDECLSPEC DBPROPSET_SQLSERVERDBINIT        = {0x5cf4ca10,0xef21,0x11d0,{0x97,0xe7,0x0,0xc0,0x4f,0xc2,0xad,0x98}};
extern const GUID OLEDBDECLSPEC DBPROPSET_SQLSERVERROWSET        = {0x5cf4ca11,0xef21,0x11d0,{0x97,0xe7,0x0,0xc0,0x4f,0xc2,0xad,0x98}};
extern const GUID OLEDBDECLSPEC DBPROPSET_SQLSERVERSESSION       = {0x28efaee5,0x2d2c,0x11d1,{0x98,0x7,0x0,0xc0,0x4f,0xc2,0xad,0x98}};
extern const GUID OLEDBDECLSPEC DBPROPSET_SQLSERVERCOLUMN        = {0x3b63fb5e,0x3fbb,0x11d3,{0x9f,0x29,0x0,0xc0,0x4f,0x8e,0xe9,0xdc}};
extern const GUID OLEDBDECLSPEC DBPROPSET_SQLSERVERSTREAM        = {0x9f79c073,0x8a6d,0x4bca,{0xa8,0xa8,0xc9,0xb7,0x9a,0x9b,0x96,0x2d}};
#endif //_SQLOLEDB_H_
extern const GUID OLEDBDECLSPEC DBPROPSET_SQLSERVERPARAMETER     = {0xfee09128,0xa67d,0x47ea,{0x8d,0x40,0x24,0xa1,0xd4,0x73,0x7e,0x8d}};
extern const GUID OLEDBDECLSPEC DBPROPSET_SQLSERVERINDEX         = {0xE428B84E,0xA6B7,0x413a,{0x94,0x65,0x56,0x23,0x2E,0x0D,0x2B,0xEB}};
extern const GUID OLEDBDECLSPEC DBPROPSET_PARAMETERALL           = {0x2cd2b7d8,0xe7c2,0x4f6c,{0x9b,0x30,0x75,0xe2,0x58,0x46,0x10,0x97}};


//----------------------------------------------------------------------------
// Provider-specific columns for IColumnsRowset
//
#define DBCOLUMN_SS_X_GUID {0x627bd890,0xed54,0x11d2,{0xb9,0x94,0x0,0xc0,0x4f,0x8c,0xa8,0x2c}}
//
#ifndef  _SQLOLEDB_H_
extern const DBID OLEDBDECLSPEC DBCOLUMN_SS_COMPFLAGS        = {DBCOLUMN_SS_X_GUID, DBKIND_GUID_PROPID, (LPOLESTR)100};
extern const DBID OLEDBDECLSPEC DBCOLUMN_SS_SORTID           = {DBCOLUMN_SS_X_GUID, DBKIND_GUID_PROPID, (LPOLESTR)101};
extern const DBID OLEDBDECLSPEC DBCOLUMN_BASETABLEINSTANCE   = {DBCOLUMN_SS_X_GUID, DBKIND_GUID_PROPID, (LPOLESTR)102};
extern const DBID OLEDBDECLSPEC DBCOLUMN_SS_TDSCOLLATION     = {DBCOLUMN_SS_X_GUID, DBKIND_GUID_PROPID, (LPOLESTR)103};
#endif //_SQLOLEDB_H_
extern const DBID OLEDBDECLSPEC DBCOLUMN_BASESERVERNAME      = {DBCOLUMN_SS_X_GUID, DBKIND_GUID_PROPID, (LPOLESTR)104};
extern const DBID OLEDBDECLSPEC DBCOLUMN_SS_XML_SCHEMACOLLECTION_CATALOGNAME= {DBCOLUMN_SS_X_GUID, DBKIND_GUID_PROPID, (LPOLESTR)105};
extern const DBID OLEDBDECLSPEC DBCOLUMN_SS_XML_SCHEMACOLLECTION_SCHEMANAME = {DBCOLUMN_SS_X_GUID, DBKIND_GUID_PROPID, (LPOLESTR)106};
extern const DBID OLEDBDECLSPEC DBCOLUMN_SS_XML_SCHEMACOLLECTIONNAME        = {DBCOLUMN_SS_X_GUID, DBKIND_GUID_PROPID, (LPOLESTR)107};
extern const DBID OLEDBDECLSPEC DBCOLUMN_SS_UDT_CATALOGNAME  = {DBCOLUMN_SS_X_GUID, DBKIND_GUID_PROPID, (LPOLESTR)108};
extern const DBID OLEDBDECLSPEC DBCOLUMN_SS_UDT_SCHEMANAME   = {DBCOLUMN_SS_X_GUID, DBKIND_GUID_PROPID, (LPOLESTR)109};
extern const DBID OLEDBDECLSPEC DBCOLUMN_SS_UDT_NAME         = {DBCOLUMN_SS_X_GUID, DBKIND_GUID_PROPID, (LPOLESTR)110};
extern const DBID OLEDBDECLSPEC DBCOLUMN_SS_ASSEMBLY_TYPENAME= {DBCOLUMN_SS_X_GUID, DBKIND_GUID_PROPID, (LPOLESTR)111};

// OLEDB part of SQL Native Client header - end here!
#endif // defined(_SQLNCLI_OLEDB_) || !defined(_SQLNCLI_ODBC_)

// ODBC part of Sql Native Client header - begin here!
#if defined(_SQLNCLI_ODBC_) || !defined(_SQLNCLI_OLEDB_)
#ifdef ODBCVER

// max SQL Server identifier length
#define SQL_MAX_SQLSERVERNAME                       128

// SQLSetConnectAttr driver specific defines.
// Microsoft has 1200 thru 1249 reserved for Microsoft SQL Native Client driver usage.
// Connection attributes
#define SQL_COPT_SS_BASE                            1200
#define SQL_COPT_SS_REMOTE_PWD                      (SQL_COPT_SS_BASE+1) // dbrpwset SQLSetConnectOption only
#define SQL_COPT_SS_USE_PROC_FOR_PREP               (SQL_COPT_SS_BASE+2) // Use create proc for SQLPrepare
#define SQL_COPT_SS_INTEGRATED_SECURITY             (SQL_COPT_SS_BASE+3) // Force integrated security on login
#define SQL_COPT_SS_PRESERVE_CURSORS                (SQL_COPT_SS_BASE+4) // Preserve server cursors after SQLTransact
#define SQL_COPT_SS_USER_DATA                       (SQL_COPT_SS_BASE+5) // dbgetuserdata/dbsetuserdata
#define SQL_COPT_SS_ENLIST_IN_DTC                   SQL_ATTR_ENLIST_IN_DTC // Enlist in a DTC transaction
#define SQL_COPT_SS_ENLIST_IN_XA                    SQL_ATTR_ENLIST_IN_XA // Enlist in a XA transaction
#define SQL_COPT_SS_FALLBACK_CONNECT                (SQL_COPT_SS_BASE+10) // Enables FallBack connections
#define SQL_COPT_SS_PERF_DATA                       (SQL_COPT_SS_BASE+11) // Used to access SQL Server ODBC driver performance data
#define SQL_COPT_SS_PERF_DATA_LOG                   (SQL_COPT_SS_BASE+12) // Used to set the logfile name for the Performance data
#define SQL_COPT_SS_PERF_QUERY_INTERVAL             (SQL_COPT_SS_BASE+13) // Used to set the query logging threshold in milliseconds.
#define SQL_COPT_SS_PERF_QUERY_LOG                  (SQL_COPT_SS_BASE+14) // Used to set the logfile name for saving queryies.
#define SQL_COPT_SS_PERF_QUERY                      (SQL_COPT_SS_BASE+15) // Used to start and stop query logging.
#define SQL_COPT_SS_PERF_DATA_LOG_NOW               (SQL_COPT_SS_BASE+16) // Used to make a statistics log entry to disk.
#define SQL_COPT_SS_QUOTED_IDENT                    (SQL_COPT_SS_BASE+17) // Enable/Disable Quoted Identifiers
#define SQL_COPT_SS_ANSI_NPW                        (SQL_COPT_SS_BASE+18) // Enable/Disable ANSI NULL, Padding and Warnings
#define SQL_COPT_SS_BCP                             (SQL_COPT_SS_BASE+19) // Allow BCP usage on connection
#define SQL_COPT_SS_TRANSLATE                       (SQL_COPT_SS_BASE+20) // Perform code page translation
#define SQL_COPT_SS_ATTACHDBFILENAME                (SQL_COPT_SS_BASE+21) // File name to be attached as a database
#define SQL_COPT_SS_CONCAT_NULL                     (SQL_COPT_SS_BASE+22) // Enable/Disable CONCAT_NULL_YIELDS_NULL
#define SQL_COPT_SS_ENCRYPT                         (SQL_COPT_SS_BASE+23) // Allow strong encryption for data
#define SQL_COPT_SS_MARS_ENABLED                    (SQL_COPT_SS_BASE+24) // Multiple active result set per connection
#define SQL_COPT_SS_FAILOVER_PARTNER                (SQL_COPT_SS_BASE+25) // Failover partner server
#define SQL_COPT_SS_OLDPWD                          (SQL_COPT_SS_BASE+26) // Old Password, used when changing password during login
#define SQL_COPT_SS_TXN_ISOLATION                   (SQL_COPT_SS_BASE+27) // Used to set/get any driver-specific or ODBC-defined TXN iso level
#define SQL_COPT_SS_TRUST_SERVER_CERTIFICATE        (SQL_COPT_SS_BASE+28) // Trust server certificate
#define SQL_COPT_SS_MAX_USED                        SQL_COPT_SS_TRUST_SERVER_CERTIFICATE
// Define old names
#define SQL_REMOTE_PWD                              SQL_COPT_SS_REMOTE_PWD
#define SQL_USE_PROCEDURE_FOR_PREPARE               SQL_COPT_SS_USE_PROC_FOR_PREP
#define SQL_INTEGRATED_SECURITY                     SQL_COPT_SS_INTEGRATED_SECURITY
#define SQL_PRESERVE_CURSORS                        SQL_COPT_SS_PRESERVE_CURSORS

// SQLSetStmtAttr SQL Native Client driver specific defines.
// Statement attributes
#define SQL_SOPT_SS_BASE                            1225
#define SQL_SOPT_SS_TEXTPTR_LOGGING                 (SQL_SOPT_SS_BASE+0) // Text pointer logging
#define SQL_SOPT_SS_CURRENT_COMMAND                 (SQL_SOPT_SS_BASE+1) // dbcurcmd SQLGetStmtOption only
#define SQL_SOPT_SS_HIDDEN_COLUMNS                  (SQL_SOPT_SS_BASE+2) // Expose FOR BROWSE hidden columns
#define SQL_SOPT_SS_NOBROWSETABLE                   (SQL_SOPT_SS_BASE+3) // Set NOBROWSETABLE option
#define SQL_SOPT_SS_REGIONALIZE                     (SQL_SOPT_SS_BASE+4) // Regionalize output character conversions
#define SQL_SOPT_SS_CURSOR_OPTIONS                  (SQL_SOPT_SS_BASE+5) // Server cursor options
#define SQL_SOPT_SS_NOCOUNT_STATUS                  (SQL_SOPT_SS_BASE+6) // Real vs. Not Real row count indicator
#define SQL_SOPT_SS_DEFER_PREPARE                   (SQL_SOPT_SS_BASE+7) // Defer prepare until necessary
#define SQL_SOPT_SS_QUERYNOTIFICATION_TIMEOUT       (SQL_SOPT_SS_BASE+8) // Notification timeout
#define SQL_SOPT_SS_QUERYNOTIFICATION_MSGTEXT       (SQL_SOPT_SS_BASE+9) // Notification message text
#define SQL_SOPT_SS_QUERYNOTIFICATION_OPTIONS       (SQL_SOPT_SS_BASE+10)// SQL service broker name
#define SQL_SOPT_SS_MAX_USED                        SQL_SOPT_SS_QUERYNOTIFICATION_OPTIONS
// Define old names
#define SQL_TEXTPTR_LOGGING                         SQL_SOPT_SS_TEXTPTR_LOGGING
#define SQL_COPT_SS_BASE_EX                         1240
#define SQL_COPT_SS_BROWSE_CONNECT                  (SQL_COPT_SS_BASE_EX+1) // Browse connect mode of operation
#define SQL_COPT_SS_BROWSE_SERVER                   (SQL_COPT_SS_BASE_EX+2) // Single Server browse request.
#define SQL_COPT_SS_WARN_ON_CP_ERROR                (SQL_COPT_SS_BASE_EX+3) // Issues warning when data from the server had a loss during code page conversion.
#define SQL_COPT_SS_CONNECTION_DEAD                 (SQL_COPT_SS_BASE_EX+4) // dbdead SQLGetConnectOption only. It will try to ping the server. Expensive connection check
#define SQL_COPT_SS_BROWSE_CACHE_DATA               (SQL_COPT_SS_BASE_EX+5) // Determines if we should cache browse info. Used when returned buffer is greater then ODBC limit (32K)
#define SQL_COPT_SS_RESET_CONNECTION                (SQL_COPT_SS_BASE_EX+6) // When this option is set, we will perform connection reset on next packet
#define SQL_COPT_SS_EX_MAX_USED                     SQL_COPT_SS_RESET_CONNECTION

// SQLColAttributes driver specific defines.
// SQLSetDescField/SQLGetDescField driver specific defines.
// Microsoft has 1200 thru 1249 reserved for Microsoft SQL Native Client driver usage.
#define SQL_CA_SS_BASE                              1200
#define SQL_CA_SS_COLUMN_SSTYPE                     (SQL_CA_SS_BASE+0)   //  dbcoltype/dbalttype
#define SQL_CA_SS_COLUMN_UTYPE                      (SQL_CA_SS_BASE+1)   //  dbcolutype/dbaltutype
#define SQL_CA_SS_NUM_ORDERS                        (SQL_CA_SS_BASE+2)   //  dbnumorders
#define SQL_CA_SS_COLUMN_ORDER                      (SQL_CA_SS_BASE+3)   //  dbordercol
#define SQL_CA_SS_COLUMN_VARYLEN                    (SQL_CA_SS_BASE+4)   //  dbvarylen
#define SQL_CA_SS_NUM_COMPUTES                      (SQL_CA_SS_BASE+5)   //  dbnumcompute
#define SQL_CA_SS_COMPUTE_ID                        (SQL_CA_SS_BASE+6)   //  dbnextrow status return
#define SQL_CA_SS_COMPUTE_BYLIST                    (SQL_CA_SS_BASE+7)   //  dbbylist
#define SQL_CA_SS_COLUMN_ID                         (SQL_CA_SS_BASE+8)   //  dbaltcolid
#define SQL_CA_SS_COLUMN_OP                         (SQL_CA_SS_BASE+9)   //  dbaltop
#define SQL_CA_SS_COLUMN_SIZE                       (SQL_CA_SS_BASE+10)  //  dbcollen
#define SQL_CA_SS_COLUMN_HIDDEN                     (SQL_CA_SS_BASE+11)  //  Column is hidden (FOR BROWSE)
#define SQL_CA_SS_COLUMN_KEY                        (SQL_CA_SS_BASE+12)  //  Column is key column (FOR BROWSE)
//#define SQL_DESC_BASE_COLUMN_NAME_OLD             (SQL_CA_SS_BASE+13)  //  This is defined at another location.
#define SQL_CA_SS_COLUMN_COLLATION                  (SQL_CA_SS_BASE+14)  //  Column collation (only for chars)
#define SQL_CA_SS_VARIANT_TYPE                      (SQL_CA_SS_BASE+15)
#define SQL_CA_SS_VARIANT_SQL_TYPE                  (SQL_CA_SS_BASE+16)
#define SQL_CA_SS_VARIANT_SERVER_TYPE               (SQL_CA_SS_BASE+17)

// XML and CLR UDT type related metadata
#define SQL_CA_SS_UDT_CATALOG_NAME                  (SQL_CA_SS_BASE+18) //  UDT catalog name
#define SQL_CA_SS_UDT_SCHEMA_NAME                   (SQL_CA_SS_BASE+19) //  UDT schema name
#define SQL_CA_SS_UDT_TYPE_NAME                     (SQL_CA_SS_BASE+20) //  UDT type name
#define SQL_CA_SS_UDT_ASSEMBLY_TYPE_NAME            (SQL_CA_SS_BASE+21) //  Qualified name of the assembly containing the UDT class
#define SQL_CA_SS_XML_SCHEMACOLLECTION_CATALOG_NAME (SQL_CA_SS_BASE+22) //  Name of the catalog that contains XML Schema collection
#define SQL_CA_SS_XML_SCHEMACOLLECTION_SCHEMA_NAME  (SQL_CA_SS_BASE+23) //  Name of the schema that contains XML Schema collection
#define SQL_CA_SS_XML_SCHEMACOLLECTION_NAME         (SQL_CA_SS_BASE+24) //  Name of the XML Schema collection
#define SQL_CA_SS_MAX_USED                          (SQL_CA_SS_BASE+25)

// Defines returned by SQL_ATTR_CURSOR_TYPE/SQL_CURSOR_TYPE
#define SQL_CURSOR_FAST_FORWARD_ONLY        8            //  Only returned by SQLGetStmtAttr/Option
// Defines for use with SQL_COPT_SS_USE_PROC_FOR_PREP
#define SQL_UP_OFF                          0L           //  Procedures won't be used for prepare
#define SQL_UP_ON                           1L           //  Procedures will be used for prepare
#define SQL_UP_ON_DROP                      2L           //  Temp procedures will be explicitly dropped
#define SQL_UP_DEFAULT                      SQL_UP_ON
// Defines for use with SQL_COPT_SS_INTEGRATED_SECURITY - Pre-Connect Option only
#define SQL_IS_OFF                          0L           //  Integrated security isn't used
#define SQL_IS_ON                           1L           //  Integrated security is used
#define SQL_IS_DEFAULT                      SQL_IS_OFF
// Defines for use with SQL_COPT_SS_PRESERVE_CURSORS
#define SQL_PC_OFF                          0L           //  Cursors are closed on SQLTransact
#define SQL_PC_ON                           1L           //  Cursors remain open on SQLTransact
#define SQL_PC_DEFAULT                      SQL_PC_OFF
// Defines for use with SQL_COPT_SS_USER_DATA
#define SQL_UD_NOTSET                       NULL         //  No user data pointer set
// Defines for use with SQL_COPT_SS_TRANSLATE
#define SQL_XL_OFF                          0L           //  Code page translation is not performed
#define SQL_XL_ON                           1L           //  Code page translation is performed
#define SQL_XL_DEFAULT                      SQL_XL_ON
// Defines for use with SQL_COPT_SS_FALLBACK_CONNECT - Pre-Connect Option only
#define SQL_FB_OFF                          0L           //  FallBack connections are disabled
#define SQL_FB_ON                           1L           //  FallBack connections are enabled
#define SQL_FB_DEFAULT                      SQL_FB_OFF
// Defines for use with SQL_COPT_SS_BCP - Pre-Connect Option only
#define SQL_BCP_OFF                         0L           //  BCP is not allowed on connection
#define SQL_BCP_ON                          1L           //  BCP is allowed on connection
#define SQL_BCP_DEFAULT                     SQL_BCP_OFF
// Defines for use with SQL_COPT_SS_QUOTED_IDENT
#define SQL_QI_OFF                          0L           //  Quoted identifiers are enable
#define SQL_QI_ON                           1L           //  Quoted identifiers are disabled
#define SQL_QI_DEFAULT                      SQL_QI_ON
// Defines for use with SQL_COPT_SS_ANSI_NPW - Pre-Connect Option only
#define SQL_AD_OFF                          0L           //  ANSI NULLs, Padding and Warnings are enabled
#define SQL_AD_ON                           1L           //  ANSI NULLs, Padding and Warnings are disabled
#define SQL_AD_DEFAULT                      SQL_AD_ON
// Defines for use with SQL_COPT_SS_CONCAT_NULL - Pre-Connect Option only
#define SQL_CN_OFF                          0L           //  CONCAT_NULL_YIELDS_NULL is off
#define SQL_CN_ON                           1L           //  CONCAT_NULL_YIELDS_NULL is on
#define SQL_CN_DEFAULT                      SQL_CN_ON
// Defines for use with SQL_SOPT_SS_TEXTPTR_LOGGING
#define SQL_TL_OFF                          0L           //  No logging on text pointer ops
#define SQL_TL_ON                           1L           //  Logging occurs on text pointer ops
#define SQL_TL_DEFAULT                      SQL_TL_ON
// Defines for use with SQL_SOPT_SS_HIDDEN_COLUMNS
#define SQL_HC_OFF                          0L           //  FOR BROWSE columns are hidden
#define SQL_HC_ON                           1L           //  FOR BROWSE columns are exposed
#define SQL_HC_DEFAULT                      SQL_HC_OFF
// Defines for use with SQL_SOPT_SS_NOBROWSETABLE
#define SQL_NB_OFF                          0L           //  NO_BROWSETABLE is off
#define SQL_NB_ON                           1L           //  NO_BROWSETABLE is on
#define SQL_NB_DEFAULT                      SQL_NB_OFF
// Defines for use with SQL_SOPT_SS_REGIONALIZE
#define SQL_RE_OFF                          0L           //  No regionalization occurs on output character conversions
#define SQL_RE_ON                           1L           //  Regionalization occurs on output character conversions
#define SQL_RE_DEFAULT                      SQL_RE_OFF
// Defines for use with SQL_SOPT_SS_CURSOR_OPTIONS
#define SQL_CO_OFF                          0L           //  Clear all cursor options
#define SQL_CO_FFO                          1L           //  Fast-forward cursor will be used
#define SQL_CO_AF                           2L           //  Autofetch on cursor open
#define SQL_CO_FFO_AF                       (SQL_CO_FFO|SQL_CO_AF)  //  Fast-forward cursor with autofetch
#define SQL_CO_FIREHOSE_AF                  4L           //  Auto fetch on fire-hose cursors
#define SQL_CO_DEFAULT                      SQL_CO_OFF
//SQL_SOPT_SS_NOCOUNT_STATUS 
#define SQL_NC_OFF                          0L
#define SQL_NC_ON                           1L
//SQL_SOPT_SS_DEFER_PREPARE 
#define SQL_DP_OFF                          0L
#define SQL_DP_ON                           1L
//SQL_COPT_SS_ENCRYPT 
#define SQL_EN_OFF                          0L
#define SQL_EN_ON                           1L
//SQL_COPT_SS_TRUST_SERVER_CERTIFICATE
#define SQL_TRUST_SERVER_CERTIFICATE_NO     0L
#define SQL_TRUST_SERVER_CERTIFICATE_YES    1L
//SQL_COPT_SS_BROWSE_CONNECT 
#define SQL_MORE_INFO_NO                    0L
#define SQL_MORE_INFO_YES                   1L
//SQL_COPT_SS_BROWSE_CACHE_DATA 
#define SQL_CACHE_DATA_NO                   0L
#define SQL_CACHE_DATA_YES                  1L
//SQL_COPT_SS_RESET_CONNECTION 
#define SQL_RESET_YES                       1L
//SQL_COPT_SS_WARN_ON_CP_ERROR 
#define SQL_WARN_NO                         0L
#define SQL_WARN_YES                        1L
//SQL_COPT_SS_MARS_ENABLED 
#define SQL_MARS_ENABLED_NO                 0L
#define SQL_MARS_ENABLED_YES                1L
/* SQL_TXN_ISOLATION_OPTION bitmasks */
#define SQL_TXN_SS_SNAPSHOT                 0x00000020L

// Driver specific SQL data type defines.
// Microsoft has -150 thru -199 reserved for Microsoft SQL Native Client driver usage.
#define SQL_SS_VARIANT                      (-150)
#define SQL_SS_UDT                          (-151)
#define SQL_SS_XML                          (-152)

#ifndef SQLNCLI_NO_BCP
// Define the symbol SQLNCLI_NO_BCP if you are not using BCP in your application
// and you want to exclude the BCP-related definitions in this header file.

// SQL Server Data Type defines.
// New types for SQL 6.0 and later servers
#define SQLTEXT                             0x23
#define SQLVARBINARY                        0x25
#define SQLINTN                             0x26
#define SQLVARCHAR                          0x27
#define SQLBINARY                           0x2d
#define SQLIMAGE                            0x22
#define SQLCHARACTER                        0x2f
#define SQLINT1                             0x30
#define SQLBIT                              0x32
#define SQLINT2                             0x34
#define SQLINT4                             0x38
#define SQLMONEY                            0x3c
#define SQLDATETIME                         0x3d
#define SQLFLT8                             0x3e
#define SQLFLTN                             0x6d
#define SQLMONEYN                           0x6e
#define SQLDATETIMN                         0x6f
#define SQLFLT4                             0x3b
#define SQLMONEY4                           0x7a
#define SQLDATETIM4                         0x3a
// New types for SQL 6.0 and later servers
#define SQLDECIMAL                          0x6a
#define SQLNUMERIC                          0x6c
// New types for SQL 7.0 and later servers
#define SQLUNIQUEID                         0x24
#define SQLBIGCHAR                          0xaf
#define SQLBIGVARCHAR                       0xa7
#define SQLBIGBINARY                        0xad
#define SQLBIGVARBINARY                     0xa5
#define SQLBITN                             0x68
#define SQLNCHAR                            0xef
#define SQLNVARCHAR                         0xe7
#define SQLNTEXT                            0x63
// New types for SQL 2000 and later servers
#define SQLINT8                             0x7f
#define SQLVARIANT                          0x62
// New types for SQL 2005 and later servers
#define SQLUDT                              0xf0
#define SQLXML                              0xf1
// Define old names
#define SQLDECIMALN                         0x6a
#define SQLNUMERICN                         0x6c
#endif // SQLNCLI_NO_BCP

// SQL_SS_LENGTH_UNLIMITED is used to describe the max length of
// VARCHAR(max), VARBINARY(max), NVARCHAR(max), and XML columns
#define SQL_SS_LENGTH_UNLIMITED             0

// User Data Type definitions.
// Returned by SQLColAttributes/SQL_CA_SS_COLUMN_UTYPE.
#define SQLudtBINARY                        3
#define SQLudtBIT                           16
#define SQLudtBITN                          0
#define SQLudtCHAR                          1
#define SQLudtDATETIM4                      22
#define SQLudtDATETIME                      12
#define SQLudtDATETIMN                      15
#define SQLudtDECML                         24
#define SQLudtDECMLN                        26
#define SQLudtFLT4                          23
#define SQLudtFLT8                          8
#define SQLudtFLTN                          14
#define SQLudtIMAGE                         20
#define SQLudtINT1                          5
#define SQLudtINT2                          6
#define SQLudtINT4                          7
#define SQLudtINTN                          13
#define SQLudtMONEY                         11
#define SQLudtMONEY4                        21
#define SQLudtMONEYN                        17
#define SQLudtNUM                           10
#define SQLudtNUMN                          25
#define SQLudtSYSNAME                       18
#define SQLudtTEXT                          19
#define SQLudtTIMESTAMP                     80
#define SQLudtUNIQUEIDENTIFIER              0
#define SQLudtVARBINARY                     4
#define SQLudtVARCHAR                       2
#define MIN_USER_DATATYPE                   256
// Aggregate operator types.
// Returned by SQLColAttributes/SQL_CA_SS_COLUMN_OP.
#define SQLAOPSTDEV                         0x30    // Standard deviation
#define SQLAOPSTDEVP                        0x31    // Standard deviation population
#define SQLAOPVAR                           0x32    // Variance
#define SQLAOPVARP                          0x33    // Variance population
#define SQLAOPCNT                           0x4b    // Count
#define SQLAOPSUM                           0x4d    // Sum
#define SQLAOPAVG                           0x4f    // Average
#define SQLAOPMIN                           0x51    // Min
#define SQLAOPMAX                           0x52    // Max
#define SQLAOPANY                           0x53    // Any
#define SQLAOPNOOP                          0x56    // None
// SQLGetInfo driver specific defines.
// Microsoft has 1151 thru 1200 reserved for Microsoft SQL Native Client driver usage.
#define SQL_INFO_SS_FIRST                   1199
#define SQL_INFO_SS_NETLIB_NAMEW            (SQL_INFO_SS_FIRST+0) //  dbprocinfo
#define SQL_INFO_SS_NETLIB_NAMEA            (SQL_INFO_SS_FIRST+1) //  dbprocinfo
#define SQL_INFO_SS_MAX_USED                SQL_INFO_SS_NETLIB_NAMEA
#ifdef UNICODE
#define SQL_INFO_SS_NETLIB_NAME             SQL_INFO_SS_NETLIB_NAMEW
#else
#define SQL_INFO_SS_NETLIB_NAME             SQL_INFO_SS_NETLIB_NAMEA
#endif
// SQLGetDiagField driver specific defines.
// Microsoft has -1150 thru -1199 reserved for Microsoft SQL Native Client driver usage.
#define SQL_DIAG_SS_BASE                    (-1150)
#define SQL_DIAG_SS_MSGSTATE                (SQL_DIAG_SS_BASE)
#define SQL_DIAG_SS_SEVERITY                (SQL_DIAG_SS_BASE-1)
#define SQL_DIAG_SS_SRVNAME                 (SQL_DIAG_SS_BASE-2)
#define SQL_DIAG_SS_PROCNAME                (SQL_DIAG_SS_BASE-3)
#define SQL_DIAG_SS_LINE                    (SQL_DIAG_SS_BASE-4)
// SQLGetDiagField/SQL_DIAG_DYNAMIC_FUNCTION_CODE driver specific defines.
// Microsoft has -200 thru -299 reserved for Microsoft SQL Native Client driver usage.
#define SQL_DIAG_DFC_SS_BASE                (-200)
#define SQL_DIAG_DFC_SS_ALTER_DATABASE      (SQL_DIAG_DFC_SS_BASE-0)
#define SQL_DIAG_DFC_SS_CHECKPOINT          (SQL_DIAG_DFC_SS_BASE-1)
#define SQL_DIAG_DFC_SS_CONDITION           (SQL_DIAG_DFC_SS_BASE-2)
#define SQL_DIAG_DFC_SS_CREATE_DATABASE     (SQL_DIAG_DFC_SS_BASE-3)
#define SQL_DIAG_DFC_SS_CREATE_DEFAULT      (SQL_DIAG_DFC_SS_BASE-4)
#define SQL_DIAG_DFC_SS_CREATE_PROCEDURE    (SQL_DIAG_DFC_SS_BASE-5)
#define SQL_DIAG_DFC_SS_CREATE_RULE         (SQL_DIAG_DFC_SS_BASE-6)
#define SQL_DIAG_DFC_SS_CREATE_TRIGGER      (SQL_DIAG_DFC_SS_BASE-7)
#define SQL_DIAG_DFC_SS_CURSOR_DECLARE      (SQL_DIAG_DFC_SS_BASE-8)
#define SQL_DIAG_DFC_SS_CURSOR_OPEN         (SQL_DIAG_DFC_SS_BASE-9)
#define SQL_DIAG_DFC_SS_CURSOR_FETCH        (SQL_DIAG_DFC_SS_BASE-10)
#define SQL_DIAG_DFC_SS_CURSOR_CLOSE        (SQL_DIAG_DFC_SS_BASE-11)
#define SQL_DIAG_DFC_SS_DEALLOCATE_CURSOR   (SQL_DIAG_DFC_SS_BASE-12)
#define SQL_DIAG_DFC_SS_DBCC                (SQL_DIAG_DFC_SS_BASE-13)
#define SQL_DIAG_DFC_SS_DISK                (SQL_DIAG_DFC_SS_BASE-14)
#define SQL_DIAG_DFC_SS_DROP_DATABASE       (SQL_DIAG_DFC_SS_BASE-15)
#define SQL_DIAG_DFC_SS_DROP_DEFAULT        (SQL_DIAG_DFC_SS_BASE-16)
#define SQL_DIAG_DFC_SS_DROP_PROCEDURE      (SQL_DIAG_DFC_SS_BASE-17)
#define SQL_DIAG_DFC_SS_DROP_RULE           (SQL_DIAG_DFC_SS_BASE-18)
#define SQL_DIAG_DFC_SS_DROP_TRIGGER        (SQL_DIAG_DFC_SS_BASE-19)
#define SQL_DIAG_DFC_SS_DUMP_DATABASE       (SQL_DIAG_DFC_SS_BASE-20)
#define SQL_DIAG_DFC_SS_DUMP_TABLE          (SQL_DIAG_DFC_SS_BASE-21)
#define SQL_DIAG_DFC_SS_DUMP_TRANSACTION    (SQL_DIAG_DFC_SS_BASE-22)
#define SQL_DIAG_DFC_SS_GOTO                (SQL_DIAG_DFC_SS_BASE-23)
#define SQL_DIAG_DFC_SS_INSERT_BULK         (SQL_DIAG_DFC_SS_BASE-24)
#define SQL_DIAG_DFC_SS_KILL                (SQL_DIAG_DFC_SS_BASE-25)
#define SQL_DIAG_DFC_SS_LOAD_DATABASE       (SQL_DIAG_DFC_SS_BASE-26)
#define SQL_DIAG_DFC_SS_LOAD_HEADERONLY     (SQL_DIAG_DFC_SS_BASE-27)
#define SQL_DIAG_DFC_SS_LOAD_TABLE          (SQL_DIAG_DFC_SS_BASE-28)
#define SQL_DIAG_DFC_SS_LOAD_TRANSACTION    (SQL_DIAG_DFC_SS_BASE-29)
#define SQL_DIAG_DFC_SS_PRINT               (SQL_DIAG_DFC_SS_BASE-30)
#define SQL_DIAG_DFC_SS_RAISERROR           (SQL_DIAG_DFC_SS_BASE-31)
#define SQL_DIAG_DFC_SS_READTEXT            (SQL_DIAG_DFC_SS_BASE-32)
#define SQL_DIAG_DFC_SS_RECONFIGURE         (SQL_DIAG_DFC_SS_BASE-33)
#define SQL_DIAG_DFC_SS_RETURN              (SQL_DIAG_DFC_SS_BASE-34)
#define SQL_DIAG_DFC_SS_SELECT_INTO         (SQL_DIAG_DFC_SS_BASE-35)
#define SQL_DIAG_DFC_SS_SET                 (SQL_DIAG_DFC_SS_BASE-36)
#define SQL_DIAG_DFC_SS_SET_IDENTITY_INSERT (SQL_DIAG_DFC_SS_BASE-37)
#define SQL_DIAG_DFC_SS_SET_ROW_COUNT       (SQL_DIAG_DFC_SS_BASE-38)
#define SQL_DIAG_DFC_SS_SET_STATISTICS      (SQL_DIAG_DFC_SS_BASE-39)
#define SQL_DIAG_DFC_SS_SET_TEXTSIZE        (SQL_DIAG_DFC_SS_BASE-40)
#define SQL_DIAG_DFC_SS_SETUSER             (SQL_DIAG_DFC_SS_BASE-41)
#define SQL_DIAG_DFC_SS_SHUTDOWN            (SQL_DIAG_DFC_SS_BASE-42)
#define SQL_DIAG_DFC_SS_TRANS_BEGIN         (SQL_DIAG_DFC_SS_BASE-43)
#define SQL_DIAG_DFC_SS_TRANS_COMMIT        (SQL_DIAG_DFC_SS_BASE-44)
#define SQL_DIAG_DFC_SS_TRANS_PREPARE       (SQL_DIAG_DFC_SS_BASE-45)
#define SQL_DIAG_DFC_SS_TRANS_ROLLBACK      (SQL_DIAG_DFC_SS_BASE-46)
#define SQL_DIAG_DFC_SS_TRANS_SAVE          (SQL_DIAG_DFC_SS_BASE-47)
#define SQL_DIAG_DFC_SS_TRUNCATE_TABLE      (SQL_DIAG_DFC_SS_BASE-48)
#define SQL_DIAG_DFC_SS_UPDATE_STATISTICS   (SQL_DIAG_DFC_SS_BASE-49)
#define SQL_DIAG_DFC_SS_UPDATETEXT          (SQL_DIAG_DFC_SS_BASE-50)
#define SQL_DIAG_DFC_SS_USE                 (SQL_DIAG_DFC_SS_BASE-51)
#define SQL_DIAG_DFC_SS_WAITFOR             (SQL_DIAG_DFC_SS_BASE-52)
#define SQL_DIAG_DFC_SS_WRITETEXT           (SQL_DIAG_DFC_SS_BASE-53)
#define SQL_DIAG_DFC_SS_DENY                (SQL_DIAG_DFC_SS_BASE-54)
#define SQL_DIAG_DFC_SS_SET_XCTLVL          (SQL_DIAG_DFC_SS_BASE-55)

// Severity codes for SQL_DIAG_SS_SEVERITY
#define EX_ANY          0
#define EX_INFO         10
#define EX_MAXISEVERITY EX_INFO
#define EX_MISSING      11
#define EX_TYPE         12
#define EX_DEADLOCK     13
#define EX_PERMIT       14
#define EX_SYNTAX       15
#define EX_USER         16
#define EX_RESOURCE     17
#define EX_INTOK        18
#define MAXUSEVERITY    EX_INTOK
#define EX_LIMIT        19
#define EX_CMDFATAL     20
#define MINFATALERR     EX_CMDFATAL
#define EX_DBFATAL      21
#define EX_TABCORRUPT   22
#define EX_DBCORRUPT    23
#define EX_HARDWARE     24
#define EX_CONTROL      25
// Internal server datatypes - used when binding to SQL_C_BINARY
#ifndef MAXNUMERICLEN   // Resolve ODS/DBLib conflicts
// DB-Library datatypes
#define DBMAXCHAR       (8000+1)                    // Max length of DBVARBINARY and DBVARCHAR, etc. +1 for zero byte
#define MAXNAME         (SQL_MAX_SQLSERVERNAME+1)   // Max server identifier length including zero byte
#ifdef UNICODE
typedef wchar_t  DBCHAR;
#else
typedef char DBCHAR;

#endif
typedef unsigned char DBBINARY;

typedef unsigned char DBTINYINT;

typedef short DBSMALLINT;

typedef unsigned short DBUSMALLINT;

typedef double DBFLT8;

typedef unsigned char DBBIT;

typedef unsigned char DBBOOL;

typedef float DBFLT4;

typedef DBFLT4 DBREAL;

typedef UINT DBUBOOL;

typedef struct dbmoney
    {
    LONG mnyhigh;
    ULONG mnylow;
    } 	DBMONEY;

typedef struct dbdatetime
    {
    LONG dtdays;
    ULONG dttime;
    } 	DBDATETIME;

typedef struct dbdatetime4
    {
    USHORT numdays;
    USHORT nummins;
    } 	DBDATETIM4;

typedef LONG DBMONEY4;

// Money value *10,000
#define DBNUM_PREC_TYPE BYTE
#define DBNUM_SCALE_TYPE BYTE
#define DBNUM_VAL_TYPE BYTE

#if (ODBCVER < 0x0300)
#define MAXNUMERICLEN 16
typedef struct dbnumeric         // Internal representation of NUMERIC data type
{
    DBNUM_PREC_TYPE precision;   // Precision
    DBNUM_SCALE_TYPE scale;      // Scale
    BYTE sign;                   // Sign (1 if positive, 0 if negative)
    DBNUM_VAL_TYPE val[MAXNUMERICLEN];// Value
} DBNUMERIC;
typedef DBNUMERIC DBDECIMAL;// Internal representation of DECIMAL data type
#else //  Use ODBC 3.0 definitions since same as DBLib
#define MAXNUMERICLEN SQL_MAX_NUMERIC_LEN
typedef SQL_NUMERIC_STRUCT DBNUMERIC;
typedef SQL_NUMERIC_STRUCT DBDECIMAL;
#endif // ODCBVER
#endif // MAXNUMERICLEN

#ifndef INT
typedef int     INT;
typedef long    DBINT;
typedef DBINT * LPDBINT;
#ifndef _LPCBYTE_DEFINED
#define _LPCBYTE_DEFINED
typedef const LPBYTE    LPCBYTE;
#endif //_LPCBYTE_DEFINED
#endif // INT
/************************************************************************** 
This struct is a global used for gathering statistical data on the driver.
Access to this structure is controlled via the pStatCrit;
***************************************************************************/ 
typedef struct sqlperf
{
    // Application Profile Statistics
    DWORD TimerResolution;
    DWORD SQLidu;
    DWORD SQLiduRows;
    DWORD SQLSelects;
    DWORD SQLSelectRows;
    DWORD Transactions;
    DWORD SQLPrepares;
    DWORD ExecDirects;
    DWORD SQLExecutes;
    DWORD CursorOpens;
    DWORD CursorSize;
    DWORD CursorUsed;
    LDOUBLE PercentCursorUsed;
    LDOUBLE AvgFetchTime;
    LDOUBLE AvgCursorSize;
    LDOUBLE AvgCursorUsed;
    DWORD SQLFetchTime;
    DWORD SQLFetchCount;
    DWORD CurrentStmtCount;
    DWORD MaxOpenStmt;
    DWORD SumOpenStmt;
    // Connection Statistics
    DWORD CurrentConnectionCount;
    DWORD MaxConnectionsOpened;
    DWORD SumConnectionsOpened;
    DWORD SumConnectiontime;
    LDOUBLE AvgTimeOpened;
    // Network Statistics
    DWORD ServerRndTrips;
    DWORD BuffersSent;
    DWORD BuffersRec;
    DWORD BytesSent;
    DWORD BytesRec;
    // Time Statistics;
    DWORD msExecutionTime;
    DWORD msNetWorkServerTime;
} SQLPERF;
// The following are options for SQL_COPT_SS_PERF_DATA and SQL_COPT_SS_PERF_QUERY
#define SQL_PERF_START          1           // Starts the driver sampling performance data.
#define SQL_PERF_STOP           2           // Stops the counters from sampling performance data.
// The following are defines for SQL_COPT_SS_PERF_DATA_LOG
#define SQL_SS_DL_DEFAULT       TEXT("STATS.LOG")
// The following are defines for SQL_COPT_SS_PERF_QUERY_LOG
#define SQL_SS_QL_DEFAULT       TEXT("QUERY.LOG")
// The following are defines for SQL_COPT_SS_PERF_QUERY_INTERVAL
#define SQL_SS_QI_DEFAULT       30000   //  30,000 milliseconds

#ifndef SQLNCLI_NO_BCP
// Define the symbol SQLNCLI_NO_BCP if you are not using BCP in your application
// and you want to exclude the BCP-related definitions in this header file.

// ODBC BCP prototypes and defines
// Return codes
#define SUCCEED                 1
#define FAIL                    0
#define SUCCEED_ABORT           2
#define SUCCEED_ASYNC           3
// Transfer directions
#define DB_IN                   1   // Transfer from client to server
#define DB_OUT                  2   // Transfer from server to client
// bcp_control option
#define BCPMAXERRS              1   // Sets max errors allowed
#define BCPFIRST                2   // Sets first row to be copied out
#define BCPLAST                 3   // Sets number of rows to be copied out
#define BCPBATCH                4   // Sets input batch size
#define BCPKEEPNULLS            5   // Sets to insert NULLs for empty input values
#define BCPABORT                6   // Sets to have bcpexec return SUCCEED_ABORT
#define BCPODBC                 7   // Sets ODBC canonical character output
#define BCPKEEPIDENTITY         8   // Sets IDENTITY_INSERT on
#define BCP6xFILEFMT            9   // DEPRECATED: Sets 6x file format on
#define BCPHINTSA               10  // Sets server BCP hints (ANSI string)
#define BCPHINTSW               11  // Sets server BCP hints (UNICODE string)
#define BCPFILECP               12  // Sets clients code page for the file
#define BCPUNICODEFILE          13  // Sets that the file contains unicode header
#define BCPTEXTFILE             14  // Sets BCP mode to expect a text file and to detect Unicode or ANSI automatically
#define BCPFILEFMT              15  // Sets file format version
#define BCPFMTXML               16  // Sets the format file type to xml
// BCPFILECP values
// Any valid code page that is installed on the client can be passed plus:
#define BCPFILECP_ACP           0   // Data in file is in Windows code page
#define BCPFILECP_OEMCP         1   // Data in file is in OEM code page (default)
#define BCPFILECP_RAW           (-1)// Data in file is in Server code page (no conversion)
// bcp_collen definition
#define SQL_VARLEN_DATA (-10)   // Use default length for column
// BCP column format properties
#define BCP_FMT_TYPE            0x01
#define BCP_FMT_INDICATOR_LEN   0x02
#define BCP_FMT_DATA_LEN        0x03
#define BCP_FMT_TERMINATOR      0x04
#define BCP_FMT_SERVER_COL      0x05
#define BCP_FMT_COLLATION       0x06
#define BCP_FMT_COLLATION_ID    0x07
// BCP functions
DBINT SQL_API bcp_batch (HDBC);
RETCODE SQL_API bcp_bind (HDBC, LPCBYTE, INT, DBINT, LPCBYTE, INT, INT, INT);
RETCODE SQL_API bcp_colfmt (HDBC, INT, BYTE, INT, DBINT, LPCBYTE, INT, INT);
RETCODE SQL_API bcp_collen (HDBC, DBINT, INT);
RETCODE SQL_API bcp_colptr (HDBC, LPCBYTE, INT);
RETCODE SQL_API bcp_columns (HDBC, INT);
RETCODE SQL_API bcp_control (HDBC, INT, void *);
DBINT SQL_API bcp_done (HDBC);
RETCODE SQL_API bcp_exec (HDBC, LPDBINT);
RETCODE SQL_API bcp_getcolfmt (HDBC, INT, INT, void *, INT, INT *);
RETCODE SQL_API bcp_initA (HDBC, LPCSTR, LPCSTR, LPCSTR, INT);
RETCODE SQL_API bcp_initW (HDBC, LPCWSTR, LPCWSTR, LPCWSTR, INT);
RETCODE SQL_API bcp_moretext (HDBC, DBINT, LPCBYTE);
RETCODE SQL_API bcp_readfmtA (HDBC, LPCSTR);
RETCODE SQL_API bcp_readfmtW (HDBC, LPCWSTR);
RETCODE SQL_API bcp_sendrow (HDBC);
RETCODE SQL_API bcp_setcolfmt (HDBC, INT, INT, void *, INT);
RETCODE SQL_API bcp_writefmtA (HDBC, LPCSTR);
RETCODE SQL_API bcp_writefmtW (HDBC, LPCWSTR);
CHAR* SQL_API dbprtypeA (INT);
WCHAR* SQL_API dbprtypeW (INT);
CHAR* SQL_API bcp_gettypenameA (INT, DBBOOL);
WCHAR* SQL_API bcp_gettypenameW (INT, DBBOOL);
#ifdef UNICODE
#define bcp_init        bcp_initW
#define bcp_readfmt     bcp_readfmtW
#define bcp_writefmt    bcp_writefmtW
#define dbprtype        dbprtypeW
#define bcp_gettypename bcp_gettypenameW
#define BCPHINTS        BCPHINTSW
#else
#define bcp_init        bcp_initA
#define bcp_readfmt     bcp_readfmtA
#define bcp_writefmt    bcp_writefmtA
#define dbprtype        dbprtypeA
#define bcp_gettypename bcp_gettypenameA
#define BCPHINTS        BCPHINTSA
#endif // UNICODE

#endif // SQLNCLI_NO_BCP

// The following options have been deprecated
#define SQL_FAST_CONNECT                (SQL_COPT_SS_BASE+0)
// Defines for use with SQL_FAST_CONNECT - only useable before connecting
#define SQL_FC_OFF                      0L          //  Fast connect is off
#define SQL_FC_ON                       1L          //  Fast connect is on
#define SQL_FC_DEFAULT                  SQL_FC_OFF
#define SQL_COPT_SS_ANSI_OEM            (SQL_COPT_SS_BASE+6)
#define SQL_AO_OFF                      0L
#define SQL_AO_ON                       1L
#define SQL_AO_DEFAULT                  SQL_AO_OFF
#define SQL_CA_SS_BASE_COLUMN_NAME      SQL_DESC_BASE_COLUMN_NAME

#endif // ODBCVER
#endif // defined(_SQLNCLI_ODBC_) || !defined(_SQLNCLI_OLEDB_)
// ODBC part of SQL Native Client header - end here!



extern RPC_IF_HANDLE __MIDL_itf_sqlncli_0125_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sqlncli_0125_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* [local] */ HRESULT STDMETHODCALLTYPE ICommandWithParameters_GetParameterInfo_Proxy( 
    ICommandWithParameters * This,
    /* [out][in] */ DB_UPARAMS *pcParams,
    /* [size_is][size_is][out] */ DBPARAMINFO **prgParamInfo,
    /* [out] */ OLECHAR **ppNamesBuffer);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ICommandWithParameters_GetParameterInfo_Stub( 
    ICommandWithParameters * This,
    /* [out][in] */ DB_UPARAMS *pcParams,
    /* [size_is][size_is][out] */ DBPARAMINFO **prgParamInfo,
    /* [size_is][size_is][out] */ DBBYTEOFFSET **prgNameOffsets,
    /* [out][in] */ DBLENGTH *pcbNamesBuffer,
    /* [size_is][size_is][unique][out][in] */ OLECHAR **ppNamesBuffer,
    /* [out] */ IErrorInfo **ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE ICommandWithParameters_MapParameterNames_Proxy( 
    ICommandWithParameters * This,
    /* [in] */ DB_UPARAMS cParamNames,
    /* [size_is][in] */ const OLECHAR *rgParamNames[  ],
    /* [size_is][out] */ DB_LPARAMS rgParamOrdinals[  ]);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ICommandWithParameters_MapParameterNames_Stub( 
    ICommandWithParameters * This,
    /* [in] */ DB_UPARAMS cParamNames,
    /* [size_is][in] */ LPCOLESTR *rgParamNames,
    /* [size_is][out] */ DB_LPARAMS *rgParamOrdinals,
    /* [out] */ IErrorInfo **ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE ICommandWithParameters_SetParameterInfo_Proxy( 
    ICommandWithParameters * This,
    /* [in] */ DB_UPARAMS cParams,
    /* [size_is][unique][in] */ const DB_UPARAMS rgParamOrdinals[  ],
    /* [size_is][unique][in] */ const DBPARAMBINDINFO rgParamBindInfo[  ]);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ICommandWithParameters_SetParameterInfo_Stub( 
    ICommandWithParameters * This,
    /* [in] */ DB_UPARAMS cParams,
    /* [size_is][unique][in] */ const DB_UPARAMS *rgParamOrdinals,
    /* [size_is][unique][in] */ const DBPARAMBINDINFO *rgParamBindInfo,
    /* [out] */ IErrorInfo **ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IDBAsynchStatus_Abort_Proxy( 
    IDBAsynchStatus * This,
    /* [in] */ HCHAPTER hChapter,
    /* [in] */ DBASYNCHOP eOperation);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDBAsynchStatus_Abort_Stub( 
    IDBAsynchStatus * This,
    /* [in] */ HCHAPTER hChapter,
    /* [in] */ DBASYNCHOP eOperation,
    /* [out] */ IErrorInfo **ppErrorInfoRem);

/* [local] */ HRESULT STDMETHODCALLTYPE IDBAsynchStatus_GetStatus_Proxy( 
    IDBAsynchStatus * This,
    /* [in] */ HCHAPTER hChapter,
    /* [in] */ DBASYNCHOP eOperation,
    /* [out] */ DBCOUNTITEM *pulProgress,
    /* [out] */ DBCOUNTITEM *pulProgressMax,
    /* [out] */ DBASYNCHPHASE *peAsynchPhase,
    /* [out] */ LPOLESTR *ppwszStatusText);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDBAsynchStatus_GetStatus_Stub( 
    IDBAsynchStatus * This,
    /* [in] */ HCHAPTER hChapter,
    /* [in] */ DBASYNCHOP eOperation,
    /* [unique][out][in] */ DBCOUNTITEM *pulProgress,
    /* [unique][out][in] */ DBCOUNTITEM *pulProgressMax,
    /* [unique][out][in] */ DBASYNCHPHASE *peAsynchPhase,
    /* [unique][out][in] */ LPOLESTR *ppwszStatusText,
    /* [out] */ IErrorInfo **ppErrorInfoRem);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sql\2005\SDK\Include\msmd.h ===
//------------------------------------------------------------------------
// Microsoft MSMD OLE DB Interfaces (Analysis Services 2005)
// (C) Copyright 1988 - 2003 By Microsoft Corporation.
//
// @doc This file contains constants specific to Microsoft SQL Server
//      Analysis Services that might be useful to client applications.
//
// @module MSMD.H | Microsoft OLE DB Provider for Analysis Services Interfaces
//------------------------------------------------------------------------

#ifndef __msmd_h__
#define __msmd_h__

#ifdef INITGUID
#pragma message ("msmd.h: Defining guids from " __FILE__)
#else
//#pragma message ("msmd.h: Not defining guids from " __FILE__)
#endif

// GUIDs for DM.
DEFINE_GUID(CLSID_MSDMine,           0x2CB6C2D3L, 0xDD7C, 0x11D2, 0xAF, 0xE4, 0x00, 0x10, 0x5A, 0x99, 0x47, 0x24 );
DEFINE_GUID(DBPROPSET_DMSESSION,     0x854c773c,  0x1fe0, 0x4456, 0xbb, 0x10, 0x78, 0xaf, 0xee, 0x80, 0x86, 0x2a );

// GUIDs for OLAP.
DEFINE_GUID(CLSID_MSOLAP,            0xa07ccd0cL, 0x8148, 0x11d0, 0x87, 0xbb, 0x00, 0xc0, 0x4f, 0xc3, 0x39, 0x42 );
DEFINE_GUID(CLSID_MSOLAP_ENUMERATOR, 0xa07ccd0fL, 0x8148, 0x11d0, 0x87, 0xbb, 0x00, 0xc0, 0x4f, 0xc3, 0x39, 0x42 );
DEFINE_GUID(CLSID_MSOLAP_ERROR,      0xa07ccd0dL, 0x8148, 0x11d0, 0x87, 0xbb, 0x00, 0xc0, 0x4f, 0xc3, 0x39, 0x42 );
DEFINE_GUID(DBPROPSET_MSOLAPINIT,    0xa07ccd04L, 0x8148, 0x11d0, 0x87, 0xbb, 0x00, 0xc0, 0x4f, 0xc3, 0x39, 0x42 );
DEFINE_GUID(DBPROPSET_MDX_EXTENSIONS,0xa07ccd05L, 0x8148, 0x11d0, 0x87, 0xbb, 0x00, 0xc0, 0x4f, 0xc3, 0x39, 0x42 );
DEFINE_GUID(DBPROPSET_MSMDPERFSTAT,	 0xa07ccd0aL, 0x8148, 0x11d0, 0x87, 0xbb, 0x00, 0xc0, 0x4f, 0xc3, 0x39, 0x42 );

#define DBPROPSET_MSMDINIT DBPROPSET_MSOLAPINIT


// DataSource Initialization properties.
// These are specific to Analysis Services.
// DBPROPSET_MSOLAPINIT

#define DBPROP_MSMD_BASE					0x1000
#define DBPROP_MSMD_CREATECUBE				(DBPROP_MSMD_BASE +  1)
#define DBPROP_MSMD_INSERTINTO				(DBPROP_MSMD_BASE +  2)
#define DBPROP_MSMD_SOURCE_DSN				(DBPROP_MSMD_BASE +  3)
#define DBPROP_MSMD_USEEXISTINGFILE			(DBPROP_MSMD_BASE +  7)
#define DBPROP_MSMD_ARTIFICIALDATA			(DBPROP_MSMD_BASE +  8)
#define DBPROP_MSMD_DATA_CACHE_SIZE			(DBPROP_MSMD_BASE +  9)
#define DBPROP_MSMD_SOURCE_DSN_SUFFIX		(DBPROP_MSMD_BASE + 10)
#define DBPROP_MSMD_AUTOSYNCHPERIOD			(DBPROP_MSMD_BASE + 11)
#define DBPROP_MSMD_CACHEPOLICY				(DBPROP_MSMD_BASE + 12)
#define DBPROP_MSMD_EXECLOCATION			(DBPROP_MSMD_BASE + 13)
#define DBPROP_MSMD_WRITEBACK_TIMEOUT		(DBPROP_MSMD_BASE + 14)
#define DBPROP_MSMD_DEFAULT_ISOLATION_MODE	(DBPROP_MSMD_BASE + 15)
#define DBPROP_MSMD_COMPARECASESENSITIVESTRINGFLAGS    (DBPROP_MSMD_BASE + 16)
#define DBPROP_MSMD_COMPARECASENOTSENSITIVESTRINGFLAGS (DBPROP_MSMD_BASE + 17)
#define DBPROP_MSMD_LARGE_LEVEL_THRESHOLD	(DBPROP_MSMD_BASE + 18)
#define DBPROP_MSMD_READ_ONLY_SESSION		(DBPROP_MSMD_BASE + 19)
#define DBPROP_MSMD_SECURED_CELL_VALUE		(DBPROP_MSMD_BASE + 20)
#define DBPROP_MSMD_ROLES					(DBPROP_MSMD_BASE + 21)
#define DBPROP_MSMD_MDXCOMPATIBILITY		(DBPROP_MSMD_BASE + 22)
#define DBPROP_MSMD_SQLCOMPATIBILITY		(DBPROP_MSMD_BASE + 23)
#define DBPROP_MSMD_SSPI					(DBPROP_MSMD_BASE + 24)
#define DBPROP_MSMD_MDXUNIQUENAMES			(DBPROP_MSMD_BASE + 25)
#define DBPROP_MSMD_DISTINCTMEASURESBYKEY	(DBPROP_MSMD_BASE + 26)
#define DBPROP_MSMD_DONOTAPPLYCOMMANDS		(DBPROP_MSMD_BASE + 27)
#define DBPROP_MSMD_DEFAULT_MDX_VISUAL_MODE	(DBPROP_MSMD_BASE + 28)
#define DBPROP_MSMD_MDX_CALC_MEMBERS_MODE	(DBPROP_MSMD_BASE + 29)
#define DBPROP_MSMD_MINING_LOCATION			(DBPROP_MSMD_BASE + 30)
#define DBPROP_MSMD_OLAP_SESSION			(DBPROP_MSMD_BASE + 31)
#define DBPROP_MSMD_LOG_FILE				(DBPROP_MSMD_BASE + 32)
#define DBPROP_MSMD_MINING_EXECUTION_LOCATION	(DBPROP_MSMD_BASE + 33)
#define DBPROP_MSMD_MINING_PERSISTENCE_FORMAT	(DBPROP_MSMD_BASE + 34)
#define DBPROP_MSMD_SHOW_HIDDEN_CUBES			(DBPROP_MSMD_BASE + 35)
#define DBPROP_MSMD_DEFAULT_GUID_DIALECT		(DBPROP_MSMD_BASE + 36)
#define DBPROP_MSMD_SAFETY_OPTIONS				(DBPROP_MSMD_BASE + 37)
#define DBPROP_MSMD_CACHERATIO					(DBPROP_MSMD_BASE + 38)
#define DBPROP_MSMD_AUTHENTICATED_USER			(DBPROP_MSMD_BASE + 39)
#define DBPROP_MSMD_CACHEMODE					(DBPROP_MSMD_BASE + 40)
#define DBPROP_MSMD_NONEMPTYTHRESHOLD			(DBPROP_MSMD_BASE + 41)
#define DBPROP_MSMD_RESTRICTEDCLIENT			(DBPROP_MSMD_BASE + 42)
#define DBPROP_MSMD_CACHERATIO2					(DBPROP_MSMD_BASE + 43)
#define DBPROP_MSMD_COMMANDTIMEOUT				(DBPROP_MSMD_BASE + 44)
#define DBPROP_MSMD_USEFORMULACACHE				(DBPROP_MSMD_BASE + 45)
#define DBPROP_MSMD_DYNAMICDEBUGLIMIT			(DBPROP_MSMD_BASE + 46)
#define DBPROP_MSMD_DEBUGMODE					(DBPROP_MSMD_BASE + 47)


//
// Begin added in Analysis Services 2005
//
#define DBPROP_MSMD_DATASOURCEINFO				(DBPROP_MSMD_BASE + 60)
#define DBPROP_MSMD_SQLQUERYMODE				(DBPROP_MSMD_BASE + 61)
#define DBPROP_MSMD_CUBE			            (DBPROP_MSMD_BASE + 62)
#define DBPROP_MSMD_PROTOCOLFORMAT				(DBPROP_MSMD_BASE + 63)
#define DBPROP_MSMD_TRANSPORTCOMPRESSION		(DBPROP_MSMD_BASE + 64)
#define DBPROP_MSMD_COMPRESSIONLEVEL			(DBPROP_MSMD_BASE + 65)
#define DBPROP_MSMD_CHARACTERENCODING			(DBPROP_MSMD_BASE + 66)
#define DBPROP_MSMD_ENCRYPTION_PASSWORD			(DBPROP_MSMD_BASE + 67)
#define DBPROP_MSMD_REAL_TIME_OLAP				(DBPROP_MSMD_BASE + 68)
#define DBPROP_MSMD_CONNECT_TO					(DBPROP_MSMD_BASE + 69)
#define DBPROP_MSMD_EFFECTIVE_USERNAME			(DBPROP_MSMD_BASE + 70)
#define DBPROP_MSMD_MDX_MISSING_MEMBER_MODE		(DBPROP_MSMD_BASE + 71)
#define DBPROP_MSMD_SESSIONID					(DBPROP_MSMD_BASE + 72)
#define DBPROP_MSMD_CUSTOMDATA					(DBPROP_MSMD_BASE + 73)
#define DBPROP_MSMD_ERROR_MESSAGE_MODE			(DBPROP_MSMD_BASE + 74)

DEFINE_GUID(DBPROPSET_MDCOMMAND,     0x980883ff,  0xb1fa, 0x4fef, 0xaa, 0x92, 0x3e, 0x59, 0x60, 0xb3, 0x0f, 0x95 );

// DBPROPSET_MDCOMMAND properties
#define DBPROP_MSMD_FLATTENED_ROWSET			(DBPROP_MSMD_BASE + 1)
#define DBPROP_MSMD_FLATTENED2					(DBPROP_MSMD_BASE + 2)

//
// End added in Analysis Services 2005
//

// DataSource properties.
// These are specific to Analysis Services.
// DBPROPSET_MSMDPERFSTAT

#define DBPROP_MSMD_PERFSTAT_QUERYCOUNT		(DBPROP_MSMD_BASE + 1)
#define DBPROP_MSMD_PERFSTAT_QUERYTIME		(DBPROP_MSMD_BASE + 2)
#define DBPROP_MSMD_PERFSTAT_QUERYCELLCOUNT	(DBPROP_MSMD_BASE + 3)
#define DBPROP_MSMD_PERFSTAT_QUERYNETCOUNT	(DBPROP_MSMD_BASE + 4)
#define DBPROP_MSMD_PERFSTAT_QUERYNETTIME	(DBPROP_MSMD_BASE + 5)


// DataSource Information properties.
// These are specific to Analysis Services, but could be created by anyone.
// DBPROPSET_MDX_EXTENSIONS

#define DBPROP_MSMD_MDX_DDL_EXTENSIONS		(DBPROP_MSMD_BASE +  1)
#define DBPROP_MSMD_MDX_USE_EXTENSIONS		(DBPROP_MSMD_BASE +  2)
#define DBPROP_MSMD_MDX_CALCMEMB_EXTENSIONS	(DBPROP_MSMD_BASE +  3)

#define DBPROPVAL_MDX_DDL_CREATECUBE		0x0001
#define DBPROPVAL_MDX_DDL_INSERTINTO		0x0002
#define DBPROPVAL_MDX_DDL_REFRESHCUBE		0x0004
#define DBPROPVAL_MDX_DLL_CREATESESSIONCUBE 0x0008
#define DBPROPVAL_MDX_DLL_CREATEGLOBALCUBE	0x0010

#define DBPROPVAL_MDX_USE_LIBRARY		0x0001
#define DBPROPVAL_MDX_USE_CATALOG		0x0002

#define DBPROPVAL_MDX_CALCMEMB_ADD		0x0001
#define DBPROPVAL_MDX_CALCMEMB_STRIP	0x0002

#define DBPROPVAL_MSMD_CAP_DEFAULT				0x0000
#define DBPROPVAL_MSMD_CAP_WINDOWING			0x0001
#define DBPROPVAL_MSMD_CAP_ALLSCAN				0x0002
#define DBPROPVAL_MSMD_CAP_ISOLATED				0x0003
#define DBPROPVAL_MSMD_CAP_IGNORE_VP			0x0004
#define DBPROPVAL_MSMD_CAP_INFINITE_VP			0x0005
#define DBPROPVAL_MSMD_CAP_LARGEST_AREA_FIRST	0x0006

#define DBPROPVAL_MSMD_EXL_DEFAULT		0x0000
#define DBPROPVAL_MSMD_EXL_SMART		0x0001
#define DBPROPVAL_MSMD_EXL_CLIENT		0x0002
#define DBPROPVAL_MSMD_EXL_SERVER		0x0003

#define DBPROPVAL_MSMD_LARGE_LEVEL_THRESHOLD_MIN 10
#define DBPROPVAL_MSMD_LARGE_LEVEL_THRESHOLD_DEFAULT 1000

#define DBPROPVAL_MSMD_SECURED_CELL_VALUE_DEFAULT 0x0000
#define DBPROPVAL_MSMD_SECURED_CELL_VALUE_NA      0x0001
#define DBPROPVAL_MSMD_SECURED_CELL_VALUE_ERROR   0x0002
#define DBPROPVAL_MSMD_SECURED_CELL_VALUE_NULL    0x0003
#define DBPROPVAL_MSMD_SECURED_CELL_VALUE_ZERO    0x0004
#define DBPROPVAL_MSMD_SECURED_CELL_VALUE_STRING  0x0005

#define DBPROP_MSMD_MDXCOMPATIBILITY_DEFAULT      0x0000
#define DBPROP_MSMD_MDXCOMPATIBILITY_70           0x0001
#define DBPROP_MSMD_MDXCOMPATIBILITY_7X           0x0002

#define DBPROP_MSMD_SQLCOMPATIBILITY_DEFAULT      0x0000
#define DBPROP_MSMD_SQLCOMPATIBILITY_NORMAL       0x0001
#define DBPROP_MSMD_SQLCOMPATIBILITY_COMPACT      0x0002
#define DBPROP_MSMD_SQLCOMPATIBILITY_NOFIREHOSE   0x0003
#define DBPROP_MSMD_SQLCOMPATIBILITY_80COMPATIBLE 0x0004

#define DBPROP_MSMD_MDXUNIQUENAMES_DEFAULT        0x0000
#define DBPROP_MSMD_MDXUNIQUENAMES_KEYPATH        0x0001
#define DBPROP_MSMD_MDXUNIQUENAMES_NAMEPATH       0x0002
#define DBPROP_MSMD_MDXUNIQUENAMES_7X             0x0003

#define DBPROPVAL_VISUAL_MODE_DEFAULT			  0x0000
#define DBPROPVAL_VISUAL_MODE_VISUAL			  0x0001
#define DBPROPVAL_VISUAL_MODE_ORIGINAL			  0x0002

#define DBPROPVAL_MSMD_CALC_MEMBERS_MODE_DEFAULT  0x0000
#define DBPROPVAL_MSMD_CALC_MEMBERS_MODE_ADD      0x0001
#define DBPROPVAL_MSMD_CALC_MEMBERS_MODE_STRIP    0x0002
#define DBPROPVAL_MSMD_CALC_MEMBERS_MODE_ORIGINAL 0x0003

#define DBPROPVAL_MSMD_SAFETY_OPTIONS_DEFAULT	  0x0000
#define DBPROPVAL_MSMD_SAFETY_OPTIONS_ALLOW_ALL	  0x0001
#define DBPROPVAL_MSMD_SAFETY_OPTIONS_ALLOW_SAFE  0x0002
#define DBPROPVAL_MSMD_SAFETY_OPTIONS_ALLOW_NONE  0x0003

#define DBPROPVAL_MSMD_CACHERATIO_LOWER			  0.
#define DBPROPVAL_MSMD_CACHERATIO_UPPER			  1.
#define  DBPROPVAL_MSMD_CACHERATIO_DEFAULT		  0.5

#define DBPROPVAL_MSMD_CACHEMODE_DEFAULT			0x0000
#define	DBPROPVAL_MSMD_CACHEMODE_REGONLY			0x0001
#define	DBPROPVAL_MSMD_CACHEMODE_SCAN				0x0002

#define DBPROPVAL_MSMD_NO_ERRORS					0
#define DBPROPVAL_MSMD_SCRIPT_ERRORS				1
#define DBPROPVAL_MSMD_SECURITY_ERRORS				2

// Constants for identifier lengths.
// Note that these should also be returned by IDBInfo.
#define MSMD_DBLITERAL_CATALOG_NAME_CCHMAXLEN				24
#define MSMD_DBLITERAL_CUBE_NAME_CCHMAXLEN					24
#define MSMD_DBLITERAL_DIMENSION_NAME_CCHMAXLEN				14
#define MSMD_DBLITERAL_HIERARCHY_NAME_CCHMAXLEN				10
#define MSMD_DBLITERAL_DIMENSIONHIERARCHY_NAME_CCHMAXLEN	24
#define MSMD_DBLITERAL_LEVEL_NAME_CCHMAXLEN					255
#define MSMD_DBLITERAL_MEMBER_NAME_CCHMAXLEN				255

#define MSMD_DBLITERAL_INVALID_STARTING_CHARS L"0123456789 "
#define MSMD_DBLITERAL_INVALID_CHARS L"."


// Provider-specific HRESULT codes.
#define MSMD_E_TRANSACTION_COMMIT_TIMEOUT	((HRESULT)0x8040F008)

// Provider-specific schema rowset restrictions
#define CRESTRICTIONS_MDSCHEMA_FUNCTIONS					4
#define CRESTRICTIONS_MDSCHEMA_SETS  						5

// Provider-specific schema rowset restrictions
#define CRESTRICTIONS_MDSCHEMA_COMMANDS						5

// Provider-specific schema rowset Actions
#define CRESTRICTIONS_MDSCHEMA_ACTIONS						8

// Provider-specific schema rowset MeasureGroupDimensions
#define CRESTRICTIONS_MDSCHEMA_MEASUREGROUP_DIMENSIONS		6

#define MSMD_SCHEMA_FUNCTIONS_ORIGIN_MSOLAP					0x0001
#define MSMD_SCHEMA_FUNCTIONS_ORIGIN_UDF					0x0002

////Note: The following items may be migrated to oledb.h in a future release
#define	MD_DIMTYPE_QUANTITATIVE								0x05
#define	MD_DIMTYPE_ACCOUNTS									0x06
#define	MD_DIMTYPE_CUSTOMERS								0x07
#define	MD_DIMTYPE_PRODUCTS									0x08
#define	MD_DIMTYPE_SCENARIO									0x09
#define	MD_DIMTYPE_UTILIY									0x0A
#define	MD_DIMTYPE_CURRENCY									0x0B
#define	MD_DIMTYPE_RATES									0x0C
#define	MD_DIMTYPE_CHANNEL									0x0D
#define	MD_DIMTYPE_PROMOTION								0x0E
#define	MD_DIMTYPE_ORGANIZATION								0x0F
#define	MD_DIMTYPE_BILL_OF_MATERIALS						0x10
#define	MD_DIMTYPE_GEOGRAPHY								0x11

#define	MDLEVEL_TYPE_GEO_CONTINENT							0x2001
#define	MDLEVEL_TYPE_GEO_REGION								0x2002
#define	MDLEVEL_TYPE_GEO_COUNTRY							0x2003
#define	MDLEVEL_TYPE_GEO_STATE_OR_PROVINCE					0x2004
#define	MDLEVEL_TYPE_GEO_COUNTY								0x2005
#define	MDLEVEL_TYPE_GEO_CITY								0x2006
#define	MDLEVEL_TYPE_GEO_POSTALCODE							0x2007
#define	MDLEVEL_TYPE_GEO_POINT								0x2008
#define	MDLEVEL_TYPE_ORG_UNIT								0x1011
#define	MDLEVEL_TYPE_BOM_RESOURCE							0x1012
#define	MDLEVEL_TYPE_QUANTITATIVE							0x1013
#define	MDLEVEL_TYPE_ACCOUNT								0x1014
#define	MDLEVEL_TYPE_CUSTOMER								0x1021
#define	MDLEVEL_TYPE_CUSTOMER_GROUP							0x1022
#define	MDLEVEL_TYPE_CUSTOMER_HOUSEHOLD						0x1023
#define	MDLEVEL_TYPE_PRODUCT								0x1031
#define	MDLEVEL_TYPE_PRODUCT_GROUP							0x1032
#define	MDLEVEL_TYPE_SCENARIO								0x1015
#define	MDLEVEL_TYPE_UTILITY								0x1016
#define	MDLEVEL_TYPE_PERSON									0x1041
#define	MDLEVEL_TYPE_COMPANY								0x1042
#define	MDLEVEL_TYPE_CURRENCY_SOURCE						0x1051
#define	MDLEVEL_TYPE_CURRENCY_DESTINATION					0x1052
#define	MDLEVEL_TYPE_CHANNEL								0x1061
#define	MDLEVEL_TYPE_REPRESENTATIVE							0x1062
#define	MDLEVEL_TYPE_PROMOTION								0x1071

#define	MD_PROPTYPE_REGULAR  								0x0000
#define	MD_PROPTYPE_ID										0x0001
#define	MD_PROPTYPE_RELATION_TO_PARENT						0x0002
#define MD_PROPTYPE_ROLLUP_OPERATOR							0x0003
#define	MD_PROPTYPE_ORG_TITLE								0x0011
#define	MD_PROPTYPE_CAPTION 								0x0021
#define	MD_PROPTYPE_CAPTION_SHORT							0x0022
#define	MD_PROPTYPE_CAPTION_DESCRIPTION						0x0023
#define	MD_PROPTYPE_CAPTION_ABBREVIATION					0x0024
#define	MD_PROPTYPE_WEB_URL									0x0031
#define	MD_PROPTYPE_WEB_HTML								0x0032
#define	MD_PROPTYPE_WEB_XML_OR_XSL							0x0033
#define	MD_PROPTYPE_WEB_MAIL_ALIAS							0x0034
#define	MD_PROPTYPE_ADDRESS									0x0041
#define	MD_PROPTYPE_ADDRESS_STREET							0x0042
#define	MD_PROPTYPE_ADDRESS_HOUSE							0x0043
#define	MD_PROPTYPE_ADDRESS_CITY							0x0044
#define	MD_PROPTYPE_ADDRESS_STATE_OR_PROVINCE 				0x0045
#define	MD_PROPTYPE_ADDRESS_ZIP								0x0046
#define	MD_PROPTYPE_ADDRESS_QUARTER							0x0047
#define	MD_PROPTYPE_ADDRESS_COUNTRY							0x0048
#define	MD_PROPTYPE_ADDRESS_BUILDING						0x0049
#define	MD_PROPTYPE_ADDRESS_ROOM							0x004A
#define	MD_PROPTYPE_ADDRESS_FLOOR							0x004B
#define	MD_PROPTYPE_ADDRESS_FAX								0x004C
#define	MD_PROPTYPE_ADDRESS_PHONE							0x004D
#define	MD_PROPTYPE_GEO_CENTROID_X							0x0061
#define	MD_PROPTYPE_GEO_CENTROID_Y							0x0062
#define	MD_PROPTYPE_GEO_CENTROID_Z							0x0063
#define	MD_PROPTYPE_GEO_BOUNDARY_TOP						0x0064
#define	MD_PROPTYPE_GEO_BOUNDARY_LEFT						0x0065
#define	MD_PROPTYPE_GEO_BOUNDARY_BOTTOM						0x0066
#define	MD_PROPTYPE_GEO_BOUNDARY_RIGHT						0x0067
#define	MD_PROPTYPE_GEO_BOUNDARY_FRONT						0x0068
#define	MD_PROPTYPE_GEO_BOUNDARY_REAR						0x0069
#define	MD_PROPTYPE_GEO_BOUNDARY_POLYGON					0x006A
#define	MD_PROPTYPE_PHYSICAL_SIZE							0x0071
#define	MD_PROPTYPE_PHYSICAL_COLOR							0x0072
#define	MD_PROPTYPE_PHYSICAL_WEIGHT							0x0073
#define	MD_PROPTYPE_PHYSICAL_HEIGHT							0x0074
#define	MD_PROPTYPE_PHYSICAL_WIDTH							0x0075
#define	MD_PROPTYPE_PHYSICAL_DEPTH							0x0076
#define	MD_PROPTYPE_PHYSICAL_VOLUME							0x0077
#define	MD_PROPTYPE_PHYSICAL_DENSITY						0x0078
#define	MD_PROPTYPE_PERSON_FULL_NAME						0x0082
#define	MD_PROPTYPE_PERSON_FIRST_NAME						0x0083
#define	MD_PROPTYPE_PERSON_LAST_NAME						0x0084
#define	MD_PROPTYPE_PERSON_MIDDLE_NAME						0x0085
#define	MD_PROPTYPE_PERSON_DEMOGRAPHIC						0x0086
#define	MD_PROPTYPE_PERSON_CONTACT							0x0087
#define	MD_PROPTYPE_QTY_RANGE_LOW							0x0091
#define	MD_PROPTYPE_QTY_RANGE_HIGH							0x0092
#define	MD_PROPTYPE_FORMATTING_COLOR						0x00A1
#define	MD_PROPTYPE_FORMATTING_ORDER						0x00A2
#define	MD_PROPTYPE_FORMATTING_FONT							0x00A3
#define	MD_PROPTYPE_FORMATTING_FONT_EFFECTS					0x00A4
#define	MD_PROPTYPE_FORMATTING_FONT_SIZE					0x00A5
#define	MD_PROPTYPE_FORMATTING_SUB_TOTAL					0x00A1
#define	MD_PROPTYPE_DATE									0x00B1
#define	MD_PROPTYPE_DATE_START								0x00B2
#define	MD_PROPTYPE_DATE_ENDED								0x00B3
#define	MD_PROPTYPE_DATE_CANCELED							0x00B4
#define	MD_PROPTYPE_DATE_MODIFIED							0x00B5
#define	MD_PROPTYPE_DATE_DURATION							0x00B6
#define	MD_PROPTYPE_VERSION									0x00C1

//Note: The following items may be migrated to oledb.h in a future release
#define MD_SECURITY_ENABLE_DRILLTHROUGH						0x0001
#define MD_SECURITY_ENABLE_WRITEBACK						0x0002

//Note: The following items may be migrated to oledb.h in a future release
#define	MDACTION_COORDINATE_CUBE							0x00000001
#define	MDACTION_COORDINATE_DIMENSION						0x00000002
#define	MDACTION_COORDINATE_LEVEL							0x00000003
#define	MDACTION_COORDINATE_MEMBER							0x00000004
#define	MDACTION_COORDINATE_SET								0x00000005
#define	MDACTION_COORDINATE_CELL							0x00000006

#define	MDACTION_TYPE_ALL									0x00000000
#define	MDACTION_TYPE_URL									0x00000001
#define	MDACTION_TYPE_HTML									0x00000002
#define	MDACTION_TYPE_STATEMENT								0x00000004
#define	MDACTION_TYPE_DATASET								0x00000008
#define	MDACTION_TYPE_ROWSET								0x00000010
#define	MDACTION_TYPE_COMMANDLINE							0x00000020
#define	MDACTION_TYPE_PROPRIETARY							0x00000040
#define	MDACTION_TYPE_REPORT								0x00000080
#define	MDACTION_TYPE_DRILLTHROUGH							0x00000100

#define MDDATA_TYPE_ALL										0x00000000
#define MDDATA_TYPE_VARIANT									0x00000001
#define MDDATA_TYPE_WSTRING									0x00000002

#define	MDACTION_INVOCATION_ALL								0x00000000
#define	MDACTION_INVOCATION_INTERACTIVE						0x00000001
#define	MDACTION_INVOCATION_ON_OPEN							0x00000002
#define	MDACTION_INVOCATION_BATCH							0x00000004

#define MDLEVELS_CUSTOM_ROLLUP_EXPRESSION					0x00000001
#define MDLEVELS_CUSTOM_ROLLUP_COLUMN						0x00000002 
#define	MDLEVELS_SKIPPED_LEVELS								0x00000004
#define	MDLEVELS_CUSTOM_MEMBER_PROPERTIES					0x00000008
#define	MDLEVELS_UNARY_OPERATOR								0x00000010

#define MDLEVELS_MEMBER_KEY_UNIQUE							0x00000001
#define MDLEVELS_MEMBER_NAME_UNIQUE							0x00000002

#define MDPROP_SYSTEM						                0x00000004
#define MDPROP_BLOB							                0x00000008

#define MDDIMENSIONS_MEMBER_KEY_UNIQUE						0x00000001
#define MDDIMENSIONS_MEMBER_NAME_UNIQUE						0x00000002

#define MDLEVELS_HIDEMEMBERIF_NO_HOLES						0x00000000	// no holes on this level
#define MDLEVELS_HIDEMEMBERIF_ONLY_CHILD_AND_BLANK_NAME	    0x00000001	// hole is determined if the vertex has an empty name and singleton
#define MDLEVELS_HIDEMEMBERIF_ONLY_CHILD_AND_PARENT_NAME	0x00000002	// hole is determined if the vertex has a name same as the parent and singleton
#define MDLEVELS_HIDEMEMBERIF_BLANK_NAME					0x00000003	// hole is determined if the vertex has an empty name
#define MDLEVELS_HIDEMEMBERIF_PARENT_NAME					0x00000004,	// hole is determined if the vertex has a name same as the parent

//Note: The following items may be migrated to oledb.h in a future release
//			  should be 10 and we should use that one instead of this one
//			  everywhere in the code
#define CRESTRICTIONS_MDSCHEMA_PROPERTIES_7x                10

// Measure type distinct count
//Note: The following items may be migrated to oledb.h in a future release
#define MDMEASURE_AGGR_DST									0x08

// Measures types for semiadditive measures.
//Note: The following items may be migrated to oledb.h in a future release
#define MDMEASURE_AGGR_NONE                                 0x09
#define MDMEASURE_AGGR_AVGCHILDREN                          0x0A
#define MDMEASURE_AGGR_FIRSTCHILD                           0x0B
#define MDMEASURE_AGGR_LASTCHILD                            0x0C
#define MDMEASURE_AGGR_FIRSTNONEMPTY                        0x0D
#define MDMEASURE_AGGR_LASTNONEMPTY                         0x0E
#define MDMEASURE_AGGR_BYACCOUNT                            0x0F

//Note: The following items may be migrated to oledb.h in a future release
enum DBPROPENUM27
{
	DBPROP_PROVIDEROLEDBOLAPVER			=	0x101L,
	DBPROP_DATASOURCE_CONNECTION_TYPE	=	0x102L
};

#define DBPROPVAL_MDX_DCT_SERVER 0x0001
#define DBPROPVAL_MDX_DCT_LOCAL	 0x0002
#define DBPROPVAL_MDX_DCT_HTTP 	 0x0004

#define MD_STRUCTURE_FULLYBALANCED		0x0000
#define MD_STRUCTURE_RAGGEDBALANCED		0x0001
#define MD_STRUCTURE_UNBALANCED			0x0002
#define MD_STRUCTURE_NETWORK			0x0003

#define MDSET_SCOPE_GLOBAL				0x00001
#define MDSET_SCOPE_SESSION				0x00002

#define DBPROP_VISUALMODE				(DBPROP_SESS_AUTOCOMMITISOLEVELS  + 1)

//property values for UPDATE cell property
#define MD_MASK_ENABLED										0x00000000
#define MD_MASK_NOT_ENABLED									0x10000000

#define DBPROP_CELL_UPDATE_ENABLED							MD_MASK_ENABLED		| 0x00000001 // can update
#define DBPROP_CELL_UPDATE_ENABLED_WITH_UPDATE				MD_MASK_ENABLED		| 0x00000002 // can update using UPDATE function
#define DBPROP_CELL_UPDATE_NOT_ENABLED_FORMULA				MD_MASK_NOT_ENABLED | 0x00000001 // cannot update formula
#define DBPROP_CELL_UPDATE_NOT_ENABLED_NONSUM_MEASURE		MD_MASK_NOT_ENABLED | 0x00000002 // cannot update non-sum type measure
#define DBPROP_CELL_UPDATE_NOT_ENABLED_NACELL_VIRTUALCUBE	MD_MASK_NOT_ENABLED | 0x00000003 // cannot update N/A cell in virtual cube
#define DBPROP_CELL_UPDATE_NOT_ENABLED_UPDATETONULL			MD_MASK_NOT_ENABLED | 0x00000004 // cannot store a NULL in a non NULL cell
#define DBPROP_CELL_UPDATE_NOT_ENABLED_SECURE				MD_MASK_NOT_ENABLED | 0x00000005 // cannot update because cell is secured
#define DBPROP_CELL_UPDATE_NOT_ENABLED_CALCLEVEL			MD_MASK_NOT_ENABLED | 0x00000006 // cannot update for calculated level
#define DBPROP_CELL_UPDATE_NOT_ENABLED_CANNOTUPDATE			MD_MASK_NOT_ENABLED | 0x00000007 // cannot update for internal reason
#define DBPROP_CELL_UPDATE_NOT_ENABLED_INVALIDDIMENSIONTYPE	MD_MASK_NOT_ENABLED | 0x00000009 // cannot update if special dimensions (ref, MM, DM) non trivial coordinates

extern const OLEDBDECLSPEC GUID MDGUID_DM  = {0x62c58fed,0xcca5,0x44f1,{0x83, 0xb6, 0x7b, 0x45, 0x68, 0x2b, 0x39, 0x04}};

//
// Begin added in Analysis Services 2005
//

// Enum values for <object>_ORIGIN
#define MD_ORIGIN_USER_DEFINED							0x00000001
#define MD_ORIGIN_ATTRIBUTE								0x00000002
#define MD_ORIGIN_KEY_ATTRIBUTE							0x00000004
#define MD_ORIGIN_INTERNAL								0x00000008

// Enum values for INSTANCE_SELECTION
#define MD_INSTANCE_SELECTION_NONE						0x00000000
#define MD_INSTANCE_SELECTION_DROPDOWN					0x00000001
#define MD_INSTANCE_SELECTION_LIST						0x00000002
#define MD_INSTANCE_SELECTION_FILTEREDLIST				0x00000003
#define MD_INSTANCE_SELECTION_MANDATORYFILTER			0x00000004					

// Enum values for GROUPING_BEHAVIOR
#define	MD_GROUPING_BEHAVIOR_ENCOURAGE					0x00000001
#define	MD_GROUPING_BEHAVIOR_DISCOURAGE					0x00000002

// Enum values for CUBE_SOURCE property
#define	MD_CUBE_SOURCE_CUBE				0x0001
#define	MD_CUBE_SOURCE_DIMENSION		0x0002

//
// End added in Analysis Services 2005
//

//////////////////////////////////////////////////////////////////////////
// Begin: Interface  and related structure definitions for IMDDatasetInfo
//////////////////////////////////////////////////////////////////////////

typedef struct tagMDAXISINFOEX
    {
    DBLENGTH cbSize;
    DBCOUNTITEM iAxis;
    DBCOUNTITEM cHierarchies;
    LPOLESTR *rgpwszHierarchyNames;
    } 	MDAXISINFOEX;

typedef struct tagMDCUBEINFO
    {
    DBLENGTH cbSize;
    DBCOUNTITEM iCube;
    LPOLESTR wszCubeName;
    DATE LastDataUpdate;
    DATE LastSchemaUpdate;
    } 	MDCUBEINFO;



extern RPC_IF_HANDLE __MIDL_itf_pxoprovider_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_pxoprovider_0000_v0_0_s_ifspec;

#ifndef __IMDDatasetInfo_INTERFACE_DEFINED__
#define __IMDDatasetInfo_INTERFACE_DEFINED__

/* interface IMDDatasetInfo */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IMDDatasetInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a07ccd16-8148-11d0-87bb-00c04fc33942")
    IMDDatasetInfo : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE FreeAxisInfo( 
            DBCOUNTITEM cAxes,
            MDAXISINFOEX *rgAxisInfo) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetAxisInfo( 
            DBCOUNTITEM *pcAxes,
            MDAXISINFOEX **prgAxisInfo) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE FreeCubeInfo( 
            DBCOUNTITEM cCubes,
            MDCUBEINFO *rgCubeInfo) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCubeInfo( 
            DBCOUNTITEM *pcCubes,
            MDCUBEINFO **prgCubeInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMDDatasetInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMDDatasetInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMDDatasetInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMDDatasetInfo * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *FreeAxisInfo )( 
            IMDDatasetInfo * This,
            DBCOUNTITEM cAxes,
            MDAXISINFOEX *rgAxisInfo);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetAxisInfo )( 
            IMDDatasetInfo * This,
            DBCOUNTITEM *pcAxes,
            MDAXISINFOEX **prgAxisInfo);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *FreeCubeInfo )( 
            IMDDatasetInfo * This,
            DBCOUNTITEM cCubes,
            MDCUBEINFO *rgCubeInfo);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetCubeInfo )( 
            IMDDatasetInfo * This,
            DBCOUNTITEM *pcCubes,
            MDCUBEINFO **prgCubeInfo);
        
        END_INTERFACE
    } IMDDatasetInfoVtbl;

    interface IMDDatasetInfo
    {
        CONST_VTBL struct IMDDatasetInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMDDatasetInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMDDatasetInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMDDatasetInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMDDatasetInfo_FreeAxisInfo(This,cAxes,rgAxisInfo)	\
    ( (This)->lpVtbl -> FreeAxisInfo(This,cAxes,rgAxisInfo) ) 

#define IMDDatasetInfo_GetAxisInfo(This,pcAxes,prgAxisInfo)	\
    ( (This)->lpVtbl -> GetAxisInfo(This,pcAxes,prgAxisInfo) ) 

#define IMDDatasetInfo_FreeCubeInfo(This,cCubes,rgCubeInfo)	\
    ( (This)->lpVtbl -> FreeCubeInfo(This,cCubes,rgCubeInfo) ) 

#define IMDDatasetInfo_GetCubeInfo(This,pcCubes,prgCubeInfo)	\
    ( (This)->lpVtbl -> GetCubeInfo(This,pcCubes,prgCubeInfo) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMDDatasetInfo_FreeAxisInfo_Proxy( 
    IMDDatasetInfo * This,
    DBCOUNTITEM cAxes,
    MDAXISINFOEX *rgAxisInfo);


void __RPC_STUB IMDDatasetInfo_FreeAxisInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMDDatasetInfo_GetAxisInfo_Proxy( 
    IMDDatasetInfo * This,
    DBCOUNTITEM *pcAxes,
    MDAXISINFOEX **prgAxisInfo);


void __RPC_STUB IMDDatasetInfo_GetAxisInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMDDatasetInfo_FreeCubeInfo_Proxy( 
    IMDDatasetInfo * This,
    DBCOUNTITEM cCubes,
    MDCUBEINFO *rgCubeInfo);


void __RPC_STUB IMDDatasetInfo_FreeCubeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMDDatasetInfo_GetCubeInfo_Proxy( 
    IMDDatasetInfo * This,
    DBCOUNTITEM *pcCubes,
    MDCUBEINFO **prgCubeInfo);


void __RPC_STUB IMDDatasetInfo_GetCubeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);

#endif 	/* __IMDDatasetInfo_INTERFACE_DEFINED__ */

DEFINE_GUID(IID_IMDDatasetInfo,      0xa07ccd16,  0x8148, 0x11d0, 0x87, 0xbb, 0x00, 0xc0, 0x4f, 0xc3, 0x39, 0x42 );

//////////////////////////////////////////////////////////////////////////
// END: Interface  and related structure definitions for IMDDatasetInfo
//////////////////////////////////////////////////////////////////////////

#endif	// __msmd_h__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sql\2005\SDK\Include\oledbdm.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0366 */
/* at Mon Jul 18 10:16:45 2005
 */
/* Compiler settings for oledbdm.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __oledbdm_h__
#define __oledbdm_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_oledbdm_0000 */
/* [local] */ 

#define DBSOURCETYPE_DATASOURCE_DM (4)
#define OLEDB_DM_PROVIDER_STRING "OLE DB DM Provider"
#ifdef DBINITCONSTANTS
extern const OLEDBDECLSPEC GUID DMSCHEMA_MINING_SERVICES =
	{0x3add8a95,0xd8b9,0x11d2,{0x8d,0x2a,0x00,0xe0,0x29,0x15,0x4f,0xde}};
extern const OLEDBDECLSPEC GUID DMSCHEMA_MINING_SERVICE_PARAMETERS =
	{0x3add8a75,0xd8b9,0x11d2,{0x8d,0x2a,0x00,0xe0,0x29,0x15,0x4f,0xde}};
extern const OLEDBDECLSPEC GUID DMSCHEMA_MINING_MODEL_CONTENT =
	{0x3add8a76,0xd8b9,0x11d2,{0x8d,0x2a,0x00,0xe0,0x29,0x15,0x4f,0xde}};
extern const OLEDBDECLSPEC GUID DMSCHEMA_MINING_MODEL_XML =
	{0x4290b2d5,0xe9c,0x4aa7,{0x93,0x69,0x98,0xc9,0x5c,0xfd,0x9d,0x13}};
extern const OLEDBDECLSPEC GUID DMSCHEMA_MINING_MODELS =
	{0x3add8a77,0xd8b9,0x11d2,{0x8d,0x2a,0x00,0xe0,0x29,0x15,0x4f,0xde}};
extern const OLEDBDECLSPEC GUID DMSCHEMA_MINING_COLUMNS =
	{0x3add8a78,0xd8b9,0x11d2,{0x8d,0x2a,0x00,0xe0,0x29,0x15,0x4f,0xde}};
extern const OLEDBDECLSPEC GUID DMSCHEMA_MINING_FUNCTIONS =
	{0x3add8a79,0xd8b9,0x11d2,{0x8d,0x2a,0x00,0xe0,0x29,0x15,0x4f,0xde}};
extern const OLEDBDECLSPEC GUID DMSCHEMA_MINING_STRUCTURES =
	{0x883269f3,0x0cad,0x462f,{0xb6,0xf5,0xe8,0x8a,0x72,0x41,0x8c,0x4b}};
extern const OLEDBDECLSPEC GUID DMSCHEMA_MINING_STRUCTURE_COLUMNS =
	{0x9952e836,0xbfbf,0x4d1f,{0x85,0x35,0x9b,0x67,0xdb,0xd9,0xdd,0xfe}};
#else //!DBINITCONSTANTS
extern const GUID DMSCHEMA_MINING_SERVICES;
extern const GUID DMSCHEMA_MINING_SERVICE_PARAMETERS;
extern const GUID DMSCHEMA_MINING_MODEL_CONTENT;
extern const GUID DMSCHEMA_MINING_MODEL_XML;
extern const GUID DMSCHEMA_MINING_MODELS;
extern const GUID DMSCHEMA_MINING_COLUMNS;
extern const GUID DMSCHEMA_MINING_FUNCTIONS;
extern const GUID DMSCHEMA_MINING_STRUCTURES;
extern const GUID DMSCHEMA_MINING_STRUCTURE_COLUMNS;
#endif //DBINITCONSTANTS
// Fixing spec compliance issue in previous versions
#define  DMSCHEMA_MINING_MODEL_CONTENT_PMML DMSCHEMA_MINING_MODEL_XML
// Node types in MINING_MODEL_CONTENT schema rowset
const LONG DM_NODE_TYPE_MODEL					= 1;
const LONG DM_NODE_TYPE_CLASSIFICATION_TREE_ROOT	= 2;
const LONG DM_NODE_TYPE_TREE_INTERIOR			= 3;
const LONG DM_NODE_TYPE_TREE_DISTRIBUTION		= 4;
const LONG DM_NODE_TYPE_CLUSTER					= 5;
const LONG DM_NODE_TYPE_UNKNOWN					= 6;
const LONG DM_NODE_TYPE_ITEMSET					= 7;
const LONG DM_NODE_TYPE_ASSOCIATION_RULE			= 8;
const LONG DM_NODE_TYPE_NB_PREDICTABLE_ATTRIBUTE	= 9;
const LONG DM_NODE_TYPE_NB_INPUT_ATTRIBUTE		= 10;
const LONG DM_NODE_TYPE_NB_INPUT_ATTRIBUTE_STATE	= 11;
const LONG DM_NODE_TYPE_SEQUENCE					= 13;
const LONG DM_NODE_TYPE_TRANSITION				= 14;
const LONG DM_NODE_TYPE_TIME_SERIES				= 15;
const LONG DM_NODE_TYPE_TS_TREE					= 16;
const LONG DM_NODE_TYPE_NN_SUBNETWORK			= 17;
const LONG DM_NODE_TYPE_NN_INPUT_LAYER			= 18;
const LONG DM_NODE_TYPE_NN_HIDDEN_LAYER			= 19;
const LONG DM_NODE_TYPE_NN_OUTPUT_LAYER			= 20;
const LONG DM_NODE_TYPE_NN_INPUT_NODE			= 21;
const LONG DM_NODE_TYPE_NN_HIDDEN_NODE			= 22;
const LONG DM_NODE_TYPE_NN_OUTPUT_NODE			= 23;
const LONG DM_NODE_TYPE_NN_MARGINAL_STAT_NODE	= 24;
const LONG DM_NODE_TYPE_REGRESSION_TREE_ROOT		= 25;
const LONG DM_NODE_TYPE_NB_MARGINAL_STAT_NODE	= 26;
const LONG DM_NODE_TYPE_CUSTOM_BASE				= 1000;
//
// Tree Operators for MINING_MODEL_CONTENT schema rowset
#define     DMTREEOP_CHILDREN           0x01
#define     DMTREEOP_SIBLINGS           0x02
#define     DMTREEOP_PARENT             0x04
#define     DMTREEOP_SELF               0x08
#define     DMTREEOP_DESCENDANTS        0x10
#define     DMTREEOP_ANCESTORS          0x20

enum DM_MiningServiceTypeID
    {	DM_SERVICETYPE_CLASSIFICATION	= 0x1,
	DM_SERVICETYPE_CLUSTERING	= 0x2,
	DM_SERVICETYPE_ASSOCIATION	= 0x4,
	DM_SERVICETYPE_DENSITY_ESTIMATE	= 0x8,
	DM_SERVICETYPE_SEQUENCE	= 0x10
    } ;

enum DM_MiningServiceTrainingComplexity
    {	DM_TRAINING_COMPLEXITY_LOW	= 0,
	DM_TRAINING_COMPLEXITY_MEDIUM	= 1,
	DM_TRAINING_COMPLEXITY_HIGH	= 2
    } ;

enum DM_MiningServicePredictionComplexity
    {	DM_PREDICTION_COMPLEXITY_LOW	= 0,
	DM_PREDICTION_COMPLEXITY_MEDIUM	= 1,
	DM_PREDICTION_COMPLEXITY_HIGH	= 2
    } ;

enum DM_MiningServiceExpectedQuality
    {	DM_EXPECTED_QUALITY_LOW	= 0,
	DM_EXPECTED_QUALITY_MEDIUM	= 1,
	DM_EXPECTED_QUALITY_HIGH	= 2
    } ;

enum DM_MiningServiceScaling
    {	DM_SCALING_LOW	= 0,
	DM_SCALING_MEDIUM	= 1,
	DM_SCALING_HIGH	= 2
    } ;

enum DM_MiningServiceControl
    {	DM_CONTROL_NONE	= 0,
	DM_CONTROL_CANCEL	= 1,
	DM_CONTROL_SUSPENDRESUME	= 2,
	DM_CONTROL_SUSPENDWITHRESULT	= 3
    } ;

enum DM_MiningServiceParameterFlags
    {	DM_PARAMETER_TRAINING	= 0x1,
	DM_PARAMETER_PREDICTION	= 0x2
    } ;
#define	DMMVALUETYPE_AUTODETECT	( 0 )

#define	DMMVALUETYPE_MISSING	( 1 )

#define	DMMVALUETYPE_EXISTING	( 2 )

#define	DMMVALUETYPE_CONTINUOUS	( 3 )

#define	DMMVALUETYPE_DISCRETE	( 4 )

#define	DMMVALUETYPE_DISCRETIZED	( 5 )

#define	DMMVALUETYPE_BOOLEAN	( 6 )

#define	DMMVALUETYPE_COEFFICIENT	( 7 )

#define	DMMVALUETYPE_SCOREGAIN	( 8 )

#define	DMMVALUETYPE_STATISTICS	( 9 )

#define	DMMVALUETYPE_NODE_UNIQUE_NAME	( 10 )

#define	DMMVALUETYPE_INTERCEPT	( 11 )



extern RPC_IF_HANDLE __MIDL_itf_oledbdm_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_oledbdm_0000_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sql\2005\SDK\Include\srv.h ===
//------------------------------------------------------------
// Open Data Services header file: srv.h
// Copyright (c) Microsoft Corporation. All rights reserved.
//

// Avoid double inclusion
#ifndef _ODS_SRV_H_
#define _ODS_SRV_H_

#ifndef COMPILE_FOR_CLR
#include "windows.h"
#endif

// ODS uses pack(4) on all CPU types
#pragma pack(4)

#ifdef __cplusplus
extern "C" {
#endif

// define model
#if !defined( FAR )
#define FAR far
#endif

//------------------------------------------------------------
// Formats of data types
#if !defined(DBTYPEDEFS) // Do not conflict with DBLIB definitions
#if !defined(MAXNUMERICLEN) // Do not conflict with ODBC definitions

#define DBTYPEDEFS

typedef unsigned char DBBOOL;
typedef unsigned char DBBYTE;
typedef unsigned char DBTINYINT;
typedef short DBSMALLINT;
typedef unsigned short DBUSMALLINT;
typedef long DBINT;
typedef char DBCHAR;
typedef unsigned char DBBINARY;
typedef unsigned char DBBIT;
typedef double DBFLT8;

typedef struct srv_datetime 
{	// Format for SRVDATETIME
    long dtdays;            // number of days since 1/1/1900
    unsigned long dttime;   // number 300th second since mid
} DBDATETIME;				

typedef struct srv_money 
{		// Format for SRVMONEY
    long mnyhigh;
    unsigned long mnylow;
} DBMONEY;

typedef float DBFLT4;
typedef long DBMONEY4;

typedef struct dbdatetime4 
{	// Format for SRVDATETIM4
    unsigned short numdays; // number of days since 1/1/1900
    unsigned short nummins; // number of minutes sicne midnight
} DBDATETIM4;

#define MAXNUMERICLEN	16
typedef struct dbnumeric	
{	// Format for SRVNUMERIC,SRVNUMERICN,SRVDECIMAL,SRVDECIMALN
	BYTE precision;
	BYTE scale;
	BYTE sign;
	BYTE val[MAXNUMERICLEN];
} DBNUMERIC;
typedef DBNUMERIC DBDECIMAL;

#endif  // #if !defined(MAXNUMERICLEN)
#endif  // #if !defined( DBTYPEDEFS )

//------------------------------------------------------------
// Constants used by APIs

// Type Tokens
#define SRV_TDS_NULL           (BYTE) 0x1f
#define SRV_TDS_TEXT           (BYTE) 0x23
#define SRV_TDS_GUID           (BYTE) 0x24
#define SRV_TDS_VARBINARY      (BYTE) 0x25
#define SRV_TDS_INTN           (BYTE) 0x26
#define SRV_TDS_VARCHAR        (BYTE) 0x27
#define SRV_TDS_BINARY         (BYTE) 0x2d
#define SRV_TDS_IMAGE          (BYTE) 0x22
#define SRV_TDS_CHAR           (BYTE) 0x2f
#define SRV_TDS_INT1           (BYTE) 0x30
#define SRV_TDS_BIT            (BYTE) 0x32
#define SRV_TDS_INT2           (BYTE) 0x34
#define SRV_TDS_DECIMAL        (BYTE) 0x37
#define SRV_TDS_INT4           (BYTE) 0x38
#define SRV_TDS_DATETIM4       (BYTE) 0x3a
#define SRV_TDS_FLT4           (BYTE) 0x3b
#define SRV_TDS_MONEY          (BYTE) 0x3c
#define SRV_TDS_DATETIME       (BYTE) 0x3d
#define SRV_TDS_FLT8           (BYTE) 0x3e
#define SRV_TDS_NUMERIC        (BYTE) 0x3f
#define SRV_TDS_SSVARIANT      (BYTE) 0x62
#define SRV_TDS_NTEXT		   (BYTE) 0x63
#define SRV_TDS_BITN		   (BYTE) 0x68
#define SRV_TDS_DECIMALN       (BYTE) 0x6a
#define SRV_TDS_NUMERICN       (BYTE) 0x6c
#define SRV_TDS_FLTN           (BYTE) 0x6d
#define SRV_TDS_MONEYN         (BYTE) 0x6e
#define SRV_TDS_DATETIMN       (BYTE) 0x6f
#define SRV_TDS_MONEY4         (BYTE) 0x7a
#define SRV_TDS_INT8           (BYTE) 0x7f
#define SRV_TDS_BIGVARBINARY   (BYTE) 0xA5
#define SRV_TDS_BIGVARCHAR     (BYTE) 0xA7
#define SRV_TDS_BIGBINARY      (BYTE) 0xAD
#define SRV_TDS_BIGCHAR        (BYTE) 0xAF
#define SRV_TDS_NVARCHAR	   (BYTE) 0xe7
#define SRV_TDS_NCHAR		   (BYTE) 0xef

// Datatypes
// Also: values of symbol parameter to srv_symbol when type = SRV_DATATYPE
#define SRVNULL        SRV_TDS_NULL
#define SRVTEXT        SRV_TDS_TEXT
#define SRVGUID        SRV_TDS_GUID
#define SRVVARBINARY   SRV_TDS_VARBINARY
#define SRVINTN        SRV_TDS_INTN
#define SRVVARCHAR     SRV_TDS_VARCHAR
#define SRVBINARY      SRV_TDS_BINARY
#define SRVIMAGE       SRV_TDS_IMAGE
#define SRVCHAR        SRV_TDS_CHAR
#define SRVINT1        SRV_TDS_INT1
#define SRVBIT         SRV_TDS_BIT
#define SRVINT2        SRV_TDS_INT2
#define SRVDECIMAL	   SRV_TDS_DECIMAL
#define SRVINT4        SRV_TDS_INT4
#define SRVDATETIM4    SRV_TDS_DATETIM4
#define SRVFLT4        SRV_TDS_FLT4    
#define SRVMONEY       SRV_TDS_MONEY
#define SRVDATETIME    SRV_TDS_DATETIME
#define SRVFLT8        SRV_TDS_FLT8
#define SRVNUMERIC	   SRV_TDS_NUMERIC
#define SRVSSVARIANT   SRV_TDS_SSVARIANT
#define SRVNTEXT	   SRV_TDS_NTEXT
#define SRVBITN		   SRV_TDS_BITN
#define SRVDECIMALN	   SRV_TDS_DECIMALN
#define SRVNUMERICN	   SRV_TDS_NUMERICN
#define SRVFLTN        SRV_TDS_FLTN
#define SRVMONEYN      SRV_TDS_MONEYN
#define SRVDATETIMN    SRV_TDS_DATETIMN
#define SRVMONEY4      SRV_TDS_MONEY4
#define SRVINT8        SRV_TDS_INT8  
#define SRVBIGVARBINARY SRV_TDS_BIGVARBINARY
#define SRVBIGVARCHAR  SRV_TDS_BIGVARCHAR
#define SRVBIGBINARY   SRV_TDS_BIGBINARY
#define SRVBIGCHAR     SRV_TDS_BIGCHAR
#define SRVNVARCHAR	   SRV_TDS_NVARCHAR
#define SRVNCHAR	   SRV_TDS_NCHAR

// values for srv_symbol type parameter
#define SRV_ERROR      0
#define SRV_DONE       1
#define SRV_DATATYPE   2
#define SRV_EVENT      4

// values for srv_symbol symbol parameter, when type = SRV_ERROR
#define SRV_ENO_OS_ERR     0
#define SRV_INFO           1
#define SRV_FATAL_PROCESS  10
#define SRV_FATAL_SERVER   19

// Types of server events
// Also: values for srv_symbol symbol parameter, when type = SRV_EVENT
#define SRV_CONTINUE       0
#define SRV_LANGUAGE       1
#define SRV_CONNECT        2
#define SRV_RPC            3
#define SRV_RESTART        4
#define SRV_DISCONNECT     5
#define SRV_ATTENTION      6
#define SRV_SLEEP          7
#define SRV_START          8
#define SRV_STOP           9
#define SRV_EXIT           10
#define SRV_CANCEL         11
#define SRV_SETUP          12
#define SRV_CLOSE          13
#define SRV_PRACK          14
#define SRV_PRERROR        15
#define SRV_ATTENTION_ACK  16
#define SRV_CONNECT_V7	   16	// TDS type for TDS 7 clients.  Overloaded with SRV_ATTENTION_ACK
#define SRV_SKIP		   17
#define SRV_TRANSMGR	   18
#define SRV_PRELOGIN	   19
#define SRV_OLEDB	       20
#define SRV_INTERNAL_HANDLER 99
#define SRV_PROGRAMMER_DEFINED  100

// values for srv_sfield field parameter
#define SRV_SERVERNAME          0
#define SRV_VERSION             6

// Length to indicate string is null terminated
#define SRV_NULLTERM   -1

// values of msgtype parameter to srv_sendmsg
#define SRV_MSG_INFO    1
#define SRV_MSG_ERROR   2

// values of status parameter to srv_senddone
// Also: values for symbol parameters to srv_symbol when type = SRV_DONE
#define SRV_DONE_FINAL			(USHORT) 0x0000
#define SRV_DONE_MORE			(USHORT) 0x0001
#define SRV_DONE_ERROR			(USHORT) 0x0002
#define SRV_DONE_COUNT			(USHORT) 0x0010
#define SRV_DONE_RPC_IN_BATCH   (USHORT) 0x0080

// return values of srv_paramstatus
#define SRV_PARAMRETURN		0x0001
#define SRV_PARAMDEFAULT    0x0002
#define SRV_PARAMSORTORDER	0x0004

// return values of srv_rpcoptions
#define SRV_RECOMPILE		0x0001
#define SRV_NOMETADATA		0x0002

// values of field parameter to srv_pfield
//#define SRV_LANGUAGE 1   already defined above
//#define SRV_EVENT    4   already defined above
#define SRV_SPID				10
#define SRV_NETSPID				11
#define SRV_TYPE				12
#define SRV_STATUS				13
#define SRV_RMTSERVER			14
#define SRV_HOST				15
#define SRV_USER				16
#define SRV_PWD					17
#define SRV_CPID				18
#define SRV_APPLNAME			19
#define SRV_TDS					20
#define SRV_CLIB				21
#define SRV_LIBVERS				22
#define SRV_ROWSENT				23
#define SRV_BCPFLAG				24
#define SRV_NATLANG				25
#define SRV_PIPEHANDLE			26
#define SRV_NETWORK_MODULE	    27
#define SRV_NETWORK_VERSION		28
#define SRV_NETWORK_CONNECTION	29
#define SRV_LSECURE				30
#define SRV_SAXP				31
#define SRV_UNICODE_USER		33
#define SRV_UNICODE_PWD			35
#define SRV_SPROC_CODEPAGE      36
#define SRV_MSGLCID				37
#define SRV_INSTANCENAME		38
#define SRV_HASHPWD				39
#define SRV_UNICODE_CURRENTLOGIN 40

// return value of SRV_TDSVERSION macro
#define SRV_TDS_NONE   0
#define SRV_TDS_2_0    1
#define SRV_TDS_3_4    2
#define SRV_TDS_4_2    3
#define SRV_TDS_6_0    4
#define SRV_TDS_7_0    5

// Return values from APIs
typedef int SRVRETCODE;        // SUCCEED or FAIL
#ifndef ODBCVER
typedef int RETCODE;
#endif

#if !defined( SUCCEED )
#define SUCCEED     1   // Successful return value
#endif

#if !defined( FAIL )
#define FAIL        0   // Unsuccessful return value
#endif

#define SRV_DUPLICATE_HANDLER	2	// additional return value for srv_pre/post_handle

#ifndef COMPILE_FOR_CLR
//------------------------------------------------
//PreDeclare structures
//
struct srv_server;
typedef struct srv_server SRV_SERVER;

struct srv_config;
typedef struct srv_config SRV_CONFIG;

struct CXPData;
typedef struct CXPData SRV_PROC;


//------------------------------------------------
//------------------------------------------------
// ODS MACROs & APIs

// Describing and sending a result set
int __cdecl srv_describe(SRV_PROC*,int,char*,int,long int,long int,long int,long int,void*);
int __cdecl srv_setutype(SRV_PROC* srvproc,int column,long int usertype);
int __cdecl srv_setcoldata(SRV_PROC* srvproc,int column,void* data);
int __cdecl srv_setcollen( SRV_PROC* srvproc,int column,int len);
int __cdecl srv_sendrow(SRV_PROC* srvproc );
int __cdecl srv_senddone(SRV_PROC* srvproc,USHORT status,USHORT curcmd,long int count);

// Dealing with Extended Procedure parameters
int __cdecl srv_rpcparams(SRV_PROC*);
int __cdecl srv_paraminfo(SRV_PROC*,int,BYTE*,ULONG*,ULONG*,BYTE*,BOOL*);
int __cdecl srv_paramsetoutput(SRV_PROC*,int,BYTE*,ULONG,BOOL);

void* __cdecl srv_paramdata(SRV_PROC*,int);
int __cdecl srv_paramlen(SRV_PROC*,int);
int __cdecl srv_parammaxlen(SRV_PROC*,int);
int __cdecl srv_paramtype(SRV_PROC*,int);
int __cdecl srv_paramset(SRV_PROC*,int,void*,int);

char* __cdecl srv_paramname(SRV_PROC*,int,int*);
int __cdecl srv_paramnumber(SRV_PROC*,char*,int);

//--------------------------------------------------------------
//--------------------------------------------------------------
// The rest of these APIs are still supported, in SQL Server 7.0,
// but may not be supported after SQL Server 7.0

// MACROs
#define SRV_GETSERVER(a)		srv_getserver	  ( a )
#define SRV_GOT_ATTENTION(a)	srv_got_attention ( a )
#define	SRV_TDSVERSION(a)		srv_tdsversion	  ( a )

SRV_SERVER* __cdecl srv_getserver( SRV_PROC   * srvproc );
BOOL __cdecl srv_got_attention( SRV_PROC * srvproc );

// Memory
void* __cdecl srv_alloc(long int ulSize);
int __cdecl srv_bmove(void* from,void* to,long int count);
int __cdecl srv_bzero( void  * location,long int count);
int __cdecl srv_free( void * ptr );


int __cdecl srv_convert(SRV_PROC*,int,void*,long int,int,void*,long int);

void* __cdecl srv_getuserdata( SRV_PROC * srvproc );

int __cdecl srv_getbindtoken(SRV_PROC * srvproc,char* token_buf);

int __cdecl srv_getdtcxact(SRV_PROC * srvproc,void ** ppv);

typedef int (* EventHandler)(void *);

int __cdecl srv_impersonate_client( SRV_PROC * srvproc );

long __cdecl srv_langcpy(SRV_PROC *	srvproc,long start,long nbytes,char* buffer);
long __cdecl srv_langlen( SRV_PROC * srvproc );
void* __cdecl srv_langptr( SRV_PROC *srvproc );

int
     __cdecl srv_log( SRV_SERVER * server,
					BOOL	     datestamp,
					char     * msg,
					int 	     msglen );

int __cdecl srv_paramstatus(SRV_PROC*,int);

void* __cdecl srv_pfieldex( SRV_PROC * srvproc,int	field,int	* len );

char* __cdecl srv_pfield( SRV_PROC * srvproc,int	      field,int	    * len );

int __cdecl srv_returnval( SRV_PROC * srvproc,
						  char   * valuename,
						  int		 len,
						  BYTE		 status,
						  long int 	 type,
						  long int 	 maxlen,
						  long int 	 datalen,
						  void	   * value );

int __cdecl srv_revert_to_self( SRV_PROC * srvproc );

char* __cdecl srv_rpcdb(SRV_PROC* srvproc,int* len );
char* __cdecl srv_rpcname(SRV_PROC * srvproc,int* len );
int __cdecl srv_rpcnumber( SRV_PROC * srvproc );
USHORT __cdecl srv_rpcoptions( SRV_PROC * srvproc );
char* __cdecl srv_rpcowner( SRV_PROC * srvproc,int	  * len );

int __cdecl srv_wsendmsg(	SRV_PROC	* srvproc,
						long int	msgnum, 
						BYTE		msgclass, 
						WCHAR		* message,    // message text 
						int			msglen);	   // length of message text

int
     __cdecl srv_sendmsg( SRV_PROC  * srvproc,
						int	        msgtype,
						long int	    msgnum,
						BYTE   msgclass,
						BYTE   state,
						char	  * rpcname,
						int	        rpcnamelen,
						USHORT linenum,
						char	  * message,
						int	        msglen );

int __cdecl srv_sendstatus( SRV_PROC * srvproc,long int	  status );


int __cdecl srv_setuserdata(SRV_PROC* srvproc,void* ptr);


char* __cdecl srv_sfield( SRV_SERVER * server,int field,int* len);

char* __cdecl srv_symbol(int	type,int symbol,int* len);

int __cdecl srv_tdsversion(SRV_PROC* srvproc);

BOOL __cdecl srv_willconvert(int srctype,int desttype );

int __cdecl srv_terminatethread( SRV_PROC * srvproc );

int __cdecl srv_sendstatistics( SRV_PROC * srvproc );

int __cdecl srv_clearstatistics( SRV_PROC * srvproc );

int __cdecl srv_message_handler( SRV_PROC * srvproc, 
								int        errornum, 
								BYTE       severity,
								BYTE       state, 
								int        oserrnum, 
								char     * errtext, 
								int        errtextlen, 
								char     * oserrtext, 
								int        oserrtextlen );

int __cdecl srv_pre_handle( SRV_SERVER * server,
						    SRV_PROC   * srvproc,
						    long int event,
						    EventHandler handler,
						    BOOL         remove );
int __cdecl srv_post_handle( SRV_SERVER * server,
							 SRV_PROC   * srvproc,
							 long int        event,
							 EventHandler handler,
							 BOOL         remove );

int __cdecl srv_IgnoreAnsiToOem( SRV_PROC * srvproc,BOOL bTF);

#endif // #ifndef COMPILE_FOR_CLR

#ifdef __cplusplus
}
#endif

#pragma pack()

#define SS_MAJOR_VERSION    7
#define SS_MINOR_VERSION    00
#define SS_LEVEL_VERSION    0000
#define SS_MINIMUM_VERSION  "7.00.00.0000"
#define ODS_VERSION			((SS_MAJOR_VERSION << 24)  | (SS_MINOR_VERSION << 16))

#endif //_ODS_SRV_H_

//////////////////////////////////////////////////////////////////
// Suggested implementation of __GetXpVersion
//
//__declspec(dllexport) ULONG __GetXpVersion() 
//	{
//	return ODS_VERSION;
//	}
//////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\SQLAgent\code\Connection.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Reflection;
using System.Data.SqlClient;
using System.Diagnostics;

namespace SQLAgent
{
    using ConsoleFileLog;

    public class Connection
    {
        public Connection(LogWriter logWriter, string serverName, string userName, string userPassword)
        {
            Debug.Assert(logWriter != null);
            this.logWriter = logWriter;

            Debug.Assert(serverName != null);
            this.serverName = serverName;

            this.userName = userName;
            this.userPassword = userPassword;
        }

        public SqlConnection GetSqlConnection(string databaseName, int connectTimeout)
        {
            SqlConnectionStringBuilder sqlConnectionStringBuilder = new SqlConnectionStringBuilder();

            sqlConnectionStringBuilder.ApplicationName = Assembly.GetExecutingAssembly().FullName;
            sqlConnectionStringBuilder.ConnectTimeout = connectTimeout;
            sqlConnectionStringBuilder.DataSource = serverName;
            sqlConnectionStringBuilder.InitialCatalog = databaseName;

            if (true == String.IsNullOrEmpty(userName))
            {
                sqlConnectionStringBuilder.IntegratedSecurity = true;
            }
            else
            {
                sqlConnectionStringBuilder.IntegratedSecurity = false;
                sqlConnectionStringBuilder.UserID = userName;
                sqlConnectionStringBuilder.Password = userPassword;
            }

            return new SqlConnection(sqlConnectionStringBuilder.ToString());
        }

        private string serverName;
        private string userName;
        private string userPassword;

        private LogWriter logWriter;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\SQLAgent\code\Job.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Threading;
using System.Reflection;
using System.Data.SqlClient;
using System.Diagnostics;

namespace SQLAgent
{
    using ConsoleFileLog;

    public class Job
    {
        public Job(LogWriter logWriter, Connection connection, string name)
        {
            Debug.Assert(logWriter != null);
            this.logWriter = logWriter;

            Debug.Assert(connection != null);
            this.connection = connection;

            Debug.Assert(name != null);
            this.name = name;
        }

        public Connection Connection
        {
            get { return connection; }
        }

        public string Name
        {
            get { return name; }
        }

        public void Start()
        {
            using (SqlConnection sqlConnection = connection.GetSqlConnection(SQLAgent.MSDB_DATABASE, SQLAgent.CONNECT_TIMEOUT))
            {
                sqlConnection.Open();

                SqlCommand sqlCommand = sqlConnection.CreateCommand();
                sqlCommand.CommandTimeout = SQLAgent.COMMAND_TIMEOUT;
                sqlCommand.CommandText = "EXEC dbo.sp_start_job @job_name='" + name + "'";

                //log.WriteLine("Running SQL: " + sqlCommand.CommandText);
                SqlDataReader sqlReader = sqlCommand.ExecuteReader();
                sqlReader.Close();

                logWriter.WriteLine("Job '" + name + "' started.");
            }
        }

        public void Wait()
        {
            try
            {
                int loopCount = 0;

                while (true)
                {
                    ++loopCount;

                    using (SqlConnection sqlConnection = connection.GetSqlConnection(SQLAgent.MSDB_DATABASE, SQLAgent.CONNECT_TIMEOUT))
                    {
                        sqlConnection.Open();

                        SqlCommand sqlCommand = sqlConnection.CreateCommand();
                        sqlCommand.CommandTimeout = SQLAgent.COMMAND_TIMEOUT;
                        sqlCommand.CommandText = "SELECT TOP(1) a.run_requested_date, a.start_execution_date, a.stop_execution_date, a.job_history_id, a.job_id";
                        sqlCommand.CommandText += " FROM sysjobs as j, sysjobactivity as a";
                        sqlCommand.CommandText += " WHERE j.job_id=a.job_id AND j.name='" + name + "'";
                        sqlCommand.CommandText += " ORDER BY a.session_id DESC";

                        int INDEX_RUN_REQUESTED_DATE = 0;
                        int INDEX_START_EXECUTION_DATE = 1;
                        int INDEX_STOP_EXECUTION_DATE = 2;
                        int INDEX_JOB_HISTORY_ID = 3;
                        int INDEX_JOB_ID = 4;

                        //log.WriteLine("Running SQL: " + sqlCommand.CommandText);
                        SqlDataReader sqlReader = sqlCommand.ExecuteReader();

                        if (sqlReader.Read() == false)
                        {
                            throw new Exception("Job '" + name + "' does not exist!");
                        }

                        if (sqlReader.IsDBNull(INDEX_RUN_REQUESTED_DATE) && sqlReader.IsDBNull(INDEX_START_EXECUTION_DATE))
                        {
                            logWriter.Write("Job '" + name + "' has not run yet!");
                            return;
                        }

                        if (sqlReader.IsDBNull(INDEX_START_EXECUTION_DATE) == false)
                        {
                            DateTime startExecutionDate = sqlReader.GetDateTime(INDEX_START_EXECUTION_DATE);

                            if (sqlReader.IsDBNull(INDEX_STOP_EXECUTION_DATE) == false)
                            {
                                DateTime stopExecutionDate = sqlReader.GetDateTime(INDEX_STOP_EXECUTION_DATE);

                                if (startExecutionDate.CompareTo(stopExecutionDate) <= 0)
                                {
                                    Guid jobId = sqlReader.GetGuid(INDEX_JOB_ID);
                                    int jobHistoryId = sqlReader.GetInt32(INDEX_JOB_HISTORY_ID);
                                    sqlCommand = sqlConnection.CreateCommand();
                                    sqlCommand.CommandTimeout = SQLAgent.COMMAND_TIMEOUT;
                                    sqlCommand.CommandText = "SELECT TOP(2) sql_message_id, run_status, message";
                                    sqlCommand.CommandText += " FROM sysjobhistory";
                                    sqlCommand.CommandText += " WHERE job_id='" + jobId.ToString() + "'";
                                    sqlCommand.CommandText += " AND instance_id<=" + jobHistoryId.ToString();
                                    sqlCommand.CommandText += " ORDER BY instance_id DESC";

                                    int INDEX_SQL_MESSAGE_ID = 0;
                                    int INDEX_RUN_STATUS = 1;
                                    int INDEX_MESSAGE = 2;

                                    sqlReader.Close();

                                    //log.WriteLine("Running SQL: " + sqlCommand.CommandText);
                                    sqlReader = sqlCommand.ExecuteReader();

                                    if (sqlReader.Read() == false)
                                    {
                                        throw new Exception("Error getting job status!");
                                    }

                                    int sqlMessageId = sqlReader.GetInt32(INDEX_SQL_MESSAGE_ID);
                                    SQLJobStepRunStatus runStatus = (SQLJobStepRunStatus) sqlReader.GetInt32(INDEX_RUN_STATUS);
                                    string message = sqlReader.GetString(INDEX_MESSAGE);

                                    if (loopCount > 1)
                                    {
                                        logWriter.WriteLine();
                                    }

                                    switch (runStatus)
                                    {
                                        case SQLJobStepRunStatus.Succeeded:
                                            logWriter.Write("Job '" + name + "' succeeded.");
                                            return;

                                        case SQLJobStepRunStatus.Canceled:
                                            throw new Exception("Job '" + name + "' was canceled.");

                                        case SQLJobStepRunStatus.Failed:
                                            logWriter.Write("Job '" + name + "' FAILED!");
                                            message = "Job '" + name + "' failed.";

                                            if (sqlReader.Read())
                                            {
                                                message += "\r\n";
                                                message += sqlReader.GetString(INDEX_MESSAGE);
                                            }
                                            throw new Exception(message);
                                    }
                                }
                            }
                        }
                    }

                    logWriter.Write((loopCount == 1) ? "Job '" + name + "' is running." : ".");
                    Thread.Sleep(1000);
                }
            }
            finally
            {
                logWriter.WriteLine();
            }
        }

        public int Enable(bool enable)
        {
            try
            {
                using (SqlConnection sqlConnection = connection.GetSqlConnection(SQLAgent.MSDB_DATABASE, SQLAgent.CONNECT_TIMEOUT))
                {
                    sqlConnection.Open();

                    SqlCommand sqlCommand = sqlConnection.CreateCommand();
                    sqlCommand.CommandTimeout = SQLAgent.COMMAND_TIMEOUT;
                    sqlCommand.CommandText = "EXEC dbo.sp_update_job @job_name='" + name + "'";
                    sqlCommand.CommandText += ", @enabled=" + (enable ? "1" : "0");

                    SqlDataReader sqlReader = sqlCommand.ExecuteReader();
                    sqlReader.Close();

                    logWriter.WriteLine("Job '" + name + "' " + (enable ? "enabled" : "disabled") + ".");
                }

                return 0;
            }
            finally
            {
                logWriter.WriteLine();
            }
        }

        private LogWriter logWriter;
        private Connection connection;
        private string name;

        enum SQLJobStepRunStatus
        {
            Failed = 0,
            Succeeded = 1,
            Retry = 2,
            Canceled = 3,
            InProgress = 4,
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\SQLAgent\code\SQLAgent.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Diagnostics;

namespace SQLAgent
{
    using ConsoleFileLog;
    using NamedArgParser;

    class SQLAgent
    {
        static public int Main(string[] args)
        {
            int returnValue = 0;

            Assembly assembly = Assembly.GetExecutingAssembly();
            string assemblyName = Path.GetFileNameWithoutExtension(assembly.ManifestModule.Name);

            // attach the log object
            logWriter.AttachConsole();
            try
            {
                logWriter.AttachFile(assemblyName + ".log");
            }
            catch (IOException e)
            {
                logWriter.WriteLine("IOException: " + e.Message);
                return Marshal.GetHRForException(e);
            }

            try
            {
                // parse the command line arguments
                NamedArgsCollection namedArgsCollection = new NamedArgsCollection();
                string namedArgGroup = null;
                using (Stream stream = assembly.GetManifestResourceStream("SQLAgent.Resources.Usage.xml"))
                {
                    namedArgGroup = namedArgsCollection.Parse(stream, args, new DisplayUsageCallback(DisplayUsage));
                }

                if (String.IsNullOrEmpty(namedArgGroup))
                {
                    throw new ArgumentException("Missing parameter.");
                }

                if (namedArgsCollection["quiet"] != null)
                {
                    logWriter.DetachConsole();
                }

                Connection connection = new Connection(logWriter, namedArgsCollection["server"], namedArgsCollection["uid"], namedArgsCollection["pwd"]);

                if ("StartJob" == namedArgGroup)
                {
                    Job job = new Job(logWriter, connection, namedArgsCollection["start"]);
                    job.Start();
                }
                else if ("WaitJob" == namedArgGroup)
                {
                    Job job = new Job(logWriter, connection, namedArgsCollection["wait"]);
                    job.Wait();
                }
                else if ("EnableJob" == namedArgGroup)
                {
                    Job job = new Job(logWriter, connection, namedArgsCollection["enable"]);
                    returnValue = job.Enable(true);
                }
                else if ("DisableJob" == namedArgGroup)
                {
                    Job job = new Job(logWriter, connection, namedArgsCollection["disable"]);
                    returnValue = job.Enable(false);
                }
                else
                {
                    Debug.Assert(false);
                }

                return returnValue;
            }
            catch (Exception e)
            {
                returnValue = Marshal.GetHRForException(e);
                logWriter.WriteLine("Error {0}: {1}", returnValue, e.Message);
                logWriter.WriteLine(e.StackTrace);
                return returnValue;
            }
        }

        public const string MSDB_DATABASE = "MSDB";
        public const int CONNECT_TIMEOUT = 30;
        public const int COMMAND_TIMEOUT = 30;

        /// <summary>
        /// Displays the program usage
        /// </summary>
        static private void DisplayUsage(string usage)
        {
            logWriter.WriteLine(usage);
        }

        static private LogWriter logWriter = new LogWriter();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\armmk.inc ===
!IF 0

Copyright (c) Microsoft Corporation

Module Name:

    armmk.inc

Abstract:

        This module contains the ARM specific build controls.  It is included
        by makefile.def.

Revision History:

!ENDIF

#
# ARM option control
#
UMBASE=$(UMBASE:*=arm)
UMLIBS=$(UMLIBS:*=arm)
NTRES=$(NTRES:*=arm)
UMRES=$(UMRES:*=arm)
UMOBJS=$(UMOBJS:*=arm)
LINKLIBS=$(LINKLIBS:*=arm)
GDI_DRIVER_LIBS=$(GDI_DRIVER_LIBS:*=arm)
DLLBASE=$(DLLBASE:*=arm)
DLLDEF=$(DLLDEF:*=arm)
MACHINE_TARGETLIBS=$(MACHINE_TARGETLIBS:*=arm)
!ifdef USE_MSHTML_PDB_RULES
MACHINE_TARGETLIBS=$(MACHINE_TARGETLIBS:????????=*)
!endif
TARGET=$(TARGET:*=arm)
DYNLINK_LIB=$(DYNLINK_LIB:*=arm)
TARGETEXEFILES=$(TARGETEXEFILES:*=arm)
TARGETLIBFILES=$(TARGETLIBFILES:*=arm)
TARGETOBJFILES=$(TARGETOBJFILES:*=arm)
UMOBJFILES=$(UMOBJFILES:*=arm)
UMEXEFILES=$(UMEXEFILES:*=arm)
HEADERFILE=$(HEADERFILE:*=arm)
HEADEROBJNAME=$(HEADEROBJNAME:*=arm)
HEADEROBJ=$(HEADEROBJ:*=arm)
PRECOMPILED=$(PRECOMPILED:*=arm)
PRECOMPILED_CXX=$(PRECOMPILED_CXX:*=arm)
PRECOMPILED_TARGET=$(PRECOMPILED_TARGET:*=arm)
MFC_STATIC_LIB=$(MFC_STATIC_LIB:*=arm)
CRT_LIB_PATH=$(CRT_LIB_PATH:*=arm)
SDK_LIB_PATH=$(SDK_LIB_PATH:*=arm)
DDK_LIB_PATH=$(DDK_LIB_PATH:*=arm)
IFSKIT_LIB_PATH=$(IFSKIT_LIB_PATH:*=arm)
HALKIT_LIB_PATH=$(HALKIT_LIB_PATH:*=arm)
ORDER=$(ORDER:*=arm)
OBJLIBFILES=$(OBJLIBFILES:*=arm)
MISCFILES=$(MISCFILES) $(ARM_MISCFILES)
SOURCES=$(SOURCES) $(ARM_SOURCES)

ADDITIONAL_ATL_LIBS = $(ADDITIONAL_ATL_LIBS) $(ATL_LIB_PATH)\atls.lib

!ifdef NTTARGETFILES
NTTARGETFILES=$(NTTARGETFILES:*=arm)
!endif
!ifdef NTTARGETFILE0
NTTARGETFILE0=$(NTTARGETFILE0:*=arm)
!endif
!ifdef NTTARGETFILE1
NTTARGETFILE1=$(NTTARGETFILE1:*=arm)
!endif

!ifdef PROJECT_LIB_PATH
PROJECT_LIB_PATH=$(PROJECT_LIB_PATH:*=arm)
!endif

ENTRY_SUFFIX=
GDI_ENTRY_SUFFIX=

DEFAULT_STACKRESERVE=0x40000
DEFAULT_STACKCOMMIT=0x1000

ADDITIONAL_ATL_LIBS = $(ADDITIONAL_ATL_LIBS)

!IFDEF ARM_WARNING_LEVEL
MSC_WARNING_LEVEL=$(ARM_WARNING_LEVEL)
!ENDIF

MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

!ifdef ARM_PERFFLAGS
PERFFLAGS = $(ARM_PERFFLAGS)
!endif

# Set MSC_OPTIMIZATION.
# Order of precedence:
#   Platform specific override
#   Environment variable
#   System Default

!if defined(ARM_OPTIMIZATION)
MSC_OPTIMIZATION=$(ARM_OPTIMIZATION)
!elseif !defined(MSC_OPTIMIZATION)
MSC_OPTIMIZATION=$(DEFAULT_MSC_OPT)
!endif

DBGFLAGS=$(DBGFLAGS) $(MSC_OPTIMIZATION)

WIN32_LIBS=$(WIN32_LIBS) $(SDK_LIB_PATH)\ntdll.lib

!IFDEF ARM_CPPFLAGS
MSC_CPPFLAGS=$(ARM_CPPFLAGS)
!ENDIF

!ifdef NO_STRING_POOLING
STRING_POOLING =
!else
!ifdef NO_READONLY_STRINGS
STRING_POOLING = /Gf
!else
STRING_POOLING = /GF
!endif
!endif

!ifdef USE_NATIVE_EH
! if "$(USE_NATIVE_EH)" == "ASYNC"
EH_FLAGS=/EHa
! else
!  if "$(USE_NATIVE_EH)" == "CTHROW"
EH_FLAGS=/EHsc-
!  else
EH_FLAGS=/EHsc
!  endif
! endif
!else
EH_FLAGS=/EHs-c-
!endif

! ifdef USE_RTTI
RTTI_FLAGS=/GR
! else
RTTI_FLAGS=/GR-
! endif

! if "$(BUFFER_OVERFLOW_CHECKS)" == "1"
BO_FLAGS = /GS
! endif

!ifndef ARM_CPU_OPTIMIZATION
ARM_CPU_OPTIMIZATION=
!endif

!if defined(ARM_STRUCT_PACKING)
MSC_STRUCT_PACKING=$(ARM_STRUCT_PACKING)
!elseif !defined(MSC_STRUCT_PACKING)
MSC_STRUCT_PACKING=/Zp8
!endif

STDFLAGS= /c /Zl $(MSC_STRUCT_PACKING) /Gy $(CBSTRING) $(MSC_WARNING_LEVEL) $(MSC_CALL_TYPE) \
          $(ERATTA_FLAGS) $(ARM_CPU_OPTIMIZATION) $(EH_FLAGS) \
          $(RTTI_FLAGS) $(STRING_POOLING) $(BO_FLAGS)

!if $(FREEBUILD)
ASM_DBG_DEFINES=/DDBG=0
!else
ARM_ADBGFLAGS=$(ARM_ADBGFLAGS) /Zi
!endif

# @@BEGIN_DDKSPLIT
!IFDEF NTBBT
# @@END_DDKSPLIT
DBGFLAGS=$(DBGFLAGS) /Zi
ARM_ADBGFLAGS=$(ARM_ADBGFLAGS) /Zi
LINKER_FLAGS=$(LINKER_FLAGS) /debug:full /debugtype:cv,fixup,pdata
# @@BEGIN_DDKSPLIT
!ENDIF
# @@END_DDKSPLIT

!if !defined(USE_PDB_TO_COMPILE) || "$(USE_PDB_TO_COMPILE)" == "0"
DBGFLAGS=$(DBGFLAGS:/Zi=/Z7)
DBGFLAGS=$(DBGFLAGS:-Zi=/Z7)
!else
USER_C_FLAGS=$(USER_C_FLAGS:/Z7=/Zi)
USER_C_FLAGS=$(USER_C_FLAGS:-Z7=/Zi)
! ifndef USE_MSHTML_PDB_RULES
!  if "$(TARGETTYPE)" == "LIBRARY"
DBGFLAGS=$(DBGFLAGS) /Fd$(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).pdb
!  else
DBGFLAGS=$(DBGFLAGS) /Fd$(MAKEDIR)\$O^\
!  endif
! else
!  ifndef TARGETPDB
TARGETPDB=$(TARGETNAME)
!  endif
DBGFLAGS=$(DBGFLAGS) /Fd$(OBJ_PATH)\$O\$(TARGETPDB).pdb
! endif
!endif

!ifndef NO_BROWSER_INFO
! ifdef BROWSER_INFO
DBGFLAGS=$(DBGFLAGS) /FR$(OBJ_PATH)\$O^\
! endif
!endif

#
# arm option control
#

!IF "$(HALTYPE)" == ""
HALDEF=
!ELSE
HALDEF=/D$(HALTYPE)=1
!ENDIF

!IF "$(USE_STD_DEFINES)" == "1"
STD_DEFINES=/D_ARM_ /DARM $(HALDEF) $(MSC_CALL_DEFINE) $(STD_DEFINES)
!ELSE
STD_DEFINES=
!ENDIF

CDEFINES=$(STD_DEFINES) $(TARGET_DBG_DEFINES) \
              $(LIBC_DEFINES) $(C_DEFINES) $(NET_C_DEFINES) $(MFC_DEFINES)
CFLAGS=$(ARM_FLAGS) $(NTARMFLAGS) $(STDFLAGS) $(DBGFLAGS) $(PERFFLAGS) $(USER_C_FLAGS)
ARM_ASMFLAGS=$(ARM_ADBGFLAGS) $(STD_DEFINES) $(ASM_DBG_DEFINES)\
              $(TARGET_DBG_DEFINES) $(ASM_DEFINES)

ARM_CDEFINES=$(CDEFINES)
ARM_CFLAGS=$(CFLAGS)

!if defined(SUBSTITUTE_ARM_CC_MANAGED) && defined(MANAGED_CXX)
CC_NAME=$(SUBSTITUTE_ARM_CC_MANAGED)
!elseif defined(SUBSTITUTE_ARM_CC) && !defined(MANAGED_CXX)
CC_NAME=$(SUBSTITUTE_ARM_CC)
!elseif !defined(CC_NAME)
CC_NAME=cl.exe 
!endif

C_COMPILER_NAME     = $(CC_NAME)
CXX_COMPILER_NAME   = $(CC_NAME)
C_PREPROCESSOR_NAME = $(CC_NAME)
!ifndef ARM_ASSEMBLER_NAME
ARM_ASSEMBLER_NAME  = armasm.exe
!endif

GLOBAL_C_FLAGS = /Iarm\ /I. $(INCPATH1) $(CDEFINES) $(CFLAGS)

NP_COMPILER_FLAGS = $(GLOBAL_C_FLAGS) $(COMPILER_WARNINGS)

CXX_COMPILER_FLAGS_NOPCH = $(NP_COMPILER_FLAGS) $(MSC_CPPFLAGS) $(NTCPPFLAGS) $(MANAGED_CXX_FLAGS)
C_COMPILER_FLAGS_NOPCH = $(NP_COMPILER_FLAGS)
C_COMPILER_FLAGS = $(C_COMPILER_FLAGS_NOPCH) $(PRECOMPILED)
CXX_COMPILER_FLAGS = $(CXX_COMPILER_FLAGS_NOPCH) $(PRECOMPILED_CXX)
C_PREPROCESSOR_FLAGS = $(GLOBAL_C_FLAGS) /EP /Tc

C_PREPROCESSOR = $(C_PREPROCESSOR_NAME) $(C_PREPROCESSOR_FLAGS)
C_ASM_PREPROCESSOR = $(C_PREPROCESSOR_NAME) $(ASM_DEFINES) $(C_PREPROCESSOR_FLAGS)
C_COMPILER     = $(C_COMPILER_NAME) $(C_COMPILER_FLAGS)
NP_C_COMPILER  = $(C_COMPILER_NAME) $(NP_COMPILER_FLAGS)
CXX_COMPILER   = $(CXX_COMPILER_NAME) $(CXX_COMPILER_FLAGS)

ARM_ASSEMBLER=$(ARM_ASSEMBLER_NAME) /c /coff /Cx /nologo /Iarm /I. $(INCPATH1) $(ARM_ASMFLAGS)

ECHO_MSG=$(C_COMPILER) $<
ECHO_MSG_P=$(NP_C_COMPILER) $**
ECHO_CXX_MSG=$(CXX_COMPILER) $<

ECHO_PRECOMPILED_MSG1=$(C_COMPILER_NAME) $(C_COMPILER_FLAGS) /Yl$(TARGETNAME) /Yc$(?F) $(HEADERFILE) \
               $(HEADEROBJ) $(PRECOMPILED_FLAG) $(PRECOMPILED_SOURCEFILE)
	       
ECHO_PRECOMPILED_MSG2=$(C_COMPILER_NAME) $(C_COMPILER_FLAGS) /Yl$(TARGETNAME) /Yc$(?F) $(HEADERFILE) \
               $(HEADEROBJ) $(PRECOMPILED_FLAG)

{}.c{}.asm:
    $(C_COMPILER_NAME) @<< /Fa $(MAKEDIR)\$<
$(C_COMPILER_FLAGS: =
)
$(C_COMPILER_FLAGS:##= )
<<NOKEEP


{..\arm}.asm{}.lst:
    $(ARM_ASSEMBLER) /Fl$@ /Fo$O\$(@B).obj $(MAKEDIR)\$<

{arm}.asm{}.lst:
    $(ARM_ASSEMBLER) /Fl$@ /Fo$(OBJ_PATH)\$O\$(@B).obj $(MAKEDIR)\$<

{..\arm}.asm{$O}.obj:
    $(ARM_ASSEMBLER) /Fo$(OBJ_PATH)\$@ $(MAKEDIR)\$<

{arm}.asm{$O}.obj:
    $(ARM_ASSEMBLER) /Fo$(OBJ_PATH)\$@ $(MAKEDIR)\$<

{$O}.asm{$O}.obj:
    $(ARM_ASSEMBLER) /Fo$(OBJ_PATH)\$@ $(MAKEDIR)\$<

{..\arm}.asm{$(OBJ_PATH)\$O}.obj:
    $(ARM_ASSEMBLER) /Fo$@ $(MAKEDIR)\$<

{arm}.asm{$(OBJ_PATH)\$O}.obj:
    $(ARM_ASSEMBLER) /Fo$@ $(MAKEDIR)\$<

{$(OBJ_PATH)\$O}.asm{$(OBJ_PATH)\$O}.obj:
    $(ARM_ASSEMBLER) /Fo$@ $<

!IF "$(NTDEBUGTYPE)" == "windbg" || "$(NTDEBUGTYPE)" == "both"
NTKERNEL_LINK_OPTIONS=/entry:KiSystemStartup
!ELSE
NTKERNEL_LINK_OPTIONS=/base:0x80100000 /entry:KiSystemStartup
!ENDIF

!IFDEF USE_NO_WIN98
LINKER_FLAGS=$(LINKER_FLAGS) /opt:nowin98
!ENDIF

DRIVER_ALIGNMENT=0x0080
KERNEL_ALIGNMENT=0x1000
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\amd64mk.inc ===
!IF 0

Copyright (c) Microsoft Corporation

Module Name:

    amd64mk.inc

Abstract:

        This module contains the AMD64 specific build controls.  It is included
        by makefile.def.

Revision History:

!ENDIF

#
# AMD64 option control
#
UMBASE=$(UMBASE:*=amd64)
UMLIBS=$(UMLIBS:*=amd64)
NTRES=$(NTRES:*=amd64)
UMRES=$(UMRES:*=amd64)
UMOBJS=$(UMOBJS:*=amd64)
CRTLIBS=$(CRTLIBS:*=amd64)
LINKLIBS=$(LINKLIBS:*=amd64)
GDI_DRIVER_LIBS=$(GDI_DRIVER_LIBS:*=amd64)
DLLBASE=$(DLLBASE:*=amd64)
DLLDEF=$(DLLDEF:*=amd64)
MACHINE_TARGETLIBS=$(MACHINE_TARGETLIBS:*=amd64)
!ifdef USE_MSHTML_PDB_RULES
MACHINE_TARGETLIBS=$(MACHINE_TARGETLIBS:????????=*)
!endif
TARGET=$(TARGET:*=amd64)
DYNLINK_LIB=$(DYNLINK_LIB:*=amd64)
TARGETEXEFILES=$(TARGETEXEFILES:*=amd64)
TARGETLIBFILES=$(TARGETLIBFILES:*=amd64)
TARGETOBJFILES=$(TARGETOBJFILES:*=amd64)
UMOBJFILES=$(UMOBJFILES:*=amd64)
UMEXEFILES=$(UMEXEFILES:*=amd64)
HEADERFILE=$(HEADERFILE:*=amd64)
HEADEROBJNAME=$(HEADEROBJNAME:*=amd64)
HEADEROBJ=$(HEADEROBJ:*=amd64)
PRECOMPILED=$(PRECOMPILED:*=amd64)
PRECOMPILED_CXX=$(PRECOMPILED_CXX:*=amd64)
PRECOMPILED_TARGET=$(PRECOMPILED_TARGET:*=amd64)
MFC_STATIC_LIB=$(MFC_STATIC_LIB:*=amd64)
CRT_LIB_PATH=$(CRT_LIB_PATH:*=amd64)
SDK_LIB_PATH=$(SDK_LIB_PATH:*=amd64)
DDK_LIB_PATH=$(DDK_LIB_PATH:*=amd64)
IFSKIT_LIB_PATH=$(IFSKIT_LIB_PATH:*=amd64)
HALKIT_LIB_PATH=$(HALKIT_LIB_PATH:*=amd64)
ORDER=$(ORDER:*=amd64)
OBJLIBFILES=$(OBJLIBFILES:*=amd64)
MISCFILES=$(MISCFILES) $(AMD64_MISCFILES)
!if defined(AMD64_DRIVER_INFS)
DRIVER_INFS=$(DRIVER_INFS) $(AMD64_DRIVER_INFS)
!endif
!if defined(AMD64_PRINTER_INFS)
PRINTER_INFS=$(PRINTER_INFS) $(AMD64_PRINTER_INFS)
!endif
!if defined(AMD64_NON_PNP_INFS)
NON_PNP_INFS=$(NON_PNP_INFS) $(AMD64_NON_PNP_INFS)
!endif
!if defined(AMD64_NON_PNP_SIGN_INFS)
NON_PNP_SIGN_INFS=$(NON_PNP_SIGN_INFS) $(AMD64_NON_PNP_SIGN_INFS)
!endif
!if defined(AMD64_LOC_DRIVER_INFS)
LOC_DRIVER_INFS=$(LOC_DRIVER_INFS) $(AMD64_LOC_DRIVER_INFS)
!endif
!if defined(AMD64_LOC_PRINTER_INFS)
LOC_PRINTER_INFS=$(LOC_PRINTER_INFS) $(AMD64_LOC_PRINTER_INFS)
!endif
!if defined(AMD64_LOC_NON_PNP_INFS)
LOC_NON_PNP_INFS=$(LOC_NON_PNP_INFS) $(AMD64_LOC_NON_PNP_INFS)
!endif
!if defined(AMD64_LOC_NON_PNP_SIGN_INFS)
LOC_NON_PNP_SIGN_INFS=$(LOC_NON_PNP_SIGN_INFS) $(AMD64_LOC_NON_PNP_SIGN_INFS)
!endif
SOURCES=$(SOURCES) $(AMD64_SOURCES)

!ifdef NTTARGETFILES
NTTARGETFILES=$(NTTARGETFILES:*=amd64)
!endif
!ifdef NTTARGETFILE0
NTTARGETFILE0=$(NTTARGETFILE0:*=amd64)
!endif
!ifdef NTTARGETFILE1
NTTARGETFILE1=$(NTTARGETFILE1:*=amd64)
!endif

!ifdef PROJECT_LIB_PATH
PROJECT_LIB_PATH=$(PROJECT_LIB_PATH:*=amd64)
!endif

ENTRY_SUFFIX=
GDI_ENTRY_SUFFIX=

DEFAULT_STACKRESERVE=0x80000
DEFAULT_STACKCOMMIT=0x2000

ADDITIONAL_ATL_LIBS = $(ADDITIONAL_ATL_LIBS)

!IFDEF AMD64_WARNING_LEVEL
MSC_WARNING_LEVEL=$(AMD64_WARNING_LEVEL)
!ENDIF

MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) $(COMPILER_WX_SWITCH)

!ifdef AMD64_PERFFLAGS
PERFFLAGS = $(AMD64_PERFFLAGS)
!endif

# Set MSC_OPTIMIZATION.
# Order of precedence:
#   Platform specific override
#   Environment variable
#   System Default

!ifdef AMD64_OPTIMIZATION
MSC_OPTIMIZATION=$(AMD64_OPTIMIZATION)
!elseif !defined(MSC_OPTIMIZATION)
MSC_OPTIMIZATION=$(DEFAULT_MSC_OPT)
!endif

LINK_TIME_CODE_GENERATION_MSC_FLAG=
!if defined(LINK_TIME_CODE_GENERATION) && !defined(FORCENATIVEOBJECT)
# Some objects must be built native, so turn off GL for those
LINK_TIME_CODE_GENERATION_MSC_FLAG=/GL
!endif

DBGFLAGS=$(DBGFLAGS) $(MSC_OPTIMIZATION) $(LINK_TIME_CODE_GENERATION_MSC_FLAG)

!IFDEF AMD64_CPPFLAGS
MSC_CPPFLAGS=$(AMD64_CPPFLAGS)
!ENDIF

!ifdef NO_STRING_POOLING
STRING_POOLING =
!else
!ifdef NO_READONLY_STRINGS
STRING_POOLING = /Gf
!else
STRING_POOLING = /GF
!endif
!endif

!ifdef USE_NATIVE_EH
!if "$(USE_NATIVE_EH)" == "ASYNC"
EH_FLAGS=/EHa
!else
!if "$(USE_NATIVE_EH)" == "CTHROW"
EH_FLAGS=/EHsc-
!else
EH_FLAGS=/EHsc
!endif
!endif
!else
EH_FLAGS=/EHs-c-
!endif

!if defined(USE_RTTI) || defined(MANAGED_CXX)
RTTI_FLAGS=/GR
! else
RTTI_FLAGS=/GR-
! endif

# On by default
!if "$(BUFFER_OVERFLOW_CHECKS)" == ""
BUFFER_OVERFLOW_CHECKS=1
!endif

# Turn off for the select few
!if ("$(DRIVERTYPE)" == "VXD") || \
    (("$(TARGETTYPE)" == "MINIPORT") && ($(_NT_TARGET_VERSION) < 0x502)) || \
    (("$(TARGETTYPE)" == "DYNLINK") && defined(RESOURCE_ONLY_DLL)) || \
    "$(BUFFER_OVERFLOW_CHECKS)" == "0"
!undef BUFFER_OVERFLOW_CHECKS
!endif

!if defined(BUFFER_OVERFLOW_CHECKS)
# verify it's one of the chosen few - 1, NTDLL or compile only - all others are wrong.
! if "$(BUFFER_OVERFLOW_CHECKS)" != "1" && \
     "$(BUFFER_OVERFLOW_CHECKS)" != "NTDLL" && \
     "$(BUFFER_OVERFLOW_CHECKS)" != "COMPILE_ONLY" && \
     "$(BUFFER_OVERFLOW_CHECKS)" != "LINK_ONLY"
!message BUILDMSG: Error: INVALID BUFFER_OVERFLOW_CHECKS value "$(BUFFER_OVERFLOW_CHECKS)" in $(MAKEDIR)
! endif
! if "$(BUFFER_OVERFLOW_CHECKS)" == "LINK_ONLY"
BO_FLAGS=/GS-
BUFFER_OVERFLOW_CHECKS=1
! else
BO_FLAGS=/GS
! endif
! if "$(BUFFER_OVERFLOW_CHECKS)" == "1"
!  if "$(TARGETTYPE)" == "DRIVER" || \
      "$(TARGETTYPE)" == "EXPORT_DRIVER" || \
      "$(TARGETTYPE)" == "DRIVER_LIBRARY" || \
      "$(TARGETTYPE)" == "MINIPORT" 
BO_LIB=$(SDK_LIB_PATH)\BufferOverflowK.lib
DRIVER_ENTRY=GsDriverEntry
!  elseif "$(TARGETTYPE)" == "GDI_DRIVER"
BO_LIB=$(SDK_LIB_PATH)\BufferOverflowGDI.lib
GDI_DRIVER_ENTRY=GsDrvEnableDriver
!  elseif "$(TARGETTYPE)" == "DYNLINK"
!   if !(("$(UMTYPE)"== "nt") || ("$(UMTYPE)"=="ntss"))
!    if ("$(DLLENTRY)" == "/noentry" || "$(DLLENTRY)" == "-noentry")
!     if defined(USE_MSVCRT) || defined(USE_LIBCMT)
DLLENTRY=-entry:_DllMainCRTStartup
!     else
DLLENTRY=-entry:_DllMainCRTStartupForGS
!     endif
!    endif
!    if !defined(USE_MSVCRT) && !defined(USE_LIBCMT)
BO_LIB=$(SDK_LIB_PATH)\BufferOverflowU.lib
!    endif
!   endif
!  else	# TARGETTYPE == PROGRAM/LIBRARY/NOTARGET with special build rules
!   if ("$(UMTYPE)"== "nt") || ("$(UMTYPE)"=="ntss")
!    if defined(NTKERNEL)
BO_LIB=$(SDK_LIB_PATH)\BufferOverflowK.lib
!    else
BO_LIB=$(SDK_LIB_PATH)\BufferOverflow.lib
!    endif
!   else
!    if !defined(USE_MSVCRT) && !defined(USE_LIBCMT)
BO_LIB=$(SDK_LIB_PATH)\BufferOverflowU.lib
!    endif
!   endif
!  endif
! elseif "$(BUFFER_OVERFLOW_CHECKS)" == "NTDLL"
BO_LIB=$(SDK_LIB_PATH)\BufferOverflow.lib
!  if ("$(TARGETTYPE)" == "DYNLINK") && \
      ("$(DLLENTRY)" == "/noentry" || "$(DLLENTRY)" == "-noentry") && \
      ("$(TARGETNAME)" != "ntdll")
DLLENTRY=-entry:_DllMainCRTStartupForGS
!  endif
! endif
!endif  # Overflow checks

!ifndef AMD64_CPU_OPTIMIZATION
AMD64_CPU_OPTIMIZATION=
!endif

!if defined(AMD64_STRUCT_PACKING)
MSC_STRUCT_PACKING=$(AMD64_STRUCT_PACKING)
!elseif !defined(MSC_STRUCT_PACKING)
MSC_STRUCT_PACKING=/Zp8
!endif

#
# Allow the default behavior of WCHAR to be overridden.
#

!ifndef NO_WCHAR_T
COMPILER_WCHAR_T=/Zc:wchar_t-
!else
COMPILER_WCHAR_T=
!endif

#
# Turn off the default behavior of WCHAR if managed code version 1.1 is used.
#

!if "$(URT_VER)" == "1.1" && defined(MANAGED_CXX)
COMPILER_WCHAR_T=
!endif

STDFLAGS= /c $(COMPILER_WCHAR_T) /Zl $(MSC_STRUCT_PACKING) /Gy $(CBSTRING) $(MSC_WARNING_LEVEL) $(MSC_CALL_TYPE) \
          $(ERATTA_FLAGS) $(AMD64_CPU_OPTIMIZATION) $(EH_FLAGS) \
          $(RTTI_FLAGS) $(STRING_POOLING) $(BO_FLAGS)

!if $(FREEBUILD)
ASM_DBG_DEFINES=/DDBG=0
!else
AMD64_ADBGFLAGS=$(AMD64_ADBGFLAGS) /Zi
!endif

# @@BEGIN_DDKSPLIT
!IFDEF NTBBT
# @@END_DDKSPLIT
DBGFLAGS=$(DBGFLAGS) /Zi
AMD64_ADBGFLAGS=$(AMD64_ADBGFLAGS) /Zi
LINKER_FLAGS=$(LINKER_FLAGS) /debug /debugtype:cv,fixup,pdata
# @@BEGIN_DDKSPLIT
!ENDIF
# @@END_DDKSPLIT

!if !defined(USE_PDB_TO_COMPILE) || "$(USE_PDB_TO_COMPILE)" == "0"
DBGFLAGS=$(DBGFLAGS:/Zi=/Z7)
DBGFLAGS=$(DBGFLAGS:-Zi=/Z7)
!else
USER_C_FLAGS=$(USER_C_FLAGS:/Z7=/Zi)
USER_C_FLAGS=$(USER_C_FLAGS:-Z7=/Zi)
! ifndef USE_MSHTML_PDB_RULES
!  if "$(TARGETTYPE)" == "LIBRARY"
DBGFLAGS=$(DBGFLAGS) /Fd$(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).pdb
!  else
DBGFLAGS=$(DBGFLAGS) /Fd$(OBJ_PATH)\$(_OBJ_DIR)\amd64^\
!  endif
! else
!  ifndef TARGETPDB
TARGETPDB=$(TARGETNAME)
!  endif
DBGFLAGS=$(DBGFLAGS) /Fd$(OBJ_PATH)\$(_OBJ_DIR)\amd64\$(TARGETPDB).pdb
! endif
!endif

!ifndef NO_BROWSER_INFO
! ifdef BROWSER_INFO
DBGFLAGS=$(DBGFLAGS) /FR$(OBJ_PATH)\$(_OBJ_DIR)\amd64^\
! endif
!endif

#
# amd64 option control
#

!IF "$(HALTYPE)" == ""
HALDEF=
!ELSE
HALDEF=/D$(HALTYPE)=1
!ENDIF

STD_DEFINES=/D_WIN64 /D_AMD64_ /DAMD64 $(HALDEF) $(MSC_CALL_DEFINE) $(STD_DEFINES)

CDEFINES=$(STD_DEFINES) $(TARGET_DBG_DEFINES) \
              $(LIBC_DEFINES) $(C_DEFINES) $(NET_C_DEFINES) $(MFC_DEFINES)
CFLAGS=$(AMD64_FLAGS) $(NTAMD64FLAGS) $(STDFLAGS) $(DBGFLAGS) $(PERFFLAGS) $(USER_C_FLAGS)
AMD64_ASMFLAGS=$(AMD64_ADBGFLAGS) $(STD_DEFINES) $(ASM_DBG_DEFINES)\
              $(TARGET_DBG_DEFINES) $(ASM_DEFINES)

AMD64_CDEFINES=$(CDEFINES)
AMD64_CFLAGS=$(CFLAGS)

!if defined(SUBSTITUTE_AMD64_CC_MANAGED) && defined(MANAGED_CXX)
CC_NAME=$(SUBSTITUTE_AMD64_CC_MANAGED) 
!elseif defined(SUBSTITUTE_AMD64_CC) && !defined(MANAGED_CXX)
CC_NAME=$(SUBSTITUTE_AMD64_CC) 
!elseif !defined(CC_NAME)
CC_NAME = cl.exe 
!endif

C_COMPILER_NAME     = $(CC_NAME)
CXX_COMPILER_NAME   = $(CC_NAME)
C_PREPROCESSOR_NAME = $(CC_NAME)
!ifndef AMD64_ASSEMBLER_NAME
AMD64_ASSEMBLER_NAME  = ml64.exe
!endif

GLOBAL_C_FLAGS = /Iamd64\ /I. $(INCPATH1) $(CDEFINES) $(CFLAGS)

!if !$(FREEBUILD)
GLOBAL_C_FLAGS = $(GLOBAL_C_FLAGS) /homeparams
!endif

GLOBAL_C_FLAGS=$(CRT_BUILD_FLAGS) $(GLOBAL_C_FLAGS)

NP_COMPILER_FLAGS = $(GLOBAL_C_FLAGS) $(COMPILER_WARNINGS)

CXX_COMPILER_FLAGS_NOPCH = $(NP_COMPILER_FLAGS) $(MSC_CPPFLAGS) $(NTCPPFLAGS) $(MANAGED_CXX_FLAGS)
C_COMPILER_FLAGS_NOPCH = $(NP_COMPILER_FLAGS)
C_COMPILER_FLAGS = $(C_COMPILER_FLAGS_NOPCH) $(PRECOMPILED)
CXX_COMPILER_FLAGS = $(CXX_COMPILER_FLAGS_NOPCH) $(PRECOMPILED_CXX)
C_PREPROCESSOR_FLAGS = $(GLOBAL_C_FLAGS) /EP /Tc

C_PREPROCESSOR = $(C_PREPROCESSOR_NAME) $(C_PREPROCESSOR_FLAGS)
C_ASM_PREPROCESSOR = $(C_PREPROCESSOR_NAME) $(ASM_DEFINES) $(C_PREPROCESSOR_FLAGS)
C_COMPILER     = $(C_COMPILER_NAME) $(C_COMPILER_FLAGS)
NP_C_COMPILER  = $(C_COMPILER_NAME) $(NP_COMPILER_FLAGS)
CXX_COMPILER   = $(CXX_COMPILER_NAME) $(CXX_COMPILER_FLAGS)

AMD64_ASSEMBLER=$(AMD64_ASSEMBLER_NAME) /c /Cx /nologo /Iamd64\ /I. $(INCPATH1) $(AMD64_ASMFLAGS)

ECHO_MSG=$(C_COMPILER) $<
ECHO_MSG_P=$(NP_C_COMPILER) $**
ECHO_CXX_MSG=$(CXX_COMPILER) $<

ECHO_PRECOMPILED_MSG1=$(C_COMPILER_NAME) $(C_COMPILER_FLAGS) /Yl$(TARGETNAME) /Yc$(?F) $(HEADERFILE) \
               $(HEADEROBJ) $(PRECOMPILED_FLAG) $(PRECOMPILED_SOURCEFILE) 

ECHO_PRECOMPILED_MSG2=$(C_COMPILER_NAME) $(C_COMPILER_FLAGS) /Yl$(TARGETNAME) /Yc$(?F) $(HEADERFILE) \
               $(HEADEROBJ) $(PRECOMPILED_FLAG)

{}.c{}.asm:
    $(C_COMPILER_NAME) @<< /Fa $<
$(C_COMPILER_FLAGS: =
)
$(C_COMPILER_FLAGS:##= )
<<NOKEEP

#
# Here is a workaround for a masm code generation bug having to do with
# broken interaction between the preprocessor and the code generator.
#
# The workaround is to generate a preprocessed file first, then assemble
# that.  When the assembler is fixed, delete the following !if-related
# statements and the stuff in the !else block.
#

{..\amd64}.asm{}.pp:
    $(AMD64_ASSEMBLER) /Zs /EP $< > $@

{amd64}.asm{}.pp:
    $(AMD64_ASSEMBLER) /Zs /EP $< > $@

!if 1

{..\amd64}.asm{}.lst:
    $(AMD64_ASSEMBLER) /Fl$@ /Fo$@.obj $<

{amd64}.asm{}.lst:
    $(AMD64_ASSEMBLER) /Fl$@ /Fo$@.obj $<

{..\amd64}.asm{$(_OBJ_DIR)\amd64}.obj:
    $(AMD64_ASSEMBLER) /Fo$@ $<

{amd64}.asm{$(_OBJ_DIR)\amd64}.obj:
    $(AMD64_ASSEMBLER) /Fo$@ $<

{$(_OBJ_DIR)\amd64}.asm{$(_OBJ_DIR)\amd64}.obj:
    $(AMD64_ASSEMBLER) /Fo$@ $<

!else

{..\amd64}.asm{}.lst:
    $(AMD64_ASSEMBLER) /Zs /EP $< > $@.pp
    $(AMD64_ASSEMBLER) /Fl$@ /Fo$@.obj $@.pp
    del $@.pp

{amd64}.asm{}.lst:
    $(AMD64_ASSEMBLER) /Zs /EP $< > $@.pp
    $(AMD64_ASSEMBLER) /Fl$@ /Fo$@.obj $@.pp
    del $@.pp

{..\amd64}.asm{$(_OBJ_DIR)\amd64}.obj:
    $(AMD64_ASSEMBLER) /Zs /EP $< > $@.pp
    $(AMD64_ASSEMBLER) /Fo$@ $@.pp
    del $@.pp

{amd64}.asm{$(_OBJ_DIR)\amd64}.obj:
    $(AMD64_ASSEMBLER) /Zs /EP $< > $@.pp
    $(AMD64_ASSEMBLER) /Fo$@ $@.pp
    del $@.pp

{$(_OBJ_DIR)\amd64}.asm{$(_OBJ_DIR)\amd64}.obj:
    $(AMD64_ASSEMBLER) /Zs /EP $< > $@.pp
    $(AMD64_ASSEMBLER) /Fo$@ $@.pp
    del $@.pp

!endif

!if 1

{..\amd64}.asm{}.lst:
    $(AMD64_ASSEMBLER) /Fl$@ /Fo$@.obj $<

{amd64}.asm{}.lst:
    $(AMD64_ASSEMBLER) /Fl$@ /Fo$@.obj $<

{..\amd64}.asm{$(OBJ_PATH)\$(_OBJ_DIR)\amd64}.obj:
    $(AMD64_ASSEMBLER) /Fo$@ $<

{amd64}.asm{$(OBJ_PATH)\$(_OBJ_DIR)\amd64}.obj:
    $(AMD64_ASSEMBLER) /Fo$@ $<

{$(OBJ_PATH)\$(_OBJ_DIR)\amd64}.asm{$(OBJ_PATH)\$(_OBJ_DIR)\amd64}.obj:
    $(AMD64_ASSEMBLER) /Fo$@ $<

!else

{..\amd64}.asm{}.lst:
    $(AMD64_ASSEMBLER) /Zs /EP $< > $@.pp
    $(AMD64_ASSEMBLER) /Fl$@ $@.pp
    del $@.pp

{amd64}.asm{}.lst:
    $(AMD64_ASSEMBLER) /Zs /EP $< > $@.pp
    $(AMD64_ASSEMBLER) /Fl$@ $@.pp
    del $@.pp

{..\amd64}.asm{$(OBJ_PATH)\$(_OBJ_DIR)\amd64}.obj:
    $(AMD64_ASSEMBLER) /Zs /EP $< > $@.pp
    $(AMD64_ASSEMBLER) /Fo$@ $@.pp
    del $@.pp

{amd64}.asm{$(OBJ_PATH)\$(_OBJ_DIR)\amd64}.obj:
    $(AMD64_ASSEMBLER) /Zs /EP $< > $@.pp
    $(AMD64_ASSEMBLER) /Fo$@ $@.pp
    del $@.pp

{$(OBJ_PATH)\$(_OBJ_DIR)\amd64}.asm{$(OBJ_PATH)\$(_OBJ_DIR)\amd64}.obj:
    $(AMD64_ASSEMBLER) /Zs /EP $< > $@.pp
    $(AMD64_ASSEMBLER) /Fo$@ $@.pp
    del $@.pp

!endif

!IF "$(NTDEBUGTYPE)" == "windbg" || "$(NTDEBUGTYPE)" == "both"
NTKERNEL_LINK_OPTIONS=/entry:KiSystemStartup
!ELSE
NTKERNEL_LINK_OPTIONS=/base:0x80100000 /entry:KiSystemStartup
!ENDIF

!if ! ("$(COMPILER_VERSION)" >= "VS9")
LINKER_FLAGS=$(LINKER_FLAGS) /opt:nowin98
!endif

LINKER_FLAGS=$(LINKER_FLAGS) /functionpadmin:6

DRIVER_ALIGNMENT=0x0080
KERNEL_ALIGNMENT=0x1000

# NXCOMPAT support for binaries built with an older compiler (is on by default as of VS10)
!if "$(TARGETTYPE)" != "DRIVER"         && \
    "$(TARGETTYPE)" != "DRIVER_LIBRARY" && \
    "$(TARGETTYPE)" != "EXPORT_DRIVER"  && \
    "$(TARGETTYPE)" != "HAL"            && \
    "$(TARGETTYPE)" != "GDI_DRIVER"     && \
    "$(TARGETTYPE)" != "MINIPORT"
! if $(_NT_TOOLS_VERSION) >= 0x800 && \
     (!defined(NTKERNEL)) && \
     ("$(UMTYPE)" != "posix")
!  ifdef NO_NXCOMPAT
LINKER_FLAGS=$(LINKER_FLAGS) /nxcompat:no
!  else
LINKER_FLAGS=$(LINKER_FLAGS) /nxcompat
!  endif
! endif
!endif

# SEH support for libs built with an older compiler
# @@BEGIN_DDKSPLIT
!if 0
# @@END_DDKSPLIT
!ifdef _NT_TARGET_VERSION
!    if $(_NT_TARGET_VERSION) < 0x600 && $(_NT_TOOLS_VERSION) >= 0x700
TARGETLIBS=$(TARGETLIBS) $(DDK_LIB_PATH)\sehupd.lib
!    endif
!endif
# @@BEGIN_DDKSPLIT
!endif
# @@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\SQLAgent\code\Properties\AssemblyInfo.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="AssemblyInfo.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   assembly info
// </summary>
//-----------------------------------------------------------------------
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("SQLAgent")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("SQLAgent")]
[assembly: AssemblyCopyright("Copyright (c) Microsoft Corporation.  All rights reserved.")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("c0bbce97-e760-49d2-a075-dbe3cdd8c77a")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("4.3.0.0")]
[assembly: AssemblyFileVersion("4.3.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\tools\ia64mk.inc ===
!IF 0

Copyright (c) Microsoft Corporation

Module Name:

    ia64mk.inc

Abstract:

        This module contains the ia64 specific build controls.  It is included
        by makefile.def.

        Add the following variable to your env.

        1) To turn on IA64 hazard detection:

                    set _IA64_HAZARD_DETECTION=-X explicit

        2) To turn on Merced MSR access, add the following variable to your env.

                    set _IA64_MERCED_MSR =-A MERCED

Revision History:

!ENDIF

#
# ia64 option control
#

UMBASE=$(UMBASE:*=ia64)
UMLIBS=$(UMLIBS:*=ia64)
NTRES=$(NTRES:*=ia64)
UMRES=$(UMRES:*=ia64)
UMOBJS=$(UMOBJS:*=ia64)
CRTLIBS=$(CRTLIBS:*=ia64)
LINKLIBS=$(LINKLIBS:*=ia64)
GDI_DRIVER_LIBS=$(GDI_DRIVER_LIBS:*=ia64)
DLLBASE=$(DLLBASE:*=ia64)
DLLDEF=$(DLLDEF:*=ia64)
MACHINE_TARGETLIBS=$(MACHINE_TARGETLIBS:*=ia64)
TARGET=$(TARGET:*=ia64)
DYNLINK_LIB=$(DYNLINK_LIB:*=ia64)
TARGETEXEFILES=$(TARGETEXEFILES:*=ia64)
TARGETLIBFILES=$(TARGETLIBFILES:*=ia64)
TARGETOBJFILES=$(TARGETOBJFILES:*=ia64)
UMOBJFILES=$(UMOBJFILES:*=ia64)
UMEXEFILES=$(UMEXEFILES:*=ia64)
HEADERFILE=$(HEADERFILE:*=ia64)
HEADEROBJNAME=$(HEADEROBJNAME:*=ia64)
HEADEROBJ=$(HEADEROBJ:*=ia64)
PRECOMPILED=$(PRECOMPILED:*=ia64)
PRECOMPILED_CXX=$(PRECOMPILED_CXX:*=ia64)
PRECOMPILED_TARGET=$(PRECOMPILED_TARGET:*=ia64)
MFC_STATIC_LIB=$(MFC_STATIC_LIB:*=ia64)
CRT_LIB_PATH=$(CRT_LIB_PATH:*=ia64)
SDK_LIB_PATH=$(SDK_LIB_PATH:*=ia64)
DDK_LIB_PATH=$(DDK_LIB_PATH:*=ia64)
IFSKIT_LIB_PATH=$(IFSKIT_LIB_PATH:*=ia64)
HALKIT_LIB_PATH=$(HALKIT_LIB_PATH:*=ia64)
ORDER=$(ORDER:*=ia64)
OBJLIBFILES=$(OBJLIBFILES:*=ia64)
MISCFILES=$(MISCFILES) $(IA64_MISCFILES)
!if defined(IA64_DRIVER_INFS)
DRIVER_INFS=$(DRIVER_INFS) $(IA64_DRIVER_INFS)
!endif
!if defined(IA64_PRINTER_INFS)
PRINTER_INFS=$(PRINTER_INFS) $(IA64_PRINTER_INFS)
!endif
!if defined(IA64_NON_PNP_INFS)
NON_PNP_INFS=$(NON_PNP_INFS) $(IA64_NON_PNP_INFS)
!endif
!if defined(IA64_NON_PNP_SIGN_INFS)
NON_PNP_SIGN_INFS=$(NON_PNP_SIGN_INFS) $(IA64_NON_PNP_SIGN_INFS)
!endif
!if defined(IA64_LOC_DRIVER_INFS)
LOC_DRIVER_INFS=$(LOC_DRIVER_INFS) $(IA64_LOC_DRIVER_INFS)
!endif
!if defined(IA64_LOC_PRINTER_INFS)
LOC_PRINTER_INFS=$(LOC_PRINTER_INFS) $(IA64_LOC_PRINTER_INFS)
!endif
!if defined(IA64_LOC_NON_PNP_INFS)
LOC_NON_PNP_INFS=$(LOC_NON_PNP_INFS) $(IA64_LOC_NON_PNP_INFS)
!endif
!if defined(IA64_LOC_NON_PNP_SIGN_INFS)
LOC_NON_PNP_SIGN_INFS=$(LOC_NON_PNP_SIGN_INFS) $(IA64_LOC_NON_PNP_SIGN_INFS)
!endif
SOURCES=$(SOURCES) $(IA64_SOURCES)
# BINPLACE_FLAGS=$(BINPLACE_FLAGS) /CI 8,halo.exe,/certain,/errata,/quiet

!ifdef NTTARGETFILES
NTTARGETFILES=$(NTTARGETFILES:*=ia64)
!endif
!ifdef NTTARGETFILE0
NTTARGETFILE0=$(NTTARGETFILE0:*=ia64)
!endif
!ifdef NTTARGETFILE1
NTTARGETFILE1=$(NTTARGETFILE1:*=ia64)
!endif

!ifdef PROJECT_LIB_PATH
PROJECT_LIB_PATH=$(PROJECT_LIB_PATH:*=ia64)
!endif

ENTRY_SUFFIX=
GDI_ENTRY_SUFFIX=

DEFAULT_STACKRESERVE=0x100000
DEFAULT_STACKCOMMIT=0x4000

!ifndef _IA64_HAZARD_DETECTION
_IA64_HAZARD_DETECTION=-X explicit
!endif

!ifndef _IA64_MERCED_MSR
_IA64_MERCED_MSR=-A itanium
!endif

!ifndef GENIA64
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /Wp64
!endif

!ifdef IA64_WARNING_LEVEL
MSC_WARNING_LEVEL=$(IA64_WARNING_LEVEL)
!ENDIF

MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) $(COMPILER_WX_SWITCH)

!ifdef IA64_PERFFLAGS
PERFFLAGS = $(IA64_PERFFLAGS)
!endif

# Set MSC_OPTIMIZATION.
# Order of precedence:
#   Platform specific override
#   Environment variable
#   System Default

!ifdef IA64_OPTIMIZATION
MSC_OPTIMIZATION=$(IA64_OPTIMIZATION)
!elseif !defined(MSC_OPTIMIZATION)
MSC_OPTIMIZATION=$(DEFAULT_MSC_OPT)
!endif

LINK_TIME_CODE_GENERATION_MSC_FLAG=

!ifndef GENIA64
!ifdef IA64_DEBUGGABLE_OPTIMIZATION
MSC_OPTIMIZATION=$(MSC_OPTIMIZATION) /Zx
!endif
!ifndef IA64_FULL_FLOATING_POINT
MSC_OPTIMIZATION=$(MSC_OPTIMIZATION) /QIPF_fr32
!endif
!if defined(LINK_TIME_CODE_GENERATION) && !defined(FORCENATIVEOBJECT)
# Some objects must be built native, so turn off GL for those
LINK_TIME_CODE_GENERATION_MSC_FLAG=/GL
!endif
!if !defined(MANAGED_CXX)
MSC_OPTIMIZATION=$(MSC_OPTIMIZATION) /QIPF_noPIC
!endif
!endif

DBGFLAGS=$(DBGFLAGS) $(MSC_OPTIMIZATION) $(LINK_TIME_CODE_GENERATION_MSC_FLAG)
IA64_ADBGFLAGS=$(IA64_ADBGFLAGS) /d debug

!ifdef IA64_CPPFLAGS
MSC_CPPFLAGS=$(IA64_CPPFLAGS)
!elseif defined(386_CPPFLAGS)
MSC_CPPFLAGS=$(386_CPPFLAGS)
!ENDIF

!ifdef NO_STRING_POOLING
STRING_POOLING =
!else
!ifdef NO_READONLY_STRINGS
STRING_POOLING = /Gf
!else
STRING_POOLING = /GF
!endif
!endif

!ifdef USE_NATIVE_EH
!if "$(USE_NATIVE_EH)" == "ASYNC"
EH_FLAGS=/EHa
!else
!if "$(USE_NATIVE_EH)" == "CTHROW"
EH_FLAGS=/EHsc-
!else
EH_FLAGS=/EHsc
!endif
!endif
!else
EH_FLAGS=/EHs-c-
!endif

!if defined(USE_RTTI) || defined(MANAGED_CXX)
RTTI_FLAGS=/GR
! else
RTTI_FLAGS=/GR-
! endif

# On by default
!if "$(BUFFER_OVERFLOW_CHECKS)" == ""
BUFFER_OVERFLOW_CHECKS=1
!endif

# Turn off for the select few
!if ("$(DRIVERTYPE)" == "VXD") || \
    (("$(TARGETTYPE)" == "MINIPORT") && ($(_NT_TARGET_VERSION) < 0x502)) || \
    (("$(TARGETTYPE)" == "DYNLINK") && defined(RESOURCE_ONLY_DLL)) || \
    "$(BUFFER_OVERFLOW_CHECKS)" == "0"
!undef BUFFER_OVERFLOW_CHECKS
!endif

!if defined(BUFFER_OVERFLOW_CHECKS)
# verify it's one of the chosen few - 1, NTDLL or compile only - all others are wrong.
! if "$(BUFFER_OVERFLOW_CHECKS)" != "1" && \
     "$(BUFFER_OVERFLOW_CHECKS)" != "NTDLL" && \
     "$(BUFFER_OVERFLOW_CHECKS)" != "COMPILE_ONLY" && \
     "$(BUFFER_OVERFLOW_CHECKS)" != "LINK_ONLY"
!message BUILDMSG: Error: INVALID BUFFER_OVERFLOW_CHECKS value "$(BUFFER_OVERFLOW_CHECKS)" in $(MAKEDIR)
! endif
! if "$(BUFFER_OVERFLOW_CHECKS)" == "LINK_ONLY"
BO_FLAGS=/GS-
BUFFER_OVERFLOW_CHECKS=1
! else
BO_FLAGS=/GS
! endif
! if "$(BUFFER_OVERFLOW_CHECKS)" == "1"
!  if "$(TARGETTYPE)" == "DRIVER" || \
      "$(TARGETTYPE)" == "EXPORT_DRIVER" || \
      "$(TARGETTYPE)" == "DRIVER_LIBRARY" || \
      "$(TARGETTYPE)" == "MINIPORT" 
BO_LIB=$(SDK_LIB_PATH)\BufferOverflowK.lib
DRIVER_ENTRY=GsDriverEntry
!  elseif "$(TARGETTYPE)" == "GDI_DRIVER"
BO_LIB=$(SDK_LIB_PATH)\BufferOverflowGDI.lib
GDI_DRIVER_ENTRY=GsDrvEnableDriver
!  elseif "$(TARGETTYPE)" == "DYNLINK"
!   if !(("$(UMTYPE)"== "nt") || ("$(UMTYPE)"=="ntss"))
!    if ("$(DLLENTRY)" == "/noentry" || "$(DLLENTRY)" == "-noentry")
!     if defined(USE_MSVCRT) || defined(USE_LIBCMT)
DLLENTRY=-entry:_DllMainCRTStartup
!     else
DLLENTRY=-entry:_DllMainCRTStartupForGS
!     endif
!    endif
!    if !defined(USE_MSVCRT) && !defined(USE_LIBCMT)
BO_LIB=$(SDK_LIB_PATH)\BufferOverflowU.lib
!    endif
!   endif
!  else	# TARGETTYPE == PROGRAM/LIBRARY/NOTARGET with special build rules
!   if ("$(UMTYPE)"== "nt") || ("$(UMTYPE)"=="ntss")
!    if defined(NTKERNEL)
BO_LIB=$(SDK_LIB_PATH)\BufferOverflowK.lib
!    else
BO_LIB=$(SDK_LIB_PATH)\BufferOverflow.lib
!    endif
!   else
!    if !defined(USE_MSVCRT) && !defined(USE_LIBCMT)
BO_LIB=$(SDK_LIB_PATH)\BufferOverflowU.lib
!    endif
!   endif
!  endif
! elseif "$(BUFFER_OVERFLOW_CHECKS)" == "NTDLL"
BO_LIB=$(SDK_LIB_PATH)\BufferOverflow.lib
!  if ("$(TARGETTYPE)" == "DYNLINK") && \
      ("$(DLLENTRY)" == "/noentry" || "$(DLLENTRY)" == "-noentry") && \
      ("$(TARGETNAME)" != "ntdll")
DLLENTRY=-entry:_DllMainCRTStartupForGS
!  endif
! endif
!endif  # Overflow checks


ERRATA_FLAGS=

!if defined(IA64_STRUCT_PACKING)
MSC_ST