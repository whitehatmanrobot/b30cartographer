
            }
        }

        static bool overwriteDMPSettings = false; // not really thread-safe. but this class is only used in single-threaded LiveOffer utility

        /// <summary>
        /// The Target DataStore
        /// </summary>
        public static bool OverwriteDMPSettings
        {
            get
            {
                return overwriteDMPSettings;
            }
            set
            {
                overwriteDMPSettings = value;
            }
        }

        static bool useTransaction = true;

        /// <summary>
        /// The Target DataStore
        /// </summary>
        public static bool UseTransaction
        {
            get
            {
                return useTransaction;
            }
            set
            {
                useTransaction = value;
            }
        }


        // this arrayList stores the local names of images that were propped to Live
        static ArrayList imageFilePaths = null;

        public static string[] ImageFilePaths
        {
            get
            {
                string[] iFPs = new string[imageFilePaths.Count];
                imageFilePaths.CopyTo(iFPs);
                return iFPs;
            }
        }

        // this Hashtable stores what server paths images have been written to
        static Hashtable imageServerPaths = null;

        public static byte[] HexStringToByteArray(string s)
        {
            s = s.Trim().ToUpper();

            if (s[0] == '0' && s[1] == 'X')
                s = s.Substring(2);

            int numBytes = s.Length / 2;
            byte[] bytes = new byte[numBytes];

            for (int j = 0; j < numBytes; j++)
            {
                bytes[j] = Byte.Parse(s.Substring(j * 2, 2), NumberStyles.HexNumber);
            }

            return bytes;
        }

        public static string ByteArrayToHexString(byte[] bytes)
        {
            StringBuilder sb = new StringBuilder(bytes.Length * 2 + 1);

            for (int i = 0; i < bytes.Length; i++)
            {
                sb.Append(bytes[i].ToString("x2"));
            }

            return sb.ToString();
        }

        public static ulong ParseUlong(string s)
        {
            s = s.Trim().ToUpper();

            ulong u;

            if (s[0] == '0' && s[1] == 'X')
                u = UInt64.Parse(s.Substring(2), NumberStyles.HexNumber);
            else
            {
                try
                {
                    u = (ulong)Int64.Parse(s);
                }
                catch (FormatException)
                {
                    u = UInt64.Parse(s, NumberStyles.HexNumber);
                }
            }

            return u;
        }

        public static uint ParseUint(string s)
        {
            s = s.Trim().ToUpper();

            uint i;

            if (s[0] == '0' && s[1] == 'X')
                i = UInt32.Parse(s.Substring(2), NumberStyles.HexNumber);
            else
            {
                try
                {
                    i = (uint)Int32.Parse(s);
                }
                catch (FormatException)
                {
                    i = UInt32.Parse(s, NumberStyles.HexNumber);
                }
            }

            return i;
        }

        static uint[] ParseUints(ArrayList value)
        {
            var result = new uint[value.Count];
            for (int i = 0; i < value.Count; i++)
            {
                result[i] = ParseUint((string)value[i]);
            }
            return result;
        }

        public static int MapConsoleType(ConsoleType consoleType)
        {
            switch (consoleType)
            {
                case ConsoleType.Xbox360:
                    return (int)ConsoleTypeEnum.Xenon;
                case ConsoleType.PC:
                    return (int)ConsoleTypeEnum.PC;
            }

            throw new Exception("invalid content offerType: " + consoleType);
        }

        public static int MapRelationType(OfferRelationType relationType)
        {
            switch (relationType)
            {
                case OfferRelationType.Renewal:
                    return (int)OfferingRelationTypeEnum.Renewal;

                case OfferRelationType.Trial:
                    return (int)OfferingRelationTypeEnum.Trial;

                case OfferRelationType.Xbox1XenonSubstitution:
                    return (int)OfferingRelationTypeEnum.Xbox1ToXenon;
            }

            throw new Exception("invalid relation type: " + relationType);
        }

        public static int MapConvertMode(OfferConvertMode convertMode)
        {
            switch (convertMode)
            {
                case OfferConvertMode.Convert:
                    return (int)OfferingConvertMode.Convert;

                case OfferConvertMode.Renew:
                    return (int)OfferingConvertMode.Renew;
            }

            throw new Exception("invalid convert mode: " + convertMode);
        }

        public static int MapLiveTier(LiveTier liveTier)
        {
            switch (liveTier)
            {
                case LiveTier.NewUser:
                    return (int)TierEnum.NewUser;

                case LiveTier.Silver:
                    return (int)TierEnum.Silver;

                case LiveTier.Gold:
                    return (int)TierEnum.Gold;

                case LiveTier.FamilyGold:
                    return (int)TierEnum.FamilyGold;
            }

            throw new Exception("invalid live tier: " + liveTier);
        }

        public static int MapGenre(Genre genre)
        {
            switch (genre)
            {
                case Genre.Action:
                    return 102000000;

                case Genre.Adventure:
                    return 103000000;

                case Genre.Compilations:
                    return 104000000;

                case Genre.Family:
                    return 105000000;

                case Genre.Fighting:
                    return 106000000;

                case Genre.Music:
                    return 108000000;

                case Genre.Platform:
                    return 109000000;

                case Genre.Racing:
                    return 110000000;

                case Genre.RolePlaying:
                    return 111000000;

                case Genre.Shooter:
                    return 112000000;

                case Genre.Simulation:
                    return 113000000;

                case Genre.Sports:
                    return 114000000;

                case Genre.Strategy:
                    return 115000000;

                case Genre.XArcadeAction:
                    return 116010000;

                case Genre.XArcadeCardAndBoard:
                    return 116020000;

                case Genre.XArcadeCoinOpClassics:
                    return 116030000;

                case Genre.XArcadePuzzleAndWord:
                    return 116040000;

                case Genre.XArcadeSocialSports:
                    return 116050000;

                case Genre.XArcadeStrategyAndSims:
                    return 116060000;

                case Genre.XArcadeConsoleClassics:
                    return 116070000;

                case Genre.XArcadeGameShows:
                    return 116080000;

                case Genre.XArcadeFamilyGames:
                    return 116090000;

                case Genre.XArcadeTrivia:
                    return 116100000;
            }

            throw new Exception("invalid genre: " + genre);
        }

        public static byte MapSubscriptionFrequency(SubscriptionFrequency frequency)
        {
            switch (frequency)
            {
                case SubscriptionFrequency.OneTimeCharge:
                    return (byte)OfferingFrequencyEnum.OneTimeCharge;

                case SubscriptionFrequency.Monthly:
                    return (byte)OfferingFrequencyEnum.Monthly;

                case SubscriptionFrequency.Quarterly:
                    return (byte)OfferingFrequencyEnum.Quarterly;

                case SubscriptionFrequency.BiAnnually:
                    return (byte)OfferingFrequencyEnum.BiAnnually;

                case SubscriptionFrequency.Annually:
                    return (byte)OfferingFrequencyEnum.Annually;
            }

            throw new Exception("invalid subscriptionFrequency: " + frequency);
        }

        public static byte MapTaxType(TaxType taxType)
        {
            switch (taxType)
            {
                case TaxType.NoTax:
                    return (byte)TaxTypeEnum.NoTax;

                case TaxType.DefaultTax:
                    return (byte)TaxTypeEnum.Default;

                case TaxType.GST:
                    return (byte)TaxTypeEnum.GST;

                case TaxType.VAT:
                    return (byte)TaxTypeEnum.VAT;

                case TaxType.TaxNotApplicable:
                    return (byte)TaxTypeEnum.TaxNotApplicable;
            }

            throw new Exception("invalid taxType: " + taxType);
        }

        public static bool VetOfferRegionCultures(ulong offerID, OfferRegionInfoCollection oric, OfferCultureDetailsCollection ocdc)
        {
            bool bFound = false, bRet = true;

            // Ensure that we have all Cultures for each Region's Country
            foreach (OfferRegionInfo info in oric)
            {
                ArrayList regionCultures = Culture.GetRegionCultures(info.countryID);

                // Make sure we have all needed OfferCultureDetailsCollection objects
                foreach (CultureData c in regionCultures)
                {
                    bFound = false;
                    foreach (OfferCultureDetails detail in ocdc)
                    {
                        if ((int)detail.culture == c.CultureID)
                        {
                            bFound = true;
                        }
                    }

                    if (!bFound)
                    {
                        bRet = false;
                        throw new Exception("invalid Culture Collection in OfferID: " + offerID.ToString("X") + " - missing CultureID: " + c.CultureID + " for CountryID: " + c.CountryID);
                    }
                }
            }

            return bRet;
        }

        static void PropOfferCultureDetailsCollection(OfferCultureDetailsCollection c, ulong offerID, uint[] titleIDs)
        {
            foreach (OfferCultureDetails details in c)
            {
                int culture = (int)details.culture;
                string name = details.name;
                string sellText = details.sellText;

                p_svc_insert_offer_culture_details(offerID, culture, name, sellText);

                string localFileName = details.imageFilePath;

                foreach (uint titleID in titleIDs)
                {
                    WriteFileToStorage(details.imageFilePath, offerID, titleID);
                }
            }
        }


        public static void PropOfferRegionInfoCollection(OfferRegionInfoCollection c, ulong offerID,
            bool autoXboxToken)
        {
            bool hasSCSPaymentTypes = false; // PS# 117737 - LiveOffer must support propping SCS data (campaignID) for content offers

            PropOfferRegionInfoCollection(c, offerID, autoXboxToken, true, out hasSCSPaymentTypes);
        }
        public static void PropOfferRegionInfoCollection(OfferRegionInfoCollection c, ulong offerID,
            bool autoXboxToken, bool allowWholesalePaymentTypes, out bool hasSCSPaymentTypes)
        {
            hasSCSPaymentTypes = false; // reset

            foreach (OfferRegionInfo region in c)
            {
                byte countryID = region.countryID;
                int tierRequired = MapLiveTier(region.liveTier);
                DateTime startDate = region.startDate;
                DateTime endDate = region.endDate;

                int paymentType;
                string boid;
                int priceWhole;
                int priceFractional;
                uint specificOfferDetails;

                if (region.__paymentTypePoints != null)
                {
                    paymentType = (int)PaymentTypeEnum.Points;
                    boid = (region.paymentTypePoints.boid == null) ? string.Empty : region.paymentTypePoints.boid;
                    priceWhole = (int)region.paymentTypePoints.priceInPoints;
                    priceFractional = 0;
                    specificOfferDetails = 0;

                    p_svc_insert_offer_regions_xenon(offerID, countryID, tierRequired, paymentType, startDate,
                        endDate, boid, priceWhole, priceFractional, specificOfferDetails);
                }

                // Fix for Bug 39226 - Offergap/LiveOffer must always set tokens to be allowed for offers
                if (region.paymentTypeXboxToken || autoXboxToken)
                {
                    paymentType = (int)PaymentTypeEnum.Token;
                    boid = string.Empty;
                    priceWhole = 0;
                    priceFractional = 0;
                    specificOfferDetails = 0;

                    p_svc_insert_offer_regions_xenon(offerID, countryID, tierRequired, paymentType, startDate,
                        endDate, boid, priceWhole, priceFractional, specificOfferDetails);
                }

                if (region.__paymentTypeSCG != null)
                {
                    ValidateBoidValue(region.paymentTypeSCG.boid, "paymentTypeSCG");
                    hasSCSPaymentTypes = true;
                    paymentType = (int)PaymentTypeEnum.CreditCard;
                    boid = (region.paymentTypeSCG.boid == null) ? string.Empty : region.paymentTypeSCG.boid;
                    priceWhole = (int)region.paymentTypeSCG.priceWhole;
                    priceFractional = (int)region.paymentTypeSCG.priceFractional;

                    byte taxType = MapTaxType(region.paymentTypeSCG.taxType);
                    specificOfferDetails = Details.BuildSpecificOfferDetails(taxType, false);

                    p_svc_insert_offer_regions_xenon(offerID, countryID, tierRequired, paymentType, startDate,
                        endDate, boid, priceWhole, priceFractional, specificOfferDetails);
                }

                if (region.__paymentTypeSCGToken != null)
                {
                    ValidateBoidValue(region.paymentTypeSCGToken.boid, "paymentTypeSCGToken");
                    hasSCSPaymentTypes = true;
                    paymentType = (int)PaymentTypeEnum.Token;
                    boid = (region.paymentTypeSCGToken.boid == null) ? string.Empty : region.paymentTypeSCGToken.boid;
                    priceWhole = 0;
                    priceFractional = 0;
                    specificOfferDetails = 0;

                    p_svc_insert_offer_regions_xenon(offerID, countryID, tierRequired, paymentType, startDate,
                        endDate, boid, priceWhole, priceFractional, specificOfferDetails);
                }

                if (region.__paymentTypeWholesaleCollection != null &&
                    region.__paymentTypeWholesaleCollection.Count > 0)
                {
                    if (!allowWholesalePaymentTypes)
                    {
                        throw new ArgumentException("Wholesale PaymentType not allowed for this Offer-Type.");
                    }

                    Dictionary<string, bool> _wholesalePaymentProvider = new Dictionary<string, bool>();
                    foreach (PaymentTypeWholesale paymentTypeWholesale in region.__paymentTypeWholesaleCollection)
                    {
                        string partnerName = paymentTypeWholesale.wholesalePartner;
                        if (_wholesalePaymentProvider.ContainsKey(partnerName.ToLower()))
                        {
                            throw new Exception("A duplicate wholesale payment type was found for wholesale provider " + partnerName + ".");
                        }
                        _wholesalePaymentProvider.Add(partnerName.ToLower(), true);


                        // Force that only CHINATELCOM Wireline is supported.  Later, when more providers 
                        // are added, this line will most likely turn into a database query.
                        if (partnerName.ToLower() != "CHINATELCOM Wireline".ToLower())
                        {
                            throw new Exception("Ignoring unknown wholesale payment type partner \"" + paymentTypeWholesale.wholesalePartner + "\".");
                        }
                        ValidateBoidValue(paymentTypeWholesale.boid, "paymentTypeWholesale");
                        paymentType = (int)PaymentTypeEnum.Wholesale;
                        boid = (paymentTypeWholesale.boid == null) ? string.Empty : paymentTypeWholesale.boid;
                        priceWhole = (int)paymentTypeWholesale.priceWhole;
                        priceFractional = (int)paymentTypeWholesale.priceFractional;
                        specificOfferDetails = 0;

                        p_svc_insert_offer_regions_xenon(offerID, countryID, tierRequired, paymentType, startDate,
                            endDate, boid, priceWhole, priceFractional, specificOfferDetails);
                    }
                }
            }
        }


        /// <summary>
        /// Create a mapping to the appropriate subscription family from offer instances. The offer 
        /// instances are calculated from the offerId, payment type, and country in each OfferRegionInfo
        /// passed in. The calculated offerInstanceId is the 'smart' GUID for the offerInstance in CatalogDB
        /// </summary>
        /// <param name="c">The collection of OfferRegionInfo for the offer being configured. </param>
        /// <param name="offerID">The ulong offer id in UODB.</param>
        public static void PropOfferInstanceFamilyMappingCollection(OfferRegionInfoCollection c, ulong offerID, bool autoXboxToken)
        {
            foreach (OfferRegionInfo region in c)
            {
                //Get the payment type specified for the offer - default to 'Invalid'
                int paymentType = 0;

                if (region.__paymentTypePoints != null)
                {
                    paymentType = (int)PaymentTypeEnum.Points;
                }
                else if (region.paymentTypeXboxToken || autoXboxToken)
                {
                    // Fix for Bug 39226 - Offergap/LiveOffer must always set tokens to be allowed for offer
                    paymentType = (int)PaymentTypeEnum.Token;
                }
                else if (region.__paymentTypeSCG != null)
                {
                    paymentType = (int)PaymentTypeEnum.CreditCard;
                }
                else if (region.__paymentTypeSCGToken != null)
                {
                    paymentType = (int)PaymentTypeEnum.Token;
                }

                //Do not create an offerInstance => family mapping when the only payment type specified is 'Wholesale'
                if (!(paymentType == 0
                        && region.__paymentTypeWholesaleCollection != null
                        && region.__paymentTypeWholesaleCollection.Count > 0))
                {
                    p_svc_insert_offer_instance_family_mappings(offerID, region.countryID, paymentType);
                }
            }
        }


        /// <summary>
        /// Validates boid value and throws an exception if it is not a guid.
        /// </summary>
        /// <param name="value">value of the string to validate</param>
        /// <param name="section">section name</param>
        /// <exception cref="ArgumentException"></exception>
        static void ValidateBoidValue(string value, string section)
        {
            if (!string.IsNullOrEmpty(value))
            {
                if (!OfferUtil.IsGUID(value))
                {
                    throw new ArgumentException(string.Format("Billing Offer Id {0} within {1} must either be an emptystring/Guid", value, section));
                }
            }
        }
        public static void PropOfferPrivilegeInfo(OfferPrivilegeInfo opi, ulong offerID)
        {
            if (opi.offerPrivilegeGrantCollection.Count > 0)
            {
                OfferPrivilegeGrants grants = new OfferPrivilegeGrants();
                foreach (uint p in opi.offerPrivilegeGrantCollection) grants[(int)p] = true;
                grants.Save(offerID);
            }

            if (opi.offerPrivilegeRestrictionCollection.Count > 0)
            {
                OfferPrivilegeRestrictions restrictions = new OfferPrivilegeRestrictions();
                foreach (uint p in opi.offerPrivilegeRestrictionCollection) restrictions[(int)p] = true;
                restrictions.Save(offerID);
            }
        }

        public static void PropOfferBasicInfo(OfferBasicInfo info, int offerType, uint policyFlags,
            uint licenseBits, byte[] contentID, ulong previewOfferID, bool autoXboxToken)
        {
            bool hasSCSPaymentTypes = false; // PS# 117737 - LiveOffer must support propping SCS data (campaignID) for content offers

            PropOfferBasicInfo(info, offerType, policyFlags, licenseBits, contentID, previewOfferID,
                                autoXboxToken, true, out hasSCSPaymentTypes);
        }

        public static void PropOfferBasicInfo(OfferBasicInfo info, int offerType, uint policyFlags,
            uint licenseBits, byte[] contentID, ulong previewOfferID, bool autoXboxToken,
            bool allowWholesalePaymentTypes, out bool hasSCSPaymentTypes)
        {
            uint titleID = ParseUint(info.primaryTitleID);
            ulong offerID = ParseUlong(info.offerID);
            uint bitFilter = ParseUint(info.bitFilter);

            string friendlyName = info.friendlyName;
            ConsoleTypeEnum consoleType = (ConsoleTypeEnum)MapConsoleType(info.consoleType);

            if (consoleType == ConsoleTypeEnum.PC &&
               info.offerEnumerationType != OfferEnumerationType.NeverEnumerate
              )
            {
                // PC Arcade offers must have their offerEnumerationType set to NeverEnumerate for UODB
                policyFlags |= Offer.DO_NOT_ENUMERATE;
            }
            else
            {
                switch (info.offerEnumerationType)
                {
                    case OfferEnumerationType.AlwaysEnumerateExceptInPartnerNetDash:
                        policyFlags |= Offer.HIDE_FROM_PARTNERNET_DASH;
                        break;

                    case OfferEnumerationType.NeverEnumerate:
                        policyFlags |= Offer.DO_NOT_ENUMERATE;
                        break;

                    case OfferEnumerationType.AlwaysEnumerate:
                        // no flags are set
                        break;
                }
            }

            if (info.__requiresGeofencingSpecified == true && info.requiresGeofencing == true)
                policyFlags |= Offer.REQUIRES_GEOFENCING;

            p_svc_insert_offers(titleID, offerID, bitFilter, offerType, friendlyName, consoleType, policyFlags,
                licenseBits, contentID, previewOfferID);

            foreach (string s in info.associatedTitleIDCollection)
            {
                uint associatedTitleID = ParseUint(s);
                p_svc_insert_title_associated_offer(associatedTitleID, offerID);
            }

            VetOfferRegionCultures(offerID, info.offerRegionInfoCollection, info.offerCultureDetailsCollection);

            PropOfferCultureDetailsCollection(info.offerCultureDetailsCollection, offerID, new[] { titleID });

            // Since regions contain billing info, clean out existing before insert new...
            p_svc_delete_offer_regions_xbox((long)offerID);

            PropOfferRegionInfoCollection(info.offerRegionInfoCollection, offerID, autoXboxToken, allowWholesalePaymentTypes, out hasSCSPaymentTypes);
        }

        public static void ExpireOfferBasicInfo(OfferBasicInfo info, DateTime expirationDateTime)
        {
            if (info == null)
                throw new ArgumentException("Null OfferBasicInfo passed into ExpireOfferBasicInfo!", "info");

            ulong offerID = ParseUlong(info.offerID);

            foreach (OfferRegionInfo offerRegionInfo in info.offerRegionInfoCollection)
            {
                offerRegionInfo.endDate = expirationDateTime;
            }

            // Since regions contain billing info, clean out existing before insert new...
            p_svc_delete_offer_regions_xbox((long)offerID);

            PropOfferRegionInfoCollection(info.offerRegionInfoCollection, offerID, false);
        }

        public static void ExpireOfferFromCatalogDB(Dictionary<string, Content> contentDictionary, ContentOffer contentOffer, DateTime expirationDateTime)
        {
            Content content = null;
            contentDictionary.TryGetValue(contentOffer.offerContentInfo.contentID, out content);

            if (content == null)
            {
                Console.WriteLine("Error expiring offers to CatalogDB. Cannot find Content with contentId = '{0}' as referenced by offer with offerId = '{1}'.",
                    contentOffer.offerContentInfo.contentID,
                    contentOffer.offerBasicInfo.offerID);
            }

            //Resetting the OfferInfo EndDateTimes to a new expired EndDateTime
            foreach (OfferRegionInfo offerRegionInfo in contentOffer.offerBasicInfo.offerRegionInfoCollection)
            {
                offerRegionInfo.endDate = expirationDateTime;
            }

            GameOfferHelper.CreateGameOffer(contentOffer, content);
        }

        public static void PropSKUDetails(SKUDetails details)
        {
            // TODO: add checks here to make sure we're not overwriting anything previously configured
            int skuType;
            if (details.skuType == SKUType.Promo)
                skuType = (int)OfferingSKUType.PromotionalSKU;
            else if (details.skuType == SKUType.Revenue)
                skuType = (int)OfferingSKUType.RevenueSKU;
            else
                throw new Exception("invalid sku type: " + details.skuType);

            p_svc_insert_offer_sku(details.skuID, skuType, details.sku, details.friendlyName);
        }

        public static void PropCampaignDetails(CampaignDetails details)
        {
            // TODO: add checks here to make sure we're not overwriting anything previously configured

            p_svc_insert_offer_campaign(details.campaignID, details.friendlyName);
        }

        public static void PropAcquisitionType(AcquisitionType type)
        {
            // TODO: add checks here to make sure we're not overwriting anything previously configured

            p_svc_insert_offer_acquisition_type((int)type.acquisitionTypeID, type.friendlyName);
        }

        public static void PropDMPInfo(OfferDMPInfo info, ulong offerID, int offerType)
        {
            PropSKUDetails(info.sku);
            int revenueSkuID = (int)info.sku.skuID;

            int categoryID = offerType;

            PropCampaignDetails(info.campaign);
            int campaignID = (int)info.campaign.campaignID;

            p_svc_insert_dmp_offer_details(offerID, revenueSkuID, categoryID, campaignID);
        }

        public static void PropPointsBundleOffer(PointsBundleOffer o)
        {
            int offerType = (int)OfferingTypeEnum.PointsBundle;

            uint policyFlags = 0;
            uint licenseBits = 0;
            byte[] contentID = null;

            PropOfferBasicInfo(o.offerBasicInfo, offerType, policyFlags, licenseBits, contentID, 0, false);

            PropCampaignDetails(o.campaign);
            int campaignID = (int)o.campaign.campaignID;

            ulong offerID = ParseUlong(o.offerBasicInfo.offerID);
            p_svc_insert_offer_scs_item_details(offerID, campaignID);
        }

        public static void PropGamertagChangeOffer(GamertagChangeOffer o)
        {
            int offerType = (int)OfferingTypeEnum.GamertagChange;

            uint policyFlags = 0;
            uint licenseBits = 0;
            byte[] contentID = null;

            PropOfferBasicInfo(o.offerBasicInfo, offerType, policyFlags, licenseBits, contentID, 0, true);

            ulong offerID = ParseUlong(o.offerBasicInfo.offerID);
            PropDMPInfo(o.offerDMPInfo, offerID, offerType);
        }

        public static void PropGameplayOffer(GameplayOffer o)
        {
            int offerType = (int)OfferingTypeEnum.Gameplay;
            ulong offerID = ParseUlong(o.offerBasicInfo.offerID);

            uint policyFlags = 0;
            uint licenseBits = 0;
            byte[] contentID = null;

            PropOfferBasicInfo(o.offerBasicInfo, offerType, policyFlags, licenseBits, contentID, 0, true);

            // Instead of simply granting multiplayer privileges, we now require privileges to
            // be explicitly declared in the xml for gameplay offers.
            PropOfferPrivilegeInfo(o.offerPrivilegeInfo, offerID);

            p_svc_insert_offer_duration(offerID, (int)o.durationInSeconds);

            // Ensure that Fusion and Xbox1 can take advantage of 48-hour offers
            p_svc_insert_offer_services_xbox(offerID, 1);
            p_svc_insert_offer_services_xbox(offerID, 2);
            p_svc_insert_offer_services_xbox(offerID, 9999);

            SubscriptionTypeInfo subscriptionTypeInfo = new SubscriptionTypeInfo();
            subscriptionTypeInfo.subscriptionType = 1; // xbox-live
            subscriptionTypeInfo.tierProvided = 0;
            subscriptionTypeInfo.isBase = false;

            p_svc_insert_subscription_info(subscriptionTypeInfo, offerID);
        }

        public static void PropReward(Reward r)
        {
            int rewardID = (int)r.rewardID;
            int pointsRewarded = (int)r.pointsRewarded;
            int rewardLifetime = 0; // reward lifetime comes from the dmp promo sku

            PropSKUDetails(r.sku);
            int promoSKU = (int)r.sku.skuID;

            PropCampaignDetails(r.campaign);
            int campaignID = (int)r.campaign.campaignID;

            PropAcquisitionType(r.acquisitionType);
            int acquisitionType = (int)r.acquisitionType.acquisitionTypeID;

            p_svc_insert_dmp_reward(rewardID, pointsRewarded, rewardLifetime, promoSKU,
                campaignID, acquisitionType);

            foreach (RewardCultureDetails details in r.rewardCultureDetailsCollection)
            {
                int cultureID = (int)details.culture;
                string acquisitionTitle = details.acquisitionTitle;

                p_svc_insert_dmp_reward_culture_details(rewardID, cultureID, acquisitionTitle);
            }
        }

        public static void PropPromotionalPointsOffer(PromotionalPointsOffer o)
        {
            int offerType = (int)OfferingTypeEnum.PromoPoints;

            uint policyFlags = 0;
            uint licenseBits = 0;
            byte[] contentID = null;

            PropOfferBasicInfo(o.offerBasicInfo, offerType, policyFlags, licenseBits, contentID, 0, true);

            ulong offerID = ParseUlong(o.offerBasicInfo.offerID);

            p_svc_insert_offer_reward_details(offerID, (int)o.rewardID);
        }

        static void PropSubscriptionBasicInfo(SubscriptionBasicInfo info, int offerType)
        {
            uint[] titleIDs = ParseUints(info.titleIDCollection);
            ulong offerID = ParseUlong(info.offerID);
            uint bitFilter = ParseUint(info.bitFilter);

            string friendlyName = info.friendlyName;
            ConsoleTypeEnum consoleType = (ConsoleTypeEnum)MapConsoleType(info.consoleType);

            string billingComponentID = info.billingComponentID;

            uint policyFlags = Offer.PER_USER_RIGHTS;
            switch (info.offerEnumerationType)
            {
                case OfferEnumerationType.AlwaysEnumerateExceptInPartnerNetDash:
                    policyFlags |= Offer.HIDE_FROM_PARTNERNET_DASH;
                    break;

                case OfferEnumerationType.NeverEnumerate:
                    policyFlags |= Offer.DO_NOT_ENUMERATE;
                    break;

                case OfferEnumerationType.AlwaysEnumerate:
                    // no flags are set
                    break;
            }

            byte frequency = MapSubscriptionFrequency(info.subscriptionFrequency);
            byte duration = info.duration;
            byte freeCycles = 0; // legacy

            bool cancelable = false; // default
            if (info.__cancelableSpecified)
            {
                cancelable = info.cancelable;
            }

            uint globalOfferDetails = Details.BuildGlobalOfferDetails(frequency, duration, freeCycles);

            p_svc_insert_subscriptions_multi_title(titleIDs, offerID, bitFilter, cancelable, offerType, friendlyName, billingComponentID,
                policyFlags, globalOfferDetails, consoleType);

            VetOfferRegionCultures(offerID, info.offerRegionInfoCollection, info.offerCultureDetailsCollection);

            PropOfferPrivilegeInfo(info.offerPrivilegeInfo, offerID);

            PropOfferCultureDetailsCollection(info.offerCultureDetailsCollection, offerID, titleIDs);

            PropOfferRegionInfoCollection(info.offerRegionInfoCollection, offerID, false);

            PropOfferInstanceFamilyMappingCollection(info.offerRegionInfoCollection, offerID, false);
        }

        public static void ExpireSubscriptionBasicInfo(SubscriptionBasicInfo info, DateTime expirationDateTime)
        {
            if (info == null)
                throw new ArgumentException("Null SubscriptionBasicInfo structure passed into ExpireSubscriptionBasicInfo.", "info");

            ulong offerID = ParseUlong(info.offerID);

            foreach (OfferRegionInfo offerRegionInfo in info.offerRegionInfoCollection)
            {
                offerRegionInfo.endDate = expirationDateTime;
            }

            PropOfferRegionInfoCollection(info.offerRegionInfoCollection, offerID, false);
        }

        public static void PropLiveSubscription(LiveSubscription s)
        {
            int offerType = s.isTrial ? (int)OfferingTypeEnum.Trial : (int)OfferingTypeEnum.Subscription;
            ulong offerID = ParseUlong(s.subscriptionBasicInfo.offerID);

            SubscriptionTypeInfo subscriptionTypeInfo;

            // if they provided subscriptionTypeInfo,  then we use it
            // if they provided a liveTier then make sure it  matches

            if (s.__subscriptionTypeInfo != null)
            {
                subscriptionTypeInfo = s.__subscriptionTypeInfo;

                if (s.__liveTierProvidedSpecified)
                {
                    if (subscriptionTypeInfo.tierProvided != s.liveTierProvided)
                    {
                        Console.WriteLine("OfferManger.PropLiveSubscription() error: value of <liveTierProvided> does not match value in <SubscriptionTypeInfo>");
                        throw new Exception("live tier mismatch");
                    }
                }
            }

            // if they didn't provide subscriptionTypeInfo,  then  we
            // create one and fill it in  with  some  default  values

            else
            {
                Console.WriteLine("OfferManger.PropLiveSubscription() warning: no subscription type info provided, using defaults");

                subscriptionTypeInfo = new SubscriptionTypeInfo();
                subscriptionTypeInfo.subscriptionType = 1;
                subscriptionTypeInfo.isBase = true;

                if (s.__liveTierProvidedSpecified)
                    subscriptionTypeInfo.tierProvided = s.liveTierProvided;
                else
                {
                    subscriptionTypeInfo.tierProvided = LiveTier.Gold;
                }
            }

            p_svc_insert_subscription_info(subscriptionTypeInfo, offerID);
            PropSubscriptionBasicInfo(s.subscriptionBasicInfo, offerType);

            // TODO - remove this once we no longer use base offer
            uint tierID = (uint)MapLiveTier(subscriptionTypeInfo.tierProvided);
            p_svc_insert_base_offer(offerID, tierID);

            foreach (OfferSubscriptionRewardInfo info in s.offerSubscriptionRewardInfoCollection)
            {
                ushort countryID = info.countryID;
                int subscriptionTier = MapLiveTier(info.userTier);
                int rewardID = (int)info.rewardID;
                DateTime startDate = info.startDate;
                DateTime endDate = info.endDate;

                p_svc_insert_offer_subscription_reward(offerID, countryID, subscriptionTier, rewardID,
                    startDate, endDate);
            }

            foreach (LiveSubscriptionRelation relation in s.offerRelationInfoCollection)
            {
                ulong offerIDFrom = ParseUlong(relation.offerIDFrom);
                ulong OfferIDTo = offerID;
                int relationType = MapRelationType(relation.relationType);
                int convertMode = MapConvertMode(relation.convertMode);

                p_svc_insert_offer_relations(offerIDFrom, OfferIDTo, relationType, convertMode);
            }

            // if this subscription should allow xbox1play, we need to populate t_offer_services
            // for the offer with all of the xbox1 services.  if this subscription should *not*
            // allow xbox1 play, nothing more needs to be done--services/privileges for xenon
            // will come from the subscription tier
            if (s.allowsXbox1Play)
            {
                p_svc_insert_offer_services_xbox(offerID, 1);
                p_svc_insert_offer_services_xbox(offerID, 2);
                p_svc_insert_offer_services_xbox(offerID, 9999);
            }
        }

        public static void PropGameSubscription(GameSubscription s)
        {
            ulong offerID = ParseUlong(s.subscriptionBasicInfo.offerID);
            int offerType = (int)OfferingTypeEnum.Subscription;

            SubscriptionTypeInfo subscriptionTypeInfo;

            if (s.__subscriptionTypeInfo != null)
                subscriptionTypeInfo = s.__subscriptionTypeInfo;
            else
            {
                Console.WriteLine("OfferManger.PropLiveSubscription() warning: no subscription type info provided, using defaults");

                subscriptionTypeInfo = new SubscriptionTypeInfo();
                subscriptionTypeInfo.subscriptionType = 1;
                subscriptionTypeInfo.tierProvided = LiveTier.Gold;
            }

            p_svc_insert_subscription_info(subscriptionTypeInfo, offerID);
            PropSubscriptionBasicInfo(s.subscriptionBasicInfo, offerType);

            if (s.__liveServiceProvidedSpecified)
            {
                uint serviceID = s.liveServiceProvided;
                p_svc_service_create_offer(offerID, serviceID);
            }

            foreach (LiveSubscriptionRelation relation in s.offerRelationInfoCollection)
            {
                ulong offerIDFrom = ParseUlong(relation.offerIDFrom);
                ulong OfferIDTo = offerID;
                int relationType = MapRelationType(relation.relationType);
                int convertMode = MapConvertMode(relation.convertMode);

                p_svc_insert_offer_relations(offerIDFrom, OfferIDTo, relationType, convertMode);
            }
        }

        public static void PropPcAccountCreationOffer(PcAccountCreationOffer s)
        {
            ulong offerID = ParseUlong(s.offerID);
            uint titleID = ParseUint(s.titleID);

            p_svc_insert_offers(
                titleID, offerID, 0 /* bitFilter */, (int)OfferingTypeEnum.PcAccountCreation,
                s.friendlyName, ConsoleTypeEnum.PC, 0 /* policyFlags */, 0 /* licenseBits */,
                null /* contentID */, 0 /* previewOfferID */);
        }

        public static int PropLiveOffer(LiveOffer lo)
        {
            int count = 0;

            TransactionScope ts = (useTransaction ? TransactionScope.DTC : TransactionScope.None);
            IsolationLevel il = IsolationLevel.ReadCommitted;

            #region Prop to UODB
            foreach (Reward r in lo.rewardCollection)
            {
                using (TransactionWrapper myTrans = new TransactionWrapper(ts, il))
                {
                    PropReward(r);
                    if (useTransaction)
                        myTrans.SetComplete();
                }
            }

            foreach (PromotionalPointsOffer o in lo.promotionalPointsOfferCollection)
            {
                using (TransactionWrapper myTrans = new TransactionWrapper(ts, il))
                {
                    PropPromotionalPointsOffer(o);
                    count++;
                    if (useTransaction)
                        myTrans.SetComplete();
                }
            }

            foreach (PointsBundleOffer o in lo.pointsBundleOfferCollection)
            {
                using (TransactionWrapper myTrans = new TransactionWrapper(ts, il))
                {
                    PropPointsBundleOffer(o);
                    count++;
                    if (useTransaction)
                        myTrans.SetComplete();
                }
            }

            foreach (GamertagChangeOffer o in lo.gamertagChangeOfferCollection)
            {
                using (TransactionWrapper myTrans = new TransactionWrapper(ts, il))
                {
                    PropGamertagChangeOffer(o);
                    count++;
                    if (useTransaction)
                        myTrans.SetComplete();
                }
            }

            foreach (GameplayOffer o in lo.gameplayOfferCollection)
            {
                using (TransactionWrapper myTrans = new TransactionWrapper(ts, il))
                {
                    PropGameplayOffer(o);
                    count++;
                    if (useTransaction)
                        myTrans.SetComplete();
                }
            }

            foreach (LiveSubscription s in lo.liveSubscriptionCollection)
            {
                using (TransactionWrapper myTrans = new TransactionWrapper(ts, il))
                {
                    PropLiveSubscription(s);
                    count++;
                    if (useTransaction)
                        myTrans.SetComplete();
                }
            }

            foreach (GameSubscription s in lo.gameSubscriptionCollection)
            {
                using (TransactionWrapper myTrans = new TransactionWrapper(ts, il))
                {
                    PropGameSubscription(s);
                    count++;
                    if (useTransaction)
                        myTrans.SetComplete();
                }
            }

            foreach (PcAccountCreationOffer s in lo.pcAccountCreationOfferCollection)
            {
                using (TransactionWrapper myTrans = new TransactionWrapper(ts, il))
                {
                    PropPcAccountCreationOffer(s);
                    count++;
                    if (useTransaction)
                        myTrans.SetComplete();
                }
            }
            #endregion

            #region Prop to CatalogDB

            // A Content object can't be added in CatalogDB, it needs some information from
            // the offer, so only add content that is referenced by an offer and don't add offers
            // that don't have a content specified in the same file
            Dictionary<string, Content> dictionary = new Dictionary<string, Content>(lo.contentCollection.Count);

            foreach (Content content in lo.contentCollection)
            {
                dictionary[content.contentID] = content;
            }

            Console.WriteLine(String.Empty);
            Console.WriteLine("Add GameContent and Offer to CatalogDB - Starting ");
            Console.WriteLine(String.Empty);

            foreach (ContentOffer contentOffer in lo.contentOfferCollection)
            {
                Content content = null;
                dictionary.TryGetValue(contentOffer.offerContentInfo.contentID, out content);

                if (content == null)
                {
                    Console.WriteLine("Error adding offers to CatalogDB. Cannot find Content with contentId = '{0}' as referenced by offer with offerId = '{1}'.",
                        contentOffer.offerContentInfo.contentID,
                        contentOffer.offerBasicInfo.offerID);
                    continue;
                }

                // Prop Media to the Catalog
                GameOfferHelper.CreateGameContent(contentOffer, content);
                // Prop Offer to the Catalog
                GameOfferHelper.CreateGameOffer(contentOffer, content);

                // Prop Offer Banner to Storage
                Console.WriteLine(" Adding Offer Images to Storage... ");
                foreach (OfferCultureDetails details in contentOffer.offerBasicInfo.offerCultureDetailsCollection)
                {
                    WriteFileToStorage(details.imageFilePath,
                        ParseUlong(contentOffer.offerBasicInfo.offerID),
                        ParseUint(contentOffer.offerBasicInfo.primaryTitleID));
                }
            }

            Console.WriteLine(String.Empty);
            Console.WriteLine("Add GameContent and Offer to CatalogDB - Completed ");
            Console.WriteLine(String.Empty);

            // remove from dictionary to detect content that was not referenced by offers
            foreach (ContentOffer contentOffer in lo.contentOfferCollection)
            {
                if (dictionary.ContainsKey(contentOffer.offerContentInfo.contentID))
                {
                    dictionary.Remove(contentOffer.offerContentInfo.contentID);
                }
            }

            foreach (Content content in dictionary.Values)
            {
                Console.WriteLine("Error adding offers to CatalogDB. Content with contentId = '{0}' was NOT referenced by an offer so it couldn't be added to CatalogDB.",
                    content.contentID);
            }

            #endregion

            return count;
        }
        public static bool ValidateImageSizes(LiveOffer lo)
        {
            foreach (Title t in lo.titleCollection)
            {
                foreach (TitleCultureDetails details in t.titleCultureDetailsCollection)
                {
                    if (false == ValidateImage(details.imageFilePath)) return false;
                }
            }
            foreach (PromotionalPointsOffer o in lo.promotionalPointsOfferCollection)
            {
                foreach (OfferCultureDetails details in o.offerBasicInfo.offerCultureDetailsCollection)
                {
                    if (false == ValidateImage(details.imageFilePath)) return false;
                }
            }
            foreach (ContentOffer o in lo.contentOfferCollection)
            {
                foreach (OfferCultureDetails details in o.offerBasicInfo.offerCultureDetailsCollection)
                {
                    if (false == ValidateImage(details.imageFilePath)) return false;
                }
            }
            foreach (PointsBundleOffer o in lo.pointsBundleOfferCollection)
            {
                foreach (OfferCultureDetails details in o.offerBasicInfo.offerCultureDetailsCollection)
                {
                    if (false == ValidateImage(details.imageFilePath)) return false;
                }
            }
            foreach (GamertagChangeOffer o in lo.gamertagChangeOfferCollection)
            {
                foreach (OfferCultureDetails details in o.offerBasicInfo.offerCultureDetailsCollection)
                {
                    if (false == ValidateImage(details.imageFilePath)) return false;
                }
            }
            foreach (GameplayOffer o in lo.gameplayOfferCollection)
            {
                foreach (OfferCultureDetails details in o.offerBasicInfo.offerCultureDetailsCollection)
                {
                    if (false == ValidateImage(details.imageFilePath)) return false;
                }
            }
            foreach (LiveSubscription s in lo.liveSubscriptionCollection)
            {
                foreach (OfferCultureDetails details in s.subscriptionBasicInfo.offerCultureDetailsCollection)
                {
                    if (false == ValidateImage(details.imageFilePath)) return false;
                }
            }
            foreach (GameSubscription s in lo.gameSubscriptionCollection)
            {
                foreach (OfferCultureDetails details in s.subscriptionBasicInfo.offerCultureDetailsCollection)
                {
                    if (false == ValidateImage(details.imageFilePath)) return false;
                }
            }
            return true;
        }

        static bool ValidateImage(string localFileName)
        {
            try
            {
                if (Path.GetExtension(localFileName).ToLower().EndsWith("png"))
                {
                    if (!File.Exists(localFileName))
                    {
                        Console.WriteLine("OfferManager.ValidateImage() error: " + localFileName + " does not exist. Please check the filename and location.");
                        return false;
                    }

                    Bitmap b = new Bitmap(localFileName);
                    if (b.Width != 420 || b.Height != 95)
                    {
                        Console.WriteLine("OfferManager.ValidateImage() error: '" + localFileName + "' is not the required size.  420x95 required; " + b.Width + "x" + b.Height + " found.");
                        return false;
                    }
                }
                else
                {
                    Console.WriteLine("OfferManager.ValidateImage() error: " + localFileName + " is not a PNG file");
                    return false;
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine("OfferManager.ValidateImage() error: file '" + localFileName + "' threw exception '" + ex.Message + "'");
                return false;
            }

            return true;
        }

        static void p_svc_insert_offers(uint titleID, ulong offerID, uint bitFilter,
            int offerType, string friendlyName, ConsoleTypeEnum consoleType, uint policyFlags,
            uint licenseBits, byte[] contentID, ulong previewOfferID)
        {
            byte[] symKey = new byte[16];
            byte[] publicKey = new byte[284];

            p_svc_insert_offers_EX(titleID, offerID, 0, false, 0, 0, symKey, bitFilter,
                "", offerType, 0,
                new DateTime(2001, 11, 15), new DateTime(3001, 11, 15), friendlyName, publicKey,
                policyFlags, consoleType, licenseBits, contentID, previewOfferID);
        }


        static void p_svc_insert_dmp_offer_details(ulong offerID, int revenueSkuID, int categoryID,
            int campaignID)
        {
            // Iterate through all db targets
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcInsertDmpOfferDetails(
                        //  ISpilConnectionManager scm,
                        //  SqlInt64 bi_offer_id,
                        //  SqlInt32 i_revenue_sku_id,
                        //  SqlInt32 i_category_id,
                        //  SqlInt32 i_campaign_id)
                        //
                        try
                        {
                            int[] results = so.SvcInsertDmpOfferDetails(scm
                                      , (long)offerID
                                      , revenueSkuID
                                      , categoryID
                                      , campaignID
                                      );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }

        public static void p_svc_insert_title_associated_offer(uint titleID, ulong offerID)
        {
            // Iterate through all db targets
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcInsertTitleAssociatedOffer(
                        //  ISpilConnectionManager scm,
                        //  SqlInt32 i_title_id,
                        //  SqlInt64 bi_offer_id)
                        //
                        try
                        {
                            int[] results = so.SvcInsertTitleAssociatedOffer(scm
                                , (int)titleID
                                , (long)offerID
                                );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }

        public static void p_svc_insert_offer_culture_details(ulong offerID, int culture, string name,
            string sellText)
        {
            // Iterate through all db targets
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcInsertOfferCultureDetails(
                        //  ISpilConnectionManager scm,
                        //  SqlInt64 bi_offer_id,
                        //  SqlInt32 i_culture_id,
                        //  string vc_name,
                        //  string vc_sell_text) {
                        //
                        try
                        {
                            int[] results = so.SvcInsertOfferCultureDetails(scm
                                , (long)offerID
                                , culture
                                , name
                                , sellText
                                );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }

        public static void p_svc_insert_offer_regions_xenon(ulong offerID, byte countryID,
            int tierRequired, int paymentType, DateTime startDate, DateTime endDate, string boid,
            int priceWhole, int priceFractional, uint specificOfferDetails)
        {
            // Iterate through all db targets
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcInsertOfferRegionsXenon(
                        //  ISpilConnectionManager scm, 
                        //  SqlInt64 bi_offer_id, 
                        //  SqlByte ti_country_id, 
                        //  SqlInt32 i_tier_required,
                        //  SqlInt32 i_payment_type_id,
                        //  SqlDateTime dt_start_date,
                        //  SqlDateTime dt_end_date,
                        //  string vc_billing_offer_id,
                        //  SqlInt32 i_price_whole,
                        //  SqlInt32 i_price_fractional,
                        //  SqlInt16 si_specific_offer_details)

                        //
                        try
                        {
                            int[] results = so.SvcInsertOfferRegionsXenon(scm
                                , (long)offerID
                                , countryID
                                , tierRequired
                                , paymentType
                                , startDate
                                , endDate
                                , boid
                                , priceWhole
                                , priceFractional
                                , (short)specificOfferDetails
                                );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }


        public static void p_svc_insert_offer_instance_family_mappings(ulong offerID, byte countryID, int paymentType)
        {
            // Iterate through all db targets
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcInsertOfferInstanceFamilyMappings(
                        //  ISpilConnectionManager scm, 
                        //  SqlInt64 bi_offer_id, 
                        //  SqlByte ti_country_id, 
                        //  SqlInt32 i_payment_type_id)
                        //

                        try
                        {
                            int[] results = so.SvcInsertOfferInstanceFamilyMappings(scm
                                , (long)offerID
                                , countryID
                                , paymentType
                                );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }

        static void RemoveFileFromStorage(string storageFileName, ulong titleID)
        {
            string arguments = string.Format("-a:remove -p:{0} -t:0x{1:x8}", storageFileName, titleID);

            Process stutil = new Process();
            stutil.StartInfo.FileName = "stutil.exe";
            stutil.StartInfo.Arguments = arguments;
            stutil.StartInfo.UseShellExecute = false;
            stutil.StartInfo.RedirectStandardOutput = true;

            stutil.Start();

            Console.WriteLine();
            Console.WriteLine("{0} {1}", stutil.StartInfo.FileName, stutil.StartInfo.Arguments);
            Console.WriteLine(stutil.StandardOutput.ReadToEnd());

            stutil.WaitForExit();
        }

        static void WriteFileToStorage(string localFileName, ulong offerID, ulong titleID)
        {
            if (string.IsNullOrEmpty(localFileName))
                return;

            string storageFileName = string.Format("//global/t:{0}/marketplace/{1}/{2}",
                titleID.ToString("x"), 0, offerID.ToString("x"));

            WriteFileToStorage(localFileName, storageFileName, titleID);
        }

        static void WriteFileToStorage(string localFileName, string storageFileName, ulong titleID)
        {
            if (Environment.GetEnvironmentVariable("LIVEOFFER_NOPIX") != null)
                return;

            // check to see if we've already written an image to this location, and if so move on
            if (imageServerPaths.Contains(storageFileName))
                return;

            // check to see if the local file exists; if not, abort and return
            if (!File.Exists(localFileName))
            {
                Console.WriteLine("OfferManager.WriteFileToStorage(): ERROR: could not find source file " + localFileName + " using current path " + Environment.CurrentDirectory);
                return;
            }

            string arguments = string.Format("-a:write -f:{0} -p:{1} -t:0x{2:x8} -y", localFileName, storageFileName, titleID);

            Process stutil = new Process();
            stutil.StartInfo.FileName = "stutil.exe";
            stutil.StartInfo.Arguments = arguments;
            stutil.StartInfo.UseShellExecute = false;
            stutil.StartInfo.RedirectStandardOutput = true;

            stutil.Start();

            Console.WriteLine();
            Console.WriteLine("{0} {1}", stutil.StartInfo.FileName, stutil.StartInfo.Arguments);
            Console.WriteLine(stutil.StandardOutput.ReadToEnd());

            stutil.WaitForExit();

            if (stutil.ExitCode == 0) // success
            {
                if (imageFilePaths.IndexOf(localFileName) < 0) // a distinct list
                    imageFilePaths.Add(localFileName);

                imageServerPaths[storageFileName] = 1;
            }

        }

        static void p_svc_insert_offer_scs_item_details(ulong offerID, int campaignID)
        {
            // Iterate through all db targets
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcInsertOfferScsItemDetails(
                        //  ISpilConnectionManager scm,
                        //  SqlInt64 bi_offer_id,
                        //  SqlInt32 i_campaign_id)
                        //
                        try
                        {
                            int[] results = so.SvcInsertOfferScsItemDetails(scm
                                , (long)offerID
                                , campaignID
                                );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }

        public static void p_svc_insert_offer_campaign(uint campaignID, string friendlyName)
        {
            // Iterate through all db targets
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcInsertOfferCampaign(
                        //  ISpilConnectionManager scm,
                        //  SqlInt32 i_campaign_id,
                        //  string vc_friendly_name)
                        //
                        try
                        {
                            int[] results = so.SvcInsertOfferCampaign(scm
                                , (int)campaignID
                                , friendlyName
                                , (overwriteDMPSettings ? 1 : 0)
                                );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }

        public static void p_svc_insert_offer_sku(uint skuID, int skuType, string SKU, string friendlyName)
        {
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcInsertOfferSku(
                        //  ISpilConnectionManager scm,
                        //  SqlInt32 i_sku_id,
                        //  SqlInt32 i_sku_type_id,
                        //  string vc_sku,
                        //  string vc_friendly_name) {
                        //
                        try
                        {
                            int[] results = so.SvcInsertOfferSku(scm
                                , (int)skuID
                                , skuType
                                , SKU
                                , friendlyName
                                , (overwriteDMPSettings ? 1 : 0)
                                );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }

        public static void p_svc_insert_offer_duration(ulong offerID, int durationSeconds)
        {
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcInsertOfferDuration(
                        //  ISpilConnectionManager scm,
                        //  SqlInt64 bi_offer_id,
                        //  SqlInt32 i_duration_seconds)
                        //
                        try
                        {
                            int[] results = so.SvcInsertOfferDuration(scm
                                , (long)offerID
                                , durationSeconds
                                );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }

        public static void p_svc_insert_dmp_reward_culture_details(int rewardID, int cultureID,
            string acquisitionTitle)
        {
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcInsertDmpRewardCultureDetails(
                        //  ISpilConnectionManager scm,
                        //  SqlInt32 i_reward_id,
                        //  SqlInt32 i_culture_id,
                        //  string vc_acquisition_title)
                        //
                        try
                        {
                            int[] results = so.SvcInsertDmpRewardCultureDetails(scm
                                , rewardID
                                , cultureID
                                , acquisitionTitle
                                );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }

        public static void p_svc_insert_dmp_reward(int rewardID, int pointsRewarded, int rewardLifetime,
            int promoSKU, int campaignID, int acquisitionType)
        {
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcInsertDmpReward(
                        //  ISpilConnectionManager scm,
                        //  SqlInt32 i_reward_id,
                        //  SqlInt32 i_points_rewarded,
                        //  SqlInt32 i_reward_lifetime,
                        //  SqlInt32 i_promo_sku_id,
                        //  SqlInt32 i_campaign_id,
                        //  SqlInt32 i_acquisition_type_id)
                        //
                        try
                        {
                            int[] results = so.SvcInsertDmpReward(scm
                                , rewardID
                                , pointsRewarded
                                , rewardLifetime
                                , promoSKU
                                , campaignID
                                , acquisitionType
                                );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }

        public static void p_svc_insert_offer_acquisition_type(int acquisitionType, string friendlyName)
        {
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcInsertOfferAcquisitionType(
                        //  ISpilConnectionManager scm,
                        //  SqlInt32 i_acquisition_type_id,
                        //  string vc_friendly_name)
                        //
                        try
                        {
                            int[] results = so.SvcInsertOfferAcquisitionType(scm
                                , acquisitionType
                                , friendlyName
                                , (overwriteDMPSettings ? 1 : 0)
                                );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }

        public static void p_svc_insert_offer_reward_details(ulong offerID, int rewardID)
        {
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcInsertOfferRewardDetails(
                        //  ISpilConnectionManager scm,
                        //  SqlInt64 bi_offer_id,
                        //  SqlInt32 i_reward_id)
                        //
                        try
                        {
                            int[] results = so.SvcInsertOfferRewardDetails(scm
                                , (long)offerID
                                , rewardID
                                );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }

        static void p_svc_insert_subscriptions_multi_title(uint[] titleIDs, ulong offerID, uint bitFilter,
            bool cancelable, int offerType, string friendlyName, string billingComponentID, uint policyFlags,
            uint globalOfferDetails, ConsoleTypeEnum consoleType)
        {
            p_svc_insert_subscriptions_EX(titleIDs, offerID, 0,
                cancelable, 0, 0, null, (int)bitFilter, billingComponentID, offerType, 0,
                new DateTime(2001, 11, 15), new DateTime(3001, 11, 15), friendlyName, null, policyFlags,
                globalOfferDetails, consoleType);
        }

        public static void p_svc_service_create_offer(ulong offerID, uint serviceID)
        {
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcServiceCreateOffer(
                        //  ISpilConnectionManager scm,
                        //  SqlInt32 i_service_id,
                        //  SqlInt64 bi_offer_id)
                        //
                        try
                        {
                            int[] results = so.SvcServiceCreateOffer(scm
                                , (int)serviceID
                                , (long)offerID
                                );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }

        public static void p_svc_insert_base_offer(ulong offerID, uint tierID)
        {
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcInsertBaseOffer(
                        //  ISpilConnectionManager scm,
                        //  SqlInt64 bi_offer_id,
                        //  SqlInt32 i_tier_id)
                        //
                        try
                        {
                            int[] results = so.SvcInsertBaseOffer(scm
                                , (long)offerID
                                , (int)tierID
                                );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }

        public static void p_svc_insert_subscription_info(SubscriptionTypeInfo typeInfo, ulong offerID)
        {
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcInsertSubscriptionInfo(
                        //  ISpilConnectionManager scm,
                        //  SqlInt64 bi_offer_id,
                        //  SqlInt16 si_subscription_type
                        //  SqlInt32 i_tier_id
                        //  SqlByte  ti_is_base
                        // ) 
                        //
                        try
                        {
                            int[] results = so.SvcInsertSubscriptionInfo(
                                scm, (long)offerID,
                                typeInfo.subscriptionType,
                                MapLiveTier(typeInfo.tierProvided),
                                typeInfo.isBase ? (byte)1 : (byte)0
                            );
                        }
                        catch
                        {
                            bThrown = true; throw;
                        }
                        finally
                        {
                            ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown);
                        }
                    }
                }
            }
        }

        public static void p_svc_insert_offer_subscription_reward(ulong offerID, ushort countryID, int subscriptionTier,
            int rewardID, DateTime startDate, DateTime endDate)
        {
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcInsertOfferSubscriptionReward(
                        //  ISpilConnectionManager scm,
                        //  SqlInt64 bi_offer_id,
                        //  SqlInt32 ti_country_id,
                        //  SqlInt32 i_subscription_tier_id,
                        //  SqlDateTime dt_start_date,
                        //  SqlDateTime dt_end_date,
                        //  SqlInt32 i_reward_id)
                        //
                        try
                        {
                            int[] results = so.SvcInsertOfferSubscriptionReward(scm
                                , (long)offerID
                                , (int)countryID
                                , subscriptionTier
                                , startDate
                                , endDate
                                , rewardID
                                );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }

        public static void p_svc_insert_offer_relations(ulong offerIDFrom, ulong OfferIDTo, int relationType, int convertMode)
        {
            //        public virtual int[] SvcInsertOfferRelations(ISpilConnectionManager scm, SqlInt64 bi_offer_id, SqlInt64 bi_related_offer_id, SqlInt32 i_relation_type_id, SqlInt32 i_convert_mode) {
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcInsertOfferRelations(
                        //  ISpilConnectionManager scm,
                        //  SqlInt64 bi_offer_id,
                        //  SqlInt64 bi_related_offer_id,
                        //  SqlInt32 i_relation_type_id,
                        //  SqlInt32 i_convert_mode) {
                        //
                        try
                        {
                            int[] results = so.SvcInsertOfferRelations(scm
                                , (long)OfferIDTo
                                , (long)offerIDFrom
                                , relationType
                                , convertMode
                                );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }


        #region Xbox XML Shredding...

        public static int PropXboxOffers(XboxOffers xos)
        {
            int count = 0;

            TransactionScope ts = (useTransaction ? TransactionScope.DTC : TransactionScope.None);
            IsolationLevel il = IsolationLevel.ReadCommitted;

            //task: HOW SHOULD WE DEPLOY SERVICES AND SERVICE INSTANCES?? 
            //task: for services and service instances


            //for subscription offers
            foreach (XboxSubscription xs in xos.XboxSubscriptionCollection)
            {
                //Note: TransactionScope.DTC currently has issue when over 100 commands are issued in the same Transaction -- WebstoreProduct bug 5812 is being researched
                //      Current Workaround is to update HKLM\Software\Microsoft\WebStore\<WebStore AppName>\MaxPoolSize (DWORD) to be over 100
                using (TransactionWrapper myTrans = new TransactionWrapper(ts, il))
                {
                    DeployXboxSubscription(xs);
                    count++;
                    // From SPIL 3.0 documentation:
                    // This method should be called just before the end of the "using" block. 
                    // It lets the TransactionWrapper know that the block completed without throwing an exception. 
                    // If SetComplete was not called before Dispose was called, then we automatically abort the transaction. 
                    if (useTransaction)
                        myTrans.SetComplete();
                }
            }

            //for each content offer (there is only 1 possible)
            if (xos.__XboxContentOffer != null)
            {
                using (TransactionWrapper myTrans = new TransactionWrapper(ts, il))
                {
                    DeployXboxContentOffer(xos.XboxContentOffer);
                    count++;
                    if (useTransaction)
                        myTrans.SetComplete();
                }
            }

            //task: for each update ???
            // This should be handled by LiveTitle or LiveContent

            return count;
        }


        //note: the schema for Xbox contains many "long" types where "ulong" would have been more appropriate
        //      but it seemed easier to convert these here 
        public static void DeployXboxContentOffer(XboxContentOffer xo)
        {

            XboxOfferBasicInfo xobi = xo.xboxOfferBasicInfo;

            // basic validation
            if (String.IsNullOrEmpty(xobi.symKey) || String.IsNullOrEmpty(xobi.publicKey))
            {
                Console.WriteLine("OfferManager error: either symKey or publicKey are empty or null.  Aborting deployment of offer...");
                return;
            }

            byte[] symKey = HexStringToByteArray(xobi.symKey);
            byte[] pubKey = HexStringToByteArray(xobi.publicKey);

            p_svc_insert_offers_xbox(
                (uint)xobi.titleID, (ulong)xobi.offerID, (ushort)xobi.ESRB,
                (int)xobi.packageSize, (int)xobi.installSize, symKey, (uint)xobi.bitFilter,
                xobi.billingSvcComponentID, (int)xobi.offerTypeID, xobi.startDate,
                xobi.endDate, xobi.friendlyName, pubKey, xobi.policyFlags);

            foreach (XboxOfferDescription xod in xo.xboxOfferDescriptionCollection)
            {
                byte[] blob = null;
                if (xod.blobBase64 == true)
                    blob = Convert.FromBase64String(xod.detailsBlob);
                else
                    blob = HexStringToByteArray(xod.detailsBlob);
                p_svc_insert_offer_descriptions_xbox((ulong)xod.liveOfferID, (int)xod.descriptionIndex, blob);
            }

            foreach (XboxOfferDescriptionDetails xods in xo.xboxOfferDescriptionDetailsCollection)
            {
                byte[] blob = null;
                if (xods.blobBase64 == true)
                    blob = Convert.FromBase64String(xods.detailsBlob);
                else
                    blob = HexStringToByteArray(xods.detailsBlob);
                p_svc_insert_offer_description_details_xbox((ulong)xods.liveOfferID, blob, (int)xods.descriptionIndex, (int)xods.order);
            }

            foreach (XboxOfferLocations xol in xo.xboxOfferLocationsCollection)
            {
                p_svc_insert_offer_locations_xbox((ulong)xol.offerID, (int)xol.locationRank, xol.XRL);
            }

            //titlemgr did it this way... so we'll do it too.
            p_svc_delete_offer_regions_xbox(xobi.offerID);

            foreach (XboxOfferRegions xor in xo.xboxOfferRegionsCollection)
            {
                p_svc_insert_offer_regions_xbox((ulong)xor.liveOfferID, xor.countryID, xor.billingOfferID,
                    (int)xor.priceWhole, (int)xor.priceFractional, (short)xor.specificOfferDetails);
            }
        }

        //note: the schema for Xbox contains many "long" types where "ulong" would have been more appropriate
        //      but it seemed easier to convert these here 
        public static void DeployXboxSubscription(XboxSubscription xs)
        {

            XboxSubscriptionBasicInfo xsbi = xs.xboxSubscriptionBasicInfo;
            byte[] symKey = null;
            byte[] pubKey = null;
            // backwards compat with old subscription offers files that 
            // always used base64. Not perfect, but works in all cases encountered in test
            if (String.Compare(xsbi.symKey.Substring(0, 2), ("0x"), true) != 0)
            {
                symKey = Convert.FromBase64String(xsbi.symKey);
                pubKey = Convert.FromBase64String(xsbi.publicKey);
            }
            else
            {   // New / expected format for these values
                symKey = HexStringToByteArray(xsbi.symKey);
                pubKey = HexStringToByteArray(xsbi.publicKey);
            }


            p_svc_insert_subscriptions_xbox(
                (uint)xsbi.titleID, (ulong)xsbi.offerID, (ushort)xsbi.ESRB, xsbi.cancellable,
                (int)xsbi.packageSize, (int)xsbi.installSize, symKey,
                xsbi.bitFilter, xsbi.billingSvcComponentID, (int)xsbi.offerTypeID,
                (int)xsbi.offerFrequency, xsbi.startDate, xsbi.endDate, xsbi.friendlyName,
                pubKey, xsbi.policyFlags, xsbi.globalOfferDetails);

            //task: if BASE OFFER do anything else ???
            //    : eventually, make sure that site 1 is specified in offerchecker
            if (xs.baseOffer)
            {
                //add it to base_offers
                p_svc_insert_base_offer((ulong)xs.xboxSubscriptionBasicInfo.offerID, 6);  // LiveTier.Gold

                SubscriptionTypeInfo subscriptionTypeInfo = new SubscriptionTypeInfo();
                subscriptionTypeInfo.subscriptionType = 1;
                subscriptionTypeInfo.isBase = true;
                subscriptionTypeInfo.tierProvided = LiveTier.Gold;

                p_svc_insert_subscription_info(subscriptionTypeInfo, (ulong)xs.xboxSubscriptionBasicInfo.offerID);
            }

            foreach (XboxOfferDescription xod in xs.xboxOfferDescriptionCollection)
            {
                byte[] blob = null;
                if (xod.blobBase64 == true
                    // backwards compat with old subscription offers files that 
                    // always used base64. Not perfect, but works in all cases encountered in test
                        || String.Compare(xod.detailsBlob.Substring(0, 2), ("0x"), true) != 0)
                    blob = Convert.FromBase64String(xod.detailsBlob);
                else
                    blob = HexStringToByteArray(xod.detailsBlob);
                p_svc_insert_offer_descriptions_xbox((ulong)xod.liveOfferID, (int)xod.descriptionIndex, blob);
            }

            foreach (XboxOfferDescriptionDetails xods in xs.xboxOfferDescriptionDetailsCollection)
            {
                byte[] blob = null;
                if (xods.blobBase64 == true
                    // backwards compat with old subscription offers files that 
                    // always used base64. Not perfect, but works in all cases encountered in test
                        || String.Compare(xods.detailsBlob.Substring(0, 2), ("0x"), true) != 0)
                    blob = Convert.FromBase64String(xods.detailsBlob);
                else
                    blob = HexStringToByteArray(xods.detailsBlob);
                p_svc_insert_offer_description_details_xbox((ulong)xods.liveOfferID, blob, (int)xods.descriptionIndex, (int)xods.order);
            }

            //titlemgr did it this way... so we'll do it too.
            p_svc_delete_offer_regions_xbox(xsbi.offerID);

            foreach (XboxOfferRegions xor in xs.xboxOfferRegionsCollection)
            {
                p_svc_insert_offer_regions_xbox((ulong)xor.liveOfferID, xor.countryID, xor.billingOfferID,
                    (int)xor.priceWhole, (int)xor.priceFractional, (short)xor.specificOfferDetails);

                //For xbox1 offers, create an offer instance to family mapping with an 'invalid' payment type
                // because there is no payment type available.  
                p_svc_insert_offer_instance_family_mappings((ulong)xor.liveOfferID, xor.countryID, 0);
            }

            foreach (XboxOfferRelations xorl in xs.xboxOfferRelationsCollection)
            {
                p_svc_insert_offer_relations_xbox((ulong)xorl.offerID, (ulong)xorl.relatedOfferID, (int)xorl.relationTypeID,
                    (int)xorl.convertMode);
            }

            foreach (XboxOfferServices xsvc in xs.xboxOfferServicesCollection)
            {
                p_svc_insert_offer_services_xbox((ulong)xsvc.offerID, (int)xsvc.siteID);
            }

        }

        #endregion


        #region Xbox Stored Procedure Code


        //REVIEW: several methods here duplicate methods above... we should 
        //        refactor so that the Xenon calls just put defaults for legacy params
        //        and call these Xbox procedures.  
        //        It doesn't seem good at this late hour to be refactoring working code
        //        that doesn't (yet) have unit tests.

        //p_svc_delete_offer_regions
        static void p_svc_delete_offer_regions_xbox(long offerID)
        {
            // Iterate through all db targets
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        //         public virtual int[] SvcDeleteRegions(ISpilConnectionManager scm, SqlInt64 bi_offer_id)
                        //
                        try
                        {
                            int[] results = so.SvcDeleteRegions(scm, offerID);

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }


        public static void p_svc_insert_offers_xbox(uint titleID, ulong offerID, int esrb,
            int packageSize, int installSize, byte[] symKey, uint bitFilter,
            string billingSvcComponentID, int offerType, DateTime startDate, DateTime endDate,
            string friendlyName, byte[] publicKey, uint policyFlags)
        {
            p_svc_insert_offers_EX(titleID, offerID, esrb, false, packageSize, installSize, symKey, bitFilter,
            billingSvcComponentID, offerType, 0,
            startDate, endDate, friendlyName, publicKey,
            policyFlags, ConsoleTypeEnum.Xbox1, 0, null, 0);
        }

        // function that both consoleTypes can use
        public static void p_svc_insert_offers_EX(uint titleID, ulong offerID, int esrb,
            bool cancelable, int packageSize, int installSize, byte[] symKey, uint bitFilter,
            string billingSvcComponentID, int offerType, int offerFrequency,
            DateTime startDate, DateTime endDate, string friendlyName, byte[] publicKey,
            uint policyFlags, ConsoleTypeEnum consoleType, uint licenseBits, byte[] contentID, ulong previewOfferID)
        {

            // Iterate through all db targets
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        //  public virtual int[] SvcInsertOffers(
                        //  ISpilConnectionManager scm,
                        //  SqlInt32 i_title_id,
                        //  SqlInt64 bi_offer_id,
                        //  SqlInt32 i_ESRB_id,
                        //  SqlByte b_cancelable,
                        //  SqlInt32 i_package_size,
                        //  SqlInt32 i_install_size,
                        //  SqlBinary vb_sym_key,
                        //  SqlInt32 i_bitfilter,
                        //  string vc_billing_svc_component_id,
                        //  SqlInt32 i_offer_type_id,
                        //  SqlInt32 i_offer_frequency_id,
                        //  SqlDateTime dt_start_date,
                        //  SqlDateTime dt_end_date,
                        //  string vc_friendly_name,
                        //  SqlBinary vb_public_key,
                        //  SqlInt32 i_policy_flags,
                        //  SqlByte ti_console_type_id,
                        //  SqlInt32 i_license_bits,
                        //  SqlBinary b_content_id,
                        //  SqlInt64 bi_preview_offer_id)
                        //
                        try
                        {
                            int[] results = so.SvcInsertOffers(scm
                                , (int)titleID
                                , (long)offerID
                                , (int)esrb // i_ESRB_id : legacy
                                , (byte)(cancelable ? 1 : 0) // b_cancelable : legacy
                                , packageSize // i_package_size : legacy
                                , installSize // i_install_size : legacy
                                , symKey
                                , (int)bitFilter
                                , billingSvcComponentID // vc_billing_svc_component_id : not applicable to content offers
                                , offerType
                                , 0 // i_offer_frequency_id : legacy
                                , startDate // dt_start_date : legacy
                                , endDate // dt_end_date : legacy
                                , friendlyName
                                , publicKey // legacy
                                , (int)policyFlags
                                , (byte)consoleType // xbox consoletype
                                , (int)licenseBits
                                , (contentID != null ? contentID : SqlBinary.Null)
                                , (long)previewOfferID
                                );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }

        //insert offer descriptions
        public static void p_svc_insert_offer_descriptions_xbox(ulong offerID,
            int descriptionIndex, byte[] detailsBlob)
        {
            // Iterate through all db targets
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcInsertOfferDescriptions(
                        //   ISpilConnectionManager scm,
                        //   SqlInt64 bi_offer_id,
                        //   SqlBinary vb_enum_blob,
                        //   SqlInt32 i_description_index)
                        //
                        try
                        {
                            int[] results = so.SvcInsertOfferDescriptions(scm
                                , (long)offerID
                                , detailsBlob
                                , descriptionIndex
                                );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }

        //insert offer description details
        public static void p_svc_insert_offer_description_details_xbox(ulong offerID,
            byte[] detailsBlob, int descriptionIndex, int order)
        {
            // Iterate through all db targets
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcInsertOfferDescriptionDetails(
                        //   ISpilConnectionManager scm,
                        //   SqlInt64 bi_offer_id,
                        //   SqlBinary vb_details_blob,
                        //   SqlInt32 i_description_index,
                        //   SqlInt32 i_order)
                        //
                        try
                        {
                            int[] results = so.SvcInsertOfferDescriptionDetails(scm
                                , (long)offerID
                                , detailsBlob
                                , descriptionIndex
                                , order
                                );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }

        //p_svc_insert_offer_locations
        public static void p_svc_insert_offer_locations_xbox(ulong offerID, int locationRank, string xrl)
        {
            // Iterate through all db targets
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcInsertOfferLocations(
                        // ISpilConnectionManager scm,
                        //  SqlInt64 bi_offer_id,
                        //  SqlInt32 i_location_rank,
                        //  string vc_XRL)
                        //
                        try
                        {
                            int[] results = so.SvcInsertOfferLocations(scm
                                , (long)offerID
                                , locationRank
                                , xrl
                                );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }


        //p_svc_insert_offer_relations
        static void p_svc_insert_offer_relations_xbox(ulong offerID, ulong relatedOfferID,
            int relationTypeID, int convertMode)
        {
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcInsertOfferRelations(
                        //  ISpilConnectionManager scm,
                        //  SqlInt64 bi_offer_id,
                        //  SqlInt64 bi_related_offer_id,
                        //  SqlInt32 i_relation_type_id,
                        //  SqlInt32 i_convert_mode)
                        //
                        try
                        {
                            int[] results = so.SvcInsertOfferRelations(scm
                                , (long)offerID
                                , (long)relatedOfferID
                                , relationTypeID
                                , convertMode
                                );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }


        //p_svc_insert_offer_regions
        static void p_svc_insert_offer_regions_xbox(ulong offerID, byte countryID,
            string billingOfferID, int priceWhole, int priceFractional, short specificOfferDetails)
        {
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcInsertOfferRegions(
                        //  ISpilConnectionManager scm,
                        //  SqlInt64 bi_offer_id,
                        //  SqlByte ti_country_id,
                        //  string vc_billing_offer_id,
                        //  SqlInt32 i_price_whole,
                        //  SqlInt32 i_price_fractional,
                        //  SqlInt16 si_specific_offer_details)
                        //
                        try
                        {
                            int[] results = so.SvcInsertOfferRegions(scm
                                , (long)offerID
                                , countryID
                                , billingOfferID
                                , priceWhole
                                , priceFractional
                                , specificOfferDetails
                                );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }

        //p_svc_insert_offer_services
        static void p_svc_insert_offer_services_xbox(ulong offerID, int siteID)
        {
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcInsertOfferServices(
                        //  ISpilConnectionManager scm,
                        //  SqlInt64 bi_offer_id,
                        //  SqlInt32 i_site_id)
                        //
                        try
                        {
                            int[] results = so.SvcInsertOfferServices(scm
                                , (long)offerID
                                , siteID
                                );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }

        //p_svc_insert_title_update_packages 
        static void p_svc_insert_title_update_packages_xbox(uint titleID,
            int titleBaseVersion, int titleUpdateVersion, int packageSize, int installSize,
            byte[] symKey, byte[] publicKey)
        {
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcInsertTitleUpdatePackages(
                        //  ISpilConnectionManager scm,
                        //  SqlInt32 i_title_id,
                        //  SqlInt32 i_title_base_version,
                        //  SqlInt32 i_title_update_version,
                        //  SqlInt32 i_package_size,
                        //  SqlInt32 i_install_size,
                        //  SqlBinary vb_update_sym_key,
                        //  SqlBinary vb_public_key,
                        //  SqlBinary b_content_id) {
                        //
                        try
                        {
                            int[] results = so.SvcInsertTitleUpdatePackages(scm
                                , (int)titleID
                                , titleBaseVersion
                                , titleUpdateVersion
                                , packageSize
                                , installSize
                                , symKey
                                , publicKey
                                , SqlBinary.Null
                                , SqlByte.Null
                                );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }

        //p_svc_insert_title_versions  
        static void p_svc_insert_title_versions(uint titleID,
            int titleBaseVersion, int titleNewVersion, int versionFlag)
        {
            //        public virtual int[] SvcInsertTitleVersions(ISpilConnectionManager scm, SqlInt32 i_title_id, SqlInt32 i_base_version, SqlInt32 i_new_version, SqlInt32 i_version_flag) {
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcInsertTitleVersions(
                        //  ISpilConnectionManager scm,
                        //  SqlInt32 i_title_id,
                        //  SqlInt32 i_base_version,
                        //  SqlInt32 i_new_version,
                        //  SqlInt32 i_version_flag) {
                        //
                        try
                        {
                            int[] results = so.SvcInsertTitleVersions(scm
                                , (int)titleID
                                , titleBaseVersion
                                , titleNewVersion
                                , versionFlag
                                , SqlByte.Null
                                );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }

        //p_svc_insert_subscriptions, in the same order as the procedure..  ONLY USE IT FOR XBOX
        static void p_svc_insert_subscriptions_xbox(uint titleID, ulong offerID, ushort esrb,
            bool cancelable, int packageSize, int installSize, byte[] symKey,
            int bitFilter, string billingSvcComponentID, int offerType, int offerFrequency,
            DateTime startDate, DateTime endDate, string friendlyName, byte[] pubKey, uint policyFlags,
            uint globalOfferDetails)
        {
            p_svc_insert_subscriptions_EX(new[] { titleID }, offerID, esrb,
            cancelable, packageSize, installSize, symKey,
            bitFilter, billingSvcComponentID, offerType, offerFrequency,
            startDate, endDate, friendlyName, pubKey, policyFlags,
            globalOfferDetails, ConsoleTypeEnum.Xbox1);
        }

        //p_svc_insert_subscriptions, in the same order as the procedure..  ONLY USE IT FOR XBOX
        static void p_svc_insert_subscriptions_EX(uint[] titleIDs, ulong offerID, ushort esrb,
            bool cancelable, int packageSize, int installSize, byte[] symKeyIn,
            int bitFilter, string billingComponentID, int offerType, int offerFrequency,
            DateTime startDate, DateTime endDate, string friendlyName, byte[] pubKeyIn, uint policyFlags,
            uint globalOfferDetails, ConsoleTypeEnum consoleType)
        {
            byte[] symKey = (symKeyIn == null ? new byte[16] : symKeyIn);
            byte[] publicKey = (pubKeyIn == null ? new byte[284] : pubKeyIn);

            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        //  public virtual int[] SvcInsertSubscriptionsMultiTitle(
                        //      ISpilConnectionManager scm,
                        //      SqlXml xml_title_ids,
                        //      SqlInt64 bi_offer_id,
                        //      SqlInt32 i_ESRB_id,
                        //      SqlByte b_cancelable,
                        //      SqlInt32 i_package_size,
                        //      SqlInt32 i_install_size,
                        //      SqlBinary vb_sym_key,
                        //      SqlInt32 i_bitfilter,
                        //      string vc_billing_svc_component_id,
                        //      SqlInt32 i_offer_type_id,
                        //      SqlInt32 i_offer_frequency_id,
                        //      SqlDateTime dt_start_date,
                        //      SqlDateTime dt_end_date,
                        //      string vc_friendly_name,
                        //      SqlBinary vb_public_key,
                        //      SqlInt32 i_policy_flags,
                        //      SqlInt16 si_global_offer_details,
                        //      SqlByte ti_console_type_id)
                        //
                        try
                        {
                            int[] results = so.SvcInsertSubscriptionsMultiTitle(scm
                                , MarshalToXml(titleIDs)
                                , (long)offerID
                                , (short)esrb // i_ESRB_id : legacy
                                , (byte)(cancelable ? 1 : 0) // b_cancelable : legacy
                                , packageSize // i_package_size : not applicable to subscription offers
                                , installSize // i_install_size : not applicable to subscription offers
                                , symKey // not applicable to subscription offers
                                , (int)bitFilter
                                , billingComponentID
                                , offerType
                                , offerFrequency // i_offer_frequency_id : legacy
                                , startDate // dt_start_date : legacy
                                , endDate // dt_end_date : legacy
                                , friendlyName
                                , publicKey // not applicable to subscription offers
                                , (int)policyFlags
                                , (short)globalOfferDetails
                                , (byte)consoleType
                                );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }

        static SqlXml MarshalToXml(uint[] values)
        {
            var builder = new StringBuilder();

            // N.B. conversion to int before serialization
            foreach (int value in values)
            {
                builder.AppendFormat("<item value='{0}'/>", value);
            }

            return new SqlXml(new MemoryStream(Encoding.ASCII.GetBytes(builder.ToString())));
        }

        //p_svc_insert_content
        //p_svc_insert_content_locations

        #endregion

    }


    public class OfferPrivilegeGrants : OfferPrivileges
    {
        public OfferPrivilegeGrants()
            : base()
        {
        }

        public OfferPrivilegeGrants(uint[] privileges)
            : base(privileges)
        {
        }

        override public string StoredProcedure
        {
            get { return "dbo.p_svc_insert_offer_privileges"; }
        }
    }

    public class OfferPrivilegeRestrictions : OfferPrivileges
    {
        public OfferPrivilegeRestrictions()
            : base()
        {
        }

        public OfferPrivilegeRestrictions(uint[] privileges)
            : base(privileges)
        {
        }

        override public string StoredProcedure
        {
            get { return "dbo.p_svc_insert_offer_privilege_restrictions"; }
        }
    }

    public abstract class OfferPrivileges
    {
        /*

        Privileges are stored as single bits in a field of 256 bits.  Bits are stored
        with the high bits being stored in the first of the 32 bytes in the array,
        and so on.

        */

        public const int NUM_PRIVILEGE_BITS = 256;
        public const int NUM_PRIVILEGE_DWORDS = NUM_PRIVILEGE_BITS / 32;

        public OfferPrivileges()
        {
            m_privileges = new uint[NUM_PRIVILEGE_DWORDS];

            for (int i = 0; i < NUM_PRIVILEGE_DWORDS; i++)
                m_privileges[i] = 0;
        }

        public OfferPrivileges(uint[] privileges)
        {
            if (privileges.Length != NUM_PRIVILEGE_DWORDS)
                throw new Exception("Expecting exactly " + NUM_PRIVILEGE_DWORDS + " privilege bytes");

            m_privileges = privileges;
        }

        public override string ToString()
        {
            // generates a string of 0's and 1's which represent the 256 privileges
            // the first 1 or 0 corresponds to privilege #0, and so on...

            StringBuilder privileges = new StringBuilder(NUM_PRIVILEGE_BITS);

            for (int i = 0; i < NUM_PRIVILEGE_BITS; i++)
            {
                if (this[i] == true)
                    privileges.Append('1');
                else
                    privileges.Append('0');
            }

            return privileges.ToString();
        }

        public void Save(ulong offerID)
        {
            using (WstConnection c = new WstConnection(ConfigUtil.UodbWebstoreApp))
            {
                c.Open();

                for (int partition = 0; partition < c.SqlPartitions.Count; partition++)
                {
                    using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
                    {
                        ws.PhysicalPartition = partition;
                        ws.StoredProc = this.StoredProcedure;

                        ws.AddParameter(ParamType.RETVAL, "@ret", 0);
                        ws.AddParameter(ParamType.INPUT, "@bi_offer_id", offerID);
                        ws.AddParameter(ParamType.INPUT, "@vc_privileges", this.ToString(), NUM_PRIVILEGE_BITS);

                        ws.ExecuteNonQuery();

                        uint hr = (uint)ws.GetIntParameter("@ret");
                        if (HResult.Failed(hr))
                        {
                            string msg = ws.GetCallSignature() + " failed with hr = 0x" + hr.ToString("x");

                            throw new XRLException(hr, XEvent.Id.COMMON_CODE_145, msg);
                        }

                        Console.WriteLine();
                        Console.WriteLine(ws.GetCallSignature());
                    }
                }
            }
        }

        public bool this[int index]
        {
            // get or set individual bits within the privilege set

            get
            {
                uint ul = m_privileges[index / 32];
                uint mask = (uint)1 << (index % 32);

                return (ul & mask) == mask;
            }

            set
            {
                uint ul = m_privileges[index / 32];
                uint mask = (uint)1 << (index % 32);

                if (value == true)
                    ul = ul | mask;
                else
                    ul = ul & ~mask;

                m_privileges[index / 32] = ul;
            }
        }

        public uint[] ToArray()
        {
            return m_privileges;
        }

        uint[] m_privileges;

        public abstract string StoredProcedure
        {
            get;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveTitle\titlesuitecommon\XSCLeaderboard.cs ===
using System;
using System.Collections;

namespace Microsoft.Ems.Tools.LiveTitle
{
    public class XscLeaderboard
    {
        /// <summary>
        /// Extract leaderboards of type 'individual' from the XSC file for the given titleID
        /// </summary>
        /// <param name="xscPath">Path of XSC file to be read</param>
        /// <param name="titleID">titleID of title for which leaderboards need to be extracted</param>
        /// <returns>ArrayList of LeaderboardSettings objects</returns>
        public static ArrayList GetXSCLeaderboardConfiguration( string xscPath, uint titleID )
        {
            //task: refactor to move this code out of "framework", into common/xscutil, remove log dependency
            CLog log = new CLog();
            CXsc xsc = new CXsc(xscPath,log); // taken from titlemgr code

            ArrayList leaderboardList = new ArrayList();
            uint[] lbIds;

            // Extract regular leaderboards from the XSC file
            lbIds = xsc.LBGetList();
            foreach (uint lbId in lbIds)
            {
                LeaderboardSettings lb = ExtractLeaderboard( xsc, titleID, lbId, LbType.Regular);
                leaderboardList.Add(lb);
            }

            // Extract competition leaderboards from the XSC file
            lbIds = xsc.CompGetList();
            foreach (uint lbId in lbIds)
            {
                LeaderboardSettings lb = ExtractLeaderboard( xsc, titleID, lbId, LbType.Competition);
                leaderboardList.Add(lb);
            }

            // return array of LeaderboardSettings objects
            return leaderboardList;
        }


        public static Hashtable GetXSCLeaderboardValueFormats( string xscPath )
        {
            CLog log = new CLog();
            CXsc xsc = new CXsc(xscPath,log); // taken from titlemgr code

            // Extract leaderboard IDs from the XSC file
            uint[] indLBIDs = xsc.LBGetList(); // Get leaderboards of type 'individual'

            // hashtable, key=lbID, value=SortedList of attributes
            Hashtable rawAttribs = new Hashtable();

            // Add each leaderboard of type 'individual' to the leaderboardList
            for ( int i = 0; i < indLBIDs.Length; i++ )
            {
                // Get LB ID
                int iLb = (int)indLBIDs[i];

                // LBAttrGetList returns empty list if attributes are not found
                rawAttribs.Add( iLb, xsc.LBValueGetList( (uint)iLb ) );
            }

            return rawAttribs;
        }

        public static LeaderboardSettings ExtractLeaderboard( CXsc xsc, uint titleID, uint lbId, LbType type )
        {
            ELBReset lbReset=0;
            uint uiAttachCount=0, uiMaxAttachSize=0, uiDecayDays=0, uiMaxRatingCount=0;
            bool bRequireArbitration=false, bIsTeam=false;
            int topEntries = 100;
            CELOConfig eloConfig = new CELOConfig();

            // For each LBConfig values, fill up a new LeaderboardSettings object

            //task: figure out maxRatCount and "top entries" retrieve different values from same XML ...
            //NOTE: topEntries and uiMaxRatingCount pull from the same XML element, they just
            //      do different transformations.  We use TopEntries, since it's correct.
            bool ret;
            if (type == LbType.Regular)
            {
                ret = xsc.LBConfigGet(
                    lbId,
                    ref lbReset,
                    ref uiAttachCount,
                    ref uiMaxAttachSize,
                    ref uiDecayDays,
                    ref uiMaxRatingCount,
                    ref bRequireArbitration,
                    ref bIsTeam,
                    ref topEntries,
                    ref eloConfig);
            }
            else
            {
                ret = xsc.CompConfigGet(
                    lbId,
                    ref lbReset,
                    ref uiAttachCount,
                    ref uiMaxAttachSize,
                    ref uiDecayDays,
                    ref bRequireArbitration,
                    ref bIsTeam,
                    ref eloConfig);

            }

            if (!ret)
            {
                throw new Exception("Could not get Leaderboard configuration for Leaderboard ID " + lbId);
            }

            LeaderboardSettings lbSettings = new LeaderboardSettings();
            lbSettings.Type = type;
            lbSettings.Arbitrated = bRequireArbitration;
            lbSettings.DecayDays = (int)uiDecayDays;
            lbSettings.LastReset = DateTime.UtcNow;
            lbSettings.LBServer = "";
            lbSettings.LeaderboardID = (int)lbId;
            lbSettings.MaxAttachments = (int)uiAttachCount;
            lbSettings.MaxAttachmentSize = (int) uiMaxAttachSize;
            lbSettings.ResetType = (byte)lbReset;
            lbSettings.TeamView = bIsTeam;
            lbSettings.TitleID = titleID;
            lbSettings.TopEntries = topEntries;


            //
            // ELOConfig
            //

            // ELOCtable
            // Concatenate ELO rating values in a string from the CELOMaxWeightRatingRange[] array
            string sEloCtable = ""; // CTable string to supply to sproc
            foreach(CELOMaxWeightRatingRange rating in eloConfig.rgMaxWeightRatings)
            {
                sEloCtable += rating.uiStart.ToString() + ":" + rating.uiMaxWeight.ToString() + ",";
            }

            // Remove last comma
            if (sEloCtable != "") sEloCtable = sEloCtable.Remove(sEloCtable.Length-1,1);
            // Now that we have the string, set it in the object
            if (sEloCtable != "")
                lbSettings.EloCtable = sEloCtable;
            else
                lbSettings.EloCtable = "0:40"; // default value

            // EloE - exponentialBase
            //
            if (eloConfig.exponentialBase == EELOExponentialBase.e)
                lbSettings.EloE = "E";
            else
                lbSettings.EloE = "10"; // default value

            // EloK - RatingScaleFactor
            //
            if ((int)eloConfig.uiRatingScaleFactor > 0)
                lbSettings.EloK = (int)eloConfig.uiRatingScaleFactor;
            else
                lbSettings.EloK = 100; // default value

            // EloNew - InitialPlayerRating
            //
            if ((int)eloConfig.uiInitialPlayerRating > 0)
                lbSettings.EloNew = (int)eloConfig.uiInitialPlayerRating;
            else
                lbSettings.EloNew = 500; // default value;


            //
            // webdb config
            //

            // leaderboard descriptions
            SortedList sl = xsc.LBDescGetList( lbId );
            lbSettings.Descriptions = new LocalizedDescription[sl.Count];
            for (int i = 0; i < sl.Count; i++)
            {
                lbSettings.Descriptions[i] = new LocalizedDescription();
                lbSettings.Descriptions[i].Locale = (string)sl.GetKey(i);
                lbSettings.Descriptions[i].Description = (string)sl.GetByIndex(i);
            }

            // raw attributes
            sl = xsc.LBAttrGetList( lbId );
            lbSettings.RawAttributes = new RawAttribute[sl.Count];
            for (int i = 0; i < sl.Count; i++)
            {
                lbSettings.RawAttributes[i] = new RawAttribute();
                lbSettings.RawAttributes[i].Index = (int)(uint)sl.GetKey(i);
                lbSettings.RawAttributes[i].IsPuid = (bool)sl.GetByIndex(i);
            }


            // formats
            string[] names = xsc.LBValueGetList( lbId );
            lbSettings.Columns = new LbColumn[names.Length];

            for (int i = 0; i < names.Length; i++)
            {
                LbColumn col = new LbColumn();
                col.Name = names[i];

                EWebValueReturnType returnType = EWebValueReturnType.String;

                xsc.LBValueGet(lbId, names[i], ref returnType, ref col.Formula);
                col.ReturnType = (int)returnType;

                sl = xsc.LBValueDescGetList(lbId, names[i]);
                col.Descriptions = new LocalizedDescription[sl.Count];

                for (int j = 0; j < col.Descriptions.Length; j++)
                {
                    col.Descriptions[j] = new LocalizedDescription();
                    col.Descriptions[j].Locale = (string)(sl.GetKey(j));
                    col.Descriptions[j].Description = (string)(sl.GetByIndex(j));
                }

                lbSettings.Columns[i] = col;
            }

            return lbSettings;
        }
/*
        /// <summary>
        /// Extract competition templates from the XSC file for the given titleID
        /// </summary>
        /// <param name="xscPath">Path of XSC file to be read</param>
        /// <param name="titleID">titleID of title for which templates need to be extracted</param>
        /// <returns>ArrayList of LeaderboardSettings objects</returns>
        public static ArrayList GetXSCCompetitionConfiguration( string xscPath, uint titleID )
        {
            //task: refactor to move this code out of "framework", into common/xscutil, remove log dependency
            CLog log = new CLog();
            CXsc xsc = new CXsc(xscPath,log); // taken from titlemgr code

            ArrayList leaderboardList = new ArrayList();

            // Extract leaderboards of type 'competitions'
            uint[] compLBIDs = xsc.CompGetList();
            ExtractCompetitionTemplates( titleID, compLBIDs, leaderboardList, xsc );

            // return array of LeaderboardSettings objects
            return leaderboardList;
        }
    */

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveTitle\toolsframework\CServer.cs ===
using System;
using System.Net;
using System.Text;

namespace Microsoft.Ems.Tools.LiveTitle
{
    /// <summary>
    /// A simple class that encapsulates an array of IP addresses that can be
    /// used to contact a particular server. A server is not limited to only one
    /// IP address, and we take advantage of that fact in our production data
    /// center by configuring each server with two IP addresses, each of which
    /// is routed through a separate switch. This, if all our code is written correctly,
    /// allows us to fail over gracefully if one switch fails, because there is still
    /// a completely independant route in operation. Therefore, when we want
    /// to identify a server in the tools framework, we use this class instead of
    /// using the IP directly. We also, for good measure, put the server name
    /// in this class.
    /// </summary>
    public class CServer
    {
        public string sServerName;
        public IPAddress[] rgipAddresses;

        public CServer()
        {
            sServerName = null;
            rgipAddresses = null;
        }

        public CServer(
            string _sServerName,
            IPAddress[] _rgipAddresses)
        {
            sServerName = _sServerName;
            rgipAddresses = _rgipAddresses;
        }

        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("{");
            sb.Append(sServerName == null ? "null" : sServerName);
            sb.Append(",");
            sb.Append(rgipAddresses == null ? "null" : CLog.CollectionToString(rgipAddresses));
            sb.Append("}");
            return sb.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveTitle\tools\CheckReady.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.IO;

using Microsoft.Webstore.WstClient;
using Microsoft.Ems.Tools.LiveTools.Common;
using xonline.common.config;

namespace Microsoft.Ems.Tools.LiveTitle
{
	/// <summary>
	/// Hopefully, this will be the last time we write a class to check this sort of stuff... 
	/// </summary>
    public class CheckReady
    {

        // since environment checks are fairly application specific,
        // anyone else who wants to use CheckReady should subclass it
        // and change the implementation of CheckReadyMain
        // Please feel free to add other checks which need to be added
        // added command line output. remove it for server uses.. 
        public static bool CheckReadyMain( NamedArgParser parsedArgs, out string results )
        {

            bool checkResult = true;

            results = "";               //printed at the end for summary of all tests
            string testResult = "";     //printed as the cumulative details of each test

            Console.WriteLine( "\nChecking if tool can read input file: " + parsedArgs[ "inputfile" ] );
            // confirm input file can be read from
            if ( ( parsedArgs[ "inputfile" ] != null ) && CheckReadFile( parsedArgs[ "inputfile" ] ) )
            {
                // everything's working!
                results += "\r\n    Tool is able to find and read the input file.";
            }
            else
            {
                // houston, we have a problem
                checkResult = false;
                // write error to result string
                results += "\r\n!!  Tool is not able to find read the input file!";
            }

            // confirm sps
            // SPS Test Connection
            Console.WriteLine( "Checking SPS Connectivity....." );
            if ( CheckSPS() )
            {
                // everything's working!
                results += "\r\n    Tool is able to connect to SPS.";
            }
            else
            {
                // houston, we have a problem... 
                results += "\r\n!!  Tool is not able to connect to SPS!";
                checkResult = false;
            }
            
            // confirm uodb
            Console.WriteLine( "Checking connectivity to Webstore UODB ....." );
            if ( CheckWebstore( ConfigUtil.UodbWebstoreApp ) )
            {
                // everything's working!
                results += "\r\n    Tool is able to connect to UODB.";
            }
            else
            {
                // houston, we have a problem... 
                results += "\r\n!!  Tool is not able to connect to UODB!";
                checkResult = false;
            }

            string connectionString = "Data Source=" +  parsedArgs[ "serialsql" ] + ";Trusted_Connection=Yes;Initial Catalog=" + parsedArgs[ "serialdb" ];
            // confirm SerialDB
            Console.WriteLine( "Checking connectivity to SerialDB ....." );
            if ( CheckDB( connectionString, ref testResult ) )
            {
                // everything's working!
                results += "\r\n    Tool is able to connect to SerialDB!";
            }
            else
            {
                // houston, we have a problem... 
                results += "\r\n!!  Tool is not able to connect to SerialDB!";
                checkResult = false;
            }
            results += testResult;

            return checkResult;

        }

	//
        public static bool ParamCheck( NamedArgParser args, string argName, bool console)
        {
            //if arg doesn't exist, return false
            if ( args[ argName ] == null )
            {
		        if ( console )
                {
                    Console.WriteLine( "==> {0} Parameter must be supplied.", argName );
                }

                //Xom.Trace(XomAreaName.checkready, LogLevel.L_WARNING, "Parameter " + argName + " was null." );

                return false;
            }
            else
            {
                return true;
            }
        }

        //task: should change this to write to Auditdb, or log, or have OUT string param, not REF 
        public static bool CheckDB( string connection, ref string dbResults )
        {

            bool check = false; 

            try  
            {
                using (SqlConnection checkConn = new SqlConnection( connection ) )
                {
                    //results = "Open connection to " + connection + "\r\n";
                    checkConn.Open();
                    //results += "Connection opened\r\n";
                    SqlCommand checkCmd = checkConn.CreateCommand();
                    checkCmd.CommandType = CommandType.Text;
                    checkCmd.CommandText = "select top 1 * from sysobjects";

                    //results += "Executing command \r\n";
                    SqlDataReader checkReader = checkCmd.ExecuteReader();

                    // do we have results?
                    if ( checkReader.Read() )
                    {
                        dbResults += "Connection Successful.\r\n";
                        check = true;
                    }
                    else
                    {
                        dbResults += "Error: Returning results from connection failed.\r\n";
                        check = false;
                    }
                } //using

            } // try
            catch (Exception e)
            {   
                dbResults += "\nError: Exception occurred: \n" + e.ToString();         
                check = false;
            }

            return check;
        }


        public static bool CheckWriteFile( string filePath )
        {
            bool result = false;

            try
            {
                // Can we write to the output file location?
                using (StreamWriter textFile = new StreamWriter(filePath, true, System.Text.Encoding.UTF8))
                {
                    textFile.AutoFlush = true;

                    // write to file, just a space
                    textFile.Write(" ");

                    // flush
                    textFile.Flush();
                    textFile.Close();
                }

                // check file existence
                if ( File.Exists( filePath ) )
                {
                    result = true;
                }
            } // try
            catch ( Exception e )
            {
                Console.WriteLine("An error occurred writing to the file: \r\n" + filePath + e.Message + "\r\n\r\n" + e.StackTrace  );
                result = false;
            }
            
            return result;
        } // checkwritefile

        public static bool CheckReadFile( string filePath )
        {
            
            bool result = false;

            // Can we read from file location?
            try
            {
                using (StreamReader textFile = new StreamReader( filePath, System.Text.Encoding.UTF8 ))
                {
                    // check file existence
                    if (System.IO.File.Exists(filePath))
                    {
                        // test read
                        int nextChar = textFile.Peek();
                        if (nextChar == -1)
                        {
                            // end of file
                        }
                        result = true;
                        textFile.Close();
                    }
                }

            } // try

            catch ( Exception e )
            {
                Console.WriteLine("An error occurred reading from the file: \r\n" + filePath + e.Message + "\r\n\r\n" + e.StackTrace  );
                result = false;
            }
            
            return result;

        } // checkwritefile

        public static bool CheckSPS( )
        {
            // TODO (marthare) : can we remove call to TestSPSConnection()?
            return true;
            //try
            //{
            //    // figure out what this should be
            //    UserBillingInfo ubi = new UserBillingInfo();
            //    return ( ubi.TestSPSConnection() );
            //}
            //catch (Exception e)
            //{
            //    //task: take some action here
            //    Console.WriteLine( "\nAn error occurred connecting to SPS." );
            //    Console.WriteLine( "Error was " + e.ToString() );
            //    return false;
            //}
        }

        public static bool CheckWebstore( string webstoreApplication )
        {

            bool check = false;

            try
            {
                using (WstConnection checkConn = new WstConnection( webstoreApplication ) )
                {
                
                    checkConn.Open();
                    WstCommand checkCmd = checkConn.CreateCommand();
                    checkCmd.CommandType = CommandType.Text;

                    checkCmd.Partition = WstCommand.AnyPartition;
                
                    checkCmd.CommandText = "select top 1 * from sysobjects";

                    WstDataReader wr = checkCmd.ExecuteReader();

                    // Load voucheroffers info 
                    if ( wr.Read() )
                    {
                        check = true;
                    }
                    else
                    {
                        check = false;
                    }

                } // using

            } // try
            catch (Exception e)
            {
                //task: take some action here
                Console.WriteLine( "\nAn error occurred connecting to " + webstoreApplication );
                Console.WriteLine( "Error was " + e.ToString() );
                check = false;
            }

            return check;
        }

        //check whether the root exists and can be written to / read from
        public static bool CheckTitleVault( )
        {
            bool check = true;

            try
            {
                //get config
                string vaultPath = Config.GetSetting( Setting.titlevault_root );

                //confirm titevault_root setting is not INVALID  value != "INVALID" 
                if ( vaultPath.IndexOf( "INVALID" ) >= 0 )
                {
                    return false;
                }

                //check
                check = Directory.Exists( vaultPath );
                
                string testPath = vaultPath + "\\" + "Checkready_" + Environment.MachineName + "_" + Guid.NewGuid().ToString() + ".txt";
                
                if ( File.Exists( testPath ) )
                {
                    File.Delete( testPath );
                }

                if ( CheckWriteFile( testPath ) )
                {
                    if ( CheckReadFile( testPath ) )
                    {
                        File.Delete( testPath );
                    }
                    else
                    {
                        check = false;
                    }
                }
                else
                {
                    check = false;
                }
           
            }
            catch
            {
                check = false;
            }
            
            return check;

        }

    } // class checkready
} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveTitle\toolsframework\CLocale.cs ===
using System;

namespace Microsoft.Ems.Tools.LiveTitle
{
    /// <summary>
    /// This class encapsulates a locale, and provides operations for 
    /// representing that locale in various formats relevant to Xbox Live.
    /// Once constructed, an object of this class is immutable.
    /// </summary>
    public class CLocale
    {
        // internally store the locale in enum form, then use the array
        // below to get the string when it is needed
        private string m_sLocale;
        //private ELocale m_enumLocale;

        /// <summary>
        /// An array to map locale strings to enum values.
        /// The ordering of this array is significant, because it is intended that you 
        /// can use the enum value to index the array to come up with the right
        /// string for that locale.
        /// This is protected to make unit testing easier.
        /// </summary>
        protected static string[] m_rgsLocaleStringMapping =
        {
            "da-DK",
            "de-AT",
            "de-CH",
            "de-DE",
            "en-AU",
            "en-CA",
            "en-IE",
            "en-GB",
            "en-SG",
            "en-US",
            "es-ES",
            "fi-FI",
            "fr-BE",
            "fr-CA",
            "fr-CH",
            "fr-FR",
            "it-IT",
            "ja-JP",
            "ko-KR",
            "nb-NO",
            "nl-BE",
            "nl-NL",
            "sv-SE",
            "zh-HK",
            "zh-TW",
        };

        /// <summary>
        /// Checks to see if the string passed to the function 
        /// is a valid supported locale string.
        /// </summary>
        /// <param name="enumLocale">
        /// The string to be tested.
        /// </param>
        public static bool IsSupported(string sLocale)
        {
            // the constructor already has this logic, so just wrap it
            try
            {
                CLocale loc = new CLocale(sLocale);
                return true;
            }
            catch (InvalidLocaleException)
            {
                return false;
            }
        }

        public static CLocale[] SupportedList()
        {
            CLocale[] rgLoc = new CLocale[m_rgsLocaleStringMapping.Length];
            for (int i = 0; i < m_rgsLocaleStringMapping.Length; ++i)
            {
                rgLoc[i] = new CLocale(m_rgsLocaleStringMapping[i]);
            }
            return rgLoc;
        }

        /// <summary>
        /// Creates a locale object given a string representing a locale
        /// </summary>
        /// <param name="sLocale">
        /// The locale, in string form, that this object represents.
        /// </param>
        /// <exception cref="InvalidLocaleException">
        /// Thrown if sLocale does not represent a supported locale
        /// </exception>
        public CLocale(string sLocale)
        {
            for (int i = 0; i < (int)m_rgsLocaleStringMapping.Length; ++i)
            {
                if (sLocale == m_rgsLocaleStringMapping[i])
                {
                    m_sLocale= m_rgsLocaleStringMapping[i];
                    return;
                }
            }
            // if we get here, the locale string was not found
            // in the locale string array
            throw new InvalidLocaleException(
                "Invalid locale string '"
                + sLocale
                + "' passed to TitleMgr.CLocale.CLocale(string)");
        }

        /// <summary>
        /// Gets the locale in string format, for example "en-US" for US English
        /// </summary>
        public override string ToString()
        {
            return m_sLocale;
        }

    }

    public class InvalidLocaleException : ApplicationException
    {
        public InvalidLocaleException() : base() {}
        public InvalidLocaleException(string s) : base(s) {}
        protected InvalidLocaleException(
            System.Runtime.Serialization.SerializationInfo si,
            System.Runtime.Serialization.StreamingContext sc
        ) : base(si, sc) {}
        public InvalidLocaleException(string s, Exception e) : base(s, e) {}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveTitle\toolsframework\CLog.cs ===
using System;
using System.IO;
using System.Text;
using System.Data;
using System.Data.SqlClient;
using System.Collections;

namespace Microsoft.Ems.Tools.LiveTitle 
{
    /// <summary>
    /// The existing titlemgr code base uses simple WriteLine and WriteLineV members 
    /// of the CTitleMgr class to write log lines to the console, file, and event log. Unfortunately,
    /// these functions rely on globals, which messes up my unit testing. Therefore, my new
    /// code is designed to be passed a logging object, either CLog or a decendant. CLog implements
    /// a simple wrapper around Console.WriteLine, which is exactly what I want for unit testing,
    /// as well as serving as a place to collect useful logging functions such as SqlCommandToString,
    /// that encapsulate the intelligence to crack and log more complex object types.
    /// </summary>
    public class CLog
    {
        // log level conventions:
        // 
        // level 1 - "CONSOLE" - end user level output, in console apps, expected to go to stdout
        //           messages generally shouldn't be prefixed with class name & method
        //           unless they are unexpected errors that indicate bugs. To make it easy
        //           to search for errors and warnings in scripts, try to prefix messages 
        //           with "Error: " and "Warning: " when appropriate.
        //
        // level 2 - "LOGFILE" - useful information for a normal verbosity log file,
        //           When a library function encounters an error, it should write a note
        //           to the log at this level and then throw. Somewhere higher in the call
        //           stack the app can choose to output to level 1 if appropriate. Should
        //           be prefixed with class name and method.
        //
        // level 3 - "DATAMOD" - When calling .net functions or other code outside the framework
        //           that will make changes to persistent data such as files on disk or rows
        //           in database, log those operations using this level. Should be prefixed with class
        //           name and method.
        //
        // level 4 - "DATAMOD2" - Similar to DATAMOD, but used when making changes to in-memory
        //           copies of data that may or may not then be persisted later. For example,
        //           the CRepository class uses this level to log changes made to XmlDocument objects
        //           loaded in memory, but uses the DATAMOD level to note when those changes are
        //           actually comitted to disk
        //
        // level 5 - "STACKTRACE" - Should log all unction entries and exits to public methods of framework
        //           classes at this level. No need to log entry and exit of private methods.
        //           Should log parameters passed, and return value, if its a simple type.
        //           Should prefix with 
        //
        // level 6 - "FULLTRACE" - anything and everything. Prefix with class name and method.
        //           this is full on debugging info. You should be able to figure out exactly
        //           what code path was run at this level.

        public const int CONSOLE = 1;
        public const int LOGFILE = 2;
        public const int DATAMOD = 3;
        public const int DATAMOD2 = 4;
        public const int STACKTRACE = 5;
        public const int FULLTRACE = 6;

        private int m_iLevel = CONSOLE;

        public int Level
        {
            get
            {
                return m_iLevel;
            }
            set
            {
                m_iLevel = value;
            }
        }

        // Generic function - overloaded by derived classes.
        // This default implementation just outputs to the system console with 
        // a level prefix
        virtual protected void WriteLine(int iLevel, string s)
        {
            if (m_iLevel >= iLevel)
            {
                System.Console.WriteLine(LevelPrefix(iLevel)+s);
                System.Console.Out.Flush();
            }
        }

        protected string LevelPrefix(int iLevel)
        {
            switch (iLevel)
            {
                case CONSOLE:
                    return "[1]|";

                case LOGFILE:
                    return "  [2]|";

                case DATAMOD:
                    return "    [3]|";

                case DATAMOD2:
                    return "      [4]|";

                case STACKTRACE:
                    return "        [5]|";

                case FULLTRACE:
                    return "          [6]|";

                default:
                    return "["+iLevel+"]|";
            }
        }

        // Useful wrappers
        public void Console(string s)
        {
            WriteLine(CONSOLE, s);
        }
        public void LogFile(string s)
        {
            WriteLine(LOGFILE, s);
        }
        public void DataMod(string s)
        {
            WriteLine(DATAMOD, s);
        }
        public void DataMod2(string s)
        {
            WriteLine(DATAMOD2, s);
        }
        public void StackTrace(string s)
        {
            WriteLine(STACKTRACE, s);
        }
        public void FullTrace(string s)
        {
            WriteLine(FULLTRACE, s);
        }

        // aliases for compatibility with titlemgr code
        public void WriteLineV(string s)
        {
            FullTrace(s);
        }

        public void WriteLine(string s)
        {
            Console(s);
        }

        public static string CollectionToString(ICollection collection)
        {
            if (collection == null)
            {
                return "null";
            }
            StringBuilder sb = new StringBuilder();
            sb.Append("{");
            IEnumerator enumerator = collection.GetEnumerator();
            bool bNext = enumerator.MoveNext();
            while (bNext)
            {
                sb.Append(enumerator.Current == null ? "null" : enumerator.Current.ToString());
                bNext = enumerator.MoveNext();
                if (bNext)
                {
                    sb.Append(",");
                }
            }
            sb.Append("}");
            return sb.ToString();
        }

        public static string SqlCommandToString(SqlCommand sqlCommand)
        {
            if (sqlCommand == null)
            {
                throw new ArgumentNullException("sqlCommand");
            }

            if (sqlCommand.CommandText == null || sqlCommand.CommandText.Length == 0)
            {
                return "SqlCommand.CommandText is empty";
            }

            switch (sqlCommand.CommandType)
            {
            case CommandType.Text:
                return sqlCommand.CommandText;

            case CommandType.StoredProcedure:
                StringBuilder sb = new StringBuilder();
                sb.Append(sqlCommand.CommandText);
                foreach (SqlParameter sParam in sqlCommand.Parameters)
                {
                    sb.Append(" ");
                    sb.Append(sParam.ParameterName);
                    sb.Append("=");
                    if (sParam.Value == null)
                    {
                         sb.Append("null");
                    }
                    else
                    {
                        sb.Append(sParam.Value.ToString());
                    }
                }
                sb.Append(" CommandTimeout="+sqlCommand.CommandTimeout);
                return sb.ToString();

            default:
                return "Unknown SqlCommand.CommandType. SqlCommand.CommandText is: " + sqlCommand.CommandText;
            }
        }
    }

    /// <summary>
    /// Instead of checking for a null log reference everywhere we write to the log, instead, when we detect a null 
    /// log reference, we set that reference to CLogNull - this effectively disables logging without having to protect
    /// each log writing statement with an if (null) clause.
    /// </summary>
    public class CLogNull : CLog
    {
        protected override void WriteLine(int iLevel, string s)
        {
            // do nothing
            return;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveTitle\toolsframework\EWebValueReturnType.cs ===
namespace Microsoft.Ems.Tools.LiveTitle
{
    /// <summary>
    /// An Enum that can be used to specify the return type of a formatted attribute.
    /// </summary>
    public enum EWebValueReturnType
    {
        // reference private\webcache\stats\dll\stats.cs enum AttributeUnit for the ordering
        // on this enum
        Integer = 0,
        Float = 1,
        Percent = 2,
        Gamertag = 3,
        Timestamp = 4,
        Millisecond = 5, // xlast "legacy stats" does not use plural
        Milliseconds = 5, // but xlast "v3 stats" does <sigh>
        TenMillisecond = 6,
        TenMilliseconds = 6,
        HundredMillisecond = 7,
        HundredMilliseconds = 7,
        Second = 8,
        Seconds = 8,
        Minute = 9,
        Minutes = 9,
        Hours= 10,
        Days = 11,
        String = 12,
        Team = 13
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveTitle\livetitle.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Reflection;
using System.Text;
using System.Xml;
using Microsoft.Ems.Tools.LiveTools.Common;
using Microsoft.Ems.Tools.LiveTools.Common.Utilities;
using xonline.common.config;
using xonline.common.protocol;
using xonline.common.mgmt;
using xonline.common.livetitleconfig;
using xonline.common.xlastutil;
using xonline.tools.framework;

namespace Microsoft.Ems.Tools.LiveTitle
{
    /// <summary>
    /// Command line code for the Live Title tool
    /// </summary>
    class LiveTitle
    {
        const int DEFAULT_RELOAD_TIMEOUT = 60000; // 60 seconds
        const string XBOX_SCHEMA_VERSION = "XBOX";
        const string MARKETPLACE_SCHEMA_VERSION = "MARKETPLACE";

        static void Usage()
        {
            Console.WriteLine( "\r\n         L  I  V  E    T  I  T  L  E");
            Console.WriteLine( "\r\n=================================================" );
            Console.WriteLine( "" );
            Console.WriteLine( "Tool to configure a title in the Xbox Live Service " );
            Console.WriteLine( "" );
            Console.WriteLine( "Usage:" );
            Console.WriteLine( "" );
            Console.WriteLine( "    LiveTitle /checkready [/verbose] (confirms database connectivity, TitleVault existence, parameter files exist)" );
            Console.WriteLine( "" );
            Console.WriteLine( "    LiveTitle /livetitledefault /xlastpath:<xlastpath> /lbs:<defaultlbs> /matchsvr:<defaultmatchsvr> [/verbose]");
            Console.WriteLine( "" );
            Console.WriteLine( "    LiveTitle /deploy      /xlastpath:<xlastpath> /ltcpath:<ltcfilepath> /images [</noreload>] [/timeout:millis] [/version:<baseversion>] [/verbose]");
            Console.WriteLine( "" );
            Console.WriteLine( "    LiveTitle /deploy      /marketplacepath:<marketplacepath> /images [</noreload>] [</timeout:millis>] [/verbose]");
            Console.WriteLine( "" );
            Console.WriteLine( "    LiveTitle /xboxdefault /xboxpath:<xboxpath> /xscpath:<xscfilepath> /lbs:<defaultlbs> /matchsvr:<defaultmatchsvr> [/verbose]");
            Console.WriteLine( "" );
            Console.WriteLine( "    LiveTitle /deployxbox  /xboxpath:<xboxpath> /ltcpath:<ltcfilepath> /xscpath:<xscfilepath> [/verbose]");
            Console.WriteLine( "                           /xmspath:<xmsfilepath>  [</noreload>] [</timeout:millis>] [/version:<baseversion>] [/verbose] [/verbose]");
            Console.WriteLine( "" );
            Console.WriteLine( "    LiveTitle /lock        /xlastpath:<xlastpath> [/verbose] [/verbose]");
            Console.WriteLine( "" );
            Console.WriteLine( "    LiveTitle /reportver  /titleid:<titleid> [/verbose]");
            Console.WriteLine( "    LiveTitle /addbasever  /titleid:<titleid> /version:<baseversion> /platform:<platform> [/verbose]");
            Console.WriteLine( "    LiveTitle /delbasever  /titleid:<titleid> /version:<baseversion> /platform:<platform> [/verbose]");
            Console.WriteLine( "" );
            Console.WriteLine( "Definitions:" );
            Console.WriteLine( "    <XLASTPath>         - Full path to an XLAST XML file " );
            Console.WriteLine( "    <LTCPath>           - Full path to a LiveTitleConfig XML file " );
            Console.WriteLine( "    <lbs>               - Default Leaderboard server for this title " );
            Console.WriteLine( "    <matchsvr>          - Default Match server for this title " );
            Console.WriteLine( "    <discid>            - Disc-media id for this title (optional -- default is 0) " );
            Console.WriteLine( "    <titleid>           - Titleid for this title " );
            Console.WriteLine( "    <baseversion>       - Base version of the title being referenced" );
            Console.WriteLine( "    <xboxpath>          - Full path to an Xbox1 configuration XML file " );
            Console.WriteLine( "    <xscpath>           - Full path to an XSC file for xbox1 (Optional) " );
            Console.WriteLine( "    <xmspath>           - Full path to an XMS file for xbox1 (Optional) " );
            Console.WriteLine( "    <noreload>          - Any reload actions are ignored " );
            Console.WriteLine( "    <timeout>           - Controls timeout in milliseconds of network commands " );
            Console.WriteLine( "    <platform>          - Specifies which platform to add the version to." );
            Console.WriteLine( "                          Allowable values are 'Xbox1', 'Xenon' and 'PC' (case insensitive).");
            Console.WriteLine( "" );
            Console.WriteLine( "" );
            Console.WriteLine( "Examples:" );
            Console.WriteLine( "" );
            Console.WriteLine( "    Create a default Live Title Config file from an Xlast file (Do this BEFORE you deploy the Xlast doc)" );
            Console.WriteLine( "    LiveTitle /livetitledefault /xlastpath:c:\\temp\\ffe04585.xlast /lbs:TukPrStatInh001 /matchsvr:MtchSqlv01;MtchSqlv03" );
            Console.WriteLine( "" );
            Console.WriteLine( "" );
            Console.WriteLine( "    Deploy initial configuration so title 0xffe04585, which is part of the bounty program can log in" );
            Console.WriteLine( "    LiveTitle /deploy /xlastpath:c:\\temp\\ffe04585.xlast /ltcpath:c:\\temp\\ffe04585_ltc.xml" );
            Console.WriteLine( "" );
            Console.WriteLine( "" );
            Console.WriteLine( "    Create a default Live Title Config file from an XBOX1 config file (Do this BEFORE you deploy the Xbox1 title)" );
            Console.WriteLine( "    LiveTitle /xboxdefault /xboxpath:c:\\temp\\ffe04585.xbox  /xscpath:c:\\temp\\ffe04585.xsc " );
            Console.WriteLine( "              /lbs:TukPrStatInh001 /matchsvr:MtchSqlv01;MtchSqlv03" );
            Console.WriteLine( "" );
            Console.WriteLine( "" );
            Console.WriteLine( "    Deploy initial so Xbox title 0xffe04585 can log in" );
            Console.WriteLine( "    LiveTitle /deployxbox /xboxpath:c:\\temp\\ffe04585.xbox /ltcpath:c:\\temp\\ffe04585_ltc.xml " );
            Console.WriteLine( "              /xscpath:c:\\temp\\ffe04585.xsc " );
            Console.WriteLine( "" );
            Console.WriteLine( "" );
            Console.WriteLine( "    Mark a title's configuration as 'locked'" );
            Console.WriteLine( "    LiveTitle /lock /xlastpath:c:\\temp\\ffe04585.xlast" );
            Console.WriteLine( "" );
            Console.WriteLine( "" );
            Console.WriteLine( "    Report version information for title 0xffe04585 " );
            Console.WriteLine( "    LiveTitle /reportver /titleid:0xffe04585 " );
            Console.WriteLine( "" );
            Console.WriteLine( "" );
            Console.WriteLine( "    Add new base version 0x5 for Xenon title 0xffe04585 " );
            Console.WriteLine( "    LiveTitle /addbasever /titleid:0xffe04585 /version:0x5 /platform:Xenon" );
            Console.WriteLine( "" );
            Console.WriteLine( "" );
            Console.WriteLine( "    Delete version chain for PC title 0xffe04585 version 0x5 " );
            Console.WriteLine( "    LiveTitle /delbasever /titleid:0xffe04585 /version:0x5 /platform:PC" );
            Console.WriteLine( "" );
        }

        private static int ParseVersion(string versionString)
        {
            if (
                (versionString.Length > 2) &&
                (versionString.Substring(0, 2).ToLower() == "0x")
                )
            {
                //this can throw an exception as well
                return Int32.Parse(versionString.Substring(2), NumberStyles.HexNumber);
            }
            else
            {
                //if it doesn't meet basic checks, it's bad
                throw new Exception("Invalid version was supplied");
            }
        }

        /// <summary>
        /// Call SPAC tool to verify the validity of the XLAST file
        /// </summary>
        /// <param name="xlastPath"></param>
        /// <param name="xlastVersion"></param>
        /// <returns></returns>
        public static int RunSpac( string xlastPath, string xlastVersion )
        {
            int exitCode;
            string spacOutput;
            try
            {
                //NOTE: this pattern is important when checking in new spac.exe versions
                string spacExe =  Config.GetSetting(Setting.setup_approot) + "\\xbltools\\spac_" + xlastVersion + ".exe";
                string spacExeDefault = Config.GetSetting( Setting.setup_approot ) + "\\xbltools\\spac.exe";
               
                Console.WriteLine( "   XLAST version: " + xlastVersion + " \r\n   About to run: " + spacExe );
                string currentEnvironment = Config.Environment.ToLower();
                Console.WriteLine( "   Current environment: " + currentEnvironment );

                if (
                     ( !File.Exists( spacExe ) ) &&
                     //can't use "environment type"... because partnernet is considered "develop"... yet another config annoyance.
                     ( ( currentEnvironment == "xblob" ) || ( currentEnvironment == "testnet" ) || ( currentEnvironment == "bvtnet" ) )
                   )
                {
                    //use the fallback version for special cases...
                    if ( File.Exists( spacExeDefault ) )
                    {
                        spacExe = spacExeDefault;
                    }
                    else
                    {
                        Console.WriteLine( "Correct Spac.exe for your file was not found." );
                        Console.WriteLine( "Please confirm the correct versions of Spac.exe are deployed for your XLAST.\r\n" );
                        exitCode = -100;
                        return exitCode;
                    }

                    Console.WriteLine( "Using default spac.exe... please add the correct one to my versioned spac collection!\r\n" );
                }

                ProcessStartInfo startInfo = new ProcessStartInfo( spacExe );
                //some *devs* put spaces in their filenames... grrr

                startInfo.Arguments                 = " -server -nousage -nospa -noh \"" + xlastPath + "\"";
                startInfo.RedirectStandardOutput    = true;
                startInfo.UseShellExecute           = false;

                Process spacProcess = Process.Start( startInfo );

                spacOutput = spacProcess.StandardOutput.ReadToEnd();
                spacProcess.WaitForExit();
                exitCode = spacProcess.ExitCode;

                if (exitCode != 0) {
                    Console.WriteLine("LiveTitle error: Spac returned a warning (" + exitCode + ").");
                }
                Console.WriteLine("Spac tool exit code: " + exitCode);
                Console.WriteLine("Spac tool says:  " + Environment.NewLine + spacOutput);
            }
            catch ( Exception e )
            {
                Console.WriteLine(Environment.NewLine + Environment.NewLine + "There was an error during xlast validation: " + Environment.NewLine + Environment.NewLine + e.ToString());
                exitCode = -200;
            }

            // From the Spac code in the client tree
            // Success             = 0,    // Peachy
            // BadUsage            = 1,    // RTFM
            // NonFatalError       = 2,    // Warnings, possible cert failure
            // FatalError          = 3,    // No files generated
            if ( ( exitCode == 1 ) || ( exitCode == 3 ) )
            {
                Console.WriteLine( "There is a serious problem with this XLAST file that " );
                Console.WriteLine( " prevents it's deployment. Possible causes include: " );
                Console.WriteLine( "   - file was edited using a non-supported XDK " );
                Console.WriteLine( "   - file has been hand-edited incorrectly " );
                Console.WriteLine( "   - there is a mis-match between the file's XDK and the spac XDK " );
                Console.WriteLine( "Please correct it and try again." );
            }

            return exitCode;

        } //run spac


        //task: will probably want to move this elsewhere eventually
        public static void ResetFrontDoor( string serverInterface, string process, string component, string command, int timeout )
        {
            int result = 0;

            //need to loop through each of the servers in the Virtual Interface...
            string[] serverList = Config.GetServerListByInterface( serverInterface );
            string[] responses = null;
            Console.WriteLine( "Resetting Front Doors... " );
            foreach( string server in serverList )
            {
                try
                {
                    Console.Write( " " + server );

                    // Since we are executing XMGMT commands, rather than use the caller's Interface spec,
                    // we will retrieve the IP for the xmgmtsrv Interface.  If,

                    IInterfaceInfo svrIFaceInfo = Config.GetInterface( server, Interface.xmgmtsrv );

                    if (svrIFaceInfo == null)
                    {
                        Console.Write( " WARNING: Could not retrieve xmgmtsrv interface for " + server + ", using service interface instead");
                        svrIFaceInfo = Config.GetInterface( server, serverInterface );
                    }

                    XomAdminSession xmgmt = new XomAdminSession( svrIFaceInfo.IPAddress );
                    xmgmt.SendCommand( process, component, command, timeout, out responses, out result);
                }
                catch ( Exception e )
                {
                    Console.WriteLine( "There was a serious error while reloading front doors:" );
                    Console.WriteLine( "  Error was : " + e.Message + "\r\n" + e.StackTrace );
                }
            }
             
            Console.WriteLine( "\r\n Attempted to reset all " + serverInterface.ToString() + " front doors" );
        }


        public static bool TitleCheckReady( NamedArgParser argParser )
        {
            bool ready = true;
            string reply = String.Empty;

            try
            {
                Console.WriteLine( "Commencing Resource Checks... " );

                //if xlast file is specified confirm it can be read
                if ( null != argParser[ "xlastpath" ] )
                {
                    if ( ! CheckReady.CheckReadFile( argParser[ "xlastpath" ] ) )
                    {
                        ready = false;
                        Console.WriteLine( "--> There was an issue finding the XLAST file at the path you specified. " );
                    }
                }

                if ( null != argParser[ "ltcpath" ] )
                {
                    if ( ! CheckReady.CheckReadFile( argParser[ "ltcpath" ] ) )
                    {
                        ready = false;
                        Console.WriteLine( "--> There was an issue finding the LTC file at the path you specified. " );
                    }
                }

                if ( null != argParser[ "xboxpath" ] )
                {
                    if ( ! CheckReady.CheckReadFile( argParser[ "xboxpath" ] ) )
                    {
                        ready = false;
                        Console.WriteLine( "--> There was an issue finding the Xbox configuration file at the path you specified. " );
                    }
                }

                if ( null != argParser[ "xscpath" ] )
                {
                        if ( ! CheckReady.CheckReadFile( argParser[ "xscpath" ] ) )
                        {
                            ready = false;
                            Console.WriteLine( "--> There was an issue finding the Xbox XSC configuration file at the path you specified. " );
                        }
                }

                if ( null != argParser[ "xmspath" ] )
                {
                        if ( ! CheckReady.CheckReadFile( argParser[ "xmspath" ] ) )
                        {
                            ready = false;
                            Console.WriteLine( "--> There was an issue finding the Xbox XMS configuration file at the path you specified. " );
                        }
                }

                if ( null != argParser[ "xqspath" ] )
                {
                        if ( ! CheckReady.CheckReadFile( argParser[ "xqspath" ] ) )
                        {
                            ready = false;
                            Console.WriteLine( "--> There was an issue finding the Xbox XQS configuration file at the path you specified. " );
                        }
                }

                Console.WriteLine("   +Checking TitleVault Access...");
                if (!CheckReady.CheckTitleVault())
                {
                    Console.WriteLine("--> There was an issue getting access to TitleVault!");
                    Console.WriteLine("    Current titlevault_root config: |" + Config.GetSetting(Setting.titlevault_root) + "|");
                    ready = false;
                }

                string connection = ConfigUtil.NpdbConnectionString;
                Console.WriteLine("   +Checking NPDB Access, Using connection string: {0}", connection);


                if ( !CheckReady.CheckDB( connection, ref reply) )
                {
                    Console.WriteLine( "--> Connecting to NPDB had a problem:\r\n    " + reply );
                    ready = false;
                }

                Console.WriteLine("   +Checking WebDB Access...");
                //task: ref strings don't make sense... make it an OUT param
                reply = String.Empty;
                connection = ConfigUtil.WebdbConnectionString;

                if (!CheckReady.CheckDB(connection, ref reply))
                {
                    Console.WriteLine("--> Connecting to WebDB had a problem:\r\n    " + reply);
                    ready = false;
                }

                Console.WriteLine("   +Checking UODB Access...");
                //hint: we just want to get this string: "UODB"
                IVirtualInterfaceInfo viInfo = Config.GetVirtualInterface(VirtualInterface.uodb, Site.main);
                string webstoreApplicationName = viInfo.WebstoreApp;
                if (!CheckReady.CheckWebstore(webstoreApplicationName))
                {
                    Console.WriteLine("--> Connecting to UODB had a problem:\r\n    ");
                    ready = false;
                }

                Console.WriteLine("   +Checking ContentIngestion WebService (for CatalogDB) Access...");
                reply = String.Empty;
                if (!GameHelper.CheckReadyCatalogDB(out reply))
                {
                    Console.WriteLine("--> Connecting to CatalogDB had a problem:\r\n    " + reply);
                    ready = false;
                }

                if ( !ready )
                {
                    Console.WriteLine( "\r\n\r\nOne or more resources necessary to run are unavailable. " );
                    Console.WriteLine( "    Please correct these and re-run the tool." );
                }

                Console.WriteLine( "\r\nResource Checks are Completed." );
            }
            catch ( Exception e )
            {
                ready = false;
                Console.WriteLine( "\r\n\r\nA necessary resource is unavailable or there is in invalid config data!\r\n\r\n" );
                Console.WriteLine( "This caused a serious error to occur... " );
                Console.WriteLine( "Error was:\r\n" + e.ToString() );
            }

            return ready;
        }

        /// <summary>Simple validation function to check the command line specifications
        /// for the leaderboard and match servers for accuracy against the NPDB
        /// </summary>
        /// <param name="lbs">name of the server where leaderboards will be hosted</param>
        /// <param name="mtch">comma delimited list of servers where matchmaking will be hosted</param>
        /// <returns>
        /// null - no validation issues
        /// string - error text
        /// </returns>
        static public string CheckLTCServers(string lbs, string mtch)
        {
            if (lbs != null)
            {
                try
                {
                    IInterfaceInfo face = Config.GetInterface(lbs, Interface.lbsvr );
                }
                catch
                {
                    return "Leaderboard server [" + lbs + "] does not exist in NPDB or does not have an lbsvr Interface";
                }
            }


            if (mtch != null)
            {
                string [] svrList = mtch.Split(new char[] {';'});

                foreach (string svr in svrList)
                {
                    try
                    {
                        IInterfaceInfo face = Config.GetInterface(svr, Interface.xmatch);
                    }
                    catch
                    {
                        return "Matchmaking server [" + svr + "] does not exist in NPDB or does not have an xmatch Interface" ;
                    }
                }
            }

            return null;
        } // CheckLTCServers


        public static string TitleVaultDir( uint titleID, bool locked )
        {
            return Config.GetSetting(Setting.titlevault_root) + "\\" + (locked ? "locked\\" : "") + titleID.ToString("x8");
        }


        // Move this out of common\tools\TitleVault.cs because it uses some xlast specific functionality
        // which is not used by other components and is specific only to LiveTitle.
        public static int MoveFilesToTitleVault( string xlastPath, string ltcPath, uint titleID, Images images, bool marketplace, bool locked)
        {
            int fileCount = 0;
            string configFilename;

            if (marketplace)
            {
                configFilename = titleID.ToString("X") + ".marketplace";
            }
            else
            {
                configFilename = titleID.ToString("X") + ".xlast";
            }

            //write XLAST and LTC

            string titleRoot = TitleVaultDir( titleID, locked);

            Console.WriteLine( "\r\nMoving source files to" + (locked ? " LOCKED" : "") + " TitleVault location:\r\n  " + titleRoot );

            if ( ! Directory.Exists( titleRoot ) )
            {
                Directory.CreateDirectory( titleRoot );
            }

            //have already verified the xlast & ltc files exist
            TitleVault.TitleVaultCopy( titleRoot, xlastPath, configFilename );
            fileCount++;
            Console.WriteLine("   Copied XLAST to" + (locked ? " LOCKED" : "") + " TitleVault." );

            if (ltcPath != null)
            {
                string ltcFilename = titleID.ToString("X") + "_LTC.xml";
                TitleVault.TitleVaultCopy( titleRoot, ltcPath, ltcFilename );
                fileCount++;
                Console.WriteLine("   Copied LTC to" + (locked ? " LOCKED" : "") + " TitleVault." );

            }


            //now write the IMAGES
            //REVIEW: image file should be in same path as xlast... is this always true?
            FileInfo xlastFileInfo = new FileInfo( xlastPath );
            string localPath = xlastFileInfo.Directory.FullName;

            if ( ( null != images ) && ( null != images.Image ) )
            {
                Console.WriteLine( "   Moving image files to"  + (locked ? " LOCKED" : "") + " TitleVault... " );


                foreach( Image img in images.Image )
                {
                    //bug 44000 - system titles can have an empty path
                    if ( img.Path == "" )
                    {
                        Console.WriteLine( "   --> Empty image path encountered. This is only ok for System titles." );
                    }
                    else
                    {
                        FileInfo imgPath = new FileInfo( img.Path );
                        if ( File.Exists( localPath + "\\" + imgPath.Name ) )
                        {
                            // Copy file
                            string toDir = Path.Combine(titleRoot, imgPath.Name);
                            Console.WriteLine("      Moving " + imgPath.Name.PadRight(15) + " to " + toDir + ", image id: " + img.id);
                            TitleVault.TitleVaultCopy(titleRoot, localPath + "\\" + imgPath.Name, imgPath.Name);
                            fileCount++;
                        }
                        else
                        {
                            Console.WriteLine( "      Serious Error - image file |" + localPath + "\\" + imgPath.Name + " not found! " );
                        } //file exist

                    } // file not blank

                } //foreach image

            } //if images exist
            else
            {
                Console.WriteLine( "   No images found in XLAST file, this could be a problem!" );
            }

            //task: HOW SHOULD I COPY CONTENT FILES to TITLEVAULT?

            return fileCount;
        }

        //task: move this to a more appropriate file
        //used for creating an initial titleconfig that reflects the title's information...
        //NOTE: similar code is in statsxlastutil.cs.  this one creates LeaderboardConfigs, the other creates Leaderboards
        public static LiveTitleConfig GetLiveTitleConfigFromXbox( string xboxXml, string xscPath, string lbServer )
        {

            XboxConfiguration XboxCfg = XboxUtil.FromXml(xboxXml);
            uint titleID;

            if ( XboxCfg.GameConfig.titleId.Substring(0,2).ToLower() == "0x" )
            {
                titleID = Convert.ToUInt32(XboxCfg.GameConfig.titleId,16);
            }
            else
            {
                titleID = (UInt32) Convert.ToInt32(XboxCfg.GameConfig.titleId);
            }

            LiveTitleConfig ltc = new LiveTitleConfig( titleID, Generation.Xbox );

            // Add the clusterID and locale
            ltc.clusterid = XboxCfg.WebdbInfo.ClusterID;
            ltc.locale = XboxCfg.WebdbInfo.DefaultLocale;

            if (xscPath != null)
            {
                // Get array of LeaderboardSettings objects from XSC file
                ArrayList LeaderboardSettingsList = XscLeaderboard.GetXSCLeaderboardConfiguration(xscPath, titleID);

                // Fill up the LeaderboardConfig[] array for LTC
                // from the LeaderboardSettings objects
                if ( LeaderboardSettingsList.Count > 0 )
                {
                    ltc.LeaderboardConfigs = new LeaderboardConfig[ LeaderboardSettingsList.Count ];
                    for(int i=0;i<LeaderboardSettingsList.Count;i++)
                    {
                        ltc.LeaderboardConfigs[i] = new LeaderboardConfig();
                        ltc.LeaderboardConfigs[i].HostingLbs    = lbServer;
                        ltc.LeaderboardConfigs[i].LeaderboardID = ((LeaderboardSettings)LeaderboardSettingsList[i]).LeaderboardID;
                        ltc.LeaderboardConfigs[i].IsCompetition = (((LeaderboardSettings)LeaderboardSettingsList[i]).Type == LbType.Competition);
                    }
                }
            }
            else
            {
                Console.WriteLine( "No XSC path, configuring for no leaderboards");
                ltc.LeaderboardConfigs = new LeaderboardConfig[0];
            }

            return ltc;
        }

        [STAThread]
        static int Main(string[] args)
        {
            NamedArgParser argParser = null;
            LiveTitleConfig ltc;
            string eText = String.Empty;

            try
            {
                #region Parse and validate args
                try
                {

                    //task: these next 20 lines or so appear in all console tools.. is there a way to factor this out?
                    string[] rgstrCmdLineTags =
                    {
                        "?",
                        "checkready",           // confirms all necessary resources are up
                        "deploy",               //
                        "lock",                 //
                        "deployxbox",           //
                        "checkready",           // checks all resources are available
                        "livetitledefault",     //
                        "xboxdefault",          //
                        "reportver",            //
                        "delbasever",           //
                        "addbasever",           //
                        "xlastpath",            //
                        "ltcpath",              //
                        "xscpath",              //
                        "xmspath",              //
                        "xboxpath",             //
                        "lbs",                  //
                        "matchsvr",             //
                        "discid",               // for the 0.5% case that the discID != Xlast titleID
                        "titleid",              // for the tools widget, so it doesn't have to crack the XLAST
                        "images",               // run stutil core code to upload storage file
                        "contentupdate",        // this is a content update (not a title update)
                        "version",              //
                        "marketplacepath",      //
                        "noreload",             // don't process any reload actions
                        "timeout",              // optional timeout value
                        "platform",             // platform, can be Xenon or PC
                        "verbose",              // optional, if omitted only errors will be printed
                        "usetransactions",      // optional, if omitted live title will not use transactions when
                                                // writing to partitioned tables
                        "group"                 // used to supply a beta group for the title version
                    };

                    argParser = new NamedArgParser(rgstrCmdLineTags);

                    // Validate commandline args
                    // Parse any command line arguments, returns false if there are extras
                    if (!argParser.Parse(args))
                    {
                        if (String.IsNullOrEmpty(argParser.InvalidArgText))
                        {
                            Usage();
                        }
                        else
                        {
                            Console.WriteLine("Unrecognized or duplicate argument \"" + argParser.InvalidArgText + "\".  Run \"LiveTitle.exe /?\" for usage information.");
                        }
                        return -1;
                    }

                    // Did the user just request usage information?
                    if ((0 == argParser.Count) || (null != argParser["?"]))
                    {
                        Usage();
                        return 0;
                    }

                }
                catch (Exception e)
                {
                    Console.WriteLine("There was an error: \r\n" + e.ToString());
                    Console.WriteLine("\r\nThe above error occurred while attempting to parse command-line ");
                    Console.WriteLine(" arguments. Please check the arguments and retry.");
                    return -1;
                }

                Console.WriteLine("\r\n         L  I  V  E    T  I  T  L  E");
                Console.WriteLine("\r\n                       v " + Assembly.GetExecutingAssembly().GetName().Version.ToString());
                Console.WriteLine("\r\n=================================================\r\nCommand Line Arguments were: ");
                foreach (object thisArg in argParser.Keys)
                {
                    if (((string)argParser[thisArg.ToString()]) == "")
                    {
                        //for switches that don't supply an argument
                        Console.WriteLine("Switch " + ((string)thisArg).PadLeft(30, ' ') + "    Was Present ");
                    }
                    else
                    {
                        Console.WriteLine("Switch " + ((string)thisArg).PadLeft(30, ' ') + "    had the value |" + ((string)argParser[thisArg.ToString()]).PadRight(30, ' ') + "|");
                    }
                }
                Console.WriteLine("");
                Console.WriteLine("Exe location: " + Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location));
                Console.WriteLine("\r\n===================");

                bool ready = TitleCheckReady(argParser);

                if (!ready || ((null != argParser["checkready"])))
                {
                    return (ready ? 0 : -1);
                }

                bool reload = (argParser["noreload"] == null);
                int reloadTimeout = DEFAULT_RELOAD_TIMEOUT;

                // Allow the network command timeouts to be configured from the commandline
                if (null != argParser["timeout"])
                {
                    try
                    {
                        reloadTimeout = Int32.Parse(argParser["timeout"]);
                    }
                    catch (Exception)
                    {
                        Console.WriteLine("ERROR: /timeout value was not a valid integer");
                        return -1;
                    }
                }

                // usetransaction flag
                if (null != argParser["usetransactions"])
                {
                    Title.useTransactions = true;
                }

                #endregion

                #region Verify Xlast or Xbox input file

                //before we do anything.. confirm the file we're getting is good.
                //is it an xlast file?
                if ((null != argParser["xlastpath"]))
                {
                    bool isMobileTitle = false;
                    bool isMobileTitleProcessed = false;
                    do
                    {
                        if (isMobileTitle)
                        {
                            isMobileTitleProcessed = true;
                        }

                        StreamReader xlastReader = new StreamReader(
                            argParser["xlastpath"].ToString());

                        string xlastXml = xlastReader.ReadToEnd();

                        xlastReader.Close();

                        // XENON 50572: LiveTitle: Specifying a file for the 
                        // /xlastpath parameter that is not a valid XLAST file 
                        // causes an unhandled exception
                        string xlastVersion;
                        try
                        {
                            xlastVersion = XlastUtil.GetXlastVersion(xlastXml);
                        }
                        catch (Exception e)
                        {
                            Console.WriteLine("Error in XLast file: {0}",
                                argParser["xlastpath"].ToString());
                            Console.WriteLine("     {0}", e.Message);
                            return 0;
                        }

                        Console.WriteLine("About to run Spac tool.");

                        // LiveTitle will verify the validity of the XLAST file
                        // by calling the SPAC tool. If SPAC returns an error,
                        // processing is halted and no LTC file is created.
                        int exitCode = RunSpac(argParser["xlastpath"].ToString(), xlastVersion);

                        if ((exitCode == 1) || (exitCode == 3) || (exitCode < 0))
                        {
                            //bad file or missing spac == end of this line of execution.
                            return exitCode;
                        }

                        try
                        {
                            isMobileTitle = ConvertMobileAndWebTitlesToConsoleFormat(argParser["xlastpath"]);
                        }
                        catch (Exception)
                        {
                            // Return an error exit code
                            return -1;
                        }
                    } while (isMobileTitle && !isMobileTitleProcessed);
                }
                else if ((null != argParser["xboxdefault"]) || (null != argParser["deployxbox"]))
                {
                    // Placeholder - should add specific checks for values
                    XboxUtil.CheckXboxConfig();
                }

                #endregion

                //Now that we've got good files, and can connect to resources, do work...

                if (
                    (null != argParser["livetitledefault"]) &&
                    (null != argParser["xlastpath"]) &&
                    (null != argParser["lbs"]) &&
                    (null != argParser["matchsvr"])
                    )
                {
                    #region Action: /livetitledefault

                    // they want to create LTC file based on XLAST file
                    try
                    {
                        string xlastPath = Path.GetFullPath(argParser["xlastpath"].ToString());

                        StreamReader xlastReader = new StreamReader(xlastPath);

                        string xlastXml = xlastReader.ReadToEnd();

                        xlastReader.Close();

                        string xlastVersion = XlastUtil.GetXlastVersion(xlastXml);

                        CTitleId xlastTitleID;
                        try
                        {
                            //task: one day, I'll convert CTitleId to have static conversion methods...
                            xlastTitleID = new CTitleId(XlastUtil.GetXlastTitleID(xlastXml));
                        }
                        catch
                        {
                            Console.WriteLine("Title ID Supplied in the XLAST file was unusable.");
                            return -1;
                        }

                        if (xlastTitleID.uiTitleId == 0)
                        {
                            Console.WriteLine("Title ID Supplied in the XLAST file was zero.  This is an invalid Title ID.");
                            return -1;
                        }

                        //This conditional / parameter is used to verify this XLAST contains the expected titleID
                        //The tools widget can't read an Xlast, so it merely tells the tool what titleID
                        // it thinks it's deploying so the tool can verify it. It is currently the
                        // only user of this param
                        if (null != argParser["titleid"])
                        {
                            CTitleId commandLineTitleID;
                            try
                            {
                                commandLineTitleID = new CTitleId(argParser["titleid"]);
                            }
                            catch
                            {
                                Console.WriteLine("Title ID Supplied on the command line was unusable.");
                                return -1;
                            }

                            if (xlastTitleID.uiTitleId != commandLineTitleID.uiTitleId)
                            {
                                Console.WriteLine("Title ID Supplied on the command line did not match the Title ID Supplied in the XLAST file!");
                                return -1;
                            }
                            else
                            {
                                Console.WriteLine("Title ID Supplied on the command line matches the Title ID Supplied in the XLAST file.");
                            }
                        }

                        string ltcFileName = xlastTitleID.sTitleIdHexNoPrefix + "_ltc.xml";

                        //extract from npdb, deserialize, returns null if not present
                        LiveTitleConfig existingLTC = LiveTitleConfig.Get(xlastTitleID.uiTitleId);

                        ltc = null;

                        if (existingLTC != null)
                        {
                            //use existing LTC file
                            Console.WriteLine("\r\nExisting LTC document was used. Please review to confirm defaults are correct.");

                            //update the leaderboardconfigs in the TLC to synchronize with the new xlast
                            ltc = existingLTC;

                            LiveTitleConfig newLTC = LiveTitleConfig.GetLiveTitleConfigFromXlast(xlastXml, argParser["lbs"].ToString(), argParser["matchsvr"].ToString());

                            ltc = LiveTitleConfig.UpdateLiveTitleConfigFromExisting(newLTC, ltc, argParser["lbs"].ToString());

                            if (ltc == null)
                            {
                                Console.WriteLine("\r\nThere was an error applying existing Leaderboard assignments to new leaderboard configuration.");
                                Console.WriteLine("Please examine the XLAST document and the existing LTC document.");
                                return -1;
                            }
                        }
                        else
                        {
                            //create a new LTC document
                            Console.WriteLine("\r\nNew LTC being created...");

                            //-----------------------------------------------------
                            // Confirm that the specified leaderboard and match
                            // servers are valid as far as the NPDB is concerned.
                            //
                            eText = CheckLTCServers(argParser["lbs"], argParser["matchsvr"]);
                            if (eText != null)
                            {
                                Console.WriteLine("An Error occured: " + eText);
                                return -1;
                            }

                            ltc = LiveTitleConfig.GetLiveTitleConfigFromXlast(xlastXml, argParser["lbs"].ToString(), argParser["matchsvr"].ToString());

                            // No LTC in titlevault/npdb, check local directory for a 
                            // template LTC.  If found we will merge in the settings
                            // from this file.

                            string ltcFragmentFile = Path.Combine(
                                Path.GetDirectoryName(xlastPath),
                                ltcFileName);

                            if (File.Exists(ltcFragmentFile))
                            {
                                try
                                {
                                    ltc = LiveTitleConfig.MergeFragmentOverrides(ltc, ltcFragmentFile);
                                }
                                catch (Exception e)
                                {
                                    Console.WriteLine(string.Format("Failed to read LTC override fragment file {0}.  Error = {1}.", ltcFragmentFile, e.Message));
                                    return -1;
                                }
                            }

                            //for the rare case that the discid isn't the default (xlast title id)
                            if (null != argParser["discid"])
                            {
                                CTitleId title = new CTitleId(argParser["discid"]);
                                ltc.DiscMediaID = (int)title.uiTitleId;
                            }
                        }

                        Console.WriteLine("Writing LiveTitleConfig file to current directory as: " + ltcFileName);

                        using (StreamWriter sw = new StreamWriter(ltcFileName, false, Encoding.Unicode))
                        {
                            sw.WriteLine(ltc.ToXml());
                        }

                    }
                    catch (SqlException se)
                    {
                        Console.WriteLine("An Error occurred calling SQL:\r\n" + se.Message + "\r\n" + se.StackTrace);
                        return -1;
                    }
                    catch (IOException ioe)
                    {
                        Console.WriteLine("An Error occurred accessing the file system:\r\n " + ioe.Message + "\r\n" + ioe.StackTrace);
                        return -1;
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine("An unexpected error occurred: " + e.Message + "\r\n" + e.StackTrace);
                        return -1;
                    }
                    return 0;

                    #endregion
                }
                else if ((null != argParser["xboxdefault"]) &&  // Create default LTC file for xbox1
                    (null != argParser["xboxpath"]) &&      // xbox Configuration XML file
                    (null != argParser["lbs"]))             // Leaderboard servers
                {
                    #region Action: /xboxdefault

                    //do they want to create a default Xbox configuration file
                    try
                    {
                        // Get arguments
                        string xboxPath = argParser["xboxpath"];
                        string xscPath = argParser["xscpath"];   // optional param: may be null
                        string lbs = argParser["lbs"];


                        //-----------------------------------------------------
                        // Confirm that the specified leaderboard amd match
                        // servers are valid as far as the NPDB is concerned.
                        //
                        eText = CheckLTCServers(argParser["lbs"], argParser["matchsvr"]);
                        if (eText != null)
                        {
                            Console.WriteLine("An Error occured: " + eText);
                            return -1;
                        }

                        // Read xbox Xml file
                        StreamReader xboxReader = new StreamReader(xboxPath);
                        string xboxXml = xboxReader.ReadToEnd();
                        xboxReader.Close();

                        // Read xboxSchema XML file
                        string xboxSchemaXml = XlastSchemaUtil.GetXlastSchema(XBOX_SCHEMA_VERSION);

                        // Validate xboxConfig XML file
                        // returns an exception if xml is invalid
                        Console.WriteLine("Validating {0} against schema version XBOX ...", xboxPath);
                        XboxUtil.ValidateXboxConfigXML(xboxXml, xboxSchemaXml);

                        // Create the xboxCfg object from the XML string
                        XboxConfiguration XboxCfg = XboxUtil.FromXml(xboxXml);

                        CTitleId ctitle;
                        try
                        {
                            //task: one day, I'll convert CTitleId to have static conversion methods...
                            ctitle = new CTitleId(XboxCfg.GameConfig.titleId);
                        }
                        catch
                        {
                            Console.WriteLine("Title ID in the Xbox Config document was unusable.  Please correct the .xbox file and try again.");
                            return -1;
                        }

                        if (ctitle.uiTitleId == 0)
                        {
                            Console.WriteLine("Title ID Supplied was zero.  This is an invalid Title ID.");
                            return -1;
                        }

                        //extract from titlevault, deserialize, returns null if not present
                        LiveTitleConfig existingLTC = LiveTitleConfig.Get(ctitle.uiTitleId);

                        ltc = null;

                        if (existingLTC != null)
                        {
                            //use existing LTC file
                            Console.WriteLine("\r\nExisting LTC document was used. Please review to confirm settings are correct.");

                            //update the leaderboardconfigs in the TLC to synchronize with the new xlast
                            ltc = existingLTC;

                            // 111574 - This need to be hard coded to zero.  There are cases where older
                            // LTC files originally propped before the addition of MatchDeleteDelaySeconds
                            // will get the value 300 when repropped, which is BAD!!!
                            ltc.MatchDeleteDelaySeconds = 0;

                            LiveTitleConfig newLTC = GetLiveTitleConfigFromXbox(xboxXml, xscPath, lbs);

                            ltc = LiveTitleConfig.UpdateLiveTitleConfigFromExisting(newLTC, ltc, argParser["lbs"].ToString());

                            if (ltc == null)
                            {
                                Console.WriteLine("\r\nThere was an error applying existing Leaderboard assignments to new leaderboard configuration.");
                                Console.WriteLine("Please examine the XSC document and the existing LTC document.");
                                return -1;
                            }
                        }
                        else
                        {
                            //create a new LTC document
                            Console.WriteLine("\r\nNew LTC being created...");

                            //-----------------------------------------------------
                            // Confirm that the specified leaderboard and match
                            // servers are valid as far as the NPDB is concerned.
                            //
                            eText = CheckLTCServers(argParser["lbs"], argParser["matchsvr"]);
                            if (eText != null)
                            {
                                Console.WriteLine("An Error occured: " + eText);
                                return -1;
                            }

                            ltc = GetLiveTitleConfigFromXbox(xboxXml, xscPath, lbs);

                            if (null != argParser["matchsvr"])
                            {
                                ltc.MatchServerList = argParser["matchsvr"];
                            }

                            //for the rare case that the discid isn't the default (xlast title id)
                            if (null != argParser["discid"])
                            {
                                CTitleId title = new CTitleId(argParser["discid"]);
                                ltc.DiscMediaID = (int)title.uiTitleId;
                            }
                        }

                        // Create LTC XML file
                        // File name format: <titleID>_ltc.xml
                        Console.WriteLine("Writing LiveTitleConfig file to current directory as: " + String.Format("{0,8:X8}", ltc.TitleID) + "_ltc.xml ");
                        using (StreamWriter sw = new StreamWriter(String.Format("{0,8:X8}", ltc.TitleID) + "_ltc.xml", false, Encoding.Unicode))
                        {
                            sw.WriteLine(ltc.ToXml());
                        }

                    }
                    catch (SqlException se)
                    {
                        Console.WriteLine("An Error occurred calling SQL:\r\n" + se.Message + "\r\n" + se.StackTrace);
                        return -1;
                    }
                    catch (IOException ioe)
                    {
                        Console.WriteLine("An Error occurred accessing the file system:\r\n " + ioe.Message + "\r\n" + ioe.StackTrace);
                        return -1;
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine("An unexpected error occurred: " + e.Message + "\r\n" + e.StackTrace);
                        return -1;
                    }
                    return 0;
                    #endregion
                }
                else if (
                    (null != argParser["deployxbox"]) &&    // Deploy xbox LiveTitleConfiguration
                    (null != argParser["xboxpath"]) &&      // Path to xbox Config XML file
                    (null != argParser["ltcpath"])          // Path to LTC XML file generated earlier
                    )
                {
                    #region Action: /deployxbox

                    // deploy an Xbox configuration to the service
                    try
                    {
                        //////////////////////////////////////////////////////////
                        // XBOX Config
                        //
                        //- read and check Xbox config
                        //- store Xbox config and LTC file in NPDB
                        //- call Title.CreateNewXboxTitle()
                        //- call Title.AddVersion as necessary for the various Xbox versions
                        //////////////////////////////////////////////////////////

                        Console.WriteLine("Commencing configuration of Xbox1 title... ");
                        Console.WriteLine("Legacy Xbox 1 title and offer data will only be added to UODB because it is not supported in CatalogDB.");

                        // Get arguments
                        string xboxPath = argParser["xboxpath"];
                        string xscPath = argParser["xscpath"];   // optional param: may be null
                        string xmsPath = argParser["xmspath"];   // optional param: may be null
                        string ltcPath = argParser["ltcpath"];
                        CTitleId titleId;

                        // Read xboxConfig XML file
                        StreamReader xboxReader = new StreamReader(argParser["xboxpath"].ToString());
                        string xboxXml = xboxReader.ReadToEnd();
                        xboxReader.Close();

                        // Read LTC file
                        StreamReader ltcReader = new StreamReader(ltcPath);
                        string ltcXml = ltcReader.ReadToEnd();
                        ltcReader.Close();
                        ltc = LiveTitleConfig.FromXml(ltcXml);

                        // Read xboxSchema XML file
                        string xboxSchemaXml = XlastSchemaUtil.GetXlastSchema(XBOX_SCHEMA_VERSION);

                        // Validate xboxConfig XML file
                        // returns an exception if xml is invalid
                        Console.WriteLine("Validating {0} against schema version XBOX ...", xboxPath);
                        XboxUtil.ValidateXboxConfigXML(xboxXml, xboxSchemaXml);

                        //deserializing *now* confirms that we will be able to use it later...
                        XboxConfiguration XboxCfg = XboxUtil.FromXml(xboxXml);

                        //verify max leaderboard
                        StringBuilder validationInformation = new StringBuilder();
                        bool bRet = XboxChecker.CheckXboxConfig(xboxXml, ltcXml, ref validationInformation);
                        if (!bRet)
                        {

                            Console.WriteLine(validationInformation.ToString());
                            Console.WriteLine("\r\n\r\n!! One or more server-side XSC / LTC consistency checks failed. See text above.");
                            return -1;
                        }

                        //sometimes that value will be an integer, not "0xhexdigits"
                        try
                        {
                            titleId = new CTitleId(XboxCfg.GameConfig.titleId);
                        }
                        catch
                        {
                            Console.WriteLine("Title ID in the Xbox Config document was unusable.  Please correct the .xbox file and try again.");
                            return -1;
                        }

                        if (titleId.uiTitleId == 0)
                        {
                            Console.WriteLine("Title ID Supplied was zero.  This is an invalid Title ID.");
                            return -1;
                        }

                        // load files to npdb
                        XboxUtil.PutXboxConfig(
                            titleId.uiTitleId,
                            xboxXml
                            );

                        // load LTC to NPDB
                        ltc.Save();

                        StringBuilder processingInfo = new StringBuilder();

                        int newVersion = 0;
                        if (argParser["version"] != null)
                        {
                            try
                            {
                                newVersion = ParseVersion(argParser["version"]);
                            }
                            catch (Exception)
                            {
                                Console.WriteLine("There was an issue with the version you supplied.");
                                Console.WriteLine("Please use a hexadecimal number with leading '0x' for the base version");
                                return -1;
                            }

                        }

                        Title.CreateNewXboxTitle(XboxCfg, ltc, newVersion, ref processingInfo);
                        Console.WriteLine("Finished configuration of Xbox1 title... ");

                        //store files for safekeeping later... (do not copy an XQS file)                        
                        TitleVault.MoveFilesToTitleVault(xboxPath, xscPath, xmsPath, null, ltcPath, titleId.uiTitleId);

                        if (reload)
                        {
                            //Reset the appropriate front doors to make sure the settings "take"
                            //interface, process, component, command, timeout
                            ResetFrontDoor(Interface.kdcsvc, "", "xkdc", "reload", reloadTimeout);

                            //
                            // WebCache Reload
                            //
                            Console.WriteLine("Reloading webcaches...");
                            ResetFrontDoor(Interface.wcgeneral, "", "wcgeneral", "ReloadTitles", reloadTimeout);
                            ResetFrontDoor(Interface.wcpresence, "", "wcpresence", "ReloadTitles", reloadTimeout);
                            ResetFrontDoor(Interface.wcmessaging, "", "wcmessaging", "ReloadTitles", reloadTimeout);
                            ResetFrontDoor(Interface.wcalerts, "", "wcalerts", "ReloadTitles", reloadTimeout);
                            ResetFrontDoor(Interface.wcquery, "", "wcquery", "ReloadTitles", reloadTimeout);
                            ResetFrontDoor(Interface.wcsignature, "", "wcsignature", "ReloadTitles", reloadTimeout);
                            ResetFrontDoor(Interface.wcstats, "", "wcstats", "ReloadTitles", reloadTimeout);
                            ResetFrontDoor(Interface.wcstats, "", "wcstats", "ReloadLeaderboards", reloadTimeout);
                            ResetFrontDoor(Interface.wcstorage, "", "wcstorage", "ReloadTitles", reloadTimeout);
                            ResetFrontDoor(Interface.wcusers, "", "wcusers", "ReloadTitles", reloadTimeout);
                        }

                        //task: check whether title exists
                        if (Title.CheckExistUODBPartition(titleId.uiTitleId, 0))
                        {
                            ArrayList titleVers = Title.GetTitleVersions(titleId.uiTitleId, ref processingInfo);
                            string versionInfo = Title.ReportVersions(titleVers);
                            Console.WriteLine("\r\n\r\n" + versionInfo);
                        }
                        else
                        {
                            Console.WriteLine("The titleID specified does not exist. Please deploy this title first.");
                            return -1;
                        }
                    }
                    catch (SqlException se)
                    {
                        Console.WriteLine("An Error occurred calling SQL:\r\n" + se.Message + "\r\n" + se.StackTrace);
                        return -1;
                    }
                    catch (IOException ioe)
                    {
                        Console.WriteLine("An Error occurred accessing the file system:\r\n " + ioe.Message + "\r\n" + ioe.StackTrace);
                        return -1;
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine("\r\nTitle deployment was not successful.  The following error occurred:\r\n");
                        Console.WriteLine(e.Message + "\r\n\r\nThe Stack trace was: \r\n" + e.StackTrace);
                        return -1;
                    }

                    return 0;
                    #endregion
                }
                else if (
                    (null != argParser["deploy"]) &&
                    (null != argParser["xlastpath"]) &&
                    (null != argParser["ltcpath"])
                    )
                {
                    #region Action: /deploy

                    // they want to Deploy xlast and ltc to service, and create the title
                    try
                    {
                        Console.WriteLine("Commencing initial configuration of xbox 360 title... ");

                        string xlastPath = argParser["xlastpath"];
                        string ltcPath = argParser["ltcpath"];
                        bool processImages = (argParser["images"] != null);
                        bool isContentUpdate = (argParser["contentupdate"] != null);

                        FileInfo fi = new FileInfo(xlastPath);
                        string xlastDir = fi.Directory.FullName;


                        StreamReader xlastReader = new StreamReader(xlastPath);
                        string xlastXml = xlastReader.ReadToEnd();
                        xlastReader.Close();
                        string xlastVersion = XlastUtil.GetXlastVersion(xlastXml);

                        StreamReader ltcReader = new StreamReader(ltcPath);
                        string ltcXml = ltcReader.ReadToEnd();
                        ltcReader.Close();
                        ltc = LiveTitleConfig.FromXml(ltcXml);

                        //deserializing *now* confirms that we will be able to use it later...
                        XboxLiveSubmissionProject xlsp = XlastUtil.GetXlastFromXml(xlastXml);
                        GameConfigProject gcp = xlsp.GameConfigProject;

                        StringBuilder validationInformation = new StringBuilder();
                        if (!XlastChecker.CheckXlast(xlsp, ltc, ref validationInformation))
                        {
                            Console.WriteLine(validationInformation.ToString());
                            Console.WriteLine("LiveTitle: One or more server-side XLAST / LTC consistency checks failed.");
                            return -1;
                        }

                        CTitleId ctitleId;
                        try
                        {
                            ctitleId = new CTitleId(gcp.titleId);
                        }
                        catch
                        {
                            Console.WriteLine("Title ID in the XLAST file (\"" + gcp.titleId + "\") was unusable.");
                            return -1;
                        }

                        if (ctitleId.uiTitleId == 0)
                        {
                            Console.WriteLine("Title ID Supplied in the XLAST file was zero.  This is an invalid Title ID.");
                            return -1;
                        }

                        // if LOCKED directory exists, then do comparisons before propping
                        //
                        string lockedXlastPath = TitleVaultDir(ctitleId.uiTitleId, true) + "\\" + ctitleId.uiTitleId.ToString("x8") + ".xlast";
                        if (!File.Exists(lockedXlastPath))
                        {
                            Console.WriteLine("NOTE: no previously LOCKED xlast version found.  Proceeding, assuming all is ok.");
                        }
                        else
                        {
                            string lockedXlastXml;
                            using (StreamReader lockedXlastReader = new StreamReader(lockedXlastPath))
                            {
                                lockedXlastXml = lockedXlastReader.ReadToEnd();
                            }

                            XboxLiveSubmissionProject lockedXlsp = XlastUtil.GetXlastFromXml(lockedXlastXml);

                            if (!XlastComparer.IsValidUpdate(lockedXlsp, xlsp, validationInformation))
                            {
                                Console.WriteLine(validationInformation.ToString());
                                Console.WriteLine("\r\n\r\n!! Invalid XLAST update!   See errors above.");
                                return -1;
                            }

                            // attempting to limit this to a content update, so if the locked version
                            // exists, compare it to this new file to ensure changes are valid
                            //
                            if (isContentUpdate && !XlastComparer.IsContentUpdate(lockedXlsp, xlsp, TitleVaultDir(ctitleId.uiTitleId, true), xlastDir, validationInformation))
                            {
                                Console.WriteLine(validationInformation.ToString());
                                Console.WriteLine("\r\n\r\n!! /contentupdate specified, but new XLAST requires a title update!   See errors above.");
                                return -1;
                            }

                            Console.WriteLine("Comparision against LOCKED xlast succeeded, deploying for " + (isContentUpdate ? "CONTENT UPDATE" : "TITLE UPDATE") + ".");
                        }



                        //load files to npdb
                        XlastUtil.PutXlast(ctitleId.uiTitleId, xlastXml);
                        ltc.Save();

                        //task: ??? more specific exceptions with different catch (npdb, uodb, reporting, webdb, pcdb, etc)
                        //this allows us to get detailed information back to the caller...
                        StringBuilder processingInfo = new StringBuilder();

                        int newVersion = 0;
                        if (argParser["version"] != null)
                        {
                            try
                            {
                                newVersion = ParseVersion(argParser["version"]);
                            }
                            catch (Exception)
                            {
                                Console.WriteLine("There was an issue with the version you supplied.");
                                Console.WriteLine("Please use a hexadecimal number with leading '0x' for the base version");
                                return -1;
                            }

                        }

                        Title.CreateNew(xlsp, ltc, xlastDir, processImages, newVersion, ref processingInfo);

                        //task: add verbose option, and then output the processing info to the console...
                        //      a lousy design (considering we have xom logging... but they want *console* output... )

                        //store files for safekeeping later
                        MoveFilesToTitleVault(xlastPath, ltcPath, ctitleId.uiTitleId, gcp.Images, false, false);

                        if (reload)
                        {
                            //Reset the appropriate front doors to make sure the settings "take"
                            //interface, process, component, command, timeout
                            ResetFrontDoor(Interface.kdcsvc, "", "xkdc", "reload", reloadTimeout);
                        }

                        //task: check whether title exists
                        if (Title.CheckExistUODBPartition(ctitleId.uiTitleId, 0))
                        {
                            ArrayList titleVers = Title.GetTitleVersions(ctitleId.uiTitleId, ref processingInfo);
                            string versionInfo = Title.ReportVersions(titleVers);
                            Console.WriteLine("\r\n\r\n" + versionInfo);
                        }
                        else
                        {
                            Console.WriteLine("The titleID specified does not exist. Please deploy this title first.");
                            return -1;
                        }
                    }
                    catch (DuplicateTitleException)
                    {
                        //task: catch more general exception, and suggest user check auditdb...
                        //task: have a quick web page that retrieves that info like title browser

                        Console.WriteLine("\r\n\r\nThat titleID already exists in either the UODB or XPROFILE database. ");
                        Console.WriteLine(" Please use ChangeTitle to change existing titles or ");
                        Console.WriteLine(" DeleteTitle to clear this title's configuration.\r\n");
                        return -1;
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine("!!Serious Error occurred, and LiveTitle could not proceed:");
                        Console.WriteLine("  Error was:\r\n " + e.Message + "\r\n" + e.StackTrace);
                        return -1;
                    }
                    Console.WriteLine("\r\nTitle Configuration Complete.");
                    return 0;

                    #endregion
                }
                else if (
                    (null != argParser["deploy"]) &&
                    (null != argParser["marketplacepath"])
                    )
                {
                    #region Action: /deploy marketplace

                    // they want to Deploy a marketplace only title
                    try
                    {
                        Console.WriteLine("Commencing initial configuration of marketplace title... ");

                        string marketplacePath = argParser["marketplacepath"];
                        bool processImages = (argParser["images"] != null);

                        FileInfo fi = new FileInfo(marketplacePath);
                        string marketplaceDir = fi.Directory.FullName;

                        StreamReader marketplaceReader = new StreamReader(marketplacePath);
                        string marketplaceXml = marketplaceReader.ReadToEnd();
                        marketplaceReader.Close();

                        // Read marketplaceSchema XML file from NPDB
                        string marketplaceSchemaXml = XlastSchemaUtil.GetXlastSchema(MARKETPLACE_SCHEMA_VERSION);

                        // Validate marketplaceConfig XML file. This method throws an exception if xml is invalid
                        Console.WriteLine("Validating {0} against marketplace schema...", marketplacePath);
                        MarketplaceUtil.ValidateMarketplaceConfig(marketplaceXml, marketplaceSchemaXml);

                        // Deserializing now confirms that we will be able to use it later...
                        XboxLiveSubmissionProject xlsp = XlastUtil.GetXlastFromXml(marketplaceXml);

                        StringBuilder validationInformation = new StringBuilder();
                        if (!MarketplaceUtil.CheckMarketplaceConfig(xlsp, ref validationInformation))
                        {
                            Console.WriteLine(validationInformation.ToString());
                            Console.WriteLine("\r\n\r\n!! One or more server-side Marketplace consistency checks failed. See text above.");
                            return -1;
                        }

                        CTitleId ctitle;
                        try
                        {
                            ctitle = new CTitleId(xlsp.MarketplaceConfigProject.titleId);
                        }
                        catch
                        {
                            Console.WriteLine("Title ID in the marketplace file (\"" + xlsp.MarketplaceConfigProject.titleId + "\") was unusable.");
                            return -1;
                        }

                        if (ctitle.uiTitleId == 0)
                        {
                            Console.WriteLine("Title ID Supplied in the marketplace file was zero.  This is an invalid Title ID.");
                            return -1;
                        }

                        //task: ??? more specific exceptions with different catch (npdb, uodb, reporting, webdb, pcdb, etc)
                        //this allows us to get detailed information back to the caller...
                        StringBuilder processingInfo = new StringBuilder();

                        Title.CreateNew(xlsp, null, marketplaceDir, processImages, 0, ref processingInfo);

                        //task: add verbose option, and then output the processing info to the console...
                        //      a lousy design (considering we have xom logging... but they want *console* output... )

                        //store files for safekeeping later
                        MoveFilesToTitleVault(marketplacePath, null, ctitle.uiTitleId, xlsp.MarketplaceConfigProject.Images, true, false);

                        if (reload)
                        {
                            //Reset the appropriate front doors to make sure the settings "take"
                            //interface, process, component, command, timeout
                            ResetFrontDoor(Interface.kdcsvc, "", "xkdc", "reload", reloadTimeout);
                        }

                    }
                    catch (DuplicateTitleException)
                    {
                        //task: catch more general exception, and suggest user check auditdb...
                        //task: have a quick web page that retrieves that info like title browser

                        Console.WriteLine("\r\n\r\nThat titleID already exists in either the UODB or XPROFILE database. ");
                        Console.WriteLine(" Please use ChangeTitle to change existing titles or ");
                        Console.WriteLine(" DeleteTitle to clear this title's configuration.\r\n");
                        return -1;
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine("!!Serious Error occurred, and LiveTitle could not proceed:");
                        Console.WriteLine("  Error was:\r\n " + e.Message + "\r\n" + e.StackTrace);
                        return -1;
                    }
                    Console.WriteLine("\r\nTitle Configuration Complete.");
                    return 0;
                    #endregion
                }
                else if (
                    (null != argParser["lock"]) &&
                    (null != argParser["xlastpath"])
                    )
                {
                    #region Action: /lock
                    try
                    {
                        Console.WriteLine("Locking title... ");

                        string xlastPath = argParser["xlastpath"];

                        FileInfo fi = new FileInfo(xlastPath);
                        string xlastDir = fi.Directory.FullName;


                        StreamReader xlastReader = new StreamReader(argParser["xlastpath"].ToString());
                        string xlastXml = xlastReader.ReadToEnd();
                        xlastReader.Close();

                        string xlastVersion = XlastUtil.GetXlastVersion(xlastXml);

                        XboxLiveSubmissionProject xlsp = XlastUtil.GetXlastFromXml(xlastXml);

                        CTitleId titleID;
                        try
                        {
                            titleID = new CTitleId(xlsp.GameConfigProject.titleId);
                        }
                        catch
                        {
                            Console.WriteLine("Title ID in the XLAST file (\"" + xlsp.MarketplaceConfigProject.titleId + "\") was unusable.");
                            return -1;
                        }

                        if (titleID.uiTitleId == 0)
                        {
                            Console.WriteLine("Title ID Supplied in the marketplace file was zero.  This is an invalid Title ID.");
                            return -1;
                        }

                        MoveFilesToTitleVault(argParser["xlastpath"], null, titleID.uiTitleId, xlsp.GameConfigProject.Images, false, true);

                    }
                    catch (Exception e)
                    {
                        Console.WriteLine("!!Serious Error occurred, and LiveTitle could not proceed:");
                        Console.WriteLine("  Error was:\r\n " + e.Message + "\r\n" + e.StackTrace);
                        return -1;
                    }
                    Console.WriteLine("\r\nTitle Configuration Locked!");
                    return 0;
                    #endregion
                }
                else if (
                    (null != argParser["reportver"]) &&
                    (null != argParser["titleid"])
                    )
                {
                    #region Action: /reportver
                    //Display all version information for this title

                    //display version info
                    CTitleId ctitle;
                    try
                    {
                        //task: one day, I'll convert CTitleId to have static conversion methods...
                        ctitle = new CTitleId(argParser["titleid"]);
                    }
                    catch
                    {
                        Console.WriteLine("Title ID Supplied (\"" + argParser["titleid"] + "\") was unusable.");
                        return -1;
                    }

                    if (ctitle.uiTitleId == 0)
                    {
                        Console.WriteLine("Title ID Supplied was zero.  This is an invalid Title ID.");
                        return -1;
                    }

                    StringBuilder processingInfo = new StringBuilder();

                    ArrayList titleVers = Title.GetTitleVersions(ctitle.uiTitleId, ref processingInfo);

                    string versionInfo = Title.ReportVersions(titleVers);
                    Console.WriteLine("\r\n\r\n" + versionInfo);

                    return 0;
                    #endregion
                }
                else if (
                    (null != argParser["addbasever"]) &&
                    (null != argParser["titleid"]) &&
                    (null != argParser["version"]) &&
                    (null != argParser["platform"])
                    )
                {
                    #region Action: /addbasever

                    //display version info
                    StringBuilder processingInfo = new StringBuilder();
                    CTitleId ctitle;
                    ConsoleTypeEnum platform;

                    try
                    {
                        platform = (ConsoleTypeEnum)Enum.Parse(typeof(ConsoleTypeEnum), argParser["platform"], true);

                        if (platform != ConsoleTypeEnum.PC &&
                            platform != ConsoleTypeEnum.Xenon &&
                            platform != ConsoleTypeEnum.Xbox1 &&
                            platform != ConsoleTypeEnum.Mobile &&
                            platform != ConsoleTypeEnum.WebGames)
                            throw new ApplicationException("Invalid platform");
                    }
                    catch
                    {
                        Console.WriteLine("Valid values for /platform are 'Xbox1', 'Xenon', 'PC', 'Mobile' and 'WebGames'.");
                        return -1;
                    }

                    try
                    {
                        //task: one day, I'll convert CTitleId to have static conversion methods...
                        ctitle = new CTitleId(argParser["titleid"]);
                    }
                    catch
                    {
                        Console.WriteLine("Title ID Supplied was unusable.  Please read instructions and try again.");

                        return -1;
                    }

                    if (ctitle.uiTitleId == 0)
                    {
                        Console.WriteLine("Title ID Supplied was zero.  This is an invalid Title ID.");
                        return -1;
                    }

                    int newVersion = 0;
                    try
                    {
                        newVersion = ParseVersion(argParser["version"]);
                    }
                    catch (Exception)
                    {
                        Console.WriteLine("There was an issue with the version you supplied.");
                        Console.WriteLine("Please use a hexadecimal number with leading '0x' for the base version");
                        return -1;
                    }

                    Guid betaGroup = Guid.Empty;
                    try
                    {
                        if( null != argParser["group"] )
                        {
                            betaGroup = new Guid(argParser["group"]);
                        }
                    }
                    catch (Exception)
                    {
                        Console.WriteLine("There was an issue with the beta guid you supplied.");
                        Console.WriteLine("Please use a guid in the form of {00000000-0000-0000-0000-000000000000}");
                        return -1;
                    }

                    //task: check whether title exists
                    if (Title.CheckExistUODBPartition(ctitle.uiTitleId, 0))
                    {
                        Title.AddTitleVersion(ctitle.uiTitleId, newVersion, platform, betaGroup, ref processingInfo);
                        ArrayList titleVers = Title.GetTitleVersions(ctitle.uiTitleId, ref processingInfo);
                        string versionInfo = Title.ReportVersions(titleVers);
                        Console.WriteLine("\r\n\r\n" + versionInfo);
                        return 0;
                    }
                    else
                    {
                        Console.WriteLine("The titleID specified does not exist. Please deploy this title first.");
                        return -1;
                    }
                    #endregion
                }
                else if (
                    (null != argParser["delbasever"]) &&
                    (null != argParser["titleid"]) &&
                    (null != argParser["version"]) &&
                    (null != argParser["platform"])
                    )
                {
                    #region Action: /delbasever

                    //delete base version
                    StringBuilder processingInfo = new StringBuilder();
                    ConsoleTypeEnum platform;

                    try
                    {
                        platform = (ConsoleTypeEnum)Enum.Parse(typeof(ConsoleTypeEnum), argParser["platform"], true);

                        if (platform != ConsoleTypeEnum.PC &&
                            platform != ConsoleTypeEnum.Xenon &&
                            platform != ConsoleTypeEnum.Xbox1 &&
                            platform != ConsoleTypeEnum.Mobile &&
                            platform != ConsoleTypeEnum.WebGames)
                            throw new ApplicationException("Invalid platform");
                    }
                    catch
                    {
                        Console.WriteLine("Valid values for /platform are 'Xbox1', 'Xenon', 'PC', 'Mobile' and 'WebGames'.");
                        return -1;
                    }

                    CTitleId ctitle;
                    try
                    {
                        //task: one day, I'll convert CTitleId to have static conversion methods...
                        ctitle = new CTitleId(argParser["titleid"]);
                    }
                    catch
                    {
                        Console.WriteLine("Title ID Supplied was unusable.  Please read instructions and try again.");
                        return -1;
                    }

                    if (ctitle.uiTitleId == 0)
                    {
                        Console.WriteLine("Title ID Supplied was zero.  This is an invalid Title ID.");
                        return -1;
                    }

                    int baseVer = 0;
                    try
                    {
                        baseVer = ParseVersion(argParser["version"]);
                    }
                    catch (Exception)
                    {
                        Console.WriteLine("There was an issue with the version you supplied.");
                        Console.WriteLine("Please use a hexadecimal number with leading '0x' for the base version");
                        return -1;
                    }

                    Guid betaGroup = Guid.Empty;
                    try
                    {
                        if( null != argParser["group"] )
                        {
                            betaGroup = new Guid(argParser["group"]);
                        }
                    }
                    catch (Exception)
                    {
                        Console.WriteLine("There was an issue with the beta guid you supplied.");
                        Console.WriteLine("Please use a guid in the form of {00000000-0000-0000-0000-000000000000}");
                        return -1;
                    }


                    Title.DeleteVersion(ctitle.uiTitleId, baseVer, platform, betaGroup, ref processingInfo);

                    ArrayList titleVers = Title.GetTitleVersions(ctitle.uiTitleId, ref processingInfo);
                    string versionInfo = Title.ReportVersions(titleVers);
                    Console.WriteLine("\r\n\r\n" + versionInfo);

                    return 0;
                    #endregion
                }
                else
                {
                    Usage();
                    Console.WriteLine("\r\n\r\n--> Your request didn't match known commands and parameters.  Please check and try again. ");
                    return -1;
                }
            }
            catch (Exception e)
            {
                Console.WriteLine("LiveTitle encountered an exception.  Details follow:\r\n");
                Console.WriteLine(e.ToString());
                return -1;
            }

        } // main

        /// <summary>
        /// Converts a mobile/web title's xlast/gameconfig to it's console equivalent.
        /// It backs up the original file and writes the converted file with the same name.
        /// </summary>
        /// <param name="gameConfigFilePath">The path of the game config file.</param>
        /// <returns>Whether the tile is a mobile/web title.</returns>
        private static bool ConvertMobileAndWebTitlesToConsoleFormat(string gameConfigFilePath)
        {
            StreamReader gameConfigReader = new StreamReader(gameConfigFilePath);
            string gameConfigXML = gameConfigReader.ReadToEnd();
            Encoding fileEncoding = gameConfigReader.CurrentEncoding;
            gameConfigReader.Close();

            // Get required objects from xlast, which we can use later.
            XboxLiveSubmissionProject xlsp = XlastUtil.GetXlastFromXml(gameConfigXML);
            bool isMobileTitle = MobileAndWebLeaderboardUtils.IsMobileTitle(xlsp);

            if (isMobileTitle)
            {
                Console.WriteLine("The input gameconfig/xlast is for a mobile/web title, it will be converted to the console format: {0}", gameConfigFilePath);

                string localizationDataFilePath = GetDirectoryOfAssembly() + "\\" + MobileAndWebLeaderboardUtils.ColLocalizationDataFile;
                Dictionary<string, string> localizationData = MobileAndWebLeaderboardUtils.GetLocalizationDataDictionary(localizationDataFilePath);
                MobileAndWebLeaderboardUtils.ConvertMobileLeaderboardsToGeneralFormat(xlsp, localizationData);
                string convertedXML = XlastUtil.ToXml(xlsp);

                // Backup the original file.
                string backUpPath = gameConfigFilePath + ".bak-" + ((ulong)DateTime.UtcNow.Ticks);
                Console.WriteLine("Backing up the original gameconfig/xlast to: {0}", backUpPath);

                try
                {
                    File.Copy(gameConfigFilePath, backUpPath);
                }
                catch (Exception ex)
                {
                    Console.WriteLine("Error while trying to copy file: {0} to location: {1}", gameConfigFilePath, backUpPath);
                    Console.WriteLine("     {0}", ex.Message);

                    throw;
                }

                // Write the converted xml to the original path.
                Console.WriteLine("Writing the converted gameconfig/xlast to: {0}", gameConfigFilePath);

                try
                {
                    StreamWriter convertedWriter = new StreamWriter(gameConfigFilePath, false, fileEncoding);
                    convertedWriter.Write(convertedXML);
                    convertedWriter.Flush();
                    convertedWriter.Close();
                }
                catch (Exception ex)
                {
                    Console.WriteLine("Error in while trying to rewrite file: {0}", gameConfigFilePath);
                    Console.WriteLine("     {0}", ex.Message);

                    throw;
                }
            }

            return isMobileTitle;
        }

        /// <summary>
        /// Get the directory of the current assembly. e.g. C:\tools\bins\
        /// </summary>
        /// <returns>The directory of the current assembly.</returns>
        private static string GetDirectoryOfAssembly()
        {
            string assemblyLocation = Assembly.GetExecutingAssembly().Location;
            FileInfo fileInfo = new FileInfo(assemblyLocation);

            return fileInfo.DirectoryName;
        }

    } // Live title

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveToolsCommon\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveTitle\xboxutil\xboxutil.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Xml;
using System.Xml.Schema;
using System.Xml.Serialization;
using System.Xml.XPath;
using Microsoft.Ems.Tools.LiveTools.Common;
using xonline.common.config;
using xonline.common.livetitleconfig;

namespace Microsoft.Ems.Tools.LiveTitle
{

    public class XboxUtil
    {
        public const string XBOX_SCHEMA_VERSION = "XBOX";
        public const string TITLE_NAME_FRIENDLY_NAME = "X_STRINGID_TITLENAME";

        /// <summary>
        /// Returns the translations as an XmlNodeList for the localized title name strings for the xbox1 title.
        /// </summary>
        /// <param name="xboxXml">Path of the xbox1 configuration XML file</param>
        /// <returns>XmlNodeList containing the translations</returns>
        public static XboxConfigurationLocalizedString GetTitleNameLocalizedString(
            XboxConfiguration xboxCfg)
        {
            string TitleNameString = TITLE_NAME_FRIENDLY_NAME;
            XboxConfigurationLocalizedString localizedString = null;
            foreach (XboxConfigurationLocalizedString ls in xboxCfg.LocalizedStrings)
            {
                if (ls.friendlyName == TitleNameString)
                {
                    localizedString = ls;
                    break;
                }
            }
            return localizedString;
        }

        public static string ToXml(XboxConfiguration XboxCfg)
        {
            XmlSerializer serializer = new XmlSerializer(typeof(XboxConfiguration));
            StringWriter sw = new StringWriter();
            serializer.Serialize(sw, XboxCfg);
            return sw.ToString();
        }

        public static XboxConfiguration FromXml(string xboxXml)
        {
            XmlTextReader xmlReader = new XmlTextReader(new StringReader(xboxXml));
            XmlSerializer serializer = new XmlSerializer(typeof(XboxConfiguration));
            XboxConfiguration XboxCfg = (XboxConfiguration)serializer.Deserialize(xmlReader);
            return XboxCfg;
        }

        public static void PutXboxConfig(uint titleID, string xboxString)
        {

            using (SqlConnection conn = new SqlConnection(ConfigUtil.NpdbConnectionString))
            {
                conn.Open();
                SqlCommand cmd = conn.CreateCommand();
                cmd.CommandType = CommandType.StoredProcedure;

                //confirm that title doesn't already exist in NPDB
                cmd.CommandText = "dbo.p_game_save_config";

                cmd.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)titleID;
                cmd.Parameters["@i_title_id"].Direction = ParameterDirection.Input;

                cmd.Parameters.Add("@xml_config", SqlDbType.NText).Value = xboxString;
                cmd.Parameters["@xml_config"].Direction = ParameterDirection.Input;

                //task: hardcoded for now, will need to change once XLAST has the schema version.
                cmd.Parameters.Add("@vc_xdk_version", SqlDbType.VarChar, 50).Value = XBOX_SCHEMA_VERSION;
                cmd.Parameters["@vc_xdk_version"].Direction = ParameterDirection.Input;

                cmd.Parameters.Add("@hr", SqlDbType.Int);
                cmd.Parameters["@hr"].Direction = ParameterDirection.ReturnValue;

                SqlDataReader reader = cmd.ExecuteReader();

                reader.Close();
                conn.Close();
            }

        }

        public static bool CheckXboxConfig()
        {
            /*// Check GameConfig
            XboxCfg.GameConfig.titleId;
            // Check WebdbInfo
            XboxCfg.WebdbInfo;
            // Check Bounty
            XboxCfg.Bounty;
            // Check LocalizedStrings
            XboxCfg.LocalizedStrings;
            // Check ProductInformation
            XboxCfg.ProductInformation;


            if ( !CheckRating( ltc ) )
            {
            validXlast = false;
            }

            if ( !CheckLeaderBoards( ltc ) )
            {
            validXlast = false;
            }

            if ( !CheckBounty() )
            {
            validXlast = false;
            }
            return validXlast;*/
            return true;
        }

        //confirm rating elements conform to rating info in npdb
        public static bool CheckRating(LiveTitleConfig ltc)
        {

            //task: What checks should really be here?
            //            int rsid = 0;
            //            int rating = 0;
            //            try 
            //            {
            //                rsid = Convert.ToInt32( argParser[ "rsid" ] );
            //                rating = Convert.ToInt32( argParser[ "rating" ] );
            //            }
            //                //review: is there a more elegant way to do this?
            //            catch ( ArithmeticException )
            //            {
            //                Console.WriteLine( "Either the rating system ID or rating is unable to be converted to an integer." );
            //                return -1;
            //            }

            //            int esrb = 0;
            //            try 
            //            {
            //                esrb = Convert.ToInt32( argParser[ "esrb" ] );
            //
            //            }
            //                //review: is there a more elegant way to do this?
            //            catch ( ArithmeticException )
            //            {
            //                Console.WriteLine( "The esrb argument is unable to be converted to an integer." );
            //                return -1;
            //            }

            return true;
        }


        public static bool CheckBounty()
        {

            //            bool bounty;
            //            if (
            //                ( null != argParser[ "bountyflag" ] ) &&
            //                 (
            //                    ( "Y" == argParser[ "bountyflag" ] ) ||
            //                    ( "N" == argParser[ "bountyflag" ] )
            //                  )
            //                )
            //            {
            //                bounty = ( argParser[ "bountyflag" ] == "Y" );
            //                Console.WriteLine("bounty is " + bounty );
            //            }
            //            else
            //            {
            //                Usage();
            //                Console.WriteLine( "\n\r===> Incorrect Bounty Setting: Bounty must be Y or N!" );
            //                return 0;
            //            }

            return true;
        }

        //task: should this be here?
        //confirm leaderboards don't exceed LTC limits, and that XLAST and LTC contain same lbid's
        /*public static bool CheckLeaderBoards( LiveTitleConfig ltc )
        {
            int lbCount = 0;
            GameConfigProject gcp = xlsp.GameConfigProject;

            //IF there's stats, check consistency between XLAST and LTC
            if ( 
                ( gcp.StatsViews != null ) &&
                ( gcp.StatsViews.StatsView != null )
                )
            {
                lbCount += gcp.StatsViews.StatsView.Length;
            }

            //skill leaderboards count toward max as well
            if (
                ( gcp.GameModes != null ) &&
                ( gcp.GameModes.GameMode != null )
                )
            {
                lbCount += gcp.GameModes.GameMode.Length;
            }

            if ( lbCount > ltc.StatsMaxLeaderboards )
            {
                //task: NO CONSOLE OUTPUT HERE!!!
                Console.WriteLine( "The Xlast document contains more leaderboards than the LiveTitleConfig " );
                Console.WriteLine( " document allows.  Please reduce leaderboards in Xlast or increase MaxStatsLeaderboards in LTC." );
                return false;
            }

            return true;

        }  // checklb
        */

        /// <summary>
        /// Validate the XBOX XML against the schema
        /// </summary>
        /// <param name="xboxXml"></param>
        /// <param name="schemaXml"></param>
        /// <returns></returns>
        public static bool ValidateXboxConfigXML(string xboxXml, string schemaXml)
        {
            StringReader schemaStream = new StringReader(schemaXml);
            StringReader xmlStream = new StringReader(xboxXml);

            XmlReaderSettings xmlReaderSettings;
            XmlTextReader schemaReader;

            schemaReader = new XmlTextReader(schemaStream);
            xmlReaderSettings = new XmlReaderSettings();

            xmlReaderSettings.Schemas.Add("", schemaReader);
            xmlReaderSettings.ValidationType = ValidationType.Schema;
            XmlReader xmlReader = XmlReader.Create(xmlStream, xmlReaderSettings);

            bool validXml = false;
            try
            {
                while (xmlReader.Read()) ;
                validXml = true;
            }
            catch (Exception e)
            {
                throw new Exception("INVALID XBOX Xml document. Exception: " + e.ToString());
            }
            return validXml;
        }



    } // XboxUtil class

    [System.Xml.Serialization.XmlRootAttribute(Namespace = "", IsNullable = false)]
    public class XboxConfiguration
    {
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(Form = System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public XboxConfigurationGameConfig GameConfig;

        /// <remarks/>
        [System.Xml.Serialization.XmlArrayAttribute(Form = System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("LocalizedString", Form = System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable = false)]
        public XboxConfigurationLocalizedString[] LocalizedStrings;

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(Form = System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool Bounty;

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(Form = System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public XboxConfigurationWebdbInfo WebdbInfo;

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(Form = System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public XboxConfigurationProductInformation ProductInformation;
    }

    /// <remarks/>
    public class XboxConfigurationGameConfig
    {

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string version;

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string titleId;

        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool titleIdSpecified;

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string titleName;

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string name;

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string projectVersion;
    }

    /// <remarks/>
    public class XboxConfigurationProductInformationPublisher
    {

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string name;
    }

    /// <remarks/>
    public class XboxConfigurationProductInformation
    {

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(Form = System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public XboxConfigurationProductInformationPublisher Publisher;
    }

    /// <remarks/>
    public class XboxConfigurationWebdbInfo
    {

        /// <remarks/>
        //[System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, DataType="integer")]
        [System.Xml.Serialization.XmlElementAttribute(Form = System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string ESRB;

        /// <remarks/>
        //[System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, DataType="integer")]
        [System.Xml.Serialization.XmlElementAttribute(Form = System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string ClusterID;

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(Form = System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string DefaultLocale;
    }

    /// <remarks/>
    public class XboxConfigurationLocalizedStringTranslation
    {

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string locale;

        /// <remarks/>
        [System.Xml.Serialization.XmlTextAttribute()]
        public string Value;
    }

    /// <remarks/>
    public class XboxConfigurationLocalizedString
    {

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("Translation", Form = System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable = true)]
        public XboxConfigurationLocalizedStringTranslation[] Translation;

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string id;

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string friendlyName;
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "", IsNullable = false)]
    public class NewDataSet
    {

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("XboxConfiguration")]
        public XboxConfiguration[] Items;
    }



} // xonline.common.xboxutil namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveToolsCommon\GameIdMapping.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Diagnostics;
using Microsoft.Ems.Apps.Web.CatalogWebServiceProxy;
using System.Globalization;

// Documentation link: http://sharepoint/sites/ems/wiki/Catalog%20Object%20Id%20Generation%20from%20UODB.aspx

namespace Microsoft.Ems.Tools.LiveTools.Common
{
    /// <summary>
    /// Helper class that contains all the logic for how to map UODB Ids to CatalogDB Ids
    /// </summary>
    public static class GameIdMapping
    {
        public static Guid GetGuidForGame(int consoleType, uint liveTitleID)
        {
            // Replace console type 3 - marketplace with console type 2 - xbox 360.
            // It was agreed on this, to support a pre-release game propped via .marketplace file that later will
            // be proppped via .xlast

            int consoleTypeToUse = (consoleType == 3) ? 2 : consoleType;

            // 66acd000-77fe-1000-9115-D8cctttttttt
            // c = live console-type id
            // t = live title id
            return new Guid("66acd000-77fe-1000-9115-D8" + consoleTypeToUse.ToString("D2") + liveTitleID.ToString("X8"));
        }

        public static Guid GetGuidForProppingImage(ulong imageId, uint titleId, ulong offerId)
        {
            if (offerId != 0)
            {
                // If this is an offer associated image (there is only one image per offer):
                // tttttttt-oooo-4001-8000-ooooiiiiiiii
                // t = high DWORD of UODB Offer ID = title id
                // o = low DWORD of UODB Offer ID
                // i = image id

                ulong lowOfferId = offerId & 0x00000000FFFFFFFF;
                ulong highOfferId = offerId >> 32;
                ulong lowImageId = imageId & 0x00000000FFFFFFFF;
                return new Guid(highOfferId.ToString("X8") + "-" + (lowOfferId >> 16).ToString("X4") + "-4001-8000-" + (lowOfferId & 0x0000FFFF).ToString("X4") + lowImageId.ToString("X8"));
            }
            else
            {
                // If this is an title associated image:
                // tttttttt-00ii-4000-80ii-iiiiiiiiiiii
                // i = Image ID
                // t = Title ID

                ulong first8Bits = imageId >> 56;
                ulong second8Bits = (imageId & 0x00FF000000000000) >> 48;
                ulong last48Bits = imageId & 0x0000FFFFFFFFFFFF;
                return new Guid(titleId.ToString("X8") + "-00" + first8Bits.ToString("X2") + "-4000-80" + second8Bits.ToString("X2") + "-" + last48Bits.ToString("X12"));
            }
        }

        public static ushort GetPublisher(uint liveTitleID)
        {
            // publisher is the first two bytes of the liveTitleID
            return (ushort)(liveTitleID >> 16);
        }

        public static Guid GetGuidForGameContent(int gameContentMediaType, ulong offerId, Guid gameMediaId)
        {
            if ((gameContentMediaType == CatalogConstants.MediaType360ArcadeGame)
                || (gameContentMediaType == CatalogConstants.MediaType360Game)
                || (gameContentMediaType == CatalogConstants.MediaTypeXbox1Game)
                || (gameContentMediaType == CatalogConstants.MediaTypeCommunityGame))
            {
                // for Full Games, gameContent will be the actual game row.
                return gameMediaId;
            }
            else
            {
                return GameIdMapping.GetGuidForGameContent(offerId);
            }
        }

        private static Guid GetGuidForGameContent(ulong offerId)
        {
            // 00000000-0000-40oo-80oo-ooootttttttt
            // o = low DWORD of UODB Offer ID
            // t = high DWORD of UODB Offer ID = title id

            ulong low = offerId & 0x00000000FFFFFFFF;
            ulong high = offerId >> 32;

            return new Guid("00000000-0000-40" + (low >> 24).ToString("X2") + "-80" + ((low & 0x00FF0000) >> 16).ToString("X2") + "-" + (low & 0x0000FFFF).ToString("X4") + high.ToString("X8"));
        }

        /// <summary>
        /// Get the UODB offerId that is enconded in a Catalog Offer Id guid
        /// </summary>
        /// <param name="offerId"></param>
        /// <returns></returns>
        public static ulong GetOfferIdFromOfferGuid(Guid offerId)
        {
            // oooooooo-0000-4000-8000-0000tttttttt
            // o = low DWORD of UODB Offer ID
            // t = high DWORD of UODB Offer ID = title id
            string guidString = offerId.ToString();
            // get the digits back from the guid
            string offerIdString = guidString.Substring(28, 8) + guidString.Substring(0, 8);

            return UInt64.Parse(offerIdString, System.Globalization.NumberStyles.HexNumber);
        }

        public static Guid GetGuidForGameContentInstance(byte[] contentId)
        {
            if (contentId == null)
                throw new ArgumentNullException("contentId");
            if (contentId.Length < 14)
                throw new ArgumentException("This method requires that contentId is at least 14 bytes");

            // CCCCCCCC-CCCC-40CC-80CC-CCCCCCCCCCCC
            // C = Content ID bits

            // convert the byte array to a string
            // don't try to use the byte array directly
            // in the constructor of the Guid Class
            // because the order of the bytes was not read
            // in the same way

            StringBuilder sb = new StringBuilder(28);
            for (int i = 0; i < 14; i++)
            {
                sb.Append(contentId[i].ToString("x2"));
            }

            string contentIdString = sb.ToString();
            Debug.Assert(contentIdString.Length == 28);

            return new Guid(contentIdString.Substring(0, 8) + "-" +
                contentIdString.Substring(8, 4) + "-40" +
                contentIdString.Substring(12, 2) + "-80" +
                contentIdString.Substring(14, 2) + "-" +
                contentIdString.Substring(16));

        }

        public static Guid GetGuidForGameContentInstanceFile(byte[] contentId, int sortOrder)
        {
            if (contentId == null)
                throw new ArgumentNullException("contentId");
            if (contentId.Length < 12)
                throw new ArgumentException("This method requires that contentId is at least 12 bytes");

            // CCCCCCCC-CCCC-40CC-80CC-CCCCCCCCCCRR
            // C = Content ID bits
            // R = Content Location Sort Order (2 digits in hex format)

            // convert the byte array to a string
            // don't try to use the byte array directly
            // in the constructor of the Guid Class
            // because the order of the bytes was not read
            // in the same way

            StringBuilder sb = new StringBuilder(28);
            for (int i = 0; i < 13; i++)
            {
                sb.Append(contentId[i].ToString("x2"));
            }

            string contentIdString = sb.ToString();

            return new Guid(contentIdString.Substring(0, 8) + "-" +
                contentIdString.Substring(8, 4) + "-40" +
                contentIdString.Substring(12, 2) + "-80" +
                contentIdString.Substring(14, 2) + "-" +
                contentIdString.Substring(16, 10) +
                sortOrder.ToString("X2"));

        }

        public static Guid GetGuidForOffer(ulong offerId)
        {
            // oooooooo-0000-4000-8000-0000tttttttt
            // o = low DWORD of UODB Offer ID
            // t = high DWORD of UODB Offer ID = title id

            ulong low = offerId & 0x00000000FFFFFFFF;
            ulong high = offerId >> 32;

            return new Guid(low.ToString("X8") + "-0000-4000-8000-0000" + high.ToString("X8"));
        }

        public static Guid GetGuidForOfferInstance(ulong offerId, int userTypeId, byte countryCode, int paymentType)
        {
            // oooooooo-uccc-40pp-8000-0000tttttttt
            // o = low DWORD of UODB Offer ID
            // t = high DWORD of UODB Offer ID = title id
            // u = 0 (zero) if there are multple OfferInstanceUserType rows for this Offer Instance, or the exact UserTypeId from EMS CatalogDB if only one OfferInstanceUserType is present for the Offer Instance
            // ccc = numeric live CountryCode (hex)
            // pp = PaymentTypeID from EMS CatalogDB (Points = 1, Token = 2)

            ulong low = offerId & 0x00000000FFFFFFFF;
            ulong high = offerId >> 32;

            return new Guid(low.ToString("X8") + "-" + userTypeId.ToString("X1") + countryCode.ToString("X3") + "-40" + paymentType.ToString("X2") +"-8000-0000" + high.ToString("X8"));
        }

        public static bool IsXNAPublisher(ushort publisher)
        {
            foreach (ushort id in CatalogConstants.GamePublishersForXNA)
            {
                if (publisher == id)
                    return true;
            }
            return false;
        }

        public static bool IsServerBackedGame(ushort publisher)
        {
            foreach (ushort id in CatalogConstants.GamePublishersForSBG)
            {
                if (publisher == id)
                    return true;
            }
            return false;
        }

        public static int GetLcidFromUODBCultureId(int cultureId)
        {
            int lcid;

            // add special handling for en-HK, en-IN, en-SG, en-AE because those use the uodb i_culture_id
            // that is different to the lcids we use in EMS.
            switch (cultureId)
            {
                case UODBCultureIdEnIN: lcid = UODBLcIdEnIN; //en-IN
                    break;
                case UODBCultureIdEnHK: lcid = UODBLcIdEnHK; //en-HK
                    break;
                case UODBCultureIdEnSG: lcid = UODBLcIdEnSG; //en-SG
                    break;
                case UODBCultureIdEnAE: lcid = UODBLcIdEnAE; //en-AE
                    break;

                default:
                    lcid = cultureId;
                    break;
            }

            return lcid;
        }

        public static int GetRatingValueId(uint ratingId, uint ratingSystemId)
        {
            int catalogRatingValueId = -1;
            if (ratingId == 1 && ratingSystemId == 0) catalogRatingValueId = 0;
            if (ratingId == 2 && ratingSystemId == 0) catalogRatingValueId = 10;
            if (ratingId == 3 && ratingSystemId == 0) catalogRatingValueId = 20;
            if (ratingId == 4 && ratingSystemId == 0) catalogRatingValueId = 30;
            if (ratingId == 5 && ratingSystemId == 0) catalogRatingValueId = 40;
            if (ratingId == 6 && ratingSystemId == 0) catalogRatingValueId = 50;
            if (ratingId == 7 && ratingSystemId == 0) catalogRatingValueId = 60;
            if (ratingId == 8 && ratingSystemId == 0) catalogRatingValueId = 25;
            if (ratingId == 11 && ratingSystemId == 1) catalogRatingValueId = 14001;
            if (ratingId == 12 && ratingSystemId == 1) catalogRatingValueId = 14002;
            if (ratingId == 13 && ratingSystemId == 1) catalogRatingValueId = 14003;
            if (ratingId == 14 && ratingSystemId == 1) catalogRatingValueId = 14004;
            if (ratingId == 15 && ratingSystemId == 1) catalogRatingValueId = 14005;
            if (ratingId == 21 && ratingSystemId == 2) catalogRatingValueId = 4001;
            if (ratingId == 22 && ratingSystemId == 2) catalogRatingValueId = 4002;
            if (ratingId == 23 && ratingSystemId == 2) catalogRatingValueId = 4003;
            if (ratingId == 24 && ratingSystemId == 2) catalogRatingValueId = 4004;
            if (ratingId == 25 && ratingSystemId == 2) catalogRatingValueId = 4005;
            if (ratingId == 31 && ratingSystemId == 3) catalogRatingValueId = 5001;
            if (ratingId == 32 && ratingSystemId == 3) catalogRatingValueId = 5002;
            if (ratingId == 33 && ratingSystemId == 3) catalogRatingValueId = 5003;
            if (ratingId == 34 && ratingSystemId == 3) catalogRatingValueId = 5004;
            if (ratingId == 35 && ratingSystemId == 3) catalogRatingValueId = 5005;
            if (ratingId == 41 && ratingSystemId == 4) catalogRatingValueId = 6001;
            if (ratingId == 42 && ratingSystemId == 4) catalogRatingValueId = 6002;
            if (ratingId == 43 && ratingSystemId == 4) catalogRatingValueId = 6003;
            if (ratingId == 44 && ratingSystemId == 4) catalogRatingValueId = 6004;
            if (ratingId == 45 && ratingSystemId == 4) catalogRatingValueId = 6005;
            if (ratingId == 46 && ratingSystemId == 4) catalogRatingValueId = 6006;
            if (ratingId == 47 && ratingSystemId == 4) catalogRatingValueId = 6007;
            if (ratingId == 48 && ratingSystemId == 4) catalogRatingValueId = 6008;
            if (ratingId == 51 && ratingSystemId == 5) catalogRatingValueId = 100;
            if (ratingId == 52 && ratingSystemId == 5) catalogRatingValueId = 110;
            if (ratingId == 53 && ratingSystemId == 5) catalogRatingValueId = 120;
            if (ratingId == 54 && ratingSystemId == 5) catalogRatingValueId = 130;
            if (ratingId == 56 && ratingSystemId == 5) catalogRatingValueId = 140;
            if (ratingId == 61 && ratingSystemId == 6) catalogRatingValueId = 7001;
            if (ratingId == 62 && ratingSystemId == 6) catalogRatingValueId = 7002;
            if (ratingId == 63 && ratingSystemId == 6) catalogRatingValueId = 7003;
            if (ratingId == 64 && ratingSystemId == 6) catalogRatingValueId = 7004;
            if (ratingId == 65 && ratingSystemId == 6) catalogRatingValueId = 7005;
            if (ratingId == 71 && ratingSystemId == 7) catalogRatingValueId = 8001;
            if (ratingId == 72 && ratingSystemId == 7) catalogRatingValueId = 8002;
            if (ratingId == 73 && ratingSystemId == 7) catalogRatingValueId = 8003;
            if (ratingId == 74 && ratingSystemId == 7) catalogRatingValueId = 8004;
            if (ratingId == 75 && ratingSystemId == 7) catalogRatingValueId = 8005;
            if (ratingId == 81 && ratingSystemId == 8) catalogRatingValueId = 9001;
            if (ratingId == 82 && ratingSystemId == 8) catalogRatingValueId = 9002;
            if (ratingId == 83 && ratingSystemId == 8) catalogRatingValueId = 9003;
            if (ratingId == 84 && ratingSystemId == 8) catalogRatingValueId = 9004;
            if (ratingId == 85 && ratingSystemId == 8) catalogRatingValueId = 9005;
            if (ratingId == 91 && ratingSystemId == 9) catalogRatingValueId = 15001;
            if (ratingId == 92 && ratingSystemId == 9) catalogRatingValueId = 15002;
            if (ratingId == 93 && ratingSystemId == 9) catalogRatingValueId = 15003;
            if (ratingId == 94 && ratingSystemId == 9) catalogRatingValueId = 15004;
            if (ratingId == 101 && ratingSystemId == 10) catalogRatingValueId = 12001;
            if (ratingId == 102 && ratingSystemId == 10) catalogRatingValueId = 12002;
            if (ratingId == 103 && ratingSystemId == 10) catalogRatingValueId = 12003;
            if (ratingId == 104 && ratingSystemId == 10) catalogRatingValueId = 12004;
            if (ratingId == 105 && ratingSystemId == 10) catalogRatingValueId = 12005;
            if (ratingId == 111 && ratingSystemId == 11) catalogRatingValueId = 13001;
            if (ratingId == 112 && ratingSystemId == 11) catalogRatingValueId = 13002;
            if (ratingId == 113 && ratingSystemId == 11) catalogRatingValueId = 13003;
            if (ratingId == 114 && ratingSystemId == 11) catalogRatingValueId = 13004;
            if (ratingId == 115 && ratingSystemId == 11) catalogRatingValueId = 13005;
            if (ratingId == 116 && ratingSystemId == 11) catalogRatingValueId = 13006;
            if (catalogRatingValueId == -1)
            {
                throw new ArgumentException(string.Format(CultureInfo.InvariantCulture, "No mapping catalogRatingValueId present for UODB ratingId : {0} & ratingSystemId : {1}.", ratingId, ratingSystemId), "RatingValueId");
            }
            return catalogRatingValueId;

        }

        #region UODB Constants

        const int UODBCultureIdEnIN = 101081;
        const int UODBCultureIdEnHK = 103076;
        const int UODBCultureIdEnSG = 104100;
        const int UODBCultureIdEnAE = 114337;

        const int UODBLcIdEnIN = 16393;
        const int UODBLcIdEnHK = 15369;
        const int UODBLcIdEnSG = 18441;
        const int UODBLcIdEnAE = 14337;

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveToolsCommon\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveToolsCommon\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_microsoft.ems.tools.livetools.common_none_12.4.56.0_none_91df464bb3d6646b
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_microsoft.ems.tools.livetools.common_no-public-key_12.4.56.0_x-ww_b7a36ae3
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=microsoft.ems.tools.livetools.common
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_microsoft.ems.tools.livetools.common_no-public-key_12.4.56.0_x-ww_b7a36ae3
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_microsoft.ems.tools.livetools.common_no-public-key_12.4.56.0_x-ww_b7a36ae3.manifest
XP_MANIFEST_PATH=manifests\msil_microsoft.ems.tools.livetools.common_no-public-key_12.4.56.0_x-ww_b7a36ae3.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_microsoft.ems.tools.livetools.common_no-public-key_12.4.56.0_x-ww_b7a36ae3.cat
XP_CATALOG_PATH=manifests\msil_microsoft.ems.tools.livetools.common_no-public-key_12.4.56.0_x-ww_b7a36ae3.cat
XP_PAYLOAD_PATH=msil_microsoft.ems.tools.livetools.common_no-public-key_12.4.56.0_x-ww_b7a36ae3
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=microsoft.ems.tools.livetools.common,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveToolsCommon\console\NamedArgParser.cs ===
using System;
using System.IO;
using System.Collections;
using System.Globalization;
using System.Collections.Specialized;
using System.Diagnostics;

namespace Microsoft.Ems.Tools.LiveTools.Common
{


/// <remarks>
///     Generic class for parsing out command line arguments, in the
///     form of:
///
///     <example>
///         myprogram.exe /a:argument1 /b arg2 /novaluearg
///     </example>
///
///     Parsing takes place by calling the Parse() function.   the resulting
///     tag/value pairs can be access via the [] accessor (or Item() property).
/// </remarks>
public class NamedArgParser : StringDictionary
{
    private static char[] _defaultDelims = { '/', '-' };

    private bool _ignoreCase = true;
    private string _invalidArgText = "";

    private char[] _delims;
    private string[] _tags;



    /// <summary>
    ///     default constructor.  initalizes with default delimeters ('/' or '-')
    ///     and no specific tags.
    /// </summary>
    public NamedArgParser()             : this(null, _defaultDelims) { }
    /// <summary>
    ///     Initalize, limiting valid arguments to the given list of <paramref name='tags'>tags</paramref>.
    ///     initalizes with default delimeters ('/' or '-').
    ///     <param name='tags'>
    ///         tags to be used
    ///     </param>
    /// </summary>
    public NamedArgParser(string[] tags)    : this(tags, _defaultDelims) { }
    /// <summary>
    ///     Initalize, limiting valid arguments to the given list of <paramref name='tags'>tags</paramref>,
    ///     and using the given <paramref name='delimeters'>delimeters</paramref> for denoting tags.
    ///     <param name='tags'>
    ///         tags to be used
    ///     </param>
    ///     <param name='delimeters'>
    ///         argument delimeters to look for
    ///     </param>
    /// </summary>
    public NamedArgParser(string[] tags, char[] delimeters)
    {
        _tags = tags;
        _delims = delimeters;

#if DEBUG
        // tags cannot contain delimeters or ':' or '@'
        if (_tags != null) {
            for (int n=0; n < _tags.Length; n++) {
                Debug.Assert(_tags[n].IndexOf(":") == -1);
                Debug.Assert(_tags[n].IndexOf("@") == -1);
                for (int j=0; j < _delims.Length; j++) {
                    Debug.Assert(_tags[n].IndexOf(_delims[j]) == -1);
                }
            }
        }
#endif

    }

    /// <summary>
    ///     list of valid delimiter characters.  defaults to '/' and '-'
    /// </summary>
    public char[] Delimiters
    {
        set { _delims = value; }
        get { return _delims; }
    }

    /// <summary>
    ///     list of valid tags.  if not specified, all tags are allowed.
    ///     if it is specified, Parse() will fail if it encouters tags that
    ///     aren't listed in this array.
    /// </summary>
    public string[] Tags
    {
        set { _tags = value; }
        get { return _tags; }
    }

    /// <summary>
    ///     set to false if tags should be verified in a case-sensitive
    ///     way.  Defaults to true.
    /// </summary>
    public bool IgnoreCase
    {
        set { _ignoreCase = value; }
        get { return _ignoreCase; }
    }

    /// <summary>
    ///     returns an argument as an uint, or 0 if it can't be parsed.
    /// </summary>
    public uint ParseHexUInt(string tag) { bool b; return ParseHexUInt(tag, out b); }
    public uint ParseHexUInt(string tag, out bool success)
    {
        return (uint)ParseInt(tag, NumberStyles.HexNumber, out success);
    }



    /// <summary>
    ///     returns an argument as an uint, or 0 if it can't be parsed.
    /// </summary>
    public uint ParseUInt(string tag) { bool b; return ParseUInt(tag, out b); }
    public uint ParseUInt(string tag, out bool b) { return ParseUInt(tag, NumberStyles.Integer, out b); }
    public uint ParseUInt(string tag, NumberStyles defaultStyle, out bool success)
    {
        NumberStyles style = defaultStyle;
        string valstr;
        uint val = 0;

        success = true;

        try
        {
            valstr = this[tag];
            if (valstr == "" || valstr == null)
            {
                success = false;
                return val;
            }

            // check for hex indicator
            if (valstr.StartsWith("0x"))
            {
                style = NumberStyles.HexNumber;
                valstr = valstr.Substring(2);
            }

            val = UInt32.Parse(valstr, style);
        }
        catch (Exception)
        {
            success = false;
        }

        return val;
    }

    /// <summary>
    ///     returns an argument as an int, or 0 if it can't be parsed.
    /// </summary>
    public int ParseInt(string tag) { bool b; return ParseInt(tag, out b); }
    public int ParseInt(string tag, out bool b) { return ParseInt(tag, NumberStyles.Integer, out b); }
    public int ParseInt(string tag, NumberStyles defaultStyle, out bool success)
    {
        NumberStyles style = defaultStyle;
        string valstr;
        int val = 0;

        success = true;

        try
        {
            valstr = this[tag];
            if (valstr == "" || valstr == null)
            {
                success = false;
                return val;
            }

            // check for hex indicator
            if (valstr.StartsWith("0x"))
            {
                style = NumberStyles.HexNumber;
                valstr = valstr.Substring(2);
            }

            val = Int32.Parse(valstr, style);
        }
        catch (Exception)
        {
            success = false;
        }


        return val;
    }

    /// <summary>
    ///     returns an argument as an uLong, or 0 if it can't be parsed.
    /// </summary>
    public ulong ParseULong(string tag) { bool b; return ParseULong(tag, out b); }
    public ulong ParseULong(string tag, out bool success)
    {
        return (ulong)ParseLong(tag, out success);
    }

    /// <summary>
    ///     returns an argument as an uLong, or 0 if it can't be parsed.
    /// </summary>
    public ulong ParseHexULong(string tag) { bool b; return ParseULong(tag, out b); }
    public ulong ParseHexULong(string tag, out bool success)
    {
        return (ulong)ParseLong(tag, NumberStyles.HexNumber, out success);
    }

    /// <summary>
    ///     returns an argument as an Long, or 0 if it can't be parsed.
    /// </summary>
    public long ParseLong(string tag) { bool b; return ParseLong(tag, out b); }
    public long ParseLong(string tag, out bool success)  { return ParseLong(tag, NumberStyles.Integer, out success); }
    public long ParseLong(string tag, NumberStyles defaultStyle, out bool success)
    {
        NumberStyles style = defaultStyle;
        string valstr;
        long val = 0;

        success = true;

        try
        {
            valstr = this[tag];
            if (valstr == "" || valstr == null)
            {
                success = false;
                return val;
            }

            // check for hex indicator
            if (valstr.StartsWith("0x"))
            {
                style = NumberStyles.HexNumber;
                valstr = valstr.Substring(2);
            }

            val = Int64.Parse(valstr, style);
        }
        catch (Exception)
        {
            success = false;
        }


        return val;
    }


    /// <summary>
    ///     If a call to Parse() returns false, contains the
    ///     text of the argument that cased the failure.
    /// </summary>
    public string InvalidArgText
    {
        get { return _invalidArgText; }
    }

    /// <summary>
    ///     parses the list of arguments and populates the Args[] mapping.
    ///
    ///     <param name='args'>
    ///         the list of arguments, typically the arg list passed into Main()
    ///     </param>
    /// </summary>
    public bool Parse(string[] args)
    {
        int n;
        string arg;
        string tag;
        string value;
        int valueIndex;

        bool success = true;

        // The calling function is trying to parse args
        // but an empty string array have been passed.
        if( args.Length == 0 ){
            _invalidArgText = "";
            success = false;
        }

        for (n = 0; n < args.Length; n++) {

            arg = args[n];

            if (arg[0] == '@')
            {
                // it's a response file.
                success = ParseResponseFile(arg.Substring(1));
                if (!success) break;

                continue;
            }


            // get the tag
            tag = GetTag(arg);
            if (tag == "") {
                // no tag found, bad args
                _invalidArgText = arg;
                success = false;
                break;
            }

            // get the value associated with the tag (if any)
            value = "";
            valueIndex = arg.IndexOf(':');
            if (valueIndex > 0) {

                // the arg contains the value
                value = arg.Substring(valueIndex + 1);
            }

            // add the tag/value pair to the dictionary
            if (_ignoreCase == true) {
                tag = tag.ToLower();
            }

            try
            {
                base.Add(tag, value);
            }
            catch (ArgumentException)
            {
                _invalidArgText = tag;
                success = false;
                break;
            }

        }

        return success;
    }

    /// <summary>
    ///     Gets the tag name from the given <paramref name='arg'>argument</paramref> string.
    ///
    ///     <param name='arg'>the argument to parse</param>
    /// </summary>
    private string GetTag(string arg)
    {
        int n;
        string tag;

        for (n = 0; n < _delims.Length; n++) {
            if (arg[0] == _delims[n]) break;
        }

        if (n == _delims.Length) {
            // delimeter not found, must not be a tag
            return "";
        }

        // remove the delimeter
        arg = arg.Substring(1);

        n = arg.IndexOf(':');
        if (n > 0) {
            tag = arg.Substring(0, n);
        }
        else {
            tag = arg;
        }

        // if a set of tags have been specified, verify the list
        // against this potential tag.
        if (_tags != null) {
            for (n = 0; n < _tags.Length; n++) {
                if ((_ignoreCase == true && _tags[n].ToLower() == tag.ToLower()) ||
                    (_ignoreCase == false && _tags[n] == tag))  break;
            }

            if (n == _tags.Length) {
                // tag not found
                return "";
            }
        }

        return tag;

    }

    /// <summary>
    ///     Parses a file containing additional arguments.
    /// </summary>
    private bool ParseResponseFile(string filename)
    {
        StreamReader reader;
        StringCollection argList = new StringCollection();
        string[] args;
        string arg;

        try
        {
            reader = File.OpenText(filename);
            arg = reader.ReadLine();

            while (arg != null)
            {
                arg = arg.Trim();
                if (arg != "")
                    argList.Add(arg.Trim());

                arg = reader.ReadLine();
            }

            reader.Close();

            args = new string[argList.Count];
            argList.CopyTo(args, 0);

            return Parse(args);
        }
        catch(Exception e)
        {
            _invalidArgText = e.Message;
            return false;
        }
    }


}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveTitle\xboxutil\xboxchecker.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Xml;
using System.Xml.Schema;
using System.Xml.Serialization;
using System.Xml.XPath;
using System.Text;
using xonline.common.livetitleconfig;


namespace Microsoft.Ems.Tools.LiveTitle
{
    class XboxChecker
    {


        //            Console.WriteLine( "    <name>              - The name of the title (use quotes, limited to XXX unicode characters" );
        //            Console.WriteLine( "    <ClientTitleID>     - The title ID you want to configure (e.g. hexadecimal number 0xfffed000 )" );
        //            Console.WriteLine( "    <LiveTitleID>       - an alternate Title ID ***FIX THIS " );
        //            Console.WriteLine( "    <bountyflag>        - Is this title eligible for bounty payments (Y/N)" );
        //            Console.WriteLine( "    <esrb>              - " );
        //            Console.WriteLine( "    <rsid>              - rating system id (e.g. \"PIC\", \"ESRB\", etc.) " );
        //            Console.WriteLine( "    <rating>            - rating within the rating system" );
        //            Console.WriteLine( "    <clusterid>         - WebCache clusterID" );
        //            Console.WriteLine( "    <PCDBlocale>        - Locale ????  for PCDB (e.g. 1033 or \"en-us\" *** FIX THIS " );
        //            Console.WriteLine( "    <LiveLocale>        - Locale string (e.g. \"en-us\" " );


        //task: where do parameters get checked? *** In the new XBOXCheck class...  (e.g. name < 128, esrb foreign key, etc??)
        public static bool CheckXboxConfig( string xboxXml, string ltcXml, ref StringBuilder validationInfo )
        {
            bool validXlast = true;
            LiveTitleConfig ltc = null; 

            try 
            {
                ltc = LiveTitleConfig.FromXml( ltcXml );

            }
            catch
            {
                return false;
            }

            //task: seems like there should be a more elegant way to write this... 
            //task: should all check functions return an out string?

            if ( !CheckRating( ltc ) )
            {
                validXlast = false;
                validationInfo.Append( "\n-- CheckRating Has Failed." );
            }
            
            if ( !CheckLeaderBoards( ltc ) )
            {
                validXlast = false;
                validationInfo.Append( "\n-- The XSC document contains more leaderboards than the LiveTitleConfig " );
                validationInfo.Append( "\n-- document allows.  Please reduce leaderboards in XSC or increase MaxStatsLeaderboards in LTC." );
            }

            if ( !CheckBounty() )
            {
                validXlast = false;
                validationInfo.Append( "\n-- CheckBounty Has Failed." );
            }


            return validXlast;

        }


        //confirm rating elements conform to rating info in npdb
        public static bool CheckRating( LiveTitleConfig ltc )
        {

            //task: What checks should really be here?
//            int rsid = 0;
//            int rating = 0;
//            try 
//            {
//                rsid = Convert.ToInt32( argParser[ "rsid" ] );
//                rating = Convert.ToInt32( argParser[ "rating" ] );
//            }
//                //review: is there a more elegant way to do this?
//            catch ( ArithmeticException )
//            {
//                Console.WriteLine( "Either the rating system ID or rating is unable to be converted to an integer." );
//                return -1;
//            }

//            int esrb = 0;
//            try 
//            {
//                esrb = Convert.ToInt32( argParser[ "esrb" ] );
//
//            }
//                //review: is there a more elegant way to do this?
//            catch ( ArithmeticException )
//            {
//                Console.WriteLine( "The esrb argument is unable to be converted to an integer." );
//                return -1;
//            }

            return true;
        }


        public static bool CheckBounty()
        {

            //            bool bounty;
            //            if (
            //                ( null != argParser[ "bountyflag" ] ) &&
            //                 (
            //                    ( "Y" == argParser[ "bountyflag" ] ) ||
            //                    ( "N" == argParser[ "bountyflag" ] )
            //                  )
            //                )
            //            {
            //                bounty = ( argParser[ "bountyflag" ] == "Y" );
            //                Console.WriteLine("bounty is " + bounty );
            //            }
            //            else
            //            {
            //                Usage();
            //                Console.WriteLine( "\n\r===> Incorrect Bounty Setting: Bounty must be Y or N!" );
            //                return 0;
            //            }

            return true;
        }

        //task: should this be here?
        //confirm leaderboards don't exceed LTC limits, and that XLAST and LTC contain same lbid's
        public static bool CheckLeaderBoards( LiveTitleConfig ltc )
        {
            //IF there's stats, check consistency between XSC and LTC

            if (ltc.LeaderboardConfigs != null) //null means that there were no leaderboards - that is how the current code is now - It is ok for a title to have 0 leaderboard
            {
                if ( ltc.LeaderboardConfigs.Length > ltc.StatsMaxLeaderboards )
                {
                    //task: NO CONSOLE OUTPUT HERE!!!
                    Console.WriteLine( "The XSC document contains more leaderboards than the LiveTitleConfig " );
                    Console.WriteLine( " document allows.  Please reduce leaderboards in XSC or increase MaxStatsLeaderboards in LTC." );
                    return false;
                }
            }
            else
            {
                Console.WriteLine(String.Format("Warning --- Title ID {0} Has No LeaderBoards", ltc.TitleID));
            }

            return true;

        }  // checklb

    }

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveTitle\toolsframework\CXsc.cs ===
using System;
using System.IO;
using System.Net;
using System.Text;
using System.Xml;
using System.Collections;
using Microsoft.CSharp;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Reflection;
using xonline.tools.framework;

namespace Microsoft.Ems.Tools.LiveTitle 
{
    /// <summary>
    /// This class encapsulates the logic that reads in a title's stats configuration in xml format
    /// and applies that configuration to the stats cluster.
    /// </summary>
    public class CXsc
    {
        private CLog m_log = null;

        private XmlDocument m_xmlDoc = null;
        private int m_iXscVersion = 0;

        private XmlNamespaceManager m_xmlnsm = null;

        public CXsc(MemoryStream dataStream, CLog log)
        {
            if (dataStream == null)
            {
                throw new ArgumentNullException("dataStream");
            }
            if (log == null)
            {
                m_log = new CLogNull();
            }
            else
            {
                m_log = log;
            }

            m_xmlDoc = new XmlDocument();
            try
            {
                m_xmlDoc.Load(dataStream);
            }
            catch (XmlException xmlException)
            {
                string sErr = "Xbox.Tools.Framework.CXsc.ctor: "
                    + "xsc file "
                    + " does not contain well formed xml data";
                m_log.WriteLineV(sErr);
                m_log.WriteLineV("XmlException.LineNumber: " + xmlException.LineNumber);
                m_log.WriteLineV("XmlException.LinePosition: " + xmlException.LinePosition);
                m_log.WriteLineV("XmlException.Message: " + xmlException.Message);
                throw new CXscException(sErr, xmlException);
            }
            

            ValidateXmlDocument ();

        }

        public CXsc(string sPathAndFileName, CLog log)
        {
            if (sPathAndFileName == null)
            {
                throw new ArgumentNullException("sPathAndFileName");
            }
            if (log == null)
            {
                m_log = new CLogNull();
            }
            else
            {
                m_log = log;
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.ctor("
                + sPathAndFileName + ", "
                + "{log})");

            m_xmlDoc = new XmlDocument();

            if (!File.Exists(sPathAndFileName))
            {
                string sErr = "Xbox.Tools.Framework.CXsc.ctor: "
                    + "xsc file "
                    + sPathAndFileName
                    + " does not exist";
                m_log.WriteLineV(sErr);
                throw new CXscException(sErr);
            }

            FileStream fileStream = File.OpenRead(sPathAndFileName);
            try
            {
                m_xmlDoc.Load(fileStream);
            }
            catch (XmlException xmlException)
            {
                string sErr = "Xbox.Tools.Framework.CXsc.ctor: "
                    + "xsc file "
                    + sPathAndFileName
                    + " does not contain well formed xml data";
                m_log.WriteLineV(sErr);
                m_log.WriteLineV("XmlException.LineNumber: " + xmlException.LineNumber);
                m_log.WriteLineV("XmlException.LinePosition: " + xmlException.LinePosition);
                m_log.WriteLineV("XmlException.Message: " + xmlException.Message);
                throw new CXscException(sErr, xmlException);
            }
            finally
            {
                fileStream.Close();
            }

            ValidateXmlDocument ();
        }

        public int Version
        {
            get
            {
                return m_iXscVersion;
            }
        }

        private void ValidateXmlDocument ()
        {
            // use the name table from the now-loaded document to initialize
            // a namespace manager - we need this to make the Select statements
            // below work properly
            m_xmlnsm = new XmlNamespaceManager(m_xmlDoc.NameTable);

            // add the xboxlive URI to the namespace manager
            m_xmlnsm.AddNamespace(ns, "http://www.xboxlive.com");

            // version 1 xsc files used 'version' attribute on Title element
            // version 3 xsc files used 'Version' attribute on Title element, whoops.
            string sV1Xpath = "/"+nsPfx("Title")+"/@version";
            string sV3Xpath = "/"+nsPfx("Title")+"/@Version";

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.ctor: "
                + "Selecting node that matches: "
                + sV3Xpath);
            XmlAttribute xmlAttrVersion = 
                (XmlAttribute)m_xmlDoc.SelectSingleNode(sV3Xpath, m_xmlnsm);
            if (xmlAttrVersion == null)
            {
                // we only look for the old style version attribute if the
                // new style one is missing
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.ctor: "
                    + "Selecting node that matches: "
                    + sV1Xpath);
                xmlAttrVersion= 
                    (XmlAttribute)m_xmlDoc.SelectSingleNode(sV1Xpath, m_xmlnsm);
            }
            string sVersion = null;
            if (xmlAttrVersion != null)
            {
                sVersion = xmlAttrVersion.Value;
            }

            if (sVersion != null)
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.ctor: "
                    + "found version attribute of "
                    + sVersion);

                // we only look at the major version, so grab everything
                // before the first '.', if there is one
                if (sVersion.IndexOf('.') != -1)
                {
                    sVersion = sVersion.Substring(0, sVersion.IndexOf('.'));
                }
                try
                {
                    m_iXscVersion = Int32.Parse(sVersion);
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.ctor: "
                        + "Using version "
                        + m_iXscVersion
                        + " format.");
                }
                catch (Exception e)
                {
                    string sErr = "Xbox.Tools.Framework.CXsc.ctor: "
                        + "unable to parse major version of "
                        + sVersion
                        + " into an integer ";
                    m_log.WriteLineV(sErr);
                    throw new CXscException(sErr, e);
                }
            }
            else
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.ctor: "
                    + "No version specfied in xsc file, defaulting to version 1 format");
                m_iXscVersion = 1;
            }
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.ctor complete");
        }
        private string nsPfx(string sElemName)
        {
            return ns + ":" + sElemName;
        }

        private string ns
        {
            get { return "xbl"; }
        }

        private string TitleXpath
        {
            get {return "/"+ ns + ":Title";}
        }

        private string TitleIDXpath
        {
            get
            {
                if (m_iXscVersion < 3)
                {
                    return TitleXpath+"/@titleid";
                }
                return TitleXpath+"/@TitleID";
            }
        }

        private string UnitDecayXpath 
        {
            get { return TitleXpath+"/@UnitLeaderboardDecayConstant"; }
        }

        private string DefaultLocaleXpath
        {
            get
            {
                if (m_iXscVersion < 3)
                {
                    return TitleXpath+"/@default_locale";
                }
                return TitleXpath+"/@Default_Locale";
            }
        }

        private string IndLBListXpath
        {
            get
            {
                if (m_iXscVersion < 3)
                {
                    return TitleXpath
                        +"/"+ns+":Leaderboard";
                    
                }
                return TitleXpath
                    +"/"+ns+":LeaderboardContainer[@type='individual']"
                    +"/"+ns+":Leaderboard";
            }
        }

        private string UnitLBListXpath 
        {
            get
            {
                return TitleXpath
                    +"/"+nsPfx("LeaderboardContainer[@type='units']")
                    +"/"+nsPfx("Leaderboard");
            }
        }

        private string CompLBListXpath 
        {
            get
            {
                return TitleXpath
                    +"/"+nsPfx("LeaderboardContainer[@type='competitions']")
                    +"/"+nsPfx("LeaderboardTemplate");
            }
        }

        private string LBIDAttr
        {
            get
            {
                if (m_iXscVersion < 3)
                {
                    return "id";
                }
                return "ID";
            }
        }

        private string IndLBXpath(uint uiLBNum)
        {
                return IndLBListXpath+"[@"+LBIDAttr+"="+uiLBNum+"]";
        }

        private string UnitLBXpath(uint uiLBNum)
        {
                return UnitLBListXpath+"[@"+LBIDAttr+"="+uiLBNum+"]";
        }

        private string CompLBXpath(uint uiLBNum)
        {
                return CompLBListXpath+"[@"+LBIDAttr+"="+uiLBNum+"]";
        }

        // relative to IndLBXpath, UnitLBXpath, or CompLBXpath
        private string ResetXpath
        {
            get { return ns+":Reset/text()"; }
        }

        private string Top100Xpath 
        {
            get { return ns+":TopOneHundred/text()"; }
        }

        private string DecayDaysXpath 
        {
            get { return ns+":DecayDays/text()"; }
        }

        private string TeamsXpath
        {
            get { return ns+":TeamsLeaderboard/text()"; }
        }

        private string ArbitrateXpath
        {
            get { return ns+":Arbitrate/text()"; }
        }

        private string AttachCountXpath
        {
            get { return ns+":Attachments/"+ns+":Uploads/text()"; }
        }

        private string MaxAttachSizeXpath 
        {
            get { return ns+":Attachments/"+ns+":Size/text()"; }
        }

        private string ELOInitXpath 
        {
            get { return ns+":ELO/"+ns+":InitialPlayerRating/text()"; }
        }

        private string ELOScaleXpath 
        {
            get { return ns+":ELO/"+ns+":RatingScaleFactor/text()"; }
        }

        private string ELOExpXpath 
        {
            get { return ns+":ELO/"+ns+":ExponentialBase/text()"; }
        }

        private string ELORangeListXpath 
        {
            get
            {
                return ns+":ELO/"
                    +ns+":MaxWeightRatingRangeArray/"
                    +ns+":MaxWeightRatingRange";
            }
        }

        // relative to ELORangeListXpath
        private string ELORangeStartXpath
        {
            get { return "@start"; }
        }

        private string ELORangeWeightXpath
        {
            get { return "@maxweight"; }
        }

        // relative to IndLBXpath, UnitLBXpath, or CompLBXpath
        private string DescListXpath
        {
            get { return ns+":Names/"+ns+":LocalizedName"; }
        }

        // relative to DescListXpath
        private string LBDescNameXpath
        {
            get { return ns+":Name/text()"; }
        }

        private string LBDescLocaleXpath
        {
            get { return ns+":Locale/text()"; }
        }

        // relative to IndLBXpath, UnitLBXpath, or CompLBXpath
        private string AttrListXpath
        {
            get { return ns+":RawAttributes/"+ns+":Attribute"; }
        }

        // relative to LBAttrListXpath
        private string LBAttrIndexXpath
        {
            get { return ns+":Index/text()"; }
        }

        private string LBAttrIsPuidXpath
        {
            get 
            {
                if (m_iXscVersion < 3)
                {
                    return ns+":Puid/text()";
                }
                return ns+":PUID/text()";
            }
        }

        // relative to IndLBXpath, UnitLBXpath, or CompLBXpath
        private string ValueListXpath
        {
            get { return ns+":FormattedValues/"+ns+":FormattedValue"; }
        }

        // relative to IndLBXpath, UnitLBXpath, or CompLBXpath
        private string ValueXpath(string sName)
        {
            return ValueListXpath+"[xbl:NameID/text()="+sName+"]";
        }

        // relative to LBValueXpath or LBValueListXpath
        private string LBValueNameXpath 
        {
            get { return ns+":NameID/text()"; }
        }

        // relative to IndLBXpath, UnitLBXpath, or CompLBXpath
        private string ValueTypeXpath(string sName)
        {
            return ValueXpath(sName)+"/"+ns+":Type/text()";
        }

        // relative to IndLBXpath, UnitLBXpath, or CompLBXpath
        private string ValueFormulaXpath (string sName)
        {
            return ValueXpath(sName)+"/"+ns+":Formula/text()";
        }

        // relative to IndLBXpath, UnitLBXpath, or CompLBXpath
        private string ValueDescListXpath(string sName)
        {
            return ValueXpath(sName)+"/"+ns+":Names/"+ns+":LocalizedName";
        }

        // relative to LBValueDescListXpath
        private string LBValueDescNameXpath 
        {
            get { return ns+":Name/text()"; }
        }

        private string LBValueDescLocaleXpath
        {
            get { return ns+":Locale/text()"; }
        }

        public bool TitleIdGet(out CTitleId tid)
        {
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.TitleIdGet("
                + "{out tid})");

            tid = null;
            bool bFound = false;

            string sXpath = TitleIDXpath;
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.TitleIdGet: "
                + "Selecting node that matches: "
                + sXpath);
            XmlAttribute xmlAttr = (XmlAttribute)m_xmlDoc.SelectSingleNode(sXpath, m_xmlnsm);
            if (xmlAttr == null)
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.TitleIdGet: "
                    + "Unable to find titleid");
                bFound = false;
                tid = null;
            }
            else
            {
                string sTitleId = xmlAttr.Value;
                try
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.TitleIdGet: "
                        + "Found titleid of "
                        + sTitleId);
                    // titleid is specified in the xsc file in hex but without the
                    // "0x" prefix. Prepend the prefix and try to parse it
                    tid = new CTitleId("0x" + sTitleId);
                    bFound = true;
                }
                catch (Exception)
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.TitleIdGet: "
                        + "titleid in of '" 
                        + sTitleId 
                        + "' is not in the correct format");
                    bFound = false;
                    tid = null;
                }
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.TitleIdGet complete, returning: " + bFound);
            return bFound;
        }

        public bool UnitDecayFactorGet(out double dUnitLBDecayFactor)
        {
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitDecayFactorGet("
                + "{out dUnitLBDecayFactor})");

            dUnitLBDecayFactor = 0.0;
            bool bFound = false;

            string sXpath = UnitDecayXpath;
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitDecayFactorGet: "
                + "Selecting node that matches: "
                + sXpath);
            XmlAttribute xmlAttr = (XmlAttribute)m_xmlDoc.SelectSingleNode(sXpath, m_xmlnsm);
            if (xmlAttr == null)
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitDecayFactorGet: "
                    + "Unit decay factor not found");
                bFound = false;
                dUnitLBDecayFactor = 0.0;
            }
            else
            {
                string sDecayFactor = xmlAttr.Value;
                try
                {
                    // try to parse it
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitDecayFactorGet: "
                        + "Found UnitLeaderboardDecayConstant attribute in Title element with value "
                        + sDecayFactor);
                    dUnitLBDecayFactor = Double.Parse(sDecayFactor);
                    bFound = true;
                }
                catch (Exception)
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitDecayFactorGet: "
                        + "Could not parse unit decay factor of '" 
                        + sDecayFactor
                        + " as a double.");
                    bFound = false;
                    dUnitLBDecayFactor = 0.0;
                }
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitDecayFactorGet complete, returning: " + bFound);
            return bFound;
        }

        public bool DefaultLocaleGet(out CLocale locDefault)
        {
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.DefaultLocaleGet("
                + "{out dUnitLBDecayFactor})");

            locDefault = null;
            bool bFound = false;

            string sXpath = DefaultLocaleXpath;
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.DefaultLocaleGet: "
                + "Selecting node that matches: "
                + sXpath);
            XmlAttribute xmlAttr = (XmlAttribute)m_xmlDoc.SelectSingleNode(sXpath, m_xmlnsm);
            if (xmlAttr == null)
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.DefaultLocaleGet: "
                    + "Default locale not found");
                bFound = false;
                locDefault = null;
            }
            else
            {
                string sDefaultLocale = xmlAttr.Value;
                try
                {
                    // try to parse it
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.DefaultLocaleGet: "
                        + "Found default locale of "
                        + sDefaultLocale);
                    locDefault = new CLocale(sDefaultLocale);
                    bFound = true;
                }
                catch (Exception)
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.DefaultLocaleGet: "
                        + sDefaultLocale 
                        + " is not a valid locale string ");
                    bFound = false;
                    locDefault = null;
                }
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.DefaultLocaleGet complete, returning: " + bFound);
            return bFound;
        }

        public uint[] LBGetList()
        {
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBGetList()");

            ArrayList al = new ArrayList();

            string sXpath = IndLBListXpath;
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBGetList: "
                + "Selecting nodes that match: "
                + sXpath);
            XmlNodeList xmlNodeList = m_xmlDoc.SelectNodes(sXpath, m_xmlnsm);
            foreach (XmlNode xmlNode in xmlNodeList)
            {
                uint ui;

                // the leaderboard id is in the id attribute on the leaderboard element
                if (xmlNode.Attributes != null)
                {
                    XmlAttribute xmlAttr = xmlNode.Attributes[LBIDAttr];
                    if (xmlAttr != null)
                    {
                        // found an ID, try to parse it as a uint
                        try
                        {
                            ui = UInt32.Parse(xmlAttr.Value);
                            
                            // if it parsed, then add it to the list
                            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBGetList: "
                                + "found individual leaderboard id "
                                + ui);
                            al.Add(ui);
                        }
                        catch (Exception e)
                        {
                            // didn't parse, log the info, then continue
                            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBGetList: "
                                + "Could not parse leaderboard id value of "
                                + xmlAttr.Value
                                + ". This element will be ignored. Exception details: "
                                + e.Message);
                        }
                    }
                    else
                    {
                        m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBGetList: "
                            + " Leaderboard element is missing the "
                            + LBIDAttr
                            + " attribute and will be ignored");
                    }
                }
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBGetList: "
                + al.Count
                + " individual leaderboards found");
            uint[] rgui = new uint[al.Count];
            al.CopyTo(rgui);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBGetList complete");
            return rgui;
        }

        public uint[] UnitGetList()
        {
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitGetList()");

            ArrayList al = new ArrayList();

            string sXpath = UnitLBListXpath;
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitGetList: "
                + "Selecting nodes that match: "
                + sXpath);
            XmlNodeList xmlNodeList = m_xmlDoc.SelectNodes(sXpath, m_xmlnsm);
            foreach (XmlNode xmlNode in xmlNodeList)
            {
                uint ui;

                // the leaderboard id is in the id attribute on the leaderboard element
                if (xmlNode.Attributes != null)
                {
                    XmlAttribute xmlAttr = xmlNode.Attributes[LBIDAttr];
                    if (xmlAttr != null)
                    {
                        // found an ID, try to parse it as a uint
                        try
                        {
                            ui = UInt32.Parse(xmlAttr.Value);
                            
                            // if it parsed, then add it to the list
                            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitGetList: "
                                + "found unit leaderboard id "
                                + ui);
                            al.Add(ui);
                        }
                        catch (Exception e)
                        {
                            // didn't parse, log the info, then continue
                            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitGetList: "
                                + "Could not parse unit id value of "
                                + xmlAttr.Value
                                + ". This element will be ignored. Exception details: "
                                + e.Message);
                        }
                    }
                    else
                    {
                        m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitGetList: "
                            + " Leaderboard element is missing the "
                            + LBIDAttr
                            + " attribute and will be ignored");
                    }
                }
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitGetList: "
                + al.Count
                + " unit leaderboards found");
            uint[] rgui = new uint[al.Count];
            al.CopyTo(rgui);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitGetList complete");
            return rgui;
        }

        public uint[] CompGetList()
        {
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompGetList()");

            ArrayList al = new ArrayList();

            string sXpath = CompLBListXpath;
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompGetList: "
                + "Selecting nodes that match: "
                + sXpath);
            XmlNodeList xmlNodeList = m_xmlDoc.SelectNodes(sXpath, m_xmlnsm);
            foreach (XmlNode xmlNode in xmlNodeList)
            {
                uint ui;

                // the comp template id is in the id attribute on the 
                // leaderboard template element
                if (xmlNode.Attributes != null)
                {
                    XmlAttribute xmlAttr = xmlNode.Attributes[LBIDAttr];
                    if (xmlAttr != null)
                    {
                        // found an ID, try to parse it as a uint
                        try
                        {
                            ui = UInt32.Parse(xmlAttr.Value);
                            
                            // if it parsed, then add it to the list
                            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompGetList: "
                                + "found competition template id "
                                + ui);
                            al.Add(ui);
                        }
                        catch (Exception e)
                        {
                            // didn't parse, log the info, then continue
                            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompGetList: "
                                + "Could not parse competition template id value of "
                                + xmlAttr.Value
                                + ". This element will be ignored. Exception details: "
                                + e.Message);
                        }
                    }
                    else
                    {
                        m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompGetList: "
                            + " LeaderboardTemplate element is missing the "
                            + LBIDAttr
                            + " attribute and will be ignored");
                    }
                }
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompGetList: "
                + al.Count
                + " competition templates found");
            uint[] rgui = new uint[al.Count];
            al.CopyTo(rgui);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompGetList complete");
            return rgui;
        }

        public bool LBConfigGet(
            uint uiLBNum, 
            ref ELBReset lbReset,
            ref uint uiAttachCount,
            ref uint uiMaxAttachSize,
            ref uint uiDecayDays,
            ref uint uiMaxRatingCount,
            ref bool bRequireArbitration,
            ref bool bIsTeam,
            ref CELOConfig eloConfig)
        {
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBConfigGet()");

            // note, we use 'ref' instead of 'out' parameters here so the 
            // caller can set the default they want if we don't find anything
            // in the xml file.

            bool bFound = false;

            // get the leaderboard element
            string sXpath = IndLBXpath(uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBConfigGet: "
                + "Selecting node that matches: "
                + sXpath);
            XmlNode xmlNode = m_xmlDoc.SelectSingleNode(sXpath, m_xmlnsm);
            if (xmlNode == null)
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBConfigGet: "
                    + "leaderboard id "
                    + uiLBNum
                    + " not found");
                bFound = false;
            }
            else
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBConfigGet: "
                    + "found leaderboard id "
                    + uiLBNum);

                ResetGet(xmlNode, ref lbReset);
                AttachCountGet(xmlNode, ref uiAttachCount);
                MaxAttachSizeGet(xmlNode, ref uiMaxAttachSize);
                DecayDaysGet(xmlNode, ref uiDecayDays);
                MaxRatingCountGet(xmlNode, ref uiMaxRatingCount);
                ArbitrationGet(xmlNode, ref bRequireArbitration);
                TeamGet(xmlNode, ref bIsTeam);
                ELOGet(xmlNode, ref eloConfig);

                bFound = true;
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBConfigGet complete");
            return bFound;
        }

        public bool LBConfigGet(
            uint uiLBNum, 
            ref ELBReset lbReset,
            ref uint uiAttachCount,
            ref uint uiMaxAttachSize,
            ref uint uiDecayDays,
            ref uint uiMaxRatingCount,
            ref bool bRequireArbitration,
            ref bool bIsTeam,
            ref int  itopEntries,
            ref CELOConfig eloConfig)
        {
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBConfigGet()");

            // note, we use 'ref' instead of 'out' parameters here so the 
            // caller can set the default they want if we don't find anything
            // in the xml file.

            bool bFound = false;

            // get the leaderboard element
            string sXpath = IndLBXpath(uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBConfigGet: "
                + "Selecting node that matches: "
                + sXpath);
            XmlNode xmlNode = m_xmlDoc.SelectSingleNode(sXpath, m_xmlnsm);
            if (xmlNode == null)
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBConfigGet: "
                    + "leaderboard id "
                    + uiLBNum
                    + " not found");
                bFound = false;
            }
            else
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBConfigGet: "
                    + "found leaderboard id "
                    + uiLBNum);

                ResetGet(xmlNode, ref lbReset);
                AttachCountGet(xmlNode, ref uiAttachCount);
                MaxAttachSizeGet(xmlNode, ref uiMaxAttachSize);
                DecayDaysGet(xmlNode, ref uiDecayDays);
                MaxRatingCountGet(xmlNode, ref uiMaxRatingCount);
                ArbitrationGet(xmlNode, ref bRequireArbitration);
                TeamGet(xmlNode, ref bIsTeam);
                ELOGet(xmlNode, ref eloConfig);
                TopOneHundredGet(xmlNode, ref itopEntries);
                bFound = true;
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBConfigGet complete");
            return bFound;
        }



        public bool UnitConfigGet(
            uint uiLBNum, 
            ref bool bRequireArbitration,
            ref bool bIsTeam,
            ref CELOConfig eloConfig)
        {
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitConfigGet()");

            // note, we use 'ref' instead of 'out' parameters here so the 
            // caller can set the default they want if we don't find anything
            // in the xml file.

            bool bFound = false;

            // get the leaderboard element
            string sXpath = UnitLBXpath(uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitConfigGet: "
                + "Selecting node that matches: "
                + sXpath);
            XmlNode xmlNode = m_xmlDoc.SelectSingleNode(sXpath, m_xmlnsm);
            if (xmlNode == null)
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitConfigGet: "
                    + "unit leaderboard id "
                    + uiLBNum
                    + " not found");
                bFound = false;
            }
            else
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitConfigGet: "
                    + "found unit leaderboard id "
                    + uiLBNum);

                ArbitrationGet(xmlNode, ref bRequireArbitration);
                TeamGet(xmlNode, ref bIsTeam);
                ELOGet(xmlNode, ref eloConfig);

                bFound = true;
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitConfigGet complete");
            return bFound;
        }

        public bool CompConfigGet(
            uint uiLBNum, 
            ref ELBReset lbReset,
            ref uint uiAttachCount,
            ref uint uiMaxAttachSize,
            ref uint uiDecayDays,
            ref bool bRequireArbitration,
            ref bool bIsTeam,
            ref CELOConfig eloConfig)
        {
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompConfigGet("
                +uiLBNum+")");

            // note, we use 'ref' instead of 'out' parameters here so the 
            // caller can set the default they want if we don't find anything
            // in the xml file.

            bool bFound = false;

            // get the leaderboard element
            string sXpath = CompLBXpath(uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompConfigGet: "
                + "Selecting node that matches: "
                + sXpath);
            XmlNode xmlNode = m_xmlDoc.SelectSingleNode(sXpath, m_xmlnsm);
            if (xmlNode == null)
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompConfigGet: "
                    + "competition template id "
                    + uiLBNum
                    + " not found");
                bFound = false;
            }
            else
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompConfigGet: "
                    + "found competition template id "
                    + uiLBNum);

                ResetGet(xmlNode, ref lbReset);
                AttachCountGet(xmlNode, ref uiAttachCount);
                MaxAttachSizeGet(xmlNode, ref uiMaxAttachSize);
                DecayDaysGet(xmlNode, ref uiDecayDays);
                ArbitrationGet(xmlNode, ref bRequireArbitration);
                TeamGet(xmlNode, ref bIsTeam);
                ELOGet(xmlNode, ref eloConfig);

                bFound = true;
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompConfigGet complete");
            return bFound;
        }

        public SortedList LBDescGetList(uint uiLBNum)
        {
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBDescGetList("
                +uiLBNum+")");

            string sXpath = IndLBXpath(uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBDescGetList: "
                + "Selecting node that matches: "
                + sXpath);

            SortedList sl = new SortedList();

            XmlNode xmlNodeLB = m_xmlDoc.SelectSingleNode(sXpath, m_xmlnsm);

            if (xmlNodeLB != null)
            {
                sl = DescGetList(xmlNodeLB);
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBGetList: "
                + sl.Count
                + " localized leaderboard descriptions found for leaderboard id "
                + uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBDescGetList complete");
            return sl;
        }

        public SortedList UnitDescGetList(uint uiLBNum)
        {
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitDescGetList("
                +uiLBNum+")");

            string sXpath = UnitLBXpath(uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitDescGetList: "
                + "Selecting node that matches: "
                + sXpath);

            SortedList sl = new SortedList();

            XmlNode xmlNodeLB = m_xmlDoc.SelectSingleNode(sXpath, m_xmlnsm);

            if (xmlNodeLB != null)
            {
                sl = DescGetList(xmlNodeLB);
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitDescGetList: "
                + sl.Count
                + " localized leaderboard descriptions found for unit leaderboard id "
                + uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitDescGetList complete");
            return sl;
        }


        public SortedList CompDescGetList(uint uiLBNum)
        {
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompDescGetList("
                +uiLBNum+")");

            string sXpath = CompLBXpath(uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompDescGetList: "
                + "Selecting node that matches: "
                + sXpath);

            SortedList sl = new SortedList();

            XmlNode xmlNodeLB = m_xmlDoc.SelectSingleNode(sXpath, m_xmlnsm);

            if (xmlNodeLB != null)
            {
                sl = DescGetList(xmlNodeLB);
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompDescGetList: "
                + sl.Count
                + " localized leaderboard descriptions found for competition template id "
                + uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompDescGetList complete");
            return sl;
        }

        public SortedList LBAttrGetList(uint uiLBNum)
        {
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBAttrGetList("
                +uiLBNum+")");

            SortedList sl = new SortedList();

            string sXpath = IndLBXpath(uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBAttrGetList: "
                + "Selecting node that matches: "
                + sXpath);
            XmlNode xmlNodeLB = m_xmlDoc.SelectSingleNode(sXpath, m_xmlnsm);

            if (xmlNodeLB != null)
            {
                sl = AttrGetList(xmlNodeLB);
            }
            
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBAttrGetList: "
                + sl.Count
                + " raw attributes found for leaderboard id "
                + uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBAttrGetList complete");
            return sl;
        }

        public SortedList UnitAttrGetList(uint uiLBNum)
        {
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitAttrGetList("
                +uiLBNum+")");

            SortedList sl = new SortedList();

            string sXpath = UnitLBXpath(uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitAttrGetList: "
                + "Selecting node that matches: "
                + sXpath);
            XmlNode xmlNodeLB = m_xmlDoc.SelectSingleNode(sXpath, m_xmlnsm);

            if (xmlNodeLB != null)
            {
                sl = AttrGetList(xmlNodeLB);
            }
            
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitAttrGetList: "
                + sl.Count
                + " raw attributes found for unit leaderboard id "
                + uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitAttrGetList complete");
            return sl;
        }

        public SortedList CompAttrGetList(uint uiLBNum)
        {
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompAttrGetList("
                +uiLBNum+")");

            SortedList sl = new SortedList();

            string sXpath = CompLBXpath(uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompAttrGetList: "
                + "Selecting node that matches: "
                + sXpath);
            XmlNode xmlNodeLB = m_xmlDoc.SelectSingleNode(sXpath, m_xmlnsm);

            if (xmlNodeLB != null)
            {
                sl = AttrGetList(xmlNodeLB);
            }
            
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompAttrGetList: "
                + sl.Count
                + " raw attributes found for competition template id "
                + uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompAttrGetList complete");
            return sl;
        }

        public string[] LBValueGetList(uint uiLBNum)
        {
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBValueGetList("
                +uiLBNum+")");

            ArrayList al = new ArrayList();

            string sXpath = IndLBXpath(uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBValueGetList: "
                + "Selecting nodes that match: "
                + sXpath);

            XmlNode xmlNodeLB = m_xmlDoc.SelectSingleNode(sXpath, m_xmlnsm);

            if (xmlNodeLB != null)
            {
                al = ValueGetList(xmlNodeLB);
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBValueGetList: "
                + al.Count
                + " formatted values found for leaderboard id "
                + uiLBNum);

            string[] rgs = new string[al.Count];
            al.CopyTo(rgs);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBValueGetList complete");
            return rgs;
        }

        public string[] UnitValueGetList(uint uiLBNum)
        {
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitValueGetList("
                +uiLBNum+")");

            ArrayList al = new ArrayList();

            string sXpath = UnitLBXpath(uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitValueGetList: "
                + "Selecting nodes that match: "
                + sXpath);

            XmlNode xmlNodeLB = m_xmlDoc.SelectSingleNode(sXpath, m_xmlnsm);

            if (xmlNodeLB != null)
            {
                al = ValueGetList(xmlNodeLB);
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitValueGetList: "
                + al.Count
                + " formatted values found for unit leaderboard id "
                + uiLBNum);

            string[] rgs = new string[al.Count];
            al.CopyTo(rgs);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitValueGetList complete");
            return rgs;
        }


        public string[] CompValueGetList(uint uiLBNum)
        {
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompValueGetList("
                +uiLBNum+")");

            ArrayList al = new ArrayList();

            string sXpath = CompLBXpath(uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompValueGetList: "
                + "Selecting nodes that match: "
                + sXpath);

            XmlNode xmlNodeLB = m_xmlDoc.SelectSingleNode(sXpath, m_xmlnsm);

            if (xmlNodeLB != null)
            {
                al = ValueGetList(xmlNodeLB);
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompValueGetList: "
                + al.Count
                + " formatted values found for competition template id "
                + uiLBNum);

            string[] rgs = new string[al.Count];
            al.CopyTo(rgs);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompValueGetList complete");
            return rgs;
        }

        public bool LBValueGet(
            uint uiLBNum, 
            string sName, 
            ref EWebValueReturnType returnType,
            ref string sFormula)
        {
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBValueGet("
                +uiLBNum+", "
                +sName+", "
                +"{out sReturnType}, "
                +"{out sFormula})");

            bool bFound = false;

            string sXpath = IndLBXpath(uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBValueGet: "
                + "Selecting node that matches: "
                + sXpath);
            XmlNode xmlNodeLB = m_xmlDoc.SelectSingleNode(sXpath, m_xmlnsm);
            if (xmlNodeLB != null)
            {
                bFound = ValueGet(xmlNodeLB, sName, ref returnType, ref sFormula);
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBValueGet complete, returning: "
                + bFound);
            return bFound;
        }

        public bool UnitValueGet(
            uint uiLBNum, 
            string sName, 
            ref EWebValueReturnType returnType,
            ref string sFormula)
        {
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitValueGet("
                +uiLBNum+", "
                +sName+", "
                +"{out sReturnType}, "
                +"{out sFormula})");

            bool bFound = false;

            string sXpath = UnitLBXpath(uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitValueGet: "
                + "Selecting node that matches: "
                + sXpath);
            XmlNode xmlNodeLB = m_xmlDoc.SelectSingleNode(sXpath, m_xmlnsm);
            if (xmlNodeLB != null)
            {
                bFound = ValueGet(xmlNodeLB, sName, ref returnType, ref sFormula);
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitValueGet complete, returning: "
                + bFound);
            return bFound;
        }

        public bool CompValueGet(
            uint uiLBNum, 
            string sName, 
            ref EWebValueReturnType returnType,
            ref string sFormula)
        {
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompValueGet("
                +uiLBNum+", "
                +sName+", "
                +"{out sReturnType}, "
                +"{out sFormula})");

            bool bFound = false;

            string sXpath = CompLBXpath(uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompValueGet: "
                + "Selecting node that matches: "
                + sXpath);
            XmlNode xmlNodeLB = m_xmlDoc.SelectSingleNode(sXpath, m_xmlnsm);
            if (xmlNodeLB != null)
            {
                bFound = ValueGet(xmlNodeLB, sName, ref returnType, ref sFormula);
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompValueGet complete, returning: "
                + bFound);
            return bFound;
        }

        public SortedList LBValueDescGetList(uint uiLBNum, string sName)
        {
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBValueDescGetList("
                +uiLBNum+", "
                +sName+")");

            SortedList sl = new SortedList();

            string sXpath = IndLBXpath(uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBValueDescGetList: "
                + "Selecting nodes that match: "
                + sXpath);
            XmlNode xmlNodeLB = m_xmlDoc.SelectSingleNode(sXpath, m_xmlnsm);

            if (xmlNodeLB != null)
            {
                sl = ValueDescGetList(xmlNodeLB, sName);
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBValueDescGetList: "
                + sl.Count
                + " localized formatted value descriptions found for formatted value "
                + sName
                +" in leaderboard id "
                + uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBValueDescGetList complete");
            return sl;
        }

        public SortedList UnitValueDescGetList(uint uiLBNum, string sName)
        {
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitValueDescGetList("
                +uiLBNum+", "
                +sName+")");

            SortedList sl = new SortedList();

            string sXpath = UnitLBXpath(uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitValueDescGetList: "
                + "Selecting nodes that match: "
                + sXpath);
            XmlNode xmlNodeLB = m_xmlDoc.SelectSingleNode(sXpath, m_xmlnsm);

            if (xmlNodeLB != null)
            {
                sl = ValueDescGetList(xmlNodeLB, sName);
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitValueDescGetList: "
                + sl.Count
                + " localized formatted value descriptions found for formatted value "
                + sName
                +" in unit leaderboard id "
                + uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.UnitValueDescGetList complete");
            return sl;
        }

        public SortedList CompValueDescGetList(uint uiLBNum, string sName)
        {
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompValueDescGetList("
                +uiLBNum+", "
                +sName+")");

            SortedList sl = new SortedList();

            string sXpath = CompLBXpath(uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompValueDescGetList: "
                + "Selecting nodes that match: "
                + sXpath);
            XmlNode xmlNodeLB = m_xmlDoc.SelectSingleNode(sXpath, m_xmlnsm);

            if (xmlNodeLB != null)
            {
                sl = ValueDescGetList(xmlNodeLB, sName);
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompValueDescGetList: "
                + sl.Count
                + " localized formatted value descriptions found for formatted value "
                + sName
                +" in competition template id "
                + uiLBNum);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.CompValueDescGetList complete");
            return sl;
        }

        private bool ExtractFormula(XmlNode xmlNode, ref string sFormula)
        {
            bool bFound = false;
            if (xmlNode.NodeType == XmlNodeType.CDATA)
            {
                sFormula = xmlNode.Value;
                bFound = true;
            }
            else
            {
                // v3 stats xlast released in November 2003 mistakenly 
                // generated formula elements that look like this:
                //
                // <Formula>&lt;![CDATA[attr[2]]]&gt;</Formula>
                //
                // This is not actually a CDATA section. When the xml parser reads 
                // it in, it does expand the entitiy reference but it treats the node 
                // as TEXT not CDATA. Thus it is not protected from the xml parser like 
                // you would expect a CDATA section to be, and the formula may have
                // been mangled
                //
                // Because it's not a real CDATA section, the parser doesn't rip
                // out the prefix and suffix for us. 
                //
                // The false CDATA prefix is 8 characters in length
                // The false CDATA suffix is 3 characters in length
                //
                // <![CDATA[attr[2]]]>
                // 0123456789012345678
                // ---------^-----^---
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "Warning: Non-CDATA node detected for formula node! "
                    + "This xsc file may have been generated by the November "
                    + "2003 version of Xlast. The formula may be corrupt.");
                string sFormulaTemp = xmlNode.Value.Trim();
                if (sFormulaTemp.Length > 12 && 
                    sFormulaTemp.Substring(0, 9) == "<![CDATA[" &&
                    sFormulaTemp.Substring(sFormulaTemp.Length - 3, 3) == "]]>")
                {
                    sFormula = sFormulaTemp.Substring(9, sFormulaTemp.Length - 12);
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBValueGet: "
                        + "Extracted formula: "
                        + sFormula);
                    bFound = true;
                }
                else
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                        + "Unable to extract formula, this node will be ingored");
                    bFound = false;
                }
            }
            return bFound;
        }

        private bool ResetGet(XmlNode xmlNodeLB, ref ELBReset lbReset)
        {
            bool bFound = false;
            string sXpath = ResetXpath;
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                + "Selecting node that matches: "
                + sXpath);
            XmlNode xmlNode = xmlNodeLB.SelectSingleNode(sXpath, m_xmlnsm);
            if (xmlNode == null)
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "reset element not found");
                bFound = false;
            }
            else
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "found reset element with value "
                    + xmlNode.Value);
                try
                {
                    lbReset = (ELBReset)Int32.Parse(xmlNode.Value);
                    bFound = true;
                }
                catch (Exception e)
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                        + xmlNode.Value
                        + " could not be parsed as an integer value, details:"
                        + e.Message);
                }
                bFound = true;
            }
            return bFound;
        }

        private bool AttachCountGet(XmlNode xmlNodeLB, ref uint uiAttachCount)
        {
            bool bFound = false;
            string sXpath = AttachCountXpath;
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                + "Selecting node that matches: "
                + sXpath);
            XmlNode xmlNode = xmlNodeLB.SelectSingleNode(sXpath, m_xmlnsm);
            if (xmlNode == null)
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "attachment count element not found");
                bFound = false;
            }
            else
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "found attachment count element with value "
                    + xmlNode.Value);
                try
                {
                    uiAttachCount = UInt32.Parse(xmlNode.Value);
                    bFound = true;
                }
                catch (Exception e)
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                        + xmlNode.Value
                        + " could not be parsed as an integer value, details:"
                        + e.Message);
                }
                bFound = true;
            }
            return bFound;
        }


        private bool MaxAttachSizeGet(XmlNode xmlNodeLB, ref uint uiMaxAttachSize)
        {
            bool bFound = false;
            string sXpath = MaxAttachSizeXpath;
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                + "Selecting node that matches: "
                + sXpath);
            XmlNode xmlNode = xmlNodeLB.SelectSingleNode(sXpath, m_xmlnsm);
            if (xmlNode == null)
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "max attachment size element not found");
                bFound = false;
            }
            else
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "found max attachment size element with value "
                    + xmlNode.Value);
                try
                {
                    uiMaxAttachSize = UInt32.Parse(xmlNode.Value);
                    bFound = true;
                }
                catch (Exception e)
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                        + xmlNode.Value
                        + " could not be parsed as an integer value, details:"
                        + e.Message);
                }
                bFound = true;
            }
            return bFound;
        }

        private bool DecayDaysGet(XmlNode xmlNodeLB, ref uint uiDecayDays)
        {
            bool bFound = false;
            string sXpath = DecayDaysXpath;
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                + "Selecting node that matches: "
                + sXpath);
            XmlNode xmlNode = xmlNodeLB.SelectSingleNode(sXpath, m_xmlnsm);
            if (xmlNode == null)
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "decay days element not found");
                bFound = false;
            }
            else
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "found decay days element with value "
                    + xmlNode.Value);
                try
                {
                    uiDecayDays = UInt32.Parse(xmlNode.Value);
                    bFound = true;
                }
                catch (Exception e)
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                        + xmlNode.Value
                        + " could not be parsed as an integer value, details:"
                        + e.Message);
                }
                bFound = true;
            }
            return bFound;
        }

        private bool MaxRatingCountGet(XmlNode xmlNodeLB, ref uint uiMaxRatingCount)
        {
            bool bFound = false;
            string sXpath = Top100Xpath;
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                + "Selecting node that matches: "
                + sXpath);
            XmlNode xmlNode = xmlNodeLB.SelectSingleNode(sXpath, m_xmlnsm);
            if (xmlNode == null)
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "top 100 element not found");
                bFound = false;
            }
            else
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "found top 100 element with value "
                    + xmlNode.Value);

                string sValue = xmlNode.Value.Trim().ToLower();
                if (sValue == "true")
                {
                    uiMaxRatingCount = 100;
                    bFound = true;
                }
                else if (sValue == "false")
                {
                    uiMaxRatingCount = 0;
                    bFound = true;
                }
                else
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                        + "top 100 value "
                        + xmlNode.Value
                        + " not recognized. This element will be ignored");
                }
                bFound = true;
            }
            return bFound;
        }

        private bool ArbitrationGet(XmlNode xmlNodeLB, ref bool bRequireArbitration)
        {
            bool bFound = false;
            string sXpath = ArbitrateXpath;
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                + "Selecting node that matches: "
                + sXpath);
            XmlNode xmlNode = xmlNodeLB.SelectSingleNode(sXpath, m_xmlnsm);
            if (xmlNode == null)
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "arbitration element not found");
                bFound = false;
            }
            else
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "found arbitration element with value "
                    + xmlNode.Value);

                string sValue = xmlNode.Value.Trim().ToLower();
                if (sValue == "true")
                {
                    bRequireArbitration = true;
                    bFound = true;
                }
                else if (sValue == "false")
                {
                    bRequireArbitration = false;
                    bFound = true;
                }
                else
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                        + "arbitration value "
                        + xmlNode.Value
                        + " not recognized. This element will be ignored");
                }
                bFound = true;
            }
            return bFound;
        }

        private bool TopOneHundredGet(XmlNode xmlNodeLB, ref int itopEntries)
        {

            bool bFound = false;
            string sXpath = Top100Xpath;
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                + "Selecting node that matches: "
                + sXpath);
            XmlNode xmlNode = xmlNodeLB.SelectSingleNode(sXpath, m_xmlnsm);
            if (xmlNode == null)
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "Top100 element not found");
                bFound = false;
            }
            else
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "found Top100 element with value "
                    + xmlNode.Value);

                string sValue = xmlNode.Value.Trim().ToLower();
                if (sValue == "true")
                {
                    itopEntries = 100;
                    bFound = true;
                }
                else if (sValue == "false")
                {
                    itopEntries = -1;
                    bFound = true;
                }
                else
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                        + "Top100 value "
                        + xmlNode.Value
                        + " not recognized. This element will be ignored");
                }
                bFound = true;
            }
            return bFound;

        }

        private bool TeamGet(XmlNode xmlNodeLB, ref bool bIsTeam)
        {
            bool bFound = false;
            string sXpath = TeamsXpath;
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                + "Selecting node that matches: "
                + sXpath);
            XmlNode xmlNode = xmlNodeLB.SelectSingleNode(sXpath, m_xmlnsm);
            if (xmlNode == null)
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "team element not found");
                bFound = false;
            }
            else
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "found team element with value "
                    + xmlNode.Value);

                string sValue = xmlNode.Value.Trim().ToLower();
                if (sValue == "true")
                {
                    bIsTeam = true;
                    bFound = true;
                }
                else if (sValue == "false")
                {
                    bIsTeam = false;
                    bFound = true;
                }
                else
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                        + "team value "
                        + xmlNode.Value
                        + " not recognized. This element will be ignored");
                }
                bFound = true;
            }
            return bFound;
        }

        private bool ELOGet(XmlNode xmlNodeLB, ref CELOConfig eloConfig)
        {
            // keep our findings here until we're sure we
            // got everything
            CELOConfig eloConfigWork = new CELOConfig();

            // first get the ELO Init value
            string sXpath = ELOInitXpath;
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                + "Selecting node that matches: "
                + sXpath);
            XmlNode xmlNode = xmlNodeLB.SelectSingleNode(sXpath, m_xmlnsm);
            if (xmlNode == null)
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "ELO Initial Player Rating not found. "
                    + "Any other ELO information for this "
                    + "leaderboard will be ignored");
                return false;
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                + "found ELO Initial Player Rating element with value "
                + xmlNode.Value);

            try
            {
                eloConfigWork.uiInitialPlayerRating = UInt32.Parse(xmlNode.Value);
            }
            catch (Exception e)
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + xmlNode.Value
                    + " could not be parsed as an integer value. "
                    + "Any other ELO information for this leaderboard "
                    + "will be ignored, exception details:"
                    + e.Message);
                return false;
            }

            // next get the ELO scale factor 
            sXpath = ELOScaleXpath;
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                + "Selecting node that matches: "
                + sXpath);
            xmlNode = xmlNodeLB.SelectSingleNode(sXpath, m_xmlnsm);
            if (xmlNode == null)
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "ELO Rating Scale Factor not found. "
                    + "Any other ELO information for this "
                    + "leaderboard will be ignored");
                return false;
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                + "found ELO Rating Scale Factor element with value "
                + xmlNode.Value);

            try
            {
                eloConfigWork.uiRatingScaleFactor = UInt32.Parse(xmlNode.Value);
            }
            catch (Exception e)
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + xmlNode.Value
                    + " could not be parsed as an integer value. "
                    + "Any other ELO information for this leaderboard "
                    + "will be ignored, exception details:"
                    + e.Message);
                return false;
            }

            // next get the ELO exponential base
            sXpath = ELOExpXpath;
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                + "Selecting node that matches: "
                + sXpath);
            xmlNode = xmlNodeLB.SelectSingleNode(sXpath, m_xmlnsm);
            if (xmlNode == null)
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "ELO Exponential Base not found. "
                    + "Any other ELO information for this "
                    + "leaderboard will be ignored");
                return false;
            }

            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                + "found ELO Exponential Base element with value "
                + xmlNode.Value);

            string sValue = xmlNode.Value.Trim().ToLower();
            if (sValue == "10")
            {
                eloConfigWork.exponentialBase = EELOExponentialBase.ten;
            }
            else if (sValue == "e")
            {
                eloConfigWork.exponentialBase = EELOExponentialBase.e;
            }
            else
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "ELO Exponential Base value "
                    + xmlNode.Value
                    + " not recognized. Any other ELO information for "
                    + "this leaderboard will be ignored");
                return false;
            }

            // finally we have to run through the max weight rating ranges
            ArrayList alRatings = new ArrayList();
            sXpath = ELORangeListXpath;
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                + "Selecting nodes that match: "
                + sXpath);
            XmlNodeList xmlNodeList = xmlNodeLB.SelectNodes(sXpath, m_xmlnsm);
            foreach (XmlNode xmlNodeRating in xmlNodeList)
            {
                uint uiStart;
                uint uiMaxWeight;

                // get the start value
                sXpath = ELORangeStartXpath;
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "Selecting node that matches: "
                    + sXpath);
                XmlNode xmlNodeStart = xmlNodeRating.SelectSingleNode(sXpath, m_xmlnsm);
                if (xmlNodeStart == null)
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                        + "ELO Rating Range Start not found. "
                        + "Any other ELO information for this "
                        + "leaderboard will be ignored");
                    return false;
                }

                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "found ELO Rating Range Start with value "
                    + xmlNodeStart.Value);

                try
                {
                    uiStart = UInt32.Parse(xmlNodeStart.Value);
                }
                catch (Exception e)
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                        + xmlNodeStart.Value
                        + " could not be parsed as an integer value. "
                        + "Any other ELO information for this leaderboard "
                        + "will be ignored, exception details:"
                        + e.Message);
                    return false;
                }

                // get the max weight value
                sXpath = ELORangeWeightXpath;
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "Selecting node that matches: "
                    + sXpath);
                XmlNode xmlNodeWeight = xmlNodeRating.SelectSingleNode(sXpath, m_xmlnsm);
                if (xmlNodeWeight == null)
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                        + "ELO Rating Range Start not found. "
                        + "Any other ELO information for this "
                        + "leaderboard will be ignored");
                    return false;
                }

                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "found ELO Rating Range Start with value "
                    + xmlNodeWeight.Value);

                try
                {
                    uiMaxWeight = UInt32.Parse(xmlNodeWeight.Value);
                }
                catch (Exception e)
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                        + xmlNodeWeight.Value
                        + " could not be parsed as an integer value. "
                        + "Any other ELO information for this leaderboard "
                        + "will be ignored, exception details:"
                        + e.Message);
                    return false;
                }

                alRatings.Add(new CELOMaxWeightRatingRange(uiStart, uiMaxWeight));
            }

            if (alRatings.Count == 0)
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "No ELO Max Weight Rating Ranges found. "
                    + "Any other ELO information for this "
                    + "leaderboard will be ignored");
                return false;
            }

            // copy the array list to the elo object
            eloConfigWork.rgMaxWeightRatings
                = new CELOMaxWeightRatingRange[alRatings.Count];
            alRatings.CopyTo(eloConfigWork.rgMaxWeightRatings);

            // set the ref var
            eloConfig = eloConfigWork;
            return true;
        }

        public SortedList DescGetList(XmlNode xmlNodeLB)
        {
            SortedList sl = new SortedList();

            string sXpath = DescListXpath;
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBDescGetList: "
                + "Selecting nodes that match: "
                + sXpath);
            XmlNodeList xmlNodeList = xmlNodeLB.SelectNodes(sXpath, m_xmlnsm);
            foreach (XmlNode xmlNode in xmlNodeList)
            {
                XmlNode xmlNodeName = xmlNode.SelectSingleNode(
                    LBDescNameXpath, m_xmlnsm);
                if (xmlNodeName == null)
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBDescGetList: "
                        + "Leaderboard LocalizedName missing Name element. "
                        + "This LocalizedName will be ignored");
                    continue;
                }

                XmlNode xmlNodeLocale = xmlNode.SelectSingleNode(
                    LBDescLocaleXpath, m_xmlnsm);
                if (xmlNodeLocale == null)
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBDescGetList: "
                        + "Leaderboard LocalizedName missing Locale element. "
                        + "This LocalizedName will be ignored");
                    continue;
                }

                // check to make sure the locale is valid
                CLocale locale;
                try
                {
                    locale = new CLocale(xmlNodeLocale.Value);
                }
                catch (Exception)
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBDescGetList: "
                        + "Leaderboard LocalizedName Locale element contains "
                        + xmlNodeLocale.Value
                        + " which is not a valid locale. "
                        + "This LocalizedName element will be ignored.");
                    continue;
                }

                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.LBDescGetList: "
                    + "Found description '"
                    + xmlNodeName.Value
                    + "' for locale "
                    + locale.ToString());
                sl[locale.ToString()] = xmlNodeName.Value;
            }
            return sl;
        }

        public SortedList AttrGetList(XmlNode xmlNodeLB)
        {
            SortedList sl = new SortedList();

            string sXpath = AttrListXpath;
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                + "Selecting nodes that match: "
                + sXpath);
            XmlNodeList xmlNodeList = xmlNodeLB.SelectNodes(sXpath, m_xmlnsm);
            foreach (XmlNode xmlNode in xmlNodeList)
            {
                XmlNode xmlNodeIndex = xmlNode.SelectSingleNode(
                    LBAttrIndexXpath, m_xmlnsm);
                if (xmlNodeIndex == null)
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                        + "Leaderboard RawAttribute Attribute missing Index element. "
                        + "This Attribute element will be ignored");
                    continue;
                }

                XmlNode xmlNodeIsPuid = xmlNode.SelectSingleNode(
                    LBAttrIsPuidXpath, m_xmlnsm);
                if (xmlNodeIsPuid == null)
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                        + "Leaderboard RawAttribute Attribute missing PUID element. "
                        + "This Attribute will be ignored");
                    continue;
                }

                // check to make sure puid is true or false
                string sIsPuid = xmlNodeIsPuid.Value.Trim().ToLower();
                bool bIsPuid;
                if (sIsPuid == "true")
                {
                    bIsPuid = true;
                }
                else if (sIsPuid == "false")
                {
                    bIsPuid = false;
                }
                else
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                        + "Leaderboard RawAttribute Attribute PUID element contains "
                        + xmlNodeIsPuid.Value
                        + " which is not a valid. It must be 'true' or 'false'. "
                        + "This Attribute element will be ignored.");
                    continue;
                }

                // try to parse the index
                uint uiIndex;
                try
                {
                    uiIndex = UInt32.Parse(xmlNodeIndex.Value);
                }
                catch (Exception e)
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                        + "Leaderboard RawAttribute Attribute Index element contains "
                        + xmlNodeIsPuid.Value
                        + " which could not be parsed as a positive integer. "
                        + "This Attribute element will be ignored. Exception details: "
                        + e.Message);
                    continue;
                }

                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "Found Attribute index "
                    + uiIndex
                    + " with puid value of "
                    + bIsPuid);
                sl[uiIndex] = bIsPuid;
            }

            return sl;
        }

        public ArrayList ValueGetList(XmlNode xmlNodeLB)
        {
            ArrayList al = new ArrayList();

            string sXpath = ValueListXpath;
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                + "Selecting nodes that match: "
                + sXpath);
            XmlNodeList xmlNodeList = xmlNodeLB.SelectNodes(sXpath, m_xmlnsm);
            foreach (XmlNode xmlNode in xmlNodeList)
            {
                XmlNode xmlNodeName = xmlNode.SelectSingleNode(
                    LBValueNameXpath, m_xmlnsm);
                if (xmlNodeName == null)
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                        + "Leaderboard FormattedValues FormattedValue Attribute missing NameID element. "
                        + "This FormattedValue element will be ignored");
                    continue;
                }

                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "Found FormattedValue named "
                    + xmlNodeName.Value);
                al.Add(xmlNodeName.Value);
            }

            return al;
        }

        public bool ValueGet(
            XmlNode xmlNodeLB,
            string sName, 
            ref EWebValueReturnType returnType,
            ref string sFormula)
        {
            bool bFoundFormula = false;
            bool bFoundRetType = false;

            string sXpath = ValueTypeXpath(sName);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                + "Selecting node that matches: "
                + sXpath);
            XmlNode xmlNode = xmlNodeLB.SelectSingleNode(sXpath, m_xmlnsm);
            if (xmlNode != null)
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "Found return type node with value "
                    + xmlNode.Value);
                string sReturnType = xmlNode.Value;
                try
                {
                    returnType = 
                        (EWebValueReturnType)Enum.Parse(
                        typeof(EWebValueReturnType), 
                        sReturnType, 
                        true);
                    bFoundRetType = true;
                }
                catch (Exception e)
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                        + "Invalid return type of "
                        + sReturnType
                        + ", Exception details: "
                        + e.Message);
                }
            }

            sXpath = ValueFormulaXpath(sName);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                + "Selecting node that matches: "
                + sXpath);
            xmlNode = xmlNodeLB.SelectSingleNode(sXpath, m_xmlnsm);
            if (xmlNode != null)
            {
                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "Found formula node with value "
                    + xmlNode.Value);
                bFoundFormula = ExtractFormula(xmlNode, ref sFormula);
            }

            return bFoundRetType && bFoundFormula;
        }

        public SortedList ValueDescGetList(XmlNode xmlNodeLB, string sName)
        {
            SortedList sl = new SortedList();

            string sXpath = ValueDescListXpath(sName);
            m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                + "Selecting nodes that match: "
                + sXpath);
            XmlNodeList xmlNodeList = xmlNodeLB.SelectNodes(sXpath, m_xmlnsm);
            foreach (XmlNode xmlNode in xmlNodeList)
            {
                XmlNode xmlNodeName = xmlNode.SelectSingleNode(
                    LBValueDescNameXpath, m_xmlnsm);
                if (xmlNodeName == null)
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                        + "Leaderboard FormattedValue Localized Name missing Name element. "
                        + "This LocalizedName will be ignored");
                    continue;
                }

                XmlNode xmlNodeLocale = xmlNode.SelectSingleNode(
                    LBDescLocaleXpath, m_xmlnsm);
                if (xmlNodeLocale == null)
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                        + "Leaderboard FormattedValue LocalizedName missing Locale element. "
                        + "This LocalizedName will be ignored");
                    continue;
                }

                // check to make sure the locale is valid
                CLocale locale;
                try
                {
                    locale = new CLocale(xmlNodeLocale.Value);
                }
                catch (Exception)
                {
                    m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                        + "Leaderboard FormattedValue LocalizedName Locale element contains "
                        + xmlNodeLocale.Value
                        + " which is not a valid locale. "
                        + "This LocalizedName element will be ignored.");
                    continue;
                }

                m_log.WriteLineV("Xbox.Tools.Framework.CXsc.: "
                    + "Found description '"
                    + xmlNodeName.Value
                    + "' for locale "
                    + locale.ToString()
                    + " for formatted value named "
                    + sName);
                sl[locale.ToString()] = xmlNodeName.Value;
            }

            return sl;
        }


        private void DumpXmlNode(XmlNode xmlNode)
        {
            DumpXmlNode(xmlNode, 0);
        }

        // debugging routine
        private void DumpXmlNode(XmlNode xmlNode, int iDepth)
        {
            m_log.WriteLineV(iDepth + ":xmlNode.NodeType: " + xmlNode.NodeType);
            m_log.WriteLineV(iDepth + ":xmlNode.Name: " + xmlNode.Name);
            m_log.WriteLineV(iDepth + ":xmlNode.LocalName: " + xmlNode.LocalName);
            m_log.WriteLineV(iDepth + ":xmlNode.Prefix: " + xmlNode.Prefix);
            m_log.WriteLineV(iDepth + ":xmlNode.NamespaceURI: " + xmlNode.NamespaceURI);
            m_log.WriteLineV(iDepth + ":xmlNode.Value: " + (xmlNode.Value == null ? "null" : xmlNode.Value));

            if (xmlNode.Attributes != null)
            {
                m_log.WriteLineV(iDepth + ":xmlNode.Attributes");
                foreach (XmlAttribute xmlAttribute in xmlNode.Attributes)
                {
                    m_log.WriteLineV(iDepth + ":xmlAttribute.NodeType: " + xmlAttribute.NodeType);
                    m_log.WriteLineV(iDepth + ":xmlAttribute.Name: " + xmlAttribute.Name);
                    m_log.WriteLineV(iDepth + ":xmlAttribute.LocalName: " + xmlAttribute.LocalName);
                    m_log.WriteLineV(iDepth + ":xmlAttribute.Prefix: " + xmlAttribute.Prefix);
                    m_log.WriteLineV(iDepth + ":xmlAttribute.NamespaceURI: " + xmlAttribute.NamespaceURI);
                    m_log.WriteLineV(iDepth + ":xmlAttribute.Value: " + (xmlAttribute.Value == null ? "null" : xmlAttribute.Value));
                }
            }

            if (--iDepth >= 0)
            {
                foreach (XmlNode xmlNodeChild in xmlNode.ChildNodes)
                {
                    DumpXmlNode(xmlNodeChild, iDepth);
                }
            }
        }

            
    }

    /// <summary>
    /// Thrown when the xml passed is well formed, but does not contain
    /// the structure or content expected in a stats submission xml file.
    /// </summary>
    public class CXscException: ApplicationException
    {
        public CXscException() : base() {}
        public CXscException(string s) : base(s) {}
        protected CXscException(
            System.Runtime.Serialization.SerializationInfo si,
            System.Runtime.Serialization.StreamingContext sc
        ) : base(si, sc) {}
        public CXscException(string s, Exception e) : base(s, e) {}
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveToolsCommon\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_microsoft.ems.tools.livetools.common_none_12.4.56.0_none_91df464bb3d6646b
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_microsoft.ems.tools.livetools.common_no-public-key_12.4.56.0_x-ww_b7a36ae3
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=microsoft.ems.tools.livetools.common
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_microsoft.ems.tools.livetools.common_no-public-key_12.4.56.0_x-ww_b7a36ae3
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_microsoft.ems.tools.livetools.common_no-public-key_12.4.56.0_x-ww_b7a36ae3.manifest
XP_MANIFEST_PATH=manifests\msil_microsoft.ems.tools.livetools.common_no-public-key_12.4.56.0_x-ww_b7a36ae3.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_microsoft.ems.tools.livetools.common_no-public-key_12.4.56.0_x-ww_b7a36ae3.cat
XP_CATALOG_PATH=manifests\msil_microsoft.ems.tools.livetools.common_no-public-key_12.4.56.0_x-ww_b7a36ae3.cat
XP_PAYLOAD_PATH=msil_microsoft.ems.tools.livetools.common_no-public-key_12.4.56.0_x-ww_b7a36ae3
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=microsoft.ems.tools.livetools.common,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveToolsCommon\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveTitle\toolsframework\CStats.cs ===
using System;
using System.Net;
using System.Data;
using System.Data.SqlClient;
using System.Collections;
using System.Text;
using System.IO;
using System.Threading;
using System.Globalization;
using xonline.tools.framework;

namespace Microsoft.Ems.Tools.LiveTitle
{
    /// <summary>
    /// Defines the leaderboard reset intervals supported by the stats v3 "tsunami" stats service
    /// </summary>
    public enum ELBReset
    {
        /// <summary>Minimum legal reset interval value</summary>
        MinValue = 0,
        /// <summary> LB never resets </summary>
        ResetNever = 0,
        /// <summary> LB resets every week</summary>
        ResetEveryWeek= 1,
        /// <summary> LB resets every month</summary>
        ResetEveryMonth = 2,
        /// <summary> LB resets every second months</summary>
        ResetEvery2Months = 3,
        /// <summary> LB resets every third month</summary>
        ResetEvery3Months = 4,
        /// <summary> LB resets every six months</summary>
        ResetEvery6Months = 5,
        /// <summary> LB resets every year</summary>
        ResetEveryYear = 6,
        /// <summary>Maximum legal reset interval value</summary>
        MaxValue = 6
    }

    /// <summary>
    /// A class to hold an ELO max weight rating range
    /// </summary>
    public class CELOMaxWeightRatingRange
    {
        public uint uiStart;
        public uint uiMaxWeight;

        public CELOMaxWeightRatingRange()
        {
            uiStart = 0;
            uiMaxWeight = 0;
        }

        public CELOMaxWeightRatingRange(
            uint _uiStart,
            uint _uiMaxWeight)
        {
            uiStart = _uiStart;
            uiMaxWeight = _uiMaxWeight;
        }

        public override string ToString()
        {
            return "{" + uiStart + "," + uiMaxWeight + "}";
        }

        public string ToStatsDBString()
        {
            return uiStart + ":" + uiMaxWeight;
        }
    }

    /// <summary>
    /// An enum that provides the (two) allowable values for an ELO exponential base
    /// </summary>
    public enum EELOExponentialBase 
    {
        /// <summary> The ELO calculations use base 10</summary>
        ten,
        /// <summary> The ELO calculations use base 'e' </summary>
        e
    }

    /// <summary>
    /// A simple data class that contains a complete ELO configuration
    /// </summary>
    public class  CELOConfig
    {
        public uint uiInitialPlayerRating;
        public uint uiRatingScaleFactor;
        public EELOExponentialBase exponentialBase;
        public CELOMaxWeightRatingRange[] rgMaxWeightRatings;

        public CELOConfig()
        {
            uiInitialPlayerRating = 0;
            uiRatingScaleFactor = 0;
            exponentialBase = EELOExponentialBase.ten;
            rgMaxWeightRatings = new CELOMaxWeightRatingRange[0];
        }

        public CELOConfig(
            uint _uiInitialPlayerRating,
            uint _uiRatingScaleFactor,
            EELOExponentialBase _eExponentialBase,
            CELOMaxWeightRatingRange[] _rgMaxWeightRatings)
        {
            uiInitialPlayerRating = _uiInitialPlayerRating;
            uiRatingScaleFactor = _uiRatingScaleFactor;
            exponentialBase = _eExponentialBase;
            rgMaxWeightRatings = _rgMaxWeightRatings;
        }

        public static CELOConfig Parse(string sELOString)
        {
            // Format of an ELO string:
            // ELO_E=10;ELO_K=120;ELO_NEW=500;ELO_C=0:40,1000:20,1500:10
            // Allowed values for ELO_E are 'E' and '10'

            if (sELOString == null)
            {
                throw new ArgumentNullException(sELOString);
            }

            bool bFoundELO_E = false;
            bool bFoundELO_K = false;
            bool bFoundELO_NEW = false;
            bool bFoundELO_C = false;

            CELOConfig eloConfig = new CELOConfig(0, 0, EELOExponentialBase.e, null);

            string[] rgsSplit = sELOString.Split(';');
            foreach (string sTerm in rgsSplit)
            {
                // sTerm is of the form TERM=value
                string[] sTermSplit = sTerm.Split('=');
                if (sTermSplit.Length != 2)
                {
                    throw new FormatException(
                        "Format error in ELO string, in fragment: "
                        + sTerm);
                }
                string sTag = sTermSplit[0].Trim().ToUpper();
                string sValue = sTermSplit[1].Trim().ToUpper();

                if (sTag == "ELO_E")
                {
                    // make sure we haven't already seen this tag
                    if (bFoundELO_E == true)
                    {
                        throw new FormatException(
                            "Multiple ELO_E tags found in ELO string: "
                            + sELOString);
                    }

                    // this tag must be one of
                    // ELO_E=E
                    // ELO_E=10
                    // anything else is an exception
                    if (sValue == "E")
                    {
                        eloConfig.exponentialBase = EELOExponentialBase.e;
                    }
                    else if (sValue == "10")
                    {
                        eloConfig.exponentialBase = EELOExponentialBase.ten;
                    }
                    else
                    {
                        throw new FormatException(
                            "Unknown exponential base in ELO string, in fragment: "
                            + sTerm);
                    }
                    bFoundELO_E = true;
                }
                else if (sTag == "ELO_K")
                {
                    // make sure we haven't already seen this tag
                    if (bFoundELO_K == true)
                    {
                        throw new FormatException(
                            "Multiple ELO_K tags found in ELO string: "
                            + sELOString);
                    }

                    // this tag is simple, just ELO_K=<uint32value>
                    try
                    {
                        eloConfig.uiRatingScaleFactor = UInt32.Parse(sValue);
                    }
                    catch (FormatException formatException)
                    {
                        throw new FormatException(
                            "Format error parsing ELO_K term, in fragment: "
                            + sTerm,
                            formatException);
                    }
                    catch (OverflowException overflowException)
                    {
                        throw new FormatException(
                            "Format error parsing ELO_K term, in fragment: "
                            + sTerm,
                            overflowException);
                    }
                    bFoundELO_K = true;
                }
                else if (sTag == "ELO_NEW")
                {
                    // make sure we haven't already seen this tag
                    if (bFoundELO_NEW == true)
                    {
                        throw new FormatException(
                            "Multiple ELO_NEW tags found in ELO string: "
                            + sELOString);
                    }

                    // this tag is simple, just ELO_NEW=<uint32value>
                    try
                    {
                        eloConfig.uiInitialPlayerRating = UInt32.Parse(sValue);
                    }
                    catch (FormatException formatException)
                    {
                        throw new FormatException(
                            "Format error parsing ELO_NEW term, in fragment: "
                            + sTerm,
                            formatException);
                    }
                    catch (OverflowException overflowException)
                    {
                        throw new FormatException(
                            "Format error parsing ELO_NEW term, in fragment: "
                            + sTerm,
                            overflowException);
                    }
                    bFoundELO_NEW = true;
                }
                else if (sTag == "ELO_C")
                {
                    // make sure we haven't already seen this tag
                    if (bFoundELO_C == true)
                    {
                        throw new FormatException(
                            "Multiple ELO_C tags found in ELO string: "
                            + sELOString);
                    }

                    // this tag is a bit of a pain. It contains one or more ranges
                    // of the form 10:40, separated by commas. For example:
                    // ELO_C=0:40,1000:20,1500:10
                    // So we have to split and iterate on the value here
                    string[] rgsValueSplit = sValue.Split(',');
                    if (rgsValueSplit.Length == 0)
                    {
                        throw new FormatException(
                            "No rating ranges found parsing ELO_C term, in fragment: "
                            + sTerm);
                    }

                    // allocate an array with space for the number of ranges in
                    // the string
                    CELOMaxWeightRatingRange[] rgMaxWeightRatings 
                        = new CELOMaxWeightRatingRange[rgsValueSplit.Length];

                    // now grab each range
                    for (int i = 0; i < rgsValueSplit.Length; ++i)
                    {
                        string sRange = rgsValueSplit[i];

                        // range is of the form 0:40, so we have split, again
                        string[] rgsRangeSplit = sRange.Split(':');
                        if (rgsRangeSplit.Length != 2)
                        {
                            throw new FormatException(
                                "Format error parsing ELO_C term, in fragment: "
                                + sTerm);
                        }

                        string sStart = rgsRangeSplit[0];
                        string sMaxWeight = rgsRangeSplit[1];

                        // we have the values, now parse them!
                        rgMaxWeightRatings[i] = new CELOMaxWeightRatingRange();
                        try
                        {
                            rgMaxWeightRatings[i].uiStart = UInt32.Parse(sStart);
                        }
                        catch (FormatException formatException)
                        {
                            throw new FormatException(
                                "Format error parsing ELO_C term, in fragment: "
                                + sRange,
                                formatException);
                        }
                        catch (OverflowException overflowException)
                        {
                            throw new FormatException(
                                "Format error parsing ELO_C term, in fragment: "
                                + sRange,
                                overflowException);
                        }

                        // got the start, now get the max weight
                        try
                        {
                            rgMaxWeightRatings[i].uiMaxWeight = UInt32.Parse(sMaxWeight);
                        }
                        catch (FormatException formatException)
                        {
                            throw new FormatException(
                                "Format error parsing ELO_C term, in fragment: "
                                + sRange,
                                formatException);
                        }
                        catch (OverflowException overflowException)
                        {
                            throw new FormatException(
                                "Format error parsing ELO_C term, in fragment: "
                                + sRange,
                                overflowException);
                        }
                    }

                    // if we got here without throwing, then we've successfully 
                    // parsed the max weight rating ranges, save them
                    eloConfig.rgMaxWeightRatings = rgMaxWeightRatings;
                    bFoundELO_C = true;
                }
                else
                {
                    throw new FormatException(
                        "Unknown tag in ELO string, in fragment: "
                        + sTerm);
                }
            }

            // check to make sure that we found everything we were looking for
            if (bFoundELO_E == false)
            {
                throw new FormatException("ELO_E was not found in the ELO string");
            }
            if (bFoundELO_K == false)
            {
                throw new FormatException("ELO_E was not found in the ELO string");
            }
            if (bFoundELO_NEW == false)
            {
                throw new FormatException("ELO_E was not found in the ELO string");
            }
            if (bFoundELO_C == false)
            {
                throw new FormatException("ELO_E was not found in the ELO string");
            }

            // we're done! no errors, so return the parse object
            return eloConfig;
        }

        // the Parse method does not check the semantics of
        // the max weight range array, they just verify that the strings
        // are formatted properly in terms of parsing.
        //
        // this method checks if the max weight rating range array is
        // valid
        //
        // to be valid, the first element of the max weight rating range array 
        // must have uiStart = 0, and each successive max weight rating range
        // must have uiStart larger than all previous values.
        public bool IsValid()
        {
            // must have an array, and it must have more than zero elements
            if (rgMaxWeightRatings == null || rgMaxWeightRatings.Length == 0)
            {
                return false;
            }

            // uiStart of the first element must be zero
            if (rgMaxWeightRatings[0].uiStart != 0)
            {
                return false;
            }

            // uiStart of all successive elements must be larger than the previous
            uint uiStartLast = 0;
            for (int i = 1; i < rgMaxWeightRatings.Length; ++i)
            {
                if (rgMaxWeightRatings[i].uiStart <= uiStartLast)
                {
                    return false;
                }
                uiStartLast = rgMaxWeightRatings[i].uiStart;
            }

            // if we get here, all validity tests passed, so return true!
            return true;
        }

        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("{");
            sb.Append(uiInitialPlayerRating.ToString());
            sb.Append(",");
            sb.Append(uiRatingScaleFactor.ToString());
            sb.Append(",");
            sb.Append(exponentialBase.ToString());
            sb.Append(",");
            sb.Append(CLog.CollectionToString(rgMaxWeightRatings));
            sb.Append("}");
            return sb.ToString();
        }

        public string ToStatsDBString()
        {
            // Format of an ELO string:
            // ELO_E=10;ELO_K=120;ELO_NEW=500;ELO_C=0:40,1000:20,1500:10
            // Allowed values for ELO_E are 'E' and '10'

            // build a valid ELO string from the object
            StringBuilder sb = new StringBuilder();

            // canonical ordering is ELO_E, ELO_K, ELO_NEW, ELO_C

            // ELO_E=[E|10]
            if (exponentialBase == EELOExponentialBase.e)
            {
                sb.Append("ELO_E=E");
            }
            else if (exponentialBase == EELOExponentialBase.ten)
            {
                sb.Append("ELO_E=10");
            }
            else
            {
                // this will only happen if we add a new exponential base
                // without updating this function
                throw new Exception(
                    "CELOConfig.ToStatsDBString internal error - this method requires updating");
            }
            sb.Append(";");

            // ELO_K=XXX
            sb.Append("ELO_K=");
            sb.Append(uiRatingScaleFactor.ToString());
            sb.Append(";");

            // ELO_NEW=XXX
            sb.Append("ELO_NEW=");
            sb.Append(uiInitialPlayerRating.ToString());
            sb.Append(";");

            // ELO_C=XX:XX,XX:XX,XX:XX
            if (rgMaxWeightRatings == null || rgMaxWeightRatings.Length < 1)
            {
                throw new Exception(
                    "Invalid rgMaxWeightRatings in CELOConfig.ToStatsDBString()");
            }

            sb.Append("ELO_C=");
            for (int i = 0; i < rgMaxWeightRatings.Length; ++i)
            {
                sb.Append(rgMaxWeightRatings[i].uiStart.ToString());
                sb.Append(":");
                sb.Append(rgMaxWeightRatings[i].uiMaxWeight.ToString());
                if (i + 1 < rgMaxWeightRatings.Length)
                {
                    sb.Append(",");
                }
            }

            // all done, no errors, return the string!
            return sb.ToString();
        }
    }

    /// <summary>
    /// This class encapsulates the management operations that can be performed 
    /// on the version 3 ("tsunami") statistics service. The "statistics service", in this
    /// context means the statistics database servers, and the statistics front door
    /// servers. It does not include webdb, which has it's own management object
    /// </summary>
    public class CStats
    {
        private string[] m_rgsStatsDBConnectionStrings = null;
        private CServer[] m_rgStatsFDServers = null;
        private CLog m_log = null;

        // an array of sqlconnection objects that corresponds to the 
        // sql connection strings above
        private SqlConnection[] m_rgSqlConnections = null;

        // how many competition template partitions are there?
        private const int c_iNumCompPartitions = 4;

        // competition leaderboards encode the template id in the
        // 3rd to 6th highest bits. The template id cannot be zero
        // therefore if any of these four bits are set, the leaderboard
        // is a competition leaderboard
        private const int c_uiCompMask = 0x3C000000;

        public CStats(
            string[] rgsStatsDBConnectionStrings,
            CServer[] rgStatsFDServers,
            CLog log)
        {
            if (log == null)
            {
                // if they didn't give us a logging object, then create one that
                // does nothing
                m_log = new CLogNull();
            }
            else
            {
                m_log = log;
            }
            
            // make sure all non-log parameters are non-null. The last two can be empty arrays,
            // but they can't be null.
            if (rgsStatsDBConnectionStrings == null)
            {
                throw new ArgumentNullException("rgsStatsDBConnectionStrings");
            }

            if (rgStatsFDServers == null)
            {
                throw new ArgumentNullException("rgStatsFDServers");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.ctor(" +
                "{rgsStatsDBConnectionStrings}, " +
                "{rgStatsFDServers})");
            m_log.StackTrace("{rgsStatsDBConnectionStrings}="
                + CLog.CollectionToString(rgsStatsDBConnectionStrings));
            m_log.StackTrace("{rgStatsFDServers}="
                + CLog.CollectionToString(rgStatsFDServers));

            m_rgsStatsDBConnectionStrings = rgsStatsDBConnectionStrings;
            m_rgStatsFDServers = rgStatsFDServers;

            m_rgSqlConnections = new SqlConnection[NumStatsDatabases];

            // loop through every connection string we were provided and
            // create a sql connection. Note, I've decided not to track
            // the opened state of these connections. I'll rely on the
            // sql classes to throw the appropriate exceptions if someone
            // calls Close on this class and then attempts to use some
            // other methods.
            int i = 0;
            try
            {
                for (i = 0; i < NumStatsDatabases; ++i)
                {
                    m_log.FullTrace("Xbox.Tools.Framework.CStats.ctor: "
                        + "Opening connection to stats database using connection string '"
                        + m_rgsStatsDBConnectionStrings[i]
                        + "'");
                    m_rgSqlConnections[i] = new SqlConnection(m_rgsStatsDBConnectionStrings[i]);
                    m_rgSqlConnections[i].Open();
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "Xbox.Tools.Framework.CStats.ctor: "
                    + "Opening a connection to "
                    + m_rgsStatsDBConnectionStrings[i]
                    + " caused a SqlException. Exception details: "
                    + sqlException.Message;
                m_log.LogFile(sErr);
                throw new CStatsException(sErr, sqlException);
            }
            catch (ArgumentException ArgumentException)
            {
                // this gets thrown if the connection string is improperly formatted
                string sErr = "Xbox.Tools.Framework.CStats.ctor: "
                    + "Opening a connection to "
                    + m_rgsStatsDBConnectionStrings[i]
                    + " caused an ArgumentException. Exception details: "
                    + ArgumentException.Message;
                m_log.LogFile(sErr);
                throw new CStatsException(sErr, ArgumentException);
            }

            m_log.StackTrace("Xbox.Tools.Framework.CStats.ctor complete");
        }

        // a couple properties as shorthand for "how many servers do I have?"
        public int NumStatsDatabases
        {
            get
            {
                return m_rgsStatsDBConnectionStrings.Length;
            }
        }
        public int NumFrontDoors
        {
            get
            {
                return m_rgStatsFDServers.Length;
            }
        }

        public void Close()
        {
            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.Close()");

            for (int i = 0; i < NumStatsDatabases; ++i)
            {
                try
                {
                    if (m_rgSqlConnections[i] != null && m_rgSqlConnections[i].State != ConnectionState.Closed)
                    {
                        m_log.FullTrace("Xbox.Tools.Framework.CStats.Close: "
                            + "Closing sql connection "
                            + m_rgSqlConnections[i].ConnectionString);
                        m_rgSqlConnections[i].Close();
                    }
                }
                catch (Exception e)
                {
                    // we want to attempt to close every connection, even if
                    // closing one of them threw an exception, so squash this
                    // but note it in the log
                    m_log.LogFile("Xbox.Tools.Framework.CStats.Close: "
                        + "Exception closing sql connection "
                        + m_rgSqlConnections[i].ConnectionString
                        + " Exception details: "
                        + e.Message);
                }
            }
            
            m_log.StackTrace("Xbox.Tools.Framework.CStats.Close complete");
        }

        // I had this little code block repeated all over the place in this
        // file, so I finally decided to put it in this little helper function
        // It's not always useful, because sometimes I want to check the return
        // code for specific values, but I found that most of the time
        // I just threw the same message if it was non-zero
        private void ExecuteNonQuery(
            SqlCommand sqlCommand,
            string sContext)
        {
            try
            {
                sqlCommand.ExecuteNonQuery();
                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    string sErr = sContext
                        + ": The stored procedure "
                        + sqlCommand.CommandText
                        + " returned " 
                        + iRet;
                    m_log.LogFile(sErr);
                    throw new CStatsException(sErr);
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = sContext
                    + ": The stored procedure "
                    + sqlCommand.CommandText 
                    + " caused a SqlException. Details: "
                    + sqlException.Message;
                m_log.LogFile(sErr);
                throw new CStatsException(sErr, sqlException);
            }
        }

        public SortedList TitleGetDatabaseMap()
        {
            m_log.StackTrace("Xbox.Tools.Framework.CStats.TitleGetDatabaseMap()");

            // each element of the sorted list is an array of bools, indexed by
            // server index. Example, if title config 1 is found on server index 3, then 
            // ((bool[])sortedList[1])[3] == true
            SortedList sortedList  = new SortedList();

            // iterate through every server we know about and look for title configs
            for (int i = 0; i < NumStatsDatabases; ++i)
            {
                SqlCommand sqlCommand = m_rgSqlConnections[i].CreateCommand();
                sqlCommand.CommandText = "p_Stats_QueryTitles";
                sqlCommand.CommandType = CommandType.StoredProcedure;
                sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

                m_log.FullTrace(
                    "Xbox.Tools.Framework.CStats.TitleGetDatabaseMap: SqlCommand:"
                    + CLog.SqlCommandToString(sqlCommand));

                SqlDataReader sqlDataReader = null;
                try
                {
                    sqlDataReader = sqlCommand.ExecuteReader();
                    while (sqlDataReader.Read())
                    {
                        uint uiTitleId = (uint)(int)sqlDataReader["i_titleId"];

                        m_log.FullTrace("Xbox.Tools.Framework.CStats.TitleGetDatabaseMap: "
                            + "Found title config for "
                            + uiTitleId
                            + " on server "
                            + i);

                        if (sortedList[uiTitleId] == null)
                        {
                            // we don't yet have an entry for this leaderboard
                            // number, so allocate one
                            bool[] rgbMap = new bool[NumStatsDatabases];
                            for (int j = 0; j < NumStatsDatabases; ++j)
                            {
                                rgbMap[j] = false;
                            }
                            sortedList[uiTitleId] = rgbMap;
                        }

                        // we found a title config on server i, so set the flag
                        ((bool[])sortedList[uiTitleId])[i] = true;
                    }

                    // close the sqlDataReader so we can check the return code
                    sqlDataReader.Close();

                    int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                    if (iRet != 0)
                    {
                        // for some reason, we were not able to get the title configuration
                        // note that not finding the configuration should not cause this error,
                        // it should just return zero rows
                        string sErr = "Xbox.Tools.Framework.CStats.TitleGetDatabaseMap: "
                            + "The stored procedure "
                            + sqlCommand.CommandText
                            + " returned " 
                            + iRet;
                        m_log.LogFile(sErr);
                        throw new CStatsException(sErr);
                    }
                }
                catch (SqlException sqlException)
                {
                    string sErr = "Xbox.Tools.Framework.CStats.TitleGetDatabaseMap: "
                        + "Calling the stored procedure "
                        + sqlCommand.CommandText
                        + " or reading the results caused a SqlException. Exception details: "
                        + sqlException.Message;
                    m_log.LogFile(sErr);
                    throw new CStatsException(sErr, sqlException);
                }
                finally
                {
                    // clean up the sqlDataReader if we need to
                    if (sqlDataReader != null && !sqlDataReader.IsClosed)
                    {
                        sqlDataReader.Close();
                    }
                }
            }
            m_log.StackTrace("Xbox.Tools.Framework.CStats.TitleGetDatabaseMap complete");
            return sortedList;
        }

        public void TitleDelete(
            CTitleId tid,
            int iSqlTimeoutSeconds,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.TitleDelete(" +
                tid.ToString()+ ", "+
                iSqlTimeoutSeconds+ ", " +
                bReportOnly+ ")");

            // loop through all the stats databases and nuke it
            for (int i = 0; i < NumStatsDatabases; ++i)
            {
                TitleDelete(tid, i, iSqlTimeoutSeconds, bReportOnly);
            }

            m_log.StackTrace("Xbox.Tools.Framework.CStats.TitleDelete complete");
        }


        public void TitleDelete(
            CTitleId tid,
            int iStatsDatabase,
            int iSqlTimeoutSeconds,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.TitleDelete(" +
                tid.ToString()+ ", "+
                iStatsDatabase+ ", " +
                iSqlTimeoutSeconds+ ", " +
                bReportOnly+ ")");

            if (iStatsDatabase < 0 || iStatsDatabase >= NumStatsDatabases)
            {
                string sErr = "Xbox.Tools.Framework.CStats.TitleDelete: "
                    + "iStatsDatabase must be between zero and n-1 where n = the number of elements "
                    + "in rgsStatsDBConnectionStrings passed to the constructor";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("iStatsDatabase", sErr);
            }

            SqlCommand sqlCommand = m_rgSqlConnections[iStatsDatabase].CreateCommand();
            sqlCommand.CommandText = "p_Stats_DeleteTitle";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;
            sqlCommand.CommandTimeout = iSqlTimeoutSeconds;

            m_log.DataMod(
                "Xbox.Tools.Framework.CStats.TitleDelete: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            if (!bReportOnly)
            {
                ExecuteNonQuery(sqlCommand, "Xbox.Tools.Framework.TitleDelete");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CStats.TitleDelete complete");
        }

        public void TitleConfigSet(
            CTitleId tid,
            int iStatsDatabase,
            uint uiMaxWrites,
            uint uiMaxReads,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.TitleConfigSet(" +
                tid.ToString()+ ", " +
                iStatsDatabase+ ", " +
                uiMaxWrites+ ", " +
                uiMaxReads+ ", " +
                bReportOnly+ ")");

            if (iStatsDatabase < 0 || iStatsDatabase >= NumStatsDatabases)
            {
                string sErr = "Xbox.Tools.Framework.CStats.TitleConfigSet: "
                    + "iStatsDatabase must be between zero and n-1 where n = the number of elements "
                    + "in rgsStatsDBConnectionStrings passed to the constructor";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("iStatsDatabase", sErr);
            }

            m_log.LogFile(
                "Xbox.Tools.Framework.CStats.TitleConfigSet: " +
                "Adding or Updating title information.");

            SqlCommand sqlCommand = m_rgSqlConnections[iStatsDatabase].CreateCommand();
            sqlCommand.CommandText = "p_Stats_ConfigureTitle";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_titleId", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("@i_maxWrites", SqlDbType.Int).Value = (int)uiMaxWrites;
            sqlCommand.Parameters.Add("@i_maxReads", SqlDbType.Int).Value = (int)uiMaxReads;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.DataMod(
                "Xbox.Tools.Framework.CStats.TitleConfigSet: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            if (!bReportOnly)
            {
                ExecuteNonQuery(sqlCommand, "Xbox.Tools.Framework.TitleConfigSet");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CStats.TitleConfigSet complete");
        }

        public void TitleConfigSet(
            CTitleId tid,
            uint uiMaxWrites,
            uint uiMaxReads,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.TitleConfigSet(" +
                tid.ToString()+ ", " +
                uiMaxWrites+ ", " +
                uiMaxReads+ ", " +
                bReportOnly+ ")");

            for (int i = 0; i < NumStatsDatabases; ++i)
            {
                m_log.FullTrace("Xbox.Tools.Framework.CStats.TitleConfigSet: "
                    + "Calling TitleConfigSet for database "
                    + i);
                TitleConfigSet(tid, i, uiMaxWrites, uiMaxReads, bReportOnly);
            }

            m_log.StackTrace("Xbox.Tools.Framework.CStats.TitleConfigSet complete");
        }

        public bool TitleConfigGet(
            CTitleId tid,
            int iStatsDatabase,
            out uint uiMaxWrites,
            out uint uiMaxReads)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.TitleConfigGet(" +
                tid.ToString()+ ", " +
                iStatsDatabase + ")");

            if (iStatsDatabase < 0 || iStatsDatabase >= NumStatsDatabases)
            {
                string sErr = "Xbox.Tools.Framework.CStats.TitleConfigGet: iStatsDatabase " 
                    + "must be between zero and n-1 where n = the number of elements " 
                    + "in rgsStatsDBConnectionStrings passed to the constructor";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("iStatsDatabase", sErr);
            }

            // set default values, in case we find no rows
            uiMaxWrites = 0;
            uiMaxReads = 0;

            // we haven't found anything yet!
            bool bFound = false;

            SqlCommand sqlCommand = m_rgSqlConnections[iStatsDatabase].CreateCommand();

            sqlCommand.CommandText = "p_Stats_GetTitleConfig";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_titleId", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.DataMod(
                "Xbox.Tools.Framework.CStats.TitleConfigGet: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            SqlDataReader sqlDataReader = null;
            try
            {
                // run the command!
                sqlDataReader = sqlCommand.ExecuteReader();

                // get the results
                int iRowsRead = 0;
                while (sqlDataReader.Read())
                {
                    m_log.FullTrace(
                        "Xbox.Tools.Framework.CStats.TitleConfigGet: "
                        + "found config for titleid "
                        + tid.sTitleIdHex);

                    ++iRowsRead;
                    if (iRowsRead > 1)
                    {
                        string sErr = "Xbox.Tools.Framework.CStats.TitleConfigGet: "
                            + " more than one row was returned by " 
                            + sqlCommand.CommandText;
                        m_log.LogFile(sErr);
                        throw new CStatsException(sErr);
                    }

                    // save the results in the out parameters

                    // from the table definition:
                    // i_titleId               int         not null,
                    // i_maxWrites             int         not null,
                    // i_maxReads              int         not null

                    uiMaxWrites = (uint)(int)sqlDataReader["i_maxWrites"];
                    uiMaxReads = (uint)(int)sqlDataReader["i_maxReads"];
                }

                // close the reader so we can check the return code
                sqlDataReader.Close();

                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    // for some reason, we were not able to get the title configuration
                    // note that not finding the configuration should not cause this error,
                    // it should just return zero rows
                    string sErr = "Xbox.Tools.Framework.CStats.TitleConfigGet: The stored procedure "
                        + sqlCommand.CommandText
                        + " returned " 
                        + iRet;
                    m_log.LogFile(sErr);
                    throw new CStatsException(sErr);
                }

                // if we found exactly one row, then we want to return true
                if (iRowsRead == 1)
                {
                    bFound = true;
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "Xbox.Tools.Framework.CStats.TitleConfigGet: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;
                m_log.LogFile(sErr);
                throw new CStatsException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }
            m_log.StackTrace("Xbox.Tools.Framework.CStats.TitleConfigGet complete, returning:" + bFound);
            return bFound;
        }

        public void TitleConfigDelete(
            CTitleId tid,
            int iStatsDatabase,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.TitleConfigDelete(" +
                tid.ToString()+ ", " +
                iStatsDatabase+ ", " +
                bReportOnly+ ")");

            if (iStatsDatabase < 0 || iStatsDatabase >= NumStatsDatabases)
            {
                string sErr = "Xbox.Tools.Framework.CStats.TitleConfigDelete: "
                    + "iStatsDatabase must be between zero and n-1 where n = the number of elements "
                    + "in rgsStatsDBConnectionStrings passed to the constructor";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("iStatsDatabase", sErr);
            }

            m_log.FullTrace(
                "Xbox.Tools.Framework.CStats.TitleConfigDelete: " +
                "Removing title configuration information.");

            SqlCommand sqlCommand = m_rgSqlConnections[iStatsDatabase].CreateCommand();
            sqlCommand.CommandText = "p_Stats_DeleteTitleConfig";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_titleId", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.DataMod(
                "Xbox.Tools.Framework.CStats.TitleConfigDelete: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            if (!bReportOnly)
            {
                ExecuteNonQuery(sqlCommand, "Xbox.Tools.Framework.TitleConfigDelete");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CStats.TitleConfigDelete complete");
        }

        public SortedList LBGetDatabaseMap(
            CTitleId tid,
            bool bIgnoreCompLBs)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CStats.LBGetDatabaseMap(" +
                tid.ToString()+ ","+
                bIgnoreCompLBs+")");

            // each element of the sorted list is an array of bools, indexed by
            // server index. Example, if leaderboard 1 is found on server index 3, then 
            // ((bool[])sortedList[1])[3] == true
            // I've gone with this slightly contorted construct to enable me to 
            // support the fact that it's possible for a leaderboard to be
            // defined on multiple servers. While that's not allowed, it is possible
            // and since this is the management object, it can't throw a fit 
            // if it happens, otherwise we may not be able to easily detect and 
            // delete the offending leaderboard!
            SortedList sortedList  = new SortedList();

            // iterate through every server we know about and look for leaderboards
            for (int i = 0; i < NumStatsDatabases; ++i)
            {
                SqlCommand sqlCommand = m_rgSqlConnections[i].CreateCommand();
                sqlCommand.CommandText = "p_Stats_QueryLeaderBoards";
                sqlCommand.CommandType = CommandType.StoredProcedure;
                sqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)tid.uiTitleId;
                sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

                m_log.FullTrace(
                    "Xbox.Tools.Framework.CStats.LBGetDatabaseMap: SqlCommand:"
                    + CLog.SqlCommandToString(sqlCommand));

                SqlDataReader sqlDataReader = null;
                try
                {
                    sqlDataReader = sqlCommand.ExecuteReader();
                    while (sqlDataReader.Read())
                    {
                        uint uiLBNum = (uint)(int)sqlDataReader["i_leader_board_type"];

                        m_log.FullTrace("Xbox.Tools.Framework.CStats.LBGetDatabaseMap: "
                            + "Found leaderboard "
                            + uiLBNum
                            + " on server "
                            + i);

                        if ((uiLBNum & c_uiCompMask) != 0 && bIgnoreCompLBs)
                        {
                            // this is a competition leaderboard, and the caller doesn't
                            // want to know about it, so continue with the next
                            m_log.FullTrace("Xbox.Tools.Framework.CStats.LBGetDatabaseMap: "
                                + "Ignoring competition leaderboard "
                                + uiLBNum
                                + " on server "
                                + i);
                            continue;
                        }

                        if (sortedList[uiLBNum] == null)
                        {
                            // we don't yet have an entry for this leaderboard
                            // number, so allocate one
                            bool[] rgbMap = new bool[NumStatsDatabases];
                            for (int j = 0; j < NumStatsDatabases; ++j)
                            {
                                rgbMap[j] = false;
                            }
                            sortedList[uiLBNum] = rgbMap;
                        }

                        // we found leaderboard uiLBNum on server i, so set the flag
                        ((bool[])sortedList[uiLBNum])[i] = true;
                    }

                    // close the sqlDataReader so we can check the return code
                    sqlDataReader.Close();

                    int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                    if (iRet != 0)
                    {
                        // for some reason, we were not able to get the title configuration
                        // note that not finding the configuration should not cause this error,
                        // it should just return zero rows
                        string sErr = "Xbox.Tools.Framework.CStats.LBGetDatabaseMap: "
                            + "The stored procedure "
                            + sqlCommand.CommandText
                            + " returned " 
                            + iRet;
                        m_log.LogFile(sErr);
                        throw new CStatsException(sErr);
                    }
                }
                catch (SqlException sqlException)
                {
                    string sErr = "Xbox.Tools.Framework.CStats.LBGetDatabaseMap: "
                        + "Calling the stored procedure "
                        + sqlCommand.CommandText
                        + " or reading the results caused a SqlException. Exception details: "
                        + sqlException.Message;
                    m_log.LogFile(sErr);
                    throw new CStatsException(sErr, sqlException);
                }
                finally
                {
                    // clean up the sqlDataReader if we need to
                    if (sqlDataReader != null && !sqlDataReader.IsClosed)
                    {
                        sqlDataReader.Close();
                    }
                }
            }
            m_log.StackTrace("Xbox.Tools.Framework.CStats.LBGetDatabaseMap complete");
            return sortedList;
        }

        public void LBConfigSet(
            CTitleId tid,
            int iStatsDatabase,
            uint uiLBNum, 
            ELBReset riLBResetInterval,
            uint uiAttachmentCount,
            uint uiMaxAttachmentSize,
            uint uiDecayDays,
            uint uiMaxRatingCount,
            bool bArbitrationRequired,
            bool bIsTeam,
            CELOConfig eloConfig,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.LBConfigSet(" +
                tid.ToString()+ ", " +
                iStatsDatabase + ", " +
                uiLBNum + ", " +
                riLBResetInterval + ", " +
                uiAttachmentCount+ ", " +
                uiMaxAttachmentSize+ ", " +
                uiDecayDays+ ", " +
                uiMaxRatingCount+ ", " +
                bArbitrationRequired+ ", " +
                bIsTeam + ", " +
                (eloConfig == null ? "null" : eloConfig.ToString())+ ", " +
                bReportOnly+ ")");

            if (iStatsDatabase < 0 || iStatsDatabase >= NumStatsDatabases)
            {
                string sErr = "Xbox.Tools.Framework.CStats.LBConfigSet: "
                    + "iStatsDatabase must be between zero and n-1 where n = the number of elements " 
                    + "in rgsStatsDBConnectionStrings passed to the constructor";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("iStatsDatabase", sErr);
            }

            if (bArbitrationRequired == true)
            {
                string sErr = "Xbox.Tools.Framework.CStats.LBConfigSet: LBs that "
                    + "require Arbitration cannot have Attachments.";
                if (uiAttachmentCount != 0)
                {
                    m_log.LogFile(sErr);
                    throw new ArgumentException(sErr,"uiAttachmentCount");
                }
                else if (uiMaxAttachmentSize != 0)
                {
                    m_log.LogFile(sErr);
                    throw new ArgumentException(sErr,"uiMaxAttachmentSize");
                }
            }

            // eloConfig is allowed to be null
            if (eloConfig != null && !eloConfig.IsValid())
            {
                string sErr = "Xbox.Tools.Framework.CStats.LBConfigSet: "
                    + "The ELO config provided is not valid";
                throw new ArgumentException(sErr, "eloConfig");
            }

            // double check to make sure the caller isn't attempting to create
            // this leaderboard when it already exists on a different database
            SortedList sortedListDBMap = LBGetDatabaseMap(tid, false);
            if (sortedListDBMap[uiLBNum] != null)
            {
                // the leaderboard exists, but is it on the wrong server?
                bool[] rgbServerMap = (bool[])sortedListDBMap[uiLBNum];

                for (int i = 0; i < NumStatsDatabases; ++i)
                {
                    if (rgbServerMap[i] == true && i != iStatsDatabase)
                    {
                        string sErr = "Xbox.Tools.Framework.CStats.LBConfigSet: "
                            + "Cannot create leaderboard "
                            + uiLBNum
                            + " on server "
                            + iStatsDatabase
                            + " because it already exists on server "
                            + i;
                        m_log.LogFile(sErr);
                        throw new CStatsException(sErr);
                    }
                }
            }

            // we rely on the stored proc to return non-zero in the case where the
            // leaderboard already exists on the server, but cannot be updated
            // because the caller tried to change the team status or the top 100 
            // status

            SqlCommand sqlCommand = m_rgSqlConnections[iStatsDatabase].CreateCommand();

            sqlCommand.CommandText = "p_Stats_CreateNewLeaderBoard";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("@i_leader_board_type", SqlDbType.Int).Value = (int)uiLBNum;
            sqlCommand.Parameters.Add("@ti_reset_type", SqlDbType.TinyInt).Value = (byte)riLBResetInterval;
            sqlCommand.Parameters.Add("@i_att_count", SqlDbType.Int).Value = (int)uiAttachmentCount;
            sqlCommand.Parameters.Add("@i_max_att_size", SqlDbType.Int).Value = (int)uiMaxAttachmentSize;
            sqlCommand.Parameters.Add("@i_decay_days", SqlDbType.Int).Value = (int)uiDecayDays;
            sqlCommand.Parameters.Add("@i_max_rating_count", SqlDbType.Int).Value = (int)uiMaxRatingCount;
            sqlCommand.Parameters.Add("@ti_top_hundred", SqlDbType.TinyInt).Value = (byte)(uiMaxRatingCount == 0 ? 0 : 1);
            sqlCommand.Parameters.Add("@ti_ReqArbitration", SqlDbType.TinyInt).Value = (byte)(bArbitrationRequired == false ? 0 : 1);
            sqlCommand.Parameters.Add("@vc_params", SqlDbType.VarChar,256).Value = (eloConfig == null ? "" : eloConfig.ToStatsDBString()); 
            sqlCommand.Parameters.Add("@ti_IsTeam", SqlDbType.TinyInt).Value = (byte)(bIsTeam == false ? 0 : 1);   
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.DataMod(
                "Xbox.Tools.Framework.CStats.LBConfigSet: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            if (!bReportOnly)
            {
                try
                {
                    sqlCommand.ExecuteNonQuery();
                    int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                    if (iRet != 0)
                    {
                        string sErr;
                        if (iRet == -1)
                        {
                            // this is the error code returned when we try to change i_max_rating_count
                            sErr = "Xbox.Tools.Framework.CStats.LBConfigSet: "
                                + "Unable to update leaderboard definition. Cannot change max rating count "
                                + "of an existing leaderboard.";
                        }
                        else if (iRet == -2)
                        {
                            // this is the error code returned when we try to change ti_IsTeam
                            sErr = "Xbox.Tools.Framework.CStats.LBConfigSet: "
                                + "Unable to update leaderboard definition. Cannot change team status "
                                + "of an existing leaderboard.";
                        }
                        else
                        {
                            // not sure what happened
                            sErr = "Xbox.Tools.Framework.CStats.LBConfigSet: "
                                + "The stored procedure "
                                + sqlCommand.CommandText
                                + " returned " 
                                + iRet;
                        }
                        m_log.LogFile(sErr);
                        throw new CStatsException(sErr);
                    }
                }
                catch (SqlException sqlException)
                {
                    string sErr = "Xbox.Tools.Framework.CStats.LBConfigSet: "
                        + "Calling the stored procedure "
                        + sqlCommand.CommandText
                        + " caused a SqlException. Exception details: "
                        + sqlException.Message;
                    m_log.LogFile(sErr);
                    throw new CStatsException(sErr, sqlException);
                }
            }
            m_log.StackTrace("Xbox.Tools.Framework.CStats.LBConfigSet complete");
        }

        public bool LBConfigGet(
            CTitleId tid,
            int iStatsDatabase,
            uint uiLBNum, 
            out ELBReset leaderboardResetInterval,
            out uint uiAttachmentCount,
            out uint uiMaxAttachmentSize,
            out uint uiDecayDays,
            out uint uiMaxRatingCount,
            out bool bRequireArbitration,
            out bool bIsTeam,
            out CELOConfig eloConfig,
            out Guid guid,
            out long lMinQualifyingRating,
            out DateTime dateTimeCreated,
            out byte bReadOnly,
            out byte bCopying,
            out byte bDelete)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.LBConfigGet(" +
                tid.ToString()+ ", " +
                iStatsDatabase + ", " +
                uiLBNum + ")");

            if (iStatsDatabase < 0 || iStatsDatabase >= NumStatsDatabases)
            {
                string sErr = "Xbox.Tools.Framework.CStats.LBConfigGet: iStatsDatabase " 
                    + "must be between zero and n-1 where n = the number of elements " 
                    + "in rgsStatsDBConnectionStrings passed to the constructor";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("iStatsDatabase", sErr);
            }

            // set default values, in case we find no rows
            leaderboardResetInterval = ELBReset.ResetNever;
            uiAttachmentCount = 0;
            uiMaxAttachmentSize = 0;
            uiDecayDays = 0;
            uiMaxRatingCount = 0;
            bRequireArbitration = false;
            bIsTeam = false;
            eloConfig = null;
            guid = Guid.NewGuid();
            lMinQualifyingRating = 0;
            dateTimeCreated = DateTime.UtcNow;
            bReadOnly = 0;
            bCopying = 0;
            bDelete = 0;

            // we haven't found anything yet!
            bool bFound = false;

            SqlCommand sqlCommand = m_rgSqlConnections[iStatsDatabase].CreateCommand();

            sqlCommand.CommandText = "p_Stats_GetLeaderboardConfig";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("@i_leader_board_type", SqlDbType.Int).Value = (int)uiLBNum;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.FullTrace(
                "Xbox.Tools.Framework.CStats.LBConfigGet: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            SqlDataReader sqlDataReader = null;
            try
            {
                // run the command!
                sqlDataReader = sqlCommand.ExecuteReader();
                
                // get the results
                int iRowsRead = 0;
                while (sqlDataReader.Read())
                {
                    m_log.FullTrace(
                        "Xbox.Tools.Framework.CStats.LBConfigGet: "
                        + "found leaderboard "
                        + uiLBNum);

                    ++iRowsRead;
                    if (iRowsRead > 1)
                    {
                        string sErr = "Xbox.Tools.Framework.CStats.LBConfigGet: "
                            + " more than one row was returned by the stored proc " 
                            + sqlCommand.CommandText;
                        m_log.LogFile(sErr);
                        throw new CStatsException(sErr);
                    }

                    // save the results int the out parameters

                    // from the table definition:
                    // ti_reset_type           tinyint      not null,
                    // dt_created              datetime     not null,
                    // i_att_count             int          not null,
                    // i_max_att_size          int          not null,
                    // i_decay_days            int          not null,
                    // i_max_rating_count      int          not null,
                    // bi_min_qualif_rating    bigint,
                    // vc_params               varchar(256) not null,
                    // ti_IsTeam               tinyint      not null,
                    // ti_ReqArbitration       tinyint      not null,
                    // f_readonly              tinyint      not null default(0),
                    // f_copying               tinyint      not null default(0),
                    // f_delete                tinyint      not null default(0)

                    leaderboardResetInterval = (ELBReset)(byte)sqlDataReader["ti_reset_type"];
                    uiAttachmentCount = (uint)(int)sqlDataReader["i_att_count"];
                    uiMaxAttachmentSize = (uint)(int)sqlDataReader["i_max_att_size"];
                    uiDecayDays = (uint)(int)sqlDataReader["i_decay_days"];
                    uiMaxRatingCount = (uint)(int)sqlDataReader["i_max_rating_count"];
                    bRequireArbitration = ((byte)sqlDataReader["ti_ReqArbitration"] == 0 ? false : true);
                    bIsTeam = ((byte)sqlDataReader["ti_IsTeam"] == 0 ? false : true);
                    string sEloConfig = (string)sqlDataReader["vc_params"];
                    if (sEloConfig == String.Empty)
                    {
                        eloConfig = null;
                    }
                    else
                    {
                        try
                        {
                            eloConfig = CELOConfig.Parse(sEloConfig);
                        }
                        catch (FormatException formatException)
                        {
                            string sErr = "Xbox.Tools.Framework.CStats.LBConfigGet: "
                                + "Could not parse ELO string for leaderboard " 
                                + uiLBNum
                                + ": "
                                + sEloConfig;
                            m_log.LogFile(sErr);
                            throw new CStatsException(sErr, formatException);
                        }
                        if (!eloConfig.IsValid())
                        {
                            string sWarning = "Xbox.Tools.Framework.CStats.LBConfigGet: "
                                + "ELO string for leaderboard " 
                                + uiLBNum
                                + " is not valid: "
                                + sEloConfig;
                            m_log.LogFile(sWarning);
                            // note - don't throw, just note the error
                        }
                    }
                    guid = (Guid)sqlDataReader["uid_leader_board_id"];
                    lMinQualifyingRating = (long)(Int64)sqlDataReader["bi_min_qualif_rating"];
                    dateTimeCreated = (DateTime)sqlDataReader["dt_created"];
                    bReadOnly = ((byte)sqlDataReader["f_readonly"]);
                    bCopying = ((byte)sqlDataReader["f_copying"]);
                    bDelete = ((byte)sqlDataReader["f_delete"]);
                }

                // close the sqlDataReader so we can check the return code
                sqlDataReader.Close();

                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    // for some reason, we were not able to get the leaderboard definition
                    // note that not finding the leaderboard should not cause this error,
                    // it should just return zero rows
                    string sErr = "Xbox.Tools.Framework.CStats.LBConfigGet: The stored procedure "
                        + sqlCommand.CommandText
                        + " returned " 
                        + iRet;
                    m_log.LogFile(sErr);
                    throw new CStatsException(sErr);
                }

                // if we found exactly one row, then we want to return true
                if (iRowsRead == 1)
                {
                    bFound = true;
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "Xbox.Tools.Framework.CStats.LBConfigGet: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;
                m_log.LogFile(sErr);
                throw new CStatsException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }

            m_log.StackTrace("Xbox.Tools.Framework.CStats.LBConfigGet complete, returning: " + bFound);
            return bFound;
        }

        public void LBDelete(
            CTitleId tid,
            int iStatsDatabase,
            uint uiLBNum,
            int iSqlTimeoutSeconds,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.LBDelete(" +
                tid.ToString()+ ", " +
                iStatsDatabase + ", " +
                uiLBNum + ", " +
                iSqlTimeoutSeconds+ ", " +
                bReportOnly+ ")");

            if (iStatsDatabase < 0 || iStatsDatabase >= NumStatsDatabases)
            {
                string sErr = "Xbox.Tools.Framework.CStats.LBDelete: "
                    + "iStatsDatabase must be between zero and n-1 where n = the number of elements "
                    + "in rgsStatsDBConnectionStrings passed to the constructor";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("iStatsDatabase", sErr);
            }

            SqlCommand sqlCommand = m_rgSqlConnections[iStatsDatabase].CreateCommand();
            sqlCommand.CommandText = "p_Stats_DeleteLeaderBoard";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("@i_leader_board_type", SqlDbType.Int).Value = (int)uiLBNum;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;
            sqlCommand.CommandTimeout = iSqlTimeoutSeconds;

            m_log.DataMod(
                "Xbox.Tools.Framework.CStats.LBDelete: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            if (!bReportOnly)
            {
                ExecuteNonQuery(sqlCommand, "Xbox.Tools.Framework.LBDelete");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CStats.LBDelete complete");
        }

        public void LBReset(
            CTitleId tid,
            int iStatsDatabase,
            uint uiLBNum,
            int iSqlTimeoutSeconds,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.LBReset(" +
                tid.ToString()+ ", " +
                iStatsDatabase + ", " +
                uiLBNum + ", " +
                iSqlTimeoutSeconds+ ", " +
                bReportOnly+ ")");

            if (iStatsDatabase < 0 || iStatsDatabase >= NumStatsDatabases)
            {
                string sErr = "Xbox.Tools.Framework.CStats.LBReset: "
                    + "iStatsDatabase must be between zero and n-1 where n = the number of elements " 
                    + "in rgsStatsDBConnectionStrings passed to the constructor";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("iStatsDatabase", sErr);
            }

            SqlCommand sqlCommand = m_rgSqlConnections[iStatsDatabase].CreateCommand();
            sqlCommand.CommandText = "p_Stats_ResetLeaderBoard";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("@i_leader_board_type", SqlDbType.Int).Value = (int)uiLBNum;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;
            sqlCommand.CommandTimeout = iSqlTimeoutSeconds;

            m_log.DataMod(
                "Xbox.Tools.Framework.CStats.LBReset: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            if (!bReportOnly)
            {
                try
                {
                    sqlCommand.ExecuteNonQuery();
                    int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                    if (iRet != 0)
                    {
                        string sErr;
                        if (iRet == 1)
                        {
                            // this is the error code returned when we try to reset a leaderboard
                            // that doesn't exist
                            sErr = "Xbox.Tools.Framework.CStats.LBReset: "
                                + "Unable to reset leaderboard "
                                + uiLBNum
                                + ". This probably means it does not exist";
                        }
                        else
                        {
                            // not sure what happened
                            sErr = "Xbox.Tools.Framework.CStats.LBReset: "
                                + "The stored procedure "
                                + sqlCommand.CommandText
                                + " returned " 
                                + iRet;
                        }
                        m_log.LogFile(sErr);
                        throw new CStatsException(sErr);
                    }
                }
                catch (SqlException sqlException)
                {
                    string sErr = "Xbox.Tools.Framework.CStats.LBReset: "
                        + "Calling the stored procedure "
                        + sqlCommand.CommandText
                        + " caused a SqlException. Exception details: "
                        + sqlException.Message;
                    m_log.LogFile(sErr);
                    throw new CStatsException(sErr, sqlException);
                }
            }

            m_log.StackTrace("Xbox.Tools.Framework.CStats.LBReset complete");
        }

        // The TimeSpan class does not appear to allow me to specify the
        // format on it's ToString calls, and the DateTimeFormatInfo
        // does not seem to affect it, so I'm formatting timespans
        // manually...
        private static string TimeSpanFormat(TimeSpan timeSpan)
        {
            return timeSpan.Hours.ToString("D2")
                +":"
                +timeSpan.Minutes.ToString("D2")
                +":"
                +timeSpan.Seconds.ToString("D2");
        }

        public void LBMove(
            CTitleId tid,
            uint uiLBNum, 
            int iSourceStatsDatabase,
            int iDestStatsDatabase,
            bool bReset,
            int iFrontDoorTimeoutMilliseconds,
            int iSqlTimeoutSeconds,
            int iProgressReportIntervalMilliseconds,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.LBMove(" +
                tid.ToString()+ ", " +
                uiLBNum + ", " +
                iSourceStatsDatabase + ", " +
                iDestStatsDatabase + ", " +
                bReset + ", " +
                iFrontDoorTimeoutMilliseconds + ", " +
                iSqlTimeoutSeconds + ", " +
                iProgressReportIntervalMilliseconds+ ", " +
                bReportOnly+ ")");

            // how to move a leaderboard from one server to another
            //
            // step 1) call p_Stats_MoveLbInit on both the source and destination servers
            // this sets up the users required to perform the data copy, locks the 
            // leaderboard for updates, and whatever else is required to prepare for
            // the copy
            //
            // step 2) call p_Stats_MoveLbCopy on the source database. You pass it the
            // name of the destination database, and it copies the data over
            //
            // step 3) send the a request to /xstats/xstatsreloaddbmap.ashx to each
            // front door, so they know to start going to the destination database
            // for their data
            //
            // step 4) call p_Stats_MoveLbFinalize on both the source and destination
            // servers. This cleans everything up. This should be called even if
            // p_Stats_MoveLbCopy fails, because the leaderboard needs to get unlocked
            // and the users that were created need to be destroyed.
            //
            // piece of cake!

            // first do our validation homework
            if (iSourceStatsDatabase < 0 || iSourceStatsDatabase >= NumStatsDatabases)
            {
                string sErr = "Xbox.Tools.Framework.CStats.LBMove: "
                    + "iSourceStatsDatabase must be between zero and n-1 where n = the number of elements "
                    + "in rgsStatsDBConnectionStrings passed to the constructor";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("iSourceStatsDatabase", sErr);
            }
            if (iDestStatsDatabase < 0 || iDestStatsDatabase >= NumStatsDatabases)
            {
                string sErr = "Xbox.Tools.Framework.CStats.LBMove: "
                    + " iDestStatsDatabase must be between zero and n-1 where n = the number of elements "
                    + "in rgsStatsDBConnectionStrings passed to the constructor";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("iDestStatsDatabase", sErr);
            }
            if (iDestStatsDatabase == iSourceStatsDatabase)
            {
                string sErr = "Xbox.Tools.Framework.CStats.LBMove: " +
                    "iDestStatsDatabase cannot be the same as iSourceStatsDatabase";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("iDestStatsDatabase", sErr);
            }

            // if we don't know about any front doors, we can't do this safely so bail
            if (m_rgStatsFDServers == null || NumFrontDoors == 0)
            {
                string sErr = "Xbox.Tools.Framework.CStats.LBMove: " +
                    "No stats front door addresses provided to constructor, cannot move leaderboard safely";
                m_log.LogFile(sErr);
                throw new CStatsException(sErr);
            }

            // see if the leaderboard is currently defined anywhere
            SortedList sortedListDBMap = LBGetDatabaseMap(tid, false);
            bool[] rgbDatabaseMap = (bool[])sortedListDBMap[uiLBNum];
            if (rgbDatabaseMap == null)
            {
                string sErr = "Xbox.Tools.Framework.CStats.LBMove: "
                    + "Cannot move leaderboard "
                    + uiLBNum
                    + " because it does not exist on any server";
                m_log.LogFile(sErr);
                throw new CStatsException(sErr);
            }

            // if it is not defined in the source database, we can't move it
            if (rgbDatabaseMap[iSourceStatsDatabase] == false)
            {
                string sErr = "Xbox.Tools.Framework.CStats.LBMove: "
                    + "Cannot move leaderboard "
                    + uiLBNum
                    + " from server "
                    + iSourceStatsDatabase
                    + " because it does not exist on that server";
                m_log.LogFile(sErr);
                throw new CStatsException(sErr);
            }

            // if it is defined on anywhere else but the destination 
            // server, bail - they should clean that up first
            for (int i = 0; i < NumStatsDatabases; ++i)
            {
                if (rgbDatabaseMap[i] == true
                    && i != iSourceStatsDatabase
                    && i != iDestStatsDatabase)
                {
                    string sErr = "Xbox.Tools.Framework.CStats.LBMove: "
                        + "Cannot move leaderboard "
                        + uiLBNum
                        + " from server "
                        + iSourceStatsDatabase
                        + " to server "
                        + iDestStatsDatabase
                        + " because it also defined on server "
                        + i;
                    m_log.LogFile(sErr);
                    throw new CStatsException(sErr);
                }
            }

            // finally, if it is defined in the destination database
            // we should only continue if bReset has been specified
            if (rgbDatabaseMap[iDestStatsDatabase] == true && bReset == false)
            {
                string sErr = "Xbox.Tools.Framework.CStats.LBMove: "
                    + "Cannot move leaderboard "
                    + uiLBNum
                    + " from server "
                    + iSourceStatsDatabase
                    + " to server "
                    + iDestStatsDatabase
                    + " because it is already defined the destination server.";
                m_log.LogFile(sErr);
                throw new CStatsException(sErr);
            }

            // note the current time
            DateTime dtMoveStart = DateTime.Now;

            // if we're planning to provide progress reports, we'll need
            // SqlConnections to check row counts while the main
            // connection is busy moving leaderboards
            SqlConnection sqlConnectionSrcProgress = null;
            SqlConnection sqlConnectionDstProgress = null;
            if (iProgressReportIntervalMilliseconds > 0)
            {
                sqlConnectionSrcProgress = new SqlConnection(m_rgSqlConnections[iSourceStatsDatabase].ConnectionString);
                sqlConnectionDstProgress = new SqlConnection(m_rgSqlConnections[iDestStatsDatabase].ConnectionString);

                sqlConnectionSrcProgress.Open();
                sqlConnectionDstProgress.Open();
            }

            // if we made it here, then we're good to try and move it.
            try
            {
                // step 1, call p_Stats_MoveLbInit on source and dest

                // 0        1        2        3        4        5        6        7        8
                // LBSync:HH:MM:SS; Preparing src db (i) to move lb XX
                m_log.Console(
                    "LBSync:"
                    +TimeSpanFormat(DateTime.Now.Subtract(dtMoveStart))
                    +"; Preparing src db ("
                    +iSourceStatsDatabase
                    +") to move lb "
                    +uiLBNum);

                CallMoveLbInit(
                    m_rgSqlConnections[iSourceStatsDatabase], 
                    bReset, 
                    iSqlTimeoutSeconds, 
                    sqlConnectionSrcProgress,
                    dtMoveStart,
                    iProgressReportIntervalMilliseconds,
                    bReportOnly);

                // 0        1        2        3        4        5        6        7        8
                // LBSync:HH:MM:SS; Move init on src db (i) complete
                m_log.Console(
                    "LBSync:"
                    +TimeSpanFormat(DateTime.Now.Subtract(dtMoveStart))
                    +"; Move init on src db ("
                    +iSourceStatsDatabase
                    +") complete");

                // 0        1        2        3        4        5        6        7        8
                // LBSync:HH:MM:SS; Preparing dst db (i) to move lb XX
                m_log.Console(
                    "LBSync:"
                    +TimeSpanFormat(DateTime.Now.Subtract(dtMoveStart))
                    +"; Preparing dst db ("
                    +iSourceStatsDatabase
                    +") to move lb "
                    +uiLBNum);

                CallMoveLbInit(
                    m_rgSqlConnections[iDestStatsDatabase], 
                    bReset, 
                    iSqlTimeoutSeconds, 
                    sqlConnectionDstProgress,
                    dtMoveStart,
                    iProgressReportIntervalMilliseconds,
                    bReportOnly);

                // 0        1        2        3        4        5        6        7        8
                // LBSync:HH:MM:SS; Move init on dst db (i) complete
                m_log.Console(
                    "LBSync:"
                    +TimeSpanFormat(DateTime.Now.Subtract(dtMoveStart))
                    +"; Move init on dst db ("
                    +iSourceStatsDatabase
                    +") complete");

                // step 2, call p_Stats_MoveLbCopy

                // 0        1        2        3        4        5        6        7        8
                // LBSync:HH:MM:SS; Copying rows for lb XX from src to dst database
                m_log.Console(
                    "LBSync:"
                    +TimeSpanFormat(DateTime.Now.Subtract(dtMoveStart))
                    +"; copying rows for lb "
                    +uiLBNum
                    +" from src to dst database");

                CallMoveLbCopy(
                    tid,
                    m_rgSqlConnections[iSourceStatsDatabase], 
                    m_rgSqlConnections[iDestStatsDatabase], 
                    uiLBNum,
                    iSqlTimeoutSeconds, 
                    sqlConnectionDstProgress,
                    dtMoveStart,
                    iProgressReportIntervalMilliseconds,
                    bReportOnly);

                // 0        1        2        3        4        5        6        7        8
                // LBSync:HH:MM:SS; Row copy from src to dst complete
                m_log.Console(
                    "LBSync:"
                    +TimeSpanFormat(DateTime.Now.Subtract(dtMoveStart))
                    +"; row copy from src to dst complete");

                // step 3, reload stats front doors

                // 0        1        2        3        4        5        6        7        8
                // LBSync:HH:MM:SS; Refreshing stats front doors
                m_log.Console(
                    "LBSync:"
                    +TimeSpanFormat(DateTime.Now.Subtract(dtMoveStart))
                    +"; Refreshing stats front doors");

                FrontDoorReloadAll(iFrontDoorTimeoutMilliseconds,bReportOnly);

                // 0        1        2        3        4        5        6        7        8
                // LBSync:HH:MM:SS; Leaderboard XX is now live on dst database
                m_log.Console(
                    "LBSync:"
                    +TimeSpanFormat(DateTime.Now.Subtract(dtMoveStart))
                    +"; Leaderboard "
                    +uiLBNum
                    +" is now live on dst database");
            }
            finally
            {
                // step 4, call p_Stats_MoveLbFinalize
                // this should be called no matter what happened above - success, error
                // one step or many. It is supposed to either complete the move process
                // or clean up from an error.

                // Note - some errors above may have closed the connection. If that's the
                // case then we want to try to reopen it
                try
                {
                    if (m_rgSqlConnections[iDestStatsDatabase].State != ConnectionState.Open)
                    {
                        m_rgSqlConnections[iDestStatsDatabase].Open();
                    }

                    // 0        1        2        3        4        5        6        7        8
                    // LBSync:HH:MM:SS; Finalizing dst database
                    m_log.Console(
                        "LBSync:"
                        +TimeSpanFormat(DateTime.Now.Subtract(dtMoveStart))
                        +"; Finalizing dst database");

                    // if a non-zero timeout has been specified, we want to give the finalize
                    // call an unusual amount of time to try and clean up. Therefore we 
                    // triple the normal timeout value for these finalize calls.
                    CallMoveLbFinalize(
                        m_rgSqlConnections[iDestStatsDatabase],
                        iSqlTimeoutSeconds*3,
                        sqlConnectionDstProgress,
                        dtMoveStart,
                        iProgressReportIntervalMilliseconds,
                        bReportOnly);

                    // 0        1        2        3        4        5        6        7        8
                    // LBSync:HH:MM:SS; Dst database finalized
                    m_log.Console(
                        "LBSync:"
                        +TimeSpanFormat(DateTime.Now.Subtract(dtMoveStart))
                        +"; Dst database finalized");
                }
                finally
                {
                    if (m_rgSqlConnections[iSourceStatsDatabase].State != ConnectionState.Open)
                    {
                        m_rgSqlConnections[iSourceStatsDatabase].Open();
                    }

                    // 0        1        2        3        4        5        6        7        8
                    // LBSync:HH:MM:SS; Finalizing src database
                    m_log.Console(
                        "LBSync:"
                        +TimeSpanFormat(DateTime.Now.Subtract(dtMoveStart))
                        +"; Finalizing src database");

                    CallMoveLbFinalize(
                        m_rgSqlConnections[iSourceStatsDatabase], 
                        iSqlTimeoutSeconds*3, 
                        sqlConnectionSrcProgress,
                        dtMoveStart,
                        iProgressReportIntervalMilliseconds,
                        bReportOnly);

                    // 0        1        2        3        4        5        6        7        8
                    // LBSync:HH:MM:SS; Src database finalized
                    m_log.Console(
                        "LBSync:"
                        +TimeSpanFormat(DateTime.Now.Subtract(dtMoveStart))
                        +"; Src database finalized");
                }
            }

            // 0        1        2        3        4        5        6        7        8
            // LBSync:HH:MM:SS; lb XX sucessfully moved from db XX to db XX
            m_log.Console(
                "LBSync:"
                +TimeSpanFormat(DateTime.Now.Subtract(dtMoveStart))
                +"; lb "
                +uiLBNum
                +" sucessfully moved from db "
                +iSourceStatsDatabase
                +" to db "
                +iDestStatsDatabase);
            m_log.StackTrace("Xbox.Tools.Framework.CStats.LBMove complete");
        }

        public void LBMoveFinalize(
            CTitleId tid,
            int iSqlTimeoutSeconds,
            int iProgressReportIntervalMilliseconds,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.LBMoveFinalize(" +
                tid.ToString()+ ", " +
                iSqlTimeoutSeconds + ", " +
                iProgressReportIntervalMilliseconds + ", " +
                bReportOnly+ ")");

            // iterate through each known stats database and call
            // LBMoveFinalize for it
            for (int i = 0; i < NumStatsDatabases; ++i)
            {
                LBMoveFinalize(
                    tid,
                    i,
                    iSqlTimeoutSeconds,
                    iProgressReportIntervalMilliseconds,
                    bReportOnly);
            }

            m_log.StackTrace("Xbox.Tools.Framework.CStats.LBMoveFinalize complete");
        }

        public void LBMoveFinalize(
            CTitleId tid,
            int iStatsDatabase,
            int iSqlTimeoutSeconds,
            int iProgressReportIntervalMilliseconds,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.LBMoveFinalize(" +
                tid.ToString()+ ", " +
                iStatsDatabase+ ", " +
                iSqlTimeoutSeconds + ", " +
                iProgressReportIntervalMilliseconds + ", " +
                bReportOnly+ ")");

            if (iStatsDatabase < 0 || iStatsDatabase >= NumStatsDatabases)
            {
                string sErr = "Xbox.Tools.Framework.CStats.LBMove: "
                    + "iStatsDatabase must be between zero and n-1 where n = the number of elements "
                    + "in rgsStatsDBConnectionStrings passed to the constructor";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("iStatsDatabase", sErr);
            }

            // if we're planning to provide progress reports, we'll need
            // a SqlConnection to check row counts while the main
            // connection is busy moving leaderboards
            SqlConnection sqlConnectionProgress = null;
            if (iProgressReportIntervalMilliseconds > 0)
            {
                sqlConnectionProgress = new SqlConnection(m_rgSqlConnections[iStatsDatabase].ConnectionString);
                sqlConnectionProgress.Open();
            }

            // note the current time
            DateTime dtMoveStart = DateTime.Now;

            // LBSync:HH:MM:SS; Finalizing database XX
            m_log.Console(
                "LBSync:"
                +TimeSpanFormat(DateTime.Now.Subtract(dtMoveStart))
                +"; Finalizing database "
                +iStatsDatabase);

            CallMoveLbFinalize(
                m_rgSqlConnections[iStatsDatabase], 
                iSqlTimeoutSeconds,
                sqlConnectionProgress,
                dtMoveStart,
                iProgressReportIntervalMilliseconds,
                bReportOnly);

            // LBSync:HH:MM:SS; Database XX finalized
            m_log.Console(
                "LBSync:"
                +TimeSpanFormat(DateTime.Now.Subtract(dtMoveStart))
                +"; Database "
                +iStatsDatabase
                +" finalized");

            m_log.StackTrace("Xbox.Tools.Framework.CStats.LBMoveFinalize complete");
        }

        private void CallMoveLbInit(
            SqlConnection sqlConnection, 
            bool bReset, 
            int iSqlTimeoutSeconds,
            SqlConnection sqlConnectionProgress,
            DateTime dtMoveStart,
            int iProgressReportIntervalMilliseconds,
            bool bReportOnly)
        {
            Timer timer = null;
            if (iProgressReportIntervalMilliseconds != 0)
            {
                timer = MoveLbInitProgressStart(
                    dtMoveStart,
                    sqlConnectionProgress,
                    iProgressReportIntervalMilliseconds);
            }

            try
            {
                SqlCommand sqlCommand = sqlConnection.CreateCommand();
                sqlCommand.CommandText = "p_Stats_MoveLbInit";
                sqlCommand.CommandType = CommandType.StoredProcedure;
                sqlCommand.Parameters.Add("@f_reset", SqlDbType.TinyInt).Value = (bReset ? 0 : 1);
                sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;
                sqlCommand.CommandTimeout = iSqlTimeoutSeconds;

                m_log.DataMod(
                    "Xbox.Tools.Framework.CStats.LBMove: SqlCommand:" 
                    + CLog.SqlCommandToString(sqlCommand)
                    + " on "
                    + sqlConnection.ConnectionString);
                if (!bReportOnly)
                {
                    ExecuteNonQuery(sqlCommand, "Xbox.Tools.Framework.LBMove");
                }
            }
            finally
            {
                if (iProgressReportIntervalMilliseconds != 0)
                {
                    MoveLbInitProgressEnd(
                        timer, 
                        iProgressReportIntervalMilliseconds);
                }
            }
        }

        private void CallMoveLbCopy(
            CTitleId tid,
            SqlConnection sqlConnectionSource, 
            SqlConnection sqlConnectionDest,
            uint uiLBNum, 
            int iSqlTimeoutSeconds,
            SqlConnection sqlConnectionProgress,
            DateTime dtMoveStart,
            int iProgressReportIntervalMilliseconds,
            bool bReportOnly)
        {
            Timer timer = null;
            if (iProgressReportIntervalMilliseconds != 0)
            {
                // get a count of then number of rows in the source
                // database
                LbState lbSrc = new LbState();
                lbSrc.tid = tid;
                lbSrc.uiLeaderboardId = uiLBNum;
                MoveLbGetLbState(
                    sqlConnectionSource, 
                    ref lbSrc);

                // 0        1        2        3        4        5        6        7        8
                // LBSync:HH:MM:SS; xxxxxxxxx rows to copy for xx(xxxxxxxx)
                m_log.Console(
                    "LBSync:"
                    +TimeSpanFormat(DateTime.Now.Subtract(dtMoveStart))
                    +"; "
                    +lbSrc.iTotalRows
                    +" rows to copy for "
                    +uiLBNum
                    +"("
                    +tid.sTitleIdHexNoPrefix
                    +")");

                m_log.FullTrace("Xbox.Tools.Framework.CStats.CallMoveLbCopy: "
                    +"Source leaderboard "
                    +lbSrc.uiLeaderboardId
                    +"; titleid "
                    +lbSrc.tid.sTitleIdHexNoPrefix
                    +"; f_copying: "
                    +lbSrc.bCopying
                    +"; f_delete: "
                    +lbSrc.bDelete
                    +"; i_rating:"
                    +lbSrc.iRating
                    +"; i_attrib:"
                    +lbSrc.iAttrib
                    +"; i_nickname:"
                    +lbSrc.iNickname
                    +"; i_bucket:"
                    +lbSrc.iBucket
                    +"; i_bucket_count:"
                    +lbSrc.iBucketCount);

                timer = MoveLbCopyProgressStart(
                    dtMoveStart,
                    lbSrc,
                    sqlConnectionProgress,
                    iProgressReportIntervalMilliseconds);
            }

            try
            {
                SqlCommand sqlCommand = sqlConnectionSource.CreateCommand();
                sqlCommand.CommandText = "p_Stats_MoveLbCopy";
                sqlCommand.CommandType = CommandType.StoredProcedure;
                sqlCommand.Parameters.Add("@vc_destServer", SqlDbType.VarChar).Value = sqlConnectionDest.DataSource;
                sqlCommand.Parameters.Add("@i_titleId", SqlDbType.Int).Value = (int)tid.uiTitleId;
                sqlCommand.Parameters.Add("@i_lbId", SqlDbType.Int).Value = uiLBNum;
                sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;
                sqlCommand.CommandTimeout = iSqlTimeoutSeconds;

                m_log.DataMod(
                    "Xbox.Tools.Framework.CStats.LBMove: SqlCommand:" 
                    + CLog.SqlCommandToString(sqlCommand)
                    + " on "
                    + sqlConnectionSource.DataSource);
                if (!bReportOnly)
                {
                    ExecuteNonQuery(sqlCommand, "Xbox.Tools.Framework.LBMove");
                }
            }
            finally
            {
                if (iProgressReportIntervalMilliseconds != 0)
                {
                    MoveLbCopyProgressEnd(
                        timer, 
                        iProgressReportIntervalMilliseconds);
                }
            }
        }

        private void CallMoveLbFinalize(
            SqlConnection sqlConnection, 
            int iSqlTimeoutSeconds,
            SqlConnection sqlConnectionProgress,
            DateTime dtMoveStart,
            int iProgressReportIntervalMilliseconds,
            bool bReportOnly)
        {
            Timer timer = null;
            if (iProgressReportIntervalMilliseconds != 0)
            {
                // p_Stats_MoveLbFinalize calls p_Stats_MoveLbInit to
                // do the work of cleaning up leaderboards, therefore
                // the same progress reporting is a appropriate.
                timer = MoveLbInitProgressStart(
                    dtMoveStart,
                    sqlConnectionProgress, 
                    iProgressReportIntervalMilliseconds);
            }

            try
            {
                SqlCommand sqlCommand = sqlConnection.CreateCommand();
                sqlCommand.CommandText = "p_Stats_MoveLbFinalize";
                sqlCommand.CommandType = CommandType.StoredProcedure;
                sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;
                sqlCommand.CommandTimeout = iSqlTimeoutSeconds;

                m_log.DataMod(
                    "Xbox.Tools.Framework.CStats.LBMove: SqlCommand:" 
                    + CLog.SqlCommandToString(sqlCommand)
                    + " on "
                    + sqlConnection.ConnectionString);
                if (!bReportOnly)
                {
                    ExecuteNonQuery(sqlCommand, "Xbox.Tools.Framework.LBMove");
                }
            }
            finally
            {
                if (iProgressReportIntervalMilliseconds != 0)
                {
                    MoveLbInitProgressEnd(
                        timer, 
                        iProgressReportIntervalMilliseconds);
                }
            }
        }

        // private struct here to hold results from 
        // p_Stats_QueryLeaderboardsInMoveState
        private struct LbState
        {
            public CTitleId tid;
            public uint uiLeaderboardId;
            public bool bCopying;
            public bool bReadOnly;
            public bool bDelete;
            public int iTotalRows;
            public int iRating;
            public int iAttrib;
            public int iNickname;
            public int iBucket;
            public int iBucketCount;
        }

        private struct TimerState
        {
            public SqlConnection sqlConnection;
            public DateTime dtMoveStart;
            public ArrayList alLBStates;
        }

        private Timer MoveLbInitProgressStart(
            DateTime dtMoveStart,
            SqlConnection sqlConnectionProgress,
            int iProgressReportIntervalMilliseconds)
        {
            // The init proc deletes all leaderboards on the server
            // with f_copying or f_deleted flags set. So get all those
            // leaderboards, and report how many rows they have.

            SqlCommand sqlCommand = sqlConnectionProgress.CreateCommand();
            sqlCommand.CommandText = "p_Stats_QueryLeaderboardsInMoveState";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            ArrayList al = new ArrayList();
            SqlDataReader sqlDataReader = null;
            try
            {
                sqlDataReader = sqlCommand.ExecuteReader();

                while (sqlDataReader.Read())
                {
                    LbState lb = new LbState();
                    lb.tid = new CTitleId((uint)(int)sqlDataReader["i_title_id"]);
                    lb.uiLeaderboardId = (uint)(int)sqlDataReader["i_leader_board_type"];
                    lb.bReadOnly = (((byte)sqlDataReader["f_readonly"]) != 0) ? true : false;
                    lb.bCopying = (((byte)sqlDataReader["f_copying"]) != 0) ? true : false;
                    lb.bDelete = (((byte)sqlDataReader["f_delete"]) != 0) ? true : false;

                    // only leaderboards in the copying or delete states will
                    // be cleaned up by init
                    if (lb.bCopying || lb.bDelete)
                    {
                        al.Add(lb);
                    }
                }

                // close the sqlDataReader so we can check the return code
                sqlDataReader.Close();

                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    string sErr = "Xbox.Tools.Framework.CStats.MoveLbInitProgressStart: "
                        + "The stored procedure "
                        + sqlCommand.CommandText
                        + " returned " 
                        + iRet;
                    m_log.LogFile(sErr);
                    throw new CStatsException(sErr);
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "Xbox.Tools.Framework.CStats.MoveLbInitProgressStart: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;
                m_log.LogFile(sErr);
                throw new CStatsException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }

            // if we get here, we now have a list of leaderboards
            // in al that will be deleted by the init proc.
            for (int i = 0; i < al.Count; ++i)
            {
                // populate the LbState struct with current info
                LbState lb = (LbState)al[i];
                MoveLbGetLbState(sqlConnectionProgress, ref lb);
                al[i] = lb;

                //   0        1        2        3        4        5        6        7        8
                //   LBSync:HH:MM:SS; xxxxxxxx rows to delete from xx(xxxxxxxx)
                m_log.Console(
                    "LBSync:"
                    +TimeSpanFormat(DateTime.Now.Subtract(dtMoveStart))
                    +"; "
                    +((LbState)al[i]).iTotalRows
                    +" rows to delete from "
                    +((LbState)al[i]).uiLeaderboardId
                    +"("
                    +((LbState)al[i]).tid.sTitleIdHexNoPrefix
                    +")");
                m_log.FullTrace("Xbox.Tools.Framework.CStats.MoveLbInitProgressStart: "
                    +"Cleaning leaderboard "
                    +((LbState)al[i]).uiLeaderboardId
                    +"; titleid "
                    +((LbState)al[i]).tid.sTitleIdHexNoPrefix
                    +"; f_copying: "
                    +((LbState)al[i]).bCopying
                    +"; f_delete: "
                    +((LbState)al[i]).bDelete
                    +"; i_rating:"
                    +((LbState)al[i]).iRating
                    +"; i_attrib:"
                    +((LbState)al[i]).iAttrib
                    +"; i_nickname:"
                    +((LbState)al[i]).iNickname
                    +"; i_bucket:"
                    +((LbState)al[i]).iBucket
                    +"; i_bucket_count:"
                    +((LbState)al[i]).iBucketCount);
            }

            // now we need to setup the periodic progress reports

            // this is the state object that gets passed to the
            // timer delegate
            TimerState timerState = new TimerState();
            timerState.sqlConnection = sqlConnectionProgress;
            timerState.dtMoveStart = dtMoveStart;
            timerState.alLBStates = al;

            Timer timer = new Timer(
                new TimerCallback(MoveLbInitProgressDelegate), 
                timerState, 
                iProgressReportIntervalMilliseconds,
                iProgressReportIntervalMilliseconds);

            return timer;
        }

        public void MoveLbInitProgressDelegate(object oState)
        {
            TimerState timerState = (TimerState)oState;

            foreach (LbState lbStart in timerState.alLBStates)
            {
                LbState lbCur = lbStart;
                MoveLbGetLbState(timerState.sqlConnection, ref lbCur);

                // 0        1        2        3        4        5        6        7        8
                // LBSync:HH:MM:SS; xxxxxxxxx of xxxxxxxxx rows remain in xx(xxxxxxxx)
                m_log.Console(
                    "LBSync:"
                    +TimeSpanFormat(DateTime.Now.Subtract(timerState.dtMoveStart))
                    +"; "
                    +lbCur.iTotalRows
                    +" of "
                    +lbStart.iTotalRows
                    + " rows remain in "
                    +lbCur.uiLeaderboardId
                    +"("
                    +lbCur.tid.sTitleIdHexNoPrefix
                    +")");
                m_log.FullTrace("Xbox.Tools.Framework.CStats.MoveLbInitProgressDelegate: "
                    +"lb:"
                    +lbCur.uiLeaderboardId
                    +"; titleid:"
                    +lbCur.tid.sTitleIdHexNoPrefix
                    +"; f_copying: "
                    +lbCur.bCopying
                    +"; f_delete: "
                    +lbCur.bDelete
                    +"; i_rating:"
                    +lbCur.iRating
                    +"; i_attrib:"
                    +lbCur.iAttrib
                    +"; i_nickname:"
                    +lbCur.iNickname
                    +"; i_bucket:"
                    +lbCur.iBucket
                    +"; i_bucket_count:"
                    +lbCur.iBucketCount);
            }
        }

        private void MoveLbInitProgressEnd(
            Timer timer, 
            int iProgressReportIntervalMilliseconds)
        {
            WaitHandle waitHandle = new AutoResetEvent(false);
            if (!timer.Dispose(waitHandle))
            {
                string sErr = "Xbox.Tools.Framework.CStats.MoveLbInitProgressEnd: "
                    + "Error shutting down move init progress report timer object";
                m_log.LogFile(sErr);
                throw new CStatsException(sErr);
            }

            // wait up to twice the progress interval for the 
            // timer to shutdown
            if (!waitHandle.WaitOne(iProgressReportIntervalMilliseconds*2, true))
            {
                string sErr = "Xbox.Tools.Framework.CStats.MoveLbInitProgressEnd: "
                    + "Error waiting for move init progress report timer object to shut down";
                m_log.LogFile(sErr);
                throw new CStatsException(sErr);
            }
        }

        private Timer MoveLbCopyProgressStart(
            DateTime dtMoveStart,
            LbState lbSrc,
            SqlConnection sqlConnectionProgress,
            int iProgressReportIntervalMilliseconds)
        {
            // setup the periodic progress reports

            // this is the state object that gets passed to the
            // timer delegate
            TimerState timerState = new TimerState();
            timerState.sqlConnection = sqlConnectionProgress;
            timerState.dtMoveStart = dtMoveStart;

            // just one leaderboard to monitor for copy
            ArrayList al = new ArrayList();
            al.Add(lbSrc);
            timerState.alLBStates = al;

            Timer timer = new Timer(
                new TimerCallback(MoveLbCopyProgressDelegate), 
                timerState, 
                iProgressReportIntervalMilliseconds,
                iProgressReportIntervalMilliseconds);

            return timer;
        }

        public void MoveLbCopyProgressDelegate(object oState)
        {
            TimerState timerState = (TimerState)oState;

            // only one leaderboard to monitor for copy
            LbState lbSrc = (LbState)timerState.alLBStates[0];
            LbState lbCur = lbSrc;
            MoveLbGetLbState(timerState.sqlConnection, ref lbCur);

            // 0        1        2        3        4        5        6        7        8
            // LBCopy:HH:MM:SS; xxxxxxxxx of xxxxxxxxx rows copied for xx(xxxxxxxx)
            m_log.Console(
                "LBCopy:"
                +TimeSpanFormat(DateTime.Now.Subtract(timerState.dtMoveStart))
                +"; "
                +lbCur.iTotalRows
                +" of "
                +lbSrc.iTotalRows
                + " rows copied for "
                +lbSrc.uiLeaderboardId
                +"("
                +lbSrc.tid.sTitleIdHexNoPrefix
                +")");
            m_log.FullTrace("Xbox.Tools.Framework.CStats.MoveLbProgressDelegate: "
                +"lb:"
                +lbCur.uiLeaderboardId
                +"; titleid:"
                +lbCur.tid.sTitleIdHexNoPrefix
                +"; i_rating:"
                +lbCur.iRating
                +"; i_attrib:"
                +lbCur.iAttrib
                +"; i_nickname:"
                +lbCur.iNickname
                +"; i_bucket:"
                +lbCur.iBucket
                +"; i_bucket_count:"
                +lbCur.iBucketCount);
        }

        private void MoveLbCopyProgressEnd(
            Timer timer, 
            int iProgressReportIntervalMilliseconds)
        {
            WaitHandle waitHandle = new AutoResetEvent(false);
            if (!timer.Dispose(waitHandle))
            {
                string sErr = "Xbox.Tools.Framework.CStats.MoveLbInitProgressEnd: "
                    + "Error shutting down move copy progress report timer object";
                m_log.LogFile(sErr);
                throw new CStatsException(sErr);
            }

            // wait up to twice the progress interval for the 
            // timer to shutdown
            if (!waitHandle.WaitOne(iProgressReportIntervalMilliseconds*2, true))
            {
                string sErr = "Xbox.Tools.Framework.CStats.MoveLbInitProgressEnd: "
                    + "Error waiting for move copy progress report timer object to shut down";
                m_log.LogFile(sErr);
                throw new CStatsException(sErr);
            }
        }

        private void MoveLbGetLbState(
            SqlConnection sqlConnectionProgress, 
            ref LbState lb)
        {
            SqlCommand sqlCommand = sqlConnectionProgress.CreateCommand();
            sqlCommand.CommandText = "p_Stats_LbCountRows";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)lb.tid.uiTitleId;
            sqlCommand.Parameters.Add("@i_leader_board_type", SqlDbType.Int).Value = (int)lb.uiLeaderboardId;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            SqlDataReader sqlDataReader = null;
            try
            {
                // The Timer class does not serialize calls to the delegate, so
                // we need to make sure only one thread is using this sqlConnection
                // at a time
                lock(sqlConnectionProgress)
                {
                    sqlDataReader = sqlCommand.ExecuteReader();

                    // this stored proc should return exactly one row, containing the 
                    // row counts
                    if (!sqlDataReader.Read())
                    {
                        // the stored proceedure may return no rows if the 
                        // leaderboard delete has completed and the leaderboard
                        // no longer exists. In this case, the stored proc will
                        // return 1. If there are no rows and the stored proce
                        // returned 1, then set all the counts to 0. If the
                        // rc is not 1, then throw, because we don't know what
                        // is going on.

                        // close the sqlDataReader so we can check the return code
                        sqlDataReader.Close();

                        int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                        if (iRet != 1)
                        {
                            string sErr = "Xbox.Tools.Framework.CStats.MoveLbInitProgressStart: "
                                + "The stored procedure "
                                + sqlCommand.CommandText
                                + " returned no rows and returned " 
                                + iRet;
                            m_log.LogFile(sErr);
                            throw new CStatsException(sErr);
                        }

                        // zero out all the row counts
                        lb.iTotalRows = 0;
                        lb.iRating = 0;
                        lb.iAttrib= 0;
                        lb.iNickname = 0;
                        lb.iBucket = 0;
                        lb.iBucketCount = 0;
                    }
                    else
                    {
                        lb.iRating = (int)sqlDataReader["i_rating"];
                        lb.iAttrib= (int)sqlDataReader["i_attrib"];
                        lb.iNickname = (int)sqlDataReader["i_nickname"];
                        lb.iBucket = (int)sqlDataReader["i_bucket"];
                        lb.iBucketCount = (int)sqlDataReader["i_bucket_count"];

                        lb.iTotalRows 
                            = lb.iRating
                            + lb.iAttrib
                            + lb.iNickname
                            + lb.iBucket
                            + lb.iBucketCount;

                        if (sqlDataReader.Read())
                        {
                            string sErr = "Xbox.Tools.Framework.CStats.MoveLbInitProgressStart: "
                                + "The stored procedure "
                                + sqlCommand.CommandText
                                + " returned more than one row";
                            m_log.LogFile(sErr);
                            throw new CStatsException(sErr);
                        }

                        // close the sqlDataReader so we can check the return code
                        sqlDataReader.Close();

                        int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                        if (iRet != 0)
                        {
                            string sErr = "Xbox.Tools.Framework.CStats.MoveLbInitProgressStart: "
                                + "The stored procedure "
                                + sqlCommand.CommandText
                                + " returned " 
                                + iRet;
                            m_log.LogFile(sErr);
                            throw new CStatsException(sErr);
                        }
                    }
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "Xbox.Tools.Framework.CStats.MoveLbInitProgressStart: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;
                m_log.LogFile(sErr);
                throw new CStatsException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }
        }

        public SortedList UnitTitleGetDatabaseMap()
        {
            m_log.StackTrace("Xbox.Tools.Framework.CStats.UnitTitleGetDatabaseMap()");

            // each element of the sorted list is an array of bools, indexed by
            // server index. Example, if title config 1 is found on server index 3, then 
            // ((bool[])sortedList[1])[3] == true
            SortedList sortedList  = new SortedList();

            // iterate through every server we know about and look for title configs
            for (int i = 0; i < NumStatsDatabases; ++i)
            {
                SqlCommand sqlCommand = m_rgSqlConnections[i].CreateCommand();
                sqlCommand.CommandText = "p_Units_QueryTitles";
                sqlCommand.CommandType = CommandType.StoredProcedure;
                sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

                m_log.FullTrace(
                    "Xbox.Tools.Framework.CStats.UnitTitleGetDatabaseMap: SqlCommand:"
                    + CLog.SqlCommandToString(sqlCommand));

                SqlDataReader sqlDataReader = null;
                try
                {
                    sqlDataReader = sqlCommand.ExecuteReader();
                    while (sqlDataReader.Read())
                    {
                        uint uiTitleId = (uint)(int)sqlDataReader["i_titleId"];

                        m_log.FullTrace("Xbox.Tools.Framework.CStats.UnitTitleGetDatabaseMap: "
                            + "Found title config for "
                            + uiTitleId
                            + " on server "
                            + i);

                        if (sortedList[uiTitleId] == null)
                        {
                            // we don't yet have an entry for this leaderboard
                            // number, so allocate one
                            bool[] rgbMap = new bool[NumStatsDatabases];
                            for (int j = 0; j < NumStatsDatabases; ++j)
                            {
                                rgbMap[j] = false;
                            }
                            sortedList[uiTitleId] = rgbMap;
                        }

                        // we found a title config on server i, so set the flag
                        ((bool[])sortedList[uiTitleId])[i] = true;
                    }

                    // close the sqlDataReader so we can check the return code
                    sqlDataReader.Close();

                    int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                    if (iRet != 0)
                    {
                        // for some reason, we were not able to get the title configuration
                        // note that not finding the configuration should not cause this error,
                        // it should just return zero rows
                        string sErr = "Xbox.Tools.Framework.CStats.UnitTitleGetDatabaseMap: "
                            + "The stored procedure "
                            + sqlCommand.CommandText
                            + " returned " 
                            + iRet;
                        m_log.LogFile(sErr);
                        throw new CStatsException(sErr);
                    }
                }
                catch (SqlException sqlException)
                {
                    string sErr = "Xbox.Tools.Framework.CStats.UnitTitleGetDatabaseMap: "
                        + "Calling the stored procedure "
                        + sqlCommand.CommandText
                        + " or reading the results caused a SqlException. Exception details: "
                        + sqlException.Message;
                    m_log.LogFile(sErr);
                    throw new CStatsException(sErr, sqlException);
                }
                finally
                {
                    // clean up the sqlDataReader if we need to
                    if (sqlDataReader != null && !sqlDataReader.IsClosed)
                    {
                        sqlDataReader.Close();
                    }
                }
            }
            m_log.StackTrace("Xbox.Tools.Framework.CStats.UnitTitleGetDatabaseMap complete");
            return sortedList;
        }

        public void UnitTitleConfigSet(
            CTitleId tid,
            int iStatsDatabase,
            double dDecayFactor,
            uint uiMaxAvailUnits,
            uint uiSizeUnitCache,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.UnitTitleConfigSet(" +
                tid.ToString()+ ", " +
                iStatsDatabase+ ", " +
                dDecayFactor+ ", " +
                uiMaxAvailUnits+ ", " +
                uiSizeUnitCache+ ", " +
                bReportOnly+ ")");

            if (iStatsDatabase < 0 || iStatsDatabase >= NumStatsDatabases)
            {
                string sErr = "Xbox.Tools.Framework.CStats.UnitTitleConfigSet: "
                    + "iStatsDatabase must be between zero and n-1 where n = the number of elements "
                    + "in rgsStatsDBConnectionStrings passed to the constructor";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("iStatsDatabase", sErr);
            }

            if (dDecayFactor < 0)
            {
                string sErr = "Xbox.Tools.Framework.CStats.UnitTitleConfigSet: dDecayFactor must be positive";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("dDecayFactor", sErr);
            }

            m_log.FullTrace(
                "Xbox.Tools.Framework.CStats.UnitTitleConfigSet: " +
                "Adding or Updating unit title information.");

            SqlCommand sqlCommand = m_rgSqlConnections[iStatsDatabase].CreateCommand();
            sqlCommand.CommandText = "p_Units_ConfigureTitle";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_titleId", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("@f_decayFactor", SqlDbType.Float).Value = (double)dDecayFactor;
            sqlCommand.Parameters.Add("@i_maxAvailUnits", SqlDbType.Int).Value = (int)uiMaxAvailUnits;
            sqlCommand.Parameters.Add("@i_sizeUnitCache", SqlDbType.Int).Value = (int)uiSizeUnitCache;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.DataMod(
                "Xbox.Tools.Framework.CStats.UnitTitleConfigSet: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            if (!bReportOnly)
            {
                ExecuteNonQuery(sqlCommand, "Xbox.Tools.Framework.UnitTitleConfigSet");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CStats.UnitTitleConfigSet complete");
        }

        public bool UnitTitleConfigGet(
            CTitleId tid,
            int iStatsDatabase,
            out double dDecayFactor,
            out uint uiMaxAvailUnits,
            out uint uiSizeUnitCache)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.UnitTitleConfigGet(" +
                tid.ToString()+ ", " +
                iStatsDatabase + ")");

            if (iStatsDatabase < 0 || iStatsDatabase >= NumStatsDatabases)
            {
                string sErr = "Xbox.Tools.Framework.CStats.UnitTitleConfigGet: iStatsDatabase " 
                    + "must be between zero and n-1 where n = the number of elements " 
                    + "in rgsStatsDBConnectionStrings passed to the constructor";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("iStatsDatabase", sErr);
            }

            // set default values, in case we find no rows
            dDecayFactor = 0;
            uiMaxAvailUnits = 0;
            uiSizeUnitCache = 0;

            // we haven't found anything yet!
            bool bFound = false;

            SqlCommand sqlCommand = m_rgSqlConnections[iStatsDatabase].CreateCommand();
            sqlCommand.CommandText = "p_Units_GetTitleConfig";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_titleId", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.FullTrace(
                "Xbox.Tools.Framework.CStats.UnitTitleConfigGet: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            SqlDataReader sqlDataReader = null;
            try
            {
                // run the command!
                sqlDataReader = sqlCommand.ExecuteReader();

                // get the results
                int iRowsRead = 0;
                while (sqlDataReader.Read())
                {
                    m_log.FullTrace(
                        "Xbox.Tools.Framework.CStats.UnitTitleConfigGet: "
                        + "found config for titleid "
                        + tid.sTitleIdHex);

                    ++iRowsRead;
                    if (iRowsRead > 1)
                    {
                        string sErr = "Xbox.Tools.Framework.CStats.UnitTitleConfigGet: "
                            + " more than one row was returned by the stored proc " 
                            + sqlCommand.CommandText;
                        m_log.LogFile(sErr);
                        throw new CStatsException(sErr);
                    }

                    // save the results in the out parameters

                    // from the table definition:
                    // i_titleId        int   not null,
                    // f_decayFactor    float not null,
                    // i_maxAvailUnits  int   not null,
                    // i_sizeUnitCache  int   not null

                    dDecayFactor = (double)sqlDataReader["f_decayFactor"];
                    uiMaxAvailUnits = (uint)(int)sqlDataReader["i_maxAvailUnits"];
                    uiSizeUnitCache = (uint)(int)sqlDataReader["i_sizeUnitCache"];
                }

                // close the sqlDataReader so we can check the return code
                sqlDataReader.Close();

                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    // for some reason, we were not able to get the title configuration
                    // note that not finding the configuration should not cause this error,
                    // it should just return zero rows
                    string sErr = "Xbox.Tools.Framework.CStats.UnitTitleConfigGet: The stored procedure "
                        + sqlCommand.CommandText
                        + " returned " 
                        + iRet;
                    m_log.LogFile(sErr);
                    throw new CStatsException(sErr);
                }

                // if we found exactly one row, then we want to return true
                if (iRowsRead == 1)
                {
                    bFound = true;
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "Xbox.Tools.Framework.CStats.UnitTitleConfigGet: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;
                m_log.LogFile(sErr);
                throw new CStatsException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }

            m_log.StackTrace("Xbox.Tools.Framework.CStats.UnitTitleConfigGet complete, returning:" + bFound);
            return bFound;
        }

        public bool UnitTitleConfigGet(
            CTitleId tid,
            out int iStatsDatabase,
            out double dDecayFactor,
            out uint uiMaxAvailUnits,
            out uint uiSizeUnitCache)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.UnitTitleConfigGet("+
                tid.ToString()+ ")");

            // invalid index as output if we don't find anything
            iStatsDatabase = -1; 
            dDecayFactor = 0;
            uiMaxAvailUnits = 0;
            uiSizeUnitCache = 0;
            bool bFound = false;
            for (int i = 0; i < NumStatsDatabases; ++i)
            {
                if (UnitTitleConfigGet(
                    tid,
                    i,
                    out dDecayFactor,
                    out uiMaxAvailUnits,
                    out uiSizeUnitCache))
                {
                    if (bFound == true)
                    {
                        string sErr = "Xbox.Tools.Framework.CStats.UnitTitleConfigGet: "
                            + "TitleId "
                            + tid.sTitleIdHex
                            + " has units enabled in multiple databases. "
                            + "This is an error and should be corrected!";
                        m_log.LogFile(sErr);
                        throw new CStatsException(sErr);
                    }
                    bFound = true;
                    iStatsDatabase = i;
                }
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.UnitTitleConfigGet complete");
            return bFound;
        }

        public void UnitTitleDelete(
            CTitleId tid,
            int iStatsDatabase,
            int iSqlTimeoutSeconds,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.UnitTitleDelete(" +
                tid.ToString()+ ", " +
                iStatsDatabase+ ", " +
                iSqlTimeoutSeconds+ ", " +
                bReportOnly+ ")");

            if (iStatsDatabase < 0 || iStatsDatabase >= NumStatsDatabases)
            {
                string sErr = "Xbox.Tools.Framework.CStats.UnitTitleDelete: "
                    + "iStatsDatabase must be between zero and n-1 where n = the number of elements " 
                    + "in rgsStatsDBConnectionStrings passed to the constructor";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("iStatsDatabase", sErr);
            }

            SqlCommand sqlCommand = m_rgSqlConnections[iStatsDatabase].CreateCommand();
            sqlCommand.CommandText = "p_Units_DeleteTitle";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_titleId", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;
            sqlCommand.CommandTimeout = iSqlTimeoutSeconds;

            m_log.DataMod(
                "Xbox.Tools.Framework.CStats.UnitTitleDelete: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            if (!bReportOnly)
            {
                ExecuteNonQuery(sqlCommand, "Xbox.Tools.Framework.UnitTitleDelete");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CStats.UnitTitleDelete complete");
        }


        public SortedList UnitLBGetDatabaseMap(
            CTitleId tid)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CStats.UnitLBGetDatabaseMap("+
                tid.ToString()+ ")");

            // each element of the sorted list is an array of bools, indexed by
            // server index. Example, if leaderboard 1 is found on server index 3, then 
            // ((bool[])sortedList[1])[3] == true
            // Even though all the unit leaderboards are supposed to be on one server
            // I've gone with this construct to be consistent with the LBGetDatabaseMap
            // method, plus, it is possible that the database ends up in a bad state
            // and if this method doesn't provide visibility into that, how will we
            // write a tool to fix it?

            SortedList sortedList = new SortedList();

            // iterate through every server we know about and look for unit leaderboards
            for (int i = 0; i < NumStatsDatabases; ++i)
            {
                SqlCommand sqlCommand = m_rgSqlConnections[i].CreateCommand();
                sqlCommand.CommandText = "p_Units_QueryLeaderboards";
                sqlCommand.CommandType = CommandType.StoredProcedure;
                sqlCommand.Parameters.Add("@i_titleId", SqlDbType.Int).Value = (int)tid.uiTitleId;
                sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

                m_log.FullTrace(
                    "Xbox.Tools.Framework.CStats.UnitLBGetDatabaseMap: SqlCommand:"
                    + CLog.SqlCommandToString(sqlCommand));

                bool bUnitLBsFoundOnThisServer = false;
                SqlDataReader sqlDataReader = null;
                try
                {
                    sqlDataReader = sqlCommand.ExecuteReader();
                    while (sqlDataReader.Read())
                    {
                        uint uiLBNum = (uint)(int)sqlDataReader["i_unitLbId"];

                        m_log.FullTrace("Xbox.Tools.Framework.CStats.UnitLBGetDatabaseMap: "
                            + "Found unit leaderboard "
                            + uiLBNum
                            + " on server "
                            + i);
                        bUnitLBsFoundOnThisServer = true;

                        if (sortedList[uiLBNum] == null)
                        {
                            // we don't yet have an entry for this leaderboard
                            // number, so allocate one
                            bool[] rgbMap = new bool[NumStatsDatabases];
                            for (int j = 0; j < NumStatsDatabases; ++j)
                            {
                                rgbMap[j] = false;
                            }
                            sortedList[uiLBNum] = rgbMap;
                        }

                        // we found leaderboard uiLBNum on server i, so set the flag
                        ((bool[])sortedList[uiLBNum])[i] = true;
                    }

                    // close the sqlDataReader so we can check the return code
                    sqlDataReader.Close();

                    int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                    if (iRet != 0)
                    {
                        if (iRet == 1)
                        {
                            // this is returned when the title is not configured.
                            // it's a benign error, as long as we're returning
                            // no rows.
                            if (bUnitLBsFoundOnThisServer == true)
                            {
                                // shouldn't happen, throw
                                string sErr = "Xbox.Tools.Framework.CStats.UnitLBGetDatabaseMap: "
                                    + "This title is not enabled for units on server "
                                    + i
                                    + ", but unit leaderboards are defined on this server. This should not happen!";
                                m_log.LogFile(sErr);
                                throw new CStatsException(sErr);
                            }
                            // not a problem, just drop through
                        }
                        else
                        {
                            // for some reason, we were not able to get the title configuration
                            // note that not finding the configuration should not cause this error,
                            // it should just return zero rows
                            string sErr = "Xbox.Tools.Framework.CStats.UnitLBGetDatabaseMap: "
                                + "The stored procedure "
                                + sqlCommand.CommandText
                                + " returned " 
                                + iRet;
                            m_log.LogFile(sErr);
                            throw new CStatsException(sErr);
                        }
                    }
                }
                catch (SqlException sqlException)
                {
                    string sErr = "Xbox.Tools.Framework.CStats.UnitLBGetDatabaseMap: "
                        + "Calling the stored procedure "
                        + sqlCommand.CommandText
                        + " or reading the results caused a SqlException. Exception details: "
                        + sqlException.Message;
                    m_log.LogFile(sErr);
                    throw new CStatsException(sErr, sqlException);
                }
                finally
                {
                    // clean up the sqlDataReader if we need to
                    if (sqlDataReader != null && !sqlDataReader.IsClosed)
                    {
                        sqlDataReader.Close();
                    }
                }
            }
            m_log.StackTrace("Xbox.Tools.Framework.CStats.UnitLBGetDatabaseMap complete");
            return sortedList;
        }

        public void UnitLBConfigSet(
            CTitleId tid,
            int iStatsDatabase,
            uint uiLBNum, 
            bool bArbitrationRequired,
            bool bIsTeam,
            CELOConfig eloConfig,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.UnitLBConfigSet(" +
                tid.ToString()+ ", " +
                iStatsDatabase + ", " +
                uiLBNum + ", " +
                bIsTeam + ", " +
                (eloConfig == null ? "null" : eloConfig.ToString()) + ", " +
                bReportOnly+ ")");

            if (iStatsDatabase < 0 || iStatsDatabase >= NumStatsDatabases)
            {
                string sErr = "Xbox.Tools.Framework.CStats.UnitLBConfigSet: iStatsDatabase " 
                    + "must be between zero and n-1 where n = the number of elements " 
                    + "in rgsStatsDBConnectionStrings passed to the constructor";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("iStatsDatabase", sErr);
            }

            // eloConfig is allowed to be null
            if (eloConfig != null && !eloConfig.IsValid())
            {
                string sErr = "Xbox.Tools.Framework.CStats.UnitLBConfigSet: "
                    + "The ELO config provided is not valid";
                throw new ArgumentException(sErr, "eloConfig");
            }

            // we don't check to make sure they've specified the right
            // server - we rely on the stored proc for that to avoid
            // a round trip. We also rely on the stored proc to tell us
            // if we try to change the IsTeam status of this leaderboard

            SqlCommand sqlCommand = m_rgSqlConnections[iStatsDatabase].CreateCommand();
            sqlCommand.CommandText = "p_Units_ConfigureLeaderboard";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_titleId", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("@i_unitLbId", SqlDbType.Int).Value = (int)uiLBNum;
            sqlCommand.Parameters.Add("@ti_ReqArbitration", SqlDbType.TinyInt).Value = (byte)(bArbitrationRequired == false ? 0 : 1);
            sqlCommand.Parameters.Add("@vc_params", SqlDbType.VarChar,256).Value = (eloConfig == null? "" : eloConfig.ToStatsDBString());
            sqlCommand.Parameters.Add("@ti_IsTeam", SqlDbType.TinyInt).Value = (byte)(bIsTeam == false ? 0 : 1);
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.DataMod(
                "Xbox.Tools.Framework.CStats.UnitLBConfigSet: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            if (!bReportOnly)
            {
                try
                {
                    sqlCommand.ExecuteNonQuery();
                    int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                    if (iRet != 0)
                    {
                        string sErr;
                        if (iRet == 1)
                        {
                            // this is the error code returned if the title hasn't been configued
                            sErr = "Xbox.Tools.Framework.CStats.UnitLBConfigSet: "
                                + "TitleId "
                                + tid.sTitleIdHex
                                + " has not been configured for units on this database.";
                        }
                        else if (iRet == 2)
                        {
                            // this is the error code returned when we tried to change ti_IsTeam
                            sErr = "Xbox.Tools.Framework.CStats.UnitLBConfigSet: "
                                + "Unable to update leaderboard definition. Cannot change team status "
                                + "of an existing leaderboard.";
                        }
                        else
                        {
                            // not sure what happened
                            sErr = "Xbox.Tools.Framework.CStats.UnitLBConfigSet: "
                                + "The stored procedure "
                                + sqlCommand.CommandText
                                + " returned " 
                                + iRet;
                        }
                        m_log.LogFile(sErr);
                        throw new CStatsException(sErr);
                    }
                }
                catch (SqlException sqlException)
                {
                    string sErr = "Xbox.Tools.Framework.CStats.UnitLBConfigSet: "
                        + "Calling the stored procedure "
                        + sqlCommand.CommandText
                        + " caused a SqlException. Exception details: "
                        + sqlException.Message;
                    m_log.LogFile(sErr);
                    throw new CStatsException(sErr, sqlException);
                }
            }
            m_log.StackTrace("Xbox.Tools.Framework.CStats.UnitLBConfigSet complete");
        }

        public bool UnitLBConfigGet(
            CTitleId tid,
            int iStatsDatabase,
            uint uiLBNum, 
            out bool bRequireArbitration,
            out bool bIsTeamLB,
            out CELOConfig eloConfig)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.LBConfigGet(" +
                tid.ToString()+ ", " +
                iStatsDatabase + ", " +
                uiLBNum);

            if (iStatsDatabase < 0 || iStatsDatabase >= NumStatsDatabases)
            {
                string sErr = "Xbox.Tools.Framework.CStats.UnitLBConfigGet: iStatsDatabase " 
                    + "must be between zero and n-1 where n = the number of elements " 
                    + "in rgsStatsDBConnectionStrings passed to the constructor";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("iStatsDatabase", sErr);
            }

            // set default values, in case we find no rows
            bRequireArbitration = false;
            bIsTeamLB = false;
            eloConfig = null;

            // we haven't found anything yet!
            bool bFound = false;

            SqlCommand sqlCommand = m_rgSqlConnections[iStatsDatabase].CreateCommand();
            sqlCommand.CommandText = "p_Units_GetLeaderboardConfig";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_titleId", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("@i_unitLbId", SqlDbType.Int).Value = (int)uiLBNum;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.FullTrace(
                "Xbox.Tools.Framework.CStats.UnitLBConfigGet: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            SqlDataReader sqlDataReader = null;
            try
            {
                // run the command!
                sqlDataReader = sqlCommand.ExecuteReader();

                // get the results
                int iRowsRead = 0;
                while (sqlDataReader.Read())
                {
                    m_log.FullTrace(
                        "Xbox.Tools.Framework.CStats.UnitLBConfigGet: "
                        + "found leaderboard "
                        + uiLBNum);

                    ++iRowsRead;
                    if (iRowsRead > 1)
                    {
                        string sErr = "Xbox.Tools.Framework.CStats.UnitLBConfigGet: "
                            + " more than one row was returned by the stored proc " 
                            + sqlCommand.CommandText;
                        m_log.LogFile(sErr);
                        throw new CStatsException(sErr);
                    }

                    // save the results in the out parameters

                    // from the table definition:
                    // i_titleId           int not null,
                    // i_unitLbId          int not null,
                    // vc_params           varchar(256) not null,
                    // ti_IsTeam           tinyint not null,
                    // ti_ReqArbitration   tinyint      not null

                    bRequireArbitration = ((byte)sqlDataReader["ti_ReqArbitration"] == 0 ? false : true);
                    bIsTeamLB = ((byte)sqlDataReader["ti_IsTeam"] == 0 ? false : true);
                    string sEloConfig = (string)sqlDataReader["vc_params"];
                    if (sEloConfig == String.Empty)
                    {
                        eloConfig = null;
                    }
                    else
                    {
                        try
                        {
                            eloConfig = CELOConfig.Parse(sEloConfig);
                        }
                        catch (FormatException formatException)
                        {
                            string sErr = "Xbox.Tools.Framework.CStats.UnitLBConfigGet: "
                                + " Could not parse ELO string for leaderboard " 
                                + uiLBNum
                                + ": "
                                + sEloConfig;
                            m_log.LogFile(sErr);
                            throw new CStatsException(sErr, formatException);
                        }
                        if (eloConfig.IsValid())
                        {
                            string sWarning = "Xbox.Tools.Framework.CStats.UnitLBConfigGet: "
                                + " ELO string for leaderboard " 
                                + uiLBNum
                                + " is not valid: "
                                + sEloConfig;
                            m_log.LogFile(sWarning);
                            // note, don't throw just log. Otherwise how will we fix it?
                        }
                    }
                }

                // close the sqlDataReader, so we can get the return code
                sqlDataReader.Close();

                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    string sErr;
                    if (iRet == 1)
                    {
                        // this is the error code returned if the title hasn't been configued
                        // we should simply return false in this case, but we may as
                        // well write a line to the log
                        sErr = "Xbox.Tools.Framework.CStats.UnitLBConfigGet: "
                            + "Title has not been configured for units on this database.";
                        m_log.LogFile(sErr);
                        iRowsRead = 0;
                        // drop through and return false
                    }
                    else
                    {
                        // not sure what happened
                        sErr = "Xbox.Tools.Framework.CStats.UnitLBConfigGet: "
                            + "The stored procedure "
                            + sqlCommand.CommandText
                            + " returned " 
                            + iRet;
                        m_log.LogFile(sErr);
                        throw new CStatsException(sErr);
                    }
                }

                // if we found exactly one row, then we want to return true
                if (iRowsRead == 1)
                {
                    bFound = true;
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "Xbox.Tools.Framework.CStats.UnitLBConfigGet: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;
                m_log.LogFile(sErr);
                throw new CStatsException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }

            m_log.StackTrace("Xbox.Tools.Framework.CStats.UnitLBConfigGet complete, returning:" + bFound);
            return bFound;
        }

        public SortedList CompTitleGetDatabaseMap()
        {
            m_log.StackTrace("Xbox.Tools.Framework.CStats.CompTitleGetDatabaseMap()");

            SortedList sortedList   = new SortedList();

            // iterate through every server we know about and look for competition partitions
            for (int i = 0; i < NumStatsDatabases; ++i)
            {
                SqlCommand sqlCommand = m_rgSqlConnections[i].CreateCommand();
                sqlCommand.CommandText = "p_Stats_QueryCompetitionTitles";
                sqlCommand.CommandType = CommandType.StoredProcedure;
                sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

                m_log.FullTrace(
                    "Xbox.Tools.Framework.CStats.CompTitleGetDatabaseMap: SqlCommand:"
                    + CLog.SqlCommandToString(sqlCommand));

                SqlDataReader sqlDataReader = null;
                try
                {
                    sqlDataReader = sqlCommand.ExecuteReader();
                    while (sqlDataReader.Read())
                    {
                        uint uiTitleId = (uint)(int)sqlDataReader["i_titleId"];

                        if (sortedList[uiTitleId] == null)
                        {
                            // we don't yet have an entry for this title id
                            // so allocate one
                            bool[] rgbMap = new bool[NumStatsDatabases];
                            for (int j = 0; j < NumStatsDatabases; ++j)
                            {
                                rgbMap[j] = false;
                            }
                            sortedList[uiTitleId] = rgbMap;
                        }

                        // we found partition uiPartition on server i, so set the flag
                        ((bool[])sortedList[uiTitleId])[i] = true;
                    }

                    // close the sqlDataReader so we can check the return code
                    sqlDataReader.Close();

                    int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                    if (iRet != 0)
                    {
                        // for some reason, we were not able to get the title configuration
                        // note that not finding the configuration should not cause this error,
                        // it should just return zero rows
                        string sErr = "Xbox.Tools.Framework.CStats.CompTitleGetDatabaseMap: "
                            + "The stored procedure "
                            + sqlCommand.CommandText
                            + " returned " 
                            + iRet;
                        m_log.LogFile(sErr);
                        throw new CStatsException(sErr);
                    }

                }
                catch (SqlException sqlException)
                {
                    string sErr = "Xbox.Tools.Framework.CStats.CompTitleGetDatabaseMap: "
                        + "Calling the stored procedure "
                        + sqlCommand.CommandText
                        + " caused a SqlException. Exception details: "
                        + sqlException.Message;
                    m_log.LogFile(sErr);
                    throw new CStatsException(sErr);
                }
                finally
                {
                    // clean up the sqlDataReader if we need to
                    if (sqlDataReader != null && !sqlDataReader.IsClosed)
                    {
                        sqlDataReader.Close();
                    }
                }
            }
            m_log.StackTrace("Xbox.Tools.Framework.CStats.CompTitleGetDatabaseMap complete");
            return sortedList;
        }


        public SortedList CompPartitionGetDatabaseMap(
            CTitleId tid)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CStats.CompPartitionGetDatabaseMap("+
                tid.ToString()+ ", ");

            SortedList sortedListPartitionMap  = new SortedList();

            // iterate through every server we know about and look for competition partitions
            for (int i = 0; i < NumStatsDatabases; ++i)
            {
                SqlCommand sqlCommand = m_rgSqlConnections[i].CreateCommand();
                sqlCommand.CommandText = "p_Stats_QueryCompetitionPartitions";
                sqlCommand.CommandType = CommandType.StoredProcedure;
                sqlCommand.Parameters.Add("@i_titleId", SqlDbType.Int).Value = (int)tid.uiTitleId;
                sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

                m_log.FullTrace(
                    "Xbox.Tools.Framework.CStats.CompPartitionGetDatabaseMap: SqlCommand:"
                    + CLog.SqlCommandToString(sqlCommand));

                SqlDataReader sqlDataReader = null;
                try
                {
                    sqlDataReader = sqlCommand.ExecuteReader();
                    while (sqlDataReader.Read())
                    {
                        uint uiPartition = (uint)(byte)sqlDataReader["ti_partition"];

                        if (sortedListPartitionMap[uiPartition] == null)
                        {
                            // we don't yet have an entry for this partition id
                            // so allocate one
                            bool[] rgbMap = new bool[NumStatsDatabases];
                            for (int j = 0; j < NumStatsDatabases; ++j)
                            {
                                rgbMap[j] = false;
                            }
                            sortedListPartitionMap[uiPartition] = rgbMap;
                        }

                        // we found partition uiPartition on server i, so set the flag
                        ((bool[])sortedListPartitionMap[uiPartition])[i] = true;
                    }

                    // close the sqlDataReader so we can check the return code
                    sqlDataReader.Close();

                    int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                    if (iRet != 0)
                    {
                        // for some reason, we were not able to get the title configuration
                        // note that not finding the configuration should not cause this error,
                        // it should just return zero rows
                        string sErr = "Xbox.Tools.Framework.CStats.CompPartitionGetDatabaseMap: "
                            + "The stored procedure "
                            + sqlCommand.CommandText
                            + " returned " 
                            + iRet;
                        m_log.LogFile(sErr);
                        throw new CStatsException(sErr);
                    }

                }
                catch (SqlException sqlException)
                {
                    string sErr = "Xbox.Tools.Framework.CStats.CompPartitionGetDatabaseMap: "
                        + "Calling the stored procedure "
                        + sqlCommand.CommandText
                        + " caused a SqlException. Exception details: "
                        + sqlException.Message;
                    m_log.LogFile(sErr);
                    throw new CStatsException(sErr);
                }
                finally
                {
                    // clean up the sqlDataReader if we need to
                    if (sqlDataReader != null && !sqlDataReader.IsClosed)
                    {
                        sqlDataReader.Close();
                    }
                }
            }
            m_log.StackTrace("Xbox.Tools.Framework.CStats.CompPartitionGetDatabaseMap complete");
            return sortedListPartitionMap;
        }

        // note: once created, a partition cannot be removed. If removed, the front doors
        // don't know where to look for leaderboards in that partition. Therefore, I'm 
        // not writing a CompeitionPartitionDelete API at thie time, because if we ever
        // have to do it, it'll be a huge undertaking and this one call won't be enough.

        public void CompPartitionCreate(
            CTitleId tid,
            int iStatsDatabase,
            uint uiPartition,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.CompPartitionCreate(" +
                tid.ToString()+ ", " +
                iStatsDatabase + ", " +
                uiPartition+ ", " +
                bReportOnly+ ")");

            if (iStatsDatabase < 0 || iStatsDatabase >= NumStatsDatabases)
            {
                string sErr = "Xbox.Tools.Framework.CStats.CompPartitionCreate: "
                    + "iStatsDatabase must be between zero and n-1 where n = the number of elements " 
                    + "in rgsStatsDBConnectionStrings passed to the constructor";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("iStatsDatabase", sErr);
            }

            if (uiPartition > 3)
            {
                string sErr = "Xbox.Tools.Framework.CStats.CompPartitionCreate: "
                    + "uiPartition must be between 0 and 3";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("uiPartition", sErr);
            }

            // let's be careful, and make sure that this partition isn't already
            // defined somewhere...
            SortedList sortedListPartitionMap = CompPartitionGetDatabaseMap(tid);

            bool[] rgbMap = (bool[])sortedListPartitionMap[uiPartition];
            if (rgbMap != null)
            {
                // the partition is already defined somewhere.
                // is it in the place the caller wants it to be?
                if (rgbMap[iStatsDatabase] == true)
                {
                    // the partition is already defined, just there is nothing
                    // to do, simply return.
                    m_log.FullTrace(
                        "Xbox.Tools.Framework.CStats.CompPartitionCreate: " 
                        + "Partition "
                        + uiPartition
                        + " is already defined in database "
                        + iStatsDatabase
                        + ". No partition update required.");
                    m_log.StackTrace("Xbox.Tools.Framework.CStats.CompPartitionCreate complete");
                    return;
                }
                else
                {
                    // the partition is already defined somewhere, but not where
                    // the caller wants it. This is a problem
                    string sErr = "Xbox.Tools.Framework.CStats.CompPartitionCreate: "
                        + "Partition "
                        + uiPartition
                        + " is already defined on a different server than "
                        + iStatsDatabase;
                    m_log.LogFile(sErr);
                    throw new CStatsException(sErr);
                }
            }

            m_log.FullTrace(
                "Xbox.Tools.Framework.CStats.CompPartitionCreate: " 
                + "Adding competition partition "
                + uiPartition
                + " to database "
                + iStatsDatabase);

            SqlCommand sqlCommand = m_rgSqlConnections[iStatsDatabase].CreateCommand();
            sqlCommand.CommandText = "p_Stats_CreateCompetitionPartition";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_titleId", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("@ti_partition", SqlDbType.TinyInt).Value = (int)uiPartition;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.DataMod(
                "Xbox.Tools.Framework.CStats.CompPartitionCreate: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            if (!bReportOnly)
            {
                ExecuteNonQuery(sqlCommand, "Xbox.Tools.Framework.SetCompPartition");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CStats.CompPartitionCreate complete");     
        }

        public SortedList CompTemplateGetDatabaseMap(
            CTitleId tid)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace("Xbox.Tools.Framework.CStats.CompTemplateGetDatabaseMap("+
                tid.ToString()+ ", ");

            // each element of the sorted list is an array of bools, indexed by
            // server index. Example, if leaderboard 1 is found on server index 3, then 
            // ((bool[])sortedList[1])[3] == true
            // It's allowed to have the same competition template on multiple servers,
            // but they are supposed to match exactly.

            SortedList sortedList  = new SortedList();

            // iterate through every server we know about and look for competition templates
            for (int i = 0; i < NumStatsDatabases; ++i)
            {
                SqlCommand sqlCommand = m_rgSqlConnections[i].CreateCommand();
                sqlCommand.CommandText = "p_Stats_QueryCompetitionTemplates";
                sqlCommand.CommandType = CommandType.StoredProcedure;
                sqlCommand.Parameters.Add("@i_titleId", SqlDbType.Int).Value = (int)tid.uiTitleId;
                sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

                m_log.FullTrace(
                    "Xbox.Tools.Framework.CStats.CompTemplateGetDatabaseMap: SqlCommand:"
                    + CLog.SqlCommandToString(sqlCommand));

                SqlDataReader sqlDataReader = null;
                try
                {
                    sqlDataReader = sqlCommand.ExecuteReader();
                    while (sqlDataReader.Read())
                    {
                        uint uiTemplateId = (uint)(int)sqlDataReader["i_templateId"];

                        m_log.FullTrace("Xbox.Tools.Framework.CStats.CompTemplateGetDatabaseMap: "
                            + "Found competition template "
                            + uiTemplateId
                            + " on server "
                            + i);

                        if (sortedList[uiTemplateId] == null)
                        {
                            // we don't yet have an entry for this template id
                            // so allocate one
                            bool[] rgbMap = new bool[NumStatsDatabases];
                            for (int j = 0; j < NumStatsDatabases; ++j)
                            {
                                rgbMap[j] = false;
                            }
                            sortedList[uiTemplateId] = rgbMap;
                        }

                        // we found competition template uiTemplateId on server i, so set the flag
                        ((bool[])sortedList[uiTemplateId])[i] = true;
                    }

                    // close the sqlDataReader so we can check the return code
                    sqlDataReader.Close();

                    int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                    if (iRet != 0)
                    {
                        // for some reason, we were not able to get the title configuration
                        // note that not finding the configuration should not cause this error,
                        // it should just return zero rows
                        string sErr = "Xbox.Tools.Framework.CStats.CompTemplateGetDatabaseMap: "
                            + "The stored procedure "
                            + sqlCommand.CommandText
                            + " returned " 
                            + iRet;
                        m_log.LogFile(sErr);
                        throw new CStatsException(sErr);
                    }
                }
                catch (SqlException sqlException)
                {
                    string sErr = "Xbox.Tools.Framework.CStats.CompTemplateGetDatabaseMap: "
                        + "Calling the stored procedure "
                        + sqlCommand.CommandText
                        + " or reading the results caused a SqlException. Exception details: "
                        + sqlException.Message;
                    m_log.LogFile(sErr);
                    throw new CStatsException(sErr, sqlException);
                }
                finally
                {
                    // clean up the sqlDataReader if we need to
                    if (sqlDataReader != null && !sqlDataReader.IsClosed)
                    {
                        sqlDataReader.Close();
                    }
                }
            }
            m_log.StackTrace("Xbox.Tools.Framework.CStats.CompTemplateGetDatabaseMap complete");
            return sortedList;
        }

        public void CompTemplateConfigSet(
            CTitleId tid,
            uint uiTemplateId,
            ELBReset riLBResetInterval,
            uint uiAttachmentCount,
            uint uiMaxAttachmentSize,
            uint uiDecayDays,
            bool bArbitrationRequired,
            bool bIsTeam,
            CELOConfig eloConfig,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.CompTemplateConfigSet(" +
                tid.ToString()+ ", " +
                uiTemplateId + ", " +
                uiDecayDays+ ", " +
                bIsTeam + ", " +
                (eloConfig == null ? "null" : eloConfig.ToString())+ ", " +
                bReportOnly+ ")");

            if (uiTemplateId > 15)
            {
                string sErr = "Xbox.Tools.Framework.CStats.CompTemplateConfigSet: "
                    + "template ID must be between 0 and 15 inclusive";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("uiTemplateId", sErr);
            }

            if (bArbitrationRequired == true)
            {
                string sErr = "Xbox.Tools.Framework.CStats.CompTemplateConfigSet: "
                    + "Comp templates that require Arbitration cannot have Attachments.";
                if (uiAttachmentCount != 0)
                {
                    m_log.LogFile(sErr);
                    throw new ArgumentException(sErr,"uiAttachmentCount");
                }
                else if (uiMaxAttachmentSize != 0)
                {
                    m_log.LogFile(sErr);
                    throw new ArgumentException(sErr,"uiMaxAttachmentSize");
                }
            }

            // eloConfig is allowed to be null
            if (eloConfig != null && !eloConfig.IsValid())
            {
                string sErr = "Xbox.Tools.Framework.CStats.CompTemplateConfigSet: "
                    + "The ELO config provided is not valid";
                throw new ArgumentException(sErr, "eloConfig");
            }

            // there's no reason to not put competition templates on every server
            // we know about, in case at some future time you create a competition template
            // on that new server. This method is a shortcut that allows you to put a 
            // template on every known database server in one call
            for (int i = 0; i < NumStatsDatabases; ++i)
            {
                CompTemplateConfigSet(
                    tid,
                    i,
                    uiTemplateId,
                    riLBResetInterval,
                    uiAttachmentCount,
                    uiMaxAttachmentSize,
                    uiDecayDays,
                    bArbitrationRequired,
                    bIsTeam,
                    eloConfig,
                    bReportOnly);
            }

            m_log.StackTrace("Xbox.Tools.Framework.CStats.CompTemplateConfigSet complete");
        }

        public void CompTemplateConfigSet(
            CTitleId tid,
            int iStatsDatabase,
            uint uiTemplateId,
            ELBReset riLBResetInterval,
            uint uiAttachmentCount,
            uint uiMaxAttachmentSize,
            uint uiDecayDays,
            bool bArbitrationRequired,
            bool bIsTeam,
            CELOConfig eloConfig,
            bool bReportOnly)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.CompTemplateConfigSet(" +
                tid.ToString()+ ", " +
                iStatsDatabase + ", " +
                uiTemplateId + ", " +
                uiDecayDays+ ", " +
                bIsTeam + ", " +
                (eloConfig == null ? "null" : eloConfig.ToString())+ ", " +
                bReportOnly+ ")");

            if (iStatsDatabase < 0 || iStatsDatabase >= NumStatsDatabases)
            {
                string sErr = "Xbox.Tools.Framework.CStats.CompTemplateConfigSet: iStatsDatabase " 
                    + "must be between zero and n-1 where n = the number of elements " 
                    + "in rgsStatsDBConnectionStrings passed to the constructor";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("iStatsDatabase", sErr);
            }

            if (uiTemplateId > 15)
            {
                string sErr = "Xbox.Tools.Framework.CStats.CompTemplateConfigSet: "
                    + "template ID must be between 0 and 15 inclusive";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("uiTemplateId", sErr);
            }

            if (bArbitrationRequired == true)
            {
                string sErr = "Xbox.Tools.Framework.CStats.CompTemplateConfigSet: "
                    + "Comp templates that require Arbitration cannot have Attachments.";
                if (uiAttachmentCount != 0)
                {
                    m_log.LogFile(sErr);
                    throw new ArgumentException(sErr,"uiAttachmentCount");
                }
                else if (uiMaxAttachmentSize != 0)
                {
                    m_log.LogFile(sErr);
                    throw new ArgumentException(sErr,"uiMaxAttachmentSize");
                }
            }

            // eloConfig is allowed to be null
            if (eloConfig != null && !eloConfig.IsValid())
            {
                string sErr = "Xbox.Tools.Framework.CStats.CompTemplateConfigSet: "
                    + "The ELO config provided is not valid";
                throw new ArgumentException(sErr, "eloConfig");
            }

            // a competition template is a template for leaderboards that are 
            // created at a later time. The front doors choose the server to
            // create competition templates on according to how the competition
            // partitions are configured. Thus there is no harm to having the
            // same competition template on multiple servers. Therefore we 
            // don't check for that condition here. 
            //
            // Note however that changing a competition template after it has been 
            // inserted is not allowed. So if the competition template already
            // exists, and the parameters provided do not match exactly,
            // the stored proc call will fail. Which makes it kind of pointless
            // to make the call in the first place, but it would take us a
            // round trip to check for the failure case anyway, so we might
            // as well just make the call and throw if it fails.

            SqlCommand sqlCommand = m_rgSqlConnections[iStatsDatabase].CreateCommand();
            sqlCommand.CommandText = "p_Stats_CreateCompetitionTemplate";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("@i_templateId", SqlDbType.Int).Value = (int)uiTemplateId;
            sqlCommand.Parameters.Add("@ti_reset_type", SqlDbType.TinyInt).Value = (byte)riLBResetInterval;
            sqlCommand.Parameters.Add("@i_att_count", SqlDbType.Int).Value = (int)uiAttachmentCount;
            sqlCommand.Parameters.Add("@i_max_att_size", SqlDbType.Int).Value = (int)uiMaxAttachmentSize;
            sqlCommand.Parameters.Add("@i_decay_days", SqlDbType.Int).Value = (int)uiDecayDays;
            sqlCommand.Parameters.Add("@vc_params", SqlDbType.VarChar,256).Value = (eloConfig == null ? "" : eloConfig.ToStatsDBString()); 
            sqlCommand.Parameters.Add("@ti_IsTeam", SqlDbType.TinyInt).Value = (byte)(bIsTeam == false ? 0 : 1);   
            sqlCommand.Parameters.Add("@ti_ReqArbitration", SqlDbType.TinyInt).Value = (byte)(bArbitrationRequired == false ? 0 : 1);
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.DataMod(
                "Xbox.Tools.Framework.CStats.CompTemplateConfigSet: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            if (!bReportOnly)
            {
                try
                {
                    sqlCommand.ExecuteNonQuery();
                    int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                    if (iRet != 0)
                    {
                        string sErr;
                        if (iRet == -2)
                        {
                            // this is the error code returned when the template exists and we did
                            // not match the definition exactly
                            sErr = "Xbox.Tools.Framework.CStats.CompTemplateConfigSet: "
                                + "Changing competition templates is not supported. The parameters "
                                + "provided do not match the existing template.";
                        }
                        else
                        {
                            // not sure what happened
                            sErr = "Xbox.Tools.Framework.CStats.LBConfigSet: The stored procedure "
                                + sqlCommand.CommandText
                                + " returned " 
                                + iRet;
                        }
                        m_log.LogFile(sErr);
                        throw new CStatsException(sErr);
                    }
                }
                catch (SqlException sqlException)
                {
                    string sErr = "Xbox.Tools.Framework.CStats.CompTemplateConfigSet: "
                        + "Calling the stored procedure "
                        + sqlCommand.CommandText
                        + " caused a SqlException. Exception details: "
                        + sqlException.Message;
                    m_log.LogFile(sErr);
                    throw new CStatsException(sErr, sqlException);
                }
            }
            m_log.StackTrace("Xbox.Tools.Framework.CStats.CompTemplateConfigSet complete");
        }

        public bool CompTemplateConfigGet(
            CTitleId tid,
            int iStatsDatabase,
            uint uiTemplateId, 
            out ELBReset leaderboardResetInterval,
            out uint uiAttachmentCount,
            out uint uiMaxAttachmentSize,
            out uint uiDecayDays,
            out bool bRequireArbitration,
            out bool bIsTeamLB,
            out CELOConfig eloConfig)
        {
            if (tid == null)
            {
                throw new ArgumentNullException("tid");
            }

            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.CompTemplateConfigGet(" 
                + tid.ToString()+ ", "
                + iStatsDatabase + ", " 
                + uiTemplateId + ")");

            if (iStatsDatabase < 0 || iStatsDatabase >= NumStatsDatabases)
            {
                string sErr = "Xbox.Tools.Framework.CStats.CompTemplateConfigGet: iStatsDatabase " 
                    + "must be between zero and n-1 where n = the number of elements " 
                    + "in rgsStatsDBConnectionStrings passed to the constructor";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("iStatsDatabase", sErr);
            }

            if (uiTemplateId > 15)
            {
                string sErr = "Xbox.Tools.Framework.CStats.CompTemplateConfigGet: "
                    + "template ID must be between 0 and 15 inclusive";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("uiTemplateId", sErr);
            }

            // set default values, in case we find no rows
            leaderboardResetInterval = ELBReset.ResetNever;
            uiAttachmentCount = 0;
            uiMaxAttachmentSize = 0;
            uiDecayDays = 0;
            bRequireArbitration = false;
            bIsTeamLB = false;
            eloConfig = null;

            // we haven't found anything yet!
            bool bFound = false;

            SqlCommand sqlCommand = m_rgSqlConnections[iStatsDatabase].CreateCommand();
            sqlCommand.CommandText = "p_Stats_GetCompetitionTemplate";
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.Parameters.Add("@i_titleId", SqlDbType.Int).Value = (int)tid.uiTitleId;
            sqlCommand.Parameters.Add("@i_templateId", SqlDbType.Int).Value = (int)uiTemplateId;
            sqlCommand.Parameters.Add("RETURN_VALUE", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;

            m_log.FullTrace(
                "Xbox.Tools.Framework.CStats.CompTemplateConfigGet: SqlCommand:" +
                CLog.SqlCommandToString(sqlCommand));

            SqlDataReader sqlDataReader = null;
            try
            {
                // run the command!
                sqlDataReader = sqlCommand.ExecuteReader();

                // get the results
                int iRowsRead = 0;
                while (sqlDataReader.Read())
                {
                    m_log.FullTrace(
                        "Xbox.Tools.Framework.CStats.CompTemplateConfigGet: "
                        + "found competition template "
                        + uiTemplateId);

                    ++iRowsRead;
                    if (iRowsRead > 1)
                    {
                        string sErr = "Xbox.Tools.Framework.CStats.CompTemplateConfigGet: "
                            + " more than one row was returned by the stored proc " 
                            + sqlCommand.CommandText;
                        m_log.LogFile(sErr);
                        throw new CStatsException(sErr);
                    }

                    // save the results in the out parameters

                    // from the table definition:
                    // i_titleId               int          not null,
                    // i_templateId            int          not null,
                    // ti_reset_type           tinyint      not null,
                    // i_att_count             int          not null,
                    // i_max_att_size          int          not null,
                    // i_decay_days            int          not null,
                    // i_max_rating_count      int          not null,
                    // vc_params               varchar(256) not null,
                    // ti_IsTeam               tinyint      not null,
                    // ti_ReqArbitration       tinyint      not null

                    leaderboardResetInterval = (ELBReset)(byte)sqlDataReader["ti_reset_type"];
                    uiAttachmentCount = (uint)(int)sqlDataReader["i_att_count"];
                    uiMaxAttachmentSize = (uint)(int)sqlDataReader["i_max_att_size"];
                    uiDecayDays = (uint)(int)sqlDataReader["i_decay_days"];
                    bRequireArbitration = ((byte)sqlDataReader["ti_ReqArbitration"] == 0 ? false : true);
                    bIsTeamLB = ((byte)sqlDataReader["ti_IsTeam"] == 0 ? false : true);
                    string sEloConfig = (string)sqlDataReader["vc_params"];
                    if (sEloConfig == String.Empty)
                    {
                        eloConfig = null;
                    }
                    else
                    {
                        try
                        {
                            eloConfig = CELOConfig.Parse(sEloConfig);
                        }
                        catch (FormatException formatException)
                        {
                            string sErr = "Xbox.Tools.Framework.CStats.CompTemplateConfigGet: "
                                + " Could not parse ELO string for competition template " 
                                + uiTemplateId
                                + ": "
                                + sEloConfig;
                            m_log.LogFile(sErr);
                            throw new CStatsException(sErr, formatException);
                        }
                        if (eloConfig.IsValid())
                        {
                            string sWarning = "Xbox.Tools.Framework.CStats.CompTemplateConfigGet: "
                                + " ELO string for competition template " 
                                + uiTemplateId
                                + " is not valid: "
                                + sEloConfig;
                            m_log.LogFile(sWarning);
                        }
                    }
                }

                // close the sqlDataReader so we can get the return code
                sqlDataReader.Close();

                int iRet = (int)sqlCommand.Parameters["RETURN_VALUE"].Value;
                if (iRet != 0)
                {
                    // for some reason, we were not able to get the competition template definition
                    // note that not finding the leaderboard should not cause this error,
                    // it should just return zero rows
                    string sErr = "Xbox.Tools.Framework.CStats.CompTemplateConfigGet: The stored procedure "
                        + sqlCommand.CommandText
                        + " returned " 
                        + iRet;
                    m_log.LogFile(sErr);
                    throw new CStatsException(sErr);
                }

                // if we found exactly one row, then we want to return true
                if (iRowsRead == 1)
                {
                    bFound = true;
                }
            }
            catch (SqlException sqlException)
            {
                string sErr = "Xbox.Tools.Framework.CStats.CompTemplateConfigGet: "
                    + "Calling the stored procedure "
                    + sqlCommand.CommandText
                    + " or reading the results caused a SqlException. Exception details: "
                    + sqlException.Message;
                m_log.LogFile(sErr);
                throw new CStatsException(sErr, sqlException);
            }
            finally
            {
                // clean up the sqlDataReader if we need to
                if (sqlDataReader != null && !sqlDataReader.IsClosed)
                {
                    sqlDataReader.Close();
                }
            }

            m_log.StackTrace("Xbox.Tools.Framework.CStats.CompTemplateConfigGet complete, returning:" + bFound);
            return bFound;
        }

        public bool FrontDoorReloadAll(
            int iTimeoutMilliseconds,
            bool bReportOnly)
        {
            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.FrontDoorReload(" +
                iTimeoutMilliseconds + ", " +
                bReportOnly + ")");

            // I don't want consider the degernate case of zero front
            // doors to be success, which the logic below would produce,
            // therefore I check for this explicitly
            if (NumFrontDoors == 0)
            {
                m_log.StackTrace("Xbox.Tools.Framework.CStats.FrontDoorReloadAll:"
                    + "No front doors to reload, returning false");
                return false;
            }

            bool bSuccess = true;
            for (int i = 0; i < NumFrontDoors; ++i)
            {
                if (!FrontDoorReload(i, iTimeoutMilliseconds, bReportOnly))
                {
                    // one front door failed to reload, so we'll return failure
                    bSuccess = false;
                }
            }

            m_log.StackTrace("Xbox.Tools.Framework.CStats.CompTemplateConfigGet complete, returning:" 
                + bSuccess);
            return bSuccess;
        }

        public bool FrontDoorReload(
            int iStatsFrontDoor,
            int iTimeoutMilliseconds,
            bool bReportOnly)
        {
            m_log.StackTrace(
                "Xbox.Tools.Framework.CStats.FrontDoorReload(" +
                iStatsFrontDoor + ", " +
                iTimeoutMilliseconds + ", " +
                bReportOnly + ")");

            if (iStatsFrontDoor < 0 || iStatsFrontDoor >= NumFrontDoors)
            {
                string sErr = "Xbox.Tools.Framework.CStats.FrontDoorReload: iStatsFrontDoor " 
                    + "must be between zero and n-1 where n = the number of elements " 
                    + "in rgsStatsDBConnectionStrings passed to the constructor";
                m_log.LogFile(sErr);
                throw new ArgumentOutOfRangeException("iStatsFrontDoor", sErr);
            }

            // try each IPAddress we have for the server until one works
            CServer server = m_rgStatsFDServers[iStatsFrontDoor];
            foreach (IPAddress ipAddress in server.rgipAddresses)
            {
                if (SendReloadUrl(ipAddress, iTimeoutMilliseconds))
                {
                    m_log.FullTrace("Xbox.Tools.Framework.CStats.FrontDoorReload"
                        + "Reload operation successful on server "
                        + iStatsFrontDoor);
                    m_log.StackTrace("Xbox.Tools.Framework.CStats.FrontDoorReload complete, returning true");
                    return true;
                }
            }

            // if we get here, we were not able to sucessfully send the url to the server
            m_log.LogFile("Xbox.Tools.Framework.CStats.FrontDoorReload"
                + "Reload operation not successful on server "
                + iStatsFrontDoor);
            m_log.StackTrace("Xbox.Tools.Framework.CStats.FrontDoorReload complete, returning false");
            return true;
        }

        private bool SendReloadUrl(IPAddress ipAddress, int iTimeoutMilliseconds)
        {
            string sHttpRequest = "http://" + ipAddress.ToString() + "/xstats/xstatsreloaddbmap.ashx";
            m_log.DataMod(
                "Xbox.Tools.Framework.CStats.FrontDoorReload: "
                + "Sending: " 
                + sHttpRequest);

            HttpWebRequest httpWebRequest = 
                (HttpWebRequest)WebRequest.Create(sHttpRequest);

            // Turn off connection keep-alives.
            httpWebRequest.KeepAlive = false;

            // set the requested timeout
            httpWebRequest.Timeout = iTimeoutMilliseconds;

            HttpWebResponse httpWebResponse = null;
            try
            {
                httpWebResponse = (HttpWebResponse)httpWebRequest.GetResponse();
                string sResponse;
                try
                {
                    Stream stream = httpWebResponse.GetResponseStream();
                    StreamReader streamReader = new StreamReader(stream);
                    sResponse = streamReader.ReadToEnd();
                }
                catch (ProtocolViolationException)
                {
                    // no content to be had
                    sResponse = String.Empty;
                }

                if (httpWebResponse.StatusCode == HttpStatusCode.OK)
                {
                    m_log.FullTrace("Xbox.Tools.Framework.CStats.FrontDoorReload: "
                        + sHttpRequest 
                        + " reports OK");
                    return true;
                }
                else
                {
                    m_log.WriteLine("Xbox.Tools.Framework.CStats.FrontDoorReload: "
                        + "Error: " 
                        + sHttpRequest 
                        + " reports " 
                        + httpWebResponse.StatusCode.ToString());
                    return false;
                }
            }
            catch (WebException webException)
            {
                if (webException.Status == WebExceptionStatus.Timeout)
                {
                    m_log.LogFile("Xbox.Tools.Framework.CStats.FrontDoorReload: "
                        + "Error: " 
                        + sHttpRequest 
                        + " timed out");
                    return false;
                }
                m_log.LogFile("Xbox.Tools.Framework.CStats.FrontDoorReload: "
                    + "Error: exception sending " 
                    + sHttpRequest);
                m_log.LogFile(webException.Message);
                return false;
            }
            finally
            {
                if (httpWebResponse != null)
                {
                    httpWebResponse.Close();
                }
            }
        }
    }

     public class CStatsException : ApplicationException
    {
        public CStatsException() : base() {}
        public CStatsException(string s) : base(s) {}
        protected CStatsException(
            System.Runtime.Serialization.SerializationInfo si,
            System.Runtime.Serialization.StreamingContext sc
        ) : base(si, sc) {}
        public CStatsException(string s, Exception e) : base(s, e) {}
    }
 }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveTitle\Title\Title.cs ===
using System;
using System.Diagnostics;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Data.SqlTypes;
using System.Globalization;
using System.IO;
using System.Runtime.Serialization;
using System.Reflection;
using System.Text;

using Microsoft.Webstore.WstClient;
using Microsoft.Ems.Tools.LiveTools.Common;
using xonline.common.protocol;
using xonline.common.config;
using xonline.common.service;
using xonline.common.livetitleconfig;
using xonline.common.xlastutil;
using xonline.common.content;
using xonline.common.title;
using System.Collections.Generic;

namespace Microsoft.Ems.Tools.LiveTitle
{


    /// <summary>
    /// This object is intended to encompass administrative tasks necessary for managing titles in the service.
    /// </summary>
    public class Title
    {

        public const string UNKNOWN_TITLE = "NoNameTitle";
        public static bool useTransactions = false;

        public static void AddTitleFeatureData(uint titleID, string titleName, ProductInformation pi, StringLibrary strLib, ref StringBuilder procInfo)
        {
            if (pi == null)
                return;

            Hashtable bitflags = new Hashtable(30);

            bitflags.Add("camera",                false);  //  <param required="yes" description="support camera?"/>
            bitflags.Add("coOp",                  false);  //  <param required="yes" description="support coop?"/>
            bitflags.Add("customSoundtrack",      false);  //  <param required="yes" description="support custom soundtracks?"/>
            bitflags.Add("dolby51",               false);  //  <param required="yes" description="support dolby 5.1?"/>
            bitflags.Add("hardDriveEnhanced",     false);  //  <param required="yes" description="hard drive enhanced?"/>
            bitflags.Add("hardDriveRequired",     false);  //  <param required="yes" description="hard drive required?"/>
            bitflags.Add("liveAware",             false);  //  <param required="yes" description="support xbox live?"/>
            bitflags.Add("liveCoOp",              false);  //  <param required="yes" description="support xbox live coop play?"/>
            bitflags.Add("liveClans",             false);  //  <param required="yes" description="support xbox live clans?"/>
            bitflags.Add("liveDownloads",         false);  //  <param required="yes" description="has live downloads?"/>
            bitflags.Add("liveFriends",           false);  //  <param required="yes" description="support live friends?"/>
            bitflags.Add("liveMessaging",         false);  //  <param required="yes" description="support live messaging?"/>
            bitflags.Add("liveMultiplayer",       false);  //  <param required="yes" description="support live multiplayer?"/>
            bitflags.Add("liveScoreboard",        false);  //  <param required="yes" description="support live scoreboard?"/>
            bitflags.Add("liveServiceProxy",      false);  //  <param required="yes" description="uses a live service proxy?"/>
            bitflags.Add("liveStats",             false);  //  <param required="yes" description="support live stats?"/>
            bitflags.Add("liveTournaments",       false);  //  <param required="yes" description="support live tournaments?"/>
            bitflags.Add("liveVoice",             false);  //  <param required="yes" description="support live voice?"/>
            bitflags.Add("liveVoiceMessaging",    false);  //  <param required="yes" description="support live voice messaging?"/>
            bitflags.Add("memoryUnit",            false);  //  <param required="yes" description="support memory unit?"/>
            bitflags.Add("multiplayerVersus",     false);  //  <param required="yes" description="support multiplayer versus?"/>
            bitflags.Add("peripherals",           false);  //  <param required="yes" description="support special peripherals?"/>
            bitflags.Add("systemLink",            false);  //  <param required="yes" description="support systemlink?"/>
            bitflags.Add("premiumOffers",         false);  //  <param required="yes" description="has premium offers?"/>
            bitflags.Add("userCreatableContent",  false);  //  <param required="yes" description="support user creatable content?"/>
            bitflags.Add("xboxSupport",           false);  //  <param required="yes" description="support xbox?"/>
            bitflags.Add("xbox2Support",          false);  //  <param required="yes" description="support xbox 2?"/>


            if (pi.Feature != null)
            {
                foreach (Feature x in pi.Feature)
                {
                    if (bitflags[x.name] != null)
                    {
                        bitflags[x.name] = true;
                    }
                    else
                    {
                        // Hmmm, not good, the feature name doesn't match anything we know
                    }
                }
            }


            // insert title
            IVirtualInterfaceInfo viInfo = Config.GetVirtualInterface(VirtualInterface.uodb, Site.main);
            string webstoreApplicationName = viInfo.WebstoreApp;

            ArrayList paramlist = new ArrayList();
            SqlParameter sp = null;

            //for the UODB call
            sp = new SqlParameter( "@i_title_id", SqlDbType.Int );
            sp.Value = (int) titleID;
            paramlist.Add( sp );

            sp = new SqlParameter( "@vc_name", SqlDbType.NVarChar, 255);
            sp.Value = (string) titleName;
            paramlist.Add( sp );

            sp = new SqlParameter( "@playersOffline", SqlDbType.Int );
            sp.Value = (int) pi.offlinePlayersMax;
            paramlist.Add( sp );

            sp = new SqlParameter( "@playersSystemLink", SqlDbType.Int );
            sp.Value = (int) pi.systemLinkPlayersMax;
            paramlist.Add( sp );

            sp = new SqlParameter( "@playersLive", SqlDbType.Int );
            sp.Value =  (int)pi.livePlayersMax;
            paramlist.Add( sp );

            foreach (DictionaryEntry x in bitflags)
            {
                sp = new SqlParameter( "@" + x.Key, SqlDbType.Bit );
                sp.Value =(bool) x.Value;
                paramlist.Add( sp );
            }

            ExecuteWebstoreNonQuery( webstoreApplicationName, paramlist, "dbo.p_svc_insert_title_features", ref procInfo );
        } // AddTitleFeatureData


        //by special request from the reporting team, we need to add this for Xbox titles as well
        public static void AddTitleFeatureData(uint titleID, XboxConfiguration xboxConfig, ref StringBuilder procInfo)
        {

            Hashtable bitflags = new Hashtable(30);

            bitflags.Add("camera",                false);  //  <param required="yes" description="support camera?"/>
            bitflags.Add("coOp",                  false);  //  <param required="yes" description="support coop?"/>
            bitflags.Add("customSoundtrack",      false);  //  <param required="yes" description="support custom soundtracks?"/>
            bitflags.Add("dolby51",               false);  //  <param required="yes" description="support dolby 5.1?"/>
            bitflags.Add("hardDriveEnhanced",     false);  //  <param required="yes" description="hard drive enhanced?"/>
            bitflags.Add("hardDriveRequired",     false);  //  <param required="yes" description="hard drive required?"/>
            bitflags.Add("liveAware",             false);  //  <param required="yes" description="support xbox live?"/>
            bitflags.Add("liveCoOp",              false);  //  <param required="yes" description="support xbox live coop play?"/>
            bitflags.Add("liveClans",             false);  //  <param required="yes" description="support xbox live clans?"/>
            bitflags.Add("liveDownloads",         false);  //  <param required="yes" description="has live downloads?"/>
            bitflags.Add("liveFriends",           false);  //  <param required="yes" description="support live friends?"/>
            bitflags.Add("liveMessaging",         false);  //  <param required="yes" description="support live messaging?"/>
            bitflags.Add("liveMultiplayer",       false);  //  <param required="yes" description="support live multiplayer?"/>
            bitflags.Add("liveScoreboard",        false);  //  <param required="yes" description="support live scoreboard?"/>
            bitflags.Add("liveServiceProxy",      false);  //  <param required="yes" description="uses a live service proxy?"/>
            bitflags.Add("liveStats",             false);  //  <param required="yes" description="support live stats?"/>
            bitflags.Add("liveTournaments",       false);  //  <param required="yes" description="support live tournaments?"/>
            bitflags.Add("liveVoice",             false);  //  <param required="yes" description="support live voice?"/>
            bitflags.Add("liveVoiceMessaging",    false);  //  <param required="yes" description="support live voice messaging?"/>
            bitflags.Add("memoryUnit",            false);  //  <param required="yes" description="support memory unit?"/>
            bitflags.Add("multiplayerVersus",     false);  //  <param required="yes" description="support multiplayer versus?"/>
            bitflags.Add("peripherals",           false);  //  <param required="yes" description="support special peripherals?"/>
            bitflags.Add("systemLink",            false);  //  <param required="yes" description="support systemlink?"/>
            bitflags.Add("premiumOffers",         false);  //  <param required="yes" description="has premium offers?"/>
            bitflags.Add("userCreatableContent",  false);  //  <param required="yes" description="support user creatable content?"/>
            bitflags.Add("xboxSupport",           true);   //  <param required="yes" description="support xbox?"/>
            bitflags.Add("xbox2Support",          false);  //  <param required="yes" description="support xbox 2?"/>

            string enUSTitleName = UNKNOWN_TITLE;
            int iLoop = 0;
            bool flag = false;


            //task: remove this after xboxchecker is completed.
            if ( xboxConfig.LocalizedStrings.Length < 1 )
            {
                throw new Exception( "Xbox configuration does not have localized strings configured." );
            }

            XboxConfigurationLocalizedString ls = XboxUtil.GetTitleNameLocalizedString( xboxConfig );

            while( !flag && ( iLoop < ls.Translation.Length ) )
            {
                //XboxConfigurationLocalizedStringTranslation t in xboxCfg.LocalizedStrings.Translation
                // XboxConfigurationLocalizedStringTranslation
                string locale = ls.Translation[ iLoop ].locale;

                if ( locale == "en-US" )
                {
                    flag = true;
                    enUSTitleName = ls.Translation[ iLoop ].Value;
                }

                iLoop++;
            }

            //task: remove this after xboxchecker is completed.
            if ( !flag )  // means that enUSTitleName == UNKNOWN_TITLE
            {
                throw new Exception( "Xbox configuration does not have required en-US title name." );
            }

            // insert title
            IVirtualInterfaceInfo viInfo = Config.GetVirtualInterface(VirtualInterface.uodb, Site.main);
            string webstoreApplicationName = viInfo.WebstoreApp;

            ArrayList paramlist = new ArrayList();
            SqlParameter sp = null;

            //for the UODB call
            sp = new SqlParameter( "@i_title_id", SqlDbType.Int );
            sp.Value = (int) titleID;
            paramlist.Add( sp );

            sp = new SqlParameter( "@vc_name", SqlDbType.NVarChar, 255);
            sp.Value = (string) enUSTitleName;
            paramlist.Add( sp );

            sp = new SqlParameter( "@playersOffline", SqlDbType.Int );
            sp.Value = 0;
            paramlist.Add( sp );

            sp = new SqlParameter( "@playersSystemLink", SqlDbType.Int );
            sp.Value = 0;
            paramlist.Add( sp );

            sp = new SqlParameter( "@playersLive", SqlDbType.Int );
            sp.Value =  0;
            paramlist.Add( sp );

            foreach (DictionaryEntry x in bitflags)
            {
                sp = new SqlParameter( "@" + x.Key, SqlDbType.Bit );
                sp.Value =(bool) x.Value;
                paramlist.Add( sp );
            }

            ExecuteWebstoreNonQuery( webstoreApplicationName, paramlist, "dbo.p_svc_insert_title_features", ref procInfo );
        } // AddTitleFeatureData




        public static void AddTitleCultureDetails(uint titleID, ProductInformation pi, StringLibrary strLib, ref StringBuilder procInfo )
        {
            if (pi == null)
                return;


            System.UInt16  titleNameId = 32768;

            IVirtualInterfaceInfo viInfo = Config.GetVirtualInterface(VirtualInterface.uodb, Site.main);
            string webstoreApplicationName = viInfo.WebstoreApp;

            //-----------------------------------------------------------------
            // This is fairly elaborate: the cultures member of StringLibrary has
            // been constructed as HashTable of ArrayLists  The top level HashTable
            // is keyed by language ID and the corresponding value is an ArrayList.
            // These ArrayLists contain the culture IDs that use the language
            // designated by the key value.
            //
            // The loop below uses this to first pull the translated text for a
            // particular language (outer loop) and then create a
            // t_title_culture_details record for each culture that uses that
            // language (inner loop).
            //
            foreach(DictionaryEntry x in strLib.cultures)
            {
                int languageID = (int)x.Key;

                string titleName = "";
                string sellText = "";
                string publisher = "";
                string developer = "";
                string genre = "";

                if(strLib.Exists(titleNameId, languageID))
                    titleName   = strLib.GetString(titleNameId, languageID);
                if(strLib.Exists(pi.sellTextStringId, languageID))
                    sellText   = strLib.GetString(pi.sellTextStringId, languageID);
                if(strLib.Exists(pi.publisherStringId, languageID))
                    publisher  = strLib.GetString(pi.publisherStringId, languageID);
                if(strLib.Exists(pi.developerStringId, languageID))
                    developer  = strLib.GetString(pi.developerStringId, languageID);
                if(strLib.Exists(pi.genreTextStringId, languageID))
                    genre      = strLib.GetString(pi.genreTextStringId, languageID);

                ArrayList y    = (ArrayList)x.Value;

                foreach (int cultureID in y)
                {
                    ArrayList paramlist = new ArrayList();
                    SqlParameter sp = null;

                    // write to UODB
                    sp = new SqlParameter( "@i_title_id", SqlDbType.Int );
                    sp.Value = (int) titleID;
                    paramlist.Add( sp );

                    sp = new SqlParameter( "@i_culture_id", SqlDbType.Int );
                    sp.Value = (int) cultureID;
                    paramlist.Add( sp );

                    sp = new SqlParameter( "@vc_name", SqlDbType.NVarChar, 100);
                    sp.Value = titleName;
                    paramlist.Add( sp );

                    sp = new SqlParameter( "@vc_sell_text", SqlDbType.NVarChar, 1000);
                    sp.Value = sellText;
                    paramlist.Add( sp );

                    sp = new SqlParameter( "@vc_publisher", SqlDbType.NVarChar, 60);
                    sp.Value = publisher;
                    paramlist.Add( sp );

                    sp = new SqlParameter( "@vc_developer", SqlDbType.NVarChar, 60);
                    sp.Value = developer;
                    paramlist.Add( sp );

                    sp = new SqlParameter( "@vc_genre", SqlDbType.NVarChar, 60);
                    sp.Value = (string) genre;
                    paramlist.Add( sp );

                    ExecuteWebstoreNonQuery( webstoreApplicationName, paramlist, "dbo.p_svc_insert_title_culture_details", ref procInfo );
                }
            }
        } // AddTitleFeatureData





        public static void AddTitleHdtvData(uint titleID, ProductInformation pi, ref StringBuilder procInfo )
        {
            if (pi == null || pi.HdtvMode == null)
                return;

            foreach (HdtvMode x in pi.HdtvMode)
            {
                // write to UODB
                IVirtualInterfaceInfo viInfo = Config.GetVirtualInterface(VirtualInterface.uodb, Site.main);
                string webstoreApplicationName = viInfo.WebstoreApp;

                ArrayList paramlist = new ArrayList();
                SqlParameter sp = null;

                //for the UODB call
                sp = new SqlParameter( "@i_title_id", SqlDbType.Int );
                sp.Value = (int) titleID;
                paramlist.Add( sp );

                sp = new SqlParameter( "@i_HDTVsystem_id", SqlDbType.Int);
                sp.Value = (int) x.hdtvSystemId;
                paramlist.Add( sp );

                sp = new SqlParameter( "@i_HDTVmode_id", SqlDbType.Int );
                sp.Value = (int) x.hdtvId;
                paramlist.Add( sp );

                ExecuteWebstoreNonQuery( webstoreApplicationName, paramlist, "dbo.p_svc_insert_title_hdtv_mode", ref procInfo );
            }

        } // AddTitleHdtvData





        public static void AddTitleRatingData(uint titleID, ProductInformation pi, ref StringBuilder procInfo )
        {
            if (pi == null)
            {
                pi = new ProductInformation();
            }

            if (pi.Rating != null)
            {
                foreach (Rating x in pi.Rating)
                {
                    // write to UODB
                    IVirtualInterfaceInfo viInfo = Config.GetVirtualInterface(VirtualInterface.uodb, Site.main);
                    string webstoreApplicationName = viInfo.WebstoreApp;

                    ArrayList paramlist = new ArrayList();
                    SqlParameter sp = null;

                    //for the UODB call
                    sp = new SqlParameter("@i_title_id", SqlDbType.Int);
                    sp.Value = (int)titleID;
                    paramlist.Add(sp);

                    sp = new SqlParameter("@i_rating_system_id", SqlDbType.Int);
                    sp.Value = (int)x.ratingSystemId;
                    paramlist.Add(sp);

                    sp = new SqlParameter("@i_rating_id", SqlDbType.Int);
                    sp.Value = (int)x.ratingId;
                    paramlist.Add(sp);

                    ExecuteWebstoreNonQuery(webstoreApplicationName, paramlist, "dbo.p_svc_insert_title_rating", ref procInfo);
                }
            }
        } // AddTitleRatingData





        public static void AddTitleGenreData(uint titleID, ProductInformation pi, ref StringBuilder procInfo )
        {
            ArrayList paramlist = null;
            SqlParameter sp = null;

            if (pi == null)  // $REVIEW (michion): Without a ProductInformation node, there's really nothing
                return;      // we can do... so should we remove call p_svc_clear_title_genres?  Or is it
                             // really an invalid case when pi is null?

            // N.B.
            // Unlike other p_svc_insert_title_* sprocs, p_svc_insert_title_genre does not UPDATE existing
            // records in t_title_genres if they exist for the title ID.  This is because the records in
            // this table are chained together by a parent-child relationship established by the genre ID
            // (which makes it impractical to try to update a chain when a genre ID changes because the
            // chain for the new genre will likely be different than the original one).  Accordingly, it
            // is necessary to use a separate sproc (p_svc_cleare_title_genres) to remove all records based
            // on their title ID before insert new/updated ones.


            // Get UODB connection info
            IVirtualInterfaceInfo viInfo = Config.GetVirtualInterface(VirtualInterface.uodb, Site.main);
            string webstoreApplicationName = viInfo.WebstoreApp;

            // Wipe existing title genre info in the UODB and PCDB
            paramlist = new ArrayList();
            sp = new SqlParameter( "@i_title_id", SqlDbType.Int );
            sp.Value = (int) titleID;
            paramlist.Add( sp );
            ExecuteWebstoreNonQuery( webstoreApplicationName, paramlist, "dbo.p_svc_clear_title_genres", ref procInfo );

            //---------------------------------------------------------------------
            // Now create record(s) for the genre's found in the ProductInformation
            // NOTE: There's a corner case where NO genre's are specified, in which
            // case the pi.Genre collection won't exist (will be null instead of
            // being empty) so we must protect the loop below.
            //
            if (pi.Genre != null)
            {
                foreach (Genre x in pi.Genre)
                {
                    paramlist = new ArrayList();

                    //for the UODB call
                    sp = new SqlParameter( "@i_title_id", SqlDbType.Int );
                    sp.Value = (int) titleID;
                    paramlist.Add( sp );

                    sp = new SqlParameter( "@i_genre_id", SqlDbType.Int );
                    sp.Value = (int) x.genreId;
                    paramlist.Add( sp );
                    ExecuteWebstoreNonQuery( webstoreApplicationName, paramlist, "dbo.p_svc_insert_title_genre", ref procInfo );
                }
            }
        } // AddTitleGenreData



        //you CreateNew(  ) to create a new title
        //if you want all the info about it, then call Title LoadTitle(titleid)
        //there'll be other methods:
        //  ChangeBounty
        //  ChangeName
        //  CompleteDeletion (config constrains this to certain env??) ... ;-)

        private Title()
        {
            //task: give properties default values

        }


        #region Title Creating Methods

        //public static void CreateNewXboxTitle( uint titleID, int initialVer, int ratingSystem, int ratingID, int esrb, bool bounty, string name, string locale )
        public static void CreateNewXboxTitle( XboxConfiguration xboxCfg, LiveTitleConfig ltc, int baseVersion, ref StringBuilder processingInfo )
        {
            uint titleID;

            //
            //  Don't allow base version 0 in production environments
            //

            if(baseVersion == 0 && !Config.GetBoolSetting(Setting.livetitle_allowBaseVersionZero))
            {
                throw new ArgumentException("Base version 0 is not allowed in production environments.  Use the /version command line parameter to specify a non-zero version number.");
            }

            //titleID could be hex, or integer
            if ( xboxCfg.GameConfig.titleId.Substring(0,2).ToLower() == "0x" )
            {
                titleID = Convert.ToUInt32(xboxCfg.GameConfig.titleId,16);
            }
            else
            {
                titleID = (UInt32) Convert.ToInt32(xboxCfg.GameConfig.titleId);
            }

            // UODB & PCDB
            CreateNewXboxTitleUODBandPCDB( titleID, xboxCfg, ltc, baseVersion, ref processingInfo );

            // NPDB
            processingInfo.Length = 0;
            processingInfo.Append( "Begin NPDBStrings. " );
            NPDBCreateTitleStrings(xboxCfg, ref processingInfo);

            // WEBDB
            processingInfo.Length = 0;
            processingInfo.Append( "Begin WEBDB Title configuration. " );
            CreateNewTitleWebDB(
                xboxCfg,
                ref processingInfo );

        }

        //task: add stringbuilder to get detailed log info...
        public static void CreateNew(
            XboxLiveSubmissionProject xlsp,
            LiveTitleConfig ltc,
            string filepath,
            bool processImages,
            int baseVersion,
            ref StringBuilder processingInfo )
        {
            LocalizedStrings    strings;
            string              titleName;
            uint                titleID;

            if ( xlsp == null )
            {
                throw new ArgumentException("XboxLiveSubmissionProject passed to Title.CreateNew() was null" );
            }

            // Are we creating a game title or a marketplace only title?
            if (xlsp.GameConfigProject != null)
            {
                strings = xlsp.GameConfigProject.LocalizedStrings;
                titleName = xlsp.GameConfigProject.titleName;
                titleID = UInt32.Parse( xlsp.GameConfigProject.titleId.Substring(2), NumberStyles.HexNumber);

                //
                //  Don't allow base version 0 in production environments
                //

                if(baseVersion == 0 && !Config.GetBoolSetting(Setting.livetitle_allowBaseVersionZero))
                {
                    throw new ArgumentException("Base version 0 is not allowed in production environments.  Use the /version command line parameter to specify a non-zero version number.");
                }

            }
            else if (xlsp.MarketplaceConfigProject != null)
            {
                strings = xlsp.MarketplaceConfigProject.LocalizedStrings;
                titleName = xlsp.MarketplaceConfigProject.titleName;
                titleID = UInt32.Parse( xlsp.MarketplaceConfigProject.titleId.Substring(2), NumberStyles.HexNumber);
            }
            else
            {
                throw new ApplicationException("Invalid XboxLiveSubmissionProject passed to Title.CreateNew()");
            }

            if ( titleName == "" )
            {
                throw new ArgumentException("Title name must be valid." );
            }

            if ( strings == null )
            {
                throw new ArgumentException("LocalizedStrings element not found in the Title configuration passed to Title.CreateNew()" );
            }

            if (!CreateNewTitleUODBandPCDB( titleID, xlsp, ltc, filepath, processImages, baseVersion, ref processingInfo))
            {
                throw new Exception("CreateNewTitleUODBandPCDB failed: " + processingInfo.ToString() );
            }

            processingInfo.Length = 0;
            processingInfo.Append("Begin NPDBStrings. ");

            if (!NPDBCreateTitleStrings(titleID, strings, ref processingInfo))
            {
                throw new Exception("NPDBCreateTitleStrings failed: " + processingInfo.ToString());
            }

            if (!CreateNewTitleWebDB(titleID, strings, ref processingInfo))
            {
                throw new Exception("CreateNewTitleWebDB failed: " + processingInfo.ToString());
            }
        } // CreateNew




        //Note: This code treats PCDB almost like an additional partition of UODB for the purpose of title data
        //      This is because Marketplace, Xbox.Com and Reporting all rely on PCDB accurately reflecting
        //      the title / offer data populated in UODB.
        public static bool CreateNewTitleUODBandPCDB(
            uint titleID,
            XboxLiveSubmissionProject xlsp,
            LiveTitleConfig ltc,
            string filepath,
            bool processImages,
            int baseVersion,
            ref StringBuilder procInfo )
        {

            bool                returnValue = true;
            ImageLibrary        imgLib = null;
            ConsoleTypeEnum []  consoleTypes;

            LocalizedStrings    strings;
            Privilege[]         privileges;
            ProductInformation  pi;
            Images              images;
            Achievements        achievements;
            GamerPictures       gp;
            AvatarItems         avatarItems;
            string              titleName;
            ulong               titleType;

            if ( xlsp == null )
            {
                throw new ArgumentException("XboxLiveSubmissionProject passed to Title.CreateNewTitleUODBandPCDB() was null" );
            }

            // Are we creating a game title or a marketplace only title?
            if (xlsp.GameConfigProject != null)
            {
                strings     = xlsp.GameConfigProject.LocalizedStrings;
                privileges  = xlsp.GameConfigProject.Privileges;
                pi          = xlsp.GameConfigProject.ProductInformation;
                images      = xlsp.GameConfigProject.Images;
                achievements = xlsp.GameConfigProject.Achievements;
                gp          = xlsp.GameConfigProject.GamerPictures;
                avatarItems = xlsp.GameConfigProject.AvatarItems;
                titleName   = xlsp.GameConfigProject.titleName;
                titleType   = xlsp.GameConfigProject.titleType;

                if(pi.Platform != null && pi.Platform.Length != 0)
                {
                    consoleTypes = new ConsoleTypeEnum[pi.Platform.Length];
                    for(int i = 0; i < pi.Platform.Length; ++i)
                    {
                        consoleTypes[i] = (ConsoleTypeEnum)(pi.Platform[i].id);
                    }
                }
                else
                {
                    consoleTypes = new ConsoleTypeEnum[1] { ConsoleTypeEnum.Xenon };
                }
            }
            else if (xlsp.MarketplaceConfigProject != null)
            {
                strings     = xlsp.MarketplaceConfigProject.LocalizedStrings;
                privileges  = null;

                pi          = xlsp.MarketplaceConfigProject.ProductInformation;
                images      = xlsp.MarketplaceConfigProject.Images;
                achievements = null;
                gp          = null;
                avatarItems = null;
                titleName   = xlsp.MarketplaceConfigProject.titleName;
                titleType   = xlsp.MarketplaceConfigProject.titleType;
                if (pi.Platform != null && pi.Platform.Length != 0)
                {
                    consoleTypes = new ConsoleTypeEnum[pi.Platform.Length];
                    for (int i = 0; i < pi.Platform.Length; ++i)
                    {
                        consoleTypes[i] = (ConsoleTypeEnum)(pi.Platform[i].id);
                    }
                }
                else
                {
                    consoleTypes = new ConsoleTypeEnum[1] { ConsoleTypeEnum.Marketplace };
                }
            }
            else
            {
                throw new ApplicationException("Invalid XboxLiveSubmissionProject passed to Title.CreateNewTitleUODBandPCDB()");
            }

            try
            {
                #region Add Game Title to UODB

                procInfo.Append("Add Title to UODB - Starting");

                ArrayList versions = GetTitleVersions(titleID, ref procInfo);

                bool AllowCrossPlatformPlay = ltc == null ? false : ltc.AllowCrossPlatformPlay;
                
                // No longer is this optional, due to new per-title 5x5 work.
                // t_title_info
                // Row Missing               Legacy
                // f_requires_activation=0   Per-title 5x5
                // f_requires_activation=1   SSA
                // 
                bool PcServerSideActivation = false;
                if (pi.Feature != null)
                {
                    foreach (Feature x in pi.Feature)
                    {
                        if (x.name == "pcServerSideActivation")
                        {
                            PcServerSideActivation = x.enabled;
                        }
                    }
                }
                if (PcServerSideActivation == true)
                {
                    procInfo.Append("Title requires server-side activation");
                }

                //the sp that adds titles will add version 0 if it's not there
                // so we only want to call this function with 0 if the title completely new
                if (versions.Count == 0)
                {
                    //add the title - always starts with version 0
                    AddTitleID(titleID, baseVersion, consoleTypes, AllowCrossPlatformPlay, PcServerSideActivation, ref procInfo);
                    procInfo.Append("Added New Xenon Title to UODB - Title");
                }
                else
                {
                    //add the title - one of the base versions
                    AddTitleID(titleID, ((TitleVersion)versions[0]).Base, consoleTypes, AllowCrossPlatformPlay, PcServerSideActivation, ref procInfo);
                    procInfo.Append("Added Existing Xenon Title to UODB - Title");
                }

                //-----------------------------------------------------------------
                // Load up the libraries:
                // imagelibrary.  This class is used to simplify access
                // to the <Images> data and to perform some basic checks such as
                // confirming that the files specified in the XLAST are available.
                // Some of the checks may be redundant to those performed by SPAC
                // but others (file presence) are not
                //
                StringLibrary strLib = new StringLibrary(strings);
                if (strLib.ErrorsDetected())
                {
                    throw new Exception("String data could not be loaded: " + strLib.ErrorText());
                }

                ReferenceData refData = new ReferenceData(pi);
                if (refData.ErrorsDetected())
                {
                    throw new Exception("Reference data could not be loaded: " + refData.ErrorText());
                }

                if (processImages)
                {
                    if (xlsp.GameConfigProject != null)
                    {
                        imgLib = new ImageLibrary(xlsp.GameConfigProject.titleTypeSpecified, xlsp.GameConfigProject.titleType, titleID, images, achievements, gp, avatarItems, filepath);
                    }
                    else
                    {
                        imgLib = new ImageLibrary(titleID, images, achievements, gp, filepath);
                    }
                    if (imgLib.ErrorsDetected())
                    {
                        throw new Exception("Image data could not be loaded: " + imgLib.ErrorText());
                    }
                }

                AddTitleCultureDetails(titleID, pi, strLib, ref procInfo);
                AddTitleFeatureData(titleID, titleName, pi, strLib, ref procInfo);
                AddTitleHdtvData(titleID, pi, ref procInfo);
                AddTitleRatingData(titleID, pi, ref procInfo);
                AddTitleGenreData(titleID, pi, ref procInfo);

                if (imgLib != null)
                {
                    imgLib.PropImages();
                }

                if (ltc != null)
                {
                    //alternate title ids
                    AddAltTitleInfo(ltc, ref procInfo);
                    procInfo.Append("Added Title to UODB - AltTitleID");

                    //add bounty
                    //task: can we "unbounty" a title?
                    if (ltc.BountyExempt)
                    {
                        UODBAddBountyTitle(titleID, ref procInfo);
                        procInfo.Append("Added Title to UODB - Bounty Exempt");
                    }
                }

                #endregion

                #region Add Title Privileges

                if ((privileges != null) && (privileges.Length > 0))
                {
                    procInfo.Append("Add Title to UODB - Privileges");

                    foreach (Privilege privilege in privileges)
                    {
                        AddPrivilege(titleID, privilege.name, ref procInfo);
                    }
                }

                #endregion

                procInfo.Append("Add Title to UODB - Completed");

                // prop Avatar Items
                if ((avatarItems != null) && (avatarItems.AvatarItem != null))
                {
                    Console.WriteLine();
                    Console.WriteLine("Propping Avatar Items - Starting");
                    List<AvatarItemBin> avatarItemBinFiles = new List<AvatarItemBin>();

                    string tempDirectory = null;

                    try
                    {
                        // use a unique temporary directory so multiple instances of the ingestion tool
                        // do not conflict here
                        tempDirectory = Path.Combine(Path.GetTempPath(), "temp_avataritem_build");

                        tempDirectory = Path.Combine(tempDirectory, Guid.NewGuid().ToString());

                        if (!Directory.Exists(tempDirectory))
                            Directory.CreateDirectory(tempDirectory);

                        foreach(XboxLiveSubmissionProjectGameConfigProjectAvatarItemsAvatarItem avatarItem in avatarItems.AvatarItem)
                        {
                            string avatarItemPath = null;
                            string signedAvatarItemPath = null;
                            string acpPath = null;

                            // process Avatar Item guid1
                            try
                            {
                                avatarItemPath = Path.Combine(filepath, avatarItem.guid1.ToString("D") + AvatarItemBin.FileExtension);
                                signedAvatarItemPath = AvatarItemBin.SignFile(tempDirectory, avatarItemPath, avatarItem.guid1);
                                // avatar content package for awards
                                acpPath = Path.Combine(filepath, avatarItem.guid1.ToString("D") + AvatarItemBin.ACPFileExtension);
                            }
                            catch (Exception e)
                            {
                                Console.WriteLine("ERROR: failed to sign file " + avatarItemPath + " with " + e.ToString());
                                return false;
                            }

                            avatarItemBinFiles.Add(new AvatarItemBin(signedAvatarItemPath, titleID));

                            if (!File.Exists(acpPath))
                            {
                                Console.WriteLine("ERROR: file '" + acpPath + "' is missing but it is required for AvatarAwards.");
                                return false;
                            }
                            avatarItemBinFiles.Add(new AvatarItemBin(acpPath, titleID));

                            if (!AvatarItemImageProp.IsAvatarItemNeutral(avatarItem.guid1))
                            {
                                // process Avatar Item guid2
                                try
                                {
                                    avatarItemPath = Path.Combine(filepath, avatarItem.guid2.ToString("D") + AvatarItemBin.FileExtension);
                                    signedAvatarItemPath = AvatarItemBin.SignFile(tempDirectory, avatarItemPath, avatarItem.guid2);
                                    // avatar content package for awards
                                    acpPath = Path.Combine(filepath, avatarItem.guid2.ToString("D") + AvatarItemBin.ACPFileExtension);
                                }
                                catch (Exception e)
                                {
                                    Console.WriteLine("ERROR: failed to sign file " + avatarItemPath + " with " + e.ToString());
                                    return false;
                                }

                                avatarItemBinFiles.Add(new AvatarItemBin(signedAvatarItemPath, titleID));

                                if (!File.Exists(acpPath))
                                {
                                    Console.WriteLine("ERROR: file '" + acpPath + "' is missing but it is required for AvatarAwards.");
                                    return false;
                                }
                                avatarItemBinFiles.Add(new AvatarItemBin(acpPath, titleID));
                            }
                        }
                        
                        // set sites
                        DownloadServerList serverList = new DownloadServerList();

                        try
                        {
                            serverList.ParseSiteList(Config.GetSetting(Setting.livecontent_sites));
                        }
                        catch (Exception e)
                        {
                            Console.WriteLine("ERROR: failed to parse site list " + e.ToString());
                            return false;
                        }

                        if (!XICParallelDistributer.DistributePackages(avatarItemBinFiles.ToArray(), true /*overwrite*/))
                        {
                            Console.WriteLine("ERROR: Avatar Items distribution failed.");
                            return false;
                        }
                    }
                    finally
                    {
                        if (!String.IsNullOrEmpty(tempDirectory) && Directory.Exists(tempDirectory))
                        {
                            Directory.Delete(tempDirectory, true);
                        }
                    }

                    Console.WriteLine("Propping Avatar Items - Completed");
                    Console.WriteLine();
                }

                Console.WriteLine("Adding titles to CatalogDB - Starting");
                bool isMarketplaceProject = xlsp.MarketplaceConfigProject != null;

                // Mobile and WebGames are new consoleTypes that have no Catalog media types
                // So we are going to skip those for now.
                bool supportedCatalogPlatform = true;

                for (int i = 0; i < consoleTypes.Length; i++)
                {
                    if (consoleTypes[i] == ConsoleTypeEnum.Mobile || consoleTypes[i] == ConsoleTypeEnum.WebGames)
                    {
                        supportedCatalogPlatform = false;
                    }
                }

                if (supportedCatalogPlatform)
                {
                    GameHelper.CreateGame(titleID, titleType, consoleTypes, strings, strLib, pi, isMarketplaceProject, ref procInfo, images, filepath);
                }
                else
                {
                    Console.WriteLine("Skipping adding titles to CatalogDB");
                }

                Console.WriteLine("Adding titles to CatalogDB - Completed");

            }
            catch ( Exception e )
            {
                returnValue = false;
                procInfo.Append( "Error occurred in creating title: " + e.Message + "  STACK: " + e.StackTrace  );
            }

            return returnValue;
        }


        private static void AddPrivilege(uint titleID, string privilegeName, ref StringBuilder procInfo)
        {
            FieldInfo fieldInfo = typeof(XOn).GetField(privilegeName);

            if (fieldInfo == null)
                throw new Exception("No such privilege '" + privilegeName + "'");
            else 
            {
                byte privilegeId = (byte) fieldInfo.GetRawConstantValue();
                AddPrivilege(titleID, privilegeId, ref procInfo);
            }
        }


        private static void AddPrivilege(uint titleID, byte privilegeId, ref StringBuilder procInfo)
        {
            IVirtualInterfaceInfo viInfo = Config.GetVirtualInterface(VirtualInterface.uodb, Site.main);
            string webstoreApplicationName = viInfo.WebstoreApp;

            string sproc = "dbo.p_svc_set_title_privilege";
            ArrayList paramlist = new ArrayList();
            SqlParameter sp = null;

            sp = new SqlParameter("@i_title_id", SqlDbType.Int);
            sp.Value = (int) titleID;
            paramlist.Add(sp);

            // privilege
            sp = new SqlParameter("@ti_privilege_id", SqlDbType.TinyInt);
            sp.Value = privilegeId;
            paramlist.Add(sp);

            ExecuteWebstoreNonQuery(webstoreApplicationName, paramlist, sproc, ref procInfo);
        }


        public static bool CreateNewXboxTitleUODBandPCDB(
            uint titleID,
            XboxConfiguration xboxCfg,
            LiveTitleConfig ltc,
            int baseVersion,
            ref StringBuilder procInfo )
        {

            bool flag = true;

            procInfo.Append( "Add Title to UODB - Starting" );

            ArrayList versions = GetTitleVersions( titleID, ref procInfo );

            //the sp that adds titles will add version 0 if it's not there
            // so we only want to call this function with 0 if the title completely new
            ConsoleTypeEnum [] consoleTypes = new ConsoleTypeEnum[1] { ConsoleTypeEnum.Xbox1 };
            if ( versions.Count == 0 )
            {
                //add the title - always starts with version 0, console type 0 = Xbox
                AddTitleID( titleID, baseVersion, consoleTypes, false, null, ref procInfo );
                procInfo.Append( "Added New Xbox Title to UODB - Title" );
            }
            else
            {
                //add the title - one of the base versions
                AddTitleID( titleID, ( (TitleVersion) versions[ 0 ]).Base, consoleTypes, false, null, ref procInfo );
                procInfo.Append( "Added Existing Xbox Title to UODB - Title" );
            }

            procInfo.Append( "Added Title to UODB - Title" );

            //alternate title ids
            AddAltTitleInfo( ltc, ref procInfo );
            procInfo.Append( "Added Title to UODB - AltTitleID" );

            //add bounty                
            if ( ltc.BountyExempt )
            {
                UODBAddBountyTitle( titleID, ref procInfo );
                procInfo.Append( "Added Title to UODB - Bounty Exempt" );
            }

            AddTitleFeatureData( titleID, xboxCfg, ref procInfo );

            procInfo.Append( "Add Title to UODB - Completed" );

            return flag;
        }


        //task: REVIEW whether this works for multiple partition UODB config...
        public static void AddTitleID( uint titleID, int initialVer, ConsoleTypeEnum [] consoleTypes, bool allowCrossPlatformPlay, bool? pcServerSideActivation, ref StringBuilder procInfo )
        {
            // insert title
            //it's weird, but we're supposed to get the app name from the config...
            //how often are we going to change the appname?
            IVirtualInterfaceInfo viInfo = Config.GetVirtualInterface(VirtualInterface.uodb, Site.main);
            string webstoreApplicationName = viInfo.WebstoreApp;

            foreach(ConsoleTypeEnum consoleType in consoleTypes)
            {
                ArrayList paramlist = new ArrayList();
                SqlParameter sp = null;

                //for the UODB call
                sp = new SqlParameter( "@i_title_id", SqlDbType.Int );
                sp.Value = (int) titleID;
                paramlist.Add( sp );

                sp = new SqlParameter( "@i_initial_version", SqlDbType.Int );
                sp.Value = initialVer;
                paramlist.Add( sp );

                sp = new SqlParameter( "@ti_console_type_id", SqlDbType.TinyInt );
                sp.Value = (byte)consoleType;
                paramlist.Add( sp );

                // @@@kgoodier: Hack for PC titles only; this should be refactored if we 
                // extend title activation to other platforms
                if (consoleType == ConsoleTypeEnum.PC &&
                    pcServerSideActivation != null)
                {
                    sp = new SqlParameter( "@f_requires_activation", SqlDbType.Bit );
                    sp.Value = pcServerSideActivation;
                    paramlist.Add( sp );
                }

                //t_titles, t_title_versions, t_title_info, t_trust_constants
                ExecuteWebstoreNonQuery( webstoreApplicationName, paramlist, "dbo.p_svc_insert_titles", ref procInfo );

//                catch( Exception e )
//                {
//                    //task: should probably only catch specific errors.. and re-throw so that the application can end.
//                    omTrace( title, L_ERROR, "Error: Calling UODB.dbo.p_svc_insert_titles: " + e.Message + "\n\r Stack: " + e.StackTrace );
//                    procInfo.Append( "Error: Calling UODB.dbo.p_svc_insert_titles: " + e.Message + "\n\r Stack: " + e.StackTrace );
//                }
//            }
            }

            //
            //  If more than one console type is indicated, set the XPRIVILEGE_CROSS_PLATFORM_MULTIPLAYER
            //  privilege.
            //

            if(true)
            {
                ArrayList paramlist = new ArrayList();
                SqlParameter sp = null;

                string sproc = (consoleTypes.Length > 1 && allowCrossPlatformPlay ? "dbo.p_svc_set_title_privilege" : "dbo.p_svc_remove_title_privilege");

                //
                //  UODB
                //

                // title id
                sp = new SqlParameter( "@i_title_id", SqlDbType.Int );
                sp.Value = (int) titleID;
                paramlist.Add(sp);

                // privilege
                sp = new SqlParameter( "@ti_privilege_id", SqlDbType.TinyInt );
                sp.Value = XOn.XPRIVILEGE_CROSS_PLATFORM_MULTIPLAYER;
                paramlist.Add(sp);

                ExecuteWebstoreNonQuery( webstoreApplicationName, paramlist, sproc, ref procInfo );
            }

        } //add title id

        //  AddVersion
        public static void AddTitleVersion( uint titleID, int newVer, ConsoleTypeEnum consoleType, Guid betaGroup, ref StringBuilder procInfo )
        {
            // insert additional title version
            //we're supposed to get the app name from the config...
            //how often are we going to change the appname?  seems overly complex.
            IVirtualInterfaceInfo viInfo = Config.GetVirtualInterface(VirtualInterface.uodb, Site.main);
            string webstoreApplicationName = viInfo.WebstoreApp;

            ArrayList paramlist = new ArrayList();
            SqlParameter sp = null;

            //for the UODB call
            sp = new SqlParameter( "@i_title_id", SqlDbType.Int );
            sp.Value = (int) titleID;
            paramlist.Add( sp );

            sp = new SqlParameter( "@i_initial_version", SqlDbType.Int );
            sp.Value = newVer;
            paramlist.Add( sp );

            sp = new SqlParameter( "@ti_console_type_id", SqlDbType.TinyInt );
            sp.Value = (byte)consoleType;
            paramlist.Add( sp );

            sp = new SqlParameter( "@uid_beta_group_id", SqlDbType.UniqueIdentifier );
            sp.Value = betaGroup;
            paramlist.Add( sp );

            //t_title_versions
            ExecuteWebstoreNonQuery( webstoreApplicationName, paramlist, "dbo.p_svc_insert_titles", ref procInfo );
        } //add title id

        //could either add all ratings on a server before moving on,
        //or add a rating to all servers then do next rating... latter seemed easier
        public static void AddTitleRating( uint titleID, int ratingSystem, int ratingID, ref StringBuilder procInfo )
        {
            //it's weird, but we're supposed to get the app name from the config...
            //how often are we going to change the appname?
            IVirtualInterfaceInfo viInfo = Config.GetVirtualInterface( VirtualInterface.uodb, Site.main );
            string webstoreApplicationName = viInfo.WebstoreApp;

            using ( WstConnection titleConn = new WstConnection( webstoreApplicationName ) )
            {
                //insert rating
                //p_svc_insert_title_rating.sql  int title, int ratingsystemid, int ratingid
                WstCommand titleCmd = titleConn.CreateCommand();
                titleCmd.CommandType = CommandType.StoredProcedure;

                titleCmd.CommandText = "dbo.p_svc_insert_title_rating";
                titleCmd.PartitionType = WstPartitionType.Physical;

                titleCmd.Parameters.Add( "@i_title_id", SqlDbType.Int ).Value = (int) titleID;
                titleCmd.Parameters["@i_title_id"].Direction = ParameterDirection.Input;

                titleCmd.Parameters.Add( "@i_rating_system_id", SqlDbType.Int ).Value = ratingSystem;
                titleCmd.Parameters["@i_rating_system_id"].Direction = ParameterDirection.Input;

                titleCmd.Parameters.Add( "@i_rating_id", SqlDbType.Int ).Value = ratingID;
                titleCmd.Parameters["@i_rating_id"].Direction = ParameterDirection.Input;

                titleCmd.Parameters.Add( "@hr", SqlDbType.BigInt);
                titleCmd.Parameters["@hr"].Direction = ParameterDirection.ReturnValue;

                try
                {
                    for ( int iLoop = 0; iLoop < titleConn.SqlPartitions.Count; iLoop++)
                    {
                        titleCmd.Partition = iLoop;
                        titleCmd.ExecuteNonQuery();
                        procInfo.Append( "Title rating - partition " + iLoop );
                    }

                    if ( System.Convert.ToInt32( titleCmd.Parameters["@hr"].Value ) != 0 )
                    {
                        throw new Exception( "Call to insert title version failed! " );
                    }
                }
                catch( Exception e )
                {
                    //Xom.Trace(XomAreaName.title, LogLevel.L_ERROR, "Error: Calling UODB.dbo.p_svc_insert_title_rating: " + e.Message + "\n\r Stack: " + e.StackTrace );
                    procInfo.Append( e.ToString() );
                    throw;
                }
            }
        } //add rating


        // bounty
        public static void UODBAddBountyTitle( uint titleID, ref StringBuilder procInfo )
        {

            //it's weird, but we're supposed to get the app name from the config...
            //how often are we going to change the appname?
            IVirtualInterfaceInfo viInfo = Config.GetVirtualInterface(VirtualInterface.uodb, Site.main);
            string webstoreApplicationName = viInfo.WebstoreApp;

            ArrayList parameters = new ArrayList();
            SqlParameter sp = null;

            //for the UODB call
            sp = new SqlParameter( "@i_title_id", SqlDbType.Int );
            sp.Value = (int) titleID;
            parameters.Add( sp );

            //proc already checks if title is there and won't retry the insert
            // p_xprof_insert_exempt_title   int titleid
            ExecuteWebstoreNonQuery( webstoreApplicationName, parameters, "dbo.p_xprof_insert_exempt_title", ref procInfo );
        } //bounty

        // alt title ID & services
        public static bool AddAltTitleInfo( LiveTitleConfig ltc, ref StringBuilder procInfo )
        {

            ArrayList paramlist = new ArrayList();
            SqlParameter sp = null;

            //for the UODB call
            sp = new SqlParameter( "@i_title_id", SqlDbType.Int );
            sp.Value = (int) ltc.TitleID;
            paramlist.Add( sp );

            //these will almost always be 0, but reduce code churn here,
            //these will get set to the value from the LTC.
            sp = new SqlParameter( "@i_title_region", SqlDbType.Int );
            sp.Value = ltc.TitleRegion;
            paramlist.Add( sp );

            sp = new SqlParameter( "@i_media_id", SqlDbType.Int );
            sp.Value = (int) ltc.DiscMediaID;
            paramlist.Add( sp );

            sp = new SqlParameter( "@i_live_title_id", SqlDbType.Int );
            sp.Value = (int) ltc.LiveTitleID;
            paramlist.Add( sp );

            sp = new SqlParameter( "@i_alternate_id1", SqlDbType.Int );
            sp.Value = (int) ltc.AlternateTitleID1;
            paramlist.Add( sp );

            sp = new SqlParameter( "@i_alternate_id2", SqlDbType.Int );
            sp.Value = (int) ltc.AlternateTitleID2;
            paramlist.Add( sp );

            sp = new SqlParameter( "@i_alternate_id3", SqlDbType.Int );
            sp.Value = (int) ltc.AlternateTitleID3;
            paramlist.Add( sp );

            sp = new SqlParameter( "@i_alternate_id4", SqlDbType.Int );
            sp.Value = (int) ltc.AlternateTitleID4;
            paramlist.Add( sp );

            sp = new SqlParameter( "@i_service1", SqlDbType.Int );
            sp.Value = ltc.Service1;
            paramlist.Add( sp );

            sp = new SqlParameter( "@i_service1_alt_id", SqlDbType.Int );
            sp.Value = ltc.Service1AltID;
            paramlist.Add( sp );

            sp = new SqlParameter( "@i_service2", SqlDbType.Int );
            sp.Value = ltc.Service2;
            paramlist.Add( sp );

            sp = new SqlParameter( "@i_service2_alt_id", SqlDbType.Int );
            sp.Value = ltc.Service2AltID;
            paramlist.Add( sp );

            sp = new SqlParameter( "@i_service3", SqlDbType.Int );
            sp.Value = ltc.Service3;
            paramlist.Add( sp );

            sp = new SqlParameter( "@i_service3_alt_id", SqlDbType.Int );
            sp.Value = ltc.Service3AltID;
            paramlist.Add( sp );

            sp = new SqlParameter( "@i_service4", SqlDbType.Int );
            sp.Value = ltc.Service4;
            paramlist.Add( sp );

            sp = new SqlParameter( "@i_service4_alt_id", SqlDbType.Int );
            sp.Value = ltc.Service4AltID;
            paramlist.Add( sp );

            //add it to UODB
            bool flag = true;
            ExecuteWebstoreNonQuery(
                ConfigUtil.UodbWebstoreApp,
                paramlist,
                "p_svc_set_alternate_titleids",
                ref procInfo
                );

            return flag;
        }  //alt title id


        public static bool CreateNewTitleWebDB( uint titleID, LocalizedStrings strings, ref StringBuilder procInfo )
        {
            string defaultLocale = "";
            int     clusterID    = 1;
            int     esrb         = 7;

            if (strings == null || strings.defaultLocale == null)
            {
                procInfo.Append("XLAST did not specify a defaultLocale for LocalizedStrings!");
                return false;
            }

            defaultLocale = strings.defaultLocale;



            string connection = ConfigUtil.WebdbConnectionString;

            ArrayList paramlist = new ArrayList();
            SqlParameter sp = null;

            sp = new SqlParameter( "@i_title_id", SqlDbType.Int );
            sp.Value = (int)titleID;
            paramlist.Add( sp );

            sp = new SqlParameter( "@ti_esrb_rating", SqlDbType.TinyInt );
            sp.Value = esrb;
            paramlist.Add( sp );

            sp = new SqlParameter( "@i_cluster_id", SqlDbType.Int );
            sp.Value = clusterID;
            paramlist.Add( sp );

            sp = new SqlParameter( "@vc_default_locale", SqlDbType.NVarChar, 8 );
            sp.Value = defaultLocale;
            paramlist.Add( sp );

            //add it to WebDB
            bool flag = ExecuteNonQuery(
                connection,
                paramlist,
                "dbo.p_webdb_tmr_insert_title_info",
                ref procInfo
                );




            // $REVIEW (michion): this code loops through all the localized versions of the
            // game title. This is consistent with the XBOX1 treatment, but in other databases
            // eg UODB.t_title_culture_details, we use the StringLibrary to add all languages
            // (using defaulting logic with default locale)
            //
            LocalizedString ls = XlastUtil.GetTitleNameLocalizeString( strings );

            if ( ( null != ls ) && ( null != ls.Translation ) && ( ls.Translation.Length > 0 ) )
            {
                foreach( Translation t in ls.Translation )
                {
                    paramlist = new ArrayList();

                    sp = new SqlParameter( "@i_title_id", SqlDbType.Int );
                    sp.Value = (int)titleID;
                    paramlist.Add( sp );

                    sp = new SqlParameter( "@vc_locale_id", SqlDbType.NVarChar, 8 );
                    sp.Value = t.locale;
                    paramlist.Add( sp );

                    sp = new SqlParameter( "@vc_display_name", SqlDbType.NVarChar, 128 );
                    sp.Value = t.Value;
                    paramlist.Add( sp );

                    flag = flag && ExecuteNonQuery(
                        connection,
                        paramlist,
                        "dbo.p_webdb_tmr_insert_title_name_info",
                        ref procInfo
                        );
                }
            }

            return flag;
        }

        // Called for XBOX title
        public static void CreateNewTitleWebDB( XboxConfiguration xboxCfg, ref StringBuilder procInfo )
        {

            //task: fix Xbox config to have int titleID as param
            int titleID;
            if ( xboxCfg.GameConfig.titleId.Substring(0,2).ToLower() == "0x" )
            {
                titleID = Convert.ToInt32(xboxCfg.GameConfig.titleId,16);
            }
            else
            {
                titleID = Convert.ToInt32(xboxCfg.GameConfig.titleId);
            }

            string connection = ConfigUtil.WebdbConnectionString;
            // First, create title in t_title_info with the default locale
            //
            ArrayList paramlist = new ArrayList();
            SqlParameter sp = null;

            sp = new SqlParameter( "@i_title_id", SqlDbType.Int );
            sp.Value = titleID;
            paramlist.Add( sp );

            sp = new SqlParameter( "@ti_esrb_rating", SqlDbType.TinyInt );
            sp.Value = Convert.ToInt32(xboxCfg.WebdbInfo.ESRB);
            paramlist.Add( sp );

            sp = new SqlParameter( "@i_cluster_id", SqlDbType.Int );
            sp.Value = Convert.ToInt32(xboxCfg.WebdbInfo.ClusterID);
            paramlist.Add( sp );

            sp = new SqlParameter( "@vc_default_locale", SqlDbType.NVarChar, 8 );
            sp.Value = xboxCfg.WebdbInfo.DefaultLocale;
            paramlist.Add( sp );

            //add it to WebDB
            ExecuteNonQuery(
                connection,
                paramlist,
                "dbo.p_webdb_tmr_insert_title_info",
                ref procInfo
                );

            // Second, create all localized title name strings in t_title_name_info
            //
            XboxConfigurationLocalizedString ls = XboxUtil.GetTitleNameLocalizedString( xboxCfg );
            // Insert each translation for the localized title string
            foreach( XboxConfigurationLocalizedStringTranslation t in ls.Translation )
            {
                paramlist = new ArrayList();

                sp = new SqlParameter( "@i_title_id", SqlDbType.Int );
                sp.Value = titleID;
                paramlist.Add( sp );

                sp = new SqlParameter( "@vc_locale_id", SqlDbType.NVarChar, 8 );
                sp.Value = t.locale;
                paramlist.Add( sp );

                sp = new SqlParameter( "@vc_display_name", SqlDbType.NVarChar, 128 );
                sp.Value = t.Value;
                paramlist.Add( sp );

                ExecuteNonQuery(
                    connection,
                    paramlist,
                    "dbo.p_webdb_tmr_insert_title_name_info",
                    ref procInfo
                    );
            }

        }


//                titleCmd.CommandText = "dbo.p_webdb_tmr_insert_title_info";
//
//                titleCmd.Parameters.Add( "@i_title_id", SqlDbType.Int ).Value = (int) titleID;
//                titleCmd.Parameters["@i_title_id"].Direction = ParameterDirection.Input;
//
//                titleCmd.Parameters.Add( "@ti_esrb_rating", SqlDbType.TinyInt ).Value = esrb;
//                titleCmd.Parameters["@ti_esrb_rating"].Direction = ParameterDirection.Input;
//
//                titleCmd.Parameters.Add( "@i_cluster_id", SqlDbType.Int ).Value = clusterID;
//                titleCmd.Parameters["@i_cluster_id"].Direction = ParameterDirection.Input;
//
//                titleCmd.Parameters.Add( "@vc_default_locale", SqlDbType.NVarChar, 8 ).Value = locale;
//                titleCmd.Parameters["@vc_default_locale"].Direction = ParameterDirection.Input;
//
//                titleCmd.Parameters.Add( "@hr", SqlDbType.Int );
//                titleCmd.Parameters["@hr"].Direction = ParameterDirection.ReturnValue;
//
//                //task: do something with the rows affected?
//                int numRows = titleCmd.ExecuteNonQuery();
//
//                //p_webdb_tmr_insert_title_name_info.sql
//                titleCmd = titleConn.CreateCommand();
//                titleCmd.CommandType = CommandType.StoredProcedure;
//                titleCmd.CommandText = "dbo.p_webdb_tmr_insert_title_name_info";
//
//                titleCmd.Parameters.Add( "@i_title_id", SqlDbType.Int ).Value = (int) titleID;
//                titleCmd.Parameters["@i_title_id"].Direction = ParameterDirection.Input;
//
//                titleCmd.Parameters.Add( "@vc_locale_id", SqlDbType.NVarChar, 8 ).Value = locale;
//                titleCmd.Parameters["@vc_locale_id"].Direction = ParameterDirection.Input;
//
//                titleCmd.Parameters.Add( "@vc_display_name", SqlDbType.NVarChar, 8 ).Value = name;
//                titleCmd.Parameters["@vc_display_name"].Direction = ParameterDirection.Input;
//
//                titleCmd.Parameters.Add( "@hr", SqlDbType.Int );
//                titleCmd.Parameters["@hr"].Direction = ParameterDirection.ReturnValue;
//
//                //task: do something with the rows affected?
//                numRows = titleCmd.ExecuteNonQuery();
//
//            } // using



//        public static bool WebDbAddTitleInfo( )
//        {
//            string connection = ConfigUtil.WebdbConnectionString;
//
//            return true;
//        }

//        public static bool WebDbAddTitleNameInfo( )
//        {
//            //string connection = ConfigUtil.WebdbConnectionString;
//
//            //string procName = "dbo.p_webdb_tmr_insert_title_name_info";
//
//            //task: when you figure out parameter value assignment, fix this.
//            //                titleCmd.Parameters.Add( "@i_title_id", SqlDbType.Int ).Value = (int) titleID;
//            //                titleCmd.Parameters["@i_title_id"].Direction = ParameterDirection.Input;
//            //
//            //                titleCmd.Parameters.Add( "@vc_locale_id", SqlDbType.NVarChar, 8 ).Value = locale;
//            //                titleCmd.Parameters["@vc_locale_id"].Direction = ParameterDirection.Input;
//            //
//            //                titleCmd.Parameters.Add( "@vc_display_name", SqlDbType.NVarChar, 8 ).Value = name;
//            //                titleCmd.Parameters["@vc_display_name"].Direction = ParameterDirection.Input;
//            //
//            //                titleCmd.Parameters.Add( "@hr", SqlDbType.Int );
//            //                titleCmd.Parameters["@hr"].Direction = ParameterDirection.ReturnValue;
//
//            //bool flag; // = ExecuteNonQuery( );
//
//            return true;
//
//        }

        public static bool NPDBCreateTitleStrings( uint titleID, LocalizedStrings strings, ref StringBuilder procInfo )
        {

            LocalizedString ls = XlastUtil.GetTitleNameLocalizeString( strings );

            if ( ( null != ls ) && ( null != ls.Translation ) && ( ls.Translation.Length > 0 ) )
            {
                foreach( Translation t in ls.Translation )
                {

                    NPDBCreateTitleString( titleID, 0, t.locale, t.Value, ref procInfo );

                    //xlast/spac verifies that there is a translation for the default locale
                    if ( t.locale == strings.defaultLocale )
                    {
                        NPDBCreateTitleString( titleID, 0, "default", t.Value, ref procInfo );
                    }
                }
            }

            return true;
        }


        /// <summary>
        /// Create localized title strings from the xbox Config for Xbox1
        /// </summary>
        /// <param name="xboxXml">path of xboxConfig xml file</param>
        /// <param name="procInfo">output of debugging info</param>
        /// <returns>true if operation successful</returns>
        public static bool NPDBCreateTitleStrings( XboxConfiguration xboxCfg, ref StringBuilder procInfo )
        {

            bool defaultFound = false;

            // process title strings out of *Xbox* config data
            XboxConfigurationLocalizedString ls = XboxUtil.GetTitleNameLocalizedString( xboxCfg );

            //task: fix this so titleID for xbox doesn't have to be converted in several places
            uint titleID;

            //sometimes that value will be an integer, not "0xhexdigits"
            if ( xboxCfg.GameConfig.titleId.Substring(0,2).ToLower() == "0x" )
            {
                titleID = Convert.ToUInt32(xboxCfg.GameConfig.titleId,16);
            }
            else
            {
                titleID = (UInt32) Convert.ToInt32(xboxCfg.GameConfig.titleId);
            }

            if ( ( null != ls ) && ( null != ls.Translation ) && ( ls.Translation.Length > 0 ) )
            {
                foreach( XboxConfigurationLocalizedStringTranslation t in ls.Translation )
                {
                    //review: do I care if it is already there?
                    //review: what is the correct value for string ID?
                    NPDBCreateTitleString
                    (
                        titleID,
                        0,
                        t.locale,
                        t.Value,
                        ref procInfo
                    );

                    if ( t.locale == xboxCfg.WebdbInfo.DefaultLocale )
                    {
                        NPDBCreateTitleString
                            (
                            titleID,
                            0,          //stringid 0 == title name
                            "default",  //convention for 'default' locale...
                            t.Value,
                            ref procInfo
                            );

                        defaultFound = true;
                    }
                }
            }

            if ( ! defaultFound )
            {
                throw new Exception( "Title name string not found for Default locale specified in .Xbox file." );
            }
            return true;
        }


        public static bool NPDBCreateTitleString( uint titleID, short stringID, string locale, string stringText, ref StringBuilder procInfo )
        {

            ArrayList paramlist = new ArrayList();
            SqlParameter sp = null;
            string connection = ConfigUtil.NpdbConnectionString;

            sp = new SqlParameter( "@i_title_id", SqlDbType.Int );
            sp.Value = (int) titleID;
            paramlist.Add( sp );

            sp = new SqlParameter( "@i_string_id", SqlDbType.TinyInt );
            sp.Value = stringID;
            paramlist.Add( sp );

            sp = new SqlParameter( "@vc_locale", SqlDbType.VarChar, 10 );
            sp.Value = locale;
            paramlist.Add( sp );

            //titlemgr convention to have strings expire in 100 years
            sp = new SqlParameter( "@dt_expire", SqlDbType.DateTime );
            sp.Value = System.DateTime.Now.AddYears( 100 );
            paramlist.Add( sp );

            sp = new SqlParameter( "@nvc_text", SqlDbType.NVarChar, 512 );
            if ( stringText.Length > 512 )
            {
                sp.Value = stringText.Substring( 0, 512 );
            }
            else
            {
                sp.Value = stringText;
            }
            paramlist.Add( sp );

            bool flag = ExecuteNonQuery(
                connection,
                paramlist,
                "dbo.p_stringsvr_string_add_by_id",
                ref procInfo
                );

            return flag;

        }

        #endregion Title Creating Methods

        #region Title Checking Methods

        //task: implement
        //commented out for now so nobody accidentally uses it...
//        public static bool CheckExist( uint titleID )
//        {
//
//            //task: do we need to check everywhere?
//            //task: check uodb
//            //task: check Webdb
//            //task: check pcdb product catalog
//            //task: check xprof_bounty
//
//            //task: correct this conversion!!!
//            if (
//                ( CheckExistUODB( titleID ) ) ||
//                ( CheckExistWEBDB( titleID ) )
//                )
//            {
//                return true;
//            }
//            else
//            {
//                return false;
//            }
//        }


        public static bool CheckExistNPDB( uint titleID, int stringID )
        {

            return false;
        }

        public static bool CheckExistNPDBString( uint titleID, string stringID )
        {

            //are the title strings there?
            try
            {
                //open connection
                using ( SqlConnection execConn = new SqlConnection( ConfigUtil.NpdbConnectionString ) )
                {
                    //create command
                    execConn.Open();
                    SqlCommand execCmd = execConn.CreateCommand();
                    execCmd.CommandType = CommandType.StoredProcedure;
                    execCmd.CommandText = "dbo.p_stringsvr_strings_get_by_title_and_id";

                    //add parameters
                    execCmd.Parameters.Add( "@i_title_id", SqlDbType.Int).Value = (int) titleID;
                    execCmd.Parameters["@i_title_id"].Direction = ParameterDirection.Input;

                    execCmd.Parameters.Add( "@i_string_id", SqlDbType.Int).Value = stringID;
                    execCmd.Parameters["@i_title_id"].Direction = ParameterDirection.Input;

                    //execute non-query
                    //task: create recordset and then ??
                }
            }
            catch
            {

                //rollback transaction on commands
                //review: is this necessary?  Using should close everything, right?
                //cmd.Transaction.Rollback();

                //preserve the original exception
                throw;
            }
            return false;
        }


        public static bool CheckExistPCDB( uint titleID )
        {
            return false;
        }

//        public static bool CheckExistUODB( uint titleID )
//        {
            // loop through partitions....
//            int partitionsWithTitle = 0;
//            int iLoop = 0;
//
//            for ( iLoop = 0; iLoop < titleConn.SqlPartitions.Count ; iLoop++)
//            {
//                if (
//                    ( 0 == partitionsWithTitle ) ||   //it's not present
//                    ( titleConn.SqlPartitions.Count == partitionsWithTitle )
//                    )
//                {
//                    //good config, return whether the title is there or not
//                    return ( 0 != partitionsWithTitle );
//                }
//                else
//                {
//                    //bad config -- partially provisioned title
//                    throw new InvalidUODBConfigurationException( iLoop );
//                }
            //we can catch it immediately, or just check them all at the end...
            //                        if (
            //                            ( partitionsWithTitle != 0 ) ||
            //                            ( partitionsWithTitle != ( iLoop + 1 ) )  //zero based partition collection...
            //                            )
            //                        {
            //                            //somebody is different!
            //                            throw new InvalidUODBConfigurationException( iLoop );
            //                        }
//            return false;
//        }


        //CHECK XPROF
        //                titleCmd = titleConn.CreateCommand();
        //                titleCmd.CommandType = CommandType.StoredProcedure;
        //                titleCmd.CommandText = "p_svc_title_check";
        //
        //                titleCmd.Parameters.Add( "@i_title_id", SqlDbType.Int ).Value = titleID;
        //                titleCmd.Parameters["@titleID"].Direction = ParameterDirection.Input;
        //
        //                titleCmd.Parameters.Add( "@hr", SqlDbType.BigInt);
        //                titleCmd.Parameters["@hr"].Direction = ParameterDirection.ReturnValue;
        //
        //                titleCmd.ExecuteNonQuery();
        //
        //                if ( 1 == System.Convert.ToInt32( titleCmd.Parameters["@hr"].Value ) )
        //                {
        //                    return true;
        //                }

        public static bool CheckExistUODBPartition( uint titleID, int partition )
        {
            //task: talk to configdb for this
            IVirtualInterfaceInfo viInfo = Config.GetVirtualInterface(VirtualInterface.uodb, Site.main);
            string webstoreApplicationName = viInfo.WebstoreApp;

            using ( WstConnection titleConn = new WstConnection( webstoreApplicationName ) )
            {

                WstCommand titleCmd;
                titleConn.Open();

                titleCmd = titleConn.CreateCommand();
                titleCmd.CommandType = CommandType.StoredProcedure;

                //currently only checks t_titles, but since we create there first, it's a reasonable shortcut
                titleCmd.CommandText = "p_svc_title_exists";

                titleCmd.Parameters.Add( "@i_title_id", SqlDbType.Int ).Value = (int) titleID;
                titleCmd.Parameters["@i_title_id"].Direction = ParameterDirection.Input;

                titleCmd.Parameters.Add( "@hr", SqlDbType.BigInt);
                titleCmd.Parameters["@hr"].Direction = ParameterDirection.ReturnValue;

                titleCmd.Partition = partition;
                titleCmd.ExecuteNonQuery();

                //proc returns 1 if it's there, 0 if not...
                int exists = System.Convert.ToInt32( titleCmd.Parameters["@hr"].Value );
                return ( exists == 1 );

            } // using

        }

        public static bool CheckExistWEBDB( uint titleID )
        {
            //task: "p_webdb_tmr_get_title_name_info";

            //task: should LiveStats populate the "p_webdb_tmr_get_lb_list" stuff?
            //task: should LiveStats populate the "p_webdb_tmr_insert_lb_name_info";


            string connection = ConfigUtil.WebdbConnectionString;

            using (SqlConnection webdbConn = new SqlConnection( connection ) )
            {
                webdbConn.Open();
                SqlCommand webdbCmd = webdbConn.CreateCommand();
                webdbCmd.CommandType = CommandType.StoredProcedure;
                webdbCmd.CommandText = "dbo.p_webdb_tmr_get_title_info";

                webdbCmd.Parameters.Add( "@i_title_id", SqlDbType.Int ).Value = (int) titleID;
                webdbCmd.Parameters["@i_title_id"].Direction = ParameterDirection.Input;

                SqlDataReader webdbReader = webdbCmd.ExecuteReader();

                //review: is there a better way to do this?
                //                if ( webdbReader.Read() )
                //                {
                //                    return true;
                //                }
                //                else
                //                {
                return false;
                //                }
            }
        }


        #endregion Checking Methods

        #region Title Configuration Report Methods

        public static ArrayList GetTitleVersions( uint titleID, ref StringBuilder procInfo )
        {
            // there's always a partition 0
            return GetTitleVersions( titleID, 0, ref procInfo );
        }

        //this will be used later to audit title configuration, to make sure all partitions are the same
        public static ArrayList GetTitleVersions( uint titleID, int partition, ref StringBuilder procInfo )
        {
            ArrayList versions = new ArrayList();

            IVirtualInterfaceInfo viInfo = Config.GetVirtualInterface(VirtualInterface.uodb, Site.main);
            string webstoreApplicationName = viInfo.WebstoreApp;

            WstConnection conn = new WstConnection( webstoreApplicationName );
            conn.Open();

            //  Set up the command
            WstCommand cmd = new WstCommand(
                "dbo.p_svc_get_title_versions",   //name of the stored procedure
                conn,                             //connection
                partition,
                WstFailoverMode.PrimaryOnly
                );

            cmd.CommandType   = CommandType.StoredProcedure;
            cmd.PartitionType = WstPartitionType.Physical;
            cmd.Transaction   = conn.BeginTransaction();

            cmd.Parameters.Add( "@i_title_id", SqlDbType.Int ).Value = (int) titleID;
            cmd.Parameters["@i_title_id"].Direction = ParameterDirection.Input;

            cmd.Parameters.Add( "@i_base_version", SqlDbType.Int ).Value = -1; //retrieve all versions
            cmd.Parameters["@i_base_version"].Direction = ParameterDirection.Input;

            cmd.Parameters.Add( "@b_all_groups", SqlDbType.Bit ).Value = 1; //retrieve all groups
            cmd.Parameters["@b_all_groups"].Direction = ParameterDirection.Input;


            try
            {
                WstDataReader verReader = cmd.ExecuteReader();

                //task: retrieve data
                //loop through result set
                int baseCol = verReader.GetOrdinal( "i_base_version" );
                int updateCol = verReader.GetOrdinal( "i_update_version" );
                int betaCol = verReader.GetOrdinal( "uid_beta_group_id" );
                int consoleTypeCol = verReader.GetOrdinal( "ti_console_type_id" );

                while ( verReader.Read() )
                {
                    TitleVersion version = new TitleVersion(
                        titleID,
                        verReader.GetInt32( baseCol ),
                        verReader.GetInt32( updateCol ),
                        verReader.GetGuid( betaCol ),
                        (ConsoleTypeEnum) verReader.GetByte( consoleTypeCol )
                        );
                    versions.Add( version );
                }

            }
            catch ( Exception e )
            {
                string errString = "\n\rError Calling p_svc_get_title_versions on ptn " + partition + ": " + e.Message + "\n\r Stack: " + e.StackTrace;
                procInfo.Append( errString );

                throw;
            }

            return versions;
        }

        static public string ReportVersions( ArrayList titleVers )
        {

            StringBuilder sb = new StringBuilder( 500 );
            sb.Append( "            Title Version Configuration Report " );
            sb.Append( "\r\n\r\n" );

            sb.Append( "TitleID     BaseVersion   UpdateVersion  Platform  BetaGroup" );
            sb.Append( "\r\n\r\n" );

            for ( int iLoop = 0; iLoop < titleVers.Count; iLoop++ )
            {
                sb.AppendFormat( "{0} {1} {2} {3} {4}",
                    ( (TitleVersion) titleVers[ iLoop ] ).TitleID.ToString("X").PadRight( 11 ),
                    ( (TitleVersion) titleVers[ iLoop ] ).Base.ToString("X").PadRight( 13 ),
                    ( (TitleVersion) titleVers[ iLoop ] ).Update.ToString("X").PadRight( 15 ),
                    ( (TitleVersion) titleVers[ iLoop ] ).ConsoleType.ToString(),
                    ( (TitleVersion) titleVers[ iLoop ] ).BetaGroup.ToString()
                    );
                sb.Append( "\r\n" );

            }// for

            sb.Append( "\r\n" );
            return sb.ToString();
        }

        #endregion

        #region SQL Methods

        //NOTE:
        //  all calls must be for Webstore DB's
        //  all calls must be NonQuery
        //  all procedures called must have "set" semantic not additive
        //  (i.e. repeated calls with same params will not change configuration )
        public static void ExecuteWebstoreNonQuery( string applicationName, ArrayList paramList, string procName, ref StringBuilder procInfo )
        {

            int partitionCount;
            //get partition count
            using(WstConnection conn = new WstConnection( applicationName ))
            {
                conn.Open();
                partitionCount = conn.SqlPartitions.Count;
            }

            ArrayList connectionList = new ArrayList();
            ArrayList commandList = new ArrayList();

            try
            {
                //open a connection for each partition
                for( int physicalPartition = 0; physicalPartition < partitionCount; physicalPartition++ )
                {

                    WstConnection conn = new WstConnection( applicationName );
                    conn.Open();

                    //Hold on to this connection for later
                    connectionList.Add(conn);

                    //  Set up the command
                    WstCommand cmd = new WstCommand(
                        procName,                   //name of the stored procedure
                        conn,                       //connection
                        physicalPartition,
                        WstFailoverMode.PrimaryOnly
                        );

                    //Hold on to this command for later
                    commandList.Add(cmd);

                    cmd.CommandType   = CommandType.StoredProcedure;
                    cmd.PartitionType = WstPartitionType.Physical;
                    if(useTransactions)
                    {
                        cmd.Transaction   = conn.BeginTransaction();
                    }

                    //this should prevent changes to the original parameter set
                    foreach( SqlParameter sp in paramList )
                    {
                        SqlParameter paramCopy = new SqlParameter(
                            sp.ParameterName,
                            sp.SqlDbType,
                            sp.Size,
                            sp.Direction,
                            sp.IsNullable,
                            sp.Precision,
                            sp.Scale,
                            sp.SourceColumn,
                            sp.SourceVersion,
                            sp.Value
                            );
                        cmd.Parameters.Add( paramCopy );
                    } // copy params

                    try
                    {
                        cmd.ExecuteNonQuery();
                    }
                    catch ( Exception e )
                    {
                        string errString = "\n\rError Calling " + procName + " on ptn " + physicalPartition + ": " + e.Message + "\n\r Stack: " + e.StackTrace;
                        procInfo.Append( errString );

                        throw;
                    }
                }// for each partition

                //if all commands execute ok, commit all transactions
                foreach( WstCommand cmd in commandList )
                {
                    if(useTransactions)
                    {
                        cmd.Transaction.Commit();
                    }
                    cmd.Parameters.Clear();
                }

            }
            catch
            {
                //rollback all transactions on commands
                foreach( WstCommand cmd in commandList )
                {
                    if(useTransactions)
                    {
                        cmd.Transaction.Rollback();
                    }
                }

                //preserve the original exception
                throw;
            }
            finally
            {
                //task: assumes auto-rollback on close  is this the case??
                foreach( WstConnection conn in connectionList )
                {
                    conn.Close();
                }
            }
        }


        public static bool ExecuteNonQuery( string connectionString, ArrayList paramList, string procName, ref StringBuilder procInfo )
        {

            bool flag = true;



            try
            {
                //open connection
                using ( SqlConnection execConn = new SqlConnection( connectionString ) )
                {
                    //create command
                    execConn.Open();
                    SqlCommand execCmd = execConn.CreateCommand();
                    execCmd.CommandType = CommandType.StoredProcedure;
                    execCmd.CommandText = procName;

                    //this should prevent changes to the original parameter set
                    ArrayList parameters = (ArrayList) paramList.Clone();

                    //add parameters
                    foreach( object param in parameters )
                    {
                        execCmd.Parameters.Add( ( SqlParameter ) param );
                    }

                    //execute non-query
                    try
                    {
                        execCmd.ExecuteNonQuery();
                    }
                    catch ( Exception e )
                    {
                        string errString = "\n\rError Calling " + procName + " on ||" + connectionString + "|| Error was: " + e.Message + "\n\r Stack: " + e.StackTrace;
                        procInfo.Append( errString );

                        throw;
                    }
                }
            }
            catch
            {
                //no rollback here, since we only have 1 partition... it will fail or succeed.
                //don't need finally either, since Using will close the connection
                //preserve the original exception
                throw;
            }
            return flag;
        }

        #endregion

        #region Title Deleting Methods

        public static void DestroyTitle( uint titleID )
        {

            //task: probably already in a stored proc...
            //delete from dbo.t_title_trust_constants where i_title_id = 0xfeedface
            //delete from dbo.t_title_versions where i_title_id = 0xfeedface
            //delete from dbo.t_xprof_bounty_exempt_titles where i_title_id = 0xfeedface
            //delete from dbo.t_title_ratings where i_title_id = 0xfeedface
            //delete from t_titles

            //delete from webdb
            //delete from webdb.dbo.t_title_info where i_title_id = 0xfeedface
            //delete from webdb.dbo.t_title_name_info where i_title_id = 0xfeedface
            //p_webdb_tmr_delete_attribute_info.sql
            //p_webdb_tmr_delete_attribute_name_info.sql
            //p_webdb_tmr_delete_lb.sql
            //p_webdb_tmr_delete_lb_name_info.sql
            //p_webdb_tmr_delete_raw_attribute_info.sql
            //p_webdb_tmr_delete_title.sql
            //p_webdb_tmr_delete_title_info.sql
            //p_webdb_tmr_delete_title_name_info.sql


            //delete from uodb
            //p_xprof_insert_exempt_title
            //p_svc_insert_title_rating
            //p_svc_insert_titles

            //delete from pcdb
            //p_svc_insert_title_rating
            //p_svc_insert_titles

            //delete from PCDB???

            //
            //declare @titleid int
            //select @titleid = -2147482862
            //
            //delete from uodb.dbo.t_alt_titleid where i_title_id = @titleid
            //delete from uodb.dbo.t_title_trust_constants where i_title_id = @titleid
            //delete from uodb.dbo.t_title_versions where i_title_id = @titleid
            //delete from uodb.dbo.t_xprof_bounty_exempt_titles where i_title_id = @titleid
            //delete from uodb.dbo.t_title_ratings where i_title_id = @titleid
            //delete from uodb.dbo.t_titles where i_title_id = @titleid
            //
            //delete from webdb.dbo.t_title_name_info where i_title_id = @titleid
            //delete from webdb.dbo.t_title_info where i_title_id = @titleid


        } // delete

        public static void DeleteTitleID( uint titleID )
        {
            //all tables affected by p_svc_insert_title
        }


    //task: will be done as part of bug 42198
        public static void DeleteBaseVersion( uint titleID, int baseVer, ref StringBuilder procInfo )
        {
            //retrieve all rows for this title
            //loop through them, identifying any associated with this base version
            //add to-be-deleted to a hash table

            //loop through deletion hashtable to delete each base version

        }


        //  DeleteVersion
        public static void DeleteVersion( uint titleID, int ver, ConsoleTypeEnum consoleType, Guid betaGroup, ref StringBuilder procInfo )
        {
            //we're supposed to get the app name from the config...
            //how often are we going to change the appname?  seems overly complex.
            IVirtualInterfaceInfo viInfo = Config.GetVirtualInterface(VirtualInterface.uodb, Site.main);
            string webstoreApplicationName = viInfo.WebstoreApp;

            ArrayList paramlist = new ArrayList();
            SqlParameter sp = null;

            //for the UODB call
            sp = new SqlParameter( "@i_title_id", SqlDbType.Int );
            sp.Value = (int) titleID;
            paramlist.Add( sp );

            sp = new SqlParameter( "@i_base_version", SqlDbType.Int );
            sp.Value = ver;
            paramlist.Add( sp );

            sp = new SqlParameter( "@ti_console_type_id", SqlDbType.TinyInt );
            sp.Value = (byte)consoleType;
            paramlist.Add( sp );

            sp = new SqlParameter( "@uid_beta_group_id", SqlDbType.UniqueIdentifier );
            sp.Value = betaGroup;
            paramlist.Add( sp );

            //t_title_versions
            ExecuteWebstoreNonQuery( webstoreApplicationName, paramlist, "dbo.p_svc_delete_title_version", ref procInfo );
        } //add title id


        public static void DeleteAltTitleID( uint titleID )
        {
            //delete alt title id / svc info
        }

        public static void DeleteBounty( uint titleID )
        {
        }

        public static void DeleteRatings( uint titleID )
        {
        }


        #endregion Title Deleting Methods

    } //class

    public class InvalidUODBConfigurationException : Exception, ISerializable
    {
        const string message = "Invalid configuration -- UODB partitions are not the same.";
        public InvalidUODBConfigurationException( int partition ) :  base( message + " Check partition " + partition ) { }
        public InvalidUODBConfigurationException( ) :  base( message ) { }
        public InvalidUODBConfigurationException( SerializationInfo info, StreamingContext context ) :  base( info, context ) { }

    }

    public class DuplicateTitleException : Exception, ISerializable
    {
        const string message = "The specified TitleID already exists in the service.";
        public DuplicateTitleException( ) :  base( message ) { }
        public DuplicateTitleException( SerializationInfo info, StreamingContext context ) :  base( info, context ) { }

    }

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveToolsCommon\tools\TitleVault.cs ===
using System;
using System.IO;
using xonline.common.config;

namespace Microsoft.Ems.Tools.LiveTools.Common
{
    public class TitleVault
    {

        public static void TitleVaultCopy( string titleRoot, string fromPath, string toFileName )
        {
            FileAttributes fa;

            if ( !File.Exists( fromPath ) )
            {
                throw new Exception( "Cannot Copy Non-Existent file! Path was: " + fromPath );
            }

            string destFilePath = titleRoot + "\\" + toFileName;

            if ( File.Exists( destFilePath ) )
            {
                if ( !Directory.Exists( titleRoot + "\\OLD" ) )
                {
                    //create backup directory
                    Directory.CreateDirectory( titleRoot + "\\OLD" );
                }

                string oldFileName = titleRoot + "\\OLD\\" + toFileName;

                if ( File.Exists( oldFileName ) )
                {

                    //delete old file
                    fa = File.GetAttributes( oldFileName );
                    fa &= ~(FileAttributes.ReadOnly);
                    File.SetAttributes( oldFileName, fa );
                    File.Delete( oldFileName );
                }

                //move current to old
                File.Move( destFilePath, oldFileName );

            }

            //copy new to current
            File.Copy( fromPath, destFilePath );

            //make sure it isn't read-only
            fa = File.GetAttributes( destFilePath );
            fa &= ~(FileAttributes.ReadOnly);
            File.SetAttributes( destFilePath, fa );

        }

        public static int MoveFilesToTitleVault( string xboxPath, string xscPath, string xmsPath, string xqsPath, string ltcPath, uint uiTitleID )
        {
            int fileCount = 0;
            string titleID = uiTitleID.ToString("X8");

            //write XLAST and LTC
            string titleRoot = Config.GetSetting( Setting.titlevault_root ) + "\\" + titleID;
            Console.WriteLine( "\nMoving source files to TitleVault location:\n  " + titleRoot );

            if ( ! Directory.Exists( titleRoot ) )
            {
                Directory.CreateDirectory( titleRoot );
            }

            if ( ! Directory.Exists( titleRoot + "\\OLD" ) )
            {
                Directory.CreateDirectory( titleRoot + "\\OLD" );
            }

            TitleVaultCopy( titleRoot, xboxPath, titleID + ".xbox" );
            fileCount++;
            Console.WriteLine("   Copied XBOX file to TitleVault." );

            TitleVaultCopy( titleRoot, ltcPath, titleID + "_LTC.xml" );
            fileCount++;
            Console.WriteLine("   Copied LTC file to TitleVault." );

            if (xscPath != null)
            {
                TitleVaultCopy( titleRoot, xscPath, titleID + ".xsc" );
                fileCount++;
                Console.WriteLine("   Copied XSC file to TitleVault." );
            }

            if (xmsPath != null)
            {
                TitleVaultCopy( titleRoot, xmsPath, titleID + ".xms" );
                fileCount++;
                Console.WriteLine("   Copied XMS file to TitleVault." );
            }

            if (xqsPath != null)
            {
                TitleVaultCopy( titleRoot, xqsPath, titleID + ".xqs" );
                fileCount++;
                Console.WriteLine("   Copied XQS file to TitleVault." );
            }

            return fileCount;
        }

        public static string GetTitleVaultRootPath( uint uiTitleID )
        {
            string titleID = uiTitleID.ToString("X8");
            return Config.GetSetting( Setting.titlevault_root ) + "\\" + titleID;
        }

        public static string GetTitleVaultXscPath( uint uiTitleId )
        {
            return Config.GetSetting( Setting.titlevault_root ) + "\\" +
                uiTitleId.ToString("X8") + "\\" +
                uiTitleId.ToString("X8") + ".xsc";
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveToolsCommon\utilities\ImageInserter.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Drawing;
using System.Drawing.Imaging;
using System.Security;
using Microsoft.Ems.Apps.Web.CatalogWebServiceProxy;
using System.Diagnostics;
using xonline.common.config;
using xonline.common.utilities2;
using xonline.common.utilities;

namespace Microsoft.Ems.Tools.LiveTools.Common.Utilities
{
    public static class ImageInserter
    {
        // Original sizes of images (index matches corresponding resize index)
        private static readonly Size[] originalSize = { 
                                                        new Size(584, 800), 
                                                        new Size(800, 800) ,
                                                        new Size(800, 504),
                                                        new Size(1920,1320)
                                                        };
        // Resized version of the original (index matches corresponding original size index)
        private static readonly Size[] resultingSize = {
                                                        new Size(146, 200), 
                                                        new Size(200, 200),
                                                        new Size(200, 126),
                                                        new Size(1120, 770),
                                                       };

        // Base url for images: 
        // Two base urls are provided - one is a base url the is specific to the environment
        // in which the code is being executed. The second has a fixed string which can be 
        // easily replaced at some later point in time. This allows images to be migrated in
        // one environment and the data transported to a different environment where a simple
        // replacement can happen.
        private static readonly string baseUrlForImagesSuffix = "global/t.";

        private static string baseUrlForImages;
        private static string baseUrlForImagesReplaceableToken;

        public static string BaseUrlForImages
        {
            get
            {
                if (String.IsNullOrEmpty(baseUrlForImages))
                {
                    try
                    {
                        baseUrlForImages = String.Format("{0}{1}", Config.GetSetting("CatalogImageBaseUrl"), baseUrlForImagesSuffix);
                    }
                    catch (Exception e)
                    {
                        throw new Exception("CatalogImageBaseUrl Config setting could not be retrieved.", e);
                    }
                }

                return baseUrlForImages;
            }
        }

        public static string GetAvatarUrl(uint _titleId, Guid _avatarItemGuid, string _suffix)
        {
            return ImageInserter.BaseUrlForImages + String.Format("{0:x8}", _titleId) + "/avataritem/" + _avatarItemGuid.ToString() + "/" + _suffix;
        }

        public static string BaseUrlForImagesReplaceableToken
        {
            get
            {
                if (String.IsNullOrEmpty(baseUrlForImagesReplaceableToken))
                {
                    baseUrlForImagesReplaceableToken = String.Format("http://REPLACEABLE_HOSTNAME/{0}", baseUrlForImagesSuffix);
                }

                return baseUrlForImagesReplaceableToken;
            }
        }

        /// <summary>
        /// Inserts an image into the EMS Catalog database
        /// </summary>
        /// <param name="imagePath">Path where the image lives</param>
        /// <param name="toDir">Path where the image will be copied</param>
        /// <param name="url">fileUrl for this Image to be used in CatalogDB</param>
        /// <param name="titleId">ID associated with the Title</param>
        /// <param name="imageId">ID associated with the Image</param>
        /// <param name="isOffer">If this is an image to be associated with an offer</param>
        /// <param name="media">Media that will be related to this image</param>
        public static void InsertImage(string imagePath, string toDir, string url, uint titleId, ulong imageId, ulong offerId, Media media)
        {
            System.Drawing.Image originalImage = null;
            Guid imageGuid;

            // Add file to Catalog
            // Create a new image instance
            imageGuid = GameIdMapping.GetGuidForProppingImage(imageId, titleId, offerId);
            Microsoft.Ems.Apps.Web.CatalogWebServiceProxy.Image catalogImage = CatalogServices.Catalog.GetImage(imageGuid);
            List<Microsoft.Ems.Apps.Web.CatalogWebServiceProxy.ImageInstance> catalogImageInstances = new List<Microsoft.Ems.Apps.Web.CatalogWebServiceProxy.ImageInstance>();

            // Initialize the catalog image and catalog image instances
            InitializeCatalogImageInfo(ref catalogImage, ref catalogImageInstances, imageGuid);

            // Set up the catalog image instances
            int setupResults = SetupCatalogImageInstances(ref catalogImageInstances, imagePath, ref originalImage, toDir, url);
            if (setupResults == -1)
            {
                PrintError(imageGuid, imagePath, imageId);
                return;
            }

            catalogImage.Instances = catalogImageInstances.ToArray();

            // Save the image to the catalog 
            CatalogServices.Catalog.SaveImage(catalogImage);

            // Set up relationship from the media to this image
            AddRelationship(catalogImage, media);

            // Ensures that the image is disposed of..
            if (originalImage != null)
            {
                originalImage.Dispose();
            }
        }

        /// <summary>
        /// Inserts an Image media into the EMS Catalog database from the specified attributes.
        /// This method does not require to have the actual image file.
        /// It will also create mediarelationships in the Media object to the Image.
        /// </summary>
        /// <param name="url">Url for where the image can be accessed</param>
        /// <param name="titleId">ID associated with the Title</param>
        /// <param name="imageId">ID associated with the Image</param>
        /// <param name="offerId">If this is an image to be associated with an offer</param>
        /// <param name="sizeId">Image sizeId</param>        
        /// <param name="formatId">Image formatId</param>
        /// <param name="fileSize">Image file size</param>
        /// <param name="media"></param>
        /// <param name="forceUpdate">True - forces an update for all entities. False - only adds if its missing.</param>
        public static void InsertImage(string url, uint titleId, ulong imageId, ulong offerId, int sizeId, int formatId, int fileSize, Media media, bool forceUpdate)
        {
            Guid imageGuid = GameIdMapping.GetGuidForProppingImage(imageId, titleId, offerId);

            // Add file to Catalog
            // Create a new image instance
            Microsoft.Ems.Apps.Web.CatalogWebServiceProxy.Image catalogImage = CatalogServices.Catalog.GetImage(imageGuid);

            // skip games that already have those images
            if ((catalogImage != null) && !forceUpdate)
                return;

            // Initialize the catalog image and catalog image instances
            Console.WriteLine("      Adding new image using guid: " + imageGuid);

            if (catalogImage == null)
            {
                catalogImage = new Microsoft.Ems.Apps.Web.CatalogWebServiceProxy.Image();
                catalogImage.Modified = InsertDataChangeType.Add;
            }
            else
            {
                catalogImage.Modified = InsertDataChangeType.Update;
            }

            if (catalogImage.Instances == null)
            {
                catalogImage.Instances = new MediaInstance[1];
            }

            ImageInstance imageInstance = catalogImage.Instances[0] as ImageInstance;

            if (imageInstance == null)
            {
                imageInstance = new Microsoft.Ems.Apps.Web.CatalogWebServiceProxy.ImageInstance();
                imageInstance.Id = Guid.NewGuid();
                imageInstance.Modified = InsertDataChangeType.Add;
            }
            else
            {
                imageInstance.Modified = InsertDataChangeType.Update;
            }
            
            SetupCatalogImage(ref catalogImage, imageGuid); 

            // Set up the catalog image instances
            imageInstance.ImageSizeId = sizeId;
            imageInstance.ImageFormatId = formatId;
            imageInstance.FileSize = fileSize;
            imageInstance.FileUrl = url;
            imageInstance.Lcid = CatalogConstants.LcidUs;

            catalogImage.Instances[0] = imageInstance;

            // Save the image to the catalog 
            CatalogServices.Catalog.SaveImage(catalogImage);

            // Set up relationship from the media to this image
            AddRelationship(catalogImage, media);
        }

        /// <summary>
        /// Adds a relationship from the given game media to this image, if a relationship is warranted
        /// </summary>
        /// <param name="catalogImage">Image to relate to</param>
        /// <param name="gameMedia">Media that originates relationship</param>
        /// 
        private static void AddRelationship(Microsoft.Ems.Apps.Web.CatalogWebServiceProxy.Image catalogImage, Media media)
        {
            List<MediaRelationship> relationships = new List<MediaRelationship>();
            if (media.Relationships != null)
            {
                relationships.AddRange(media.Relationships);
            }
            // Check all the image instances for the right size
            foreach(ImageInstance ii in catalogImage.Instances)
            {
                if (ii.ImageSizeId == CatalogConstants.ImageSizeXboxPoster1
                    || ii.ImageSizeId == CatalogConstants.ImageSizeXboxPoster2)
                {
                    ConstructRelationship(CatalogConstants.RelationshipMediaToPoster, media, relationships, catalogImage.Id);
                }
                else if (ii.ImageSizeId == CatalogConstants.ImageSizeXboxWideBackground)
                {
                    ConstructRelationship(CatalogConstants.RelationshipMediaToWideBackgroundImage, media, relationships, catalogImage.Id);
                }
                else if (ii.ImageSizeId == CatalogConstants.ImageSizeLegacyGameOfferImage)
                {
                    ConstructRelationship(CatalogConstants.RelationshipMediaToSellImage, media, relationships, catalogImage.Id);
                }
                else if (ii.ImageSizeId == CatalogConstants.ImageSizeAdMerchBannerImage1
                    || ii.ImageSizeId == CatalogConstants.ImageSizeAdMerchBannerImage2
                    || ii.ImageSizeId == CatalogConstants.ImageSizeAdMerchBannerImage3
                    || ii.ImageSizeId == CatalogConstants.ImageSizeAdMerchBannerImage4
                    || ii.ImageSizeId == CatalogConstants.ImageSizeAdMerchBannerImage5
                    || ii.ImageSizeId == CatalogConstants.ImageSizeAdMerchBannerImage6
                    || ii.ImageSizeId == CatalogConstants.ImageSizeXboxNetworkLogo
                    || ii.ImageSizeId == CatalogConstants.ImageSizeLegacyGameTitleImage
                    || ii.ImageSizeId == CatalogConstants.ImageSizeMedThumbnail
                    || ii.ImageSizeId == CatalogConstants.ImageSizeXboxTvPoster
                    )
                {
                    ConstructRelationship(CatalogConstants.RelationshipMediaToImage, media, relationships, catalogImage.Id);
                }
            }
        }

        /// <summary>
        /// Constructs a relationship from the given imageid
        /// </summary>
        /// <param name="relationshipId">Relationship to form</param>
        /// <param name="media">From this media</param>
        /// <param name="relationships">Current list of media relationships</param>
        private static void ConstructRelationship(int relationshipId, Media media, List<MediaRelationship> relationships, Guid imageId)
        {
            // If the relationship doesn't exist, create a new one
            if (!DoesRelationshipExist(relationships, imageId, relationshipId))
            {
                // Create new relationship
                MediaRelationship mr = new MediaRelationship();
                mr.RelatedMediaId = imageId;
                mr.MediaRelationshipTypeId = relationshipId;
                mr.Modified = DataChangeType.Update;
                // Add relationship to the list, and add to the media
                relationships.Add(mr);
                media.Relationships = relationships.ToArray();
            }                
        }


        /// <summary>
        /// Checks if the relationship exists
        /// </summary>
        /// <param name="relationships">Media relationships to check</param>
        /// <param name="relatedMedia">Media to relate to</param>
        /// <param name="relationshipTypeId">ID of the relationship</param>
        /// <returns></returns>
        private static bool DoesRelationshipExist(List<MediaRelationship> relationships, Guid relatedMedia, int relationshipTypeId)
        {
            foreach (MediaRelationship relationship in relationships)
            {
                // See if this relationship already exists, and if so then no need to readd
                if (relationship.RelatedMediaId == relatedMedia &&
                    relationship.MediaRelationshipTypeId == relationshipTypeId)
                {
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Prints a generic error message
        /// </summary>
        /// <param name="imageGuid">Guid of the image</param>
        /// <param name="imagePath">Path of the image</param>
        /// <param name="imageId">Image id</param>
        private static void PrintError(Guid imageGuid, string imagePath, ulong imageId)
        {
            Console.WriteLine("Error inserting image {0} at {1} with guid {2}.",
                imageId,
                imagePath,
                imageGuid);
        }

        /// <summary>
        /// Initializes the CatalogImage information
        /// </summary>
        /// <param name="catalogImage">Catalog image to initialize</param>
        /// <param name="catalogImageInstances">Image instance to initialize</param>
        /// <param name="imageGuid">Guid of the image</param>
        private static void InitializeCatalogImageInfo(ref Microsoft.Ems.Apps.Web.CatalogWebServiceProxy.Image catalogImage,
                                                       ref List<Microsoft.Ems.Apps.Web.CatalogWebServiceProxy.ImageInstance> catalogImageInstances,
                                                       Guid imageGuid)
        {
            if (catalogImage == null)
            {
                Console.WriteLine("      Adding new image using guid: " + imageGuid);
                catalogImage = new Microsoft.Ems.Apps.Web.CatalogWebServiceProxy.Image();                
                catalogImageInstances.Add(new Microsoft.Ems.Apps.Web.CatalogWebServiceProxy.ImageInstance());
                catalogImageInstances[0].Id = Guid.NewGuid();
                catalogImage.Instances = catalogImageInstances.ToArray();
                catalogImage.Modified = InsertDataChangeType.Add;
            }
            else
            {
                Console.WriteLine("      Updating image using guid: " + imageGuid);

                // Populate the 0th image instance
                catalogImageInstances.Add(new Microsoft.Ems.Apps.Web.CatalogWebServiceProxy.ImageInstance());
                catalogImageInstances[0].Id = catalogImage.Instances[0].Id;
                catalogImageInstances[0].Modified = InsertDataChangeType.Update;

                // If there are two image instances (0th is original, 1rst is resized) then grab that one too..
                if (catalogImage.Instances.Length > 1)
                {
                    catalogImageInstances.Add(new Microsoft.Ems.Apps.Web.CatalogWebServiceProxy.ImageInstance());
                    catalogImageInstances[1].Id = catalogImage.Instances[1].Id;
                    catalogImageInstances[1].Modified = InsertDataChangeType.Update;
                }

                catalogImage.Instances = catalogImageInstances.ToArray();
                catalogImage.Modified = InsertDataChangeType.Update;
                catalogImage.Locales[0].Modified = DataChangeType.Update;
                catalogImage.Locales[0].MappedLcids[0].Modified = DataChangeType.Update;
            }

            SetupCatalogImage(ref catalogImage, imageGuid);            
        }

        /// <summary>
        /// Sets up the catalog image
        /// </summary>
        /// <param name="catalogImage">Image to be setup</param>
        /// <param name="imageGuid">Guid of the image</param>
        private static void SetupCatalogImage(ref Microsoft.Ems.Apps.Web.CatalogWebServiceProxy.Image catalogImage, Guid imageGuid)
        {
            // Set up the image
            catalogImage.Id = imageGuid;
            catalogImage.MediaTypeId = CatalogConstants.MediaTypeImage;
            catalogImage.VisibilityStatusId = CatalogConstants.VisibilityStatusLive;
            catalogImage.VisibilityDate = CatalogConstants.VisibilityDateForGameMedia;
            // create MediaLocale to indicate we want to use this image for the en-US locale
            catalogImage.Locales = new Microsoft.Ems.Apps.Web.CatalogWebServiceProxy.MediaLocale[1];
            catalogImage.Locales[0] = new Microsoft.Ems.Apps.Web.CatalogWebServiceProxy.MediaLocale();
            catalogImage.Locales[0].Lcid = CatalogConstants.LcidUs;
            catalogImage.Locales[0].Modified = DataChangeType.Add;

            Microsoft.Ems.Apps.Web.CatalogWebServiceProxy.Locale[] locales = CatalogServices.Catalog.GetLocale();

            List<MediaLocaleMap> mediaLocaleMaps = new List<MediaLocaleMap>(locales.Length);
            // create MediaLocaleMaps to indicate we want to use this image for all locales
            foreach (Microsoft.Ems.Apps.Web.CatalogWebServiceProxy.Locale locale in locales)
            {
                MediaLocaleMap mediaLocaleMap = new MediaLocaleMap();
                mediaLocaleMap.Lcid = locale.LCID;
                mediaLocaleMap.Modified = DataChangeType.Add;
                mediaLocaleMaps.Add(mediaLocaleMap);
            }
            catalogImage.Locales[0].MappedLcids = mediaLocaleMaps.ToArray();
        }

        /// <summary>
        /// Sets up all of the catalog image instances and resizes images if necessary
        /// </summary>
        /// <param name="catalogImageInstances">Image instance array</param>
        /// <param name="imagePath">Path to the image</param>
        /// <param name="originalImage">Original image submitted</param>
        /// <param name="toDir">Path where the image will be copied</param>
        /// <param name="url">fileUrl for this Image to be used in CatalogDB</param>
        private static int SetupAndResizeCatalogImageInstances(ref List<Microsoft.Ems.Apps.Web.CatalogWebServiceProxy.ImageInstance> catalogImageInstances, 
                                                       string imagePath, ref System.Drawing.Image originalImage, string toDir, string url)
        {
            originalImage = GetImage(imagePath);

            if (originalImage == null)
            {
                return -1;
            }

            System.Drawing.Bitmap resizedImage = ResizeImage(originalImage);
            // If a resized image is available, then resize and add to the image instance
            if (resizedImage != null)
            {
                // Construct original image filepath, append ORIGINAL onto filename
                string originalImageFilepath = Path.Combine(Path.GetDirectoryName(toDir), "ORIGINAL" + Path.GetFileName(imagePath));
                
                if (!Directory.Exists(Path.GetDirectoryName(toDir)))
                {
                    Directory.CreateDirectory(Path.GetDirectoryName(toDir));
                }

                // Save the original image to disk
                Console.WriteLine("Saving original image to disk: " + originalImageFilepath.ToString());
                originalImage.Save(originalImageFilepath.ToString());
                originalImage.Dispose();
                // Save the resized image to disk
                resizedImage.Save(toDir);

                // Set up original image
                // Image is being resized, original version of the image size id is id 0
                catalogImageInstances[0].ImageSizeId = 0;
                int formatId = GetImageFormatId(originalImageFilepath.ToString());
                if (formatId == -1)
                {
                    return -1;
                }
                catalogImageInstances[0].ImageFormatId = formatId;
                int imageFileSize = GetImageFileSize(originalImageFilepath.ToString());
                if (imageFileSize == -1)
                {
                    return -1;
                }
                catalogImageInstances[0].FileSize = imageFileSize;
                catalogImageInstances[0].FileUrl = url;
                catalogImageInstances[0].Lcid = CatalogConstants.LcidUs;

                // Set up resized image
                if (catalogImageInstances.Count <= 1)
                {
                    catalogImageInstances.Add(new Microsoft.Ems.Apps.Web.CatalogWebServiceProxy.ImageInstance());
                    catalogImageInstances[1].Id = Guid.NewGuid();
                    catalogImageInstances[1].Modified = InsertDataChangeType.Add;
                }
                int imageSizeId = GetImageSizeId(resizedImage.Size, imagePath);
                if (imageSizeId == -1)
                {
                    return -1;
                }
                catalogImageInstances[1].ImageSizeId = imageSizeId;
                catalogImageInstances[1].ImageFormatId = GetImageFormatId(originalImageFilepath.ToString());
                catalogImageInstances[1].FileSize = GetImageFileSize(toDir);
                catalogImageInstances[1].FileUrl = url;
                catalogImageInstances[1].Lcid = CatalogConstants.LcidUs;

                // Dispose of the image
                resizedImage.Dispose();
            }
            else
            {
                return SetupCatalogImageInstances(ref catalogImageInstances, imagePath, ref originalImage, toDir, url);
            }

            return 1;
        }

        /// <summary>
        /// Sets up all of the catalog image instances 
        /// </summary>
        /// <param name="catalogImageInstances">Image instance array</param>
        /// <param name="imagePath">Path to the image</param>
        /// <param name="originalImage">Original image submitted</param>
        /// <param name="toDir">Path where the image will be copied</param>
        /// <param name="url">fileUrl for this Image to be used in CatalogDB</param>
        private static int SetupCatalogImageInstances(ref List<Microsoft.Ems.Apps.Web.CatalogWebServiceProxy.ImageInstance> catalogImageInstances,
                                                       string imagePath, ref System.Drawing.Image originalImage, string toDir, string url)
        {
            originalImage = GetImage(imagePath);

            if (originalImage == null)
            {
                return -1;
            }

            int imageSizeId = GetImageSizeId(originalImage.Size, imagePath);
            if (imageSizeId == -1)
            {
                return -1;
            }
            catalogImageInstances[0].ImageSizeId = imageSizeId;
            catalogImageInstances[0].ImageFormatId = GetImageFormatId(imagePath);
            catalogImageInstances[0].FileSize = GetImageFileSize(imagePath);
            catalogImageInstances[0].FileUrl = url;
            catalogImageInstances[0].Lcid = CatalogConstants.LcidUs;

            return 1;
        }

        /// <summary>
        /// Checks if the image nees resizing
        /// </summary>
        /// <param name="imagePath">Path to the image</param>
        /// <returns>If an image needs to be resized</returns>
        public static Boolean CheckIfImageNeedsResizing(string imagePath)
        {
            System.Drawing.Image img = System.Drawing.Image.FromFile(imagePath);

            // Determine if we have an image which needs to be resized
            int i = 0;
            while (i < originalSize.Length && !img.Size.Equals(originalSize[i]))
            {
                ++i;
            }

            return i < originalSize.Length;
        }

        /// <summary>
        /// Resizes an image if possible and returns the resized image to the caller
        /// </summary>
        /// <param name="originalImage">Original Image needed for resize</param>
        /// <returns>Resized image</returns>
        private static System.Drawing.Bitmap ResizeImage(System.Drawing.Image originalImage)
        {
            // Determine if we have an image which needs to be resized
            int i = 0;
            while (i < originalSize.Length && !originalImage.Size.Equals(originalSize[i]))
            {
                ++i;
            }

            // We found a resizable image, resize and return the results
            // Array resultingSize has index that corresponds with appropriate image size
            if (i < originalSize.Length)
            {
                Console.WriteLine("Original image size: " + originalSize[i] + ", resized to: " + resultingSize[i]);
                return new Bitmap(originalImage, resultingSize[i]);
            }
            else
            {
                //Image does not have corresponding resized image");
                return null;
            }            
        }

        /// <summary>
        /// Loops through all the possible image sizes to determine the image ID we are to use
        /// </summary>
        /// <param name="s">Size of the image</param>
        /// <param name="imagePath">Path for the image to be resized</param>
        /// <returns>ImageId that represents the size</returns>
        private static int GetImageSizeId(Size imageSize, string imagePath)
        {
            ImageSize[] catalogImageSizes = CatalogServices.Catalog.GetImageSize();
            foreach (ImageSize catalogImageSize in catalogImageSizes)
            {
                if (imageSize.Width == catalogImageSize.Width && imageSize.Height == catalogImageSize.Height)
                {
                    return catalogImageSize.Id;
                }
            }

            Console.WriteLine("Error - image {0} does not have one of the standard sizes and will not be added to CatalogDB.", Path.GetFileName(imagePath));
            return -1;
        }

        /// <summary>
        /// Gets the image filesize
        /// </summary>
        /// <param name="localFileName">Image filename</param>
        /// <returns>Size of the image, if constructed</returns>
        private static int GetImageFileSize(string localFileName)
        {
            try
            {
                FileInfo fileInfo = new FileInfo(localFileName);
                return (int)fileInfo.Length;
            }
            catch (SecurityException se)
            {
                Console.WriteLine("Insufficient security to open: " + localFileName + ", " + se.Message);
                return -1;
            }
            catch (UnauthorizedAccessException ua)
            {
                Console.WriteLine("Unathorized to open file: " + localFileName + ", " + ua.Message);
                return -1;
            }
        }

        /// <summary>
        /// Returns the size if an image is a PNG/JPG and constructable. If either is not the case then an error will be printed
        /// and the image will be skipped
        /// </summary>
        /// <param name="localFileName">Image filename</param>
        /// <returns>Size of the image, if constructed</returns>
        private static System.Drawing.Image GetImage(string localFileName)
        {
            if (Path.GetExtension(localFileName).ToLower().EndsWith("png") || Path.GetExtension(localFileName).ToLower().EndsWith("jpg"))
            {
                System.Drawing.Image img = System.Drawing.Image.FromFile(localFileName);
                return img;
            }
            else
            {
                Console.WriteLine("error: " + localFileName + " is not a PNG or JPG file");
                return null;
            }            
        }

        /// <summary>
        /// Gets the image format ID
        /// </summary>
        /// <param name="filename">Filename of the image</param>
        /// <returns>Image format ID</returns>
        private static int GetImageFormatId(string filename)
        {
            string file = Path.GetExtension(filename).ToLower();
            if (file.EndsWith("png"))
            {
                return CatalogConstants.ImageFormatPng;
            }
            if (file.EndsWith("jpg"))
            {
                return CatalogConstants.ImageFormatJpg;
            }

            Console.WriteLine("Unable to find image format type for image type: " + Path.GetExtension(file));
            return -1;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\LiveToolsCommon\utilities\MediaLocaleHelper.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Drawing;
using System.Drawing.Imaging;
using System.Security;
using Microsoft.Ems.Apps.Web.CatalogWebServiceProxy;
using System.Diagnostics;
using xonline.common.utilities2;
using xonline.common.utilities;

namespace Microsoft.Ems.Tools.LiveTools.Common
{
    public static class MediaLocaleHelper
    {
        #region constants

        // text for rating values descriptions
        private static readonly string[] ratingValuesDescriptions = { "[USK", "[PEGI", "[ESRB", "[OFLC", "[KMRB", "[FPB" };

        private static readonly char ratingValueDescriptorEnd = ']';

        private static readonly string ellipsis = "";

        #endregion

        /// <summary>
        /// Helper method that creates a locale lookup from the locale code (en-us) to the lcid (1033) for all supported locales in Catalog.
        /// </summary>
        /// <returns></returns>
        public static Dictionary<string, int> CreateLocaleLookupTable()
        {
            Microsoft.Ems.Apps.Web.CatalogWebServiceProxy.Locale[] locales = CatalogServices.Catalog.GetLocale();

            Dictionary<string, int> localeLookup = new Dictionary<string, int>(locales.Length);

            foreach (Microsoft.Ems.Apps.Web.CatalogWebServiceProxy.Locale locale in locales)
            {
                localeLookup.Add(locale.LocaleCode, locale.LCID);
            }

            return localeLookup;
        }

        public static void SetTitleProperties(MediaLocale mediaLocale, string text)
        {
            if (mediaLocale == null)
                throw new ArgumentNullException("mediaLocale");

            SetTitleProperty(mediaLocale, text);

            SetTitleSortProperty(mediaLocale, text);

            SetReducedTitleProperty(mediaLocale, text);
        }

        public static void SetTitleProperty(MediaLocale mediaLocale, string text)
        {
            if (mediaLocale == null)
                throw new ArgumentNullException("mediaLocale");

            mediaLocale.Title = text;
        }

        public static void SetTitleSortProperty(MediaLocale mediaLocale, string text)
        {
            if (mediaLocale == null)
                throw new ArgumentNullException("mediaLocale");

            mediaLocale.TitleSort = text;
        }

        public static void SetReducedTitleProperty(MediaLocale mediaLocale, string text)
        {
            if (mediaLocale == null)
                throw new ArgumentNullException("mediaLocale");

            if ((text != null)
                && (text.Length > CatalogConstants.MediaLocaleReducedTitleLength))
                mediaLocale.ReducedTitle = text.Substring(0, CatalogConstants.MediaLocaleReducedTitleLength - 1) + ellipsis;
            else
                mediaLocale.ReducedTitle = text;
        }

        public static void SetDescriptionProperties(MediaLocale mediaLocale, string text)
        {
            if (mediaLocale == null)
                throw new ArgumentNullException("mediaLocale");

            mediaLocale.Description = GetMediaLocaleDescription(text);
            if ((mediaLocale.Description != null)
                && (mediaLocale.Description.Length > CatalogConstants.MediaLocaleReducedDescriptionLength))
                mediaLocale.ReducedDescription = mediaLocale.Description.Substring(0, CatalogConstants.MediaLocaleReducedDescriptionLength - 1) + ellipsis;
            else
                mediaLocale.ReducedDescription = mediaLocale.Description;
        }

        public static void SetDescriptionProperty(MediaLocale mediaLocale, string text)
        {
            if (mediaLocale == null)
                throw new ArgumentNullException("mediaLocale");

            mediaLocale.Description = GetMediaLocaleDescription(text);
        }

        public static void SetReducedDescriptionProperty(MediaLocale mediaLocale, string text)
        {
            if (mediaLocale == null)
                throw new ArgumentNullException("mediaLocale");

            string description = GetMediaLocaleDescription(text);
            if ((description != null)
                && (description.Length > CatalogConstants.MediaLocaleReducedDescriptionLength))
                mediaLocale.ReducedDescription = description.Substring(0, CatalogConstants.MediaLocaleReducedDescriptionLength - 1) + ellipsis;
            else
                mediaLocale.ReducedDescription = description;
        }

        private static string GetMediaLocaleDescription(string text)
        {
            if (!String.IsNullOrEmpty(text))
            {
                foreach (string toRemove in ratingValuesDescriptions)
                {
                    int startIndex = text.IndexOf(toRemove);
                    if (startIndex >= 0)
                    {
                        int endIndex = text.IndexOf(ratingValueDescriptorEnd);

                        if (endIndex >= 0)
                        {
                            return text.Remove(startIndex, endIndex - startIndex + 1);
                        }
                    }
                }
            }

            return text;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\lsp\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\lsp\ConfigPartnerAction.cs ===
// --------------------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved
//
// ConfigPartnerAction.cs
//
// LiveLsp
//
// Process the ConfigPartner command
// --------------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Xml;
using System.Xml.XPath;

using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.diagnostics;
using xonline.common.sql.webstore;
using xonline.common.tools.console;
using xonline.common.tools;

namespace xonline.tools.livelsp
{
    public class ConfigPartnerAction
    {
        // Config information
        private XPathNavigator xservice;
        private XPathNavigator xsite;

        private bool _serviceExists = false;
        private bool _siteExists    = false;
        private bool _sitekeyExists = false;

        public void Process(NamedArgParser args)
        {
            // Parse args
            ParseArguments(args);

            Uodb uodb = new Uodb(args);
            Npdb npdb = new Npdb(args);

            // Does service exist already?
            xservice = uodb.GetServiceInfo(_args.service).CreateNavigator();
            if (xservice.SelectSingleNode("/service-info/service-id") != null)
            {
                _serviceExists = true;
            }

            // Does site exist already?
            xsite = npdb.GetSiteInfo(_args.site).CreateNavigator();
            if (xsite.SelectSingleNode("/site-info/site-id") != null)
            {
                _siteExists = true;
                
                // Does site key exist already?
                if (xsite.SelectSingleNode("/site-info/key-info") != null)
                {
                    _sitekeyExists = true;
                }
            }

            Output.Debug("ServiceExists: {0}", _serviceExists);
            Output.Debug("SiteExists: {0}", _siteExists);
            
            // Special case for -remove. Process it now and return.
            if (_args.removeassociation)
            {
                // -service is required. -site is optional, and if not specified 
                // we will default to use the same value as -service.
                Output.Info("Unmapping service-id 0x{0:X8} from site-id 0x{1:X8}",
                            _args.service, _args.site);
                uodb.UnmapServiceFromSite(_args.service, _args.site);
                return;
            }

            // Automatically fill in any missing options
            if (_serviceExists)
            {
                if (!_args.servicedesc_specified)
                {
                    _args.servicedesc = xservice.SelectSingleNode("/service-info/description").Value;
                    Output.Debug("Using service description \"{0}\" from existing service", _args.servicedesc);
                }
            }

            if (_siteExists)
            {
                if (!_args.sitedesc_specified)
                {
                    _args.sitedesc = xsite.SelectSingleNode("/site-info/description").Value;
                    Output.Debug("Using site description \"{0}\" from existing site", _args.sitedesc);
                }
                if (!_args.authdata_specified)
                {
                    _args.authdata = (UInt32)xsite.SelectSingleNode("/site-info/authdata-version").ValueAsInt;
                    Output.Debug("Using authdata version {0} from existing site", _args.authdata);
                }
            }
            
            // Spew useful info 
            Output.Info("=================================================");
            Output.Info("Configuring site and service...");
            Output.Info("=================================================");
            Output.Info("Using service-id                       : 0x{0:X8} ({1}) [{2}]", 
                        _args.service, _args.service, _serviceExists ? "existing" : "new");
            Output.Info("Using service-description              : {0}", _args.servicedesc);
            Output.Info("Using site-id                          : 0x{0:X8} ({1}) [{2}]", 
                        _args.site, _args.site, _siteExists ? "existing" : "new");
            Output.Info("Using site-description                 : {0}", _args.sitedesc);
            Output.Info("Using authdata version                 : {0}", _args.authdata);
            Output.Info("Using ticket lifetime                  : {0} hours", _args.ticketlifetime);
            if (_args.siteip != null)
                Output.Info("Using site IP address                  : {0}", _args.siteip);
            if (!_sitekeyExists)
                Output.Info("Using master key file                  : {0}", _args.masterkeyfile);
            Output.Info("");

            //
            // Database work
            // 

            // Insert or update site & service
            Output.Info("Configuring site and service...");
            npdb.AddSite(_args.site, _args.authdata, _args.siteip);
            uodb.AddService(_args.site, _args.sitedesc, _args.authdata, _args.service, _args.servicedesc);
            

            // Add mapping for service -> site for all titles. This is optional since it 
            // isn't currently done and maybe we want to preserve that behavior.
            if (!_args.noassociation)
            {
                Output.Info("Mapping service to site for all titles (this will be used as a default mapping)...");
                uodb.MapServiceToSite(_args.service, _args.site, 0);
            }

            //
            // Xkeymgr work
            //

            if (!_sitekeyExists)
            {
                Output.Info("Creating a site key for the new site (this may take a short while)...");
                if (!LiveLspUtils.CreateSiteKey(_args.site, _args.masterkeyfile, 3600 * _args.ticketlifetime))
                {
                    Output.Error("Please verify the site key manually in t_service_keys");
                }
            }

            //
            // Xmgmt reloads
            // For sites and services and such, we need to reload the XKDC and LiveProxy 
            // (it feeds the GetSiteInfo calls from the LSPSG)
            //

            if (args["noreload"] == null)
            {
                Output.Info("Reloading the XKDC (e :xkdc reload)...");
                LiveLspUtils.ReloadXkdc();

                Output.Info("Reloading the LiveProxy (e :livepxy reloadkeys)...");
                LiveLspUtils.ReloadLivepxyKeys();
            }

        }

        // Old Webdb implementation stuff. Not going to do for version 1.0 of 
        // this tool, but it will be implemented eventually, so I'd like to 
        // keep this around.
        // {{{
#if false
        private void ProcessWebdb(NamedArgParser args)
        {
            WebDb webdb = new WebDb(args);

            XPathDocument xmlPartner = webdb.GetPartnerInfo(_args.partner);
            XPathNavigator xpath = xmlPartner.CreateNavigator();

            string partnerDescription = xpath.SelectSingleNode(
                "/partner/partner-description").Value;
            string partnerCredSubject = xpath.SelectSingleNode(
                "/partner/cred-subject-name").Value;

            Output.Info("Partner Information:");
            Output.Info("");
            Output.OutPairs(
                Output.Level.Info,
                2,
                "description", partnerDescription,
                "cert-subject", partnerCredSubject);
            Output.Info("");

            // Grant Web Apis
            
            Output.Info("Granting Web Apis:");
            Output.Info("");
            GrantApi(xpath, webdb, "LiveProxy.GetSiteInfo");
            GrantApi(xpath, webdb, "LiveProxy.LspAdvertise");
            Output.Info("");

            // Grant title-ids

            Output.Info("Granting title:");
            Output.Info("");
            Output.OutPairs(Output.Level.Info, 2, "Title 0x"+_args.title.ToString("X"));
            
            if(xpath.SelectSingleNode(string.Format(
                        "/partner/allowed-titles/allowed-title/title"+
                        "[. = {0} and title-privilege = 7]",
                        _args.title)) == null)
            {
                webdb.AddAllowedTitle(_args.partner, _args.title, 7);
                Output.Info("[OK]");
            }
            else
            {
                Output.Info("[ALREADY GRANTED]");
            }

        }

        private void GrantApi(
            XPathNavigator xpath, 
            WebDb webdb,
            string api
            )
        {
            Output.OutPairs(Output.Level.Info, 2, api.PadRight(33));

            if(xpath.SelectSingleNode(string.Format(
                        "/partner/allowed-apis/api"+
                        "[normalize-space(.) = '{0}']", api.ToLower())) != null)
            {
                Output.Info("[ALREADY GRANTED]");
                return;
            }

            webdb.AddAllowedApi(_args.partner, api);
            Output.Info("[OK]");
        }
#endif
        // }}} End stubs
        
        private void ParseArguments(NamedArgParser args)
        {
            if(args["help"] != null || args["h"] != null || args["?"] != null)
            {
                PrintUsageConfig();
            }
            
            try
            {
                _args = new Arguments(args);
            }
            catch (LiveLspBadArgumentException e)
            {
                Output.Error(e.Message);
                PrintUsageConfig();
                return;
            }

            Output.Debug("Arguments:");
            _args.Dump();
            Output.Debug("");
            
        }

        private static void PrintUsageConfig()
        {
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890123456789

            string helpText = @"
Livelsp.exe -configpartner [options...]
LiveLsp.exe -cp [options...]

Notes:
    Any parameter surrounded by brackets is optional. All others are required. 
    See -remove for exceptions.

Options:

    -service:<service-id>
        Specifies the LSP service. Usually a publisher has a single service 
        that's shared by all of its titles. It may be hex (with 0x) or 
        decimal.

    [-site:<site-id>]
        Explicitly defines the site-id to associate the service-id with. If
        one is not specified, this tool will use the service-id as the site-id. 
        If the specified site does not exist, one will be created for you.

    [-servicedesc:<description>]
        Description of the service. If not specified, the service-id is used. If 
        specified for an existing services, the description will be updated. 
        Description must be enclosed in double quotes if it contains spaces. Up 
        to 30 characters allowed.

    [-sitedesc:<description>]
        Description of the site. If not specified, the site-id is used. If 
        specified for an existing site, the description will be updated. 
        Description must be enclosed in double quotes if it contains spaces. Up 
        to 100 characters allowed.

    [-authdata:2|3]
        Specifies what auth-data version is supported by the publisher's LSP 
        backend.  Legacy LSP only supports version 2 while non-legacy LSP 
        supports both. This is used for new sites, or for updating an existing 
        site's authdata version. If not specified, version 3 is used.

    [-lifetime:<hours>]
        Lifetime of the XKDC ticket, in hours, for this site. Default is 36 
        hours for normal XLSP sites.

    [-ip:<ip-address>]
        Specifies the site's ip address, to be populated in the XKDC ticket.  
        This is unused by most XLSP installations, and can be used to update an 
        existing site ip address.

    [-masterkey:<filename>]
        Provides the master public key file needed to create a key for a new 
        site. This should be the full path to the MasterKey.pub file, which is 
        provided to xkeymgr.  If not specified, MasterKey.pub in the local 
        directory will be used.

    [-noassociation]
        Do not associate this service id to this site id for all titles by 
        default. This will maintain parity with how things have been done in the 
        past.

    [-remove]
        Special switch that allows associations between the service and site to 
        be removed. The -service option is required and -site is optional. All 
        other options above are ignored. This switch only affects the table 
        t_service_instances.
        
Examples:

LiveLsp -cp -service:0x4D530000 -site:0x4D530000 -masterkey:""..\MasterKeyV1.pub""
LiveLsp -cp -service:0x4D530000 -servicedesc:""Test LiveLsp Service""
LiveLsp -cp -service:0x4D530000 -site:0x4D530001 -authdata:2 -sitedesc:""Test site""
LiveLsp -cp -service:0x4D530000 -site:0x4D530001 -remove -v
            ";
           
            Output.Info(helpText);
            System.Environment.Exit(-1);
        }

        // class Arguments
        // {{{
        private class Arguments
        {
            public UInt32   service;
            public UInt32   site;
            public bool     site_specified;
            public string   servicedesc;
            public bool     servicedesc_specified;
            public string   sitedesc;
            public bool     sitedesc_specified;
            public UInt32   authdata;
            public bool     authdata_specified;
            public UInt32   ticketlifetime;
            public bool     ticketlifetime_specified;
            public string   siteip;
            public string   masterkeyfile;
            public bool     masterkeyfile_specified;
            public bool     noassociation;
            public bool     removeassociation;

            public Arguments(NamedArgParser args)
            {
                this.removeassociation = (args["remove"] != null);
                
                this.service = args.ParseUInt("service");
                if(this.service == 0)
                {
                    throw new LiveLspBadArgumentException(
                        "Error: -service is missing or invalid");
                }

                if(args["site"] != null)
                {
                    this.site = args.ParseUInt("site");
                    this.site_specified = true;

                    if(this.site == 0)
                    {
                        throw new LiveLspBadArgumentException("Invalid -site.");
                    }
                }
                else
                {
                    this.site = service;
                    this.site_specified = false;
                }

                // -remove is special. -service is required and -site is 
                // optional.  All others are ignored.
                if (this.removeassociation)
                {
                    return;
                }

                if (args["servicedesc"] != null)
                {
                    this.servicedesc = args["servicedesc"];
                    this.servicedesc_specified = true;
                    // t_services.vc_description is only 30 characters
                    if (this.servicedesc.Length > 30)
                    {
                        this.servicedesc = this.servicedesc.Substring(0, 30);
                        Output.Info("Service description is too long, truncating to \"{0}\"", this.servicedesc);
                    }
                }
                else
                {
                    this.servicedesc = String.Format("Service 0x{0:X}", this.service);
                    this.servicedesc_specified = false;
                }

                if (args["sitedesc"] != null)
                {
                    this.sitedesc = args["sitedesc"];
                    this.sitedesc_specified = true;
                    // t_sites.vc_description is only 100 characters
                    if (this.sitedesc.Length > 100)
                    {
                        this.sitedesc = this.sitedesc.Substring(0, 100);
                        Output.Info("Site description is too long, truncating to \"{0}\"", this.sitedesc);
                    }
                }
                else
                {
                    this.sitedesc = String.Format("Site 0x{0:X}", this.site);
                    this.sitedesc_specified = false;
                }

                if(args["lifetime"] != null)
                {
                    this.ticketlifetime = args.ParseUInt("lifetime");
                    this.ticketlifetime_specified = true;

                    if (this.ticketlifetime > 24*7 || this.ticketlifetime == 0)
                    {
                        throw new LiveLspBadArgumentException(
                            "Invalid -lifetime. Valid values are 1 hour to 168 hours (1 week).");
                    }
                }
                else
                {
                    this.ticketlifetime = 36;
                    this.ticketlifetime_specified = false;
                }

                if(args["authdata"] != null)
                {
                    this.authdata = args.ParseUInt("authdata");
                    this.authdata_specified = true;

                    if(this.authdata != 2 &&
                       this.authdata != 3)
                    {
                        throw new LiveLspBadArgumentException(
                            "Invalid -authdata. Valid values are 2 or 3.");
                    }
                }
                else
                {
                    this.authdata = 3;
                    this.authdata_specified = false;
                }

                if (args["ip"] != null)
                {
                    this.siteip = args["ip"];
                }

                if (args["masterkey"] != null)
                {
                    this.masterkeyfile = args["masterkey"];
                    this.masterkeyfile_specified = true;
                }
                else
                {
                    this.masterkeyfile = "masterkey.pub";
                    this.masterkeyfile_specified = false;
                }

                if (args["noassociation"] != null)
                {
                    this.noassociation = true;
                }
                else
                {
                    this.noassociation = false;
                }

            } // Arguments

            public void Dump()
            {
                Output.OutPairs(
                    Output.Level.Debug,
                    2, 
                    "service", "0x" + this.service.ToString("X"),
                    "site", "0x" + this.site.ToString("X"),
                    "site_specified", this.site_specified.ToString(),
                    "servicedesc", this.servicedesc,
                    "servicedesc_specified", this.servicedesc_specified.ToString(),
                    "sitedesc", this.sitedesc,
                    "sitedesc_specified", this.sitedesc_specified.ToString(),
                    "authdata", this.authdata.ToString(),
                    "authdata_specified", this.authdata_specified.ToString(),
                    "lifetime", this.ticketlifetime.ToString(),
                    "lifetime_specified", this.ticketlifetime_specified.ToString(),
                    "ip", this.siteip,
                    "masterkeyfile", this.masterkeyfile,
                    "masterkeyfile_specified", this.masterkeyfile_specified.ToString(),
                    "noassociation", this.noassociation.ToString(),
                    "removeassociation", this.removeassociation.ToString());
            }
        } // }}} end class Arguments

        private Arguments _args;

    } // end class ConfigPartnerAction

} // end namespace xonline.tools.livelsp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\lsp\ConfigTitleAction.cs ===
// --------------------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved
//
// ConfigTitleAction.cs
//
// LiveLsp
//
// Process the ConfigTitle command
// --------------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Xml;
using System.Xml.XPath;

using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.diagnostics;
using xonline.common.sql.webstore;
using xonline.common.tools.console;
using xonline.common.tools;

namespace xonline.tools.livelsp
{
    public class ConfigTitleAction
    {
        // Config information
        private XPathNavigator xtitle;
        private XPathNavigator xservice;
        private XPathNavigator xsite;

        // Deduced information
        private uint _servicesGrantedCount;
        private uint _dwordServicesGrantedCount;
        private uint _servicesAssociatedCount;
        private uint _titleCountXbox;
        private uint _titleCountXbox360;
        private uint _titleCountPC;

        public void Process(NamedArgParser args)
        {
            // Parse args
            ParseArguments(args);
    
            Uodb uodb = new Uodb(args);
            Npdb npdb = new Npdb(args);

            // Verify title exists
            xtitle = uodb.GetTitleInfo(_args.title).CreateNavigator();
            if (xtitle.SelectSingleNode("/title-info/title-id") == null)
            {
                Output.Error("No title found for id 0x{0:X8}", _args.title);
                Output.Error("Please ensure this title is properly configured before proceeding.");
                (new QueryAction()).DumpXml(xtitle);
                return;
            }

            // Special case for -remove. Process it now and return.
            if (_args.removeassociation)
            {
                // -service is optional. If specified, we'll limit the remove to 
                // it (plus the title). If not specified (value is 0), all 
                // services will be disassociated from the title.
                if (_args.service == 0)
                {
                    Output.Info("Unmapping all services from title-id 0x{0:X8}", _args.title);
                }
                else
                {
                    Output.Info("Unmapping service-id 0x{0:X8} from title-id 0x{1:X8}", _args.service, _args.title);
                }
                uodb.RemoveServiceGrantFromTitle(_args.service, _args.title);
                return;
            }

            // Verify service exists
            xservice = uodb.GetServiceInfo(_args.service).CreateNavigator();
            if (xservice.SelectSingleNode("/service-info/service-id") == null)
            {
                Output.Error("No service found for service-id {0} (0x{1:X8})", _args.service, _args.service);
                Output.Error("Please ensure this service exists in t_services.");
                (new QueryAction()).DumpXml(xservice);
                return;
            }

            // Determine site
            if (!_args.site_specified)
            {
                _args.site = DetermineSite();
                if (_args.site == 0)
                {
                    Output.Error("No site specified and none could be determined. Please specify the site.");
                    return;
                }
            }
            else
            {
                // Verify site exists
                xsite = npdb.GetSiteInfo(_args.site).CreateNavigator();
                if (xsite.SelectSingleNode("/site-info/site-id") == null)
                {
                    Output.Error("No site found for site-id {0} (0x{1:X8})", _args.site, _args.site);
                    Output.Error("Please ensure this site exists in t_sites and t_service_keys.");
                    return;
                }
            }

            // Verify 4 or fewer DWORD (>= 256) services are associated with this title.  
            // We'll do the actual check later, when we determine whether this is an 
            // INSERT or an UPDATE to the DB.
            _servicesGrantedCount = (uint)xtitle.Select("/title-info/title-services/service").Count;
            _dwordServicesGrantedCount = (uint)xtitle.Select("/title-info/title-services/service[service-id >= 256 or service-id < 0]").Count;
            _servicesAssociatedCount = (uint)xtitle.Select("/title-info/service-instances/service").Count;

            // Verify title is either Xbox1 or Xbox360/PC, but not both
            _titleCountXbox = (uint)xtitle.Select("/title-info/title-versions/title-version[@console-type=0]").Count;
            _titleCountXbox360 = (uint)xtitle.Select("/title-info/title-versions/title-version[@console-type=2]").Count;
            _titleCountPC = (uint)xtitle.Select("/title-info/title-versions/title-version[@console-type=4]").Count;

            // Spew useful info 
            Output.Info("=================================================");
            Output.Info("Configuring title...");
            Output.Info("=================================================");
            Output.Info("Using title-id                         : 0x{0:X8} ({1})", _args.title, _args.title);
            Output.Info("Count of title versions for consoles   : Xbox1 [{0}], Xbox360 [{1}], PC [{2}]",
                        _titleCountXbox, _titleCountXbox360, _titleCountPC);
            Output.Info("Using service-id                       : 0x{0:X8} ({1})", _args.service, _args.service);
            Output.Info("Using site-id                          : 0x{0:X8} ({1})", _args.site, _args.site);
            //Output.Info("Using authdata version                 : {0}", _args.authdata);
            Output.Info("Num services granted by title          : {0}", _servicesGrantedCount);
            Output.Info("Num DWORD services granted by title    : {0}", _dwordServicesGrantedCount);
            Output.Info("Num services associated with title     : {0}", _servicesAssociatedCount);
            Output.Info("");

            // Sanity checks
            if (_titleCountXbox > 0 && (_titleCountXbox360 > 0 || _titleCountPC > 0))
            {
                // TODO: is this the appropriate action?
                Output.Error("Warning: This title exists for both Xbox1 and Xbox360/PC. Please investigate.");
            }


            // 
            // Configure Xbox1 title in UODB
            // t_service_instances and t_offer_services
            //

            if (_titleCountXbox > 0)
            {
                // Check the 4 dword service limit
                int existingAssociation = xtitle.Select("/title-info/service-instances/service[service-id=" + _args.service + "]").Count;
                if (existingAssociation == 0 && _servicesAssociatedCount >= 4)
                {
                    Output.Error("Warning: title-id {0} (0x{1:X8}) already has {2} associations with service-id {3} (0x{4:X8})",
                                _args.title, _args.title, _servicesAssociatedCount, _args.service, _args.service);
                    Output.Error("Adding another one will go over the limit, but may be ok depending on title versions.");
                    Output.Error("I'm going to add another t_service_instance association, but you should investigate.");
                }

                // Associate title to service/site via t_service_instances
                Output.Info("{0} Xbox1 title (t_service_instances)...",
                            existingAssociation == 0 ? "Configuring" : "Reconfiguring");

                Output.Info("Mapping service 0x{0:X8} to site 0x{1:X8}...", _args.service, _args.site);
                uodb.MapServiceToSite(_args.service, _args.site, _args.title);

                // Associate the service with the base offers. This includes all Xbox1 
                // offers, plus the Xbox360 gold and silver offers. Silver is only useful 
                // for the free weekend scenarios, but will simplify that case. Not that 
                // t_offer_services is ignored for Xbox360 titles for any offer in 
                // t_base_offers, to prevent granting all Xbox1 LSP services to everyone.

                Output.Info("Mapping service 0x{0:X8} to all base offers...", _args.service);
                uodb.MapServiceToBaseOffers(_args.service);
            }

            //
            // Configure Xbox360/PC title in UODB
            // t_service_instances and t_title_services
            //

            if (_titleCountXbox360 > 0 || _titleCountPC > 0)
            {
                // Make sure we won't go over the 4 dword service limit
                int existingGrant = xtitle.Select("/title-info/title-services/service[service-id=" + _args.service + "]").Count;
                if (_args.service >= 256)
                {
                    if (existingGrant == 0 && _dwordServicesGrantedCount >= 4)
                    {
                        Output.Error("Unable to grant service-id {0} (0x{1:X8}) to title-id {2} (0x{3:X8}) due to 4 DWORD service limit",
                                     _args.service, _args.service, _args.title, _args.title);
                        throw new LiveLspConfigException("4 DWORD service limit already reached for t_title_services, please investigate.");
                    }
                }

                // Make title automatically grant this service based on t_title_services
                Output.Info("{0} Xbox360/PC title (t_title_services and t_service_instances)...",
                            existingGrant == 0 ? "Configuring" : "Reconfiguring");

                Output.Info("Mapping service 0x{0:X8} to site 0x{1:X8}...", _args.service, _args.site);
                uodb.MapServiceToSite(_args.service, _args.site, _args.title);

                Output.Info("Adding service 0x{0:X8} to list of services granted by title 0x{1:X8}...", _args.service, _args.title);
                uodb.AddServiceGrantToTitle(_args.service, _args.title);
            }

            //
            // Npdb
            //

            try
            {
                // Back-compat?
                if (_args.backcompat)
                {
                    Output.Info("Adding title to back-compat list...");
                    npdb.AddBackCompatSetting(_args.title);
                }
            }
            catch (Exception e)
            {
                Output.Error("Error configuring npdb..t_settings query_LspBackcompTitles, please verify manually");
                Output.Error("Exception: {0}", e.Message);
            }

            try
            {
                // t_interface_buckets
                Output.Info("Adding title to interface buckets (t_interface_buckets)...");
                npdb.AddInterfaceBucket(_args.title, _args.querydb, _args.querydb_specified);
            }
            catch (Exception e)
            {
                Output.Error("Error configuring npdb..t_interface_buckets, please verify manually");
                Output.Error("Exception: {0}", e.Message);
            }

            //
            // Xmgmt reloads
            // Only XKDC needed for new titles (service instance mapping)
            // @@@ LiveProxy has reloads for partners and titles - do these only hit the 
            // WebDb?
            //

            if (args["noreload"] == null)
            {
                Output.Info("Reloading the XKDC...");
                LiveLspUtils.ReloadXkdc();
            }

        }

        // Try to determine the site-id from the service-info query. Since our title-id 
        // presumably isn't associated yet, this may be non-deterministic.  For instance, 
        // if a service is associated with more than 1 site.  We'll try our best.
        private uint DetermineSite()
        {
            XPathNavigator node;
            XPathNodeIterator iter;

            // If all instances of this service are associated with only 1 site, use it
            Output.Debug("DetermineSite: Looking for consistent site for this service...");
            iter = xservice.Select("/service-info/sites/site/site-id");
            if (iter != null && iter.Count == 1)
            {
                Output.Debug("Found a single site");
                iter.MoveNext();
                return (uint)iter.Current.ValueAsInt;
            }

            // Look for site where title-id matches ours. Only applies to re-props.
            Output.Debug("DetermineSite: Looking for title-id match...");
            node = xservice.SelectSingleNode(String.Format("/service-info/service-instances/title[title-id={0} and version=0 and region=0]/site-id", _args.title)); 
            if (node != null)
            {
                Output.Debug("Found site matching our title-id.");
                iter.MoveNext();
                return (uint)node.ValueAsInt;
            }

            Output.Debug("DetermineSite: Unable to find any sites for this service-id.");
            return 0;
        }


        private void ParseArguments(NamedArgParser args)
        {
            if(args["help"] != null || args["h"] != null || args["?"] != null)
            {
                PrintUsageConfig();
            }
            
            try
            {
                _args = new Arguments(args);
            }
            catch (LiveLspBadArgumentException e)
            {
                Output.Error(e.Message);
                PrintUsageConfig();
                return;
            }

            Output.Debug("Arguments:");
            _args.Dump();
            Output.Debug("");
        }

        private static void PrintUsageConfig()
        {
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890123456789

            string helpText = @"
LiveLsp.exe -configtitle [options...]
LiveLsp.exe -ct [options...]

Notes:
    Any parameter surrounded by brackets is optional. All others are required. 
    See -remove for exceptions.

Options:

    -titleid:<title-id>
        Specifies the title-id to configure. It may be hex (with 0x) or 
        decimal.

    -service:<service-id>
        Specifies the LSP service. Usually a publisher has a single service 
        that's shared by all of its titles. It may be hex (with 0x) or 
        decimal.

    [-site:<site-id>]
        Explicitly defines the site-id to use. Otherwise, this tool will 
        attempt to auto-determine the site from the current configuration. 
    
    [-querydb:<query-db-name>]
        Specifies the name of a query-db server to store the title's 
        advertisement data, such as XETITLSQLV01. If not specified, then this 
        tool will attempt to auto-determine the default querydb server from 
        the NPDB.

    [-backcompat]
        The -backcompat argument specifies whether the publisher has a 
        non-legacy LSP backend but has games that use legacy LSP APIs that 
        need to access it. If this argument is not specified, the backcompat 
        status for the title is unchanged which, for new titles, means that 
        backcompat is NOT enabled. If this argument is specified, the title is 
        added to the query_LspBackcompTitles setting in the NPDB.  

    [-remove]
        Special switch that allows associations to be removed. If only -titleid 
        is specified, then remove all services associated with the title. If 
        both -titleid and -service are specified, then remove only that service 
        from the association. All other options above are ignored. This switch 
        only affects the tables t_title_services and t_service_instances.

Examples:

LiveLsp -ct -titleid:0x4D5307D1 -service:0x4D530000
LiveLsp -ct -titleid:0x4D5307D2 -service:0x4D530000 -site:0xFFFF0072 -backcompat 
LiveLsp -ct -titleid:0xFFFF0072 -service:0x4D530000 -v -readonly -outfile:o.txt
LiveLsp -ct -titleid:-65422 -service:1297285120 -querydb:XETITLSQLV01 
LiveLsp -ct -titleid:0x4D5307D1 -service:0x4D530000 -remove -v
LiveLsp -ct -titleid:0x4D5307D1 -remove -v
            ";

            Output.Info(helpText);
            System.Environment.Exit(-1);
        }
        
        // class Arguments
        // {{{
        private class Arguments
        {
            public UInt32   title;
            public UInt32   service;
            public UInt32   site;
            public bool     site_specified;
            public bool     backcompat;
            public string   querydb;
            public bool     querydb_specified;
            public bool     removeassociation;

            public Arguments(NamedArgParser args)
            {
                this.removeassociation = (args["remove"] != null);

                this.title = args.ParseUInt("titleid");

                if(this.title == 0)
                {
                    throw new LiveLspBadArgumentException(
                        "Error: -titleid is missing or invalid");
                }

                this.service = args.ParseUInt("service");

                // -remove is special. -titleid is required and -service is 
                // optional. All others are ignored.
                if (this.removeassociation)
                {
                    return;
                }

                if(this.service == 0)
                {
                    throw new LiveLspBadArgumentException(
                        "Error: -service is missing or invalid");
                }

                if(args["site"] != null)
                {
                    this.site = args.ParseUInt("site");
                    this.site_specified = true;

                    if(this.site == 0)
                    {
                        throw new LiveLspBadArgumentException("Invalid -site.");
                    }
                }
                else
                {
                    this.site = service;
                    this.site_specified = false;
                }                
                
                this.backcompat        = (args["backcompat"] != null);

                if(args["querydb"] != null)
                {
                    this.querydb = args["querydb"];
                    this.querydb_specified = true;
                }
                else
                {
                    this.querydb = "";
                    this.querydb_specified = false;
                }              

            } 

            public void Dump()
            {
                Output.OutPairs(
                    Output.Level.Debug,
                    2, 
                    "titleid", "0x" + this.title.ToString("X"),
                    "service", "0x" + this.service.ToString("X"),
                    "site", "0x" + this.site.ToString("X"),
                    "site_specified", this.site_specified.ToString(),
                    "querydb", this.querydb,
                    "querydb_specified", this.querydb_specified.ToString(),
                    "backcompat", this.backcompat.ToString(),
                    "removeassociation", this.removeassociation.ToString());
            }
        } // }}} class Arguments

        private Arguments _args;

    } // end class ConfigTitleAction
     
} // end namespace xonline.tools.livelsp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\lsp\Database.cs ===
// --------------------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved
//
// database.cs
//
// LiveLsp
//
// Database stuff
// --------------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Xml;
using System.Xml.XPath;

using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.diagnostics;
using xonline.common.sql.webstore;
using xonline.common.tools.console;
using xonline.common.tools;

namespace xonline.tools.livelsp
{
    // class WebDb
    // {{{
    public class WebDb
    {
        // Twiddle this for read-only access to the DB
        public bool ReadOnly = false;

        public WebDb(NamedArgParser args)
        {
            ReadOnly = args["readonly"] != null;
            
            // Get the connection string for the webdb interface from Config
            _webdbConnectionString = ConfigUtil.WebdbConnectionString;

            Output.Debug("Using WebDb: connection=\"{0}\", readonly={1}", _webdbConnectionString, ReadOnly);
        }

        public XPathDocument GetPartnerInfo(UInt32 partnerId)
        {
            using(SqlConnection sql = new SqlConnection(_webdbConnectionString))
            {
                sql.Open();
                
                SqlCommand cmd = new SqlCommand(SqlQueries.GetPartnerInfoSql, sql);
                cmd.CommandType = CommandType.Text;

                cmd.Parameters.Add("@i_partner_id", SqlDbType.Int).Value = (Int32) partnerId;

                using(SqlDataReader reader = cmd.ExecuteReader())
                {
                    Assert.IsTrue(reader.Read());

                    XmlReader xmlreader  = reader.GetSqlXml(0).CreateReader();
                    XPathDocument xmldoc = new XPathDocument(xmlreader);
                    return xmldoc;
                }
            }
        }

        public void AddAllowedApi(UInt32 partnerId, string api)
        {
            using(SqlConnection sql = new SqlConnection(_webdbConnectionString))
            {
                sql.Open();
                
                SqlCommand cmd = new SqlCommand(SqlQueries.AddAllowedApiSql, sql);
                cmd.CommandType = CommandType.Text;

                cmd.Parameters.Add("@i_partner_id", SqlDbType.Int).Value = (Int32) partnerId;
                cmd.Parameters.Add("@vc_api_name",  SqlDbType.NVarChar).Value = api;

                cmd.ExecuteNonQuery();
            }
        }

        public void AddAllowedTitle(UInt32 partnerId, UInt32 titleId, UInt32 privilege)
        {
            using(SqlConnection sql = new SqlConnection(_webdbConnectionString))
            {
                sql.Open();
                
                SqlCommand cmd = new SqlCommand(SqlQueries.AddAllowedTitleSql, sql);
                cmd.CommandType = CommandType.Text;

                cmd.Parameters.Add("@i_partner_id", SqlDbType.Int).Value = (Int32) partnerId;
                cmd.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (Int32) titleId;
                cmd.Parameters.Add("@i_title_privilege", SqlDbType.Int).Value = (Int32) privilege;

                cmd.ExecuteNonQuery();
            }
        }

        protected string _webdbConnectionString;
    } // }}} class WebDb


    // class Npdb
    // {{{
    public class Npdb 
    {
        // Twiddle this for read-only access to the DB
        public bool ReadOnly = false;

        public Npdb(NamedArgParser args)
        {
            ReadOnly = args["readonly"] != null;
            // Get the connection string for the uodb interface from Config
            _npdbConnectionString = ConfigUtil.NpdbConnectionString;
            
            Output.Debug("Using Npdb: connection=\"{0}\", readonly={1}", _npdbConnectionString, ReadOnly);
        }

        public void AddBackCompatSetting(UInt32 titleId)
        {
            Output.Debug("");
            Output.Debug("=================================================");
            Output.Debug("AddBackCompatSetting SQL");
            Output.Debug("=================================================");
            Output.Debug("");
            Output.Debug("            declare @vc_title_id as nvarchar(16) set @vc_title_id='0x{0:X}'", titleId);
            Output.Debug(SqlQueries.AddBackCompatSettingSql);
            Output.Debug("=================================================");

            if (ReadOnly)
                return;

            using(SqlConnection sql = new SqlConnection(_npdbConnectionString))
            {
                sql.Open();

                // Parameter: @vc_title_id as string with leading "0x"
                SqlCommand cmd = new SqlCommand(SqlQueries.AddBackCompatSettingSql, sql);
                cmd.CommandType = CommandType.Text;

                cmd.Parameters.Add("@vc_title_id", SqlDbType.NVarChar).Value = String.Format("0x{0:X}", titleId);

                cmd.ExecuteNonQuery();
            }
        }
       
        public void AddInterfaceBucket(UInt32 titleId, string querydb, bool querydb_specified)
        {
            Output.Debug("");
            Output.Debug("=================================================");
            Output.Debug("AddInterfaceBucket SQL");
            Output.Debug("=================================================");
            Output.Debug("");
            Output.Debug("            declare @i_title_id as int set @i_title_id=0x{0:X}", titleId);
            Output.Debug("            declare @vc_querydb as nvarchar(16) set @vc_querydb='{0}'", querydb);
            Output.Debug(SqlQueries.AddInterfaceBucketSql);
            Output.Debug("=================================================");

            if (ReadOnly)
                return;

            using(SqlConnection sql = new SqlConnection(_npdbConnectionString))
            {
                sql.Open();

                // Parameter: @i_title_id
                SqlCommand cmd = new SqlCommand(SqlQueries.AddInterfaceBucketSql, sql);
                cmd.CommandType = CommandType.Text;
                
                cmd.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (Int32)titleId;
                cmd.Parameters.Add("@vc_querydb", SqlDbType.NVarChar).Value = querydb;

                cmd.ExecuteNonQuery();
            }
        }

        public XPathDocument GetSiteInfo(UInt32 siteId)
        {
            Output.Debug("");
            Output.Debug("=================================================");
            Output.Debug("GetSiteInfo SQL");
            Output.Debug("=================================================");
            Output.Debug("");
            Output.Debug("            declare @i_site_id as int set @i_site_id=0x{0:X}", siteId);
            Output.Debug(SqlQueries.GetSiteInfoSql);
            Output.Debug("=================================================");

            using (SqlConnection sql = new SqlConnection(_npdbConnectionString))
            {
                sql.Open();

                using (SqlCommand command = sql.CreateCommand())
                {
                    command.CommandType = CommandType.Text;

                    // p_livelsp_get_site_info
                    // Parameter: @i_site_id
                    command.CommandText = SqlQueries.GetSiteInfoSql;
                    command.Parameters.Add("@i_site_id", SqlDbType.Int).Value = (Int32)siteId;

                    using (XmlReader xmlreader = command.ExecuteXmlReader())
                    {
                        XPathDocument xmldoc = new XPathDocument(xmlreader);
                        return xmldoc;
                    }
                }
            }
        }

        public XPathDocument GetSiteAuthdataVersionInfo(UInt32 siteId)
        {
            Output.Debug("");
            Output.Debug("=================================================");
            Output.Debug("GetSiteInfo SQL");
            Output.Debug("=================================================");
            Output.Debug("");
            Output.Debug("            declare @i_site_id as int set @i_site_id=0x{0:X}", siteId);
            Output.Debug(SqlQueries.GetSiteInfoSql);
            Output.Debug("=================================================");

            using (SqlConnection sql = new SqlConnection(_npdbConnectionString))
            {
                sql.Open();

                using (SqlCommand command = sql.CreateCommand())
                {
                    command.CommandType = CommandType.Text;

                    // p_livelsp_get_site_info
                    // Parameter: @i_site_id
                    command.CommandText = SqlQueries.GetSiteInfoSql;
                    command.Parameters.Add("@i_site_id", SqlDbType.Int).Value = (Int32)siteId;

                    using (XmlReader xmlreader = command.ExecuteXmlReader())
                    {
                        XPathDocument xmldoc = new XPathDocument(xmlreader);
                        return xmldoc;
                    }
                }
            }
        }

        public void AddSite(UInt32 siteId, UInt32 authdataVer, string siteIp)
        {
            if (siteIp == null)
            {
                siteIp = "";
            }

            Output.Debug("");
            Output.Debug("=================================================");
            Output.Debug("AddSite SQL");
            Output.Debug("=================================================");
            Output.Debug("");
            Output.Debug("            declare @i_site_id as int set @i_site_id=0x{0:X}", siteId);
            Output.Debug("            declare @i_authdata_version as int set @i_authdata_version={0}", authdataVer);
            Output.Debug(SqlQueries.AddSiteSql);
            Output.Debug("=================================================");
            Output.Debug("            declare @i_site_id as int set @i_site_id=0x{0:X}", siteId);
            Output.Debug("            declare @vc_ip as nvarchar(32) set @vc_ip='{0}'", siteIp);
            Output.Debug(SqlQueries.AddSiteVirtualInterfaceIpSql);
            Output.Debug("=================================================");

            if (ReadOnly)
                return;

            using (SqlConnection sql = new SqlConnection(_npdbConnectionString))
            {
                sql.Open();

                using (SqlCommand command = sql.CreateCommand())
                {
                    command.CommandType = CommandType.Text;
                    command.CommandText = SqlQueries.AddSiteSql;
                    command.Parameters.Add("@i_site_id", SqlDbType.Int).Value = (Int32)siteId;
                    command.Parameters.Add("@i_authdata_version", SqlDbType.Int).Value = (Int32)authdataVer;
                    command.Parameters.Add("@retval", SqlDbType.BigInt).Direction = ParameterDirection.ReturnValue;

                    command.ExecuteNonQuery();

                    Output.Debug("AddSite retval={0}", System.Convert.ToInt32(command.Parameters["@retval"].Value));
                }

                using (SqlCommand command = sql.CreateCommand())
                {
                    command.CommandType = CommandType.Text;
                    command.CommandText = SqlQueries.AddSiteVirtualInterfaceIpSql;
                    command.Parameters.Add("@i_site_id", SqlDbType.Int).Value = (Int32)siteId;
                    command.Parameters.Add("@vc_ip", SqlDbType.NVarChar).Value = siteIp;
                    command.Parameters.Add("@retval", SqlDbType.BigInt).Direction = ParameterDirection.ReturnValue;

                    command.ExecuteNonQuery();

                    Output.Debug("AddSiteVirtualInterfaceIp retval={0}", System.Convert.ToInt32(command.Parameters["@retval"].Value));
                }
            }
        }
        
        protected string    _npdbConnectionString;
    }
    // }}}

    // class Uodb
    // {{{
    public class Uodb
    {
        // Twiddle this for read-only access to the DB
        public bool ReadOnly = false;

        public Uodb(NamedArgParser args)
        {
            ReadOnly = args["readonly"] != null;
            
            // Get the connection string for the uodb interface from Config
            IVirtualInterfaceInfo iUodb = Config.GetVirtualInterface(VirtualInterface.uodb, Site.main);
            _uodbConnectionString = iUodb.WebstoreApp;
                    
            Output.Debug("Using Uodb: connection=\"{0}\", readonly={1}", _uodbConnectionString, ReadOnly);
        }

        public XPathDocument GetTitleInfo(UInt32 titleId)
        {
            Output.Debug("");
            Output.Debug("=================================================");
            Output.Debug("GetTitleInfo SQL");
            Output.Debug("=================================================");
            Output.Debug("");
            Output.Debug("            declare @i_title_id as int set @i_title_id=0x{0:X}", titleId);
            Output.Debug(SqlQueries.GetTitleInfoSql);
            Output.Debug("=================================================");
            
            using(WstConnection sql = new WstConnection(_uodbConnectionString))
            {
                sql.Open();
               
                WstCommand cmd = sql.CreateCommand();
                cmd.CommandType = CommandType.Text;
                cmd.Partition = WstCommand.AnyPartition;

                // p_livelsp_get_title_info
                // Parameter: @i_title_id
                cmd.CommandText = SqlQueries.GetTitleInfoSql; 
                cmd.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (Int32) titleId;

                using(WstXmlReader xmlreader = cmd.ExecuteXmlReader())
                {
                    XPathDocument xmldoc = new XPathDocument(xmlreader);
                    return xmldoc;
                }
            }
        }

        public XPathDocument GetServiceInfo(UInt32 serviceId)
        {
            Output.Debug("");
            Output.Debug("=================================================");
            Output.Debug("GetServiceInfo SQL");
            Output.Debug("=================================================");
            Output.Debug("");
            Output.Debug("            declare @i_service_id as int set @i_service_id=0x{0:X}", serviceId);
            Output.Debug(SqlQueries.GetServiceInfoSql);
            Output.Debug("=================================================");
            
            using(WstConnection sql = new WstConnection(_uodbConnectionString))
            {
                sql.Open();
               
                WstCommand cmd = sql.CreateCommand();
                cmd.CommandType = CommandType.Text;
                cmd.Partition = WstCommand.AnyPartition;

                // p_livelsp_get_service_info
                // Parameter: @i_service_id
                cmd.CommandText = SqlQueries.GetServiceInfoSql; 
                cmd.Parameters.Add("@i_service_id", SqlDbType.Int).Value = (Int32) serviceId;

                using(WstXmlReader xmlreader = cmd.ExecuteXmlReader())
                {
                    XPathDocument xmldoc = new XPathDocument(xmlreader);
                    return xmldoc;
                }
            }
        }

        public XPathDocument GetSiteServicesInfo(UInt32 siteId)
        {
            Output.Debug("");
            Output.Debug("=================================================");
            Output.Debug("GetSiteServicesInfo SQL");
            Output.Debug("=================================================");
            Output.Debug("");
            Output.Debug("            declare @i_site_id as int set @i_site_id=0x{0:X}", siteId);
            Output.Debug(SqlQueries.GetSiteServicesInfoSql);
            Output.Debug("=================================================");
            
            using(WstConnection sql = new WstConnection(_uodbConnectionString))
            {
                sql.Open();
               
                WstCommand cmd = sql.CreateCommand();
                cmd.CommandType = CommandType.Text;
                cmd.Partition = WstCommand.AnyPartition;

                // p_livelsp_get_site_info
                // Parameter: @i_site_id
                cmd.CommandText = SqlQueries.GetSiteServicesInfoSql; 
                cmd.Parameters.Add("@i_site_id", SqlDbType.Int).Value = (Int32) siteId;

                using(WstXmlReader xmlreader = cmd.ExecuteXmlReader())
                {
                    XPathDocument xmldoc = new XPathDocument(xmlreader);
                    return xmldoc;
                }
            }
        }

        public void MapServiceToSite(UInt32 serviceId, UInt32 siteId, UInt32 titleId)
        {
            Output.Debug("");
            Output.Debug("=================================================");
            Output.Debug("MapServiceToSite SQL");
            Output.Debug("=================================================");
            Output.Debug("");
            Output.Debug("            declare @i_service_id as int set @i_service_id=0x{0:X}", serviceId);
            Output.Debug("            declare @i_site_id as int set @i_site_id=0x{0:X}", siteId);
            Output.Debug("            declare @i_title_id as int set @i_title_id=0x{0:X}", titleId);
            Output.Debug(SqlQueries.MapServiceToSiteSql);
            Output.Debug("=================================================");
            
            if (ReadOnly)
                return;

            using(WstConnection sql = new WstConnection(_uodbConnectionString))
            {
                sql.Open();
               
                WstCommand cmd = sql.CreateCommand();
                cmd.CommandType = CommandType.Text;
                cmd.PartitionType = WstPartitionType.Physical;

                // Parameter: @i_title_id, @i_service_id, @i_site_id
                cmd.CommandText = SqlQueries.MapServiceToSiteSql; 
                cmd.Parameters.Add("@i_service_id", SqlDbType.Int).Value = (Int32) serviceId;
                cmd.Parameters.Add("@i_site_id", SqlDbType.Int).Value = (Int32) siteId;
                cmd.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (Int32) titleId;
                cmd.Parameters.Add("@retval", SqlDbType.BigInt).Direction = ParameterDirection.ReturnValue;

                ExecuteNonQueryOnAllPartitions(sql, cmd);
            }
        }

        public void UnmapServiceFromSite(UInt32 serviceId, UInt32 siteId)
        {
            Output.Debug("");
            Output.Debug("=================================================");
            Output.Debug("UnmapServiceFromSite SQL");
            Output.Debug("=================================================");
            Output.Debug("");
            Output.Debug("            declare @i_service_id as int set @i_service_id=0x{0:X}", serviceId);
            Output.Debug("            declare @i_site_id as int set @i_site_id=0x{0:X}", siteId);
            Output.Debug(SqlQueries.UnmapServiceFromSiteSql);
            Output.Debug("=================================================");
            
            if (ReadOnly)
                return;

            using(WstConnection sql = new WstConnection(_uodbConnectionString))
            {
                sql.Open();
               
                WstCommand cmd = sql.CreateCommand();
                cmd.CommandType = CommandType.Text;
                cmd.PartitionType = WstPartitionType.Physical;

                // Parameter: @i_title_id, @i_service_id, @i_site_id
                cmd.CommandText = SqlQueries.UnmapServiceFromSiteSql; 
                cmd.Parameters.Add("@i_service_id", SqlDbType.Int).Value = (Int32) serviceId;
                cmd.Parameters.Add("@i_site_id", SqlDbType.Int).Value = (Int32) siteId;
                cmd.Parameters.Add("@retval", SqlDbType.BigInt).Direction = ParameterDirection.ReturnValue;

                ExecuteNonQueryOnAllPartitions(sql, cmd);
            }
        }

        public void AddServiceGrantToTitle(UInt32 serviceId, UInt32 titleId)
        {
            Output.Debug("");
            Output.Debug("=================================================");
            Output.Debug("AddServiceGrantToTitle SQL");
            Output.Debug("=================================================");
            Output.Debug("");
            Output.Debug("            declare @i_service_id as int set @i_service_id=0x{0:X}", serviceId);
            Output.Debug("            declare @i_title_id as int set @i_title_id=0x{0:X}", titleId);
            Output.Debug(SqlQueries.AddServiceGrantToTitleSql);
            Output.Debug("=================================================");
            
            if (ReadOnly)
                return;

            using(WstConnection sql = new WstConnection(_uodbConnectionString))
            {
                sql.Open();
               
                WstCommand cmd = sql.CreateCommand();
                cmd.CommandType = CommandType.Text;
                cmd.PartitionType = WstPartitionType.Physical;

                // Parameter: @i_title_id, @i_service_id, @i_site_id
                cmd.CommandText = SqlQueries.AddServiceGrantToTitleSql; 
                cmd.Parameters.Add("@i_service_id", SqlDbType.Int).Value = (Int32) serviceId;
                cmd.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (Int32) titleId;
                cmd.Parameters.Add("@retval", SqlDbType.BigInt).Direction = ParameterDirection.ReturnValue;

                ExecuteNonQueryOnAllPartitions(sql, cmd);
            }
        }

        public void RemoveServiceGrantFromTitle(UInt32 serviceId, UInt32 titleId)
        {
            Output.Debug("");
            Output.Debug("=================================================");
            Output.Debug("RemoveServiceGrantFromTitle SQL");
            Output.Debug("=================================================");
            Output.Debug("");
            Output.Debug("            declare @i_service_id as int set @i_service_id=0x{0:X}", serviceId);
            Output.Debug("            declare @i_title_id as int set @i_title_id=0x{0:X}", titleId);
            Output.Debug(SqlQueries.RemoveServiceGrantFromTitleSql);
            Output.Debug("=================================================");
            
            if (ReadOnly)
                return;

            using(WstConnection sql = new WstConnection(_uodbConnectionString))
            {
                sql.Open();
               
                WstCommand cmd = sql.CreateCommand();
                cmd.CommandType = CommandType.Text;
                cmd.PartitionType = WstPartitionType.Physical;

                // Parameter: @i_title_id, @i_service_id (optional)
                cmd.CommandText = SqlQueries.RemoveServiceGrantFromTitleSql; 
                cmd.Parameters.Add("@i_service_id", SqlDbType.Int).Value = (Int32) serviceId;
                cmd.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (Int32) titleId;
                cmd.Parameters.Add("@retval", SqlDbType.BigInt).Direction = ParameterDirection.ReturnValue;

                ExecuteNonQueryOnAllPartitions(sql, cmd);
            }
        }

        public void AddService(UInt32 siteId, string siteDesc, UInt32 authdataVer, UInt32 serviceId, string serviceDesc)
        {
            // The ids here *must* be converted as unsigned 32-bit integers to strings.  I 
            // can't figure out how to make SQL not do signed 32-bit integers, so we're 
            // doing the conversion here.
            string siteDomain = "site" + siteId.ToString();
            string serviceDomain = "S" + serviceId.ToString();

            Output.Debug("");
            Output.Debug("=================================================");
            Output.Debug("AddSiteAndService SQL");
            Output.Debug("=================================================");
            Output.Debug("");
            Output.Debug("            declare @i_site_id as int set @i_site_id=0x{0:X}", siteId);
            Output.Debug("            declare @i_service_id as int set @i_service_id=0x{0:X}", serviceId);
            Output.Debug("            declare @i_authdata_version as int set @i_authdata_version={0}", authdataVer);
            Output.Debug("            declare @vc_site_desc as nvarchar(100) set @vc_site_desc='{0}'", siteDesc);
            Output.Debug("            declare @vc_service_desc as nvarchar(30) set @vc_service_desc='{0}'", serviceDesc);
            Output.Debug("            declare @vc_site_domain as nvarchar(30) set @vc_site_domain='{0}'", siteDomain);
            Output.Debug("            declare @vc_service_domain as nvarchar(30) set @vc_service_domain='{0}'", serviceDomain);
            Output.Debug(SqlQueries.AddServiceSql);
            Output.Debug("=================================================");
            
            if (ReadOnly)
                return;

            using(WstConnection sql = new WstConnection(_uodbConnectionString))
            {
                sql.Open();
               
                WstCommand cmd = sql.CreateCommand();
                cmd.CommandType = CommandType.Text;
                cmd.PartitionType = WstPartitionType.Physical;

                cmd.CommandText = SqlQueries.AddServiceSql; 
                cmd.Parameters.Add("@i_site_id", SqlDbType.Int).Value = (Int32) siteId;
                cmd.Parameters.Add("@i_service_id", SqlDbType.Int).Value = (Int32) serviceId;
                cmd.Parameters.Add("@i_authdata_version", SqlDbType.Int).Value = (Int32) authdataVer;
                cmd.Parameters.Add("@vc_site_desc", SqlDbType.NVarChar).Value = siteDesc.Substring(0, Math.Min(siteDesc.Length, 100));
                cmd.Parameters.Add("@vc_service_desc", SqlDbType.NVarChar).Value = serviceDesc.Substring(0, Math.Min(serviceDesc.Length, 30));
                cmd.Parameters.Add("@vc_site_domain", SqlDbType.NVarChar).Value = siteDomain;
                cmd.Parameters.Add("@vc_service_domain", SqlDbType.NVarChar).Value = serviceDomain;
                cmd.Parameters.Add("@retval", SqlDbType.BigInt).Direction = ParameterDirection.ReturnValue;

                ExecuteNonQueryOnAllPartitions(sql, cmd);
            }
        }

        public void MapServiceToBaseOffers(UInt32 serviceId)
        {
            Output.Debug("");
            Output.Debug("=================================================");
            Output.Debug("MapServiceToBaseOffers SQL");
            Output.Debug("=================================================");
            Output.Debug("");
            Output.Debug("            declare @i_service_id as int set @i_service_id=0x{0:X}", serviceId);
            Output.Debug(SqlQueries.MapServiceToBaseOffersSql);
            Output.Debug("=================================================");
            
            if (ReadOnly)
                return;

            using(WstConnection sql = new WstConnection(_uodbConnectionString))
            {
                sql.Open();
               
                WstCommand cmd = sql.CreateCommand();
                cmd.CommandType = CommandType.Text;
                cmd.PartitionType = WstPartitionType.Physical;

                cmd.CommandText = SqlQueries.MapServiceToBaseOffersSql; 
                cmd.Parameters.Add("@i_service_id", SqlDbType.Int).Value = (Int32) serviceId;
                cmd.Parameters.Add("@retval", SqlDbType.BigInt).Direction = ParameterDirection.ReturnValue;

                ExecuteNonQueryOnAllPartitions(sql, cmd);
            }
        }

        private void ExecuteNonQueryOnAllPartitions(WstConnection sql, WstCommand cmd)
        {
            int iLoop = 0;
            try
            {
                for (iLoop = 0; iLoop < sql.SqlPartitions.Count; iLoop++)
                {
                    cmd.Partition = iLoop;
                    cmd.ExecuteNonQuery();
                    Output.Debug("Partition {0}: retval={1}", iLoop, System.Convert.ToInt32(cmd.Parameters["@retval"].Value));
                }
            }
            catch (Exception e)
            {
                throw new LiveLspDbException("Failed for partition " + iLoop, e);
            }
        }


        private string      _uodbConnectionString;

    } // }}} class Uodb

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\lsp\exe\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\lsp\exe\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\lsp\Output.cs ===
// --------------------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved
//
// output.cs
//
// LiveLsp output classes
//
// --------------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;

namespace xonline.tools.livelsp
{

    public class Output
    {
        public enum Level
        {
            Debug   = 0x01,
            Info    = 0x02,
            Error   = 0x04
        }

        public static void AddOutputDestination(OutputDestination dest)
        {
            _Destinations.Add(dest);
        }

        public static void AddLevel(Level l)
        {
            foreach (OutputDestination dest in _Destinations)
            {
                dest.AddLevel(l);
            }
        }

        public static void RemoveLevel(Level l)
        {
            foreach (OutputDestination dest in _Destinations)
            {
                dest.RemoveLevel(l);
            }
        }

        public static void Debug(string fmt, params object[] prms)
        {
            Out(Level.Debug, fmt + "\r\n", prms);
        }

        public static void Info(string fmt, params object[] prms)
        {
            Out(Level.Info, fmt + "\r\n", prms);
        }

        public static void Error(string fmt, params object[] prms)
        {
            Out(Level.Error, fmt + "\r\n", prms);
        }

        public static void OutPairs(Level level, int indent, params string[] values)
        {
            int pad = 35-indent;

            for(int i=0; i < values.Length; i+=2)
            {
                Out(level, String.Empty.PadRight(indent) +
                           values[i].PadRight(pad) + " : ");

                if(i + 1 < values.Length)
                {
                    Out(level, values[i+1] + "\r\n");
                }
            }
        }

        public static void Out(Level level, string fmt, params object[] prms)
        {
            foreach (OutputDestination dest in _Destinations)
            {
                if ((dest.OutputLevel & level) == level)
                {
                    dest.FormatOutput(level, fmt, prms);
                }
            }
        }

        protected static List<OutputDestination> _Destinations = new List<OutputDestination>();

    }

    public abstract class OutputDestination 
    {
        public void AddLevel(Output.Level l)
        {
            _OutputLevel |= l;
        }

        public void RemoveLevel(Output.Level l)
        {
            _OutputLevel &= ~l;
        }

        public Output.Level OutputLevel
        {
            get { return _OutputLevel; }
            set { _OutputLevel = value; }
        }

        public abstract void FormatOutput(Output.Level level, string fmt, params object[] prms);

        private Output.Level _OutputLevel = (Output.Level.Info | Output.Level.Error);
    }

    public class ConsoleOutput : OutputDestination
    {
        public override void FormatOutput(Output.Level level, string fmt, params object[] prms)
        {
            ConsoleColor cc = ConsoleColor.Gray;
            switch (level)
            {
            case Output.Level.Debug:
                cc = ConsoleColor.DarkGray;
                break;
            case Output.Level.Info:
                cc = ConsoleColor.Gray;
                break;
            case Output.Level.Error:
                cc = ConsoleColor.Red;
                break;
            }
            Console.ForegroundColor = cc;
            Console.Write(string.Format(fmt, prms));
            Console.ResetColor();
        }
    }
    
    public class TextFileOutput : OutputDestination
    {
        public TextFileOutput(string filename)
        {
            _sw = File.CreateText(filename);
        }

        public override void FormatOutput(Output.Level level, string fmt, params object[] prms)
        {
            if (level == Output.Level.Error)
                _sw.Write("[ERROR] " + string.Format(fmt, prms));
            else
                _sw.Write(string.Format(fmt, prms));
            _sw.Flush();
        }

        protected StreamWriter _sw;
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\lsp\QueryAction.cs ===
// --------------------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved
//
// QueryAction.cs
//
// LiveLsp
//
// Process the Query command
// --------------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Xml;
using System.Xml.XPath;

using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.diagnostics;
using xonline.common.sql.webstore;
using xonline.common.tools.console;
using xonline.common.tools;

namespace xonline.tools.livelsp
{
    public class QueryAction
    {
        public QueryAction()
        {
        }

        public void Process(NamedArgParser args)
        {
            // Parse command-line args
            ParseArguments(args);

            Uodb uodb = new Uodb(args);
            Npdb npdb = new Npdb(args);

            if (_args.title_specified)
            {
                XPathDocument xmlTitle = uodb.GetTitleInfo(_args.title);
                XPathNavigator xpath = xmlTitle.CreateNavigator();
                Output.Debug("=================================================");
                Output.Debug("SQL XML from GetTitleInfo");
                Output.Debug("=================================================");
                Output.Debug(xpath.OuterXml);
                Output.Debug("=================================================");
                DumpXml(xpath);
            }

            if (_args.service_specified)
            {
                XPathDocument xmlService = uodb.GetServiceInfo(_args.service);
                XPathNavigator xpath = xmlService.CreateNavigator();
                Output.Debug("=================================================");
                Output.Debug("SQL XML from GetServiceInfo");
                Output.Debug("=================================================");
                Output.Debug(xpath.OuterXml);
                Output.Debug("=================================================");
                DumpXml(xpath);
            }

            if (_args.site_specified)
            {
                XPathDocument xmlSite = npdb.GetSiteInfo(_args.site);
                XPathNavigator xpath = xmlSite.CreateNavigator();
                Output.Debug("=================================================");
                Output.Debug("SQL XML from GetSiteInfo");
                Output.Debug("=================================================");
                Output.Debug(xpath.OuterXml);
                Output.Debug("=================================================");
                DumpXml(xpath);

                XPathDocument xmlServices = uodb.GetSiteServicesInfo(_args.site);
                XPathNavigator xpathServices = xmlServices.CreateNavigator();
                Output.Debug("=================================================");
                Output.Debug("SQL XML from GetServicesInfo");
                Output.Debug("=================================================");
                Output.Debug(xpathServices.OuterXml);
                Output.Debug("=================================================");
                DumpXml(xpathServices);
            }
        }

        public void DumpXml(XPathNavigator xpath)
        {
            XPathNodeIterator iter;

            if (!xpath.MoveToFirstChild())
            {
                Output.Error("Couldn't move to first child");
                return;
            }

            do
            {
                switch (xpath.LocalName)
                {
                case "error":
                    Output.Info("");
                    Output.Info("Error executing query:");
                    Output.Info("Message : {0}", Value("message", xpath));
                    Output.Info("Param   : {0}", Value("param", xpath));
                    break;
    
                case "site-info":
                    Output.Info("");
                    Output.Info("=================================================");
                    Output.Info("Site: {0}", ValueAsHexAndInt("site-id", xpath));
                    Output.Info("=================================================");
                    Output.Info("Service name    : {0}", Value("service-name", xpath));
                    Output.Info("Service domain  : {0}", Value("domain-name", xpath));
                    Output.Info("IP              : {0}", Value("ip", xpath));
                    Output.Info("Authdata ver    : {0}", Value("authdata-version", xpath));
                    if (xpath.SelectSingleNode("key-info") != null)
                    {
                        Output.Info("Ticket lifetime : {0} seconds", Value("key-info/ticket-lifetime", xpath)); 
                        Output.Info("Master key ver  : {0}", Value("key-info/master-key-version", xpath));
                        Output.Info("Key ver         : {0}", Value("key-info/key-version", xpath));
                    }
                    else
                    {
                        Output.Error("Site key        : Not found! Check t_service_keys.");
                    }
                    Output.Info("");
                    break;
    
                case "services":
                    iter = xpath.Select("/services/service");
                    if (iter.Count > 0)
                    {
                        Output.Info("Services associated with site {0}", ValueAsHexAndInt("site-id", xpath));
                        Output.Info("[t_service_instances]");
                        Output.Info("=================================================");
                        Output.Info("");
                        while (iter.MoveNext())
                        {
                            Output.Info("Service         : {0}", ValueAsHexAndInt("service-id", iter.Current));
                            Output.Info("Description     : {0}", Value("description", iter.Current));
                            Output.Info("Association     : {0}",
                                iter.Current.GetAttribute("type", String.Empty) == "all" ?
                                "all titles (i_title_id = 0)" : "specific title(s) (i_title_id > 0)");
                            Output.Info("");
                        }
                    }
                    
                    break;
    
                case "service-info":
                    Output.Info("");
                    Output.Info("=================================================");
                    Output.Info("Service: {0}", ValueAsHexAndInt("service-id", xpath));
                    Output.Info("=================================================");
                    Output.Info("Description     : {0}", Value("description", xpath));
                    Output.Info("Service name    : {0}", Value("service-name", xpath));
                    Output.Info("Service domain  : {0}", Value("domain-name", xpath));
                    Output.Info("Machine only    : {0}", Value("machine-only", xpath));
                    Output.Info("Num sites       : {0}", xpath.Select("sites/site").Count);
                    Output.Info("");
                    iter = xpath.Select("/service-info/sites/site");
                    if (iter.Count > 0)
                    {
                        Output.Info("Sites associated with service {0}", ValueAsHexAndInt("service-id", xpath));
                        Output.Info("[t_service_instances]");
                        Output.Info("=================================================");
                        Output.Info("");
                        while (iter.MoveNext())
                        {
                            Output.Info("Site            : {0}", ValueAsHexAndInt("site-id", iter.Current));
                            Output.Info("Authdata Ver    : {0}", Value("authdata-version", iter.Current));
                            Output.Info("");
                        }
                    }
                    iter = xpath.Select("/service-info/title-services/title");
                    if (iter.Count > 0)
                    {
                        Output.Info("Titles that grant service {0}", ValueAsHexAndInt("service-id", xpath));
                        Output.Info("[t_title_services]");
                        Output.Info("=================================================");
                        Output.Info("");
                        while (iter.MoveNext())
                        {
                            Output.Info("Title           : {0}", ValueAsHexAndInt("title-id", iter.Current));
                            Output.Info("Name            : {0}", Value("name", iter.Current));
                            Output.Info("");
                        }
                    }
                    iter = xpath.Select("/service-info/service-instances/title");
                    if (iter.Count > 0)
                    {
                        Output.Info("Titles associated with service {0}", ValueAsHexAndInt("service-id", xpath)); 
                        Output.Info("[t_service_instances]");
                        Output.Info("=================================================");
                        Output.Info("");
                        while (iter.MoveNext())
                        {
                            Output.Info("Title           : {0}", ValueAsHexAndInt("title-id", iter.Current));
                            Output.Info("Name            : {0}", Value("name", iter.Current));
                            Output.Debug("Version         : {0}", Value("version", iter.Current));
                            Output.Debug("Region          : {0}", Value("region", iter.Current));
                            Output.Debug("Site            : {0}", ValueAsHexAndInt("site-id", iter.Current));
                            Output.Debug("Port            : {0}", Value("port", iter.Current));
                            Output.Debug("Svc Available   : {0}", Value("service-available", iter.Current));
                            Output.Debug("Authdata Ver    : {0}", Value("authdata-version", iter.Current));
                            Output.Info("");
                        }
                    }
                    break;
                        
                case "title-info":
                    Output.Info("");
                    Output.Info("=================================================");
                    Output.Info("Title: {0}", ValueAsHexAndInt("title-id", xpath));
                    Output.Info("=================================================");
                    Output.Info("Name            : {0}", Value("name", xpath));
                    Output.Info("Xbox1 Versions  : {0} (count)", xpath.Select("title-versions/title-version[@console-type=0]").Count);
                    Output.Info("Xenon Versions  : {0} (count)", xpath.Select("title-versions/title-version[@console-type=2]").Count);
                    Output.Info("PC Versions     : {0} (count)", xpath.Select("title-versions/title-version[@console-type=4]").Count);
                    Output.Info("");
                    iter = xpath.Select("/title-info/title-services/service");
                    if (iter.Count > 0)
                    {
                        Output.Info("Services granted by title {0}", ValueAsHexAndInt("title-id", xpath));
                        Output.Info("[t_title_services]");
                        Output.Info("=================================================");
                        Output.Info("");
                        while (iter.MoveNext())
                        {
                            Output.Info("Service         : {0}", ValueAsHexAndInt("service-id", iter.Current));
                            Output.Info("Description     : {0}", Value("description", iter.Current));
                            Output.Info("");
                        }
                    }
                    iter = xpath.Select("/title-info/service-instances/service");
                    if (iter.Count > 0)
                    {
                        Output.Info("Services associated with title {0}", ValueAsHexAndInt("title-id", xpath));
                        Output.Info("[t_service_instances]");
                        Output.Info("=================================================");
                        Output.Info("");
                        while (iter.MoveNext())
                        {
                            Output.Info("Service         : {0}", ValueAsHexAndInt("service-id", iter.Current));
                            Output.Info("Description     : {0}", Value("description", iter.Current));
                            Output.Info("Site            : {0}", ValueAsHexAndInt("site-id", iter.Current));
                            Output.Info("Title Version   : {0}", ValueAsHexAndInt("title-version", iter.Current));
                            Output.Info("Title Region    : {0}", ValueAsHexAndInt("title-region", iter.Current));
                            Output.Info("");
                        }
                        Output.Info("");
                    }
                    break;
                }
            } while (xpath.MoveToNext());
            xpath.MoveToParent();
        }
        

        private static string Value(string nodepath, XPathNavigator xpath)
        {
            XPathNavigator node = xpath.SelectSingleNode(nodepath);
            if (node == null)
                return "n/a";
            return node.Value;
        }

        private static string ValueAsHexAndInt(string nodepath, XPathNavigator xpath)
        {
            XPathNavigator node = xpath.SelectSingleNode(nodepath);
            if (node == null)
                return "n/a";
            int v = node.ValueAsInt;
            return String.Format("0x{0:X8} ({1})", v, v);
        }

        private static int GetInt(string nodepath, XPathNavigator xpath)
        {
            XPathNavigator node = xpath.SelectSingleNode(nodepath);
            if (node == null)
                return 0;
            return node.ValueAsInt;
        }

        private void ParseArguments(NamedArgParser args)
        {
            if(args["help"] != null || args["h"] != null || args["?"] != null)
            {
                PrintUsageConfig();
            }
            
            try
            {
                _args = new Arguments(args);
            }
            catch (LiveLspBadArgumentException e)
            {
                Output.Error(e.Message + "\n");
                PrintUsageConfig();
                return;
            }

            Output.Debug("Arguments:");
            _args.Dump();
            Output.Debug("");
        }

        private static void PrintUsageConfig()
        {
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890123456789
            string helpText = @"
LiveLsp.exe -query [options...]
LiveLsp.exe -q [options...]

Notes: 
    All ids may be given as hex (with 0x) or decimal.

Options:
    -titleid:<title-id>

        Query information for a title.

    -service:<service-id>

        Query information for a service.

    -site:<site-id>

        Query information for a site.

Examples:

LiveLsp.exe -q -titleid:1297287121

LiveLsp.exe -q -titleid:0x4D5307D1 -verbose

LiveLsp.exe -q -service:0x4D530000 -verbose -outfile:output.txt
            ";

            Output.Info(helpText);
            System.Environment.Exit(-1);
        }

        // class Arguments
        // {{{
        private class Arguments
        {
            public UInt32   title;
            public bool     title_specified;
            public UInt32   service;
            public bool     service_specified;
            public UInt32   site;
            public bool     site_specified;

            public Arguments(NamedArgParser args)
            {
                if (args["titleid"] != null)
                {
                    this.title = args.ParseUInt("titleid");
                    this.title_specified = true;

                    if(this.title == 0)
                    {
                        throw new LiveLspBadArgumentException("Invalid -titleid.");
                    }
                }

                if (args["service"] != null)
                {
                    this.service = args.ParseUInt("service");
                    this.service_specified = true;

                    if(this.service == 0)
                    {
                        throw new LiveLspBadArgumentException("Invalid -service.");
                    }
                }

                if(args["site"] != null)
                {
                    this.site = args.ParseUInt("site");
                    this.site_specified = true;

                    if(this.site == 0)
                    {
                        throw new LiveLspBadArgumentException("Invalid -site.");
                    }
                }
                else
                {
                    this.site = service;
                    this.site_specified = false;
                }

                if (!title_specified && !service_specified && !site_specified)
                {
                    throw new LiveLspBadArgumentException("No switches specified, must supply at least one item to query.");
                }
            } // Arguments

            public void Dump()
            {
                Output.OutPairs(
                    Output.Level.Debug,
                    2, 
                    "titleid", "0x" + this.title.ToString("X"),
                    "titleid_specified", this.title_specified.ToString(),
                    "service", "0x" + this.service.ToString("X"),
                    "service_specified", this.service_specified.ToString(),
                    "site", "0x" + this.site.ToString("X"),
                    "site_specified", this.site_specified.ToString());
            }
        } // class Arguments
        // }}}

        private Arguments _args;

    } // end class QueryAction

} // end namespace xonline.tools.livelsp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\lsp\LiveLsp.cs ===
// --------------------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved
//
// LiveLsp.cs
//
// LiveLsp
//
// main file
// --------------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Xml;
using System.Xml.XPath;

using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.diagnostics;
using xonline.common.sql.webstore;
using xonline.common.tools.console;
using xonline.common.tools;

namespace xonline.tools.livelsp
{
    public class LiveLsp
    {
        // Operate in read-only mode?
        public static bool ReadOnly = false;

        // Default output filename. We always spew all output to a file.
        public static string OutputFilename = "livelsp.log";

        static int Main(string[] rawargs)
        {
            try
            {
                // Console output
                OutputDestination destConsole = new ConsoleOutput();
                Output.AddOutputDestination(destConsole);

                NamedArgParser args = new NamedArgParser();
                args.Parse(rawargs);

                // File output
                if (args["outfile"] != null)
                {
                    if (args["outfile"] == "")
                    {
                        PrintUsage();
                        return 1;
                    }
                    OutputFilename = args["outfile"];
                }
                OutputDestination destText = new TextFileOutput(OutputFilename);
                // File output always gets verbose text regardless of -verbose flag.
                destText.AddLevel(Output.Level.Debug);
                Output.AddOutputDestination(destText);

                // Extra text to all destinations if -verbose switch specified
                if (args["verbose"] != null || args["v"] != null)
                {
                    Output.Debug("Enabled verbose output");
                    Output.AddLevel(Output.Level.Debug);
                }

                // No console output?
                if (args["silent"] != null)
                {
                    Output.Debug("Enabling silent output");
                    destConsole.RemoveLevel(Output.Level.Debug | Output.Level.Info);
                }

                // Operate in read-only mode?
                if (args["readonly"] != null)
                {
                    ReadOnly = true;
                }

                //
                // Do actions
                // 

                if (args["query"] != null ||
                    args["q"] != null)
                {
                    (new QueryAction()).Process(args);
                }
                else if (args["configpartner"] != null ||
                         args["cp"] != null)
                {
                    (new ConfigPartnerAction()).Process(args);
                }
                else if (args["configtitle"] != null ||
                         args["ct"] != null)
                {
                    (new ConfigTitleAction()).Process(args);
                }
                else 
                {
                    PrintUsage();
                    return 1;
                }
            }
            catch (LiveLspException e)
            {
                Output.Error(e.Message);
                return 2;
            }
            catch (ArgumentException e)
            {
                Output.Error("Error parsing command-line parameters:");
                Output.Error(e.Message);
                return 3;
            }
            catch (LiveLspBadArgumentException e)
            {
                Output.Error("Error parsing command-line parameters:");
                Output.Error(e.Message);
                return 4;
            }
            catch (LiveLspDbException e)
            {
                Output.Error(e.Message);
                Output.Error(e.InnerException.Message);
                return 5;
            }
            catch (LiveLspConfigException e)
            {
                Output.Error("Fatal error encountered: {0}", e.Message);
                return 6;
            }
            catch (WstException e)
            {
                Output.Error("Webstore error:");
                Output.Error(e.Message);
                return 7;
            }
            catch (SqlException e)
            {
                Output.Error("SQL error 0x{0:X} from server {1}:", e.ErrorCode, e.Server);
                Output.Error(e.Message);
                return 8;
            }
            catch (Exception e)
            {
                Output.Error("Unhandled exception:\n" + e.ToString());
                return 9;
            }

            return 0;
        }

        private static void PrintUsage()
        {
//       1         2         3         4         5         6         7         8
//34567890123456789012345678901234567890123456789012345678901234567890123456789012345678
            string helpText = @"
LiveLsp.exe [command] [command options...] [extra options...]

Notes:
    All parameters may be given in any order. Any parameter surrounded by 
    brackets is optional. The extra options are common to all commands.

Commands:

    -query
    -q
        
        Displays information for a title, service, or site. Does not modify 
        anything.  Additional help is available for this command.

    -configtitle
    -ct

        Configures an XLSP title for an existing partner/site/service. This 
        does work in the UODB and NPDB. Additional help is available for this 
        command.
   
    -configpartner
    -cp

        Configures an XLSP partner (services and sites for now). This performs 
        work in the UODB and WEBDB. Only the UODB work has been implemented, 
        the WEBDB work is in progress.  Additional help is available for this 
        command.

Command Options:

    These parameters depend on the command given and are discussed in the help 
    for each command.

Extra options:
    [-verbose]         : Print verbose debugging information to the screen.
    [-v]               : Same as -verbose.
    [-readonly]        : Do not execute SQL statements.
    [-noreload]        : Do not reload the XKDC automatically.
    [-outfile:<file>]  : Override output filename. Default is livelsp.log.
    [-silent]          : No output to the console.
            ";

            Output.Info(helpText);
        }
    }
    
    public class LiveLspException : Exception
    {
        public LiveLspException(string message) :
            base(message)
        {
        }

        public LiveLspException(string format, params object[] args) :
            base(String.Format(format, args))
        {
        }
    }

    public class LiveLspBadArgumentException : Exception
    {
        public LiveLspBadArgumentException(string message) :
            base(message)
        {
        }
    }
    
    public class LiveLspConfigException : Exception
    {
        public LiveLspConfigException(string message) :
            base(message)
        {
        }
    }

    public class LiveLspDbException : Exception
    {
        public LiveLspDbException(string message) :
            base(message)
        {}

        public LiveLspDbException(string message, Exception inner) :
            base(message, inner)
        {}
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\lsp\LiveLspUtils.cs ===
// --------------------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved
//
// LiveLspUtils.cs
//
// LiveLspUtils
//
// Static utility functions 
// --------------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Xml;
using System.Xml.XPath;
using System.Text;

using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.diagnostics;
using xonline.common.sql.webstore;
using xonline.common.tools.console;
using xonline.common.tools;
using xonline.common.mgmt;

namespace xonline.tools.livelsp
{
    public class LiveLspUtils
    {

        public static bool CreateSiteKey(UInt32 siteId, string masterKeyFile, UInt32 ticketLifetimeInSecs)
        {
            // Sample of a "real" xkeymgr call to create a site key:
            // xkeymgr addfreq 6 1 masterkey.pub -d1 ts -s 1297287142 -c 0x4D5307E6.ini
            //
            // Site must be given in base-10 format. 

            Output.Debug("");
            Output.Debug("=================================================");
            Output.Debug("Creating site key");
            Output.Debug("=================================================");

            bool ok = false;
            string siteKeyFile = String.Format("Site{0}Key.ini", siteId);
            string xkeymgrArgs = String.Format("addfreq 6 1 {0} -d1 ts -s {1} -c {2} -l {3}",
                                              masterKeyFile,
                                              siteId,
                                              siteKeyFile,
                                              ticketLifetimeInSecs);
            // Sanity checks
            if (!File.Exists(masterKeyFile))
            { 
                Output.Error("Unable to find the master key file \"{0}\". Please create a site key manually by running:", masterKeyFile);
                Output.Error("xkeymgr.exe {0}", xkeymgrArgs);
                return false;
            }

            // Check for xkeymgr executable in path?

            // Run it
            Output.Debug("Running: xkeymgr.exe {0}", xkeymgrArgs);

            if (LiveLsp.ReadOnly)
            {
                Output.Info("[Previous command not run, read-only mode was specified]");
                return true;
            }

            StringBuilder stdout = new StringBuilder();
            StringBuilder stderr = new StringBuilder();
            Process p = new Process();
            p.StartInfo.FileName = "xkeymgr.exe";
            p.StartInfo.Arguments = xkeymgrArgs;
            p.StartInfo.RedirectStandardOutput = true;
            p.StartInfo.RedirectStandardError = true;
            p.StartInfo.UseShellExecute = false;

            p.OutputDataReceived += delegate(object sender, DataReceivedEventArgs args) { if (!String.IsNullOrEmpty(args.Data)) stdout.AppendLine(args.Data); };
            p.ErrorDataReceived += delegate(object sender, DataReceivedEventArgs args) { if (!String.IsNullOrEmpty(args.Data)) stderr.AppendLine(args.Data); };

            string output;
            string error;
            
            try
            {
                p.Start();
                p.BeginOutputReadLine();
                p.BeginErrorReadLine();

                // Read the output stream before waiting for the process to finish. This 
                // avoids a deadlock situation where the output buffer fills up and halts 
                // the process.
                
                if (!p.WaitForExit(30000))
                {
                    Output.Error("Timed out waiting for xkeymgr to run. Please verify xkeymgr.exe is no longer running and the site key was properly created. Command was:");
                    Output.Error("xkeymgr.exe {0}", xkeymgrArgs);
                    p.CancelOutputRead();
                    p.CancelErrorRead();
                }

                output = stdout.ToString();
                // Verify success or failure by examining the output
                if (output.Contains("The key has been encrypted"))
                {
                    ok = true;
                }
            }
            catch (Exception e)
            {
                Output.Error("Error executing xkeymgr.exe: {0}", e.Message);
                return false;
            }
            finally
            {
                try
                {
                    // Since this is LSP, we don't need the generated site key file. Get 
                    // rid of it!
                    Output.Debug("Removing temporary site key file \"{0}\"...", siteKeyFile);
                    File.Delete(siteKeyFile);
                }
                catch (Exception e)
                {
                    Output.Debug("Error deleting temporary site key file \"{0}\": {1}", siteKeyFile, e.Message);
                }
            }

            Output.Debug("Output from running \"{0} {1}\":", p.StartInfo.FileName, p.StartInfo.Arguments);
            Output.Debug(output);

            error = stderr.ToString();
            if (!String.IsNullOrEmpty(error))
            {
                Output.Debug("Error output from running \"{0} {1}\":", p.StartInfo.FileName, p.StartInfo.Arguments);
                Output.Debug(error);
            }

            if (ok)
            {
                Output.Debug("Site key appears to have been successfully created. Exit code={0}", p.ExitCode);
            }
            else
            {
                Output.Error("Site key creation appears to have failed, please consult debug output for details.");
                Output.Error("Output from running \"{0} {1}\":", p.StartInfo.FileName, p.StartInfo.Arguments);
                Output.Info(output);
            }
            Output.Debug("");
            
            return ok;
        }

        public static void ReloadXkdc()
        {
            // Reload title info, services, sites from Uodb
            SendXmgmtCommand(Interface.kdcsvc, "xkdc", "reload");
        }

        public static void ReloadLivepxyTitles()
        {
            // Reload title info from WebDb
            SendXmgmtCommand(Interface.livepxy, "livepxy", "reloadtitles");
        }

        public static void ReloadLivepxyPartners()
        {
            // Reload partner info from WebDb
            SendXmgmtCommand(Interface.livepxy, "livepxy", "reloadpartners");
        }

        public static void ReloadLivepxyKeys()
        {
            // Reload site key information from Uodb 
            SendXmgmtCommand(Interface.livepxy, "livepxy", "reloadkeys");
        }

        private static bool SendXmgmtCommand(string serverInterface, string component, string command)
        {
            bool ok = true;
            int result = 0;

            //need to loop through each of the servers in the Virtual Interface...
            string[] serverList = Config.GetServerListByInterface( serverInterface );
            string[] responses = null;
            string strCommand = "";
            IInterfaceInfo svrIFaceInfo;

            foreach( string server in serverList )
            {
                try
                {
                    svrIFaceInfo = Config.GetInterface( server, Interface.xmgmtsrv );
                    if (svrIFaceInfo == null)
                    {
                        svrIFaceInfo = Config.GetInterface( server, serverInterface );
                    }
                }
                catch (Exception e)
                {
                    Output.Error("A serious error occurred while retrieving data from ConfigDB for {0}", server);
                    Output.Error("Exception: {0}", e.Message);
                    ok = false;
                    continue;
                }

                try
                {
                    strCommand = String.Format("\"e :{0} {1}\" on {2} ({3})", 
                        component, command, server, svrIFaceInfo.IPAddress.ToString());
                    Output.Debug("Running {0}", strCommand);

                    if (LiveLsp.ReadOnly)
                    {
                        Output.Info("[Previous command for {0} not run, read-only mode was specified]", server);
                        continue;
                    }

                    // 90 second timeout is arbitrary, but what else can we do? It seems 
                    // the XKDC in Production takes ~ 30 seconds to reload. See bug 99228.
                    XomAdminSession xmgmt = new XomAdminSession( svrIFaceInfo.IPAddress );
                    xmgmt.SendCommand( null, component, command, 90000, out responses, out result);

                    if (result != 0)
                    {
                        Output.Error("Warning: command returned hr=0x{0:X8} for cmd {1}", result, strCommand);
                    }
                    foreach( string response in responses )
                    {
                        Output.Info(response);
                    }
                }
                catch ( Exception e )
                {
                    Output.Error("A serious error occurred while running xmgmtc command: {0}", strCommand);
                    Output.Error("Exception: {0}", e.Message);
                    ok = false;
                    continue;
                }
            }

            return ok;
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\lsp\test\functional\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\match\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\lsp\test\functional\LiveLSPHelp.cs ===
//#define IGNORE_SERVICE_ERRORS
//#define IGNORE_LIVEPROXY_KEY_RELOADS
#define IGNORE_LIVEPROXY_WEBDB_RELOADS

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Data.SqlClient;
using System.IO;
using System.Text;
using System.Threading;

//using Microsoft.Webstore.WstClient;
using ServerTestFramework;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Utilities;
//using STF.common.sql.webstore;
using xonline.common.config;
using ServerTestFramework.LiveService;

namespace LiveLSPTest
{
    /// <summary>
    /// A generic database table class.  Allows reading of entire tables and comparing different versions.
    /// </summary>
    public class GenericTable
    {
        public class Column
        {
            public string Name;
            public Type Type;
        }

        public enum RowSource { Read, Insert, Update, Old, Delete, Current, Exists, NotExists }

        public class Row
        {
            public RowSource Source;
            public object[] Data;
            public bool Marked;

            public Row (RowSource source, object[] data) { Source = source; Data = data; Marked = false; }

            public override string ToString ()
            {
                StringBuilder buff = new StringBuilder();

                switch (Source)
                {
                    case RowSource.Delete: buff.Append("[Del] "); break;
                    case RowSource.Insert: buff.Append("[Ins] "); break;
                    case RowSource.Read: buff.Append("[Rd ] "); break;
                    case RowSource.Old: buff.Append("[Old] "); break;
                    case RowSource.Update: buff.Append("[Upd] "); break;
                    case RowSource.Current: buff.Append("[Cur] "); break;
                }

                foreach (object obj in Data)
                {
                    if (obj == null || obj == DBNull.Value)
                    {
                        buff.Append("<null> | ");
                    }
                    else
                    {
                        buff.Append(obj.ToString());
                        buff.Append(" | ");
                    }
                }

                return buff.ToString(0, buff.Length - 3);
            }
        }

        protected string _tableName;
        protected string[] _primaryKeys;
        protected int _colCount;
        protected Column[] _columns;
        protected List<Row> _data;

        /// <summary>
        /// Creates an empty table, not safe to leave like this.
        /// </summary>
        protected GenericTable ()
        {
            _tableName = null;
            _primaryKeys = null;
            _colCount = 0;
            _columns = null;
            _data = null;
        }

        /// <summary>
        /// Reads the table into memory and creates the table object.
        /// </summary>
        /// <param name="server">The server to read from.</param>
        /// <param name="name">The name of the table to read.</param>
        /// <param name="command">The command to read with.  Must support appending an order by.</param>
        /// <param name="primaryKeys">The keys to sort/compare on.</param>
        protected GenericTable (string server, string database, string name, string command, string[] primaryKeys)
        {
            _tableName = server + "." + name;
            _primaryKeys = (string[]) primaryKeys.Clone();

            SqlConnectionStringBuilder connStr = new SqlConnectionStringBuilder();
            connStr.DataSource = server;
            connStr.InitialCatalog = database;
            connStr.IntegratedSecurity = true;

            SqlConnection conn = new SqlConnection(connStr.ConnectionString);

            command += " order by ";

            for (int i = 0; i < _primaryKeys.Length; ++i)
            {
                if (i > 0)
                {
                    command += ", ";
                }
                command += _primaryKeys[i];
            }

            conn.Open();
            SqlCommand comm = new SqlCommand(command, conn);
            comm.CommandType = System.Data.CommandType.Text;

            try
            {
                SqlDataReader reader = comm.ExecuteReader();

                // extract column information
                _colCount = reader.FieldCount;

                _columns = new Column[_colCount];

                for (int i = 0; i < _colCount; ++i)
                {
                    _columns[i] = new Column();
                    _columns[i].Name = reader.GetName(i);
                    _columns[i].Type = reader.GetFieldType(i);
                }

                _data = new List<Row>();

                while (reader.Read())
                {
                    Row row = new Row(RowSource.Read, new object[_colCount]);

                    if (reader.GetValues(row.Data) != _colCount)
                    {
                        reader.Close();
                        throw new Exception("Attempt to read row of data did not return the expected number of results.");
                    }

                    _data.Add(row);
                }

                reader.Close();
            }
            finally
            {
                conn.Close();
            }
        }

        /// <summary>
        /// Reads the table into memory and creates the table object.
        /// </summary>
        /// <param name="server">The server to read from.</param>
        /// <param name="table">The table to read.</param>
        /// <param name="primaryKeys">The keys to sort/compare on.</param>
        /// <param name="where">The conditions to give in the where clause.</param>
        protected static GenericTable _ReadTable (string server, string database, string table, string[] primaryKeys, string where)
        {
            string command = "select * from " + table + (where != null ? " where " + where : "");
            return new GenericTable(server, database, table, command, primaryKeys);
        }

        /// <summary>
        /// Reads the table into memory and creates the table object.
        /// </summary>
        /// <param name="server">The server to read from.</param>
        /// <param name="table">The table to read.</param>
        /// <param name="primaryKey">The key to sort/compare on.</param>
        /// <returns>A table object that contains the data from the table.</returns>
        public static GenericTable ReadTable (string server, string database, string table, string primaryKey)
        {
            return _ReadTable(server, database, table, new string[] { primaryKey }, null);
        }

        /// <summary>
        /// Reads the table into memory and creates the table object.
        /// </summary>
        /// <param name="server">The server to read from.</param>
        /// <param name="table">The table to read.</param>
        /// <param name="primaryKeys">The keys to sort/compare on.</param>
        /// <returns>A table object that contains the data from the table.</returns>
        public static GenericTable ReadTable (string server, string database, string table, string[] primaryKeys)
        {
            return _ReadTable(server, database, table, primaryKeys, null);
        }

        /// <summary>
        /// Reads the table into memory and creates the table object.
        /// </summary>
        /// <param name="server">The server to read from.</param>
        /// <param name="table">The table to read.</param>
        /// <param name="primaryKeys">The keys to sort/compare on.</param>
        /// <returns>A table object that contains the data from the table.</returns>
        public static GenericTable ReadTable (string server, string database, string table, string[] primaryKeys, string where)
        {
            return _ReadTable(server, database, table, primaryKeys, where);
        }

        /// <summary>
        /// Reads a select statement as a table under the given name.
        /// </summary>
        /// <param name="server">The server to read from.</param>
        /// <param name="name">The name to give the view.</param>
        /// <param name="statement">The select statement that defines the view.</param>
        /// <param name="primaryKeys">The keys to sort/compare on.</param>
        /// <returns>A table object that contains the data from the view.</returns>
        public static GenericTable ReadView (string server, string database, string name, string statement, string[] primaryKeys)
        {
            return new GenericTable(server, database, name, statement, primaryKeys);
        }

        /// <summary>
        /// Compares the two tables and returns another that contains changed (or new) rows.
        /// </summary>
        /// <param name="older">The older read of a table.</param>
        /// <param name="newer">The newer read of a table.</param>
        /// <returns>The difference between the tables.  Any differences will cause an entire row to be returned.</returns>
        public static GenericTable DetectChanges (GenericTable older, GenericTable newer)
        {
            if (older._tableName != newer._tableName)
            {
                throw new ArgumentException("Cannot compare tables with different names.");
            }

            if (older._primaryKeys.Length != newer._primaryKeys.Length)
            {
                throw new ArgumentException("Cannot compare tables with different primary keys.");
            }

            for (int i = 0; i < older._primaryKeys.Length; ++i)
            {
                if (older._primaryKeys[i] != newer._primaryKeys[i])
                {
                    throw new ArgumentException("Cannot compare tables with different primary keys.");
                }
            }

            // create new table and copy column information
            GenericTable ans = new GenericTable();

            ans._tableName = older._tableName;
            ans._primaryKeys = (string[]) older._primaryKeys.Clone();
            ans._colCount = older._colCount;
            ans._columns = older._columns; // shallow copy, but this is internal and not modified
            ans._data = new List<Row>();

            // check that all columns can be compared
            for (int i = 0; i < ans._columns.Length; ++i)
            {
                Type elementType = ans._columns[i].Type;

                if (elementType.IsArray)
                {
                    elementType = elementType.GetElementType();
                }

                if (elementType.GetInterface(typeof(IComparable).Name) == null)
                {
                    throw new Exception("Column '" + ans._columns[i].Name + "' does not implement IComparable.");
                }
            }

            // find the column indeces of the primary keys
            int[] pki = new int[older._primaryKeys.Length];

            for (int i = 0; i < older._primaryKeys.Length; ++i)
            {
                pki[i] = older.GetColumnIndex(older._primaryKeys[i]);
            }

            // a position for each set of rows
            int olderPos = 0;
            int newerPos = 0;

            // we can assume that the rows are both sorted by the primary key
            while (olderPos < older._data.Count)
            {
                // check for newer rows that we won't find in older
                while (newerPos < newer._data.Count && 
                    CompareRows(older._data[olderPos], newer._data[newerPos], pki) > 0)
                {
                    ans._data.Add(new Row(RowSource.Insert, newer._data[newerPos].Data));
                    ++newerPos;
                }

                // we aren't going to find the older row, it was deleted
                if (newerPos == newer._data.Count || 
                    CompareRows(older._data[olderPos], newer._data[newerPos], pki) < 0)
                {
                    ans._data.Add(new Row(RowSource.Delete, older._data[olderPos].Data));
                    ++olderPos;
                    continue;
                }

                // at this point older == newer, check each column
                int i;
                for (i = 0; i < ans._columns.Length; ++i)
                {
                    if (CompareRows(older._data[olderPos], newer._data[newerPos], i) != 0)
                    {
                        ans._data.Add(new Row(RowSource.Old, older._data[olderPos].Data));
                        ans._data.Add(new Row(RowSource.Update, newer._data[newerPos].Data));
                        break;
                    }
                }

                // rows are the same, keep one for checking against
                if (i == ans._columns.Length)
                {
                    ans._data.Add(new Row(RowSource.Current, newer._data[newerPos].Data));
                }

                // move to the next rows regardless of whether changes were made
                ++olderPos;
                ++newerPos;
            }

            // anything left in newer was inserted
            for (; newerPos < newer._data.Count; ++newerPos)
            {
                ans._data.Add(new Row(RowSource.Insert, newer._data[newerPos].Data));
            }

            return ans;
        }

        /// <summary>
        /// Compares two rows based on the given column.
        /// </summary>
        private static int _CompareData (object a, object b)
        {
            return ((IComparable) a).CompareTo(b);
        }

        /// <summary>
        /// Compares two rows based on the given array column.
        /// </summary>
        private static int _CompareArrayData (object a, object b)
        {
            Array arrayA = (Array) a;
            Array arrayB = (Array) b;

            for (int j = 0; j < arrayA.Length; ++j)
            {
                int comp = ((IComparable) arrayA.GetValue(j)).CompareTo(arrayB.GetValue(j));

                if (comp != 0)
                {
                    return comp;
                }
            }

            return 0;
        }

        /// <summary>
        /// Compares two objects.
        /// </summary>
        public static int CompareData (object a, object b)
        {
            // handle DBNull cases
            bool aNull = (a == null || a == DBNull.Value);
            bool bNull = (b == null || b == DBNull.Value);

            if (aNull && bNull) { return 0; }
            if (aNull) { return -1; }
            if (bNull) { return 1; }

            if (a.GetType().IsArray)
            {
                return _CompareArrayData(a, b);
            }
            else
            {
                return _CompareData(a, b);
            }
        }

        /// <summary>
        /// Compares two rows based on the given column.
        /// </summary>
        private static int CompareRows (Row a, Row b, int i)
        {
            return CompareData(a.Data[i], b.Data[i]);
        }

        /// <summary>
        /// Compares two rows based on the given array of columns.
        /// The first (index == 0) column has the highest precedence.
        /// </summary>
        private static int CompareRows (Row a, Row b, int[] ci)
        {
            for (int i = 0; i < ci.Length; ++i)
            {
                int val = CompareData(a.Data[ci[i]], b.Data[ci[i]]);

                if (val != 0)
                {
                    return val;
                }
            }

            return 0;
        }

        /// <summary>
        /// Looks up the column number of the given column.
        /// </summary>
        /// <param name="column">The name of the column to look up.</param>
        /// <returns>The zero-based index of the column.</returns>
        public int GetColumnIndex (string column)
        {
            for (int i = 0; i < _colCount; ++i)
            {
                if (_columns[i].Name == column)
                {
                    return i;
                }
            }

            throw new ArgumentException("Could not find ' " + column + " ' in the list of columns.");
        }

        /// <summary>
        /// Gets the number of rows in the table in memory.
        /// </summary>
        public int RowCount
        {
            get
            {
                return _data.Count;
            }
        }

        /// <summary>
        /// Gets a row from the table.
        /// </summary>
        /// <param name="i">The index of the row to get.</param>
        /// <returns>The requested row.</returns>
        public Row GetRow (int i)
        {
            return _data[i];
        }

        /// <summary>
        /// Converts the table to a string representation.
        /// </summary>
        /// <returns>A string representation of the table.</returns>
        public override string ToString ()
        {
            StringBuilder buff = new StringBuilder();

            buff.Append(_tableName);
            buff.Append('\n');

            foreach (Column col in _columns)
            {
                buff.Append('[');
                buff.Append(col.Name);
                buff.Append('<');
                buff.Append(col.Type.Name);
                buff.Append(">] ");
            }

            if (_columns.Length > 0)
            {
                buff.Length -= 1;
            }

            buff.Append('\n');

            foreach (Row row in _data)
            {
                buff.Append(row.ToString());
                buff.Append('\n');
            }

            return buff.ToString();
        }
    }

    /// <summary>
    /// The base class for all LiveLSP tests.
    /// </summary>
    public class LiveLSPTestBase : TestBase
    {
        #region Event Checking

        public const string XKDCReload = "exec :xkdc reload";
        public const string LiveProxyReloadTitles = "exec :livepxy reloadtitles";
        public const string LiveProxyReloadPartners = "exec :livepxy reloadpartners";
        public const string LiveProxyReloadKeys = "exec :livepxy reloadkeys";

        public static bool CheckForXKDCReload (DateTime begin, bool expect)
        {
            return CheckForEventString(Interface.kdcsvc, XKDCReload, begin, expect);
        }

        public static bool CheckForLiveProxyReloadTitles (DateTime begin, bool expect)
        {
            return CheckForEventString(Interface.livepxy, LiveProxyReloadTitles, begin, expect);
        }

        public static bool CheckForLiveProxyReloadPartners (DateTime begin, bool expect)
        {
            return CheckForEventString(Interface.livepxy, LiveProxyReloadPartners, begin, expect);
        }

        public static bool CheckForLiveProxyReloadKeys (DateTime begin, bool expect)
        {
            return CheckForEventString(Interface.livepxy, LiveProxyReloadKeys, begin, expect);
        }

        /// <summary>
        /// Checks for a string in an event that happened after a certain time.
        /// </summary>
        /// <param name="servers">The name of the server interface to check on.</param>
        /// <param name="value">The string to search for.</param>
        /// <param name="begin">The earliest to check for events.</param>
        /// <param name="expect">True if the string is expected; false if it is not.</param>
        /// <returns>True if expectations were met on all machines; false if any machines do not.</returns>
        public static bool CheckForEventString (string servers, string value, DateTime begin, bool expect)
        {
            string[] machines = Config.GetServerListByInterface(servers);

            foreach (string machine in machines)
            {
                if (Events.TestServerForEvents(machine, "Application", "", value, begin) != expect)
                {
                    Global.RO.Debug("The string '{0}' was{2} found on server [{1}]", value, machine, 
                        (expect ? " not" : ""));
                    return false;
                }
            }

            return true;
        }

        #endregion

        #region SubTypes

        public class State
        {
            public class Service
            {
                public enum ServiceStatus
                {
                    /// <summary>
                    /// Service is not discoverable.
                    /// This is a reference point and should not be used as a value.
                    /// </summary>
                    None,
                    /// <summary>
                    /// Service was explicitly granted.
                    /// When used for service diffs, equivalent to Given | Upgraded.
                    /// </summary>
                    Granted, 
                    /// <summary>
                    /// Service was explicitly restricted.
                    /// When used for service diffs, equivalent to Revoked | Restricted_Explicitly.
                    /// </summary>
                    Restricted, 
                    /// <summary>
                    /// Service was newly discovered and explicitly granted.
                    /// (None -> Granted)
                    /// </summary>
                    Given, 
                    /// <summary>
                    /// Service was previously granted, but is no longer discoverable.
                    /// (Granted -> None)
                    /// </summary>
                    Taken, 
                    /// <summary>
                    /// Service was previously restricted, but is now granted.
                    /// (Restricted -> Granted)
                    /// </summary>
                    Upgraded, 
                    /// <summary>
                    /// Service was previously granted, but is now restricted.
                    /// (Granted -> Restricted)
                    /// </summary>
                    Revoked, 
                    /// <summary>
                    /// Service was previously restricted, but is no longer discoverable.
                    /// (Restricted -> None)
                    /// </summary>
                    Restricted_Impicitly, 
                    /// <summary>
                    /// Service was previously not discoverable, but is now restricted.
                    /// (None -> Restricted)
                    /// </summary>
                    Restricted_Explicitly
                };
                public uint ID;
                public ServiceStatus Status;
                public bool Marked;
                public Service (uint id, ServiceStatus status) { ID = id; Status = status; Marked = false; }
                public Service (uint id, ServiceStatus status, bool marked) { ID = id; Status = status; Marked = marked; }
            }

            public Dictionary<string, GenericTable> Tables;
            public string LspBackcompTitles;
            public List<Service> Services;
        }

        protected class Output
        {
            public int ReturnValue;
            public string StdOut;
        }

        public class DBChange
        {
            public GenericTable.RowSource Source;
            public string[] Columns;
            public object[] Values;

            public DBChange (GenericTable.RowSource source, string[] columns, object[] values)
            {
                Source = source; Columns = columns; Values = values;
            }

            public override string ToString ()
            {
                string ans = "Database Change:\n  Source: " + Source.ToString() + "\n  Columns:";
                foreach (string col in Columns) { ans += " [" + col + "]"; }
                ans += "\n  Values: ";
                if (Values != null)
                {
                    for (int i = 0; i < Values.Length; ++i)
                    {
                        if (i != 0) { ans += " | "; }
                        ans += (Values[i] == null ? "<null>" : Values[i].ToString());
                    }
                }
                return ans;
            }
        }

        #endregion

        public const string LiveLSPExecutable = "livelsp.exe";
        private static string _LiveLSPExecutableLocation = LiveLSPExecutable;
        private static object _lock_obj = new object();
        private static bool _DoExeCheck = true;

        public static string LiveLSPExecutableLocation
        {
            get
            {
                if (_DoExeCheck)
                {
                    lock (_lock_obj)
                    {
                        if (_DoExeCheck)
                        {
                            _DoExeCheck = false;

                            // check for local file, if its there, leave it
                            if (!File.Exists(LiveLSPExecutable))
                            {
                                if (File.Exists(LiveLSP.SuiteLocation + LiveLSPExecutable))
                                {
                                    _LiveLSPExecutableLocation = LiveLSP.SuiteLocation + LiveLSPExecutable;
                                }
                                else
                                {
                                    throw new Exception("Could not locate the executable: " + LiveLSPExecutable);
                                }
                            }
                        }
                    }
                }
                return _LiveLSPExecutableLocation;
            }
        }

        protected bool _ExpectKDCEvents = false, _ExpectLiveProxyTitleEvents = false, 
            _ExpectLiveProxyPartnerEvents = false, _ExpectLiveProxyKeyEvents = false;
        protected bool _ExpectLoginError = false;
        protected string _ExpectedOutputSubstring = null;

        protected int _ExpectedReturnValue = 0;
        protected XeTitleInfo _TitleInfo = null;
        protected SiteInfo _SiteInfo = null;
        protected Dictionary<string, List<DBChange>> _DBChanges = new Dictionary<string,List<DBChange>>();
        protected State.Service[] _ServiceChange = null;
        protected uint _Xbox1ServiceAsk = 0;

        // These members are linkage to test data
        protected State _PreExecutionState, _PostExecutionState, _DiffState;
        protected DateTime _PreExecutionTime;
        protected Output _Output;

        protected override void Execute ()
        {
            FDTransaction.sReceiveTimeOut = 300000;
            Setup();

            _PreExecutionState = GetState();
            _PreExecutionTime = DateTime.Now;

            _Output = ExecuteLiveLSP(GetCommandSwitches());

            _PostExecutionState = GetState();
            _DiffState = DiffStates(_PreExecutionState, _PostExecutionState);

            if (VerifyOutput(_Output) && VerifyState(_DiffState) && VerifyEvents(_PreExecutionTime))
            {
                ResultCode = TEST_RESULTS.PASSED;
            }
            else
            {
                ResultCode = TEST_RESULTS.FAILED;
            }
        }

        #region Private Execute Functions

        /// <summary>
        /// Gets the current state.  All knowledge on what to get and how to get it is here.
        /// </summary>
        /// <returns>The current state.</returns>
        private State GetState ()
        {
            State ans = new State();

            // Get DB tables
            ans.Tables = new Dictionary<string, GenericTable>();

            // Setup NPDB Tables
            using (SqlConnection connection = new SqlConnection(Config.NpdbConnectionString))
            {
                string server = Config.NpdbServer;
                string database_name = Config.NpdbDatabase;
                string serv_prefix = server + "." + database_name;

                connection.Open();
                try
                {
                    ans.Tables.Add(serv_prefix + ".t_sites",
                                                GenericTable.ReadTable(server,
                                                                        database_name,
                                                                        "t_sites",
                                                                        new string[] { "vc_environment", "i_site_id"}));
                    ans.Tables.Add(serv_prefix + ".t_service_keys",
                                                GenericTable.ReadTable(server,
                                                                        database_name,
                                                                        "t_service_keys",
                                                                        new string[] { "vc_environment", "i_key_type", "vc_service_data1", "vc_service_data2", "i_master_key_version", "i_key_version" }));
                    ans.Tables.Add(serv_prefix + ".t_site_virtual_interface_ips",
                                                GenericTable.ReadTable(server,
                                                                        database_name,
                                                                        "t_site_virtual_interface_ips",
                                                                        new string[] { "vc_environment", "i_site_id", "vc_virtual_interface" }));
                }
                finally
                {
                    connection.Close();
                }
            }
            
            // Get uodb servers, there is a minor issue here in that we cannot look up the information for
            // just any environment easily.  Thus, a changed -wstsite flag cannot be verified as easily as the
            // current environment settings.  Probably want some custom code for checking a different
            // environment, as well as the current default.
            string[] uodbServers = Config.GetServerListByInterface(Interface.uodb);
            
            // Setup UODB Tables
            foreach (string server in uodbServers)
            {
                SqlConnectionStringBuilder connStr = new SqlConnectionStringBuilder();
                connStr.DataSource = server;
                connStr.InitialCatalog = "master";
                connStr.IntegratedSecurity = true;

                // with multiple primaries, we need to be sneaky and figure out what they are
                using (SqlConnection connection = new SqlConnection(connStr.ConnectionString))
                {
                    connection.Open();
                    SqlCommand command = new SqlCommand("Select [name] from sys.databases where [name] like 'uodb%' and [name] not like '%replica%'",
                        connection);
                    command.CommandType = System.Data.CommandType.Text;

                    SqlDataReader reader = command.ExecuteReader();

                    try
                    {
                        while (reader.Read())
                        {
                            string database_name = reader.GetString(0);
                            string serv_prefix = server + "." + database_name;

                            // Shouldn't be in UODB anymore
                            //ans.Tables.Add(serv_prefix + ".t_sites", 
                            //                GenericTable.ReadTable(server,
                            //                                        database_name, 
                            //                                        "t_sites", 
                            //                                        "i_site_id"));
                            ans.Tables.Add(serv_prefix + ".t_services", 
                                            GenericTable.ReadTable(server, 
                                                                    database_name, 
                                                                    "t_services", 
                                                                    "i_service_id"));
                            ans.Tables.Add(serv_prefix + ".t_service_instances", 
                                            GenericTable.ReadTable(server, 
                                                                    database_name, 
                                                                    "t_service_instances", 
                                                                    new string[] { "i_service_id", "i_title_id", "i_title_region", "i_title_version" }));
                            ans.Tables.Add(serv_prefix + ".t_title_services", 
                                            GenericTable.ReadTable(server, 
                                                                    database_name, 
                                                                    "t_title_services", 
                                                                    new string[] { "i_title_id", "i_service_id" }));
                            // Shouldn't be in UODB anymore
                            //ans.Tables.Add(serv_prefix + ".t_service_keys", 
                            //                GenericTable.ReadTable(server,
                            //                                        database_name, 
                            //                                        "t_service_keys", 
                            //                                        new string[] { "i_key_type", "vc_service_data1", "vc_service_data2", "i_master_key_version", "i_key_version" }));
                            ans.Tables.Add(serv_prefix + ".t_offer_services", 
                                            GenericTable.ReadTable(server, 
                                                                    database_name, 
                                                                    "t_offer_services", 
                                                                    new string[] { "bi_offer_id", "i_service_id" }));
                        }
                    }
                    finally
                    {
                        reader.Close();
                    }
                }
            }


            ans.Tables.Add("t_interface_buckets", GenericTable.ReadTable(Config.NpdbServer, Config.NpdbDatabase, "t_interface_buckets",
                new string[] { "vc_environment", "i_title_id" }, "vc_interface = 'querydb' and i_bucket = 0xaaaa"));

            // Get back compat string
            using (SqlConnection connection = new SqlConnection(Config.NpdbConnectionString))
            {
                connection.Open();
                SqlCommand command = new SqlCommand(
                    "select vc_value from t_settings where vc_setting = 'query_LspBackcompTitles'", connection);
                ans.LspBackcompTitles = (string) command.ExecuteScalar();
                connection.Close();
            }
            
            // Sign in to our site/title to get the services
            AuthContext auth = new AuthContext();

            // if we are trying to get a specific service, then we are an Xbox 1
            if (_Xbox1ServiceAsk != 0)
            {
                auth.ClientType = AuthContext.ClientTypes.Xbox;
            }

            auth.SetUser(User, 0);

            if (_TitleInfo != null)
            {
                auth.TitleInfo = _TitleInfo;
            }

            XkdcClient.SetDefaults(auth);

            if (_SiteInfo != null)
            {
                auth.Site = _SiteInfo;
            }

            XkdcClient client = new XkdcClient(auth, null, true);

            // Get generic service information object
            if (client.Context.IsXenonTitle || client.Context.IsPanorama)
            {
                try
                {
                    DoXenonSiteDiscovery(ans, client);
                }
                catch
                {
                    if (!_ExpectLoginError)
                    {
                        throw;
                    }
                }

                if (_ExpectLoginError)
                {
                    throw new Exception("Was able to log in, but was not expecting to be able to.");
                }
            }
            else
            {
                try
                {
                    // specifically request the service and only the service
                    if (_Xbox1ServiceAsk != 0)
                    {
                        auth.ServiceCtxXbox.dwServiceID1[0] = _Xbox1ServiceAsk;
                        auth.ServiceCtxXbox.hrService1[0] = 0;
                        auth.ServiceCtxXbox.dwNumServices = 1;
                    }

                    DoXboxServiceRequest(ans, client);
                }
                catch
                {
                    if (!_ExpectLoginError)
                    {
                        throw;
                    }
                }

                if (_ExpectLoginError)
                {
                    throw new Exception("Was able to log in, but was not expecting to be able to.");
                }
            }

            return ans;
        }

        /// <summary>
        /// Does the actual execution of the LiveLSP command, captures the return value and the output.
        /// </summary>
        /// <param name="switches">The command line switches to add.</param>
        /// <returns>The output from the program execution.</returns>
        /// <remarks>
        /// This function expects that the group/suite setup will have placed the LiveLSP executable in a
        /// directory where it can be found, or changed the value of LiveLSPExecutable.
        /// </remarks>
        protected static Output ExecuteLiveLSP (string switches)
        {
            ProcessStartInfo startinfo = new ProcessStartInfo(LiveLSPExecutableLocation, switches);
            startinfo.RedirectStandardOutput = true;
            startinfo.UseShellExecute = false;

            Global.RO.Debug("Starting process: " + LiveLSPExecutableLocation + " " + switches);
            Process livelsp = Process.Start(startinfo);

            Output ans = new Output();
            ans.StdOut = livelsp.StandardOutput.ReadToEnd();
            livelsp.WaitForExit();

            if (!livelsp.HasExited)
            {
                throw new Exception("The LiveLSP tool did not exit after the designated time.  The test was aborted.");
            }

            ans.ReturnValue = livelsp.ExitCode;

            return ans;
        }

        /// <summary>
        /// Diffs the two states, creating another one that contains only the differences.
        /// </summary>
        /// <param name="pre">The state before changes occured.</param>
        /// <param name="post">The state after changes occured.</param>
        /// <returns>A state that contains the changes that were detected.</returns>
        private State DiffStates (State pre, State post)
        {
            State ans = new State();

            // diff all tables
            ans.Tables = new Dictionary<string, GenericTable>();

            foreach (string table in pre.Tables.Keys)
            {
                ans.Tables.Add(table, GenericTable.DetectChanges(pre.Tables[table], post.Tables[table]));
            }

            // diff back compat string
            string[] preTitles = pre.LspBackcompTitles.Split(new char[] { ';' },
                StringSplitOptions.RemoveEmptyEntries);
            string[] postTitles = post.LspBackcompTitles.Split(new char[] { ';' },
                StringSplitOptions.RemoveEmptyEntries);
            bool[] preMatch = new bool[preTitles.Length];
            bool[] postMatch = new bool[postTitles.Length];

            for (int i = 0; i < preMatch.Length; ++i) { preMatch[i] = false; }
            for (int i = 0; i < postMatch.Length; ++i) { postMatch[i] = false; }

            for (int i = 0; i < preTitles.Length; ++i)
            {
                for (int j = 0; j < postTitles.Length; ++j)
                {
                    if (preTitles[i] == postTitles[j])
                    {
                        preMatch[i] = true;
                        postMatch[j] = true;
                        break;
                    }
                }
            }

            StringBuilder builder = new StringBuilder();

            for (int i = 0; i < preMatch.Length; ++i)
            {
                if (!preMatch[i])
                {
                    builder.Append('-');
                    builder.Append(preTitles[i]);
                    builder.Append(';');
                }
            }

            for (int i = 0; i < postMatch.Length; ++i)
            {
                if (!postMatch[i])
                {
                    builder.Append('+');
                    builder.Append(postTitles[i]);
                    builder.Append(';');
                }
            }

            if (builder.Length > 0)
            {
                ans.LspBackcompTitles = builder.ToString(0, builder.Length - 1);
            }
            else
            {
                ans.LspBackcompTitles = string.Empty;
            }

            // diff services
            ans.Services = new List<State.Service>();

            preMatch = new bool[pre.Services.Count];
            postMatch = new bool[post.Services.Count];

            for (int i = 0; i < preMatch.Length; ++i) { preMatch[i] = false; }
            for (int i = 0; i < postMatch.Length; ++i) { postMatch[i] = false; }

            for (int i = 0; i < pre.Services.Count; ++i)
            {
                for (int j = 0; j < post.Services.Count; ++j)
                {
                    if (pre.Services[i].ID == post.Services[j].ID)
                    {
                        preMatch[i] = true;
                        postMatch[j] = true;

                        if (pre.Services[i].Status == State.Service.ServiceStatus.Granted)
                        {
                            if (post.Services[j].Status == State.Service.ServiceStatus.Restricted)
                            {
                                ans.Services.Add(new State.Service(pre.Services[i].ID,
                                    State.Service.ServiceStatus.Revoked));
                            }
                            else
                            {
                                ans.Services.Add(new State.Service(pre.Services[i].ID,
                                    State.Service.ServiceStatus.Granted, true));
                            }
                        }
                        else // pre.Services[i].Status == State.Service.ServiceStatus.Restricted
                        {
                            if (post.Services[j].Status == State.Service.ServiceStatus.Granted)
                            {
                                ans.Services.Add(new State.Service(pre.Services[i].ID,
                                    State.Service.ServiceStatus.Upgraded));
                            }
                            else
                            {
                                ans.Services.Add(new State.Service(pre.Services[i].ID,
                                    State.Service.ServiceStatus.Restricted, true));
                            }
                        }

                        break;
                    }
                }
            }

            // now that we have done our search, add in the leftouts
            for (int i = 0; i < preMatch.Length; ++i)
            {
                if (!preMatch[i])
                {
                    if (pre.Services[i].Status == State.Service.ServiceStatus.Granted)
                    {
                        ans.Services.Add(new State.Service(pre.Services[i].ID,
                            State.Service.ServiceStatus.Taken));
                    }
                    else // pre.Services[i].Status == State.Service.ServiceStatus.Restricted
                    {
                        ans.Services.Add(new State.Service(pre.Services[i].ID,
                            State.Service.ServiceStatus.Restricted_Impicitly));
                    }
                }
            }

            for (int i = 0; i < postMatch.Length; ++i)
            {
                if (!postMatch[i])
                {
                    if (post.Services[i].Status == State.Service.ServiceStatus.Granted)
                    {
                        ans.Services.Add(new State.Service(post.Services[i].ID,
                            State.Service.ServiceStatus.Given));
                    }
                    else // pre.Services[i].Status == State.Service.ServiceStatus.Restricted
                    {
                        ans.Services.Add(new State.Service(post.Services[i].ID,
                            State.Service.ServiceStatus.Restricted_Explicitly));
                    }
                }
            }

            return ans;
        }

        #endregion

        #region Helpers

        private static object _userlock = new object();
        private static XeUser _user = null;

        /// <summary>
        /// The single user used by all tests for service verification.
        /// </summary>
        private static XeUser User
        {
            get
            {
                if (_user == null)
                {
                    lock (_userlock)
                    {
                        // check again to ensure that we weren't beaten to the punch
                        if (_user == null)
                        {
                            _user = new XeUser(false);
                            _user.CreateAsGold = true;

                            int i;
                            for (i = 0; i < 40; ++i)
                            {
                                try
                                {
                                    if (_user.Create() != 0)
                                    {
                                        break;
                                    }
                                }
                                catch (Exception e)
                                {
                                    Global.RO.Fatal(e.Message);
                                }
                            }

                            if (i >= 4)
                            {
                                _user = null;
                                throw new Exception("Could not create a user, gave up after 4 tries.");
                            }
                        }
                    }
                }

                return _user;
            }
        }

        /// <summary>
        /// Does site discovery for a Xenon client, first auto discovering, then looking up the services that
        /// come back with an hr of 1 until there are no more.
        /// </summary>
        /// <param name="toUpdate">The state object to update with information found.</param>
        /// <param name="client">The XKDC client to connect with.</param>
        private static void DoXenonSiteDiscovery (State toUpdate, XkdcClient client)
        {
            toUpdate.Services = new List<State.Service>();

            List<uint> nextLookup = new List<uint>();

            while (true)
            {
                client.SignInXkdc();
                ServiceContextXe scxe = client.Context.ServiceCtxXe;

                bool progress = false;
                nextLookup.Clear();

                for (int i = 0; i < ServiceContextXe.XONLINE_XE_MAX_BYTE_SERVICEIDS; ++i)
                {
                    if (scxe.bServiceID3[i] != 0)
                    {
                        if (scxe.hrServiceBytes3[i] == 0)
                        {
                            toUpdate.Services.Add(new State.Service((uint) scxe.bServiceID3[i],
                                State.Service.ServiceStatus.Granted));
                            progress = true;
                        }
                        else if (scxe.hrServiceBytes3[i] == 1)
                        {
                            nextLookup.Add((uint) scxe.bServiceID3[i]);
                        }
                        else
                        {
                            // we were told explicitly that we can't have that service
                            toUpdate.Services.Add(new State.Service((uint) scxe.bServiceID3[i],
                                State.Service.ServiceStatus.Restricted));
                            progress = true;
                        }
                    }
                }

                for (int i = 0; i < ServiceContextXe.XONLINE_MAX_DWORD_SERVICEIDS; ++i)
                {
                    if (scxe.dwServiceID3[i] != 0)
                    {
                        if (scxe.hrServiceDwords3[i] == 0)
                        {
                            toUpdate.Services.Add(new State.Service(scxe.dwServiceID3[i],
                                State.Service.ServiceStatus.Granted));
                            progress = true;
                        }
                        else if (scxe.hrServiceDwords3[i] == 1)
                        {
                            nextLookup.Add(scxe.dwServiceID3[i]);
                        }
                        else
                        {
                            // we were told explicitly that we can't have that service
                            toUpdate.Services.Add(new State.Service(scxe.dwServiceID3[i],
                                State.Service.ServiceStatus.Restricted));
                            progress = true;
                        }
                    }
                }

                if (nextLookup.Count == 0)
                {
                    break;
                }

                if (!progress)
                {
                    throw new Exception("Attempt to look up service information did not yield any progress, aborting.");
                }

                client.SetRequest(nextLookup.ToArray(), false);
            }
        }

        /// <summary>
        /// Does service request for an Xbox client.
        /// </summary>
        /// <param name="toUpdate">The state object to update with information found.</param>
        /// <param name="client">The XKDC client to connect with.</param>
        private static void DoXboxServiceRequest (State toUpdate, XkdcClient client)
        {
            toUpdate.Services = new List<State.Service>();

            client.SignInXkdc();
            ServiceContextXbox scxb = client.Context.ServiceCtxXbox;

            for (int i = 0; i < ServiceContextXbox.XONLINE_LEGACY_MAX_NUMBER_SERVICE; ++i)
            {
                if (scxb.dwServiceID1[i] != 0)
                {
                    if (scxb.hrService1[i] == 0)
                    {
                        toUpdate.Services.Add(new State.Service((uint) scxb.dwServiceID1[i],
                            State.Service.ServiceStatus.Granted));
                    }
                    else
                    {
                        // we were told explicitly that we can't have that service
                        toUpdate.Services.Add(new State.Service((uint) scxb.dwServiceID1[i],
                            State.Service.ServiceStatus.Restricted));
                    }
                }
            }
        }

        /// <summary>
        /// Finds the differences between two strings on a line-by-line basis.
        /// </summary>
        /// <param name="a">The first string.</param>
        /// <param name="b">The second string.</param>
        /// <returns>A string describing the differences.</returns>
        public static string DiffStrings (string a, string b)
        {
            string[] alines = a.Split(new char[] { '\n' });
            string[] blines = b.Split(new char[] { '\n' });
            string ans = string.Empty;

            for (int i = 0; i < alines.Length && i < blines.Length; ++i)
            {
                if (alines[i] != blines[i])
                {
                    string temp = i.ToString();
                    ans += "[" + temp + "] " + alines[i] + "\n" + (new string(' ', temp.Length + 3)) + 
                        blines[i] + "\n";
                }
            }

            if (alines.Length < blines.Length)
            {
                for (int i = alines.Length; i < blines.Length; ++i)
                {
                    string temp = i.ToString();
                    ans += "[" + temp + "] \n" + (new string(' ', temp.Length + 3)) + blines[i] + "\n";
                }
            }
            else if (blines.Length < alines.Length)
            {
                for (int i = blines.Length; i < alines.Length; ++i)
                {
                    string temp = i.ToString();
                    ans += "[" + temp + "] " + alines[i] + "\n" + (new string(' ', temp.Length + 3)) + "\n";
                }
            }

            return ans;
        }
        
        /// <summary>
        /// Attempts to create the service using the id given.
        /// </summary>
        /// <param name="id">The id of the service.</param>
        public static void CreateService (uint id)
        {
            CreateService(id, true);
        }

        /// <summary>
        /// Attempts to create the service using the id given.
        /// </summary>
        /// <param name="id">The id of the service.</param>
        /// <param name="mapService">If false, provides the -noassociation parameter.</param>
        public static void CreateService (uint id, bool mapService)
        {
            Output o = ExecuteLiveLSP(string.Format("-configpartner -service:0x{0:X8} -site:0x{0:X8} " +
                "-servicedesc:\"LiveLSPTest Service {0:X8}\" -sitedesc:\"LiveLSPTest Site {0:X8}\" -noreload{1}", 
                id, (mapService ? "" : " -noassociation")));
            if (o.ReturnValue != 0)
            {
                throw new Exception(String.Format("Failed to create service 0x{0:X8}:\n  " + 
                    "Return Value: {1}\n  Output:\n{2}", id, o.ReturnValue, o.StdOut));
            }
        }

        #endregion

        #region Virtual Functions

        /// <summary>
        /// Does any pre-execution steps that are needed.
        /// </summary>
        protected virtual void Setup () { }

        /// <summary>
        /// Constructs the command line for the execution of LiveLSP.
        /// </summary>
        /// <returns>The command line parameters for LiveLSP.</returns>
        protected virtual string GetCommandSwitches ()
        {
            return string.Empty;
        }

        /// <summary>
        /// Checks the output of the program execution.
        /// </summary>
        /// <param name="output">The output object.</param>
        /// <returns>True if the output was what was expected; false otherwise.</returns>
        protected virtual bool VerifyOutput (Output output)
        {
            if (output.ReturnValue != _ExpectedReturnValue)
            {
                Global.RO.Error("The return value from executing LiveLSP was {0}, expecting {1}.", 
                    output.ReturnValue, _ExpectedReturnValue);
                Global.RO.Error("The program output was:\n" + output.StdOut);
                return false;
            }

            // find any lines with the string Error or Exception
            int pos = 0;

            while (pos >= 0 && pos < output.StdOut.Length) {
                int errorPos = output.StdOut.IndexOf("error", pos, StringComparison.OrdinalIgnoreCase);
                int exceptionPos = output.StdOut.IndexOf("exception", pos, StringComparison.OrdinalIgnoreCase);

                if (errorPos == -1)
                {
                    pos = exceptionPos;
                }
                else if (exceptionPos == -1)
                {
                    pos = errorPos;
                }
                else
                {
                    pos = Math.Min(errorPos, exceptionPos);
                }

                if (pos == -1)
                {
                    break;
                }

                // find line end/begin
                int lineBegin = output.StdOut.LastIndexOf('\n', pos) + 1;
                int lineEnd = output.StdOut.IndexOf('\n', pos);

                // check for a colon at the end of the line (\r will be before \n here)
                if (lineEnd != -1 && output.StdOut[lineEnd - 2] == ':')
                {
                    lineEnd = output.StdOut.IndexOf('\n', lineEnd + 1);
                }
                if (lineEnd == -1) { lineEnd = output.StdOut.Length; }

                Global.RO.Warn(output.StdOut.Substring(lineBegin, lineEnd - lineBegin));

                pos = lineEnd;
            }

            if (_ExpectedOutputSubstring != null && !output.StdOut.Contains(_ExpectedOutputSubstring))
            {
                Global.RO.Error("String '" + _ExpectedOutputSubstring + "' not found in output, failing.");
                return false;
            }

            return true;
        }

        /// <summary>
        /// Checks the state diff.
        /// </summary>
        /// <param name="diff">The diff of the pre- and post- execution states.</param>
        /// <returns>True if the diff was what was expected; false otherwise.</returns>
        protected virtual bool VerifyState (State diff)
        {
            // check database tables
            foreach (string table in _DBChanges.Keys)
            {
                // go through all tables in our records looking for those that match
                foreach (string serverTable in diff.Tables.Keys)
                {
                    if (serverTable.EndsWith(table) && _DBChanges[table] != null)
                    {
                        // every change in our expected list
                        foreach (DBChange change in _DBChanges[table])
                        {
                            GenericTable tab = diff.Tables[serverTable];
                            int i;
                            // every row in our table
                            for (i = 0; i < tab.RowCount; ++i)
                            {
                                GenericTable.Row row = tab.GetRow(i);

                                // the row has to not be marked, and have the same source, or insert allows
                                // update to work as well, or exists allows insert, update, current
                                if ((!row.Marked && (row.Source == change.Source ||
                                    (change.Source == GenericTable.RowSource.Insert &&
                                     row.Source == GenericTable.RowSource.Update) ||
                                    (change.Source == GenericTable.RowSource.Exists &&
                                     (row.Source == GenericTable.RowSource.Update ||
                                      row.Source == GenericTable.RowSource.Insert ||
                                      row.Source == GenericTable.RowSource.Current)
                                     ))) || change.Source == GenericTable.RowSource.NotExists)
                                {
                                    bool good = true;

                                    // every column in the change data
                                    for (int j = 0; j < change.Columns.Length; ++j)
                                    {
                                        int colInd = tab.GetColumnIndex(change.Columns[j]);

                                        // compare objects
                                        if (GenericTable.CompareData(row.Data[colInd], change.Values[j]) != 0)
                                        {
                                            good = false;
                                            break;
                                        }
                                    }

                                    if (good)
                                    {
                                        row.Marked = true;

                                        // If using NotExists, you must put the change after any Delete
                                        // or you will get errors.  Easier to just not use Delete and NotExists
                                        // at the same time.
                                        if (change.Source == GenericTable.RowSource.NotExists)
                                        {
                                            if (row.Source != GenericTable.RowSource.Delete)
                                            {
                                                Global.RO.Error("Found a row in the database when we expected it to not be there.  See debug log for more detail.");
                                                Global.RO.Debug(change.ToString());
                                                Global.RO.Debug(tab.ToString());
                                                return false;
                                            }

                                            continue;
                                        }
                                        else
                                        {
                                            // we found an all-points match, we can bail out to the next change
                                            break;
                                        }
                                    }
                                }
                            }

                            // we ran out of rows looking for this change, error time
                            // unless we were checking for NotExists
                            if (i >= tab.RowCount && change.Source != GenericTable.RowSource.NotExists)
                            {
                                Global.RO.Error("Could not find the expected change in the database.  See debug log for more detail.");
                                Global.RO.Debug(change.ToString());
                                Global.RO.Debug(tab.ToString());
                                return false;
                            }
                        }
                    }
                }
            }

            // Look for leftover rows that did not have a change associated with them
            bool foundChanges = false;

            foreach (string tableName in diff.Tables.Keys)
            {
                GenericTable table = diff.Tables[tableName];

                for (int i = 0; i < table.RowCount; ++i)
                {
                    GenericTable.Row row = table.GetRow(i);

                    if (!row.Marked && row.Source != GenericTable.RowSource.Old &&
                        row.Source != GenericTable.RowSource.Current)
                    {
                        Global.RO.Error("Unexpected database change found in " + tableName + ":\n  " +
                            row.ToString());
                        foundChanges = true;
                    }
                }
            }

            if (foundChanges)
            {
                return false;
            }

            return VerifyServices(diff);
        }

        /// <summary>
        /// Verifies the services in a state diff.
        /// </summary>
        /// <param name="diff">The diff containg the services.</param>
        /// <returns>True if services were as expected; false otherwise.</returns>
        protected virtual bool VerifyServices (State diff)
        {
            // check services for change
            if (_ServiceChange != null)
            {
                foreach (State.Service expect in _ServiceChange)
                {
                    bool good = false;

                    foreach (State.Service actual in diff.Services)
                    {
                        // Of course, service IDs have to be the same, then the status has to be what we expected
                        // or the special cases for 'we don't care how you got it, but you got it'
                        if (expect.ID == actual.ID && (expect.Status == actual.Status ||
                            (expect.Status == State.Service.ServiceStatus.Granted &&
                                (actual.Status == State.Service.ServiceStatus.Given || actual.Status == State.Service.ServiceStatus.Upgraded)
                            ) ||
                            (expect.Status == State.Service.ServiceStatus.Restricted &&
                                (actual.Status == State.Service.ServiceStatus.Revoked || actual.Status == State.Service.ServiceStatus.Restricted_Explicitly)
                            )))
                        {
                            good = true;
                            actual.Marked = true;
                            break;
                        }
                    }

                    if (!good)
                    {
                        Global.RO.Error("Could not find expected service 0x{0:X8} [{1}] in list.",
                            expect.ID, expect.Status.ToString());
#if IGNORE_SERVICE_ERRORS
                        Global.RO.Warn("Not failing on service errors currently.  Since xkeymgr is not working, we can't actually get our services back from a login.");
#else
                        return false;
#endif
                    }
                }
            }

            foreach (State.Service actual in diff.Services)
            {
                if (!actual.Marked)
                {
                    Global.RO.Error("An unexpected service change was found: 0x{0:X8} [{1}]", actual.ID,
                        actual.Status.ToString());
#if IGNORE_SERVICE_ERRORS
                    Global.RO.Warn("Not failing on service errors currently.  Since xkeymgr is not working, we can't actually get our services back from a login.");
#else
                    return false;
#endif
                }
            }

            return true;
        }

        /// <summary>
        /// Checks the events.
        /// </summary>
        /// <param name="time">The time just before the execution of LiveLSP.</param>
        /// <returns>True if the events were as expected; false otherwise.</returns>
        protected virtual bool VerifyEvents (DateTime time)
        {
            bool ans = true;

            // check all servers, even after one fails
            if (!CheckForXKDCReload(time, _ExpectKDCEvents))
            {
                Global.RO.Error("XKDC server reloads were " + (_ExpectKDCEvents ? "" : "not ") +
                    "expected, but reloads were " + (_ExpectKDCEvents ? "not " : "") + "detected.");
                ans = false;
            }

            if (!CheckForLiveProxyReloadTitles(time, _ExpectLiveProxyTitleEvents))
            {
#if IGNORE_LIVEPROXY_WEBDB_RELOADS
                Global.RO.Warn("Ignoring LiveProxy title reloads.  The tool currently does nothing to WebDB.");
#else
                Global.RO.Error("Live Proxy title reloads were " + (_ExpectLiveProxyTitleEvents ? "" : "not ") +
                    "expected, but reloads were " + (_ExpectLiveProxyTitleEvents ? "not " : "") + "detected.");
                ans = false;
#endif
            }

            if (!CheckForLiveProxyReloadPartners(time, _ExpectLiveProxyPartnerEvents))
            {
#if IGNORE_LIVEPROXY_WEBDB_RELOADS
                Global.RO.Warn("Ignoring LiveProxy partner reloads.  The tool currently does nothing to WebDB.");
#else
                Global.RO.Error("Live Proxy partner reloads were " + (_ExpectLiveProxyPartnerEvents ? "" : "not ") +
                    "expected, but reloads were " + (_ExpectLiveProxyPartnerEvents ? "not " : "") + "detected.");
                ans = false;
#endif
            }

            if (!CheckForLiveProxyReloadKeys(time, _ExpectLiveProxyKeyEvents))
            {
#if IGNORE_LIVEPROXY_KEY_RELOADS
                Global.RO.Warn("Ignoring LiveProxy key reloads.");
#else
                Global.RO.Error("Live Proxy key reloads were " + (_ExpectLiveProxyKeyEvents ? "" : "not ") +
                    "expected, but reloads were " + (_ExpectLiveProxyKeyEvents ? "not " : "") + "detected.");
                ans = false;
#endif
            }

            return ans;
        }

        #endregion
    }

    /// <summary>
    /// Contains the basics for a configtitle call.
    /// </summary>
    public class ConfigTitleTestBase : LiveLSPTestBase
    {
        public const uint DefaultTitleID = 0xFFFF07A2;

        private uint _TitleID;
        protected uint ServiceID, SiteID;
        protected string QueryDB;
        protected bool BackCompat;
        public bool Remove;

        public bool NoReload = false;
        public bool ReadOnly = false;

        public ConfigTitleTestBase ()
        {
            TitleID = DefaultTitleID;
            ServiceID = 0;
            SiteID = 0;
            QueryDB = null;
            BackCompat = false;
            Remove = false;
        }

        /// <summary>
        /// Construct a -configtitle command line.
        /// </summary>
        protected override string GetCommandSwitches ()
        {
            StringBuilder buff = new StringBuilder("-configtitle");
            buff.Append(" -titleid:0x");
            buff.Append(TitleID.ToString("X8"));
            buff.Append(" -service:0x");
            buff.Append(ServiceID.ToString("X8"));

            if (SiteID != 0)
            {
                buff.Append(" -site:0x");
                buff.Append(SiteID.ToString("X8"));
            }

            if (QueryDB != null)
            {
                buff.Append(" -querydb:\"");
                buff.Append(QueryDB);
                buff.Append('"');
            }

            if (BackCompat)
            {
                buff.Append(" -backcompat");
            }

            if (Remove)
            {
                buff.Append(" -remove");
            }

            if (NoReload) { buff.Append(" -noreload"); }
            if (ReadOnly) { buff.Append(" -readonly"); }

            return buff.ToString();
        }

        protected uint TitleID
        {
            get
            {
                return _TitleID;
            }
            set
            {
                _TitleID = value;
                _TitleInfo = new XeTitleInfo(_TitleID, 0, 0);
            }
        }

        /// <summary>
        /// Sets the standard expectations for a positive test.
        /// </summary>
        protected void SetExpectations ()
        {
            Global.RO.Warn("SetExpectations: ConfigTitleTestBase");

            _DBChanges.Clear();

            if (ReadOnly)
            {
                return;
            }

            if (Remove)
            {
                _DBChanges.Add("t_service_instances", new List<DBChange>());
                _DBChanges.Add("t_title_services", new List<DBChange>());

                if (ServiceID == 0)
                {
                    _DBChanges["t_title_services"].Add(new DBChange(
                        GenericTable.RowSource.NotExists,
                        new string[] { "i_title_id" },
                        new object[] { (int) _TitleID }));

                    _DBChanges["t_service_instances"].Add(new DBChange(
                        GenericTable.RowSource.NotExists,
                        new string[] { "i_title_id", "i_title_region", "i_title_version" },
                        new object[] { (int) _TitleID, (int) 0, (int) 0 }));
                }
                else
                {
                    _DBChanges["t_title_services"].Add(new DBChange(
                        GenericTable.RowSource.NotExists,
                        new string[] { "i_service_id", "i_title_id" },
                        new object[] { (int) ServiceID, (int) _TitleID }));

                    _DBChanges["t_service_instances"].Add(new DBChange(
                        GenericTable.RowSource.NotExists,
                        new string[] { "i_service_id", "i_title_id", "i_title_region", "i_title_version" },
                        new object[] { (int) ServiceID, (int) _TitleID, (int) 0, (int) 0 }));

                    // Using taken as the remove tests should have the service
                    _ServiceChange = new State.Service[]{
                        new State.Service(ServiceID, State.Service.ServiceStatus.Taken)
                    };
                }

                return;
            }

            _DBChanges.Add("t_service_instances", new List<DBChange>());
            if (SiteID == 0)
            {
                _DBChanges["t_service_instances"].Add(new DBChange(
                    GenericTable.RowSource.Insert,
                    new string[] { "i_service_id", "i_title_id" },
                    new object[] { (int) ServiceID, (int) TitleID }));
            }
            else
            {
                _DBChanges["t_service_instances"].Add(new DBChange(
                    GenericTable.RowSource.Insert,
                    new string[] { "i_service_id", "i_title_id", "i_site_id" },
                    new object[] { (int) ServiceID, (int) TitleID, (int) SiteID }));
            }
            
            _DBChanges.Add("t_interface_buckets", new List<DBChange>());
            if (QueryDB == null)
            {
                _DBChanges["t_interface_buckets"].Add(new DBChange(
                    GenericTable.RowSource.Exists,
                    new string[] { "vc_environment", "i_title_id" },
                    new object[] { Config.Environment, (int) TitleID }));
            }
            else
            {
                _DBChanges["t_interface_buckets"].Add(new DBChange(
                    GenericTable.RowSource.Exists,
                    new string[] { "vc_environment", "i_title_id", "vc_server", "vc_next_server" },
                    new object[] { Config.Environment, (int) TitleID, QueryDB, QueryDB }));
            }

            // for an Xbox 1 title, we have to check for services in the base offers
            // this statement will only return offer ids if the title is an Xbox 1
            SqlConnection conn = new SqlConnection("Data Source=" + 
                Config.GetServerListByInterface(Interface.uodb)[0] + ";Integrated Security=SSPI;");
            SqlDataReader reader = null;

            try
            {
                conn.Open();

                SqlCommand comm = new SqlCommand(SelectBaseOffersIfXbox1, conn);
                comm.CommandType = System.Data.CommandType.Text;

                comm.Parameters.Add("title", System.Data.SqlDbType.Int).Value = (int) _TitleID;

                reader = comm.ExecuteReader();

                List<DBChange> changes = null;

                while (reader.Read())
                {
                    if (changes == null) { changes = new List<DBChange>(); }
                    changes.Add(new DBChange(GenericTable.RowSource.Exists, 
                        new string[] { "bi_offer_id", "i_service_id" }, 
                        new object[] { reader.GetInt64(0), (int) ServiceID }));
                }

                _DBChanges.Add("t_offer_services", changes);
            }
            finally
            {
                if (reader != null) { reader.Close(); }
                conn.Close();
            }

            // if this is an Xbox 1 title, we will have some changes in the offer_services table
            // if we don't, then we need a line int t_offer_services
            if (_DBChanges["t_offer_services"] == null)
            {
                _DBChanges.Add("t_title_services", new List<DBChange>());
                _DBChanges["t_title_services"].Add(new DBChange(
                    GenericTable.RowSource.Exists,
                    new string[] { "i_service_id", "i_title_id" },
                    new object[] { (int) ServiceID, (int) TitleID }));
            }
            else
            {
                _Xbox1ServiceAsk = ServiceID;
            }

            if (!NoReload)
            {
                _ServiceChange = new State.Service[]{
                    new State.Service(ServiceID, State.Service.ServiceStatus.Granted)
                };
            }

            _ExpectKDCEvents = !NoReload;
        }

        public Dictionary<string, List<DBChange>> DBChanges
        {
            get { return _DBChanges; }
        }

        public State.Service[] ServiceChange
        {
            get { return _ServiceChange; }
            set { _ServiceChange = value; }
        }

        protected const string SelectBaseOffersIfXbox1 = @"
If exists (Select null from uodb000.dbo.t_title_versions where i_title_id = @title and ti_console_type_id = 0) begin
    Select bi_offer_id from uodb000.dbo.t_base_offers
end
";
    }

    /// <summary>
    /// Contains the basics for a configpartner call.
    /// </summary>
    public class ConfigPartnerTestBase : LiveLSPTestBase
    {
        public uint ServiceID;
        public uint SiteID;
        public uint Lifetime;
        public string ServiceDescription;
        public string SiteDescription;
        public string Authdata;
        public string MasterKey;
        public string SiteIp;
        public bool NoAssociation;
        public bool Remove;

        public bool NoReload = false;
        public bool ReadOnly = false;

        public ConfigPartnerTestBase ()
        {
            ServiceID = 0;
            SiteID = 0;
            Lifetime = 0;
            ServiceDescription = null;
            SiteDescription = null;
            Authdata = null;
            MasterKey = null;
            SiteIp = null;
            NoAssociation = false;
            Remove = false;
        }

        protected override string GetCommandSwitches ()
        {
            StringBuilder buff = new StringBuilder("-configpartner");
            buff.Append(" -service:0x");
            buff.Append(ServiceID.ToString("X8"));

            if (SiteID != 0)
            {
                buff.Append(" -site:0x");
                buff.Append(SiteID.ToString("X8"));
            }

            if (Lifetime != 0)
            {
                buff.Append(" -lifetime:\"");
                buff.Append(Lifetime);
                buff.Append('"');
            }

            if (ServiceDescription != null)
            {
                buff.Append(" -servicedesc:\"");
                buff.Append(ServiceDescription);
                buff.Append('"');
            }

            if (SiteDescription != null)
            {
                buff.Append(" -sitedesc:\"");
                buff.Append(SiteDescription);
                buff.Append('"');
            }

            if (Authdata != null)
            {
                buff.Append(" -authdata:");
                buff.Append(Authdata);
            }

            if (MasterKey != null)
            {
                buff.Append(" -masterkey:\"");
                buff.Append(MasterKey);
                buff.Append('"');
            }

            if (SiteIp != null)
            {
                buff.Append(" -ip:\"");
                buff.Append(SiteIp);
                buff.Append('"');
            }

            if (NoAssociation)
            {
                buff.Append(" -noassociation");
            }

            if (Remove)
            {
                buff.Append(" -remove");
            }

            if (NoReload) { buff.Append(" -noreload"); }
            if (ReadOnly) { buff.Append(" -readonly"); }

            return buff.ToString();
        }

        public uint EffectiveSiteID
        {
            get
            {
                return (SiteID == 0 ? ServiceID : SiteID);
            }
        }

        protected void SetExpectations ()
        {
            Global.RO.Warn("SetExpectations: ConfigPartnerTestBase");
            _DBChanges.Clear();

            if (ReadOnly)
            {
                return;
            }

            if (Remove)
            {
                _DBChanges.Add("t_service_instances", new List<DBChange>());
                _DBChanges["t_service_instances"].Add(new DBChange(
                    GenericTable.RowSource.NotExists,
                    new string[] { "i_service_id", "i_site_id" },
                    new object[] { (int) ServiceID, (int) EffectiveSiteID }));

                return;
            }

            // t_services
            _DBChanges.Add("t_services", new List<DBChange>());
            if (ServiceDescription == null)
            {
                _DBChanges["t_services"].Add(new DBChange(
                    GenericTable.RowSource.Insert,
                    new string[] { "i_service_id", "vc_kerb_service_name" },
                    new object[] { (int) ServiceID, "ts" }));
            }
            else
            {
                _DBChanges["t_services"].Add(new DBChange(
                    GenericTable.RowSource.Insert,
                    new string[] { "i_service_id", "vc_kerb_service_name", "vc_description" },
                    new object[] { (int) ServiceID, "ts", ServiceDescription }));
            }

            // t_site_virtual_interface_ips
            List<string> names = new List<string>();
            List<object> vals = new List<object>();

            names.Add("vc_environment"); vals.Add((string)Config.Environment);
            names.Add("i_site_id"); vals.Add((int)EffectiveSiteID);
            names.Add("vc_virtual_interface"); vals.Add((string)"sgsvc_xlsp");
            names.Add("vc_ip"); vals.Add((SiteIp == null)?(string)"1.1.1.1":SiteIp);

            _DBChanges.Add("t_site_virtual_interface_ips", new List<DBChange>());
            _DBChanges["t_site_virtual_interface_ips"].Add(new DBChange(
                GenericTable.RowSource.Insert, names.ToArray(), vals.ToArray()));

            // t_sites
            names.Clear();
            vals.Clear();

            names.Add("vc_environment"); vals.Add((string)Config.Environment);
            names.Add("i_site_id"); vals.Add((int)EffectiveSiteID);

            if (SiteDescription != null)
            {
                names.Add("vc_description"); vals.Add(SiteDescription);
            }

            if (Authdata != null)
            {
                names.Add("i_authdata_version"); vals.Add(int.Parse(Authdata));
            }

            _DBChanges.Add("t_sites", new List<DBChange>());
            _DBChanges["t_sites"].Add(new DBChange(
                GenericTable.RowSource.Insert, names.ToArray(), vals.ToArray()));

            // t_service_instances
            if (!NoAssociation)
            {
                names.Clear();
                vals.Clear();

                names.Add("i_service_id"); vals.Add((int) ServiceID);
                names.Add("i_title_id"); vals.Add((int) 0);
                names.Add("i_title_version"); vals.Add((int) 0);
                names.Add("i_title_region"); vals.Add((int) 0);
                names.Add("i_site_id"); vals.Add((int) EffectiveSiteID);

                _DBChanges.Add("t_service_instances", new List<DBChange>());
                _DBChanges["t_service_instances"].Add(new DBChange(
                    GenericTable.RowSource.Insert, names.ToArray(), vals.ToArray()));
            }

            // t_service_keys, this is done by xkeymgr, so if it is failing, this row won't show up
            names.Clear(); vals.Clear();

            names.Add("i_key_type"); vals.Add((int) 6);
            names.Add("vc_service_data1"); vals.Add("ts");
            names.Add("vc_service_data2"); vals.Add("site" + EffectiveSiteID.ToString());
            names.Add("i_site_id"); vals.Add((int) EffectiveSiteID);
            names.Add("i_ticket_lifetime_secs"); vals.Add((Lifetime == 0) ? 36*3600 : Lifetime*3600);
            
            _DBChanges.Add("t_service_keys", new List<DBChange>());
            _DBChanges["t_service_keys"].Add(new DBChange(
                GenericTable.RowSource.Exists, names.ToArray(), vals.ToArray()));

            _ExpectKDCEvents = !NoReload;
            _ExpectLiveProxyKeyEvents = !NoReload;
            _ExpectLiveProxyPartnerEvents = !NoReload;
            _ExpectLiveProxyTitleEvents = !NoReload;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\match\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\lsp\SqlQueries.cs ===
namespace xonline.tools.livelsp
{
    public class SqlQueries
    {
        // Ugly raw SQL. This tool needs to be portable and we want to deploy it 
        // immediately, instead of waiting until the next release. We also don't want to 
        // do a QFE, so the choice to use embedded SQL instead of stored procs makes a 
        // little more sense.

        // UODB
        // {{{

        public const string GetTitleInfoSql = @"
            if not exists(select null from t_titles where i_title_id = @i_title_id)
            begin
                select 'No title id found' as 'message',
                       @i_title_id as 'param' for xml path('error'), type
                return
            end    
            select
            t.i_title_id as 'title-id',
            tfd.vc_Name as 'name',
            (
                select
                tv.i_base_version as '@base',
                tv.i_update_version as '@update',
                tv.i_beta_version as '@beta',
                tv.ti_console_type_id as '@console-type'
                from t_title_versions tv
                where 
                    tv.i_title_id = @i_title_id
                for xml path('title-version'), type
            ) as 'title-versions',
            (
                select
                'granted' as '@type',
                ts.i_service_id as 'service-id',
                svc.vc_description as 'description'
                from t_title_services ts 
                inner join 
                    t_services svc on svc.i_service_id = ts.i_service_id
                where 
                    ts.i_title_id = @i_title_id
                for xml path('service'), type
            ) as 'title-services',
            (
                select
                'associated' as '@type',
                si.i_service_id as 'service-id',
                svc.vc_description as 'description',
                si.i_title_id as 'title-id',
                si.i_title_version as 'title-version',
                si.i_title_region as 'title-region',
                si.i_site_id as 'site-id'
                from t_service_instances si
                inner join 
                    t_services svc on svc.i_service_id = si.i_service_id
                where 
                    si.i_title_id = @i_title_id
                for xml path('service'), type
            ) as 'service-instances'
            from t_titles t 
            left outer join t_title_feature_data tfd on tfd.i_TitleId = t.i_title_id
            where 
                t.i_title_id = @i_title_id
            for xml path('title-info'), type
        ";            

        public const string GetServiceInfoSql = @"
            if not exists(select null from t_services where i_service_id = @i_service_id)
            begin
                select 'No service id found' as 'message', 
                       @i_service_id as 'param' for xml path('error'), type
                return
            end    
            select
            svc.i_service_id as 'service-id',
            svc.vc_description as 'description',
            svc.vc_kerb_service_name as 'service-name',
            svc.vc_kerb_domain_name as 'domain-name',
            svc.i_machine_only as 'machine-only',
            (
                select distinct
                si.i_site_id as 'site-id'
                from t_service_instances si
                where 
                    si.i_service_id = @i_service_id
                for xml path('site'), type
            ) as 'sites',
            (
                select
                ts.i_title_id as 'title-id',
                tfd.vc_Name as 'name'
                from t_title_services ts
                left outer join 
                    t_title_feature_data tfd on tfd.i_TitleId = ts.i_title_id
                where 
                    ts.i_service_id = @i_service_id
                for xml path('title'), type
            ) as 'title-services',
            (
                select
                si.i_title_id as 'title-id',
                tfd.vc_Name as 'name',
                si.i_title_version as 'version',
                si.i_title_region as 'region',
                si.i_site_id as 'site-id',
                si.i_port as 'port',
                si.i_service_available as 'service-available'
                from t_service_instances si
                left outer join 
                    t_title_feature_data tfd on tfd.i_TitleId = si.i_title_id
                where 
                    si.i_service_id = @i_service_id
                for xml path('title'), type
            ) as 'service-instances'
            from t_services svc
            where svc.i_service_id = @i_service_id
            for xml path('service-info'), type
        ";

        public const string GetSiteServicesInfoSql = @"
            if not exists(select null from t_service_instances where i_site_id = @i_site_id)
            begin
                select 'No site id found' as 'message', 
                       @i_site_id as 'param' for xml path('error'), type
                return
            end  
            select
            (
                select
                'all' as '@type',
                si.i_service_id as 'service-id',
                svc.vc_description as 'description'
                from t_service_instances si 
                inner join 
                    t_services svc on svc.i_service_id = si.i_service_id
                where 
                    si.i_site_id = @i_site_id and 
                    si.i_title_id = 0
                for xml path('service'), type
            ),
            (
                select distinct
                'title' as '@type',
                si.i_service_id as 'service-id',
                svc.vc_description as 'description'
                from t_service_instances si 
                inner join 
                    t_services svc on svc.i_service_id = si.i_service_id
                where 
                    si.i_site_id = @i_site_id and 
                    si.i_title_id <> 0
                for xml path('service'), type
            )  
            for xml path('services')
        ";

        public const string MapServiceToSiteSql = @"
            -- t_service_instances
            if not exists (
                select null from t_service_instances 
                where i_title_id = @i_title_id 
                and i_service_id = @i_service_id
                and i_title_version = 0 
                and i_title_region = 0)
            begin
                insert into t_service_instances
                (i_service_id, i_title_id, i_title_version, i_title_region, i_site_id, i_port, i_service_available, dt_Change_datetime)
                values 
                (@i_service_id, @i_title_id, 0, 0, @i_site_id, 65535, 1, getutcdate())
            end
            else
            begin
                update t_service_instances
                set 
                    i_site_id = @i_site_id, 
                    dt_change_datetime = getutcdate()
                where 
                    i_title_id = @i_title_id and 
                    i_service_id = @i_service_id and 
                    i_title_version = 0 and 
                    i_title_region = 0
            end
        ";

        public const string UnmapServiceFromSiteSql = @"
            -- t_service_instances
            delete from t_service_instances
            where i_service_id = @i_service_id
            and i_site_id = @i_site_id
        ";

        public const string AddServiceGrantToTitleSql = @"
            -- t_title_services
            if not exists (
                select null from t_title_services
                where i_title_id = @i_title_id and i_service_id = @i_service_id)
            begin
                insert into t_title_services
                (i_title_id, i_service_id, dt_Change_datetime)
                values (@i_title_id, @i_service_id, getutcdate())
            end
        ";

        public const string RemoveServiceGrantFromTitleSql = @"
            if @i_title_id = 0
            begin
                return
            end    
            if @i_service_id != 0
            begin
                -- t_title_services
                delete from t_title_services 
                where i_title_id = @i_title_id 
                and i_service_id = @i_service_id
                
                -- t_service_instances
                delete from t_service_instances
                where i_service_id = @i_service_id
                and i_title_id = @i_title_id
                and i_title_version = 0
                and i_title_region = 0
            end
            else
            begin
                -- t_title_services
                delete from t_title_services
                where i_title_id = @i_title_id
                
                -- t_service_instances
                delete from t_service_instances
                where i_title_id = @i_title_id
                and i_title_version = 0
                and i_title_region = 0
            end
        ";

        public const string AddServiceSql = @"
            -- t_services
            if not exists (select null from t_services where i_service_id = @i_service_id)
            begin
                insert into t_services (
                    i_service_id, 
                    vc_kerb_service_name, 
                    vc_kerb_domain_name, 
                    vc_description, 
                    i_machine_only) 
                values (
                    @i_service_id,
                    'ts',
                    @vc_service_domain,
                    @vc_service_desc,
                    0
                )
            end
            else
            begin
                update t_services
                set
                    vc_description = @vc_service_desc,
                    dt_Change_datetime = getutcdate()
                where
                    i_service_id = @i_service_id
            end
        ";            

        public const string MapServiceToBaseOffersSql = @"
            -- t_offer_services (for all base offers)
            insert into t_offer_services (bi_offer_id, i_service_id) 
                select bi_offer_id, @i_service_id 
                from t_base_offers 
                where bi_offer_id not in (
                    select bi_offer_id 
                    from t_offer_services 
                    where i_service_id = @i_service_id
                )
        ";

        // }}} UODB

        // NPDB
        // {{{

        public const string AddBackCompatSettingSql = @"
            if (select charindex(@vc_title_id, vc_value) from t_settings where vc_setting = 'query_LspBackcompTitles') = 0
            begin
                update t_settings set vc_value = @vc_title_id + ';' + vc_value where vc_setting = 'query_LspBackcompTitles'
            end
        ";

        public const string AddInterfaceBucketSql = @"
            -- Get environment if none specified
            -- A stored proc could make these optional params, how do you do that here?
            declare @vc_environment as nvarchar(16)
            if @vc_environment is null
            begin
                select @vc_environment=vc_environment from t_environments where b_current=1
            end
            -- Already exists?
            if not exists (
                select null from t_interface_buckets 
                where 
                    vc_environment=@vc_environment and
                    vc_interface='querydb' and
                    i_title_id=@i_title_id and
                    i_bucket=0xaaaa)
            begin
                -- Get querydb if none specified and we're inserting a new record
                if @vc_querydb is null or @vc_querydb = ''
                begin
                    declare @t_temp_servers table (vc_server nvarchar(64))
                    insert @t_temp_servers (vc_server) exec p_config_get_server_list_by_interface @vc_environment = @vc_environment, @vc_interface = N'querydb'

                    select top 1 @vc_querydb=vc_server from @t_temp_servers 

                    print @vc_querydb
                end
                -- Then insert
                insert into t_interface_buckets
                    (vc_environment, vc_interface, i_title_id, i_bucket, vc_server, vc_next_server, 
                     dt_migration_start, vc_info1, vc_info2, vc_info3, vc_info4)
                values
                    (@vc_environment, 'querydb', @i_title_id, 0xAAAA, @vc_querydb, @vc_querydb, 
                     '9999-12-31 23:59:59.000', -1, '', '', '')
            end
            else if @vc_querydb is not null and @vc_querydb != ''
            begin
                -- Else update
                update t_interface_buckets 
                set
                    vc_server=@vc_querydb,
                    vc_next_server=@vc_querydb
                where 
                    vc_environment=@vc_environment and
                    vc_interface='querydb' and
                    i_title_id=@i_title_id and
                    i_bucket=0xaaaa
            end
        ";

        public const string GetSiteInfoSql = @"
            declare @vc_environment nvarchar(64)
            select @vc_environment = vc_environment from t_environments where b_current = 1

            if not exists(select null from t_sites where i_site_id = @i_site_id)
            begin
                select 'No site id found' as 'message',
                       @i_site_id as 'param' for xml path('error'), type
                return
            end
            
			select
            ip.i_site_id as 'site-id',
            '' as 'description',
            dbo.fn_get_service_name_from_virtual_interface(ip.vc_virtual_interface) as 'service-name',
            dbo.fn_get_domain_name_from_site_id(ip.i_site_id) as 'domain-name',
            ip.vc_ip as 'ip',
            s.i_authdata_version as 'authdata-version',
            (
                select 
                i_ticket_lifetime_secs as 'ticket-lifetime',
                i_master_key_version as 'master-key-version',
                i_key_version as 'key-version'
                from t_service_keys
                where
                    i_key_type = 6 and
                    i_site_id = @i_site_id and
                    vc_environment = @vc_environment
                for xml path ('key-info'), type
            ) 
            from t_site_virtual_interface_ips ip
            inner join t_sites s
            on ip.vc_environment = s.vc_environment
            and ip.i_site_id = s.i_site_id
            where 
                ip.i_site_id = @i_site_id and
                ip.vc_virtual_interface in ('sgsvc', 'sgsvc_xlsp') and
                ip.vc_environment = @vc_environment
            for xml path('site-info')
        ";

        public const string AddSiteSql = @"
            -- t_sites
            declare @vc_environment nvarchar(64)
            select @vc_environment = vc_environment from t_environments where b_current = 1

            if not exists (select null from t_sites where i_site_id = @i_site_id and vc_environment = @vc_environment)
            begin            
                insert into t_sites (
                    vc_environment,
                    i_site_id,
                    vc_domain,
                    i_authdata_version
                    )
                select top 1
                    @vc_environment,
                    @i_site_id,
                    vc_domain,
                    @i_authdata_version
                from t_sites
                where vc_environment = @vc_environment
            end
            else
            begin
                update t_sites
                set
                    i_authdata_version = @i_authdata_version
                where
                    i_site_id = @i_site_id
                and vc_environment = @vc_environment
            end
        ";

        public const string AddSiteVirtualInterfaceIpSql = @"
            -- t_site_virtual_interface_ip
            declare @vc_environment nvarchar(64)
            select @vc_environment = vc_environment from t_environments where b_current = 1

            if not exists (select null from t_site_virtual_interface_ips where i_site_id = @i_site_id and vc_environment = @vc_environment and vc_virtual_interface = 'sgsvc_xlsp')
            begin
                insert into t_site_virtual_interface_ips (
                    vc_environment,
                    i_site_id, 
                    vc_virtual_interface, 
                    vc_ip
                )
                values (
                    @vc_environment,
                    @i_site_id,
                    'sgsvc_xlsp',
                    case when (@vc_ip is not null and @vc_ip != '') then @vc_ip else '1.1.1.1' end
                )
            end
            else
            begin
                if (@vc_ip is not null and @vc_ip != '')
                begin
                    update t_site_virtual_interface_ips
                    set
                        vc_ip = @vc_ip
                    where
                        i_site_id = @i_site_id
                    and vc_environment = @vc_environment
                    and vc_virtual_interface = 'sgsvc_xlsp'
                end
            end
        ";

        // }}} NPDB             
        
        // WEBDB
        // @@@kgoodier These were implemented by dcaiafa and are currently unused
        // {{{

        public const string AddAllowedApiSql = @"
            if not exists (
                select null
                from t_partner_allowed_apis
                where 
                    i_partner_id = @i_partner_id
                    and vc_api_name = @vc_api_name )
            begin
                insert into dbo.t_partner_allowed_apis (
                    i_partner_id,
                    vc_api_name,
                    dt_change_datetime
                )
                values (
                    @i_partner_id,
                    @vc_api_name,
                    getutcdate()
                )
            end
        ";

        public const string AddAllowedTitleSql = @"
            if exists (
                select null
                from dbo.t_partner_allowed_titles
                where 
                    i_partner_id = @i_partner_id
                    and i_title_id = @i_title_id)
            begin
                -- Row already exists. Update privilege.
                update t_partner_allowed_titles
                set i_title_privilege = @i_title_privilege
                where 
                    i_partner_id = @i_partner_id and 
                    i_title_id = @i_title_id
            end
            else
            begin
                -- new row
                insert into dbo.t_partner_allowed_titles (
                    i_partner_id,
                    i_title_id,
                    i_title_privilege,
                    dt_Change_datetime
                )
                values (
                    @i_partner_id,
                    @i_title_id,
                    @i_title_privilege,
                    getutcdate()
                )
            end
        ";

        public const string GetPartnerInfoSql = @"
            select
                p.i_partner_id as 'partner-id',
                p.vc_description as 'partner-description',
                p.i_cred_type as 'cred-type',
                p.vc_subject_name as 'cred-subject-name',
                ( select 
                    at.i_title_id as 'title',
                    at.i_title_privilege as 'title-privilege'
                    from dbo.t_partner_allowed_titles at
                    where at.i_partner_id = p.i_partner_id
                    for xml path('allowed-title'), type
                ) as 'allowed-titles',
                ( select
                    lower(aa.vc_api_name) as 'api'
                    from dbo.t_partner_allowed_apis aa
                    where aa.i_partner_id = p.i_partner_id
                    for xml path(''), type
                ) as 'allowed-apis',
                ( select
                    ip.i_ip as 'ip'
                    from dbo.t_partner_ips ip
                    where i_partner_id = p.i_partner_id
                    for xml path(''), type
                ) as 'allowed-ips'
            from dbo.t_partners p
            where p.i_partner_id = @i_partner_id
            for xml path('partner'), type
        ";

        // }}} WEBDB
                
    }  // SqlQueries

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\match\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\match\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_livematch_none_12.4.56.0_none_506410e5344421d4
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_livematch_no-public-key_12.4.56.0_x-ww_fe4371bc
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=livematch
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_livematch_no-public-key_12.4.56.0_x-ww_fe4371bc
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_livematch_no-public-key_12.4.56.0_x-ww_fe4371bc.manifest
XP_MANIFEST_PATH=manifests\msil_livematch_no-public-key_12.4.56.0_x-ww_fe4371bc.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_livematch_no-public-key_12.4.56.0_x-ww_fe4371bc.cat
XP_CATALOG_PATH=manifests\msil_livematch_no-public-key_12.4.56.0_x-ww_fe4371bc.cat
XP_PAYLOAD_PATH=msil_livematch_no-public-key_12.4.56.0_x-ww_fe4371bc
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=livematch,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\match\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_livematch_none_12.4.56.0_none_506410e5344421d4
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_livematch_no-public-key_12.4.56.0_x-ww_fe4371bc
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=livematch
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_livematch_no-public-key_12.4.56.0_x-ww_fe4371bc
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_livematch_no-public-key_12.4.56.0_x-ww_fe4371bc.manifest
XP_MANIFEST_PATH=manifests\msil_livematch_no-public-key_12.4.56.0_x-ww_fe4371bc.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_livematch_no-public-key_12.4.56.0_x-ww_fe4371bc.cat
XP_CATALOG_PATH=manifests\msil_livematch_no-public-key_12.4.56.0_x-ww_fe4371bc.cat
XP_PAYLOAD_PATH=msil_livematch_no-public-key_12.4.56.0_x-ww_fe4371bc
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=livematch,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\stats\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\stats\exe\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\stats\exe\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\systemcheck\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\match\livematch.cs ===
using System;
using System.Collections;
using System.Security.Principal;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.match;
using xonline.common.tools;
using xonline.common.tools.console;
using xonline.tools.framework;

[assembly: XomAreaDefinition(XomAreaName.log)]

namespace xonline.tools.titlesuite
{

class LiveMatch
{
    public delegate int CommandExecution(NamedArgParser args);
    static Hashtable       _hashCommand      = null;
    static string[] _rgstrCmdLineTags = null;
    static CTitleId _tid;

    static string [] _arrCmdString = 
    {
        "?",
        "help",
        "deploymatch",
        "deployxboxmatch",
        "startmigrationforbucket",
        "endmigrationforbucket",
        "expeditemigrationforbucket",
        "migrationstatusforbucket",
        "startmigrationfortitle",
        "endmigrationfortitle",
        "expeditemigrationfortitle",
        "migrationstatusfortitle",
        "startmigrationforserver",
        "endmigrationforserver",
        "expeditemigrationforserver",
        "migrationstatusforserver",
        "addrrbucket",
        "draintoprrbucket",
        "removetoprrbucket",
        "sessioncountforbucket",
        "configuresessionlimits"
    };


    static string [] _arrParamString = 
    {
        "titleid",
        "add",
        "fallback",
        "delete",
        "noreload",
        "droptable",
        "removemode",
        "newmodeserver",
        "server",
        "notitlsql",
        "overridebuckets",
        "type",
        "mode",
        "rrid",
        "source",
        "dest",
        "verbose",
        "script",
        "enabled",
        "maxavail",
        "truncateavail",
        "warnavail",
        "maxunavail",
        "truncateunavail",
        "warnunavail",
        "periodminutes",
        "offsetminutes",
        "force",
        "ignorenondesterrors"
    };

    class CommandClass
    {
        public string           m_szCommandName;
        public string []        m_arrSzParamRequiredNoVal;
        public string []        m_arrSzParamRequiredWithVal;
        public string []        m_arrSzParamOptionalWithVal;
        public CommandExecution m_ExecCode;

        public CommandClass(string szCommandName, 
                            string [] arrSzParamRequiredWithVal, 
                            string [] arrSzParamRequiredNoVal, 
                            string [] arrSzParamOptionalWithVal,
                            CommandExecution exec)
        {
            m_szCommandName = szCommandName;
            m_arrSzParamRequiredNoVal = arrSzParamRequiredNoVal;
            m_arrSzParamRequiredWithVal = arrSzParamRequiredWithVal;
            m_arrSzParamOptionalWithVal = arrSzParamOptionalWithVal;
            m_ExecCode              = exec;

            if (null == m_szCommandName || null == m_arrSzParamRequiredWithVal || 
                null == m_arrSzParamRequiredNoVal || null == m_arrSzParamOptionalWithVal ||
                null == m_ExecCode)
                throw new Exception("CommandClass Param cannot be null");
        }

        public bool ParamCheck(NamedArgParser args)
        {
            // check the required params that don't care if they have a value
            bool bRet = true;
            foreach (string szParam in m_arrSzParamRequiredNoVal)
            {
                if (args[szParam] == null)
                {
                    bRet = false;
                    goto Error;
                }
            }

            // check the required params that do care if they have a value
            bRet = true;
            foreach (string szParam in m_arrSzParamRequiredWithVal)
            {
                if (args[szParam] == null || args[szParam] == "")
                {
                    bRet = false;
                    goto Error;
                }
            }
            
            // check the optional params that care if they have a value
            bRet = true;
            foreach (string szParam in m_arrSzParamOptionalWithVal)
            {
                if (args[szParam] != null && args[szParam] == "")
                {
                    bRet = false;
                    goto Error;
                }
            }
            
Error:
            return bRet;
        }

        public int Execute(NamedArgParser args)
        {
            return m_ExecCode(args);
        }

    }


    
    private static void Log(string message)
    {
        Xom.Log(XomAreaName.log, message);
        CommandUtility.WriteOutput(message);
    }
    private static void LogError(string message)
    {
        Xom.Log(XomAreaName.log, message);
        CommandUtility.WriteError(message);
    }

    private static int Usage(NamedArgParser ArgParser)
    {
        Console.WriteLine(LiveMatchUsage.Usage);
        return 1;
    }


    static void Init()
    {
        _hashCommand = new Hashtable();
        _hashCommand.Add("deploymatch", new CommandClass("deploymatch", new string[] {"titleid"}, new string[] {}, new string[] {"newmodeserver", "script"}, new CommandExecution(Deploy360Match)));  // other optional params: new string[] {"removemode", "droptable", "noreload", "overridebuckets"}
        _hashCommand.Add("deployxboxmatch", new CommandClass("deployxboxmatch", new string[] {"titleid"}, new string[] {}, new string[] {"add", "delete", "fallback", "script"}, new CommandExecution(DeployXbox1Match))); // other optional params: , "droptable", "noreload", "notitlsql"
        _hashCommand.Add("startmigrationforbucket", new CommandClass("startmigrationforbucket", new string[] {"titleid", "type", "mode", "rrid", "dest"}, new string[] {}, new string[] {}, new CommandExecution(StartMigrationForBucket))); // other optional params: "noreload", "notitlsql", "ignorenondesterrors"
        _hashCommand.Add("endmigrationforbucket", new CommandClass("endmigrationforbucket", new string[] {"titleid", "type", "mode", "rrid"}, new string[] {}, new string[] {} , new CommandExecution(EndMigrationForBucket))); // other optional params: "noreload"
        _hashCommand.Add("migrationstatusforbucket", new CommandClass("migrationstatusforbucket", new string[] {"titleid", "type", "mode", "rrid"}, new string[] {}, new string[] {}, new CommandExecution(MigrationStatusForBucket)));
        _hashCommand.Add("expeditemigrationforbucket", new CommandClass("expeditemigrationforbucket", new string[] {"titleid", "type", "mode", "rrid"}, new string[] {}, new string[] {}, new CommandExecution(ExpediteMigrationForBucket)));
        _hashCommand.Add("startmigrationfortitle", new CommandClass("startmigrationfortitle", new string[] {"titleid", "source", "dest"}, new string[] {}, new string[] {}, new CommandExecution(StartMigrationForTitle))); // other optional params: "noreload", "notitlsql", "ignorenondesterrors"
        _hashCommand.Add("endmigrationfortitle", new CommandClass("endmigrationfortitle", new string[] {"titleid", "source"}, new string[] {}, new string[] {} , new CommandExecution(EndMigrationForTitle))); // other optional params: "noreload"
        _hashCommand.Add("migrationstatusfortitle", new CommandClass("migrationstatusfortitle", new string[] {"titleid", "source"}, new string[] {}, new string[] {}, new CommandExecution(MigrationStatusForTitle)));
        _hashCommand.Add("expeditemigrationfortitle", new CommandClass("expeditemigrationfortitle", new string[] {"titleid", "source"}, new string[] {}, new string[] {}, new CommandExecution(ExpediteMigrationForTitle)));
        _hashCommand.Add("startmigrationforserver", new CommandClass("startmigrationforserver", new string[] {"source", "dest"}, new string[] {}, new string[] {}, new CommandExecution(StartMigrationForServer))); // other optional params: "noreload", "notitlsql", "ignorenondesterrors"
        _hashCommand.Add("endmigrationforserver", new CommandClass("endmigrationforserver", new string[] {"source"}, new string[] {}, new string[] {} , new CommandExecution(EndMigrationForServer))); // other optional params: "noreload"
        _hashCommand.Add("migrationstatusforserver", new CommandClass("migrationstatusforserver", new string[] {"source"}, new string[] {}, new string[] {}, new CommandExecution(MigrationStatusForServer)));
        _hashCommand.Add("expeditemigrationforserver", new CommandClass("expeditemigrationforserver", new string[] {"source"}, new string[] {}, new string[] {}, new CommandExecution(ExpediteMigrationForServer)));
        _hashCommand.Add("addrrbucket", new CommandClass("addrrbucket", new string[] {"titleid", "type", "mode", "server"}, new string[] {}, new string[] {}, new CommandExecution(AddRRBucket))); // other optional params: "noreload", "notitlsql"
        _hashCommand.Add("draintoprrbucket", new CommandClass("draintoprrbucket", new string[] {"titleid", "type", "mode"}, new string[] {}, new string[] {}, new CommandExecution(DrainTopRRBucket))); // other optional params: "noreload"
        _hashCommand.Add("removetoprrbucket", new CommandClass("removetoprrbucket", new string[] {"titleid", "type", "mode"}, new string[] {}, new string[] {}, new CommandExecution(RemoveTopRRBucket))); // other optional params: "noreload", "force"
        _hashCommand.Add("sessioncountforbucket", new CommandClass("sessioncountforbucket", new string[] {"titleid", "type", "mode", "rrid"}, new string[] {}, new string[] {}, new CommandExecution(SessionCountForBucket)));
        _hashCommand.Add("configuresessionlimits", new CommandClass("configuresessionlimits", new string[] {"titleid", "enabled", "maxavail", "truncateavail", "warnavail", "maxunavail", "truncateunavail", "warnunavail", "periodminutes", "offsetminutes"}, new string[] {}, new string[] {}, new CommandExecution(ConfigureSessionLimits)));
        _hashCommand.Add("help", new CommandClass("help", new string[] {}, new string[] {}, new string[] {}, new CommandExecution(Usage)));
        _hashCommand.Add("?", new CommandClass("?", new string[] {}, new string[] {}, new string[] {}, new CommandExecution(Usage)));

        _rgstrCmdLineTags = new string[_arrCmdString.Length + _arrParamString.Length];
        _arrCmdString.CopyTo  (_rgstrCmdLineTags, 0);
        _arrParamString.CopyTo(_rgstrCmdLineTags, _arrCmdString.Length);
    }



    [STAThread]
    static int Main(string[] args)
    {
        int nRet = -1;
        try
        {
            XomLoggingControl.Init();

            Init();

            string user = WindowsIdentity.GetCurrent().Name;
            string version = MatchSqlCodeGen.VersionString;

            NamedArgParser argParser = new NamedArgParser( _rgstrCmdLineTags );

            #region Validate commandline args

            try
            {
                if ( !argParser.Parse( args ) )
                {
                    if(String.IsNullOrEmpty(argParser.InvalidArgText)) {
                        Usage(null);
                    }
                    else {
                        Console.WriteLine("Unrecognized argument \"" + argParser.InvalidArgText + "\".  Run \"LiveMatch.exe /?\" for usage information.");
                    }
                    return nRet;
                }
            }
            catch ( Exception e )
            {
                LogError( "There was an error: \r\n" + e.ToString() );
                LogError( "\r\nThe above error occurred while attempting to parse command-line " );
                LogError( " arguments. Please check the arguments and retry." );
                return nRet;
            }

            if (((string)argParser["verbose"]) == "")
            {
                CommandUtility.IsVerbose = true;
            }
            else
            {
                CommandUtility.IsVerbose = false;
            }

            Log( "\r\n        L  I  V  E    M A T C H");
            Log("        Build(" + version + "), user(" + user + ")");
            Log( "\r\n=================================================\r\nCommand Line Arguments were: " );

            foreach( object thisArg in argParser.Keys )
            {
                if ( ( (string) argParser[ thisArg.ToString() ] ) == "" )
                {
                    //for switches that don't supply an argument
                    Log( "Switch " + ( (string) thisArg ).PadLeft( 26, ' ') + "    Was Present " );
                }
                else
                {
                    Log( "Switch " + ( (string) thisArg ).PadLeft( 26, ' ') + "    had the value " + ( (string) argParser[ thisArg.ToString() ] ));
                }
            }
            Log( "\r\n===================" );

            UInt32  nCommandFound    = 0;
            string szCommandToExec  = "?";
            foreach (string szCommand in _arrCmdString)
            {
                if(argParser[szCommand] != null)
                {
                    nCommandFound++;
                    szCommandToExec = szCommand;
                }
            }

            // most of the commands require titleid.  Instead of making them all re-parse, do it once...
            // doing it here also allows us to maintain back compat for the "no action" case by auto
            // choosing between deploy360 and deployxbox1.
            string strTitle = argParser["titleid"];

            if(strTitle != null && strTitle != "")
            {
                // The titleid on the command line is in hex notation, but the user
                // may not have added the 0x prefix which is expected by the
                // CTitleId class for hex numbers. If it's not there, add it.
                // to force CTitleId to interpet the string as hex digits.
                if (strTitle.Length < 2 || !strTitle.StartsWith("0x"))
                {
                    strTitle = "0x" + strTitle;
                }

                // parse the titleid
                _tid = new CTitleId(strTitle);
                Log("Working with title ID: " + _tid.ToString());
            }

            // maintain back compat with the old action-free command line syntax
            if (nCommandFound == 0)
            {
                if(MatchAdmin.XmsExists(_tid))
                {
                    Log( "No action specified, but XMS exists -- defaulting to the 'deployxboxmatch' action");
                    szCommandToExec = "deployxboxmatch";
                }
                else
                {
                    Log( "No action specified, and no XMS for title -- defaulting to the 'deploymatch' (360) action");
                    szCommandToExec = "deploymatch";
                }

            }
            else if (nCommandFound > 1)
            {
                Log( "Error: exactly one valid action must  be specified.  Try livematch /?." );
                return nRet;
            }

            #endregion

            CommandClass commandObject = (CommandClass)_hashCommand[szCommandToExec];
            bool         bParamCheck   = commandObject.ParamCheck(argParser);
            if (bParamCheck)
            {
                Log("Starting Execution for command " + szCommandToExec);

                try
                {
                    nRet = commandObject.Execute(argParser);
                    if(nRet == 0)
                    {
                        Log("Succesfully Executed " + szCommandToExec);
                    }
                    else
                    {
                        Log("Executed " + szCommandToExec + " with return code " + nRet);
                    }
                }
                catch (Exception e1)
                {
                    LogError("Error While Performing Command " + szCommandToExec);
                    LogError(e1.Message);
                }
            }
            else
            {
                LogError("Missing Parameters for executing " + szCommandToExec);
            }
        }
        catch (ExceptionWithEventId e)
        {
            LogError("Error (event): " + e.ToString());
            EventBuilder.LogEvent(e.EventId, e.Message, e);
        }
        catch (Exception e)
        {
            LogError("Error (exception): " + e.ToString());
            EventBuilder.LogEvent(XEvent.Id.TOOLS_CODE_58, e.Message, e);
        }
        finally
        {
            Log("LiveMatch exiting.");
            XomLoggingControl.Close();
        }
            
        return nRet;
    }

    // deploys match for a 360 title.
    private static int Deploy360Match(NamedArgParser argParser)
    {
        Log("Running DeployMatch (360)");
        MatchGameConfig matchGameConfig = null;
        MatchLtcConfig matchLtcConfig = null;

        MatchAdmin.PrepLiveTitleConfig(_tid.uiTitleId, out matchLtcConfig, false /*fRequireBuckets*/);
        MatchAdmin.PrepGameConfig(_tid.uiTitleId, out matchGameConfig);

        // do the actual match deployment for the title
        MatchAdmin.ConfigureTitle(
                matchGameConfig, 
                matchLtcConfig, 
                argParser["newmodeserver"],
                (argParser["removemode"] != null),
                (argParser["droptable"] != null), 
                (argParser["noreload"] == null),
                (argParser["overridebuckets"] != null),
                argParser["script"]);
        return 0;
    }


    // deploys match for an xbox1 title.
    private static int DeployXbox1Match(NamedArgParser argParser)
    {
        Log("Running DeployXboxMatch");
        MatchLtcConfig matchLtcConfig = null;

        MatchAdmin.PrepLiveTitleConfig(_tid.uiTitleId, out matchLtcConfig, false /*fRequireBuckets*/);

        // do the actual match deployment for the title
        MatchAdmin.ConfigureXboxTitle(
                MatchAdmin.XmsPath(_tid), 
                matchLtcConfig,
                (argParser["droptable"] != null), 
                (argParser["noreload"] == null),
                (argParser["notitlsql"] != null),
                argParser["script"], 
                argParser["add"], 
                argParser["delete"],
                argParser["fallback"]);
        return 0;
    }


    // starts migration for a bucket (360 only)
    private static int StartMigrationForBucket(NamedArgParser argParser)
    {
        Log("Running StartMigrationForBucket");
        MatchGameConfig matchGameConfig = null;
        MatchLtcConfig matchLtcConfig = null;

        // make sure the server being migrated to is a valid match server (Xenon 106407)
        MatchAdmin.ConfirmServer(argParser["dest"]);
        
        // get the the ltc config for the title
        MatchAdmin.PrepLiveTitleConfig(_tid.uiTitleId, out matchLtcConfig, true /*fRequireBuckets */);
        
        // allow the user to suppress the deployment to titlsql, in case they know the code is already there. 
        // the initial case for this is the site1->site5 migration, where we're doing a backup/restore.
        if(argParser["notitlsql"] == null)
        {
            // get the the xlast config for the title.  Only used if we're actually deploying sql code
            MatchAdmin.PrepGameConfig(_tid.uiTitleId, out matchGameConfig);

            // since we're migrating a bucket and we don't know if the server that bucket is going 
            // to already has match deployed to it, deploy match to all servers including the new one, to 
            // make sure all the bits are in sync.
            // TODOTHEOM: could check whether the server is already a match server, and skip this step in that case.
            MatchAdmin.ConfigureMatch(
                    matchGameConfig,
                    matchLtcConfig,
                    null, // strNewModeServer is null because you can't add a new mode while migrating.
                    argParser["dest"],
                    false, // fRemoveModeOk
                    false,  // droptable
                    false,  // no reload here... we'll do it after updating the DB
                    false,  // don't override the interface_buckets with the ones from ltc.  
                    argParser["ignorenondesterrors"] != null); // ignore errors from non-destination servers if set
        }

        MatchAdmin.StartMigrationForBucket(_tid.uiTitleId, GetBucketId(argParser), argParser["dest"], matchLtcConfig);

        // now that the DB is updated, reload to make sure the server lists used by the FD are up-to-date.
        // unless the user has asked us not to reload.  (also don't healthcheck)
        // having "noreload" imply no health check is how it's always worked for xbox 1 titles...
        if((argParser["noreload"] == null))
        {
            MatchAdmin.ReloadTitleInfo();
            MatchAdmin.HealthCheck();
        }
        return 0;
    }

    // ends migration for a bucket (360 only).  This just marks the migration
    // as complete, thereby abondoning any remaining rows on the source server.
    private static int EndMigrationForBucket(NamedArgParser argParser)
    {
        Log("Running EndMigrationForBucket");
        MatchLtcConfig matchLtcConfig = null;

        MatchAdmin.PrepLiveTitleConfig(_tid.uiTitleId, out matchLtcConfig, true /*fRequireBuckets */);
        MatchAdmin.EndMigrationForBucket(_tid.uiTitleId, GetBucketId(argParser), matchLtcConfig);

        // We updated the DB again, so reload to make sure the server lists used by the FD are up-to-date.
        // unless reloading is suppressed by the user
        if((argParser["noreload"] == null))
        {
            MatchAdmin.ReloadTitleInfo();
            MatchAdmin.HealthCheck();
        }
        return 0;
    }

    // expedite migration for a bucket (360 only).  Moves rows from the source
    // server to the destination server.
    private static int ExpediteMigrationForBucket(NamedArgParser argParser)
    {
        Log("Running ExpediteMigrationForBucket");
        MatchAdmin.ManualMigrateForBucket(_tid.uiTitleId, GetBucketId(argParser));
        return 0;
    }

    // get the status of migration for a bucket (360 only).  Prints out a count of how
    // many sessions (rows) remain to be migrated.
    private static int MigrationStatusForBucket(NamedArgParser argParser)
    {
        Log("Running MigrationStatusForBucket");
        MatchAdmin.MigrationStatusForBucket(_tid.uiTitleId, GetBucketId(argParser));
        return 0;
    }


    // starts migration for all the buckets for a given title that live on a given server (360 only)
    private static int StartMigrationForTitle(NamedArgParser argParser)
    {
        Log("Running StartMigrationForTitle");
        MatchGameConfig matchGameConfig = null;
        MatchLtcConfig matchLtcConfig = null;

        // make sure the server being migrated to is a valid match server (Xenon 106407)
        MatchAdmin.ConfirmServer(argParser["dest"]);
        
        // get the the ltc config for the title
        MatchAdmin.PrepLiveTitleConfig(_tid.uiTitleId, out matchLtcConfig, true /*fRequireBuckets */);

        // allow the user to suppress the deployment to titlsql, in case they know the code is already there. 
        // the initial case for this is the site1->site5 migration, where we're doing a backup/restore.
        if(argParser["notitlsql"] == null)
        {
            // get the the xlast config for the title.  Only used if we're actually deploying sql code
            MatchAdmin.PrepGameConfig(_tid.uiTitleId, out matchGameConfig);
            
            // first, since we're migrating a title and we don't know if the server that title is going 
            // to already has match deployed to it, deploy match to all servers including the new one, to 
            // make sure all the bits are in sync.
            // TODOTHEOM: could check whether the server is already a match server, and skip this step in that case.
            MatchAdmin.ConfigureMatch(
                    matchGameConfig,
                    matchLtcConfig,
                    null, // strNewModeServer is null because you can't add a mode while migrating.
                    argParser["dest"],
                    false, // fRemoveModeOk
                    false,  // droptable
                    false,  // no reload here... we'll do it after updating the DB
                    false,  // don't override the interface_buckets with the ones from ltc.  
                    argParser["ignorenondesterrors"] != null); // ignore errors from non-destination servers if set
        }

        MatchAdmin.StartMigrationForTitle(_tid.uiTitleId, argParser["source"], argParser["dest"]);

        // now that the DB is updated, reload to make sure the server lists used by the FD are up-to-date.
        // unless reloading is suppressed by the user
        if((argParser["noreload"] == null))
        {
            MatchAdmin.ReloadTitleInfo();
            MatchAdmin.HealthCheck();
        }
        return 0;
    }

    // ends migration for all the buckets for a given title that live on a given server (360 only).  
    // This just marks the migration as complete, thereby abondoning any remaining rows on the source server.
    private static int EndMigrationForTitle(NamedArgParser argParser)
    {
        Log("Running EndMigrationForTitle");
        MatchLtcConfig matchLtcConfig = null;
        
        MatchAdmin.PrepLiveTitleConfig(_tid.uiTitleId, out matchLtcConfig, true /*fRequireBuckets */);
        MatchAdmin.EndMigrationForTitle(_tid.uiTitleId, argParser["source"], matchLtcConfig);

        // We updated the DB again, so reload to make sure the server lists used by the FD are up-to-date.
        // unless reloading is suppressed by the user
        if((argParser["noreload"] == null))
        {
            MatchAdmin.ReloadTitleInfo();
            MatchAdmin.HealthCheck();
        }
        return 0;

    }

    // expedite migration for all the buckets for a given title that live on a given server (360 only).
    // Moves rows from the source server to the destination server.
    private static int ExpediteMigrationForTitle(NamedArgParser argParser)
    {
        Log("Running ExpediteMigrationForTitle");
        MatchAdmin.ManualMigrateForTitle(_tid.uiTitleId, argParser["source"]);
        return 0;
    }

    // get the status of migration for all the buckets for a given title that live on a given server (360 only).
    // Prints out a count of how many sessions (rows) remain to be migrated.
    private static int MigrationStatusForTitle(NamedArgParser argParser)
    {
        Log("Running MigrationStatusForTitle");
        MatchAdmin.MigrationStatusForTitle(_tid.uiTitleId, argParser["source"]);
        return 0;
    }



    // starts migration for all buckets on a given server (360 only)
    private static int StartMigrationForServer(NamedArgParser argParser)
    {
        Log("Running StartMigrationForServer");

        // make sure the server being migrated to is a valid match server (Xenon 106407)
        MatchAdmin.ConfirmServer(argParser["dest"]);

        MatchAdmin.StartMigrationForServer(argParser["source"], 
                                            argParser["dest"], 
                                            argParser["notitlsql"] != null,
                                            argParser["ignorenondesterrors"] != null); // ignore errors from non-destination servers if set

        // We updated the DB, so reload to make sure the server lists used by the FD are up-to-date.
        // unless reloading is suppressed by the user
        if((argParser["noreload"] == null))
        {
            MatchAdmin.ReloadTitleInfo();
            MatchAdmin.HealthCheck();
        }
        return 0;
    }

    // ends migration for all buckets on a given server (360 only).  
    // This just marks the migration as complete, thereby abondoning any remaining rows 
    // on the source server.
    private static int EndMigrationForServer(NamedArgParser argParser)
    {
        Log("Running EndMigrationForServer");
        MatchAdmin.EndMigrationForServer(argParser["source"]);

        // We updated the DB again, so reload to make sure the server lists used by the FD are up-to-date.
        // unless reloading is suppressed by the user
        if((argParser["noreload"] == null))
        {
                MatchAdmin.ReloadTitleInfo();
                MatchAdmin.HealthCheck();
        }
        return 0;
    }

    // expedite migration for all buckets on a given server (360 only).
    // Moves rows from the source server to the destination server.
    private static int ExpediteMigrationForServer(NamedArgParser argParser)
    {
        Log("Running ExpediteMigrationForServer");
        MatchAdmin.ManualMigrateForServer(argParser["source"]);
        return 0;
    }

    // get the status of migration for all buckets on a given server (360 only).  
    // Prints out a count of how many sessions (rows) remain to be migrated.
    private static int MigrationStatusForServer(NamedArgParser argParser)
    {
        Log("Running MigrationStatusForServer");
        MatchAdmin.MigrationStatusForServer(argParser["source"]);
        return 0;
    }



    // (360 only) Add a round-robin server for a given type/mode
    private static int AddRRBucket(NamedArgParser argParser)
    {
        Log("Running AddRRServer");
        MatchLtcConfig matchLtcConfig = null;
        MatchGameConfig matchGameConfig = null;

        // make sure the server being added to is a valid match server (Xenon 106407)
        MatchAdmin.ConfirmServer(argParser["server"]);

        // load up the config from ltc and xlast
        MatchAdmin.PrepLiveTitleConfig(_tid.uiTitleId, out matchLtcConfig, true /*fRequireBuckets */);
        MatchAdmin.PrepGameConfig(_tid.uiTitleId, out matchGameConfig);

        MatchAdmin.AddRRBucket(_tid.uiTitleId, 
                                            argParser["server"], 
                                            Convert.ToByte(argParser["type"]), 
                                            Convert.ToByte(argParser["mode"]), 
                                            matchGameConfig, 
                                            matchLtcConfig,
                                            argParser["notitlsql"] != null);


        // We updated the DB with the new bucket, so reload to make sure the server lists used by the FD are up-to-date.
        // unless reloading is suppressed by the user
        if((argParser["noreload"] == null))
        {
                MatchAdmin.ReloadTitleInfo();
                MatchAdmin.HealthCheck();
        }

        return 0;
    }


    // (360 only) Mark a round-robin server for a given type/mode to be "drained" so that no more sessions are created there
    private static int DrainTopRRBucket(NamedArgParser argParser)
    {
        Log("Running DrainTopRRBucket");
        MatchLtcConfig matchLtcConfig;
        MatchGameConfig matchGameConfig;

        // load up the config from ltc and xlast
        MatchAdmin.PrepLiveTitleConfig(_tid.uiTitleId, out matchLtcConfig, true /*fRequireBuckets */);
        MatchAdmin.PrepGameConfig(_tid.uiTitleId, out matchGameConfig);

        MatchAdmin.DrainTopRRBucket(_tid.uiTitleId, Convert.ToByte(argParser["type"]), Convert.ToByte(argParser["mode"]));

        // We updated the bucket's state in the database, so reload to make sure the server lists used by the FD are up-to-date
        // Unless reloading is suppressed by the user
        if((argParser["noreload"] == null))
        {
            MatchAdmin.ReloadTitleInfo();
            MatchAdmin.HealthCheck();
        }

        return 0;
    }

    // (360 only) Remove a round-robin server for a given type/mode.
    private static int RemoveTopRRBucket(NamedArgParser argParser)
    {
        Log("Running RemoveTopRRBucket");
        MatchLtcConfig matchLtcConfig;
        MatchGameConfig matchGameConfig;

        // load up the config from ltc and xlast
        MatchAdmin.PrepLiveTitleConfig(_tid.uiTitleId, out matchLtcConfig, true /*fRequireBuckets */);
        MatchAdmin.PrepGameConfig(_tid.uiTitleId, out matchGameConfig);

        MatchAdmin.RemoveTopRRBucket(_tid.uiTitleId, Convert.ToByte(argParser["type"]), Convert.ToByte(argParser["mode"]), matchLtcConfig, argParser["force"] != null);

        // We updated the bucket's state in the database, so reload to make sure the server lists used by the FD are up-to-date
        // Unless reloading is suppressed by the user
        if((argParser["noreload"] == null))
        {
            MatchAdmin.ReloadTitleInfo();
            MatchAdmin.HealthCheck();
        }

        return 0;
    }

    // (360 only) Prints out a count of how many sessions (rows) remain to be migrated.
    private static int SessionCountForBucket(NamedArgParser argParser)
    {
        Log("Running SessionCountForBucket");
        return((int)MatchAdmin.SessionCountForBucket(_tid.uiTitleId, GetBucketId(argParser)));
    }



    // (360 only) Configure this title to automatically create a SQL agent job, which 
    // will delete sessions for the title if they get beyond established limits.
    // This method only configured the limits -- the job is created on deployment/migration.
    private static int ConfigureSessionLimits(NamedArgParser argParser)
    {
        Log("Running ConfigureSessionLimits");
        MatchLtcConfig matchLtcConfig = null;

        // get the params from the argParser
        bool fEnabled = Convert.ToBoolean(argParser["enabled"]);
        uint uiMaxAvail = Convert.ToUInt32(argParser["maxavail"]);
        uint uiTruncateAvail = Convert.ToUInt32(argParser["truncateavail"]);
        uint uiWarnAvail = Convert.ToUInt32(argParser["warnavail"]);
        uint uiMaxUnavail = Convert.ToUInt32(argParser["maxunavail"]);
        uint uiTruncateUnavail = Convert.ToUInt32(argParser["truncateunavail"]);
        uint uiWarnUnavail = Convert.ToUInt32(argParser["warnunavail"]);
        uint uiPeriodMinutes = Convert.ToUInt32(argParser["periodminutes"]);
        uint uiOffsetMinutes = Convert.ToUInt32(argParser["offsetminutes"]);

        // do some param validation
        if(uiPeriodMinutes > 60 || uiPeriodMinutes < 1)
            throw new ArgumentException( "Error: periodminutes must be between 1 and 60" );

        if(uiOffsetMinutes > 59) // < 0 will be caught when Convert.ing above.
            throw new ArgumentException( "Error: offsetminutes must be between 0 and 59" );

        if(uiMaxAvail < uiWarnAvail || uiMaxUnavail < uiWarnUnavail)
            throw new ArgumentException("Error: The session warning level (both available and unavail) must be less than the corresponding session max level.");

        if(uiMaxAvail < uiTruncateAvail || uiMaxUnavail < uiTruncateUnavail)
            throw new ArgumentException("Error: The session truncation level (both available and unavail) must be less than the corresponding session max level.");
        
        
        // load up the config from ltc 
        MatchAdmin.PrepLiveTitleConfig(_tid.uiTitleId, out matchLtcConfig, false /*fRequireBuckets */);

        MatchAdmin.ConfigureSessionLimits(_tid.uiTitleId, 
                                                            fEnabled, 
                                                            uiMaxAvail, 
                                                            uiTruncateAvail, 
                                                            uiWarnAvail, 
                                                            uiMaxUnavail, 
                                                            uiTruncateUnavail, 
                                                            uiWarnUnavail, 
                                                            uiPeriodMinutes, 
                                                            uiOffsetMinutes, 
                                                            matchLtcConfig);
        return 0;
    }


    private static uint GetBucketId(NamedArgParser argParser)
    {
            uint dwBucketId = 0xFFFFFFFF; // TODOTHEOM: invalid_bucket
            byte bType = Convert.ToByte(argParser["type"]);
            byte bMode = Convert.ToByte(argParser["mode"]);
            byte bRRId = Convert.ToByte(argParser["rrid"]);
            // figure out what bucket id we're going to be operating on
            dwBucketId = (uint)(bType << 16) |
                                    (uint)(bMode << 8) |
                                    (uint)bRRId;
            return dwBucketId;
    }

}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\match\LiveMatchUsage.cs ===
namespace xonline.tools.titlesuite
{

// The C# parser in Source Insight (my editor) doesn't understand multi-line
// string, which messes up the syntax highlighting and code nagivation
// features of the editor for files with multi-line strings. So I've put
// this string into its own file to keep it from messing up LiveMatch.cs
class LiveMatchUsage
{
/*
0.........1.........2.........3.........4.........5.........6.........7.........8
*/
    public const string Usage = @"
Configures matchmaking database(s) for a title.

LiveMatch usage is similar to the other title tools.  In any run, you specify 
one action you'd like livematch to take, and then additional parameters that 
provide information for performing that action.

If no action is specified but a titleid is specified, LiveMatch will try to 
figure out whether the titleid is xbox1 or xbox 360, and will run the 
deploymatch or deployxboxmatch action as appropriate by default.  

Actions: 

Required and optional params are listed per action, with optional params in [].

    LiveMatch /deploymatch /titleid:<titleid> [/newmodeserver:<server>] 
                           [/script:<file>] [/droptable] [/noreload]  
                           [/removemode] [/overridebuckets] [/verbose]   
        Deploys an xbox 360 title.  Creates and updates the stored procs and
        tables on the titlsql servers, and updates t_interface_buckets and 
        the LTC with partition map information.
        
    LiveMatch /deployxboxmatch /titleid:<titleid> [/add:<server>] 
                               [/delete:<server>] [/fallback:<server>] 
                               [/script:<file>] [/droptable] [/noreload] 
                               [/notitlsql]
        Deploys an xbox 1 title.  Creates and updates the stored procs and
        tables on the titlsql servers, and updates t_interface_buckets with 
        a single t_interface_buckets entry for each round-robin server for
        the title.  (xbox1 titles do not support partitioning or migration.)

    LiveMatch /startmigrationforbucket /titleid:<titleid> /type:<typeid> 
                                       /mode:<modeid> /rrid:<rrid> 
                                       /dest:<targetserver>
        (360 only) Initiates a migration for a bucket.  The target server 
        is immediately entered in t_interface_buckets.  Traffic will start 
        migrating to the new server once a config cache refresh interval has 
        passed, so that all front doors have the update info.  While a 
        migration is in progress, all new sessions will be created on the 
        destination server and any session updates will cause sessions to be 
        moved to the dest server.  Migrations can't be started while
        a drain operation is underway for the title.

    LiveMatch /endmigrationforbucket /titleid:<titleid> /type:<typeid> 
                                     /mode:<modeid> /rrid:<rrid>
        (360 only) When called on a bucket that has had migration started on 
        it, this action simply ends the migration, pointing all traffic to 
        the new server.  Any sessions that were not yet migrated are 
        abandoned!

    LiveMatch /migrationstatusforbucket /titleid:<titleid> /type:<typeid> 
                                        /mode:<modeid> /rrid:<rrid>
        (360 only) Returns info on how the migration is going for a given 
        bucket.  This includes how many 'breadcrumb', 'sandwich', and total 
        sessions remain on the server that's being migrated from.  

    LiveMatch /sessioncountforbucket /titleid:<titleid> /type:<typeid> 
                                     /mode:<modeid> /rrid:<rrid>
        (360 only) Similar to migrationstatusforbucket, but also 
        returns the drain status of the bucket.

    LiveMatch /expeditemigrationforbucket /titleid:<titleid> /type:<typeid> 
                                          /mode:<modeid> /rrid:<rrid>
        (360 only) Forcibly moves sessions between the 'current' and 'next' 
        servers of the migrating pair.  This action should be used after 
        startmigration has been called, and the migration has been given some 
        time to progress naturally.

    LiveMatch /startmigrationfortitle /titleid:<titleid> /source:<server>
                    /dest:<targetserver>
        (360 only) Initiates a migration for all buckets for a title on a 
        server.  Otherwise, just like startmigrationforbucket.

    LiveMatch /endmigrationfortitle /titleid:<titleid> /source:<server>
        (360 only) Ends a migration for all buckets for the given title that are 
        currently located on the /source server, and are in migration.
        Otherwise, just like /endmigrationforbucket.

    LiveMatch /migrationstatusfortitle /titleid:<titleid> /source:<server>
        (360 only) Returns info on how the migration is going for all
        buckets for the given title that are located on the /source server
        and are in migration.  
        Otherwise, just like /migrationstatusforbucket.
        
    LiveMatch /expeditemigrationfortitle /titleid:<titleid> /source:<server>
        (360 only) Forcibly moves sessions between the 'current' and 'next' 
        servers, for all buckets for the given title that are currently located 
        on the /source server, and are in migration.  
        Otherwise, just like /expeditemigrationforbucket

    LiveMatch /startmigrationforserver /source:<server> /dest:<targetserver>
        (360 only) Initiates a migration for all buckets on the /source server,
        sending them to the /dest server.
        Otherwise, just like startmigrationforbucket.

    LiveMatch /endmigrationforserver /source:<server>
        (360 only) Ends migration for all buckets that are being migrated from
        the /source server to some other server.
        Otherwise, just like /endmigrationforbucket.

    LiveMatch /migrationstatusforserver /source:<server>
        (360 only) Returns info on how the migration is going for all
        buckets that are being migrated from the /source server to
        some other server.
        Otherwise, just like /migrationstatusforbucket.
        
    LiveMatch /expeditemigrationforserver /source:<server>
        (360 only) Forcibly moves sessions to the destination server
        for all buckets that are being migrated from the /source server.
        Otherwise, just like /expeditemigrationforbucket

    LiveMatch /addrrbucket /titleid:<titleid> /type:<typeid> 
                           /mode:<modeid> /server:<targetserver>
        (360 only) Adds a round-robin server for a given type and mode.  
        This should only be used in extreme cases, where a given 
        type/mode combination is so popular that a single titlsql server 
        cannot support it!  This command will re-use any draining buckets
        before actually adding new ones.

    LiveMatch /draintoprrbucket /titleid:<titleid> /type:<typeid> 
                                /mode:<modeid>
        (360 only) Marks a round-robin bucket for draining, i.e. the server 
        for the given type and mode will be taken out of the rotation for
        session creation.  

    LiveMatch /removetoprrbucket /titleid:<titleid> /type:<typeid> 
                                 /mode:<modeid> [/force]
        (360 only) Immediately removes the top round-robin bucket.  This 
        generally is done only after a bucket has fully drained, because
        otherwise any sessions in the bucket will be orphaned.  If the top
        bucket is not marked for draining, an error will be returned, unless 
        the /force flag is supplied.

    LiveMatch /configuresessionlimits /titleid:<titleid> /enabled:<true|false> 
                    /maxavail:<count> /truncateavail:<count> /warnavail:<count>
                    /maxunavail:<count> /truncateunavail:<count> 
                    /warnunavail:<count> /periodminutes:<value> 
                    /offsetminutes:<value>
        (360 only) Configures the session limit sql agent job for the title.  
        When the number of available or unavailable sessions for the title on a
        single server exceeds the 'max' count, this job will delete sessions 
        until it reaches the 'truncate' count.  The job that does this cleanup 
        is run every 'periodminutes', starting at 'offsetminutes' after 
        midnight.  If enabled is set to false, the job will be created but not 
        run.
        NOTE: /configuresessionlimits does not deploy the job.  You must 
        redeploy the title after configuring the session limits, in order to 
        get the job deployed.

    LiveMatch /help or /?
        Outputs what you're looking at now.


Parameters:

This section explains the parameters that may be passed to the actions.
Not all params may be passed to all actions, so please see the list of 
params for each action above to decide which params are relevant.

    /titleid:<titleid>
        The titleid in hex notation (with or without 0x prefix)

    /verbose
        If this optional switch is specified, LiveMatch will print 
        the full verbose output.

    /droptable
        If this optional switch is specified, LiveMatch will drop
        the current match table and recreate it. Use with caution
        on non-development environments, since this will delete
        all active sessions from the database for the title.

    /noreload
        If this optional switch is specified, LiveMatch will skip 
        front door reload.

    /script:<file>
        Write sql script to the specified file instead of
        running the sql statements directly against one or
        more matchmaking databases. <file> is required.
        The resulting script can be run using isqlw, which 
        may allow you to pinpoint where sql errors occur.

    /delete:<machinename>
        Removes the specified machinename from 
        npdb.t_interface_buckets so front doors will
        not attempt to use it, and updates the live title
        config in npdb so future executions of LiveMatch
        will not use the specified server. NOTE: This does
        NOT actually delete any tables or stored procedures
        from the specified server. While it is not required
        you may manually delete the tables and stored
        procs after a /delete operation, if you wish
        to avoid having unused tables and stored procs
        on a particular server.  

    /add:<machinename>
        Creates all tables and stored procs 
        associated with the specified title to the database
        on machinename. Also add that machinename
        to npdb.t_interface_buckets so front doors will
        not attempt to use it, and updates the live title
        config in npdb so future executions of LiveMatch
        will use the specified server. Note that a title
        should only span multiple servers if one dedicated
        database server cannot handle the load for the title,
        because spanning multiple servers makes searches
        less effective, because they do not consider all
        possible sessions. Use /add followed by /delete
        to move a title to a new match database, but note
        that /delete is destructive and should be used with
        caution. <machinename> may be a semicolon delimited
        list of machinenames. /add and /delete may be specified
        on the same command. /add operations will be performed
        first, followed by delete operations.

    /fallback:<machinename>
        When the LTC file that exists does not 
        contain valid servers this fallback machine name will 
        be used instead.

    /notitlsql
        Talk to dev before you use this. 

    /ignorenondesterrors
        Optional flag that can be used when starting migrations.
        If a server that you are migrating from is down or unreachable, 
        then migration will fail when it attempts to migrate matchmaking 
        sessions.  Using this flag will cause the migration process to 
        ignore errors on all but the destination server during the 
        matchmaking migration.


    /newmodeserver:<server>
        If you reprop an xbox 360 title and the new xlast has a game mode
        that was not present in the last prop, livematch needs to decide
        which server that new mode should live on.  This param specifies
        the server name.  

    /removemode
        If you reprop an xbox 360 title and the new xlast is missing a 
        game mode that was in the previous prop, you must specify this
        parameter to tell livematch that it's ok to remove the mode.
        This action abandons any sessions that were in the removed mode.

    /type:<typeid>
        Used with migration actions to act on a bucket, 
        to specify the gametype of the bucket.  The typeid is expected to 
        be an integer, 0 for ranked and 1 for standard match.

    /mode:<modeid> 
        Used with migration actions to act on a bucket, 
        to specify the gamemode of the bucket.  The modeid is expected to
        be an integer, and comes from the value=<int> attribute of the 
        GameMode in the title's xlast.

    /rrid:<rrid>
        Used with migration actions to act on a bucket, 
        to specify the round-robin id of the bucket.  For most titles (since
        they don't and shouldn't use round-robining) this value will be 0. 

    /source:<server>
        Used when doing a migration operation against all buckets on 
        a server, or all buckets on a server for a specific title.
        (see *migrationfortitle/*migrationforserver)

    /dest:<targetserver>
        Used when starting a migration, to indicate the 
        destination server for that migration.

    /server:<targetserver>
        Used when adding a round-robin server, 
        (action /addrrbucket) to specify the name of the server.

    /overridebuckets
        When deploying a 360 title, you can force livematch to overwrite
        the buckets in the t_interface_buckets table with the buckets from
        the LTC.  This is intended to be used for initial deployments of 
        titles that will have custom partition maps right out of the gate.

    /enabled:<true|false>
        Used when configuring session limits.
        This enables or disables the session limit job.  
        Can be false (for disable) or true (for enable).
    
    /max(avail|unavail)
        Used when configuring session limits.
        This is the max number of available or unavailable sessions that the 
        title is allowed to have on a single server.  Value is a uint.
    
    /truncate(avail|unavail)
        Used when configuring session limits.
        When the Max is exceeded, sessions are deleted until they reach
        this level.
        This value must be less than the value of max(avail|unavail).

    /warn(avail|unavail)
        Used when configuring session limits.
        When the warning level is exceeded, an event is dropped to
        notify ops that this title may have a problem.
        This value must be less than the value of max(avail|unavail).

    /periodminutes
        Used when configuring session limits.
        This is the amount of time between each run of the sql agent
        job that cleans up the sessions.
        This value must be in the range 1 through 60, inclusive.

    /offsetminutes
        Used when configuring session limits.
        This is the offset (after midnight) for the first run of the sql agent
        job that cleans up the sessions.  This allows different hit titles to 
        be configured at different times, so that they don't all run at once.
        This value must be in the range 0 through 59, inclusive.

    /force
        Used to force the removal of a round-robin bucket that is not marked
        for draining.
";
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\stats\livestats.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.IO;

using xonline.common.mgmt;
using xonline.common.config;
using xonline.common.leaderboard;
using xonline.common.livetitleconfig;
using xonline.common.service;
using xonline.common.tools;
using xonline.common.tools.console;
using xonline.common.xlastutil;
using xonline.common.xboxutil;
using xonline.common.protocol;
using xonline.tools.framework;
using xonline.tools.toolsuite;
using xonline.stats.admin;

namespace xonline.tools.toolsuite
{
    /// <summary>
    /// Command line code for the LiveStats tool
    /// </summary>
    class stats
    {
        public delegate void MoveLbsInternalCommand(int titleid, int lbid, string szServer);
        public delegate int CommandExecution(NamedArgParser args);
        static Hashtable       _hashCommand      = null;
        static string[] _rgstrCmdLineTags = null;

        /// <summary>
        /// Transition States for Migration
        /// </summary>
        public enum MigrationPhase {
            MigrationBegin,
            MigrationReadOnly,
            MigrationCopy,
            MigrationSwap,
            MigrationFinish,
        }

        static string [] _arrCmdString = 
        {
            "?",
            "deploylb",
            "deployxboxlb",
            "movelb",
            "movecompetitionlb",
            "movelbserverconfigonly",
            "deletetitle",
            "reportconfiguration",
            "resetlb",
            "resettitle",
            "reloadwebstats",
            "reloadfrontdoor",
            "deploywebdbonlylb",
            "deploywebdbonlylbxbox1",
            "settoreadonly",
            "settoreadwrite",
            "load",
            "unload",
            "issafetodeletelb",
            "cleanclip",
            "cleanxboxclip"
        };

        static string [] _arrParamString = 
        {
            "titleid",
            "lbs",
            "maxreads",
            "maxwrites",
            "lbid",
            "comppartition_id",
            "source",
            "dest",
            "puid",
            "force",
            "safeseed",
            "timeout",
            "server",
            "hoursfromnow",
            "verbose"
        };

        class CommandClass
        {
            public string           m_szCommandName;
            public string []        m_arrSzParamRequired;
            public CommandExecution m_ExecCode;

            public CommandClass(string szCommandName, string [] arrSzParamRequired, CommandExecution exec)
            {
                m_szCommandName         = szCommandName;
                m_arrSzParamRequired    = arrSzParamRequired;
                m_ExecCode              = exec;

                if (null == m_szCommandName || null == m_arrSzParamRequired || null == m_ExecCode)
                    throw new Exception("CommandClass Param cannot be null");
            }

            public bool ParamCheck(NamedArgParser args)
            {
                bool bRet = true;
                foreach (string szParam in m_arrSzParamRequired)
                {
                    if (args[szParam] == null)
                    {
                        bRet = false;
                        break;
                    }
                }

                return bRet;
            }

            public int Execute(NamedArgParser args)
            {
                return m_ExecCode(args);
            }

        }

        static void Init()
        {
            _hashCommand = new Hashtable();
            _hashCommand.Add("deploylb"           , new CommandClass("deploylb"           , new string[] {"titleid"}, new CommandExecution(DeployLb)));
            _hashCommand.Add("deployxboxlb"       , new CommandClass("deployxboxlb"       , new string[] {"titleid"}, new CommandExecution(DeployXboxLb)));
            _hashCommand.Add("movelb"             , new CommandClass("movelb"             , new string[] {"titleid", "lbid", "source", "dest"}, new CommandExecution(MoveLb)));
            _hashCommand.Add("movecompetitionlb"  , new CommandClass("movecompetitionlb"  , new string[] {"titleid", "comppartition_id", "dest"}, new CommandExecution(MoveCompetitionLb)));
            _hashCommand.Add("movelbserverconfigonly"  , new CommandClass("movelbserverconfigonly"  , new string[] {"source", "dest"}, new CommandExecution(MoveLbServerConfigOnly)));
            _hashCommand.Add("deletetitle"        , new CommandClass("deletetitle"        , new string[] {"titleid"}, new CommandExecution(DeleteTitle)));
            _hashCommand.Add("reportconfiguration", new CommandClass("reportconfiguration", new string[] {"titleid"}, new CommandExecution(ReportConfiguration)));
            _hashCommand.Add("resetlb"            , new CommandClass("resetlb"            , new string[] {"titleid", "lbid"}, new CommandExecution(ResetLb)));
            _hashCommand.Add("resettitle"         , new CommandClass("resettitle"         , new string[] {"titleid"}, new CommandExecution(ResetTitle)));
            _hashCommand.Add("reloadwebstats"     , new CommandClass("reloadwebstats"     , new string[] {}, new CommandExecution(ReloadWebStats)));   
            _hashCommand.Add("reloadfrontdoor"    , new CommandClass("reloadfrontdoor"    , new string[] {}, new CommandExecution(ReloadFrontDoor))); 
            _hashCommand.Add("deploywebdbonlylb"       , new CommandClass("deploywebdbonlylb"  , new string[] {"titleid"}, new CommandExecution(DeployWebDbOnlyLbForXbox360)));
            _hashCommand.Add("deploywebdbonlylbxbox1"  , new CommandClass("deploywebdbonlylbxbox1"  , new string[] {"titleid"}, new CommandExecution(DeployWebDbOnlyLbForXbox1)));
            _hashCommand.Add("settoreadonly"      , new CommandClass("deploywebdbonlylb"  , new string[] {"titleid", "lbid", "server"}, new CommandExecution(SetToReadOnly)));
            _hashCommand.Add("settoreadwrite"     , new CommandClass("deploywebdbonlylb"  , new string[] {"titleid", "lbid", "server"}, new CommandExecution(SetToReadWrite)));
            _hashCommand.Add("load"               , new CommandClass("deploywebdbonlylb"  , new string[] {"titleid", "lbid", "server"}, new CommandExecution(LoadLb)));
            _hashCommand.Add("unload"             , new CommandClass("deploywebdbonlylb"  , new string[] {"titleid", "lbid", "server"}, new CommandExecution(UnLoadLb)));
            _hashCommand.Add("issafetodeletelb"   , new CommandClass("deploywebdbonlylb"  , new string[] {"server", "safeseed"}, new CommandExecution(IsSafeToDeleteLb)));
            _hashCommand.Add("cleanclip"          , new CommandClass("cleanclip"          , new string[] {"titleid", "hoursfromnow"}, new CommandExecution(CleanClip)));
            _hashCommand.Add("cleanxboxclip"      , new CommandClass("cleanxboxclip"      , new string[] {"titleid", "hoursfromnow"}, new CommandExecution(CleanXboxClip)));
            _hashCommand.Add("?"                  , new CommandClass("?"                  , new string[] {}, new CommandExecution(Usage)));

            _rgstrCmdLineTags = new string[_arrCmdString.Length + _arrParamString.Length];
            _arrCmdString.CopyTo  (_rgstrCmdLineTags, 0);
            _arrParamString.CopyTo(_rgstrCmdLineTags, _arrCmdString.Length);
        }


        [STAThread]
        static int Main(string[] args)
        {
            int nRet = -1;
            try
            {
                XomLoggingControl.Init();

                Init();

                NamedArgParser argParser = new NamedArgParser( _rgstrCmdLineTags );

                #region Validate commandline args

                try
                {
                    if ( !argParser.Parse( args ) )
                    {
                        if(String.IsNullOrEmpty(argParser.InvalidArgText)) {
                            Usage();
                        }
                        else {
                            Console.WriteLine("Unrecognized argument \"" + argParser.InvalidArgText + "\".  Run \"LiveStats.exe /?\" for usage information.");
                        }
                        return nRet;
                    }
                }
                catch ( Exception e )
                {
                    CommandUtility.WriteError( "There was an error: \r\n" + e.ToString() );
                    CommandUtility.WriteError( "\r\nThe above error occurred while attempting to parse command-line " );
                    CommandUtility.WriteError( " arguments. Please check the arguments and retry." );
                    return nRet;
                }

                if (((string)argParser["verbose"]) == "") {
                    CommandUtility.IsVerbose = true;
                }
                else {
                    CommandUtility.IsVerbose = false;
                }

                CommandUtility.WriteOutput( "\r\n         L  I  V  E    S  T  A  T  S");
                CommandUtility.WriteOutput( "\r\n=================================================\r\nCommand Line Arguments were: " );

                foreach( object thisArg in argParser.Keys )
                {
                    if ( ( (string) argParser[ thisArg.ToString() ] ) == "" )
                    {
                        //for switches that don't supply an argument
                        CommandUtility.WriteOutput( "Switch " + ( (string) thisArg ).PadLeft( 30, ' ') + "    Was Present " );
                    }
                    else
                    {
                        CommandUtility.WriteOutput( "Switch " + ( (string) thisArg ).PadLeft( 30, ' ') + "    had the value |" + ( (string) argParser[ thisArg.ToString() ] ).PadRight( 30, ' ') + "|" );
                    }
                }
                CommandUtility.WriteOutput( "\r\n===================" );

                UInt32  nCommandFound    = 0;
                string szCommandToExec  = "?";
                foreach (string szCommand in _arrCmdString)
                {
                    if(argParser[szCommand] != null)
                    {
                        nCommandFound++;
                        szCommandToExec = szCommand;
                    }
                }

                if (nCommandFound == 0 || nCommandFound > 1)
                {
                    CommandUtility.WriteError( "Error: Exactly One of (/? /deploylb, /deployxboxlb, /movelb, /deletetitle, /reportconfiguration, /resetlb etc. ) must be specified" );
                    return nRet;
                }

                #endregion

                CommandClass commandObject = (CommandClass)_hashCommand[szCommandToExec];
                bool         bParamCheck   = commandObject.ParamCheck(argParser);
                if (bParamCheck)
                {
                    CommandUtility.WriteOutput("Starting Execution for command {0}", szCommandToExec);
                    try
                    {
                        commandObject.Execute(argParser);
                        nRet = 0;
                        CommandUtility.WriteOutput("Succesfully Executed {0}", szCommandToExec);
                    }
                    catch (Exception e1)
                    {
                        CommandUtility.WriteError("Error While Performing Command {0}", szCommandToExec);
                        CommandUtility.WriteError("{0}", e1.Message);
                    }
                }
                else
                {
                    CommandUtility.WriteError("Missing Parameters for executing {0}", szCommandToExec);
                }
            }
            catch (Exception e)
            {
                Xom.NtEvent( XEvent.Id.TOOLS_CONFIG_43, e, e.Message);
            }
            finally
            {
                XomLoggingControl.Close();
            }
                
            return nRet;
        }

        static int DeployLb(NamedArgParser argParser)
        {
            return DeployLbInternal(argParser, false);
        }
        
        static int DeployXboxLb(NamedArgParser argParser)
        {
            return DeployLbInternal(argParser, true);
        }

        static int ReloadWebStats(NamedArgParser argParser)
        {
            string szTimeOut = argParser[ "timeout" ];

            if (szTimeOut == null)
            {
                DbLeaderboard.ResetWebStatsOnly();
            }
            else
            {
                int nTimeOutInSeconds = SafeConvert.ToInt32(argParser[ "timeout" ], 60);
                DbLeaderboard.ResetWebStatsOnly(nTimeOutInSeconds * 1000);
            }
            
            return 0;
        }

        static int ReloadFrontDoor(NamedArgParser argParser)
        {
            string szTimeOut = argParser[ "timeout" ];

            if (szTimeOut == null)
            {
                DbLeaderboard.ResetStatsFDOnly();
            }
            else
            {
                int nTimeOutInSeconds = SafeConvert.ToInt32(argParser[ "timeout" ], 60);
                DbLeaderboard.ResetStatsFDOnly(nTimeOutInSeconds * 1000);
            }
            
            return 0;
        }

        // default implementation of movelb, passes false for fConfigOnly
        // TODO: long term, all the params to MoveLB should probably be passed as such, rather than being in the namedargparser
        static int MoveLb(NamedArgParser argParser)
        {
            return MoveLb(argParser, false);
        }

        /*
            - Can move one or ALL leaderboards

            Steps:

                    1. Set Source server to read only
                    2. Wait until safe to unload but don't unload
                    3. On the destination server, perform a reload
                    4. Set it to RW
                    5. Change the NPDB/WebDB settings to point to the new server
                    6. Unload the source server

             Params: 
                argParser has all the args passed by the user (should be TitleID, lbid, SourceServer, DestinationServer)
                fConfigOnly tells MoveLb to just update NPDB and LTC
        */
        static int MoveLb(NamedArgParser argParser, bool fConfigOnly)
        {
            try
            {
                int     nTitleID       = SafeConvert.ToInt32(argParser[ "titleid" ]);
                int  [] arrLbId        = null;
                string  szSourceServer = argParser["source"];
                string  szDestServer   = argParser["dest"];

                //source should not be the same as destination or we may have complication
                if (szSourceServer.Trim().ToUpper() == szDestServer.Trim().ToUpper())
                {
                    throw new Exception("Source cannot be Equal to destination");
                }

                if (!DbLeaderboard.IsLeaderBoardServer(szSourceServer))
                {
                    throw new Exception(string.Format("{0} is not a leaderboard Server", szSourceServer));
                }

                if (!DbLeaderboard.IsLeaderBoardServer(szDestServer))
                {
                    throw new Exception(string.Format("{0} is not a leaderboard Server", szDestServer));
                }

                if (argParser["lbid"].IndexOf("ALL") != -1)
                {
                    arrLbId = DbLeaderboard.GetAllLbForTitle(nTitleID, szSourceServer);
                }
                else
                {
                    arrLbId   = new int[1];
                    arrLbId[0]= int.Parse(argParser[ "lbid" ]);
                }

                if (arrLbId.Length <= 0)
                {
                    CommandUtility.WriteError("\r\nWarning: No Leaderboards Found for title {0} on Server {1}", nTitleID, szSourceServer);
                }
                else if (fConfigOnly)
                {
                    for (int i = 0; i < arrLbId.Length; i++)
                    {
                        CommandUtility.WriteOutput("\t\tSwitching Database to point to new server");
                        DbLeaderboard.SetLbsvrForTitle(nTitleID, arrLbId[i], szDestServer);

                        CommandUtility.WriteOutput("\t\tUpdating LTC File to remember LBS Move");
                        UpdateLTC(szDestServer, nTitleID, arrLbId[i]);
                    }

                    // no front door reload when "configonly" is passed.  The caller needs to deal with that.
                }
                else
                {
                    try 
                    {
                        for (int i = 0; i < arrLbId.Length; i++)
                        {
                            CommandUtility.WriteOutput("Processing LBID {0}", arrLbId[i]);

                            CommandUtility.WriteOutput("\t\tSet Source to Read Only");

                            uint nSwapSeed = DbLeaderboard.SetReadOnly(nTitleID, arrLbId[i], szSourceServer);

                            bool bSafe = false;

                            CommandUtility.WriteOutput("\t\tVerifying Safe To Delete LB from Source");
                            while (!bSafe)
                            {
                                bSafe = DbLeaderboard.SafeToDeleteLb(nSwapSeed, szSourceServer);
                                if (!bSafe)
                                {
                                    System.Threading.Thread.Sleep(1000); //sleep 1 second
                                    CommandUtility.WriteOutput("\t\t\tStill Waiting For LBSVR to Drain DB transactions");
                                }
                            }

                            CommandUtility.WriteOutput("\t\tLoading LB in destination server");
                            DbLeaderboard.LoadLb(nTitleID, arrLbId[i], szDestServer);

                            CommandUtility.WriteOutput("\t\tSetting Destination LBSVR as Writable");
                            DbLeaderboard.SetReadWrite(nTitleID, arrLbId[i], szDestServer);

                            CommandUtility.WriteOutput("\t\tSwitching Database to point to new server");
                            DbLeaderboard.SetLbsvrForTitle(nTitleID, arrLbId[i], szDestServer);

                            CommandUtility.WriteOutput("\t\tEverything Good - Updating LTC File to remember LBS Move");
                            UpdateLTC(szDestServer, nTitleID, arrLbId[i]);
                        }

                        CommandUtility.WriteOutput("\tCalling Reload on all Stats FD");
                        DbLeaderboard.ResetStatsFDOnly();
                    }
                    catch
                    {
                        //some errors happen - it is important that we quickly make the old leaderboards functional
                        CommandUtility.WriteError("Error - Rolling Back Best Effort");
                        for (int i=0;i<arrLbId.Length;i++)
                        {
                            CommandUtility.WriteError("\t\tRoll Back - Set back to Writable - LBID {0} on Server {1}", arrLbId[i], szSourceServer);
                            DbLeaderboard.SetReadWrite(nTitleID, arrLbId[i], szSourceServer);
                        }

                        for (int i=0;i<arrLbId.Length;i++)
                        {
                            CommandUtility.WriteError("\t\tRoll Back - Point Back To Old Server - LBID {0} on Server {1}", arrLbId[i], szSourceServer);
                            DbLeaderboard.SetLbsvrForTitle(nTitleID, arrLbId[i], szSourceServer);
                        }

                        CommandUtility.WriteError("\t\tRoll Back - Resetting Stats FD Only");
                        DbLeaderboard.ResetStatsFDOnly();
                        
                        throw;
                    }

                }

                CommandUtility.WriteOutput("Move LBS Complete for title {0}", nTitleID);
            }
            catch
            {
                throw;
            }
            finally
            {
                
            }
            
            return 0;
        }


        // default implementation of movecompetitionlb, passes false for fConfigOnly
        // TODO: long term, all the params to MoveCompetitionLB should probably be passed as such, rather than being in the namedargparser
        static int MoveCompetitionLb(NamedArgParser argParser)
        {
            return MoveCompetitionLb(argParser, false);
        }


        /// <summary>
        /// Moves one or ALL Competition Leaderboards
        /// 
        /// Steps: [Very Similar to MoveLb]
        ///     1. Enumerate all CLBs of Title on the Source Server (Discovered by Title & Partition)
        ///     2. [Disable Creation of CLBs for the Current Title on this/all Partition(s)]
        ///     3. Lock Source Server Title's Partition CLBs to Read Only
        ///     4. Wait until safe and copy all of partition CLBs to Destination Server
        ///     5. Set Destination Server to Read/Write
        ///     6. Update NPDB to point to new server
        ///     7. [Enable Creation of CLBs for the Current Title]
        ///     8. Delete Source Server's Title's Partition CLBs
        ///     9. Repeat Steps 2 - 8 with other Titles's Partitions on Source Server if moving ALL CLBs
        /// </summary>
        /// <param name="argParser">
        ///     Params: 
        ///         argParser has all the args passed by the user (should be TitleID, CompetitionPartitionID, DestinationServer)
        ///         fConfigOnly tells MoveLb to just update NPDB and LTC
        ///</param>
        /// <returns></returns>
        static int MoveCompetitionLb(NamedArgParser argParser, bool fConfigOnly)
        {
            try
            {
                // Only 4 partitions max on which any templates can be created...
                //     All Templates need to be detected for a given partition
                int nTitleID = SafeConvert.ToInt32(argParser["titleid"]);
                string szDestServer = argParser["dest"];
                string szSourceServer = "";
                int []arrLeaderboards = null;
                ArrayList[] arrCLBs = new ArrayList[4];
                Hashtable arrSwapseeds = new Hashtable();
                MigrationPhase currentPhase = MigrationPhase.MigrationBegin;

                // Check that the destination is a legitimate server
                if (!DbLeaderboard.IsLeaderBoardServer(szDestServer))
                {
                    throw new Exception(string.Format("{0} is not a leaderboard Server", szDestServer));
                }

                // Initialize the CLB ArrayList
                for (int i = 0; i < 4; i++)
                {
                    arrCLBs[i] = null;
                }

                // Finding all Leaderboards on the given Partition ID
                CommandUtility.WriteOutput("Finding all Competition Leaderboards on the given Partition ID {0}...", argParser["comppartition_id"]);
                if (argParser["comppartition_id"].IndexOf("ALL") != -1)
                {
                    // Add to ALL 4 different partitions (Bits 30-31 of LbId [Is 0x3 an invalid partition?])

                    // Create arraylists for each partition
                    for (int i = 0; i < 4; i++)
                    {
                        arrCLBs[i] = new ArrayList(10);
                    }

                    // Get all Competition Leaderboards for the title
                    arrLeaderboards = DbLeaderboard.GetAllCompLbForTitle(nTitleID);
                    foreach (int lbid in arrLeaderboards)
                    {
                        if (StatLbIdParser.IsCompetition((uint)lbid))
                        {
                            CommandUtility.WriteOutput("\tFound CLB {0}", (uint)lbid);
                            arrCLBs[StatLbIdParser.GetPartition((uint)lbid)].Add(lbid);
                        }
                    }
                }
                else
                {
                    // Only ONE of the 4 partitions is moving, save PartID temporarily
                    uint partitionID = SafeConvert.ToUInt32(argParser["comppartition_id"]);

                    // Create arraylist for the partition
                    arrCLBs[partitionID] = new ArrayList(10);

                    // Get all Competition Leaderboards for the title
                    arrLeaderboards = DbLeaderboard.GetAllCompLbForTitle(nTitleID);
                    foreach (int lbid in arrLeaderboards)
                    {
                        if (StatLbIdParser.IsCompetition((uint)lbid))
                        {
                            // Add to CLB ArrayList only if PartID matches
                            if ((uint)StatLbIdParser.GetPartition((uint)lbid) == partitionID)
                            {
                                CommandUtility.WriteOutput("\tFound CLB {0}", (uint)lbid);
                                arrCLBs[partitionID].Add(lbid);
                            }
                        }
                    }
                }

                CommandUtility.WriteOutput("Beginning Migration Process...");
                for (int i = 0; i < 4; i++)
                {
                    if (arrCLBs[i] == null)
                    {
                        // This partition is not moving, skip
                        continue;
                    }
                    else if (fConfigOnly)
                    {
                        CommandUtility.WriteOutput("\t\tSwitching Database to point to new server");
                        DbLeaderboard.SetCompLbsvrForTitle(nTitleID, i, szDestServer);

                        // to be complete, we should also update the LTC for each leaderboard.
                        // TODO: this is potentially quite slow because the file is downloaded and opened each time.  The same applies in MoveLb (non-competition)
                        if(arrCLBs[i].Count > 0)
                        {
                            foreach (int lbid in arrCLBs[i])
                            {
                                UpdateLTC(szDestServer, nTitleID, lbid);
                            }
                        }

                    }
                    else if (arrCLBs[i].Count > 0)
                    {
                        try
                        {
                            currentPhase = MigrationPhase.MigrationBegin;

                            // Find the Server for the partition using first LBID (NOTE: The Stored Proc has a case to cover CLBs)
                            try
                            {
                                szSourceServer = DbLeaderboard.GetNPDBLeaderboardServerByID(nTitleID, (int)arrCLBs[i][0]);
                            }
                            catch
                            {
                                // SRC Server not found
                                CommandUtility.WriteOutput("\tWarning: Could not find the Server mapped to for Partition {0}", i);
                                continue;
                            }

                            // SRC Server Found, time to process Migration for this partition
                            CommandUtility.WriteOutput("\t\tSRC Server Found: {0}", szSourceServer);

                            // source should not be the same as destination or we may have complication
                            if (szSourceServer.Trim().ToUpper() == szDestServer.Trim().ToUpper())
                            {
                                CommandUtility.WriteOutput("\tWarning: Source Equals Destination [{0}]. Skipping...", szDestServer);
                                continue;
                            }

                            // Block All Creation of Leaderboards on this Partition Bucket
                            CommandUtility.WriteOutput("\tBlocking Creation of CLBs on Partition {0}...", i);
                            DbLeaderboard.LockCompLbsvrPartitionForTitle(nTitleID, i, true);

                            // ReadOnly Phase - Set all CLBs on this partition to ReadOnly
                            currentPhase = MigrationPhase.MigrationReadOnly;
                            CommandUtility.WriteOutput("\t\tSetting Source CLBs to Read Only...");
                            foreach (int lbid in arrCLBs[i])
                            {
                                CommandUtility.WriteOutput("Processing LBID {0}", lbid);
                                arrSwapseeds.Add(lbid, DbLeaderboard.SetReadOnly(nTitleID, lbid, szSourceServer));
                            }

                            // Copy Phase - Load new Server and Set to ReadWrite
                            currentPhase = MigrationPhase.MigrationCopy;
                            CommandUtility.WriteOutput("\t\tCopying to Destination Server...");
                            foreach (int lbid in arrCLBs[i])
                            {
                                bool bSafe = false;

                                CommandUtility.WriteOutput("\t\tVerifying Safe To Delete LB from Source");
                                while (!bSafe)
                                {
                                    bSafe = DbLeaderboard.SafeToDeleteLb((uint)arrSwapseeds[lbid], szSourceServer);
                                    if (!bSafe)
                                    {
                                        System.Threading.Thread.Sleep(1000); //sleep 1 second
                                        CommandUtility.WriteOutput("\t\t\tStill Waiting For LBSVR to Drain DB transactions");
                                    }
                                }

                                CommandUtility.WriteOutput("\t\tLoading LB in destination server");
                                DbLeaderboard.LoadLb(nTitleID, lbid, szDestServer);

                                CommandUtility.WriteOutput("\t\tSetting Destination LBSVR as Writable");
                                DbLeaderboard.SetReadWrite(nTitleID, lbid, szDestServer);
                            }

                            // Swap Phase - Redirect Interface Bucket to new server
                            currentPhase = MigrationPhase.MigrationSwap;
                            CommandUtility.WriteOutput("\t\tSwitching Database to point to new server");
                            DbLeaderboard.SetCompLbsvrForTitle(nTitleID, i, szDestServer);

                            // Unblock Creation of Leaderboards on this Partition Bucket
                            DbLeaderboard.LockCompLbsvrPartitionForTitle(nTitleID, i, false);

                            CommandUtility.WriteOutput("\t\tCalling Reload on all Stats FD");
                            DbLeaderboard.ResetStatsFDOnly();

                            currentPhase = MigrationPhase.MigrationFinish;
                        }
                        catch
                        {
                            //some errors happen - it is important that we quickly make the old leaderboards functional
                            CommandUtility.WriteError("Error: Rolling Back Best Effort");
                            switch (currentPhase)
                            {
                                case MigrationPhase.MigrationBegin:
                                    // Nothing to be fixed
                                    // Just set Leaderboard Server back
                                    CommandUtility.WriteError("\t\tRoll Back - Point Back To Old Server");
                                    DbLeaderboard.SetCompLbsvrForTitle(nTitleID, i, szSourceServer);

                                    // Unblock Creation of Leaderboards on this Partition Bucket
                                    DbLeaderboard.LockCompLbsvrPartitionForTitle(nTitleID, i, false);
                                    break;

                                case MigrationPhase.MigrationReadOnly:
                                    // Set back to R/W and set to Source Server
                                    CommandUtility.WriteError("\t\tRoll Back - Set back to Writable");
                                    foreach (int lbid in arrCLBs[i])
                                    {
                                        DbLeaderboard.SetReadWrite(nTitleID, lbid, szSourceServer);
                                    }

                                    // Unblock Creation of Leaderboards on this Partition Bucket
                                    DbLeaderboard.LockCompLbsvrPartitionForTitle(nTitleID, i, false);
                                    break;

                                case MigrationPhase.MigrationSwap:
                                case MigrationPhase.MigrationCopy:
                                    CommandUtility.WriteOutput("\tError in Updating Server");
                                    // Set to R/W and set back to Source Server
                                    CommandUtility.WriteError("\t\tRoll Back - Set back to Writable");
                                    foreach (int lbid in arrCLBs[i])
                                    {
                                        DbLeaderboard.SetReadWrite(nTitleID, lbid, szSourceServer);
                                    }
                                    DbLeaderboard.SetCompLbsvrForTitle(nTitleID, i, szSourceServer);

                                    // Unblock Creation of Leaderboards on this Partition Bucket
                                    DbLeaderboard.LockCompLbsvrPartitionForTitle(nTitleID, i, false);
                                    break;

                                case MigrationPhase.MigrationFinish:
                                default:

                                    // Unblock Creation of Leaderboards on this Partition Bucket
                                    DbLeaderboard.LockCompLbsvrPartitionForTitle(nTitleID, i, false);
                                    break;
                            }

                            CommandUtility.WriteError("\t\tRoll Back - Resetting Stats FD Only");
                            DbLeaderboard.ResetStatsFDOnly();

                            throw;
                        }
                    }
                    else
                    {
                        // -- Empty Partition, just move the partition only, no LBs --

                        try
                        {
                            currentPhase = MigrationPhase.MigrationBegin;

                            // Block All Creation of Leaderboards on this Partition Bucket
                            CommandUtility.WriteOutput("\tBlocking Creation of CLBs on Partition {0}...", i);
                            DbLeaderboard.LockCompLbsvrPartitionForTitle(nTitleID, i, true);

                            // Swap Phase - Redirect Interface Bucket to new server
                            currentPhase = MigrationPhase.MigrationSwap;
                            CommandUtility.WriteOutput("\t\tSwitching Database to point to new server");
                            DbLeaderboard.SetCompLbsvrForTitle(nTitleID, i, szDestServer);

                            // Unblock Creation of Leaderboards on this Partition Bucket
                            DbLeaderboard.LockCompLbsvrPartitionForTitle(nTitleID, i, false);

                            CommandUtility.WriteOutput("\t\tCalling Reload on all Stats FD");
                            DbLeaderboard.ResetStatsFDOnly();

                            currentPhase = MigrationPhase.MigrationFinish;
                        }
                        catch
                        {
                            //some errors happen - it is important that we quickly make the old leaderboards functional
                            CommandUtility.WriteError("Error: Rolling Back Best Effort");

                            DbLeaderboard.LockCompLbsvrPartitionForTitle(nTitleID, i, false);

                            CommandUtility.WriteError("\t\tRoll Back - Resetting Stats FD Only");
                            DbLeaderboard.ResetStatsFDOnly();

                            throw;
                        }
                    }
                }

                CommandUtility.WriteOutput("\t\tCalling Reload on all Stats FD");
                DbLeaderboard.ResetStatsFDOnly();

                CommandUtility.WriteOutput("Move Competition LBS Complete for title {0}", nTitleID);
            }
            catch
            {
                throw;
            }
            finally
            {

            }

            return 0;
        }

       /// <summary>
        /// Moves ALL leaderboards (both competition and non) for ALL titles, from one server to another.
        /// 
        /// It does this by calling MoveLb and MoveCompetitionLb repeatedly.  For regular leaderboards, it calls once
        /// per title, and for competition leaderboards it's once per partition.
        /// </summary>
        /// <param name="argParser">Takes an array of arguments: SourceServer, DestinationServer</param>
        /// <returns></returns>
        static int MoveLbServerConfigOnly(NamedArgParser argParser)
       {
            CommandUtility.WriteOutput("Attempting to move leaderboards from server [" + argParser["source"] + "] to server [" + argParser["dest"] + "]");

            // this hashtable-based resultset isn't exactly what we need, but it's easily available so we'll use it for now.
            Hashtable hashTitleLBs = DbLeaderboard.GetAllLeaderboardInfoForServer(argParser["source"]);

            bool[] rgfCompPartitionsMoved = {false, false, false, false};

            // set up named arg parsers to fake the called methods into thinking we're calling them normally
            NamedArgParser apMoveLB = new NamedArgParser();
            apMoveLB.Add("source", argParser["source"]);
            apMoveLB.Add("dest", argParser["dest"]);
            apMoveLB.Add("titleid", "TEMP"); // temporary, will be overriden below
            apMoveLB.Add("lbid", "ALL"); // fixed, because "ALL" works

            NamedArgParser apMoveCompetitionLB = new NamedArgParser();
            apMoveCompetitionLB.Add("source", argParser["source"]);
            apMoveCompetitionLB.Add("dest", argParser["dest"]);
            apMoveCompetitionLB.Add("titleid", "TEMP"); // temporary, will be overriden below
            apMoveCompetitionLB.Add("comppartition_id", "TEMP"); // temporary, will be overriden below

            // do the actual moving of leaderboards...
            // for non-competition, they are moved at the title level.
            // for competition, they are moved at the leaderboard partition level
            foreach (int nTitleId in hashTitleLBs.Keys)
            {
                apMoveLB["titleid"] = Convert.ToString(nTitleId);
                apMoveCompetitionLB["titleid"] = Convert.ToString(nTitleId);

                CommandUtility.WriteOutput("Attempting to move non-competition leaderboards for title [" + Convert.ToString(nTitleId) + "]");
                MoveLb(apMoveLB, true /*fConfigOnly*/); // moves the non-competition leaderboards for this title from the source to dest server

                // now look for the competition leaderboard partitions located on the server in question, 
                // and move them, but only once.
                foreach (int nLBID in ((Hashtable)hashTitleLBs[nTitleId]).Keys)
                {
                    byte bPartitionID = StatLbIdParser.GetPartition((uint)nLBID);
                    if(StatLbIdParser.IsCompetition((uint)nLBID) &&  // it's a competition leaderboard
                            rgfCompPartitionsMoved[bPartitionID] == false)  // its partition has not yet been moved
                    {
                        CommandUtility.WriteOutput("Attempting to move competition leaderboards for title [" + apMoveLB["titleid"] + "], partition [" + Convert.ToString(bPartitionID) + "]");
                        apMoveCompetitionLB["comppartition_id"] = Convert.ToString(bPartitionID);
                        MoveCompetitionLb(apMoveCompetitionLB, true /*fConfigOnly*/);
                        rgfCompPartitionsMoved[bPartitionID] = true;
                    }
                }
                // reset the array used to track which partitions have been migrated for the title
                Array.Clear(rgfCompPartitionsMoved, 0, rgfCompPartitionsMoved.Length);
            }

            return 0; // TODO: why?  Is this required by the command framework?
       }



        static void UpdateLTC(string szServer, int nTitleID, int nLbID)
        {
            try
            {
                LiveTitleConfig ltc = LiveTitleConfig.Get((uint)nTitleID );
                
                if (ltc != null && ltc.LeaderboardConfigs != null)
                {
                    if (ltc.UpdateHostingServerForLb(szServer, nLbID))
                    {
                        ltc.Save(); //this should update npdb
                    }
                    else
                    {
                        throw new Exception(String.Format("Error while UpdateHostingServerForLb Title ID {0} Lb ID {1}", nTitleID, nLbID));
                    }
                }
            }
            catch (Exception e)
            {
                throw new Exception(string.Format("\r\n\tWarning - Error while Updating LTC Title ID {0} Lb ID {1}\r\n\t{2}\r\n ", nTitleID, nLbID, e.Message));
            }
        }


        /*
            Exposing some function in case Move LBS Fails and we need fix it manually
        */
        static int SetToReadOnly(NamedArgParser argParser)
        {
            return MoveLbsInternalCommon(argParser, new MoveLbsInternalCommand(SetToReadOnlyActualCommand));
        }

        static void SetToReadOnlyActualCommand(int nTitleId, int nLbID, string szServer)
        {
            uint nSwapSeed = DbLeaderboard.SetReadOnly(nTitleId, nLbID, szServer);
            CommandUtility.WriteOutput("\tTitle ID {0} LbId {1} Swap Seed {2}", nTitleId, nLbID, nSwapSeed);
        }

        static int SetToReadWrite(NamedArgParser argParser)
        {
             return MoveLbsInternalCommon(argParser, new MoveLbsInternalCommand(SetToReadWriteActualCommand));
        }

        static void SetToReadWriteActualCommand(int nTitleId, int nLbID, string szServer)
        {
            DbLeaderboard.SetReadWrite(nTitleId, nLbID, szServer);
        }

        static int LoadLb(NamedArgParser argParser)
        {
             return MoveLbsInternalCommon(argParser, new MoveLbsInternalCommand(LoadLbActualCommand));
        }

        static void LoadLbActualCommand(int nTitleId, int nLbID, string szServer)
        {
            DbLeaderboard.LoadLb(nTitleId, nLbID, szServer);
        }

        static int UnLoadLb(NamedArgParser argParser)
        {
             return MoveLbsInternalCommon(argParser, new MoveLbsInternalCommand(UnLoadLbActualCommand));
        }

        static void UnLoadLbActualCommand(int nTitleId, int nLbID, string szServer)
        {
            DbLeaderboard.UnLoadLb(nTitleId, nLbID, szServer);
        }


        static int CleanClip(NamedArgParser argParser)
        {
            return CleanClip(argParser, false);
        }

        static int CleanXboxClip(NamedArgParser argParser)
        {
            return CleanClip(argParser, true);
        }

        static int CleanClip(NamedArgParser argParser, bool bIsXboxLb)
        {
            try
            {
                uint    uiHoursFromNow  = SafeConvert.ToUInt32(argParser[ "hoursfromnow"] );
                uint    uiTitleID       = SafeConvert.ToUInt32(argParser[ "titleid" ]);
               
                ArrayList arrConfigLbs = new ArrayList();

                if ( bIsXboxLb )
                {
                    arrConfigLbs = GetXscLeaderboards(uiTitleID );
                }
                else
                {
                    arrConfigLbs = GetXlastLeaderboards(uiTitleID );
                }

                if (null == arrConfigLbs)
                {
                    throw new Exception(String.Format("Error retrieving leaderboard configuration For Title {0:x8}", uiTitleID));
                }

                if (0 == arrConfigLbs.Count)
                {
                    throw new Exception(String.Format("Title {0:x8} has 0 leaderboards", uiTitleID));
                }

                if (!ExistJob(uiTitleID, uiHoursFromNow))
                {
                    AddCronJob(uiTitleID, uiHoursFromNow);
                }
            }
            catch
            {
                throw;
            }
            finally
            {
            }

            return 0;
        }

        static bool ExistJob(uint uiTitleId, uint uiHoursFromNow)
        {
            FindJobsRequest objFindJobReq       = new FindJobsRequest();
            FindJobsResponse objFindJobResponse = new FindJobsResponse();

            objFindJobReq.search    = GenerateJobName(uiTitleId);
            objFindJobReq.searchLen = (uint)objFindJobReq.search.Length;

            XrlRequest xrlreq = new XrlRequest();
            xrlreq.TargetVirtualInterface = VirtualInterface.cron_int;
            xrlreq.Path = objFindJobReq.GetXRL();
            xrlreq.RequestOb = objFindJobReq;
            xrlreq.ResponseOb = objFindJobResponse;
            xrlreq.AuthData = new HTTPAuthData(0, 0, 0, 0, uiTitleId, 0, 0).GetBase64EncodedString();

            HResult hr = xrlreq.Send();
            if (HResult.S_OK != hr)
            {
                throw new Exception(String.Format("There was a problem Querying Existence of CRON Job TitleId {0:x}", uiTitleId));
            }

            return (objFindJobResponse.jobCount > 0);
            
        }


        static void AddCronJob(uint uiTitleId, uint uiHoursFromNow)
        {
            const string _szCleanClipDLL   = "cleanclips.dll";
            const string _szCleanClipClass = "xonline.server.cron.plugins.cleanclips.CleanClipsJob";
            const string _szArgsXML        = "<PluginContext></PluginContext>";
        
            AddJobRequest  objJobReq  = new AddJobRequest();
            AddJobResponse objJobResp = new AddJobResponse();

            objJobReq.titleId  = uiTitleId;

            objJobReq.name      = GenerateJobName(uiTitleId); 
            objJobReq.titleId   = uiTitleId;
            objJobReq.assembly  = _szCleanClipDLL;
            objJobReq.className = _szCleanClipClass;
            objJobReq.argsXml   = _szArgsXML;
            objJobReq.nextExec  = DateTime.Now.AddHours((double)uiHoursFromNow);
            objJobReq.execCount = 1;
            objJobReq.intervalSecs = XOn.XONLINE_CRON_MIN_INTERVAL_SECS; //DOES NOT MATTER SINCE EXEC COUNT IS ALWAYS ONE
            
            XrlRequest xrlreq = new XrlRequest();
            xrlreq.TargetVirtualInterface = VirtualInterface.cron_int;
            xrlreq.Path = objJobReq.GetXRL();
            xrlreq.RequestOb = objJobReq;
            xrlreq.ResponseOb = objJobResp;
            xrlreq.AuthData = new HTTPAuthData(0, 0, 0, 0, uiTitleId, 0, 0).GetBase64EncodedString();

            uint hr = xrlreq.Send();
            if (HResult.S_OK != hr)
            {
                throw new Exception(String.Format("There was a problem adding CRON Job TitleId {0:x}", uiTitleId));
            }
        }

        static string GenerateJobName(uint uiTitleId)
        {
            return string.Format("cleanclips_0x{0:x}", uiTitleId);
        }

        static int IsSafeToDeleteLb(NamedArgParser argParser)
        {
            try
            {
                uint     nSwapSeed     = SafeConvert.ToUInt32(argParser[ "safeseed" ]);
                string  szDestServer   = argParser["server"];

                if (!DbLeaderboard.IsLeaderBoardServer(szDestServer))
                {
                    throw new Exception(string.Format("{0} is not a leaderboard Server", szDestServer));
                }
                
                CommandUtility.WriteOutput("SafeToDeleteLb on Server {0} since SwapSeed {1} is {2}", szDestServer,nSwapSeed , DbLeaderboard.SafeToDeleteLb(nSwapSeed, szDestServer));
                 
            }
            catch
            {
                throw;
            }
            finally
            {
                
            }

            return 0;
        }

        static int MoveLbsInternalCommon(NamedArgParser argParser, MoveLbsInternalCommand objActualCommand)
        {
            try
            {
                int     nTitleID       = SafeConvert.ToInt32(argParser[ "titleid" ]);
                int  [] arrLbId        = null;
                string  szDestServer   = argParser["server"];

                if (!DbLeaderboard.IsLeaderBoardServer(szDestServer))
                {
                    throw new Exception(string.Format("{0} is not a leaderboard Server", szDestServer));
                }

                if (argParser["lbid"].IndexOf("ALL") != -1)
                {
                    arrLbId = DbLeaderboard.GetAllLbForTitle(nTitleID, szDestServer);
                }
                else
                {
                    arrLbId   = new int[1];
                    arrLbId[0]= int.Parse(argParser[ "lbid" ]);
                }

                if (arrLbId.Length <= 0)
                {
                    CommandUtility.WriteError("\r\nWarning: No Leaderboards Found for title {0} on Server {1}", nTitleID, szDestServer);
                }
                else
                {
                    for (int i=0;i<arrLbId.Length;i++)
                    {
                        objActualCommand(nTitleID, arrLbId[i], szDestServer);
                    }
                }
            }
            catch
            {
                throw;
            }
            finally
            {
                
            }

            return 0;
        }

        static int ResetLb(NamedArgParser argParser)
        {
            CTitleId ctitle;
            try
            {
                //task: one day, I'll convert CTitleId to have static conversion methods...
                ctitle = new CTitleId( argParser[ "titleid" ] );
            }
            catch
            {
                throw new Exception("Title ID Supplied was unusable.  Please read instructions and try again.");
            }

            int titleID = (int) ctitle.uiTitleId;
            int lbID = 0;
            
            try
            {
                lbID = Convert.ToInt32(argParser[ "lbid" ], 10);
            }
            catch
            {
                throw new Exception("Leaderboard ID supplied was unusable.  Please specify a specific leaderboard id number");
            }    
            
            CommandUtility.WriteOutput("Resetting leaderboard " + lbID.ToString() +
                                        " for title " + titleID.ToString("X") + "...");
                                    
            DbLeaderboard.ResetLeaderboard( titleID, lbID);

            return 0;
        }

        static int ResetTitle(NamedArgParser argParser)
        {
            // Extract arguments
            CTitleId ctitle;
            try
            {
                //task: one day, I'll convert CTitleId to have static conversion methods...
                ctitle = new CTitleId( argParser[ "titleid" ] );
            }
            catch
            {
                throw new Exception("Title ID Supplied was unusable.  Please read instructions and try again.");
            }

            ArrayList leaderboards = DbLeaderboard.GetNPDBLeaderboardConfiguration( ctitle.uiTitleId );
            if (leaderboards != null)
            {
                foreach (LeaderboardSettings lb in leaderboards)
                {
                    int lbID = lb.LeaderboardID;
                    CommandUtility.WriteOutput("Resetting leaderboard " + lbID.ToString("x") +
                                                " for title " + ctitle.uiTitleId.ToString("X") + "...");
                                            
                    DbLeaderboard.ResetLeaderboard( (int)ctitle.uiTitleId, lbID );
                }
            }    

            return 0;
        }

        static int DeleteTitle(NamedArgParser argParser)
        {
            CTitleId ctitle;
            try
            {
                //task: one day, I'll convert CTitleId to have static conversion methods...
                ctitle = new CTitleId( argParser[ "titleid" ] );
            }
            catch
            {
                throw new Exception("Title ID Supplied was unusable.  Please read instructions and try again.");
            }

            try
            {
                CommandUtility.WriteOutput( "==> All parameters were correct." );
                CTitleId title = new CTitleId( argParser[ "titleid" ] );
                DbLeaderboard.DeleteTitlesLeaderboards( title.uiTitleId );
                //task: display leaderboards to make sure?
            }
            catch( Exception e )
            {
                throw new Exception( "There was an error while deleting title:\r\n" + e.ToString() );
            }

            return 0;
        }

        static int Usage(NamedArgParser argParser)
        {
            Usage();
            return 0;
        }

        static int ReportUserStats(NamedArgParser argParser)
        {
            CommandUtility.WriteError( "This feature is not implemented yet." );
            return 0;
        }

        static int ReportConfiguration(NamedArgParser argParser)
        {
            try
            {
                uint titleID = SafeConvert.ToUInt32(argParser[ "titleid" ],0);
                if (titleID == 0)
                    throw new Exception("Couldn't parse titleid parameter!");

                ArrayList npdbLeaderboards =
                    DbLeaderboard.GetNPDBLeaderboardConfiguration( titleID );
                if ( ( npdbLeaderboards != null ) && ( npdbLeaderboards.Count != 0 ) )
                {
                    CommandUtility.WriteOutput( DbLeaderboard.DisplayLeaderboards( npdbLeaderboards ) );
                }
                else
                {
                    CommandUtility.WriteOutput( "No leaderboards are configured in NPDB for titleID " + argParser[ "titleid" ] );
                }
            }
            catch( Exception e )
            {
                throw new Exception( "An error while reporting LB configuration:\r\n" + e.ToString() );
            }

            return 0;
        }


        static int DeployWebDbOnlyLbForXbox1(NamedArgParser argParser)
        {
            try
            {
                uint      nTitleID      = SafeConvert.ToUInt32(argParser[ "titleid" ]);
                ArrayList arrConfigLbs  = GetXscLeaderboards( nTitleID );
                if (null == arrConfigLbs || 0 == arrConfigLbs.Count)
                    throw new Exception("Unable to get Read XSC file for Title Entered");
                return DeployWebDbOnlyLbCommon(argParser, nTitleID, arrConfigLbs);
             }
             catch
             {
                throw;
             }
        }

        static int DeployWebDbOnlyLbForXbox360(NamedArgParser argParser)
        {
            try
            {
                uint      nTitleID      = SafeConvert.ToUInt32(argParser[ "titleid" ]);
                ArrayList arrConfigLbs  = GetXlastLeaderboards( nTitleID );
                if (null == arrConfigLbs || 0 == arrConfigLbs.Count)
                    throw new Exception("Unable to get Read Xlast file for Title Entered");
                return DeployWebDbOnlyLbCommon(argParser, nTitleID, arrConfigLbs);
             }
             catch
             {
                throw;
             }
        }

        //this is by default a force redeployment of web DB
        static int DeployWebDbOnlyLbCommon(NamedArgParser argParser, uint nTitleID, ArrayList arrConfigLbs)
        {
            try
            {
                //let's see if all the leaderboard exists in npdb
                int [] arrLbIDNPDB = DbLeaderboard.GetAllLbForTitle((int)nTitleID, null);

                foreach (LeaderboardSettings lb in arrConfigLbs)
                {
                    if (lb.Type == LbType.Competition)
                        continue; //we don't deploy competition is web db
                    
                    bool bFound = false;
                    foreach (int nLbID in arrLbIDNPDB)
                    {
                        if (lb.LeaderboardID == nLbID)
                        {
                            bFound = true;
                            break;
                        }
                    }

                    if (bFound == false)
                    {
                        throw new Exception(string.Format("Unable to Find Leaderboard ID {0} in NPDB - Did you deploy it?", lb.LeaderboardID));
                    }
                }
                

                foreach (LeaderboardSettings lb in arrConfigLbs)
                {
                    DbLeaderboard.DeleteLeaderboardFromWebDB( nTitleID, (int)lb.LeaderboardID);
                }

                foreach (LeaderboardSettings lb in arrConfigLbs)
                {
                    DbLeaderboard.CreateLeaderboardInWebDb(lb);
                }
            }
            catch
            {
                throw;
            }
            finally
            {
                
            }

            return 0;
        }


        static int DeployLbInternal(NamedArgParser argParser, bool isXbox1Title)
        {
            CTitleId ctitle;
            try
            {
                //task: one day, I'll convert CTitleId to have static conversion methods...
               ctitle = new CTitleId( argParser[ "titleid" ] );
            }
            catch
            {
                throw new Exception("Title ID Supplied was unusable.  Please read instructions and try again." );
            }

            uint titleID = ctitle.uiTitleId;
            CommandUtility.WriteOutput( "\r\nNow configuring leaderboards for title: " + ctitle.sTitleIdHex + " ( " + ctitle.uiTitleId + " )" );

            ArrayList configLbs = null;

            if ( isXbox1Title )
            {
                configLbs = GetXscLeaderboards( titleID );
            }
            else
            {
                configLbs = GetXlastLeaderboards( titleID );
            }

            if (configLbs == null)
            {
                throw new Exception("Error retrieving leaderboard configuration!");
            }


            LiveTitleConfig ltc = LiveTitleConfig.Get( titleID );

            // LBServer is not populated, so fill out the LBServer field
            // for each LeaderboardSettings object from the lbServer value provided in the LTC
            //
            if (ltc != null && ltc.LeaderboardConfigs != null)
            foreach ( LeaderboardSettings lb in configLbs )
            {
                foreach ( LeaderboardConfig lbc in ltc.LeaderboardConfigs )
                {
                    if (lbc.LeaderboardID == lb.LeaderboardID &&
                        lbc.IsCompetition == (lb.Type == LbType.Competition))
                    {
                        lb.LBServer = lbc.HostingLbs;
                        break;
                    }
                }
            }
            
            //task: need to improve handling for the case where this title doesn't have an Xlast or Config

            ArrayList npdbLeaderboards = DbLeaderboard.GetNPDBLeaderboardConfiguration( titleID );

            bool force = (argParser["force"] != null);

            ArrayList updated; //list of modified lb requiring a reset
            ArrayList inNpdbOnly;
            ArrayList inConfigOnly;
            ArrayList updatedNoResetRequired;//list of modified lb not requiring a reset
            List<int> requireNotification;

            int lbCount = 0;
            int compCount = 0;

            bool foundPlatformLeaderboardChanges; // have there been any changes to the platform visible leaderboard information for this title?

            CompareStatsConfig(npdbLeaderboards, configLbs, out updated, out inNpdbOnly, out inConfigOnly, out updatedNoResetRequired, out requireNotification, out foundPlatformLeaderboardChanges);

            CommandUtility.WriteOutput(updated.Count + " leaderboard(s) changed which requires a Reset");
            CommandUtility.WriteOutput(updatedNoResetRequired.Count  + " leaderboard(s) changed which does not require a Reset");
            CommandUtility.WriteOutput(inNpdbOnly.Count + " leaderboard(s) are in npdb and are no longer in the configuration file.");
            CommandUtility.WriteOutput(inConfigOnly.Count + " leaderboard(s) are new in the configuration file.");

            foreach (LeaderboardSettings lb in configLbs)
            {
                if (force == false && !inConfigOnly.Contains(lb) && (ColumnsModified(lb, titleID)))
                {
                    throw new Exception("Livestats warning: Column(s) changed in leaderboard " + lb.LeaderboardID + ". /force flag was not specified and is necessary to continue.");
                }

                if (force == false && (updated.Count > 0 || inNpdbOnly.Count > 0))
                {
                    throw new Exception("LiveStats warning: aborting leaderboard update. " + updated.Count + " required update and reset, and " + inNpdbOnly.Count + " was in NPDB and not config, and required removal.  /force flag was not specified and is necessary to continue.");
                }
            }
                       
            //update those leaderboards which does not require a reset
            foreach (LeaderboardSettings lb in updatedNoResetRequired)
            {
                CommandUtility.WriteOutput("Updating LBID {0} Without a Reset ", lb.LeaderboardID);
                DbLeaderboard.UpdateLbInNPDB(lb);
                DbLeaderboard.UpdateLbInWebDB(lb);
            }

            if (requireNotification.Count > 0)
            {
                CommandUtility.WriteOutput("Calling xmgmt ...");
                string[] servers = xonline.common.config.Config.GetServerListByInterface(Interface.lbsvr);
                string[] responses;
                int hr;
                foreach (string server in servers)
                {
                    IInterfaceInfo iinfo = xonline.common.config.Config.GetInterface(server, Interface.lbsvr);
                    XomAdminSession xmgmt = new XomAdminSession(iinfo.IPAddress);
                    try
                    {
                        // call xmgmt reloadsettingforlb
                        foreach (int lbID in requireNotification)
                        {
                            xmgmt.SendCommand(null, Component.lbsvr, "reloadsettingforlb " + titleID + " " + lbID, iinfo.Timeout, out responses, out hr);
                        }
                    }
                    finally
                    {
                        xmgmt.Close();
                    }
                }
            }

            // delete updated leaderboards..
            foreach (LeaderboardSettings lb in updated)
            {
                if (lb.Type != LbType.Competition)
                {
                    CommandUtility.WriteOutput("Deleting updated leaderboard " + lb.LeaderboardID);
                    DbLeaderboard.DeleteLeaderboard( titleID, (int)lb.LeaderboardID);
                }
            }

            // delete removed leaderboards..
            foreach (LeaderboardSettings lb in inNpdbOnly)
            {
                if (lb.Type != LbType.Competition)
                {
                    CommandUtility.WriteOutput("Deleting removed leaderboard " + lb.LeaderboardID);
                    DbLeaderboard.DeleteLeaderboard( titleID, (int)lb.LeaderboardID);
                }
            }

            // create updated leaderboards with new settings..
            foreach (LeaderboardSettings lb in updated)
            {
                if (lb.Type != LbType.Competition)
                {
                    CommandUtility.WriteOutput("Creating updated leaderboard id " + (int)lb.LeaderboardID);
                    DbLeaderboard.CreateLeaderboard( lb );
                    lbCount++;
                }
            }

            // create new leaderboards with new settings..
            foreach (LeaderboardSettings lb in inConfigOnly)
            {
                if (lb.Type != LbType.Competition)
                {
                    CommandUtility.WriteOutput("Creating new leaderboard id " + (int)lb.LeaderboardID );
                    DbLeaderboard.CreateLeaderboard( lb );
                    lbCount++;
                }
            }

            // create competition templates
            foreach (LeaderboardSettings lb in configLbs)
            {
                if (lb.Type == LbType.Competition)
                {
                    CommandUtility.WriteOutput("Creating/Updating Competition template " + lb.LeaderboardID);
                    DbLeaderboard.DeleteCompetitionTemplate(lb.TitleID, (int)lb.LeaderboardID);
                    DbLeaderboard.CreateCompetitionTemplate(lb);
                    compCount++;
                }
            }

            if (foundPlatformLeaderboardChanges)
            {
                // Flush all platform visible leaderboard metadata from t_platform_visible_leaderboards for this titleId...
                DbLeaderboard.DeletePlatformVisibleLeaderboardMetadataForTitleId(titleID);

                // ...and then ingest all new platform visible leaderboard metadata anew!
                foreach (LeaderboardSettings lb in configLbs)
                {
                    foreach (KeyValuePair<string, PlatformVisibleLeaderboardLocInfo> kvp in lb.PlatformVisibleLeaderboardData)
                    {
                        PlatformVisibleLeaderboardLocInfo pvlInfo = kvp.Value;

                        DbLeaderboard.AddPlatformVisibleLeaderboardMetaData(
                            titleID,
                            (uint)lb.LeaderboardID,
                            kvp.Key,
                            pvlInfo.RatingAttributeId,
                            pvlInfo.Flags,
                            pvlInfo.FormatType,
                            pvlInfo.Format,
                            pvlInfo.Name,
                            pvlInfo.Rating
                            );
                    }
                }
            }

            if (ltc != null)
                DbLeaderboard.ConfigureTitle( ltc.TitleID, ltc.StatsMaxWrites ,ltc.StatsMaxReads );
           
            CommandUtility.WriteOutput("\r\n" + lbCount + " leaderboards and " + compCount + " competition templates were configured.\r\n\r\n" );

            //display current configuration of this title for the user to verify...
            npdbLeaderboards = DbLeaderboard.GetNPDBLeaderboardConfiguration( titleID );
            CommandUtility.WriteOutput( DbLeaderboard.DisplayLeaderboards( npdbLeaderboards ) );

            CommandUtility.WriteOutput("\r\nTitle Configuration Complete.");

            return 0;

        } 

        static ArrayList GetXlastLeaderboards( uint titleId )
        {
            return StatsXlastUtil.GetXLASTLeaderboardConfiguration( titleId );
        }

        static ArrayList GetXscLeaderboards( uint titleId )
        {
            // Get LiveTitleConfig for this titleID
            LiveTitleConfig ltc = LiveTitleConfig.Get( titleId );

            string xscPath = TitleVault.GetTitleVaultXscPath( titleId );

            // Get LeaderboardSettings from XSC file
            //
            if(!File.Exists(xscPath))
            {
                CommandUtility.WriteError("XSC file {0} does not exist in titlevault.", xscPath);
                return null;    // Caller should check for null and throw an exception
            }

            CommandUtility.WriteOutput("Extracting leaderboard configuration from {0}...", xscPath);
            // Get an array of LeaderboardSettings objects
            ArrayList leaderboardList = XscLeaderboard.GetXSCLeaderboardConfiguration(xscPath, titleId);

            CommandUtility.WriteOutput( "XSC File contained {0} leaderboards.", leaderboardList.Count );

            return leaderboardList;

        } // GetXscLeaderboards

        static bool ColumnsModified(LeaderboardSettings lb, uint titleID)
        {
            List<string> list = DbLeaderboard.GetLeaderboardColumnIDs(titleID, lb.LeaderboardID);
            int count = 0;
            for (int i = 0; i < lb.Columns.Length; i++ )
            {
                if (!list.Contains(lb.Columns[i].Name))
                {
                    // column exist in xlast, but not in webdb
                    return true;
                }
                else count++;
            }
            return (list.Count > count);
        }


        static void CompareStatsConfig(
            ArrayList npdbLbs,
            ArrayList configLbs,
            out ArrayList updated,
            out ArrayList inNpdbOnly,
            out ArrayList inConfigOnly,
            out ArrayList updatedNoResetRequired,
            out List<int> requireNotification,
            out bool foundPlatformLeaderboardChanges)
        {
            updated = new ArrayList();
            inNpdbOnly = new ArrayList();
            inConfigOnly = new ArrayList();
            updatedNoResetRequired = new ArrayList();
            requireNotification = new List<int>();

            foundPlatformLeaderboardChanges = false;  // init to no changes

            foreach (LeaderboardSettings npdbLb in npdbLbs)
            {
                LeaderboardSettings xlastLb = null;
                bool foundExisting = false;

                if ( StatLbIdParser.IsCompetition((uint)npdbLb.LeaderboardID) )
                {
                    // skip it -- since comp leaderboards are transient and
                    // are created and go away with the competition, we'll
                    // ignore reconfiguring it.

                    continue;
                }

                for (int i = 0; i < configLbs.Count; i++)
                {
                    xlastLb = (LeaderboardSettings)configLbs[i];

                    if ( xlastLb.Type == LbType.Competition )
                        // skip it
                        continue;

                    if (xlastLb.TitleID       == npdbLb.TitleID &&
                        xlastLb.LeaderboardID == npdbLb.LeaderboardID)
                    {
                        // xlast leaderboard already exists in the db!
                        foundExisting = true;

                        if ((xlastLb.DecayDays != npdbLb.DecayDays)||
                            (xlastLb.MaxAttachmentSize != npdbLb.MaxAttachmentSize)||
                            (xlastLb.ResetType != npdbLb.ResetType)||
                            ((xlastLb.TopEntries == -1) != (npdbLb.TopEntries == 0))||
                            (xlastLb.MaxAttachments != npdbLb.MaxAttachments))
                        {
                            updatedNoResetRequired.Add(xlastLb);
                        }
                        if ((xlastLb.DecayDays != npdbLb.DecayDays) || (xlastLb.ResetType != npdbLb.ResetType))
                        {
                            requireNotification.Add(xlastLb.LeaderboardID);
                        }

                        // check for acceptable config-only changes..
                        string changes = "";

                        if (xlastLb.EloCtable != npdbLb.EloCtable ||
                            xlastLb.EloE != npdbLb.EloE ||
                            xlastLb.EloK != npdbLb.EloK ||
                            xlastLb.EloNew != npdbLb.EloNew)
                            changes = "ELO settings";

                        // note: technically updating TeamView and Arbitrated
                        // don't require clearing the lb,
                        // but currently there's no existing way to just update npdb
                        if (xlastLb.TeamView != npdbLb.TeamView)
                            changes += (changes == "" ? "" : ", ") + "Team LB";

                        if (xlastLb.Arbitrated != npdbLb.Arbitrated)
                            changes += (changes == "" ? "" : ", ") + "Arbitration";

                        if (changes != "")
                        {
                            CommandUtility.WriteOutput("Leaderboard ID " + npdbLb.LeaderboardID + " was modified (" + changes+ "):");
                            updated.Add(xlastLb);
                        }

                        // compare platform visible leaderboard data until one mismatch is found...and then no more need to compare
                        if (!foundPlatformLeaderboardChanges)
                        {
                            foundPlatformLeaderboardChanges = xlastLb.PlatformLeaderboardIsDifferent(npdbLb);
                        }

                        break;

                    } // if same lb

                } // for

                if (foundExisting == false)
                {
                    CommandUtility.WriteOutput("Leaderboard ID " + npdbLb.LeaderboardID + " doesn't exist in new config, and will be deleted!");
                    inNpdbOnly.Add(npdbLb);
                }

            } // foreach (npdbLb)

            // check for new leaderobards in config
            foreach (LeaderboardSettings configLb in configLbs)
            {
                bool foundExisting = false;

                foreach (LeaderboardSettings npdbLb in npdbLbs)
                {
                    if (configLb.TitleID       == npdbLb.TitleID &&
                        configLb.LeaderboardID == npdbLb.LeaderboardID)
                    {
                        if (!foundPlatformLeaderboardChanges)
                        {
                            foundPlatformLeaderboardChanges = configLb.PlatformLeaderboardIsDifferent(npdbLb);
                        }

                        // found it!  compairison already done above..
                        foundExisting = true;
                        break;
                    }
                }

                if (foundExisting == false)
                {
                    CommandUtility.WriteOutput("Leaderboard ID " + configLb.LeaderboardID + " is new in config.");
                    inConfigOnly.Add(configLb);

                    // if a new leaderboard (not yet in NPDB, and has platform leaderboard data, then set
                    // foundPlatformLeaderboardChanges to true, so that platform leaderboard ingestion takes place.
                    if (!foundPlatformLeaderboardChanges)
                    {
                        foundPlatformLeaderboardChanges = configLb.HasPlatformLeaderboards;
                    }
                }

            } // foreach (configLb)

        } // CompareStatsConfig

        static void Usage()
        {

            Console.WriteLine( "\r\n         L  I  V  E    S  T  A  T  S");
            Console.WriteLine( "\r\n=================================================\r\n" );
            Console.WriteLine( "" );
            Console.WriteLine( "Tool to create a title's Stats configuration " );
            Console.WriteLine( "" );
            Console.WriteLine( "Usage:" );
            Console.WriteLine( "    LiveStats /deploylb             /titleid:<title> [/force] [/verbose]" );
            Console.WriteLine( "    LiveStats /deployxboxlb         /titleid:<title> [/force] [/verbose]");
            Console.WriteLine( "    LiveStats /movelb               /titleid:<title> /lbid:<lbid> /source:<lbssource> /dest:<lbsdest> [/verbose]");
            Console.WriteLine( "    LiveStats /movecompetitionlb    /titleid:<title> /comppartition_id:<clbpartid> /dest:<lbsdest> [/verbose]");
            Console.WriteLine( "    LiveStats /movelbserverconfigonly    /source:<lbssource> /dest:<lbsdest> [/verbose]");
            Console.WriteLine( "    LiveStats /resetlb              /titleid:<title> /lbid:<lbid> [/verbose]");
            Console.WriteLine( "    LiveStats /resettitle           /titleid:<title> [/verbose]");
            Console.WriteLine( "    LiveStats /deletetitle          /titleid:<title> /time:<current_time> [/verbose]");
            Console.WriteLine( "    LiveStats /reportconfiguration  /titleid:<title> [/verbose]");
            Console.WriteLine( "    LiveStats /reloadfrontdoor  [/verbose] [optional /timeout:seconds](will reset stats front door only)");
            Console.WriteLine( "    LiveStats /reloadwebstats   [/verbose] [optional /timeout:seconds](will reset web stats only)");
            Console.WriteLine( "    LiveStats /deploywebdbonlylb    /titleid:<title> [/verbose] (Xbox 360 Only - delete and re-prop into webdb)");
            Console.WriteLine( "    LiveStats /deploywebdbonlylbxbox1    /titleid:<title> [/verbose] (Xbox 1 Only - delete and re-prop into webdb)");
            Console.WriteLine( "    LiveStats /settoreadonly    /titleid:<title> /lbid:<lbid> /server:<lbsserver> [/verbose]");
            Console.WriteLine( "    LiveStats /settoreadwrite    /titleid:<title> /lbid:<lbid> /server:<lbsserver> [/verbose]");
            Console.WriteLine( "    LiveStats /load    /titleid:<title> /lbid:<lbid> /server:<lbsserver> [/verbose]");
            Console.WriteLine( "    LiveStats /unload    /titleid:<title> /lbid:<lbid> /server:<lbsserver> [/verbose]");
            Console.WriteLine( "    LiveStats /issafetodeletelb  /server:<lbsserver> /safeseed:<NumberReceivedFromReadOnly> [/verbose]");
            Console.WriteLine( "    LiveStats /cleanclip  /titleid:<title> /hoursfromnow:<hoursfromnow> [/verbose]");
            Console.WriteLine( "    LiveStats /cleanxboxclip  /titleid:<title> /hoursfromnow:<hoursfromnow> [/verbose]"); 
            Console.WriteLine( "" );
            Console.WriteLine( "Definitions:" );
            Console.WriteLine( "    <titleid>               - title ID to be configured" );
            Console.WriteLine( "    <lbs>                   - leaderboard server this title will be hosted by" );
            Console.WriteLine( "    <schema>                - UNC path to the .xsd file containing the XLAST schema" );
            Console.WriteLine( "    <maxread>               - max reads this title is allowed to make" );
            Console.WriteLine( "    <maxwrites>             - max writes this title is allowed to make" );
            Console.WriteLine( "    <lbid>                  - leaderboard ID to be configured" );
            Console.WriteLine( "    <clbpartid>             - competition partition for the template" );
            Console.WriteLine( "    <lbssource>             - name of the Leaderboard Server that is a source" );
            Console.WriteLine( "                              for the leaderboard to be moved" );
            Console.WriteLine( "    <lbsdest>               - name of the Leaderboard Server that is the destination" );
            Console.WriteLine( "                              for the leaderboard to be moved" );
            Console.WriteLine( "    <current_time>          - current time helps prevent accidental deletions" );
            Console.WriteLine( "    <puid>                  - user puid in decimal form" );
            Console.WriteLine( "    <force>                 - if there are differences between new and existing " );
            Console.WriteLine( "                              configurations, delete the existing data." );
            Console.WriteLine( "    <hoursfromnow>          - Number of hours from now the clean clip job will execute" );
            Console.WriteLine( "" );
            Console.WriteLine( "Examples:" );
            Console.WriteLine( "    Deploying leaderboards for a title, resetting all modified leaderboards in the process:" );
            Console.WriteLine( "    LiveStats /deploylb /titleid:0x5553000C /force" );
            Console.WriteLine( "" );
            Console.WriteLine( "    Deploying leaderboards for a new XBOX1 title with verbose output:" );
            Console.WriteLine( "    LiveStats /deployxboxlb /titleid:0x5553000C /verbose" );
            Console.WriteLine( "" );
            Console.WriteLine( "    Moving the above title's leaderboard 5 from LBServer1 to LBServer2:" );
            Console.WriteLine( "    LiveStats /movelb    /titleid:0x5553000C /lbid:5 (or /lbid:ALL) /source:TukXeStatLbs001 /dest:TukXeStatLbs002 " );
            Console.WriteLine( "" );
            Console.WriteLine( "    Clear the stats on a given leaderboard with verbose output:" );
            Console.WriteLine( "    LiveStats /resetlb /titleid:0x5553000C /lbid:5 /verbose" );
            Console.WriteLine( "" );
            Console.WriteLine( "    Clear the stats on all leaderboads for a title:" );
            Console.WriteLine( "    LiveStats /resettitle /titleid:0x5553000C" );
            Console.WriteLine( "" );
            Console.WriteLine( "    Delete all Stats configuration for this title with verbose output:" );
            Console.WriteLine( "    LiveStats /deletetitle /titleid:0x5553000C /verbose" );
            Console.WriteLine( "" );
            Console.WriteLine( "    Report current Stats configuration for this title " );
            Console.WriteLine( "    LiveStats /reportconfiguration  /titleid:0x5553000C ");
        }


    } // deploy title

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\lsp\test\functional\LiveLSPTest.cs ===
using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.IO;
using System.Text;

using ServerTestFramework;
using xonline.common.config;

namespace LiveLSPTest
{
    [TestGroup, Owner("johnmcp"), TestFrequency("Regression"), EnvRequirement("Manual")]
    public class LiveLSP : TestNode
    {
        public const string SuiteLocation = ".\\Suites\\LiveLSPTest\\";
        private static readonly uint ServiceIDBase = 0xdead0000;
        private static uint ServiceIDMax = ServiceIDBase;
        private static object _lock_obj = new object();

        private string OldCWD = null;

        /// <summary>
        /// Uses the tool to create a service, giving back the ID of that service.
        /// </summary>
        /// <returns>The ID of the service.</returns>
        private static uint CreateValidServiceID ()
        {
            uint ans;

            lock (_lock_obj)
            {
                ans = ServiceIDMax++;
            }

            LiveLSPTestBase.CreateService(ans);

            return ans;
        }

        /// <summary>
        /// Allocates a service ID, but does not create it.
        /// </summary>
        /// <returns>The ID of the service.</returns>
        private static uint AllocateValidServiceID ()
        {
            uint ans;

            lock (_lock_obj)
            {
                ans = ServiceIDMax++;
            }

            return ans;
        }

        private static uint _GoodService = 0;
        private static uint GoodService
        {
            get
            {
                if (_GoodService == 0)
                {
                    lock (_lock_obj)
                    {
                        if (_GoodService == 0)
                        {
                            _GoodService = ServiceIDMax++;
                            LiveLSPTestBase.CreateService(_GoodService);
                        }
                    }
                }

                return _GoodService;
            }
        }

        private static uint BadService
        {
            get
            {
                return ServiceIDBase - 1;
            }
        }

        private DateTime _SetupTime;
        private string _BackCompat;
        private static bool CurrDirMoved = false;

        [TestGroupSetup]
        public void GroupSetup ()
        {
            OldCWD = Directory.GetCurrentDirectory();

            // just move us there
            if (!CurrDirMoved)
            {
                Directory.SetCurrentDirectory(SuiteLocation);
                CurrDirMoved = true;
            }

            lock (_lock_obj)
            {
                ServiceIDMax = ServiceIDBase;
                _GoodService = 0;
            }

            _SetupTime = DateTime.Now;
            _SetupTime -= new TimeSpan(0, 5, 0);

            // Get back compat string
            using (SqlConnection connection = new SqlConnection(Config.NpdbConnectionString))
            {
                connection.Open();
                SqlCommand command = new SqlCommand(
                    "select vc_value from t_settings where vc_setting = 'query_LspBackcompTitles'", connection);
                _BackCompat = (string) command.ExecuteScalar();
                connection.Close();
            }

            // Ensure 0xFFFF07A2 is propped
            ServerTestFramework.STFTools.LiveTitle.CheckAndPropTitle(ConfigTitleTestBase.DefaultTitleID, 0,
                ServerTestFramework.LiveService.Auth.AuthContext.ClientTypes.Xenon, null);
            ServerTestFramework.STFTools.LiveTitle.CheckAndPropTitle(ConfigTitle_AdditionalTitles.AlternateTitleID1, 0,
                ServerTestFramework.LiveService.Auth.AuthContext.ClientTypes.Xenon, null);
            ServerTestFramework.STFTools.LiveTitle.CheckAndPropTitle(ConfigTitle_AdditionalTitles.AlternateTitleID2, 0,
                ServerTestFramework.LiveService.Auth.AuthContext.ClientTypes.Xenon, null);
            ServerTestFramework.STFTools.LiveTitle.CheckAndPropTitle(ConfigTitle_ServiceNotMapped.AlternateTitleID, 0,
                ServerTestFramework.LiveService.Auth.AuthContext.ClientTypes.Xenon, null);
        }

        [TestGroupTearDown]
        public void GroupTeardown ()
        {
            // Delete all data from the servers that was placed by tests, can basically target the service
            // IDs returned by the helper functions.
            if (((int) ServiceIDMax) - ((int) ServiceIDBase) > 1024)
            {
                throw new Exception("Something strange happened, service data not deleted because I don't want to destroy the database.");
            }

            string uodbNukeCommand = String.Format(@"
                                                    declare @servbase as int
                                                    declare @servmax as int
                                                    declare @start as datetime
                                                    set @servbase = {0}
                                                    set @servmax = {1}
                                                    set @start = '{2}'
                                                    delete from t_offer_services where i_service_id >= @servbase and i_service_id < @servmax and dt_Change_datetime > @start
                                                    delete from t_service_instances where i_service_id >= @servbase and i_service_id < @servmax and dt_Change_datetime > @start
                                                    delete from t_title_services where i_service_id >= @servbase and i_service_id < @servmax
                                                    delete from t_services where i_service_id >= @servbase and i_service_id < @servmax and vc_kerb_service_name = 'ts' and dt_Change_datetime > @start
                                                    ",
                                                    (int) ServiceIDBase, (int) ServiceIDMax, _SetupTime);
            
            SqlCommand npdbNukeCommand = new SqlCommand(String.Format(@"
                                                                        declare @servbase as int
                                                                        declare @servmax as int
                                                                        declare @start as datetime
                                                                        set @servbase = {0}
                                                                        set @servmax = {1}
                                                                        set @start = '{2}'
                                                                        delete from t_service_keys where i_site_id >= @servbase and i_site_id < @servmax and dt_Change_datetime > @start
                                                                        delete from t_sites where i_site_id >= @servbase and i_site_id < @servmax and vc_kerb_service_name = 'ts' and dt_Change_datetime > @start
                                                                        delete from t_site_virtual_interface_ips where vc_virtual_interface = 'sgsvc_xlsp' and vc_ip = '1.1.1.1'
                                                                        ",
                                                                        (int)ServiceIDBase, (int)ServiceIDMax, _SetupTime));

            // nuke them all from uodb
            ServerTestFramework.Database.UodbWS.ExecuteSQLNonQuery(uodbNukeCommand, null);

            // nuke them all from npdb and Restore back compat string
            using (SqlConnection connection = new SqlConnection(Config.NpdbConnectionString))
            {
                connection.Open();
              
                // Nuke
                npdbNukeCommand.ExecuteNonQuery();

                // Restore 
                SqlCommand comm = new SqlCommand(
                    "update t_settings set vc_value = @backcompat where vc_setting = 'query_LspBackcompTitles'",
                    connection);
                comm.Parameters.Add("@backcompat", System.Data.SqlDbType.NVarChar).Value = _BackCompat;
                comm.ExecuteNonQuery();

                connection.Close();
            }

            // set the cwd back so the state gets saved correctly
            Directory.SetCurrentDirectory(OldCWD);
            CurrDirMoved = false;
        }

        /// <summary>
        /// Removes all of the services from a title using the test class.
        /// </summary>
        /// <param name="title">The title to remove services from.</param>
        public static void RemoveServicesFromTitle (uint title)
        {
            ConfigTitle_RemoveAllServicesFromTitle ctrasft = new ConfigTitle_RemoveAllServicesFromTitle(title);
            TEST_RESULTS result = ctrasft.Run();

            if (result != TEST_RESULTS.PASSED)
            {
                throw new Exception("There was a problem removing all of the services from the given title.");
            }
        }

        [TestGroup]
        public class ConfigHelpers : TestNode
        {
            [TestCase, Ignore]
            public class SetService8001_NOT_MachineOnly : TestNode
            {
                public override TEST_RESULTS Run ()
                {
                    ServerTestFramework.Database.UodbWS.ExecuteSQLNonQuery(
                        "Update t_services set i_machine_only = 0 where i_service_id = 8001", null);

                    return TEST_RESULTS.PASSED;
                }
            }

            [TestCase, Ignore]
            public class SetService8001_MachineOnly : TestNode
            {
                public override TEST_RESULTS Run ()
                {
                    ServerTestFramework.Database.UodbWS.ExecuteSQLNonQuery(
                        "Update t_services set i_machine_only = 1 where i_service_id = 8001", null);

                    return TEST_RESULTS.PASSED;
                }
            }
        }

        [TestCase, Description("Tests the base class code to make sure it properly detects no changes.")]
        public class Empty : LiveLSPTestBase
        {
            public Empty ()
            {
                _ExpectedReturnValue = 1;
            }
        }

        [TestCase, Description("Tests the -outfile flag to make sure the output goes there as well.")]
        public class Outfile : LiveLSPTestBase
        {
            public const string FileContentsFirstLine = "Enabled verbose output\r\n";

            protected string FileName = "OutfileTest.txt";

            public Outfile ()
            {
                // delete output file if it exists
                File.Delete(FileName);
            }

            protected override string GetCommandSwitches ()
            {
                return "-query -site:1 -verbose -outfile:" + FileName;
            }

            protected override bool VerifyOutput (Output output)
            {
                try
                {
                    if (!base.VerifyOutput(output) || !File.Exists(FileName))
                    {
                        return false;
                    }

                    // file is there, check contents against output
                    FileStream stream = new FileStream(FileName, FileMode.Open);
                    string contents = new StreamReader(stream).ReadToEnd();
                    stream.Close();

                    // BUG WORKAROUND FOR TEST
                    // Remove first line 'Enabled verbose output\n' from file contents
                    if (!contents.StartsWith(FileContentsFirstLine))
                    {
                        Global.RO.Error("Expecting the string '" + FileContentsFirstLine + 
                            "' at the beginning of the file.");
                        return false;
                    }

                    contents = contents.Substring(FileContentsFirstLine.Length);

                    if (output.StdOut != contents)
                    {
                        Global.RO.Error("The console output did not match the output in the file:\n" +
                            LiveLSPTestBase.DiffStrings(output.StdOut, contents));
                        return false;
                    }
                }
                finally
                {
                    File.Delete(FileName);
                }

                return true;
            }
        }

        [TestCase, Description("Gives a valid -configtitle call with just the title and service.")]
        // Does not remove services from the title, as many other tests use this test to add services
        public class ConfigTitle_Positive : ConfigTitleTestBase
        {
            private bool _is_setup = false;

            public ConfigTitle_Positive () { }

            public ConfigTitle_Positive (uint title)
            {
                _Setup(title, GoodService);
            }

            public ConfigTitle_Positive (uint title, uint service)
            {
                _Setup(title, service);
            }

            private void _Setup (uint title, uint service)
            {
                TitleID = title;
                ServiceID = service;
                _is_setup = true;
            }

            protected override void Setup ()
            {
                if (!_is_setup)
                {
                    TitleID = DefaultTitleID;
                    ServiceID = GoodService;
                }

                SetExpectations();
            }
        }

        [TestCase, Description("Gives the readonly flag")]
        public class ConfigTitle_ReadOnly : ConfigTitleTestBase
        {
            protected override void Setup ()
            {
                ServiceID = GoodService;
                ReadOnly = true;
                // No changes should occur
            }
        }

        [TestCase, Description("Gives the noreload flag")]
        public class ConfigTitle_NoReload : ConfigTitleTestBase
        {
            protected override void Setup ()
            {
                ServiceID = GoodService;
                NoReload = true;
                SetExpectations();
            }
        }

        [TestCase, Description("Gives an invalid title id to -configtitle.")]
        public class ConfigTitle_InvalidTitle : ConfigTitleTestBase
        {
            public ConfigTitle_InvalidTitle ()
            {
                TitleID = 0xABCDEF01;

                _ExpectedOutputSubstring = "No title id found";
            }

            protected override void Setup ()
            {
                ServiceID = GoodService;
            }
        }

        [TestCase, Description("Gives an invalid service to -configtitle")]
        public class ConfigTitle_InvalidService : ConfigTitleTestBase
        {
            public ConfigTitle_InvalidService ()
            {
                _ExpectedOutputSubstring = "No service found for service-id";
            }

            protected override void Setup ()
            {
                ServiceID = BadService;
            }
        }

        [TestCase, Description("Repeats the valid -configtitle call 3 times to make sure that it works.")]
        public class ConfigTitle_Repeat3 : TestBase
        {
            protected const int RepeatCount = 3;

            protected override void Execute ()
            {
                for (int i = 0; i < RepeatCount; ++i)
                {
                    Global.RO.Debug("Run #{0} for ConfigTitle_Repeat3", i + 1);
                    ConfigTitle_Positive test = new ConfigTitle_Positive(0xFFFF0072);
                    if (i != 0)
                    {
                        test.DBChanges.Remove("t_title_services");
                        test.ServiceChange = null;
                    }
                    ResultCode = test.Run();

                    if (ResultCode != TEST_RESULTS.PASSED)
                    {
                        break;
                    }
                }
            }
        }

        [TestCase, Description("Adds 2 new Titles to the default service.")]
        public class ConfigTitle_AdditionalTitles : TestBase
        {
            public static readonly uint AlternateTitleID1 = 0xFFFE07DE;
            public static readonly uint AlternateTitleID2 = 0xFFFE07FF;

            protected override void Execute ()
            {
                Global.RO.Debug("Running ConfigTitle_Positive for AlternateTitleID1");
                ResultCode = (new ConfigTitle_Positive(AlternateTitleID1)).Run();

                if (ResultCode == TEST_RESULTS.PASSED)
                {
                    Global.RO.Debug("Running ConfigTitle_Positive for AlternateTitleID2");
                    ResultCode = (new ConfigTitle_Positive(AlternateTitleID2)).Run();
                }
            }
        }

        [TestCase, Description("Adds three new Services to the default title.")]
        public class ConfigTitle_AdditionalServices : TestBase
        {
            public uint TitleID;
            public uint[] Services;

            public ConfigTitle_AdditionalServices ()
            {
                TitleID = ConfigTitleTestBase.DefaultTitleID;
            }

            public ConfigTitle_AdditionalServices (uint title)
            {
                TitleID = title;
            }

            protected override void Execute ()
            {
                LiveLSP.RemoveServicesFromTitle(TitleID);

                ResultCode = TEST_RESULTS.FAILED;

                Services = new uint[3];

                for (int i = 0; i < 3; ++i)
                {
                    Global.RO.Debug("Run #{0} of ConfigTitle_Positive for additional services.", i + 1);
                    Services[i] = CreateValidServiceID();
                    ResultCode = (new ConfigTitle_Positive(TitleID, Services[i])).Run();

                    if (ResultCode != TEST_RESULTS.PASSED)
                    {
                        Global.RO.Debug("Run #{0} of ConfigTitle_Positive failed, aborting...", i + 1);
                        break;
                    }
                }
            }
        }

        [TestCase, Description("Adds 5 new Services to the default title.")]
        public class ConfigTitle_FiveServicesError : ConfigTitleTestBase
        {
            public uint[] Services;

            public ConfigTitle_FiveServicesError ()
            {
                TitleID = ConfigTitleTestBase.DefaultTitleID;
            }

            public ConfigTitle_FiveServicesError (uint title)
            {
                TitleID = title;
            }

            protected override void Setup ()
            {
                LiveLSP.RemoveServicesFromTitle(TitleID);

                Services = new uint[5];

                for (int i = 0; i < 4; ++i)
                {
                    Global.RO.Debug("Run #{0} of ConfigTitle_Positive for additional services, this should work.", i + 1);
                    Services[i] = CreateValidServiceID();
                    ResultCode = (new ConfigTitle_Positive(TitleID, Services[i])).Run();

                    if (ResultCode != TEST_RESULTS.PASSED)
                    {
                        throw new ApplicationException(string.Format("Run #{0} of ConfigTitle_Positive failed, aborting...", i + 1));
                    }
                }

                // Setup for running the failing test
                ServiceID = Services[4] = CreateValidServiceID();
                _ExpectedReturnValue = 6;
                _ExpectedOutputSubstring = "Fatal error encountered: 4 DWORD service limit already reached for t_title_services, please investigate.";
            }
        }

        [TestCase, Description("Adds 4 new DWORD Services to the default title, then a byte service.")]
        public class ConfigTitle_FourDWORDS_OneByte : ConfigTitleTestBase
        {
            public uint[] Services;

            public ConfigTitle_FourDWORDS_OneByte ()
            {
                TitleID = ConfigTitleTestBase.DefaultTitleID;
            }

            public ConfigTitle_FourDWORDS_OneByte (uint title)
            {
                TitleID = title;
            }

            protected override void Setup ()
            {
                LiveLSP.RemoveServicesFromTitle(TitleID);

                Services = new uint[5];

                for (int i = 0; i < 4; ++i)
                {
                    Global.RO.Debug("Run #{0} of ConfigTitle_Positive for additional services, this should work.", i + 1);
                    Services[i] = CreateValidServiceID();
                    ResultCode = (new ConfigTitle_Positive(TitleID, Services[i])).Run();

                    if (ResultCode != TEST_RESULTS.PASSED)
                    {
                        Global.RO.Debug("Run #{0} of ConfigTitle_Positive failed, aborting...", i + 1);
                        break;
                    }
                }

                // Setup for running the failing test
                ServiceID = Services[4] = 20;
                SetExpectations();
            }
        }

        [TestCase, Description("Creates a service that does not have a site mapping, then adds a title.")]
        public class ConfigTitle_ServiceNotMapped : ConfigTitleTestBase
        {
            public static readonly uint AlternateTitleID = 0xFFFF0072;

            public ConfigTitle_ServiceNotMapped ()
            {
                TitleID = AlternateTitleID;
                _ExpectedOutputSubstring = "No site specified and none could be determined. Please specify the site.";
            }

            protected override void Setup ()
            {
                ServiceID = AllocateValidServiceID();
                CreateService(ServiceID, false);
            }
        }

        [TestCase, Description("Gives a non-existant site.")]
        public class ConfigTitle_InvalidSite : ConfigTitleTestBase
        {
            protected override void Setup ()
            {
                ServiceID = GoodService;
                SiteID = BadService;
                _ExpectedOutputSubstring = "Please ensure this site exists in t_sites and t_service_keys.";
            }
        }

        [TestCase, Description("Gives a site that exists, but is not the same value as the service")]
        public class ConfigTitle_ValidSite : ConfigTitleTestBase
        {
            protected override void Setup ()
            {
                ServiceID = CreateValidServiceID();
                SiteID = GoodService;
                SetExpectations();

                LiveLSP.RemoveServicesFromTitle(TitleID);
            }
        }

        [TestCase, Description("Gives a non-existant server for the QueryDB")]
        public class ConfigTitle_BadQueryDB : ConfigTitleTestBase
        {
            public const string FakeQueryDBName = "XENOTASERVER001";

            protected override void Setup ()
            {
                _ExpectedOutputSubstring = "Exception: The UPDATE statement conflicted with the FOREIGN KEY " +
                    "constraint \"fk_interface_buckets_servers\". The conflict occurred in database \"npdb\", " +
                    "table \"dbo.t_servers\".";
                ServiceID = GoodService;
                QueryDB = null;

                SetExpectations();

                QueryDB = FakeQueryDBName;

                LiveLSP.RemoveServicesFromTitle(TitleID);
            }
        }

        /// <summary>
        /// Simple class to be used by QueryDBStability.
        /// </summary>
        public class ConfigTitle_QueryDB : ConfigTitleTestBase
        {
            public ConfigTitle_QueryDB (string querydb)
            {
                QueryDB = querydb;
            }

            protected override void Setup ()
            {
                ServiceID = GoodService;
                SetExpectations();

                LiveLSP.RemoveServicesFromTitle(TitleID);
            }
        }

        [TestCase, Description("Checks that not providing a QueryDB value leaves the old value.")]
        public class ConfigTitle_QueryDBStability : ConfigTitleTestBase
        {
            public const string RealQueryDBName = "XETITLSQLV03";

            protected override void Setup ()
            {
                ServiceID = GoodService;
                QueryDB = RealQueryDBName;
                SetExpectations();
                QueryDB = null;

                Global.RO.Debug("Running ConfigTitle_BadQueryDB to set QueryDB value");
                ResultCode = (new ConfigTitle_QueryDB(RealQueryDBName)).Run();

                if (ResultCode != TEST_RESULTS.PASSED)
                {
                    throw new Exception("ConfigTitle_QueryDB did not work.");
                }
            }
        }

        [TestCase, Description("Give the backcompat flag and check the database for the entry")]
        public class ConfigTitle_BackCompat : ConfigTitleTestBase
        {
            protected override void Setup ()
            {
                ServiceID = GoodService;
                BackCompat = true;
                SetExpectations();

                LiveLSP.RemoveServicesFromTitle(TitleID);
            }

            protected override bool VerifyState (State diff)
            {
                if (!base.VerifyState(diff))
                {
                    return false;
                }

                string expect = String.Format("+0x{0:X}", TitleID);
                if (diff.LspBackcompTitles != expect)
                {
                    Global.RO.Error("Back compat setting was not found:\n  Diff Value: {0}\n  Expected Value: {1}",
                        diff.LspBackcompTitles, expect);
                    return false;
                }

                return true;
            }
        }

        [TestCase, Description("Add a service to an Xbox 1 title to check on the t_offer_services update.")]
        public class ConfigTitle_Xbox1 : ConfigTitleTestBase
        {
            protected override void Setup ()
            {
                ServiceID = GoodService;
                TitleID = 0xFFFE0000;
                SetExpectations();
            }
        }

        [TestCase, Description("Removes a specific service from a title, which doesn't have that service.")]
        public class ConfigTitle_Remove_NoAssociation : ConfigTitleTestBase
        {
            protected override void Setup ()
            {
                ServiceID = GoodService;
                TitleID = 0xFFFE07D1;
                Remove = true;
                // No changes expected, don't call SetExpectations
            }
        }

        [TestCase, Description("Removes a single service from a title that has many.")]
        public class ConfigTitle_Remove_SingleService : ConfigTitleTestBase
        {
            protected override void Setup ()
            {
                // Would normally be done in setup
                TitleID = DefaultTitleID;
                Remove = true;

                Global.RO.Debug("Running ConfigTitle_AdditionalServices to give the default title many services.");
                ConfigTitle_AdditionalServices ctas = new ConfigTitle_AdditionalServices(TitleID);
                ResultCode = ctas.Run();

                if (ResultCode != TEST_RESULTS.PASSED)
                {
                    throw new ApplicationException("Running ConfigTitle_AdditionalServices failed, aborting.");
                }

                // extract an added service and set expectations at this time
                ServiceID = ctas.Services[0];
                SetExpectations();
            }
        }

        [TestCase, Description("Removes all services from a title, may or may not have any services.")]
        public class ConfigTitle_RemoveAllServicesFromTitle : ConfigTitleTestBase
        {
            public ConfigTitle_RemoveAllServicesFromTitle ()
            {
                TitleID = DefaultTitleID;
            }

            public ConfigTitle_RemoveAllServicesFromTitle (uint title)
            {
                TitleID = title;
            }

            protected override void Setup ()
            {
                Remove = true;
                SetExpectations();
            }

            protected override bool VerifyServices (State diff)
            {
                foreach (State.Service servchange in diff.Services)
                {
                    // we don't care about the base services
                    // special case out the machine only service used by kdc tests
                    if (servchange.ID > 100 && servchange.ID != 8001 && 
                        (servchange.Status == State.Service.ServiceStatus.Given ||
                         servchange.Status == State.Service.ServiceStatus.Upgraded ||
                         servchange.Status == State.Service.ServiceStatus.Granted))
                    {
                        Global.RO.Error("We should not have any dword services after removing all of them from a " +
                            "title: 0x{0:X8} [{1}]", servchange.ID, servchange.Status.ToString());
                        return false;
                    }
                }

                return true;
            }
        }

        [TestCase, Description("Removes all services from a title that has many.")]
        public class ConfigTitle_Remove_ManyServices : TestBase
        {
            protected override void Execute ()
            {
                uint TitleID = 0xFFFF0090;

                Global.RO.Debug("Running ConfigTitle_AdditionalServices to give a title many services.");
                ConfigTitle_AdditionalServices ctas = new ConfigTitle_AdditionalServices(TitleID);
                ResultCode = ctas.Run();

                if (ResultCode != TEST_RESULTS.PASSED)
                {
                    Global.RO.Error("Running ConfigTitle_AdditionalServices failed, aborting.");
                    return;
                }

                Global.RO.Debug("Running ConfigTitle_RemoveAllServicesFromTitle to remove those services.");
                ConfigTitle_RemoveAllServicesFromTitle ctrasft = new ConfigTitle_RemoveAllServicesFromTitle(TitleID);
                ResultCode = ctrasft.Run();
            }
        }

        [TestCase, Description("Simple positive case for -configpartner")]
        public class ConfigPartner_Positive : ConfigPartnerTestBase
        {
            protected bool ServiceStatic = false;

            public ConfigPartner_Positive() { }

            public ConfigPartner_Positive(uint service)
            {
                ServiceID = service;
                ServiceStatic = true;
            }

            protected override void Setup()
            {
                if (!ServiceStatic)
                {
                    ServiceID = AllocateValidServiceID();
                }

                SetExpectations();
            }
        }

        [TestCase, Description("Simple case for -configpartner that specifies the Site Ip")]
        public class ConfigPartner_SiteIp : ConfigPartnerTestBase
        {
            protected bool ServiceStatic = false;

            public ConfigPartner_SiteIp() { }

            public ConfigPartner_SiteIp(uint service, string siteip)
            {
                ServiceID = service;
                SiteIp = siteip;
                ServiceStatic = true;
            }

            protected override void Setup()
            {
                if (!ServiceStatic)
                {
                    ServiceID = AllocateValidServiceID();
                    SiteIp = "10.11.12.13";
                }


                SetExpectations();
            }
        }

        [TestCase, Description("Simple case for -configpartner that specifies a ticket lifetime")]
        public class ConfigPartner_TicketLifetime : ConfigPartnerTestBase
        {
            protected bool ServiceStatic = false;

            public ConfigPartner_TicketLifetime() { }

            public ConfigPartner_TicketLifetime(uint service, uint ticketlifetime)
            {
                ServiceID = service;
                Lifetime = ticketlifetime;
                ServiceStatic = true;
            }

            protected override void Setup()
            {
                if (!ServiceStatic)
                {
                    ServiceID = AllocateValidServiceID();
                    Lifetime = 4;
                }

                SetExpectations();
            }
        }


        [TestCase, Description("Give the readonly flag")]
        public class ConfigPartner_ReadOnly : ConfigPartnerTestBase
        {
            protected override void Setup ()
            {
                ServiceID = AllocateValidServiceID();
                ReadOnly = true;
                // No changes should occur
            }
        }

        [TestCase, Description("Give the noreload flag")]
        public class ConfigPartner_NoReload : ConfigPartnerTestBase
        {
            protected override void Setup ()
            {
                ServiceID = AllocateValidServiceID();
                NoReload = true;
                SetExpectations();
            }
        }

        [TestCase, Description("Repeats the valid -configpartner call 3 times to make sure that it works.")]
        public class ConfigPartner_Repeat3 : TestBase
        {
            protected const int RepeatCount = 3;

            protected override void Execute ()
            {
                uint id = AllocateValidServiceID();

                for (int i = 0; i < RepeatCount; ++i)
                {
                    Global.RO.Debug("Run #{0} for ConfigPartner_Repeat3", i + 1);
                    ConfigPartner_Positive test = new ConfigPartner_Positive(id);
                    ResultCode = test.Run();

                    if (ResultCode != TEST_RESULTS.PASSED)
                    {
                        break;
                    }
                }
            }
        }

        [TestCase, Description("Both the service and site are new")]
        public class ConfigPartner_SiteDoesNotExist : ConfigPartnerTestBase
        {
            protected override void Setup ()
            {
                ServiceID = AllocateValidServiceID();
                SiteID = AllocateValidServiceID();
                SetExpectations();
            }
        }

        [TestCase, Description("Gives a new service that already exists as a site")]
        public class ConfigPartner_SiteExistsImplicit : ConfigPartnerTestBase
        {
            protected override void Setup ()
            {
                ConfigPartner_SiteDoesNotExist test = new ConfigPartner_SiteDoesNotExist();
                if (test.Run() != TEST_RESULTS.PASSED)
                {
                    throw new Exception("Failed to create a site using ConfigPartner_SiteDoesNotExist");
                }

                ServiceID = AllocateValidServiceID();
                SiteID = test.SiteID;
                SetExpectations();
            }
        }

        [TestCase, Description("Gives a site that already exists")]
        public class ConfigPartner_SiteExistsExplicit : ConfigPartnerTestBase
        {
            protected override void Setup ()
            {
                ServiceID = AllocateValidServiceID();
                SiteID = GoodService;
                SetExpectations();
            }
        }

        [TestCase, Description("Gives a 30 character description [max length]")]
        public class ConfigPartner_ServiceDescription30 : ConfigPartnerTestBase
        {
            protected override void Setup ()
            {
                ServiceID = GoodService;
                //                    123456789012345678901234567890
                ServiceDescription = "This is 30 characters long....";
                SetExpectations();
            }
        }

        [TestCase, Description("Gives a 31 character description [too long]")]
        public class ConfigPartner_ServiceDescription31 : ConfigPartnerTestBase
        {
            protected override void Setup ()
            {
                ServiceID = GoodService;
                //                    123456789012345678901234567890
                ServiceDescription = "This is 31 characters long....";
                SetExpectations();
                _ExpectedOutputSubstring = "Service description is too long, truncating to \"This is 31 " +
                    "characters long....\"";
                ServiceDescription = "This is 31 characters long.....";
            }
        }

        [TestCase, Description("Checks that the description is not changed when not given")]
        public class ConfigPartner_ServiceDescriptionInvariance : ConfigPartnerTestBase
        {
            protected override void Setup ()
            {
                ServiceID = CreateValidServiceID();
                ServiceDescription = String.Format("LiveLSPTest Service {0:X8}", ServiceID);
                SetExpectations();
                ServiceDescription = null;
            }
        }

        [TestCase, Description("Gives a 100 character description [max length]")]
        public class ConfigPartner_SiteDescription100 : ConfigPartnerTestBase
        {
            protected override void Setup ()
            {
                ServiceID = GoodService;
                //                 1         2         3         4         5         6         7         8         9         0         |
                //                 1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
                SiteDescription = "This is 100 characters long.... seriously, exactly 100 characters, I measured it.... with a ruler...";
                SetExpectations();
            }
        }

        [TestCase, Description("Gives a 101 character description [max length]")]
        public class ConfigPartner_SiteDescription101 : ConfigPartnerTestBase
        {
            protected override void Setup ()
            {
                ServiceID = GoodService;
                //                 1         2         3         4         5         6         7         8         9         0         |
                //                 1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
                SiteDescription = "This is 101 characters long.... seriously, exactly 101 characters, I measured it.... with a ruler...";
                SetExpectations();
                _ExpectedOutputSubstring = "Site description is too long, truncating to \"This is 101 " +
                    "characters long.... seriously, exactly 101 characters, I measured it.... with a ruler...\"";
                SiteDescription = "This is 101 characters long.... seriously, exactly 101 characters, I measured it.... with a ruler...!";
            }
        }

        [TestCase, Description("Checks that the description is not changed when not given")]
        public class ConfigPartner_SiteDescriptionInvariance : ConfigPartnerTestBase
        {
            protected override void Setup ()
            {
                ServiceID = CreateValidServiceID();
                SiteID = ServiceID;
                SiteDescription = String.Format("LiveLSPTest Site {0:X8}", SiteID);
                SetExpectations();
                SiteDescription = null;
            }
        }

        [TestCase, Description("Give the value 2 to authdata")]
        public class ConfigPartner_Authdata2 : ConfigPartnerTestBase
        {
            protected override void Setup ()
            {
                ServiceID = AllocateValidServiceID();
                Authdata = "2";
                SetExpectations();
            }
        }

        [TestCase, Description("Give the value 3 to authdata")]
        public class ConfigPartner_Authdata3 : ConfigPartnerTestBase
        {
            protected override void Setup ()
            {
                ServiceID = AllocateValidServiceID();
                Authdata = "3";
                SetExpectations();
            }
        }

        [TestCase, Description("Give the value Q to authdata")]
        public class ConfigPartner_AuthdataQ : ConfigPartnerTestBase
        {
            protected override void Setup ()
            {
                ServiceID = AllocateValidServiceID();
                Authdata = "Q";
                _ExpectedReturnValue = -1;
                _ExpectedOutputSubstring = "Invalid -authdata. Valid values are 2 or 3.";
            }
        }

        [TestCase, Description("Give a different master key file")]
        public class ConfigPartner_MasterKey : ConfigPartnerTestBase
        {
            protected const string MasterKeyFile = "masterkey.pub";
            protected const string AltMasterKeyFile = "AlternateMasterKey.pub";

            protected override void Setup ()
            {
                ServiceID = AllocateValidServiceID();
                MasterKey = AltMasterKeyFile;
                SetExpectations();
            }

            protected override void Execute ()
            {
                // change the master key file to the new name
                if (File.Exists(MasterKeyFile))
                {
                    File.Move(MasterKeyFile, AltMasterKeyFile);
                }
                else
                {
                    throw new Exception("No master key file found at location '" + Path.GetFullPath(MasterKeyFile) + "'");
                }

                try
                {
                    base.Execute();
                }
                finally
                {
                    // change the file name back
                    File.Move(AltMasterKeyFile, MasterKeyFile);
                }
            }
        }

        [TestCase, Description("Give the -noassociation flag, which will not put a 0-title t_service_instance row in the database")]
        public class ConfigPartner_NoAssociation : ConfigPartnerTestBase
        {
            protected override void Setup ()
            {
                ServiceID = AllocateValidServiceID();
                NoAssociation = true;
                SetExpectations();
            }
        }

        [TestCase, Description("Attempts to remove any association that an unrelated service/site have, shouldn't change anything.")]
        public class ConfigPartner_Remove_NotAssociated : ConfigPartnerTestBase
        {
            protected override void Setup ()
            {
                ServiceID = CreateValidServiceID();
                SiteID = GoodService;
                Remove = true;
                // Don't need to SetExpectations because nothing should change
            }
        }

        [TestCase, Description("Removes the association between a service and its site.")]
        public class ConfigPartner_Remove_Associated : ConfigPartnerTestBase
        {
            protected override void Execute ()
            {
                // Would normally be done in setup
                ServiceID = AllocateValidServiceID();
                Remove = true;
                SetExpectations();

                Global.RO.Debug("Running ConfigPartner_Positive to create a valid service with a site association.");
                ConfigPartner_Positive cpp = new ConfigPartner_Positive(ServiceID);
                ResultCode = cpp.Run();

                if (ResultCode != TEST_RESULTS.PASSED)
                {
                    return;
                }

                base.Execute();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\systemcheck\exe\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\systemcheck\exe\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TokenGenTest\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TokenImport\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\systemcheck\SystemCheckSchema.cs ===
// Copyright 2004, Microsoft Corporation
// Sample Code - Use restricted to terms of use defined in the accompanying license agreement (EULA.doc)

//--------------------------------------------------------------
// Autogenerated by XSDObjectGen version 1.4.4.1
// Schema file: SystemCheckSchema.xsd
// Creation Date: 7/26/2007 7:12:33 PM
//--------------------------------------------------------------

using System;
using System.Xml.Serialization;
using System.Collections;
using System.Xml.Schema;
using System.ComponentModel;

namespace xonline.tools.toolsuite.systemcheck
{

	public struct Declarations
	{
		public const string SchemaVersion = "http://tempuri.org/SystemCheck.xsd";
	}


	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class HeaderCollection : ArrayList
	{
		public xonline.tools.toolsuite.systemcheck.Header Add(xonline.tools.toolsuite.systemcheck.Header obj)
		{
			base.Add(obj);
			return obj;
		}

		public xonline.tools.toolsuite.systemcheck.Header Add()
		{
			return Add(new xonline.tools.toolsuite.systemcheck.Header());
		}

		public void Insert(int index, xonline.tools.toolsuite.systemcheck.Header obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(xonline.tools.toolsuite.systemcheck.Header obj)
		{
			base.Remove(obj);
		}

		new public xonline.tools.toolsuite.systemcheck.Header this[int index]
		{
			get { return (xonline.tools.toolsuite.systemcheck.Header) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class CheckResultCollection : ArrayList
	{
		public xonline.tools.toolsuite.systemcheck.CheckResult Add(xonline.tools.toolsuite.systemcheck.CheckResult obj)
		{
			base.Add(obj);
			return obj;
		}

		public xonline.tools.toolsuite.systemcheck.CheckResult Add()
		{
			return Add(new xonline.tools.toolsuite.systemcheck.CheckResult());
		}

		public void Insert(int index, xonline.tools.toolsuite.systemcheck.CheckResult obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(xonline.tools.toolsuite.systemcheck.CheckResult obj)
		{
			base.Remove(obj);
		}

		new public xonline.tools.toolsuite.systemcheck.CheckResult this[int index]
		{
			get { return (xonline.tools.toolsuite.systemcheck.CheckResult) base[index]; }
			set { base[index] = value; }
		}
	}



	[XmlType(TypeName="Header",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class Header
	{

		[XmlAttribute(AttributeName="key",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __key;
		
		[XmlIgnore]
		public string key
		{ 
			get { return __key; }
			set { __key = value; }
		}

		[XmlAttribute(AttributeName="value",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __value;
		
		[XmlIgnore]
		public string @value
		{ 
			get { return __value; }
			set { __value = value; }
		}

		public Header()
		{
		}
	}


	[XmlType(TypeName="Response",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class Response
	{

		[XmlAttribute(AttributeName="httpResponseCode",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __httpResponseCode;
		
		[XmlIgnore]
		public string httpResponseCode
		{ 
			get { return __httpResponseCode; }
			set { __httpResponseCode = value; }
		}

		[XmlElement(Type=typeof(xonline.tools.toolsuite.systemcheck.Header),ElementName="Header",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public HeaderCollection __HeaderCollection;
		
		[XmlIgnore]
		public HeaderCollection HeaderCollection
		{
			get
			{
				if (__HeaderCollection == null) __HeaderCollection = new HeaderCollection();
				return __HeaderCollection;
			}
			set {__HeaderCollection = value;}
		}

		[XmlElement(ElementName="ResponseText",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __ResponseText;
		
		[XmlIgnore]
		public string ResponseText
		{ 
			get { return __ResponseText; }
			set { __ResponseText = value; }
		}

		public Response()
		{
		}
	}


	[XmlType(TypeName="CheckResult",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class CheckResult
	{

		[XmlElement(ElementName="Url",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __Url;
		
		[XmlIgnore]
		public string Url
		{ 
			get { return __Url; }
			set { __Url = value; }
		}

		[XmlElement(ElementName="TimeOut",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="int",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public int __TimeOut;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __TimeOutSpecified;
		
		[XmlIgnore]
		public int TimeOut
		{ 
			get { return __TimeOut; }
			set { __TimeOut = value; __TimeOutSpecified = true; }
		}

		[XmlElement(Type=typeof(xonline.tools.toolsuite.systemcheck.Response),ElementName="Response",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.tools.toolsuite.systemcheck.Response __Response;
		
		[XmlIgnore]
		public xonline.tools.toolsuite.systemcheck.Response Response
		{
			get
			{
				if (__Response == null) __Response = new xonline.tools.toolsuite.systemcheck.Response();		
				return __Response;
			}
			set {__Response = value;}
		}

		public CheckResult()
		{
		}
	}


	[XmlRoot(ElementName="SystemCheckResults",Namespace=Declarations.SchemaVersion,IsNullable=false),Serializable]
	[XmlType(TypeName="SystemCheckResults",Namespace=Declarations.SchemaVersion)]
	public class SystemCheckResults
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
            return CheckResultCollection.GetEnumerator();
		}

		public xonline.tools.toolsuite.systemcheck.CheckResult Add(xonline.tools.toolsuite.systemcheck.CheckResult obj)
		{
			return CheckResultCollection.Add(obj);
		}

		[XmlIgnore]
		public xonline.tools.toolsuite.systemcheck.CheckResult this[int index]
		{
			get { return (xonline.tools.toolsuite.systemcheck.CheckResult) CheckResultCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return CheckResultCollection.Count; }
        }

        public void Clear()
		{
			CheckResultCollection.Clear();
        }

		public xonline.tools.toolsuite.systemcheck.CheckResult Remove(int index) 
		{ 
            xonline.tools.toolsuite.systemcheck.CheckResult obj = CheckResultCollection[index];
            CheckResultCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            CheckResultCollection.Remove(obj);
        }

		[XmlAttribute(AttributeName="processingStart",DataType="dateTime")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public DateTime __processingStart;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __processingStartSpecified;
		
		[XmlIgnore]
		public DateTime processingStart
		{ 
			get { return __processingStart; }
			set { __processingStart = value; __processingStartSpecified = true; }
		}
		
		[XmlIgnore]
		public DateTime processingStartUtc
		{ 
			get { return __processingStart.ToUniversalTime(); }
			set { __processingStart = value.ToLocalTime(); __processingStartSpecified = true; }
		}

		[XmlAttribute(AttributeName="processingEnd",DataType="dateTime")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public DateTime __processingEnd;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __processingEndSpecified;
		
		[XmlIgnore]
		public DateTime processingEnd
		{ 
			get { return __processingEnd; }
			set { __processingEnd = value; __processingEndSpecified = true; }
		}
		
		[XmlIgnore]
		public DateTime processingEndUtc
		{ 
			get { return __processingEnd.ToUniversalTime(); }
			set { __processingEnd = value.ToLocalTime(); __processingEndSpecified = true; }
		}

		[XmlElement(Type=typeof(xonline.tools.toolsuite.systemcheck.CheckResult),ElementName="CheckResult",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public CheckResultCollection __CheckResultCollection;
		
		[XmlIgnore]
		public CheckResultCollection CheckResultCollection
		{
			get
			{
				if (__CheckResultCollection == null) __CheckResultCollection = new CheckResultCollection();
				return __CheckResultCollection;
			}
			set {__CheckResultCollection = value;}
		}

		public SystemCheckResults()
		{
			__processingStart = DateTime.Now;
			__processingEnd = DateTime.Now;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TokenImport\exe\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\systemcheck\systemchecktool.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Net;
using System.Threading;

using xonline.common.mgmt;
using xonline.common.config;
using xonline.common.tools;
using xonline.common.tools.console;
using xonline.tools.framework;
using System.Xml.Serialization;
using System.Xml;
using System.Reflection;

namespace xonline.tools.toolsuite.systemcheck
{
	/// <summary>
	/// Command line code for the system check tool
	/// </summary>
	class SystemCheckTool
	{

        static void Usage()
        {
            Console.WriteLine( "\r\nS Y S T E M  C H E C K\r\n" );
            Console.WriteLine( "A tool to check the health URL's of servers across the service." );
            Console.WriteLine( "" );
            Console.WriteLine( "Usage:" );
            Console.WriteLine( "    SystemCheck /?" );
            Console.WriteLine( "    SystemCheck /configfile:<filepath> /threads:<# of threads> " );
            Console.WriteLine( "                 /timeout:<timeout in ms> /outfile:<outputfile>" );
            Console.WriteLine( "    SystemCheck /reloadfd " );
            Console.WriteLine( "" );

            //            Console.WriteLine( "    ServiceCheck /listservers [/vip:<VIP>]" );
            //            Console.WriteLine( "    ServiceCheck /listvips [/server:<ServerName>]" );
            //            Console.WriteLine( "    ServiceCheck /server:<ServerName> " );
            //            Console.WriteLine( "    ServiceCheck /vip:<VIP> " );
            //            Console.WriteLine( "    ServiceCheck /server:<ServerName> /vip:<VIP> " );
            //            Console.WriteLine( "    ServiceCheck /title:<title> " );
            //            Console.WriteLine( "    ServiceCheck /puid:<puid> " );
            //            Console.WriteLine( "    ServiceCheck /gamertag:<gamertag> " );
            Console.WriteLine( "" );
            Console.WriteLine( "Definitions:" );
            Console.WriteLine( "    <configfile> : file containing URLs to hit, one per line." );
            Console.WriteLine( "    <threads>    : number of threads to use in making calls" );
            Console.WriteLine( "    <timeout>    : how long tool should wait for URL request to return" );
            Console.WriteLine( "    <outfile>    : (optional) output file location" );
            Console.WriteLine( "    <reloadfd>  : reload all front doors affected by Live* tools" );

            //            Console.WriteLine( "    <title>   - check that a specific title can log in" );
            //            Console.WriteLine( "    <ServerName> : if supplied, only this server will be accessed" );
            //            Console.WriteLine( "    <VIP>        : if supplied, only this VIP will be accessed" );
            Console.WriteLine( "" );
            Console.WriteLine( "" );

            Console.WriteLine( "Examples:" );
            Console.WriteLine( "" );
            Console.WriteLine( "  Call URLs with default output file, wait for up to a minute, 3 threads: " );
            Console.WriteLine( "    SystemCheck /configfile:urls2call.txt /threads:3 /timeout:60000 " );
            Console.WriteLine( "" );
            Console.WriteLine( "  Call URLs with specified output file, wait for up to 30s per URL, 5 threads: " );
            Console.WriteLine( "    SystemCheck /configfile:urls2call.txt /threads:5 /timeout:60000 /outfile:\\\\server\\share\\output.xml" );
            Console.WriteLine( "" );
            Console.WriteLine( "  Reload all the front doors after deploying many titles, wait up to 60s per xmgmt call" );
            Console.WriteLine( "    SystemCheck /reloadfd [/timeout:60000]" );


            //            Console.WriteLine( "  Getting a list of all servers:" );
            //            Console.WriteLine( "    ServiceCheck /listservers " );
            //            Console.WriteLine( "  Getting a list of all servers in the statsfd VIP:" );
            //            Console.WriteLine( "    ServiceCheck /listservers /vip:statsfd " );
            //            Console.WriteLine( "  Getting a list of all VIPs:" );
            //            Console.WriteLine( "    ServiceCheck /listvips [/server:<ServerName>]" );
            //            Console.WriteLine( "  Getting a list of all VIPs a specific server supports:" );
            //            Console.WriteLine( "    ServiceCheck /listvips /server:TukXePoolIIS001" );
            //            Console.WriteLine( "  Call the healthcheck URL for all VIPS on TukXePoolIIS001:" );
            //            Console.WriteLine( "    ServiceCheck /healthcheck /server:TukXePoolIIS001 " );
            //            Console.WriteLine( "  Call the statsfd healthcheck URL on all servers supporting it:" );
            //            Console.WriteLine( "    ServiceCheck /healthcheck /vip:statsfd " );
            //            Console.WriteLine( "  Call the statsfd healthcheck URL on :" );
            //            Console.WriteLine( "    ServiceCheck /healthcheck /server:TukXePoolIIS001 /vip:statsfd " );

        }

        public static ArrayList GetURLS( NamedArgParser args )
        {
            ArrayList URLS = new ArrayList();
            string urlLine = "";

            StreamReader urlFile = File.OpenText( args[ "configfile" ]);
            Console.WriteLine( "Queuing up URLs from the file... ");

            while ( ( urlLine = urlFile.ReadLine() ) != null ) 
            {
                urlLine = urlLine.Trim();
                if ( urlLine != "" )
                {
                    try
                    {
                        //if format isn't valid, it will throw
                        Uri testUri = new Uri( urlLine.Trim() );
                        Console.WriteLine( "   Adding: " + urlLine );
                        URLS.Add( urlLine );
                    }
                    catch( UriFormatException )
                    {
                        Console.WriteLine( "Problem URL ignored: " + urlLine );
                    }
                }
            }
           
            return URLS;
        }


        [STAThread]
        static int Main(string[] args)
        {
            try
            {
                //task: these next 20 lines or so appear in all console tools.. is there a way to factor this out?
                string[] rgstrCmdLineTags = 
            {
                "?", 
                "configfile",        //
                "threads",
                "timeout",
                "outfile",
                "reloadfd"
            };

                NamedArgParser argParser = new NamedArgParser(rgstrCmdLineTags);

                #region Validate commandline args


                // Parse any command line arguments, returns false if there are extras
                if (!argParser.Parse(args))
                {
                    Usage();
                    return -1;
                }

                // Did the user request usage information?        
                if (0 == argParser.Count ||
                    null != argParser["?"])
                {
                    Usage();
                    return 0;
                }

                Console.WriteLine("\r\n         S  Y  S  T  E  M     C  H  E  C  K ");
                Console.WriteLine("\r\n=================================================\r\nCommand Line Arguments were: ");
                foreach (object thisArg in argParser.Keys)
                {
                    if (((string)argParser[thisArg.ToString()]) == "")
                    {
                        //for switches which don't supply an argument
                        Console.WriteLine("Switch " + ((string)thisArg).PadLeft(30, ' ') + "    Was Present ");
                    }
                    else
                    {
                        Console.WriteLine("Switch " + ((string)thisArg).PadLeft(30, ' ') + "    had the value |" + ((string)argParser[thisArg.ToString()]).PadRight(30, ' ') + "|");
                    }
                }

                if (
                     (
                      (argParser["configfile"] == null) ||
                      (argParser["threads"] == null) ||
                      (argParser["timeout"] == null)
                     ) &&
                     (
                      (argParser["reloadfd"] == null)
                     )
                   )
                {
                    Usage();
                    Console.WriteLine("\r\n\r\nA required parameter was not present. Check help and try again.");
                    return -1;
                }

                int maxThreadCount = 1;
                int timeOut = 0;
                //if running health checks, not fd reload
                if (argParser["reloadfd"] == null)
                {
                    //maxthreadcount value
                    try
                    {
                        maxThreadCount = Int32.Parse(argParser["threads"]);
                        if (maxThreadCount < 1)
                        {
                            throw new ArgumentException("<threads> should be a number greater than 0", "threads");
                        }
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine("Threads parameter was not a valid integer. Please correct and retry.\r\nError was:\r\n" + e.ToString());
                        return -1;
                    }

                    //timeout value
                    try
                    {
                        timeOut = Int32.Parse(argParser["timeout"]);
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine("Timeout parameter was not a valid integer. Please correct and retry.\r\nError was:\r\n" + e.ToString());
                        return -1;
                    }
                }
                #endregion


                //task: Add CheckReady stuff here to confirm all DB's are up and reachable.
                //(once Checkready has been upgraded to use the ConfigDB..)

                //task: Method in systemcheck.cs
                //task: get list of servers/vips from ConfigDB or ConfigFile
                //task: confirm all vips/servers are valid (only if user-supplied)
                //task: confirm all specific vips exist on specified servers (only if user-supplied)

                //task: result of the above processing should be an array list with all the URLs that are going to be called
                //task: create an object for this:
                //task: server, URL, owning thread (null if not taken yet?), result
                //task: need to be able to sort by server...

                //task: what about cache reloads??? seems handy to have... 

                Console.WriteLine("\r\n\r\nCommencing System Check ... \r\n");
                Console.WriteLine("   .Net Version: " + System.Environment.Version.ToString());
                //            Console.WriteLine( "   Environment : " );
                //            Console.WriteLine( "   Server(s)   : " );
                //            Console.WriteLine( "   Component(s): " );
                Console.WriteLine("\r\n");


                //Are we reloading front doors?
                if (argParser["reloadfd"] != null)
                {
                    int xmgmtTimeout = SystemCheck.DEFAULT_RELOAD_TIMEOUT;

                    if (null != argParser["timeout"])
                    {
                        //timeout value
                        try
                        {
                            xmgmtTimeout = Int32.Parse(argParser["timeout"]);
                        }
                        catch (Exception e)
                        {
                            Console.WriteLine("Timeout parameter was not a valid integer. Please correct and retry.\r\nError was:\r\n" + e.ToString());
                            return -1;
                        }
                    }

                    string result = SystemCheck.ReloadAllFrontDoors(xmgmtTimeout);
                    Console.WriteLine(result);

                    //task: make the return code reflect any errors - if this would be used... 
                    return 0;
                }


                //The default is to call health check API's
                ArrayList URLS = GetURLS(argParser);

                //this method, essentially a custom thread pool, should be more maintainable over time
                //since the code is simpler and more straightforward than using async requests and delegates.
                //it won't be as fast as other algorithms... but this is a tool in which even a 50% perf hit
                //will be essentialy negligible over the gain the tool provides vs manual methods

                int requestNum = 0;

                //holds the currently active threads. spool <--> thread, get it?
                Thread[] spool = new Thread[maxThreadCount];
                for (int iLoop = 0; iLoop < maxThreadCount; iLoop++)
                {
                    spool[iLoop] = null;
                }

                ArrayList requestInfo = new ArrayList();

                DateTime processingStart = System.DateTime.UtcNow;
                bool done = false;
                //walk the list of requests till we've complete all requests
                while ((requestNum < URLS.Count) || !done)
                {
                    done = true;
                    Console.WriteLine("\r\n\r\nStarting to check threads... {0}\r\n{1} of {2} URLS have been requested",
                                        System.DateTime.Now, requestNum, URLS.Count);

                    //check on the threads: any need a new URL to request?
                    for (int iLoop = 0; iLoop < maxThreadCount; iLoop++)
                    {
                        //if there's a thread
                        if (spool[iLoop] != null)
                        {
                            Console.Write("  thread {0}: ", iLoop);
                            //and it's stopped
                            if (spool[iLoop].ThreadState == System.Threading.ThreadState.Stopped)
                            {
                                //mark the spot as open
                                spool[iLoop] = null;
                                Console.WriteLine(" Just completed.");
                            }
                            else
                            {
                                Console.WriteLine(" Waiting.");
                                done = false;
                            }
                        }

                        //if there's more work to do
                        if ((spool[iLoop] == null) && (requestNum < URLS.Count))
                        {
                            done = false;
                            //queue up another request
                            //give the object the data via the constructor
                            //... because ThreadStart doesn't allow parameters, or return values... 
                            URLRequestor b = new URLRequestor(URLS[requestNum].ToString(), timeOut);
                            requestInfo.Add(b);
                            Thread t = new Thread(new ThreadStart(b.CallURL));
                            spool[iLoop] = t;
                            t.Start();
                            requestNum++;
                        }

                    } //for 

                    //checked up on all threads... sleep for a bit a start again
                    Thread.Sleep(1000);

                } //while not done

                //Report and 
                Console.WriteLine("\r\n\r\n*******************\r\n\r\nWriting results...\r\n\r\n");

                try
                {

                    string logfilepath;

                    if (argParser["outfile"] == null)
                    {
                        logfilepath = System.IO.Directory.GetCurrentDirectory().ToString() + "\\SystemCheckLog_" + System.DateTime.Now.Year + "_" + System.DateTime.Now.Month + "_" + System.DateTime.Now.Day + "_" + System.DateTime.Now.Hour + "_" + System.DateTime.Now.Minute + "_" + System.DateTime.Now.Second + ".xml";
                    }
                    else
                    {
                        logfilepath = argParser["outfile"];
                    }

                    Console.WriteLine("Writing log to file... ");

                    SystemCheckResults results = new SystemCheckResults();
                    results.processingStart = processingStart;
                    results.processingEnd = DateTime.Now;
                    results.CheckResultCollection = new CheckResultCollection();

                    //output written to output file
                    foreach (URLRequestor ur in requestInfo)
                    {
                        results.CheckResultCollection.Add(ur.Result);
                    }

                    XmlWriterSettings xmlWriterSettings = new XmlWriterSettings();
                    xmlWriterSettings.Indent = true;
                    using (XmlWriter xmlWriter = XmlWriter.Create(logfilepath, xmlWriterSettings))
                    {
                        xmlWriter.WriteProcessingInstruction("xml-stylesheet", "type=\'text/xsl\' href=\'SystemCheckHTML.xslt\'");
                        XmlSerializer serializer = new XmlSerializer(typeof(SystemCheckResults));
                        serializer.Serialize(xmlWriter, results);
                    }

                    // Write the XSLT out from the manifest
                    using (FileStream xsltOutStream = new FileStream(Path.Combine(Path.GetDirectoryName(logfilepath), "SystemCheckHTML.xslt"), FileMode.Create, FileAccess.Write, FileShare.Read))
                    {
                        using (Stream xsltInStream = Assembly.GetExecutingAssembly().GetManifestResourceStream("xonline.tools.toolsuite.systemcheck.SystemCheckHTML.xslt"))
                        {
                            Byte[] block = new Byte[8192];
                            int bytesRead;

                            while ((bytesRead = xsltInStream.Read(block, 0, 8192)) != 0)
                            {
                                xsltOutStream.Write(block, 0, bytesRead);
                            }
                        }
                    }
                    Console.WriteLine("Created log file at " + logfilepath);
                } // try
                catch (Exception e)
                {
                    // something went wrong
                    Console.WriteLine("An error occurred creating the log file.");
                    Console.WriteLine("Error was: \r\n  " + e.ToString());
                    return -1;
                }

                Console.WriteLine("Results written to file.\r\nSystem Check Complete.");
            }
            catch (Exception e)
            {
                Console.WriteLine("System check failed with exception:");
                Console.WriteLine(e.ToString());

                return -1;
            }

            return 1;
        } // main

	} // deploy title

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\systemcheck\URLRequestor.cs ===
using System;
using System.IO;
using System.Net;
using System.Text;


namespace xonline.tools.toolsuite.systemcheck
{
	/// <summary>
	/// Summary description for URLRequestor.
	/// </summary>
	public class URLRequestor
	{
        public string URL = "";
        public int Timeout = 0;
        public CheckResult Result = new CheckResult();
        
        public URLRequestor( string RequestURL, int URLTimeout )
        {
            URL = RequestURL;
            Timeout = URLTimeout;
        }

        public void CallURL( )
        {
            Console.WriteLine( "Calling " + this.URL + " with timeout " + this.Timeout );

            Result.Url = URL;
            Result.TimeOut = Timeout;

            try
            {
                //call URL
                HttpWebRequest request = (HttpWebRequest)WebRequest.Create( URL );
                request.Timeout = Timeout;
                request.Proxy = WebRequest.DefaultWebProxy;

                WebResponse wr;

                try
                {
                    wr = request.GetResponse();
                }
                catch(WebException e)
                {
                    wr = e.Response;
                    if (wr == null)
                        throw;
                }

                Result.Response = new Response();
                Result.Response.httpResponseCode = ((HttpWebResponse)wr).StatusCode.ToString();

                Result.Response.HeaderCollection = new HeaderCollection();
                foreach( string key in wr.Headers.AllKeys )
                {
                    Header header = new Header();
                    header.key = key;
                    header.value = wr.Headers[key];
                    
                    Result.Response.HeaderCollection.Add(header);
                }

                // Obtain a 'Stream' object associated with the response object.
                Stream ReceiveStream = wr.GetResponseStream();
                Encoding encode = System.Text.Encoding.GetEncoding("utf-8");

                // Pipe the stream to a higher level stream reader with the required encoding format. 
                StreamReader readStream = new StreamReader( ReceiveStream, encode );

                // end <ResponseText> here... 
                String responseText = readStream.ReadToEnd();
                Result.Response.ResponseText = responseText;
            }
            catch( Exception e )
            {
                Result.Response = new Response();
                Result.Response.httpResponseCode = "Error";
                Result.Response.ResponseText = e.ToString();
                
                string errorText = "<Response httpResponseCode=\"Error\"><ResponseText healthData=\"" + e.ToString() + "\"/>";
                Console.WriteLine( "Request failed with exception:\n{0}", e.ToString() );
            }
        } //call

	} // URLRequestor
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TokenImport\exe\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TokenReplacer\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\titlesuite\systemcheck\XMLUtil.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Xml.Serialization;
using System.Xml;
using System.Xml.Schema;

namespace xonline.tools.toolsuite.systemcheck
{
    class XmlUtil
    {
        #region Core XML Serialization Functions
        /// <summary>
        /// Serialize data into XML
        /// </summary>
        /// <param name="filename">XML file to write data to.</param>
        /// <param name="data">Object to serialize.</param>
        public static void Serialize<T>(TextWriter outstream, T data)
        {
            XmlSerializer serializer;
            XmlWriter writer;
            XmlWriterSettings settings;

            serializer = new XmlSerializer(typeof(T));
            settings = new XmlWriterSettings();
            settings.Indent = true;

            writer = XmlTextWriter.Create(outstream, settings);
            serializer.Serialize(writer, data);
            writer.Close();
        }

        /// <summary>
        /// Deserialize data from XML.
        /// </summary>
        /// <param name="filename">XML File to load data from.</param>
        /// <param name="data">Object to load data into.</param>
        public static void Deserialize<T>(TextReader instream, out T data)
        {
            XmlSerializer serializer;
            XmlReader reader;
            XmlReaderSettings settings;

            serializer = new XmlSerializer(typeof(T));
            settings = new XmlReaderSettings();

            reader = XmlTextReader.Create(instream, settings);
            data = (T)serializer.Deserialize(reader);
            reader.Close();
        }

        /// <summary>
        /// Deserialize data from XML.
        /// </summary>
        /// <param name="filename">XML File to load data from.</param>
        /// <param name="data">Object to load data into.</param>
        public static void Deserialize<T>(TextReader instream, XmlReader xmlSchemaReader, out T data)
        {
            XmlSerializer serializer;
            XmlReader reader;
            XmlReaderSettings settings;

            serializer = new XmlSerializer(typeof(T));
            settings = new XmlReaderSettings();
            settings.ValidationFlags = XmlSchemaValidationFlags.ReportValidationWarnings;
            settings.Schemas.Add(null, xmlSchemaReader);

            reader = XmlTextReader.Create(instream, settings);
            data = (T)serializer.Deserialize(reader);
            reader.Close();
        }

        /// <summary>
        /// Deserialize data from XML.
        /// </summary>
        /// <param name="filename">XML File to load data from.</param>
        /// <param name="data">Object to load data into.</param>
        public static void Deserialize<T>(TextReader instream, String schemaUri, out T data)
        {
            XmlSerializer serializer;
            XmlReader reader;
            XmlReaderSettings settings;

            serializer = new XmlSerializer(typeof(T));
            settings = new XmlReaderSettings();
            settings.ValidationFlags = XmlSchemaValidationFlags.ReportValidationWarnings;
            settings.Schemas.Add(null, schemaUri);

            reader = XmlTextReader.Create(instream, settings);
            data = (T)serializer.Deserialize(reader);
            reader.Close();
        }
        #endregion
        public static void SerializeFile<T>(string filename, T data)
        {
            using (StreamWriter writer = new StreamWriter(filename))
            {
                Serialize(writer, data);
                writer.Close();
            }
        }

        public static void DeserializeFile<T>(string filename, out T data)
        {
            using (StreamReader reader = new StreamReader(filename))
            {
                Deserialize(reader, out data);
                reader.Close();
            }
        }

        public static void SerializeString<T>(out string text, T data)
        {
            StringBuilder builder = new StringBuilder();
            StringWriter writer = new StringWriter(builder);
            Serialize(writer, data);
            writer.Close();
            text = builder.ToString();
        }

        public static void DeserializeString<T>(string text, out T data)
        {
            StringReader reader = new StringReader(text);
            Deserialize(reader, out data);
            reader.Close();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TokenGenTest\TokenGenTest.cs ===
using System;
using System.IO;
using System.IO.Compression;
using System.Security.Cryptography;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.token;
using xonline.common.tools.console;

namespace xonline.tools.TokenGenTest
{
    public class TokenGenTest
    {
        static int Main(string[] rawArgs)
        {
            string[] options =
            {
                "batch",
                "category",
                "categoryid",
                "cleanup",
                "count",
                "pkpn",
                "offer",
                "status",
                "sync",
                "vet",
                "decrypt",
            };

            NamedArgParser args = new NamedArgParser(options);

            if (rawArgs.Length == 0)
            {
                // Print usage
                Console.WriteLine("Token Generation Test Tool.");
                Console.WriteLine("Arguments:");
                Console.WriteLine("/batch:<num>         specify how many tokens will be generated in a batch");
                Console.WriteLine("/category:<string>   specify token category name");
                Console.WriteLine("/categoryid:<guid>   specify token category id");
                Console.WriteLine("/cleanup:<guid>      reset stale job");
                Console.WriteLine("/count:<num>         how many tokens to generate");
                Console.WriteLine("/pkpn:<pkpn>         PKPN to use for token category");
                Console.WriteLine("/offer:<guid>        specify offer id in token category");
                Console.WriteLine("/status:<guid>       check token job status");
                Console.WriteLine("/sync                generate tokens synchronously");
                Console.WriteLine("/vet                 tokens generated will go through the forbidden name list");
                Console.WriteLine("Example:");
                Console.WriteLine("TokenGenTest /category:\"BestBuy Texas Hold'em Full Arcade\" /offer:00000001-0000-4000-8000-0000584107F6 /count:100");
                return 0;
            }

            if ( rawArgs.Length > 0 && !args.Parse(rawArgs) )
            {
                Console.Error.WriteLine("Invalid argument: " + args.InvalidArgText);
                return -1;
            }

            Guid jobId = Guid.NewGuid();

            byte[] key = new byte[16] {0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf};
            byte[] iv = jobId.ToByteArray();
            int kekVersion = -1;
            byte[] cipherText = null;
            TokenCrypto.GetEncryptedTokenFileEncryptionKey(key, iv, out kekVersion, out cipherText);

            //byte[] plainText = TokenCrypto.GetDecryptedTokenKey(cipherText, iv, kekVersion);

            if ( !string.IsNullOrEmpty(args["status"]) )
            {
                jobId = new Guid(args["status"]);
                TokenJobStatusEnum status;
                DateTime lastActivity;
                bool jobIsStale = false;
                int numTokensRequested = -1;
                int numTokensCompleted = -1;
                DateTime submitted;
                int numFailures = -1;
                DateTime nextProcessing;

                TokenJob.GetStatus(jobId, out status, out lastActivity, out jobIsStale, out numTokensRequested, out numTokensCompleted, out submitted, out numFailures, out nextProcessing);
                Console.WriteLine("Job: " + jobId.ToString());
                Console.WriteLine("-------------------------");
                Console.WriteLine("  StatusId: {0}", status.ToString());
                Console.WriteLine("  JobIsStale: {0}", jobIsStale.ToString());
                Console.WriteLine("  Lastactivity: {0}", lastActivity.ToString());
                Console.WriteLine("  NumTokensRequested: {0}", numTokensRequested.ToString());
                Console.WriteLine("  NumTokensCompleted: {0}", numTokensCompleted.ToString());
                Console.WriteLine("  Submitted: {0}", submitted.ToString());
                Console.WriteLine("  NumFailures: {0}", numFailures.ToString());
                Console.WriteLine("  NextProcessing: {0}", nextProcessing.ToString());
                return 0;
            }

            if ( !string.IsNullOrEmpty(args["decrypt"]) )
            {
                jobId = new Guid(args["decrypt"]);
                DecryptTokenFile(jobId, key);
                return 0;
            }

            string tokenCategoryName = "Token Category " + Guid.NewGuid().ToString();
            if ( !string.IsNullOrEmpty(args["category"]) )
            {
                tokenCategoryName = args["category"];
            }

            Guid tokenCategoryId = Guid.Empty;
            if ( !string.IsNullOrEmpty(args["categoryid"]) )
            {
                tokenCategoryId = new Guid(args["categoryid"]);
            }

            string pkpn = "XBX-0123456789";
            if ( !string.IsNullOrEmpty(args["pkpn"]) )
            {
                pkpn = args["pkpn"];
            }

            Guid offerId = Guid.NewGuid();
            if ( !string.IsNullOrEmpty(args["offer"]) )
            {
                offerId = new Guid(args["offer"]);
            }

            bool vetTokens = false;
            if ( args["vet"] != null )
            {
                vetTokens = true;
            }
            Console.WriteLine("vetTokens: {0}", vetTokens);

            bool sync = false;
            if (args["sync"] != null)
            {
                sync = true;
            }
            Console.WriteLine("sync: {0}", sync);

            if ( !string.IsNullOrEmpty(args["cleanup"]) )
            {
                Guid existingJobId = new Guid(args["cleanup"]);
                ResetStaleJob(existingJobId, vetTokens);
                return 0;
            }

            int numTokens = 10;

            if ( !string.IsNullOrEmpty(args["count"]) )
            {
                numTokens = Int32.Parse(args["count"]);
            }
            Console.WriteLine("numTokens: {0,10}", numTokens);

            TokenCategory tc = null;
            if ( tokenCategoryId.Equals(Guid.Empty) )
            {
                try
                {
                    tc = TokenCategory.GetTokenCategory(tokenCategoryName);
                }
                catch (Exception e)
                {
                    HResult hr = XRLException.ToHResult(e, HResult.E_FAIL);

                    if ( hr == HResult.XONLINE_E_TOKEN_NO_CATEGORY_FOUND)
                    {
                        tc = new TokenCategory(Guid.NewGuid(), tokenCategoryName, new DateTime(2999,12,31), offerId, Guid.Empty, 1, false, false, pkpn, 0, false);
                        tc.Configure();
                    }
                    else
                    {
                        throw;
                    }
                }
            }
            else
            {
                tc = TokenCategory.GetTokenCategory(tokenCategoryId);
            }

            TokenJob job = new TokenJob(jobId, tc.Id, tc.Pkpn, numTokens, key);

            job.RecordJobPending();
            Console.WriteLine("Token Job {0} added.", jobId);

            // If synchornized token generation is specified, generate the tokens right away, otherwise, it will be picked up by CRON.
            if (sync)
            {
                XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

                TokenServiceFramework.GenerateTokens(job, vetTokens);

                job.RecordJobDelivered();

                Console.WriteLine("Generated: {0,10} tokens in {1,10} seconds.", numTokens, timeElapsed.SecondsElapsed);
            }
            return 0;
        }

        public static void ResetStaleJob(Guid jobId, bool vetTokens)
        {
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

            TokenJob job = TokenJob.GetPendingJob(jobId);

            // if job is stale, cleanup any completed progress
            if ( job.IsStale )
            {
                job.ResetStaleJob();
            }

            Console.WriteLine("ResetPendingJob: cleanup took {0,10} milliseconds.", timeElapsed.MillisecondsElapsed);

            /*
            // load token category info
            TokenCategory tc = TokenCategory.GetTokenCategory(job.TokenCategoryId);

            timeElapsed = new XomRequestTimeElapsed();

            TokenServiceFramework.GenerateTokens(job, tc, job.NumTokensRequested, vetTokens);

            job.RecordJobDelivered();

            Console.WriteLine("Generated: {0,10} tokens in {1,10} seconds.", job.NumTokensRequested, timeElapsed.SecondsElapsed);
            */
        }

        public static void DecryptTokenFile(Guid jobId, byte[] key)
        {
            string fileName = TokenJob.GetFinalOutputPath(jobId);

            byte[] iv = jobId.ToByteArray();

            using (FileStream inputFile = File.Open(fileName, FileMode.Open, FileAccess.Read, FileShare.None))
            using (CryptoStream cryptoStream = TokenCrypto.GetTokenFileCryptoStream(inputFile, key, iv, CryptoStreamMode.Read))
            using (GZipStream gzipStream = new GZipStream(cryptoStream, CompressionMode.Decompress, false))
            using (StreamReader reader = new StreamReader(gzipStream))
            {
                string line;
                int lineNumber = 0;
                while ((line = reader.ReadLine()) != null)
                {
                    Console.WriteLine(string.Format("{0:d4}: {1}", ++lineNumber, line));
#if false
                    if ( lineNumber >= 999 )
                    {
                        return;
                    }
#endif
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TokenReplacer\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TokenReplacer\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TokenReplacer\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_tokenreplacer_none_12.4.56.0_none_7ade1850609b4162
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_tokenreplacer_no-public-key_12.4.56.0_x-ww_590a6c9a
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=tokenreplacer
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_tokenreplacer_no-public-key_12.4.56.0_x-ww_590a6c9a
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_tokenreplacer_no-public-key_12.4.56.0_x-ww_590a6c9a.manifest
XP_MANIFEST_PATH=manifests\msil_tokenreplacer_no-public-key_12.4.56.0_x-ww_590a6c9a.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_tokenreplacer_no-public-key_12.4.56.0_x-ww_590a6c9a.cat
XP_CATALOG_PATH=manifests\msil_tokenreplacer_no-public-key_12.4.56.0_x-ww_590a6c9a.cat
XP_PAYLOAD_PATH=msil_tokenreplacer_no-public-key_12.4.56.0_x-ww_590a6c9a
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=tokenreplacer,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TournamentUsers\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TokenReplacer\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_tokenreplacer_none_12.4.56.0_none_7ade1850609b4162
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_tokenreplacer_no-public-key_12.4.56.0_x-ww_590a6c9a
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=tokenreplacer
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_tokenreplacer_no-public-key_12.4.56.0_x-ww_590a6c9a
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_tokenreplacer_no-public-key_12.4.56.0_x-ww_590a6c9a.manifest
XP_MANIFEST_PATH=manifests\msil_tokenreplacer_no-public-key_12.4.56.0_x-ww_590a6c9a.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_tokenreplacer_no-public-key_12.4.56.0_x-ww_590a6c9a.cat
XP_CATALOG_PATH=manifests\msil_tokenreplacer_no-public-key_12.4.56.0_x-ww_590a6c9a.cat
XP_PAYLOAD_PATH=msil_tokenreplacer_no-public-key_12.4.56.0_x-ww_590a6c9a
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=tokenreplacer,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TokenReplacer\TokenReplacer.cs ===
using System;
using System.Collections;
using System.Collections.Specialized;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;


using xonline.common.utils;


namespace xonline.tools.TokenReplacer
{

    //ToDos:
    // * Logging
    // * Exception Handling





	/// <summary>
    /// Summary description for TokenReplacer.
	/// </summary>
	public class TokenReplacer
	{
        private static readonly Log _log = Log.GetInstance();


        Regex variableRegex = new Regex(
            @"^(?<name>[^=]+)=(?<value>.*)",
            RegexOptions.Compiled | RegexOptions.IgnoreCase);


        private Hashtable tokenMappings = new Hashtable();
        private string originalFileName, directoryName, outputFileName, partialFileName="";
        private string additionalDataFiles="";

        private bool randomize = false;

        static int Main(string[] rawArgs)
        {
            _log.Verbosity = LogLevel.Verbose;
            _log.OnMessage += loggingEventHandler;

            try
            {
                TokenReplacer replacer = new TokenReplacer();
                if (replacer.ParseCommandLine(rawArgs) < 0)
                    return -1;

                replacer.ShowParameters();
                return replacer.Run();
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.ToString());
                return -1;
            }


        }


        #region Execution

        private int Run()
        {

            if (!String.IsNullOrEmpty(directoryName))
            {
                DirectoryInfo currentDirInfo = new DirectoryInfo(directoryName);
                ReplaceDirectory(currentDirInfo);
            }
            else if ( (!String.IsNullOrEmpty(originalFileName) )
                && (!String.IsNullOrEmpty(outputFileName))
                )
            {
                ReplaceFile(originalFileName, outputFileName, originalFileName);
            }
            else
            {
                throw new ArgumentNullException("Either input or output filename is empty");
            }

            return 0;
        }

        private void ReplaceDirectory(DirectoryInfo currentDirInfo)
        {

            foreach (FileInfo file in currentDirInfo.GetFiles())
            {
                if (ApplyFilter(file.Name))
                {
                    ReplaceFile(file.FullName, file.FullName, currentDirInfo.Name);
                }
            }

            foreach (DirectoryInfo dir in currentDirInfo.GetDirectories() )
            {
                ReplaceDirectory(dir);
            }


        }


        private void ReplaceFile(string currentFileName, string outFileName, string directoryName)
        {
            //Replace the file
            Console.WriteLine("Performing token-replacement on " + currentFileName);
            FileUtils.TokenReplaceFile(tokenMappings, currentFileName, outFileName, randomize, directoryName);
        }


        private bool ApplyFilter(string fileName)
        {
            if (fileName.Contains(partialFileName))
                return true;
            else
                return false;
        }

        private void ShowParameters()
        {
            foreach (string key in tokenMappings.Keys)
            {
                //Console.WriteLine(String.Format("{0} = {1}", de.Key, de.Value));

                string value = (string) tokenMappings[(key)];
                Console.WriteLine(String.Format("{0} = {1}", key, value));
                
            }           
        }

        #endregion Execution



        #region Parameter handling


        private static void VerifyParameter(string currentArg, int currentArgIndex, int numberOfArgs)
        {
            if (currentArgIndex + 1 >= numberOfArgs)
            {
                Console.WriteLine("ERROR: Option " + currentArg + " requires a value to be specified.");
                Console.WriteLine("Type \"TokenReplacer /?\" for usage help.");
                Environment.Exit(1);
            }
        }


        /// <summary>
        /// Handles parsing of the command line arguments, setting member variables 
        /// based on the options and arguments specified.
        /// </summary>
        /// <param name="args">The arguments to process.</param>
        public int ParseCommandLine(string[] args)
        {
            int numberOfArgs = args.Length;
            int returnValue = 0;

            for (int currentArgIndex = 0; currentArgIndex < numberOfArgs; currentArgIndex++)
            {
                string currentArg = args[currentArgIndex];

                if (String.Compare(currentArg, "/inputFile", true) == 0)
                {
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    originalFileName = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/outputFile", true) == 0)
                {
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    outputFileName = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/inputDir", true) == 0)
                {
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    directoryName = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/randomize", true) == 0)
                {
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    randomize = Convert.ToBoolean(args[++currentArgIndex]);
                }
                else if (String.Compare(currentArg, "/tokenFile", true) == 0)
                {
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    additionalDataFiles = args[++currentArgIndex];
                    LoadHashDataFromFile(additionalDataFiles, variableRegex, tokenMappings);
                }
                else if (String.Compare(currentArg, "/fileNameContains", true) == 0)
                {
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    partialFileName = args[++currentArgIndex];
                }
                else if (String.Compare(currentArg, "/key", true) == 0)
                {
                    VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                    string key = Convert.ToString(args[++currentArgIndex]);
                    
                    currentArg = args[++currentArgIndex];
                    if (String.Compare(currentArg, "/value", true) == 0)
                    {
                        VerifyParameter(currentArg, currentArgIndex, numberOfArgs);
                        string value = Convert.ToString(args[++currentArgIndex]);

                        AddTokens(true, key, value);
                    }
                    else
                    {
                        throw new ArgumentNullException("The /key and /value parameters should be next to each other");

                    }

                    

                }

                else if (currentArg == "/?")
                {
                    this.ShowUsageInfo();
                    returnValue = -1;
                }
                else if (currentArg.StartsWith("/"))
                {
                    Console.WriteLine("ERROR: Invalid argument or option - '" + currentArg + "'.");
                    Console.WriteLine("Type \"TokenReplacer /?\" for usage help.");
                    Environment.Exit(1);
                }
                else if (variableRegex.IsMatch(currentArg))
                {
                    AddTokensFromString(currentArg, true);
                }
            }

            //If we dont pass an output file name , use the original file
            if (String.IsNullOrEmpty(outputFileName ))
            {
                outputFileName = originalFileName;
            }

            return returnValue ;
        }

        private void AddTokensFromString(string currentArg, bool overWrite)
        {
            string key, value;

            Match myMatch = variableRegex.Match(currentArg);
            key = myMatch.Groups["name"].Value;
            value = myMatch.Groups["value"].Value;

            AddTokens(overWrite, key, value);
        }

        private void AddTokens(bool overWrite, string key, string value)
        {

            if (tokenMappings.ContainsKey(key))
            {

                if (overWrite)
                {
                    tokenMappings.Remove(key);
                    tokenMappings.Add(key, value);
                }
                else
                    throw new ArgumentException(String.Format(" Key={0} already defined", key));
            }
            else
            {
                tokenMappings.Add(key, value);
            }
        }

        private void LoadHashDataFromFile(string additionalDataFiles, Regex regExp, Hashtable tokenMappings)
        {
            //Load File
            if (!String.IsNullOrEmpty(additionalDataFiles))
            {
                StreamReader sr = new StreamReader(additionalDataFiles);

                while (sr.Peek() >= 0)
                {
                    string line = sr.ReadLine();

                    if (regExp.IsMatch(line))
                    {
                        AddTokensFromString(line, false);
                    }
                    else
                    {
                        ShowUsageInfo();
                        throw new ArgumentException(String.Format(" Incorrect data {0} in token file {1}. Please see help on how to use this option", line, additionalDataFiles));

                    }
                }

             
            }
        }


        /// <summary>
        /// Displays information about this program and its command line agruments. 
        /// </summary>
        public void ShowUsageInfo()
        {
            //                |----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
            Console.WriteLine("TokenReplacer /inputFile file /inputDir directory /outputFile output /tokenFile filename [TOKEN=VALUE ...]");
            Console.WriteLine();
            Console.WriteLine("Description:");
            Console.WriteLine("    Replaces he occurence of the Tokens with the values specified");
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine("Parameter List:");
            Console.WriteLine("    /inputFile                FullPath to the input file for token replacment.");
            Console.WriteLine("    /inputDir                 Token replace all the files in the input directory. ");
            Console.WriteLine("                              All the files will be replaced in place and /outputFile parameter is ignored");
            Console.WriteLine("    /outputFile               FullPath to the token replaced Output file.");
            Console.WriteLine("    /tokenFile                Full path to file containing inital set of tokens in NAME=VALUE format");
            Console.WriteLine("    TOKEN=VALUE               Specifies a token name and its associated value");
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine();
            Console.WriteLine("Examples:");
            Console.WriteLine("    TokenReplacer /inputFile site.xml /outputFile site_new.xml USER=abcd PASSWORD=1234 ");
            Console.WriteLine();
            Console.WriteLine("    TokenReplacer /inputFile site.xml USER=abcd PASSWORD=1234 ");
            Console.WriteLine();
            Console.WriteLine("    TokenReplacer /inputDir c:\\secure USER=abcd PASSWORD=1234 ");
            Console.WriteLine();
            Console.WriteLine("    TokenReplacer /inputFile site.xml /tokenFile values.txt USER=abcd PASSWORD=1234 ");
            Console.WriteLine("                 where values.txt contains the following data :");
            Console.WriteLine("                 SERVER=test-pc");
            Console.WriteLine("                 DOMAIN=redmond");
            Console.WriteLine();
            Console.WriteLine("    TokenReplacer /inputFile site.xml /outputFile site_new.xml /randomize true USER=abcd PASSWORD=1234 ");
            Console.WriteLine();
            Console.WriteLine("    TokenReplacer /inputFile site.xml /outputFile site_new.xml /randomize true /key TextToBeReplaced /value ValueThatReplacesTheText ");
            Console.WriteLine();
            Console.WriteLine();
            //                |----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
        }



        #endregion Parameter handling



        #region Error handling


        /// <summary>
        /// Event handler for Apps Message event which writes the message to the console.
        /// </summary>
        /// <param name="sender">The Step generating the event.</param>
        /// <param name="e">The MessageEventArgs sent by the event.</param>
        public static void loggingEventHandler(object sender, LoggingEventArgs e)
        {
            if (e == null)
                return;

            Console.Write(e.Message);
        }

        #endregion Error handling


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\uimap2bin\exe\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\uimap2bin\exe\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TournamentUsers\main.cs ===
using System;
using System.Web;
using System.Collections;
using System.Configuration;
using System.IO;
using xonline.common.protocol;
using xonline.common.service;

namespace TournamentUsers
{
    //class to retrieve all the tournament users
    class CTournamentUsers
    {
        string m_szWebServiceUrl = "";

        public delegate uint OnDelEnumRow( ulong user, uint rank,  long rating);

        OnDelEnumRow m_CallBack = null;

        public CTournamentUsers(string szWebServiceUrl)
        {
            m_szWebServiceUrl        = szWebServiceUrl;

            XRL.SetTargetUrl((int)XOService.Stats, szWebServiceUrl);
        }

        public void SetEnumCallBack(OnDelEnumRow callback)
        {
            m_CallBack = callback; 
        }
        
        //returns number of lb entries processed - 0 means it is done
        public uint EnumUserInLB(uint nTitleId, uint nLbId, uint nStartIndex, uint nCount, out uint nLbSize)
        {
            uint nRowCount = 0;
            MsgWebEnumLB webEnum = new MsgWebEnumLB();

            webEnum._uiTitleId          = nTitleId;               // Title ID
            webEnum._uiLb               = nLbId;                  // Leaderboard id
            webEnum._ulPivotOrPageStart = nStartIndex;            // if _bIsPivotUser == 0, this is the page start, otherwise this is the pivot user
            webEnum._bIsPivotUser       = 0;                      // Defines if _ulPivotOrPageStart is the page start or the pivot user
            webEnum._uiPageSize         = nCount;                 // Page size

            byte [] arrRequest = new byte[32];
            byte [] arrReply   = null;
                        
            MemoryStream ms = new MemoryStream(arrRequest);
            BinaryWriter bw = new BinaryWriter(ms);
            webEnum.WriteTo(bw);

            XRL.Post(ms.ToArray(), out arrReply);

            nLbSize = 0;
            if (arrReply!= null && arrReply.Length != 0)
            {
                MemoryStream msReply = new MemoryStream(arrReply);
                BinaryReader br = new BinaryReader(msReply);

                RepWebEnumLB webRepEnumLb = new RepWebEnumLB();
                webRepEnumLb.ReadFrom(br);
            
                if (webRepEnumLb != null)
                {
                    nRowCount = webRepEnumLb._uiRepUserCount;
                    nLbSize = webRepEnumLb._uiLbSize;
                    foreach (RepWebEnumLBUser user in webRepEnumLb._users)
                    {
                        if (m_CallBack != null)
                        {
                            m_CallBack(user._ulUser, user._uiRank, user._lRating);
                        }
                    }
                }
            }

            return nRowCount;
        }
    
    }

    public class CSVFileOutput
    {
        StreamWriter m_sw = null;

        public CSVFileOutput(string szFullPath)
        {
            m_sw =  new StreamWriter(szFullPath);
        }

        public void Close()
        {
            if (m_sw != null)
            {
                m_sw.Flush();   
                m_sw.Close();
            }
        }

        public uint OnEnumRow( ulong user, uint rank,  long rating)
        {
            if (m_sw != null)
            {
                m_sw.WriteLine("{0}, {1} , {2}", user, rank, rating);
            }

            return 0;
        }
    }

    /// <summary>
    /// Summary description for Class1.
    /// </summary>
    class CMain
    { 
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main(string[] args)
        {
            bool bLbId      = false;
            bool bTitleId   = false;

            uint nLbId       = 0;
            uint nTitleId    = 0;
            string szCSVFile = "default.csv";
        
            string szWebServiceUrl  = "";
            uint    nThrottleMillis = 1000; // i second for each batch
            uint    nBatchSize      = 1000; // for each batch

            try 
            {
                //first try to load some configuration form the config file
                szWebServiceUrl      = ConfigurationManager.AppSettings.Get("WebServiceUrl");
                nThrottleMillis      = uint.Parse(ConfigurationManager.AppSettings.Get("ThrottleMillis"));
                nBatchSize           = uint.Parse(ConfigurationManager.AppSettings.Get("BatchSize"));
        
                for (int i=0;i<args.Length;i++)
                {
                    if (args[i].ToUpper().Trim() == "-TITLEID")
                    {
                        i = i + 1;
                        nTitleId = uint.Parse(args[i], System.Globalization.NumberStyles.HexNumber);
                        bTitleId = true;
                    }

                    if (args[i].ToUpper().Trim() == "-LBID")
                    {
                        i = i + 1;
                        nLbId = uint.Parse(args[i], System.Globalization.NumberStyles.HexNumber);
                        bLbId = true;
                    }

                    if (args[i].ToUpper().Trim() == "-O")
                    {
                        i = i + 1;
                        szCSVFile = args[i];
                        bLbId = true;
                    }
                }
            }
            catch (Exception e)
            {
                Usage();
                Console.WriteLine(e.Message);
                return;
            }

            if (bLbId == false || bTitleId == false)
            {
                Usage();
                return;
            }

            //
            Console.WriteLine("Web Service Url {0} Batch Size {1} ThrottleInMillis {2}", szWebServiceUrl, nThrottleMillis , nBatchSize );
            Console.WriteLine("Starting to retrieve Users for TitleID {0} LBID {1}", nTitleId, nLbId);
            Console.WriteLine("Output File to be Written at {0}", szCSVFile);

            CSVFileOutput    objFile = new CSVFileOutput(szCSVFile);
            try 
            {
                CTournamentUsers objUsers   = new CTournamentUsers(szWebServiceUrl);

                uint nStartIndex = 1;
                uint nCount      = nBatchSize;
                uint nLbSize     = 0;
                uint nRowCount   = 0;

                objUsers.SetEnumCallBack(new CTournamentUsers.OnDelEnumRow(objFile.OnEnumRow));
            
                while ((nRowCount = objUsers.EnumUserInLB(nTitleId, nLbId, nStartIndex, nCount, out nLbSize)) > 0)
                {
                    nStartIndex = nStartIndex + nRowCount;

                    System.Threading.Thread.Sleep((int)nThrottleMillis);
                }
            }
            catch  (Exception e)
            {
                Console.WriteLine(e.Message);
            }
            finally
            {
                if (objFile !=  null)
                {
                    objFile.Close();
                }
            }

            Console.WriteLine("Programs End");
        }

        static void Usage()
        {
            Console.WriteLine("TournamentUsers.exe -titleID FFFF -lbID FFFF -o File");
            Console.WriteLine("-titleID: Specifies the title ID in Hexadecimal (No 0x in front of the HEX number)");
            Console.WriteLine("-lbID: Specifies the lbID in Hexadecimal (No 0x in front of the HEX number)");
            Console.WriteLine("-o: path of where you want your CSV file to be generated");
            Console.WriteLine("NOTE: YOU ALSO NEED A GOOD CONFIG FILE IN YOUR EXECUTE DIRECTORY");
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TokenImport\TokenImport.cs ===
/*
 * TokenImport.cs
 *
 * Xbox Live Operations / Token Import tool
 *
 * Copyright (c) Microsoft Corporation. All Rights Reserved.
 *
 */

using System;
using System.IO;
using System.Collections;
using System.Text;
using System.Text.RegularExpressions;
using System.Globalization;
using System.Security.Cryptography;
using System.Diagnostics;
using xonline.common.config;
using xonline.common.service;
using xonline.common.tools.console;
using xonline.common.sql.webstore;
//using xonline.tools.framework;
using Microsoft.Webstore.WstClient;

namespace xonline.tools.tokenimport
{
    public struct BillingToken
    {
        public string token;
        public string sequenceNumber;
    }

    public class TokenImportApp
    {
        static private NamedArgParser _args;
        static private SHA1CryptoServiceProvider _sha;
        static private UnicodeEncoding _enc;
        static private EventLog _evtlog;

        static private int _added = 0;
        static private int _updated = 0;

        static private ulong _offerId = 0;
        static private ulong _minseq = 0;
        static private ulong _maxseq = 0;
        static private int _retries = 4;

        static private StreamWriter _swFailedVouchers;

        private const string BAD_COMMAND_STRING = "/import must be specified.";

        /// <summary>
        /// Main entry point for tokenimport.exe.
        /// </summary>
        /// <param name="rawArgs">Arguments.  See Help() method.</param>
        /// <returns>nothing</returns>

        public static void Main(string[] rawArgs)
        {
            if(rawArgs.Length == 0)
            {
                Help();
                return;
            }

            try
            {
                //
                //  Initialization
                //

                _sha = new SHA1CryptoServiceProvider();
                _enc = new UnicodeEncoding();

                _swFailedVouchers = File.CreateText(Path.Combine(System.Environment.CurrentDirectory, "FailedVouchers.txt"));
                _swFailedVouchers.AutoFlush = true;

                Output.WriteAll("\r\nTokenImport run on: " + DateTime.Now.ToString() + "\r\n");

                //
                //  Set up event log source
                //

                if (!EventLog.SourceExists("TokenImport"))
                    EventLog.CreateEventSource("TokenImport", "Application");

                _evtlog = new EventLog("Application", ".", "TokenImport");

                //
                //  Parse arguments
                //

                string[] tags = { "?",                                                                            // help
                                    "import", "disable", "enable", "delete", "view",                                // commands
                                    "file", "offerid", "usecount", "key", "minseq", "maxseq", "summary", "retries", "SCG", "consolever",// options
                                    "keyimport", "hashimport"                                                       // legacy
                                };

                _args = new NamedArgParser(tags);
                if (!_args.Parse(rawArgs))
                {
                    throw new ArgumentException("Invalid command line argument: " + _args.InvalidArgText);
                }

                //
                //  Help?
                //

                if (_args["?"] != null)
                {
                    Help();
                    return;
                }

                //
                // Shared parameters used in many commands.
                //

                // sequence range
                //
                _minseq = UInt64.MinValue;
                if (_args["minseq"] != null)
                {
                    _minseq = UInt64.Parse(_args["minseq"]);
                }

                _maxseq = UInt64.MaxValue;
                if (_args["maxseq"] != null)
                {
                    _maxseq = UInt64.Parse(_args["maxseq"]);
                }

                // retries
                //
                if (_args["retries"] != null)
                {
                    _retries = Int32.Parse(_args["retries"]);

                    if ( _retries <= 0 )
                    {
                        throw new ArgumentException("/retries must be greater than or equal to 1.");
                    }
                }

                //
                // Handle commands.  There should be exactly one command specified.
                //

                if(_args["import"] != null)
                {
                    if( _args["disable"] != null ||
                        _args["enable"]  != null ||
                        _args["delete"]  != null ||
                        _args["view"]    != null ||
                        _args["summary"] != null)
                    {
                        throw new ArgumentException(BAD_COMMAND_STRING);
                    }

                    DoImport();
                }
                else if (_args["view"] != null)
                {
                    if(_args["summary"] != null)
                    {
                        throw new ArgumentException(BAD_COMMAND_STRING);
                    }

                    DoView();
                }
                else if (_args["summary"] != null)
                {
                    DoSummary();
                }
            }
            catch (ArgumentException e)
            {
                Output.WriteAll(e.Message);
                Help();
            }
            catch (Exception e)
            {
                Output.WriteAll("Error!  " + e.ToString());
            }
            finally
            {
                _evtlog.WriteEntry("TokenImport run with command line:\n" + GrabArgList(rawArgs) + "\n" + Output.EventText);
                _evtlog.Dispose();
                _swFailedVouchers.Close();
            }
        }

        /// <summary>
        /// Handle the /import command:
        ///
        /// /import /usecount /offerid /key|/file [ /status:0|1 ]
        ///
        /// </summary>
        private static void DoImport()
        {
            ArrayList tokenList;
            string offerid  = _args["offerid"];

            //  First check for required parameters

            // offerid is required
            if(offerid == null || offerid == string.Empty)
            {
                throw new ArgumentException("Must specify /offerid when updating/adding voucher!");
            }

            // strip off optional hex specifier
            if(offerid.Length == 18 && offerid.ToUpper().Substring(0, 2) == "0X")
                offerid = offerid.Substring(2);

            if(offerid.Length != 16)
            {
                throw new ArgumentException("Invalid offer id.");
            }

            string file = _args["file"];
            if(file == string.Empty)
                throw new ArgumentException("No file specified.");
            Output.WriteAll("Token File: " + file);

            ProcessFile(file, out tokenList);

            // convert all other params from string to correct types
            _offerId = UInt64.Parse(offerid, NumberStyles.HexNumber);

            Output.WriteAll("Offer ID: 0x" + _offerId.ToString("x"));

            // now set each voucher in the list
            Add(tokenList);
        }

        /// <summary>
        /// Handle the /view command:
        ///
        /// /view /key|/file [/minseq] [/maxseq]
        ///
        /// </summary>
        private static void DoView()
        {
#if false
            ArrayList hashList;

            ProcessKeyFileArgs(out hashList);

            View(hashList);
#endif
        }

        /// <summary>
        /// Handle the /summary command:
        ///
        /// /summary
        ///
        /// Get a summary of all vouchers in the system.
        /// </summary>
        private static void DoSummary()
        {
#if false
            ArrayList info;
            Hashtable offers = new Hashtable();

            _voucherFramework.GetVouchersSummary(out info);

            foreach(VoucherInfo v in info)
            {
                string key = "0x" + v._offerID.ToString("x") + "\t" + v._useCount.ToString();
                if (offers.Contains(key))
                {
                    offers[key] = ((int)offers[key]) + v._numVouchers;
                }
                else
                {
                    offers[key] = v._numVouchers;
                }
            }
#endif
            Output.WriteConsole("Count\t\tOfferId\t\t\tUseCount");
            Output.WriteConsole("------------------------------------------------");
#if false
            foreach (DictionaryEntry entry in offers)
            {
                Output.WriteConsole(entry.Value + "\t\t" + entry.Key);
            }
#endif
        }

        /// <summary>
        /// Print out hash or key info for a list of such.
        /// </summary>
        /// <param name="hashList"></param>
        private static void View(ArrayList hashList)
        {
#if false
            foreach(object o in hashList)
            {
                if(o.GetType() == typeof(string))
                {
                    string key = (string)o;
                    Output.WriteConsole("key:  " + key);
                }
                else
                {
                    byte[] hash = (byte[])o;
                    Output.WriteConsole("hash: 0x" + ByteConvert.ToString(hash));
                    ViewHashInfoInDb(hash);
                    Output.WriteConsole(string.Empty);

                    _viewed++;
                }
            }

            if(_viewed == 0)
            {
                Output.WriteAll("Warning: Specified range does not exist in file.");
            }
#endif
        }

        /// <summary>
        /// Insert or update a single voucher hash in the db.
        /// </summary>
        /// <param name="hash">Hash to insert or update.</param>
        private static void Add(BillingToken bt)
        {
            int iRetries;

            for (iRetries = _retries; iRetries > 0; --iRetries)
            {
                try
                {
                    AddUnactivatedBillingToken(_offerId, bt.token, bt.sequenceNumber);
                    _added++;
                    if (_added % 1000 == 0)
                    {
                        Output.WriteConsole("\r\n" + _added + " ");
                    }
                    else if (_added % 100 == 0)
                    {
                        Output.WriteConsole(".");
                    }
                    break;
                }
                catch(XRLException xe)
                {
                    if ( xe.HResult == HResult.XOFF_E_INVALID_OFFER_ID )
                    {
                        _evtlog.WriteEntry("Invalid offer id.", EventLogEntryType.Warning);
                    }
                    throw;
                }
                catch(Exception e)
                {
                    _evtlog.WriteEntry("Try " + iRetries + ":  Failed to load voucher: \"" + bt.token + ", sequence number: " + bt.sequenceNumber + "\".  Error = " + e.Message, EventLogEntryType.Warning);
                    System.Threading.Thread.Sleep(1000 * (2 ^ (4 - iRetries)));
                    continue;
                }
            }

            if(iRetries == 0)
            {
                Output.WriteConsole("\r\nFailed to load voucher: \"" + bt.token + ", sequence number: " + bt.sequenceNumber + "\".  See event log for details.");
                _evtlog.WriteEntry("Failed to load voucher: \"" + bt.token + ", sequence number: " + bt.sequenceNumber + "\".", EventLogEntryType.Error);
                _swFailedVouchers.WriteLine(bt.token);
            }
        }

        /// <summary>
        /// Add a list of hashes/keys.
        /// </summary>
        /// <param name="hashList"></param>
        private static void Add(ArrayList tokenList)
        {
            foreach(BillingToken bt in tokenList)
            {
                Add(bt);
            }

            if(_added == 0 && _updated == 0)
            {
                Output.WriteAll("Warning: No tokens were added.");
            }
        }


        /// <summary>
        /// Process a file and return a list of tokens and sequence numbers (string)
        /// </summary>
        /// <param name="tokenList"></param>
        /// <returns></returns>
        private static void ProcessFile(string file, out ArrayList tokenList)
        {
            tokenList = new ArrayList();
            StreamReader reader;
            string line;
            string token = string.Empty;
            ulong sequenceNumber;

            reader = File.OpenText(file);

            try
            {
                line = reader.ReadLine();

                do
                {
                    line = line.Trim();

                    if (line == string.Empty)
                    {
                        continue;
                    }

                    try
                    {
                        GetTokenAndSequenceNumber(line, out token, out sequenceNumber);

                        // did this line contain a hash?
                        if (token == null)
                        {
                            continue;
                        }

                        // are we before the import window?
                        if (sequenceNumber < _minseq)
                        {
                            continue;
                        }

                        // if we're after the import window, we're done
                        if (sequenceNumber > _maxseq)
                        {
                            break;
                        }
                    }
                    catch(Exception e)
                    {
                        Output.WriteAll(e.Message);
                        continue;
                    }

                    BillingToken bt = new BillingToken();
                    bt.token = token;
                    bt.sequenceNumber = sequenceNumber.ToString();
                    tokenList.Add(bt);
                }
                while ((line = reader.ReadLine()) != null);
            }
            finally
            {
                // close up shop, all done
                reader.Close();
            }
        }

        /// <summary>
        /// Give a line of text, extract the token and sequence number
        /// </summary>
        /// <param name="line">Line of text to parse</param>
        /// <param name="token">Returned token</param>
        /// <param name="sequenceNumber">Returned sequence number</param>
        private static void GetTokenAndSequenceNumber(string line, out string token, out ulong sequenceNumber)
        {
            string[] parts;

            sequenceNumber = 0;
            token = null;

            line = line.Trim();
            if (line == string.Empty)
            {
                return;
            }

            // split out line components
            parts = line.Trim().Split( new char[] {' '} );
            if (parts.Length != 2)
            {
                throw new FormatException("Invalid format for token! ('" + line + "')");
            }

            try
            {
                // token
                token = parts[0];

                // seq num
                sequenceNumber = UInt64.Parse(parts[1]);
            }
            catch (Exception)
            {
                token = null;
                throw;
            }
        }

        private static void VerifyOfferExistence(ulong offerId)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.Partition = WstCommand.AnyPartition;
                ws.StoredProc = "dbo.p_verify_offer_exists";
                ws.AddParameter(ParamType.RETVAL, "@hr", 0);
                ws.AddParameter("@bi_offer_id", offerId);
                uint hr = (uint)ws.GetIntParameter("@hr");
                if (HResult.Failed(hr))
                {
                    string msg = ws.GetCallSignature() + " failed with hr = 0x" + hr.ToString("x");
                    throw new XRLException(hr, XEvent.Id.TOOLS_CODE_174, msg);
                }
            }
        }

        private static void AddUnactivatedBillingToken(ulong offerId, string billingToken, string sequenceNumber)
        {
            //Verify the existence of the Offer before adding the tokens.
            VerifyOfferExistence(offerId);
            //Add the token now
            using (WSClient ws = new WSClient(ConfigUtil.TokendbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                // Data is partitioned by offer id
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(offerId);

                ws.StoredProc = "dbo.p_svc_add_unactivated_token";

                ws.AddParameter(ParamType.RETVAL, "@hr", 0);
                ws.AddParameter("@bi_offer_id", offerId);
                ws.AddParameter("@vc_billing_token", billingToken);
                ws.AddParameter("@vc_sequence_number", sequenceNumber);
                ws.AddParameter("@si_hash_bucket", ws.Partition);
                ws.ExecuteNonQuery();
            }
        }

        /// <summary>
        /// Command line help.
        /// </summary>
        private static void Help()
        {
            Console.WriteLine(@"
TokenImport <options>

    -- OPTIONS --

/import /file /offerid [/minseq] [/maxseq] [/retries]
    Imports key(s)

Parameters:
  /file:<file>            file listing of tokens, each line in the format:
                                   29 character raw token
                                   14 digit sequence number

  /offerid:<offer id>     offer id to associate with the token(s)
  /minseq:<sequence num>  minimum sequence number (inclusive)
  /maxseq:<sequence num>  maximum sequence number (inclusive)

@<response file>              file containing any of the above arguments,
                                    one per line

    -- EXAMPLES --
TokenImport /import /file:tokens.txt /offerid:0xfffe07d18000001a /minseq:01099001200000 /maxseq:01099001209999
");

        }


        /// <summary>
        /// Format command line args for display.
        /// </summary>
        /// <param name="arglist">Arglist passed into TokenImport.</param>
        /// <returns>String containing args for display.</returns>
        private static string GrabArgList(string[] arglist)
        {
            string filearg;
            try
            {
                StringBuilder sb = new StringBuilder();

                foreach(string arg in arglist)
                {

                    if(arg[0] == '@')
                    {
                        StreamReader reader = File.OpenText(arg.Substring(1));
                        filearg = reader.ReadLine();

                        while (filearg != null)
                        {
                            filearg = filearg.Trim();
                            if (filearg != string.Empty)
                                sb.Append(filearg.Trim() + " ");

                            filearg = reader.ReadLine();
                        }
                        reader.Close();

                        return sb.ToString();

                    }
                    else
                    {
                        sb.Append(arg + " ");
                    }
                }

                return sb.ToString();

            }
            catch
            {
                return(String.Join(" ", arglist));
            }
        }
    }

    /// <summary>
    /// Output wrapper class.
    /// </summary>
    public class Output
    {
        private static StringBuilder _evtsb;

        public static string EventText
        {
            get
            {
                return _evtsb.ToString();
            }
        }

        static Output()
        {
            _evtsb = new StringBuilder();
        }

        public static void WriteConsole(string s)
        {
            Console.WriteLine(s);
        }

        public static void WriteEvent(string s)
        {
            _evtsb.Append(s + "\n");
        }

        public static void WriteAll(string s)
        {
            _evtsb.Append(s + "\n");
            Console.WriteLine(s);
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\UodbPuidInit\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\uodbview\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\uimap2bin\UIMap2Bin.cs ===
using System;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Reflection;
using System.Xml;
using System.Xml.Schema;
using System.Xml.Serialization;

using xonline.common.tools.console;
using xonline.common.uimaputil;

namespace xonline.tools.uimap2bin
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	class UIMap2Bin
	{
        static bool validationSuccess = true;

        static XmlReader CreateValidatingReader(string file)
        {
            string schemaPath = Path.Combine(
                Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), 
                "UIMap.xsd");
            if (!File.Exists(schemaPath))
                throw new Exception(string.Format("cannot find UIMap.xsd at {0}", schemaPath));
            
            Console.WriteLine("Validating instance against {0}", schemaPath);

            XmlReaderSettings readerSettings = new XmlReaderSettings();
            readerSettings.Schemas.Add(null, new XmlTextReader(schemaPath));
            readerSettings.ValidationType = ValidationType.Schema;
            //readerSettings.ValidationEventHandler += new ValidationEventHandler(readerSettingsValidationEventHandler);
            
            StreamReader streamReader = new StreamReader(file);
            XmlReader validatingReader = XmlReader.Create(new XmlTextReader(streamReader), readerSettings);

            if (!validationSuccess)
            {
                Console.WriteLine("XML failed to parse");
                validatingReader = null;
            }
            
            return validatingReader;
        }

        static void readerSettingsValidationEventHandler(object sender, ValidationEventArgs e)
        {
            if (e.Severity == XmlSeverityType.Warning)
            {
                Console.Write("WARNING: ");
                Console.WriteLine(e.Message);
            }
            else if (e.Severity == XmlSeverityType.Error)
            {
                Console.Write("ERROR: ");
                Console.WriteLine(e.Message);
                validationSuccess = false;
            }
        }

        static void ValidateUIMapFile(string file, bool skipVet)
        {
            XmlSerializer serializer = new XmlSerializer(typeof(SelectionListInfoArray));
            XmlReader validatingReader = CreateValidatingReader(file);
            SelectionListInfoArray slia = (SelectionListInfoArray) serializer.Deserialize(validatingReader);

            // Init hashtables, validate, etc...
            UIMapManager.PreProcessUIMap(slia, skipVet);

            Console.WriteLine("XML parsed successfully");
        }

        static void ConvertUIMapFile(string file, string prefix, string extension, bool skipVet)
        {
            string output = prefix + "." + extension;

            if (!File.Exists(file))
                throw new Exception(string.Format("cannot find to convert at {0}", file));

            XmlSerializer serializer = new XmlSerializer(typeof(SelectionListInfoArray));
            XmlReader validatingReader = CreateValidatingReader(file);
            SelectionListInfoArray slia = (SelectionListInfoArray) serializer.Deserialize(validatingReader);

            // Init hashtables, validate, etc...
            UIMapManager.PreProcessUIMap(slia, skipVet);

            FileStream fs;
            BigEndianWriter bew;

            // Output the file for each language present
            foreach(LanguageLabels lls in slia.languageLabelsCollection)
            {
                output = prefix + lls.languageType.ToString() + "." + extension;
                
                // new file for this language
                fs = new FileStream(output, FileMode.Create);

                // Create the writer for data.
                bew = new BigEndianWriter(fs);

                UIMapManager.SerializeUIMap(slia, lls.languageType, bew);

                bew.Close();
                fs.Close();
            }
            
            Console.WriteLine("XML converted successfully");
        }

        static void Usage()
        {
            Console.WriteLine("Usage:");
            Console.WriteLine();
            Console.WriteLine("  uimap2bin -action:validate -file:<uimap-file-to-check>");
            Console.WriteLine("  uimap2bin -action:convert -file:<uimap-file-to-conver> -prefix:<output-file-prefix> -extension:<output-file-extension>");
#if DEBUG
#endif
        }

        /// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main(string[] rawArgs)
		{
            NamedArgParser args = new NamedArgParser();
            args.Parse(rawArgs);

            /////////////////
            // Just to give time to attach in the debugger, if you don't have a VC# Project ready-made...
            string sleep = args["sleep"];
            if (sleep != null)
                System.Threading.Thread.Sleep(Convert.ToInt32(sleep));
            /////////////////                     

            string action = args["action"];
            if (action == null)
                action = "";

            bool skipVet = false; 
            string skipVetString = args["skipvet"];
            if (skipVetString != null)
                skipVet = true;

            try
            {
                switch(action.ToLower())
                {
                    case "validate":
                        ValidateUIMapFile(args["file"], skipVet);
                        break;

                    case "convert":
                        ConvertUIMapFile(args["file"], args["prefix"], args["extension"], skipVet);
                        break;

                    default:
                        Usage();
                        break;
                }
            }
            catch (Exception e)
            {
                Console.WriteLine(e.ToString());
                Usage();
            }

            /////////////////
            // Just to give time to view debug output...
            if (sleep != null)
                System.Threading.Thread.Sleep(Convert.ToInt32(sleep));
            /////////////////                     
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\UnProtectData\UnProtectData.cpp ===
// ---------------------------------------------------------------------------------------
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include <stdio.h>
#include <windows.h>
#include <wincrypt.h>
#include <assert.h>
#include "xboxverp.h"

#define ENTROPY_DATA "RandomStuff"
#define ENTROPY_LENGTH 11

int HandleError(char *s);

DATA_BLOB DataEntropy = { ENTROPY_LENGTH, (BYTE*)ENTROPY_DATA };

int __cdecl main(int argc, char* argv[])
{
    DATA_BLOB DataIn;
    DATA_BLOB DataOut;
    LPWSTR pDescStr;
    int byte;
    DWORD dwLength,i;

    if (argc != 2 || (dwLength = strlen(argv[1])) == 0 || dwLength % 2 != 0 )
    {
        printf("Usage: UnProtectData DataToUnProtectInHex\n");
        return(1);
    }

    dwLength /= 2;

    //
    // Modify argv[1] to binary in place
    //
    for( i=0; i < dwLength; ++i )
    {
         sscanf(&(argv[1][i*2]), "%2x", &byte );
         argv[1][i] = (char)byte;
    }

    DataIn.cbData = dwLength;
    DataIn.pbData = (BYTE*)argv[1];
    
    if (CryptUnprotectData(
            &DataIn,
            &pDescStr,
            &DataEntropy,         // Optional entropy
            NULL,                 // Reserved
            NULL,                 // Optional PromptStruct
            CRYPTPROTECT_UI_FORBIDDEN,
            &DataOut))
    {
        printf("The decryption phase worked.\n");
    }
    else
    {
        return HandleError("Decryption error!");
    }

    for( i=0; i < DataOut.cbData; ++i )
    {
        printf( "%02X", DataOut.pbData[i] );
    }
    printf("\n");

    if (pDescStr)
    {
        printf( "Description String is:%ls\n", pDescStr );
    }
    
    LocalFree(pDescStr);
    LocalFree(DataOut.pbData);
    
} // End of main

int HandleError(char *s)
{
    fprintf(stderr,"An error occurred in running the program. \n");
    fprintf(stderr,"%s\n",s);
    fprintf(stderr, "Error number %x.\n", GetLastError());
    fprintf(stderr, "Program terminating. \n");
    return 1;
} // End of HandleError
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\TournamentUsers\xrl.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Net;
using System.Net.Sockets;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using xonline.common.service;

namespace TournamentUsers
{    
    class XRL
    {     
        static IPEndPoint m_localEndPoint    = null;

        static string m_szdestHost;
        static string m_szdestPort;
        static string m_szdestPath;

        static ushort m_nDestPort;

        static IPHostEntry m_hostEntry;
        static IPEndPoint  m_destEndPoint;

        static int m_nServiceId;
            
        static public void SetTargetUrl(int nServiceId, string szUrl)
        {        
            Match match = _urlParser.Match(szUrl);

            if(match.Groups.Count == 0)
            {
                throw new Exception("URL " + szUrl + " is invalid.");
            }

            m_szdestHost = match.Groups["host"].Value;
            m_szdestPort = match.Groups["port"].Value;
            m_szdestPath = match.Groups["path"].Value;     

            m_nDestPort = Convert.ToUInt16(m_szdestPort, 10); //tell me what port

            m_hostEntry    = Dns.GetHostEntry(m_szdestHost);
            m_destEndPoint = new IPEndPoint(m_hostEntry.AddressList[0], m_nDestPort);

            m_nServiceId   = nServiceId;
        }
        

        public static uint Post(
            byte []     request, 
            out  byte[] response)
        {
            Socket xrlSocket            = null;
            response                    = null;
            uint hr                     = 0;
             
            try
            {
                m_localEndPoint = new IPEndPoint(0, 0);
                xrlSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
                xrlSocket.Bind(m_localEndPoint);

                // Build bundled auth header since we are avoiding SGINFO
                string bundledAuthHeader;
                XUIDAndTrust[] xuidAndTrust = new XUIDAndTrust[1];

                xuidAndTrust[0] = new XUIDAndTrust(0, 0, 0.0f);
                
                BundledAuthData bundledAuthData = new BundledAuthData(0 , xuidAndTrust);
                bundledAuthHeader = BundledAuthData.HTTP_HEADER_BUNDLED_AUTH_DATA + ":" + 
                    bundledAuthData.GetBase64EncodedString() + "\r\n";

                // build request header
                string serviceHeader = 
                    "POST "                 +   m_szdestPath      +   " HTTP/1.0\r\n"   + 
                    "User-Agent: "          +   m_nServiceId      +   "/1.0.0\r\n"      +
                    "Content-Type: xon/"    +   m_nServiceId      +   "\r\n"            +
                    bundledAuthHeader       +
                    "Content-Length: "      +   request.Length    +   "\r\n"            +
                    "\r\n";

                // Connect
                xrlSocket.Connect(m_destEndPoint);
 
                // Send request                
                xrlSocket.Send(Encoding.ASCII.GetBytes(serviceHeader));
                xrlSocket.Send(request);

                // Read the response
                int iWrittenResponse = 0;
                int iContentLength = 0;
                string responseHeader = String.Empty;
                byte[] responseBuffer = new Byte[102400];
                
                while(response == null || iWrittenResponse < iContentLength)
                {
                    if(xrlSocket.Poll(100000, SelectMode.SelectRead))
                    {
                        int iReceived = xrlSocket.Receive(responseBuffer);
                        
                        // If response is null, then we're still parsing the http header
                        if(response == null)
                        {
                            // Add recently written buffer to header
                            responseHeader += Encoding.ASCII.GetString(responseBuffer, 0, iReceived);
                            
                            // Did we read the entire header?
                            int endOfHeader = responseHeader.IndexOf("\r\n\r\n");

                            if(endOfHeader == -1)
                                throw new Exception(
                                    "Failed to parse http response header. Can't find CRLF last pairs.");

                            endOfHeader += 4;
                            
                            // Parse the header. First the status.
                            Match match = _regexHTTPStatus.Match(responseHeader);
                            
                            if(! match.Success)
                                throw new Exception("Failed to parse http response header. "+
                                    "Failed part: status. Http header:\n"+responseHeader);

                            int status = Convert.ToInt32((string)match.Groups["status"].Value, 10);
                            
                            // X-Err
                            match = _regexXErr.Match(responseHeader);

                            if(match.Success)
                                hr = HResult.Parse((string)match.Groups["xerr"].Value);

                            if(status != 200 && HResult.Succeeded(hr))
                                hr = HResult.E_FAIL;

                            // Content-lenth
                            match = _regexContentLength.Match(responseHeader);
                            
                            if(match.Success)
                                iContentLength = Convert.ToInt32(match.Groups["len"].Value);
                            else
                                iContentLength = 0;

                            // Allocate response 
                            response = new byte[iContentLength];
                            Array.Copy(responseBuffer, endOfHeader, response, 0, iReceived - endOfHeader);
                            iWrittenResponse = iReceived - endOfHeader;
                        }
                        else
                        {
                            // Copy more of the response
                            Array.Copy(responseBuffer, 0, response, iWrittenResponse, iReceived);
                            iWrittenResponse += iReceived;
                        }
                    }
                }

                xrlSocket.Shutdown(SocketShutdown.Both);
            }
            finally
            {
                if(xrlSocket != null)
                {
                    xrlSocket.Close();
                    xrlSocket = null;
                }
            }

            return hr;
        }

        private static Regex                _urlParser          = new Regex(@"http:\/\/(?<host>[\w-\.]+)(:(?<port>\d+))?(?<path>\/.*)?", RegexOptions.Compiled);
        private static Regex                _regexHTTPStatus    = new Regex(@"HTTP\/(?<httpver>\d+.\d+)\s(?<status>\d+)\s\w+.*", RegexOptions.Compiled | RegexOptions.Singleline | RegexOptions.Multiline);
        private static Regex                _regexXErr          = new Regex(@"^X-Err: (?<xerr>[A-Za-z0-9]+)", RegexOptions.Compiled | RegexOptions.Singleline | RegexOptions.Multiline);
        private static Regex                _regexContentLength = new Regex(@"^Content-Length: (?<len>\d+)", RegexOptions.Compiled | RegexOptions.Singleline | RegexOptions.Multiline);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\usercontent\exe\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\usercontent\exe\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\uodbview\MainForm.Designer.cs ===
namespace uodbview
{
    partial class MainForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.tabControl1 = new System.Windows.Forms.TabControl();
            this.tabPage1 = new System.Windows.Forms.TabPage();
            this.rtbDetails = new System.Windows.Forms.RichTextBox();
            this.label4 = new System.Windows.Forms.Label();
            this.btnSearchGamertag = new System.Windows.Forms.Button();
            this.tbGamertag = new System.Windows.Forms.TextBox();
            this.label3 = new System.Windows.Forms.Label();
            this.btnSearchXboxPuid = new System.Windows.Forms.Button();
            this.tbXboxPuid = new System.Windows.Forms.TextBox();
            this.label2 = new System.Windows.Forms.Label();
            this.lvTransactions = new System.Windows.Forms.ListView();
            this.columnHeader1 = new System.Windows.Forms.ColumnHeader();
            this.columnHeader2 = new System.Windows.Forms.ColumnHeader();
            this.btnRecentTransactions = new System.Windows.Forms.Button();
            this.btnSearchGuid = new System.Windows.Forms.Button();
            this.tbGuid = new System.Windows.Forms.TextBox();
            this.label1 = new System.Windows.Forms.Label();
            this.tabPage2 = new System.Windows.Forms.TabPage();
            this.columnHeader3 = new System.Windows.Forms.ColumnHeader();
            this.columnHeader4 = new System.Windows.Forms.ColumnHeader();
            this.tabControl1.SuspendLayout();
            this.tabPage1.SuspendLayout();
            this.SuspendLayout();
            // 
            // tabControl1
            // 
            this.tabControl1.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                        | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.tabControl1.Controls.Add(this.tabPage1);
            this.tabControl1.Controls.Add(this.tabPage2);
            this.tabControl1.Location = new System.Drawing.Point(12, 12);
            this.tabControl1.Name = "tabControl1";
            this.tabControl1.SelectedIndex = 0;
            this.tabControl1.Size = new System.Drawing.Size(606, 456);
            this.tabControl1.TabIndex = 0;
            // 
            // tabPage1
            // 
            this.tabPage1.Controls.Add(this.rtbDetails);
            this.tabPage1.Controls.Add(this.label4);
            this.tabPage1.Controls.Add(this.btnSearchGamertag);
            this.tabPage1.Controls.Add(this.tbGamertag);
            this.tabPage1.Controls.Add(this.label3);
            this.tabPage1.Controls.Add(this.btnSearchXboxPuid);
            this.tabPage1.Controls.Add(this.tbXboxPuid);
            this.tabPage1.Controls.Add(this.label2);
            this.tabPage1.Controls.Add(this.lvTransactions);
            this.tabPage1.Controls.Add(this.btnRecentTransactions);
            this.tabPage1.Controls.Add(this.btnSearchGuid);
            this.tabPage1.Controls.Add(this.tbGuid);
            this.tabPage1.Controls.Add(this.label1);
            this.tabPage1.Location = new System.Drawing.Point(4, 22);
            this.tabPage1.Name = "tabPage1";
            this.tabPage1.Padding = new System.Windows.Forms.Padding(3);
            this.tabPage1.Size = new System.Drawing.Size(598, 430);
            this.tabPage1.TabIndex = 0;
            this.tabPage1.Text = "MusicNet Purchases";
            this.tabPage1.UseVisualStyleBackColor = true;
            // 
            // rtbDetails
            // 
            this.rtbDetails.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                        | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.rtbDetails.Location = new System.Drawing.Point(10, 276);
            this.rtbDetails.Name = "rtbDetails";
            this.rtbDetails.ReadOnly = true;
            this.rtbDetails.Size = new System.Drawing.Size(582, 148);
            this.rtbDetails.TabIndex = 12;
            this.rtbDetails.Text = "";
            // 
            // label4
            // 
            this.label4.AutoSize = true;
            this.label4.Location = new System.Drawing.Point(7, 62);
            this.label4.Name = "label4";
            this.label4.Size = new System.Drawing.Size(56, 13);
            this.label4.TabIndex = 11;
            this.label4.Text = "Gamertag:";
            // 
            // btnSearchGamertag
            // 
            this.btnSearchGamertag.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
            this.btnSearchGamertag.Location = new System.Drawing.Point(517, 58);
            this.btnSearchGamertag.Name = "btnSearchGamertag";
            this.btnSearchGamertag.Size = new System.Drawing.Size(75, 23);
            this.btnSearchGamertag.TabIndex = 10;
            this.btnSearchGamertag.Text = "Search";
            this.btnSearchGamertag.UseVisualStyleBackColor = true;
            this.btnSearchGamertag.Click += new System.EventHandler(this.btnSearchGamertag_Click);
            // 
            // tbGamertag
            // 
            this.tbGamertag.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.tbGamertag.Location = new System.Drawing.Point(87, 59);
            this.tbGamertag.Name = "tbGamertag";
            this.tbGamertag.Size = new System.Drawing.Size(424, 20);
            this.tbGamertag.TabIndex = 9;
            // 
            // label3
            // 
            this.label3.AutoSize = true;
            this.label3.Location = new System.Drawing.Point(7, 62);
            this.label3.Name = "label3";
            this.label3.Size = new System.Drawing.Size(0, 13);
            this.label3.TabIndex = 8;
            // 
            // btnSearchXboxPuid
            // 
            this.btnSearchXboxPuid.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
            this.btnSearchXboxPuid.Location = new System.Drawing.Point(517, 32);
            this.btnSearchXboxPuid.Name = "btnSearchXboxPuid";
            this.btnSearchXboxPuid.Size = new System.Drawing.Size(75, 23);
            this.btnSearchXboxPuid.TabIndex = 7;
            this.btnSearchXboxPuid.Text = "Search";
            this.btnSearchXboxPuid.UseVisualStyleBackColor = true;
            this.btnSearchXboxPuid.Click += new System.EventHandler(this.btnSearchXboxPuid_Click);
            // 
            // tbXboxPuid
            // 
            this.tbXboxPuid.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.tbXboxPuid.Location = new System.Drawing.Point(87, 33);
            this.tbXboxPuid.Name = "tbXboxPuid";
            this.tbXboxPuid.Size = new System.Drawing.Size(424, 20);
            this.tbXboxPuid.TabIndex = 6;
            // 
            // label2
            // 
            this.label2.AutoSize = true;
            this.label2.Location = new System.Drawing.Point(7, 36);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(63, 13);
            this.label2.TabIndex = 5;
            this.label2.Text = "Xbox PUID:";
            // 
            // lvTransactions
            // 
            this.lvTransactions.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.lvTransactions.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
            this.columnHeader1,
            this.columnHeader3,
            this.columnHeader4,
            this.columnHeader2});
            this.lvTransactions.Location = new System.Drawing.Point(10, 116);
            this.lvTransactions.Name = "lvTransactions";
            this.lvTransactions.Size = new System.Drawing.Size(582, 154);
            this.lvTransactions.TabIndex = 4;
            this.lvTransactions.UseCompatibleStateImageBehavior = false;
            this.lvTransactions.View = System.Windows.Forms.View.Details;
            this.lvTransactions.DoubleClick += new System.EventHandler(this.lvTransactions_DoubleClick);
            // 
            // columnHeader1
            // 
            this.columnHeader1.Text = "GUID";
            this.columnHeader1.Width = 184;
            // 
            // columnHeader2
            // 
            this.columnHeader2.DisplayIndex = 1;
            this.columnHeader2.Text = "Last Change Date";
            this.columnHeader2.Width = 134;
            // 
            // btnRecentTransactions
            // 
            this.btnRecentTransactions.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
            this.btnRecentTransactions.Location = new System.Drawing.Point(473, 87);
            this.btnRecentTransactions.Name = "btnRecentTransactions";
            this.btnRecentTransactions.Size = new System.Drawing.Size(119, 23);
            this.btnRecentTransactions.TabIndex = 3;
            this.btnRecentTransactions.Text = "Recent Transactions";
            this.btnRecentTransactions.UseVisualStyleBackColor = true;
            this.btnRecentTransactions.Click += new System.EventHandler(this.btnRecentTransactions_Click);
            // 
            // btnSearchGuid
            // 
            this.btnSearchGuid.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
            this.btnSearchGuid.Location = new System.Drawing.Point(517, 6);
            this.btnSearchGuid.Name = "btnSearchGuid";
            this.btnSearchGuid.Size = new System.Drawing.Size(75, 23);
            this.btnSearchGuid.TabIndex = 2;
            this.btnSearchGuid.Text = "Search";
            this.btnSearchGuid.UseVisualStyleBackColor = true;
            this.btnSearchGuid.Click += new System.EventHandler(this.btnSearchGuid_Click);
            // 
            // tbGuid
            // 
            this.tbGuid.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.tbGuid.Location = new System.Drawing.Point(87, 7);
            this.tbGuid.Name = "tbGuid";
            this.tbGuid.Size = new System.Drawing.Size(424, 20);
            this.tbGuid.TabIndex = 1;
            // 
            // label1
            // 
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(7, 10);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(34, 13);
            this.label1.TabIndex = 0;
            this.label1.Text = "GUID";
            // 
            // tabPage2
            // 
            this.tabPage2.Location = new System.Drawing.Point(4, 22);
            this.tabPage2.Name = "tabPage2";
            this.tabPage2.Padding = new System.Windows.Forms.Padding(3);
            this.tabPage2.Size = new System.Drawing.Size(598, 430);
            this.tabPage2.TabIndex = 1;
            this.tabPage2.Text = "Offer Purchases";
            this.tabPage2.UseVisualStyleBackColor = true;
            // 
            // columnHeader3
            // 
            this.columnHeader3.DisplayIndex = 2;
            this.columnHeader3.Text = "GamerTag";
            this.columnHeader3.Width = 106;
            // 
            // columnHeader4
            // 
            this.columnHeader4.DisplayIndex = 3;
            this.columnHeader4.Text = "Live PUID";
            this.columnHeader4.Width = 110;
            // 
            // MainForm
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(630, 480);
            this.Controls.Add(this.tabControl1);
            this.Name = "MainForm";
            this.Text = "UODBView";
            this.tabControl1.ResumeLayout(false);
            this.tabPage1.ResumeLayout(false);
            this.tabPage1.PerformLayout();
            this.ResumeLayout(false);

        }

        #endregion

        private System.Windows.Forms.TabControl tabControl1;
        private System.Windows.Forms.TabPage tabPage1;
        private System.Windows.Forms.TabPage tabPage2;
        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.TextBox tbGuid;
        private System.Windows.Forms.ListView lvTransactions;
        private System.Windows.Forms.ColumnHeader columnHeader1;
        private System.Windows.Forms.ColumnHeader columnHeader2;
        private System.Windows.Forms.Button btnRecentTransactions;
        private System.Windows.Forms.Button btnSearchGuid;
        private System.Windows.Forms.Label label4;
        private System.Windows.Forms.Button btnSearchGamertag;
        private System.Windows.Forms.TextBox tbGamertag;
        private System.Windows.Forms.Label label3;
        private System.Windows.Forms.Button btnSearchXboxPuid;
        private System.Windows.Forms.TextBox tbXboxPuid;
        private System.Windows.Forms.Label label2;
        private System.Windows.Forms.RichTextBox rtbDetails;
        private System.Windows.Forms.ColumnHeader columnHeader3;
        private System.Windows.Forms.ColumnHeader columnHeader4;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\UodbPuidInit\uodbpuidinit.cs ===
using System;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;
namespace UodbPuidInit
{
    class UodbPuidInitException : Exception
    {
        public UodbPuidInitException(string m) : base(m) {}
    }
    
    class UodbPuidInit
    {
        public static int Main(string[] args)
        {
            try
            {
                if(args.Length != 1)
                {
                    Console.Write(
                        "Usage: UodbPuidInit <base-puid> \n"+
                        "where <base-puid> is a 64bit number in hexadecimal format "+
                        "with the 0x prefix. Only the most significant WORD can be "+
                        "different from zero. \n"+
                        "E.g.: UodbPuidInit 0x0009000000000000\n");
                    
                    return 1;
                }
                
                string strBasePuid = args[0];
                if(!(new Regex("^0x[0-9A-F]{16,16}$", RegexOptions.IgnoreCase)).Match(strBasePuid).Success)
                    throw new UodbPuidInitException("Invalid parameter");
                    
                UInt64 basePuid = Convert.ToUInt64(strBasePuid.Substring(2), 16);
                
                InitUodbPuid(basePuid);
            }
            catch(UodbPuidInitException e)
            {
                Console.WriteLine("Error: " + e.Message);
            }
            catch(Exception e)
            {
                Console.Write("Unexpected error:\n" + e.ToString());
            }
                
            return 0;            
        }
        
        protected static void InitUodbPuid(UInt64 basePuid)
        {
            if( basePuid == 0 || (basePuid & 0x0000FFFFFFFFFFFF) != 0)
                throw new UodbPuidInitException("Base puid is not valid");
                
            Console.WriteLine("Base Puid = " + basePuid);
                
            WstConnection ws = new WstConnection(xonline.common.config.ConfigUtil.UodbWebstoreApp);
            ws.IntegratedSecurity = true;
            ws.Open();
            if(WSClient.GetPartitionCount(xonline.common.config.ConfigUtil.UodbWebstoreApp) <= 0)
                throw new UodbPuidInitException("Invalid number of logical partitions");
            
            UInt32 cLogPart = (UInt32) WSClient.GetPartitionCount(xonline.common.config.ConfigUtil.UodbWebstoreApp);
            int cPhysPart = ws.SqlPartitions.Count;
            Console.WriteLine("Number of logical partitions = " + cLogPart);
            Console.WriteLine("Number of physical partitions = " + cPhysPart);
            
            UInt64 rangeSize = 0x0000FFFFFFFFFFFFUL / cLogPart;
            Console.WriteLine("Size of each range = " + rangeSize);
            
            // Build one script for each physical partition
            StringBuilder[] partitionScripts = new StringBuilder[cPhysPart];
            for(int part=0; part < partitionScripts.Length; part++)
                partitionScripts[part] = new StringBuilder();
            
            for(UInt32 logPart=0; logPart < cLogPart; logPart++)
            {
                int physPart = ws.GetSqlPartition((int)logPart);
                
                UInt64 nextId = basePuid + (logPart * rangeSize);
                
                partitionScripts[physPart].AppendFormat(
                     "if not exists(select * from dbo.t_puid_idgen where bi_base = 0x{0} and i_row_id = {1}) "
                        +"insert into dbo.t_puid_idgen (bi_base, i_row_id, bi_next_id, bi_range_size) "
                        +"values(0x{0},{1},0x{2},0x{3}) \n",
                    basePuid.ToString("x"), // bi_base
                    logPart.ToString(),        // i_row_id
                    nextId.ToString("x"),   // bi_next_id
                    rangeSize.ToString("x") // bi_range_size
                );
            }
            
            for(int part=0; part < partitionScripts.Length; part++)
            {
                Console.WriteLine("Executing script on physical partition " + part);
                WstCommand cmd = new WstCommand(partitionScripts[part].ToString(), ws);
                cmd.PartitionType = WstPartitionType.Physical;
                cmd.Partition = (int) part;
                cmd.ExecuteScalar();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Utils\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\uodbview\Program.cs ===
using System;
using System.Collections.Generic;
using System.Windows.Forms;

namespace uodbview
{
    static class Program
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new MainForm());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\uodbview\MainForm.cs ===
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Text;
using System.Windows.Forms;

using System.Data.SqlClient;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Net;
using System.Reflection;
using System.Security.Cryptography;
using System.Text.RegularExpressions;
using System.Xml;
using System.Xml.Schema;
using System.Xml.Serialization;

using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.tools.console;
using xonline.common.tools;

namespace uodbview
{
    public partial class MainForm : Form
    {
        private List<DMPTransactionState> m_transactions;
        
        public MainForm()
        {
            InitializeComponent();

            m_transactions = new List<DMPTransactionState>();
        }

        private void btnSearchGuid_Click(object sender, EventArgs e)
        {

        }

        private void btnSearchXboxPuid_Click(object sender, EventArgs e)
        {

        }

        private void btnSearchGamertag_Click(object sender, EventArgs e)
        {

        }

        public class DMPTransactionState
        {
            public string GamerTag;
            public ulong UserPuid;
            public Guid TransactionGuid;
            public DateTime ChangeDateTime;
        }
        
        private void btnRecentTransactions_Click(object sender, EventArgs e)
        {
            m_transactions.Clear();

            using (WstConnection c = new WstConnection(ConfigUtil.GetUserCommerceWebstoreApp()))
            {
                c.Open();

                using (WstCommand cmd = c.CreateCommand())
                {
                    int rowsPerPartition = 50 / c.SqlPartitions.Count;
                    
                    cmd.CommandType = CommandType.Text;
                    cmd.CommandText = string.Format(
                        "select top {0} t.uid_tracking_guid, t.bi_user_puid, t.dt_change_datetime, u.vc_gamertag from t_dmp_purchase_transactions t inner join t_users u on u.bi_user_puid = t.bi_user_puid",
                        rowsPerPartition
                        );

                    for (int i = 0; i < c.SqlPartitions.Count; i++)
                    {
                        cmd.Partition = i;

                        using (WstDataReader r = cmd.ExecuteReader())
                        {
                            DMPTransactionState state = new DMPTransactionState();
                            
                            while (r.Read())
                            {
                                state.TransactionGuid = r.GetGuid(0);
                                state.UserPuid = (ulong) r.GetInt64(1);
                                state.ChangeDateTime = r.GetDateTime(2);
                                state.GamerTag = r.GetString(3);

                                m_transactions.Add(state);
                            }
                        }
                    }
                }
            }

            m_transactions.Sort(new SortTransactionsByChangeDateTime());

            lvTransactions.Items.Clear();
            foreach (DMPTransactionState s in m_transactions)
            {
                ListViewItem item = new ListViewItem(s.TransactionGuid.ToString());
                item.SubItems.Add(s.UserPuid.ToString("d"));
                item.SubItems.Add(s.ChangeDateTime.ToString());
                item.SubItems.Add(s.GamerTag);                                
                
                lvTransactions.Items.Add(item);
            }
        }

        public class SortTransactionsByChangeDateTime : IComparer<DMPTransactionState>
        {
            int IComparer<DMPTransactionState>.Compare(DMPTransactionState s1, DMPTransactionState s2)
            {
                if (s1.ChangeDateTime < s2.ChangeDateTime)
                    return -1;
                else if (s1.ChangeDateTime > s2.ChangeDateTime)
                    return 1;
                else
                    return 0;
            }
        }
        
        public class SortTransactionsByUserPuid : IComparer<DMPTransactionState>
        {
            int IComparer<DMPTransactionState>.Compare(DMPTransactionState s1, DMPTransactionState s2)
            {
                if (s1.UserPuid < s2.UserPuid)
                    return -1;
                else if (s1.UserPuid > s2.UserPuid)
                    return 1;
                else
                    return 0;
            }
        }
        
        public class SortTransactionsByGamertag : IComparer<DMPTransactionState>
        {
            int IComparer<DMPTransactionState>.Compare(DMPTransactionState s1, DMPTransactionState s2)
            {
                return (new System.Collections.CaseInsensitiveComparer()).Compare(
                    s1.GamerTag, s2.GamerTag);
            }
        }
        
        public class SortTransactionsByTransactionGuid : IComparer<DMPTransactionState>
        {
            int IComparer<DMPTransactionState>.Compare(DMPTransactionState s1, DMPTransactionState s2)
            {
                return (new System.Collections.CaseInsensitiveComparer()).Compare(
                    s1.TransactionGuid.ToString(), s2.TransactionGuid.ToString());
            }
        }
        
        private void lvTransactions_DoubleClick(object sender, EventArgs e)
        {

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Utils\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Utils\ServerUtils.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Net;
using System.Net.Sockets;
using System.Text.RegularExpressions;
using System.Collections;
using System.IO;
using System.Net.NetworkInformation;


namespace xonline.common.utils
{
    public class ServerUtils
    {
        /// <summary>
        /// Sets/Gets the specified EnvironmentVariable
        /// </summary>
        /// <param name="action"></param>
        /// <param name="name"></param>
        /// <param name="val"></param>
        /// <returns></returns>
        public static string EnvironmentVariable(string action, string name, string val)
        {
            string returnValue = val;

            Console.WriteLine("Action : {0} , Name={1}, Value={2} ", action, name, val);

            if (action.ToUpper()=="GET")
                returnValue = Environment.GetEnvironmentVariable(name);

            if (action.ToUpper() == "SET")
                Environment.SetEnvironmentVariable(name, val);

            Console.WriteLine("\t NewValue= {0}", returnValue);

            return returnValue;
        }



        /// <summary>
        /// Gets Server IP information
        /// </summary>
        /// <param name="serverName"></param>
        /// <returns></returns>
        public static string GetServerNetworkInformation(string serverName, StreamWriter sw)
        {
            IPAddress[] addresses;
            string returnString = "";

            //Set Server information
            if (String.IsNullOrEmpty(serverName))
            {
                serverName = Dns.GetHostName();
                Console.WriteLine("Using current host: " + serverName);
            }


            //Get the IPAddress info
            try
            {

                {

                    //Get the IPv4 addresses of the server specified
                    addresses = GetIPAddresses(serverName, AddressFamily.InterNetwork);

                    //Set the output
                    if (addresses.Length >= 1)
                    {
                        sw.WriteLine("#SERVER_IP#={0}", addresses[0].ToString());
                        sw.WriteLine("#XBLOB_IP#={0}", addresses[0].ToString());
                    }


                    //Get the current servers N/W interface info
                    NetworkInterface[] adapters = NetworkInterface.GetAllNetworkInterfaces();

                    int i = 0;
                    foreach (NetworkInterface adapter in adapters)
                    {
                        i++;

                        //ToDO: CHeck to see we dont use the loopback interface
                        if (i == 1)
                        {

                            string desc = adapter.Description;
                            string macAddress = adapter.GetPhysicalAddress().ToString();
                            string gateway = "";
                            string subNetMask = "255.255.255.255";

                            IPInterfaceProperties properties = adapter.GetIPProperties();

                            if (properties.GatewayAddresses.Count >= 1)
                            {
                                gateway = properties.GatewayAddresses[0].Address.ToString();
                            }

                            sw.WriteLine("#XBLOB_MAC#={0}", macAddress);
                            sw.WriteLine("#XBLOB_GATEWAY#={0}", gateway);
                            sw.WriteLine("#XBLOB_NETMASK#={0}", subNetMask);
                        }
                    }


                }

            }
            catch (Exception e)
            {
                throw new ArgumentException(String.Format("Unable to get IPAddress information for server : {0}", serverName)
                                            , e);
            }

            return returnString;

        }



        //The IPAddresses method obtains the selected server's IP address information based on the AddressFamily specified.
        private static IPAddress[] GetIPAddresses(string serverName, AddressFamily family)
        {
            List<IPAddress> addresses = new List<IPAddress>();

            try
            {
                System.Text.ASCIIEncoding ASCII = new System.Text.ASCIIEncoding();

                // Get server related information.
                IPHostEntry heserver = Dns.GetHostEntry(serverName);
                    

                // Loop on the AddressList
                foreach (IPAddress curAdd in heserver.AddressList)
                {
                    if (curAdd.AddressFamily == family)
                    {
                        addresses.Add(curAdd);
                    }
                }

            }
            catch 
            {
                throw;
            }

            return addresses.ToArray();
        }

    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Utils\Log.cs ===
/*******************************************************************
 *    FILE:         Log.cs
 *
 *    DESCRIPTION:  
 *
 *    OWNER:        gamagev
 *
 *    HISTORY:      04/08/2004      gamagev    Created
 *
 *    Copyright <cp> 2004 Microsoft Corporation.  All Rights Reserved.
 ********************************************************************
 */
using System;
using System.Text;

namespace xonline.common.utils
{
    public enum LogLevel
    {
        Error = 0,
        Warning = 1,
        Info = 2,
        Verbose = 3
    }

    /// <summary>
    /// Summary description for Log.
    /// </summary>
    public sealed class Log
    {
        private LogLevel _verbosity = LogLevel.Error;

        Log() 
        {
        }

        /// <summary>
        /// Need to make sure we have closed our file when we are finilized
        /// </summary>
        ~Log()
        {
        }

        public event EventHandler<LoggingEventArgs> OnMessage;

        public LogLevel Verbosity
        {
            get { return _verbosity; }
            set { _verbosity = value; }
        }

        /// <summary>
        /// Contains the static instance of us. This way is both 
        /// thread safe and lazy load.
        /// </summary>
        class InternalLogClass
        {
            InternalLogClass()
            {
            }

            internal static readonly Log instance = new Log();    
        }
        
        /// <summary>
        /// We are a singelton so this is the only way to get 
        /// an instance
        /// </summary>
        /// <returns>The singelton Log object</returns>
        public static Log GetInstance()
        {
            return InternalLogClass.instance;
        }

        public void Message(LogLevel level, string message)
        {
            if (_verbosity >= level)
            {
                OnMessage(this, new LoggingEventArgs(level, message));
            }
        }
        public void Message(LogLevel level, string message, params Object[] args)
        {
            StringBuilder msg = new StringBuilder();
            msg.AppendFormat(message, args);

            Message(level, msg.ToString());        
        }

        public void WriteLine(string message)
        {
            Message(LogLevel.Verbose, message + "\r\n");           
        }

        public void WriteLine(string message, params Object[] args)
        {
            StringBuilder msg = new StringBuilder();
            msg.AppendFormat(message, args);

            WriteLine(msg.ToString());        
        }

        public void Write(string message)
        {
            Message(LogLevel.Verbose, message);
        }

        public void Write(string message, params Object[] args)
        {
            StringBuilder msg = new StringBuilder();
            msg.AppendFormat(message, args);

            Write(msg.ToString());        
        }
       

        public void Error(string message, params Object[] args)
        {
            StringBuilder msg = new StringBuilder();
            msg.AppendFormat(message, args);

            Error(msg.ToString());        
        }

        public void Error(string errorMessage)
        {
            Message(LogLevel.Error, errorMessage);
        }

        //public void Error(bool color, string errorMessage)
        //{
        //    if (color)
        //        ConsoleColor.SetForeGroundColor(ConsoleColor.ForeGroundColor.Red, true);

        //    Console.WriteLine(errorMessage);
        //    if (logStream != null)
        //        logStream.WriteLine(errorMessage);
 
        //    if (color)
        //        ConsoleColor.SetToDefaultForeGroundColor();
        //}

        //public void xmlValidationError(string errorMessage)
        //{
        //    ConsoleColor.SetForeGroundColor(ConsoleColor.ForeGroundColor.Red, true);
            
        //    Console.WriteLine("\nXML Validation Error");
        //    if (logStream != null)
        //        logStream.WriteLine("\nXML Validation Error");
            
        //    ConsoleColor.SetToDefaultForeGroundColor();
            
        //    Console.WriteLine("\nDetail: \n\t" + errorMessage);
        //    if (logStream != null)
        //        logStream.WriteLine("\nDetail: \n\t" + errorMessage);
        //}


    }

    /// <summary>
    /// 
    /// </summary>
    public class LoggingEventArgs : EventArgs
    {
        private readonly string _message;
        private readonly LogLevel _level;

        /// <summary>
        /// 
        /// </summary>
        /// <param name="level">
        /// </param>
        /// <param name="message"></param>
        public LoggingEventArgs(LogLevel level, string message)
        {
            _level = level;
            _message = message;
        }

        /// <summary>
        /// 
        /// </summary>
        public string Message
        {
            get { return _message; }
        }

        public LogLevel Level
        {
            get { return _level; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Utils\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\VoucherMgr\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\usercontent\usercontent.cs ===
﻿using System;
using System.Collections;
using System.IO;
using System.Text;
using System.Globalization;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.tools.console;
using xonline.common.user;

using xonline.tools.framework;

namespace xonline.common.tools
{
    class UserContentTool
    {
        
        const string DEFAULT_MOTTO = "Code of Conduct";  //task: will need to add localized strings

        static void Usage()
        {
            Console.WriteLine( "" );
            Console.WriteLine( "Tool to take down offensive user content " );
            Console.WriteLine( "" );
            Console.WriteLine( "Usage:" );
            Console.WriteLine( "    USERCONTENT /gamercard (/puid:<puid> | /gamertag:<gamertag>) [/bio<:\"NewBio\">] [/location<:\"NewLocation\">] [/motto<:\"NewMotto\">] [/name<:\"NewName\">]");
            Console.WriteLine( "" );
            Console.WriteLine( "Definitions:" );
            Console.WriteLine( "    <puid>        - Unique Xbox Live PUID for the desired user (in decimal)" );
            Console.WriteLine( "    <gamertag>    - Unique Xbox Live gamertag for the desired user" );
            Console.WriteLine("     <bio>         - Optional. If supplied user's bio will be changed to this text");
            Console.WriteLine("     <location>    - Optional. If supplied user's location will be changed to this text");
            Console.WriteLine("     <motto>       - Optional. If supplied user's motto will be changed to this text");
            Console.WriteLine("     <name>        - Optional. If supplied user's name will be changed to this text");
            Console.WriteLine("");
            Console.WriteLine( "Examples:" );
            Console.WriteLine( "    Changing a user's gamercard motto using puid, supplying a motto " );
            Console.WriteLine( "    usercontent /gamercard /puid:27517529866 /motto:\"New Motto For You!\" " );
            Console.WriteLine( "" );
            Console.WriteLine("    Changing a user's gamercard using gamertag, clear their motto");
            Console.WriteLine("    usercontent /gamercard /gamertag:ImaNotE1 /motto");
            Console.WriteLine("");
            Console.WriteLine("    Changing a user's gamercard using gamertag, set name and location");
            Console.WriteLine("    usercontent /gamercard /gamertag:ImaNotE1 /name:\"Bob\" /location:\"Redmond\"");
            Console.WriteLine("");
            Console.WriteLine("    Changing a user's gamercard using puid, clear their bio");
            Console.WriteLine("    usercontent /gamercard /puid:314159265396 /bio");
        }

        //task: fix this to use globalization resources instead of having it in code... 
        public static string GetLocalizedMotto( int countryID )
        {
            //21 characters are allowed for gamercard motto
            //up to 1000 bytes in the db
            string codeOfConductString = "";

            switch ( countryID )
            {
                case 5: //austria
                    codeOfConductString = "Verhaltensregeln";
                    break; 
                case 6: //australia
                    codeOfConductString = "Code of Conduct";
                    break;
                case 8: //belgium
                    codeOfConductString = "Gedragscode voor";
                    break;
                case 16: //canada
                    codeOfConductString = "Code of Conduct";
                    break;
                case 18: //switzerland
                    codeOfConductString = "Verhaltensregeln";
                    break;
                case 24: //germany
                    codeOfConductString = "Verhaltensregeln";
                    break;
                case 25: //denmark
                    codeOfConductString = "Adfærdskodeks";
                    break;
                case 31: //spain
                    codeOfConductString = "Código de conducta";
                    break;
                case 32: //finnish
                    codeOfConductString = "käyttäytymissäännöt";
                    break;
                case 34: //france
                    codeOfConductString = "Code de conduite";
                    break;
                case 35: //great britain
                    codeOfConductString = "Code of Conduct";
                    break;
                case 39: //hong kong sar
                    codeOfConductString = "管理辦法";
                    break;
                case 44: //ireland
                    codeOfConductString = "Code of Conduct";
                    break;
                case 50: //italy
                    codeOfConductString = "Codice di condotta";
                    break;
                case 53: //japan
                    codeOfConductString = "「マナーについて」";
                    break;
                case 56: //korea
                    codeOfConductString = "사용 규정";
                    break;
                case 71: //mexico
                    codeOfConductString = "Código de conducta";
                    break;
                case 74: //netherlands
                    codeOfConductString = "Gedragscode voor";
                    break;
                case 75: //norway
                    codeOfConductString = "spilleregler";
                    break;                
                case 76: //new zealand
                    codeOfConductString = "Code of Conduct";
                    break;
                case 90: //swedish
                    codeOfConductString = "Förhållningsregler";
                    break;
                case 91: //singapore
                    codeOfConductString = "Code of Conduct";
                    break;
                case 101: //taiwan
                    codeOfConductString = "管理辦法";
                    break;
                case 103: //usa
                    codeOfConductString = "Code of Conduct";
                    break;
                default:
                    codeOfConductString = "Code of Conduct";
                    break;
            }

            return codeOfConductString;
        }


        //task: once there's more than one enforcement action in this tool,
        //      consider putting this and other functions into a separate class...
        public static void ChangeUserSetting(User user, uint settingId, string settingValue)
        {

            DateTime profileDate = System.DateTime.Today.AddMinutes(-5); //this will be before *now*

            using (WstConnection wsConn = new WstConnection(ConfigUtil.UodbWebstoreApp))
            {

                //exceptions get handled higher up
                wsConn.Open();
                WstCommand wsCmd = wsConn.CreateCommand();
                wsCmd.CommandType = CommandType.StoredProcedure;
                wsCmd.WstFailoverMode = WstFailoverMode.PrimaryThenSecondary;
                wsCmd.Partition = WSClient.GetHashPartition(user.Puid, ConfigUtil.UodbWebstoreApp);
                wsCmd.CommandText = "p_stats_sync_user_settings";

                wsCmd.Parameters.Add("@bi_user_puid", SqlDbType.BigInt).Value = user.Puid;
                wsCmd.Parameters["@bi_user_puid"].Direction = ParameterDirection.Input;

                wsCmd.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)-129071; // = 0xFFFE07D1 = XOn.XENON_DASH_TITLE_ID
                wsCmd.Parameters["@i_title_id"].Direction = ParameterDirection.Input;

                wsCmd.Parameters.Add("@si_hash_bucket", SqlDbType.Int).Value = wsCmd.Partition;
                wsCmd.Parameters["@si_hash_bucket"].Direction = ParameterDirection.Input;

                wsCmd.Parameters.Add("@dt_client_version", SqlDbType.DateTime).Value = profileDate;
                wsCmd.Parameters["@dt_client_version"].Direction = ParameterDirection.Input;

                wsCmd.Parameters.Add("@i_title_id0", SqlDbType.Int).Value = (int)-129071; // = 0xFFFE07D1 = XOn.XENON_DASH_TITLE_ID
                wsCmd.Parameters["@i_title_id0"].Direction = ParameterDirection.Input;

                wsCmd.Parameters.Add("@i_setting_id0", SqlDbType.Int).Value = settingId;
                wsCmd.Parameters["@i_setting_id0"].Direction = ParameterDirection.Input;

                //length in definition of t_user_settings is 1000 bytes
                byte[] unicodeBytes = Encoding.Unicode.GetBytes(settingValue);
                //.Net initializes the extra 2 characters as 00, so that we have a properly 
                // null terminated Unicode-ish string.  That is, ending in 0000.
                wsCmd.Parameters.Add("@vb_value0", SqlDbType.Binary, unicodeBytes.Length).Value = unicodeBytes;
                wsCmd.Parameters["@vb_value0"].Direction = ParameterDirection.Input;

                WstDataReader wr = wsCmd.ExecuteReader();

                if (!wr.Read())
                {
                    throw new XRLException(HResult.XONLINE_E_DATABASE_RESULT_ERROR, XEvent.Id.TOOLS_CODE_175, "Unexpected recordset from p_stats_sync_user_settings! " +
                        "Recieved no results. GamerCard name might not have been changed.");
                }

                //task: output user settings to confirm the setting has been changed?

            } //using

        } //change user setting

        public static void ChangeUserLocation(User user, string settingValue)
        {
            ChangeUserSetting(user, ProfileDefs.XPROFILE_GAMERCARD_USER_LOCATION, settingValue);
            Console.Out.WriteLine(string.Format("Gamercard Location was changed to '{0}'", settingValue));
        }

        public static void ChangeUserMotto(User user, string settingValue)
        {
            ChangeUserSetting(user, ProfileDefs.XPROFILE_GAMERCARD_MOTTO, settingValue);
            Console.Out.WriteLine(string.Format("Gamercard Motto was changed to '{0}'", settingValue));
        }

        public static void ChangeUserName(User user, string settingValue)
        {
            ChangeUserSetting(user, ProfileDefs.XPROFILE_GAMERCARD_USER_NAME, settingValue);
            Console.Out.WriteLine(string.Format("Gamercard Name was changed to '{0}'", settingValue));
        }

        public static void ChangeUserBio(User user, string settingValue)
        {
            ChangeUserSetting(user, ProfileDefs.XPROFILE_GAMERCARD_USER_BIO, settingValue);
            Console.Out.WriteLine(string.Format("Gamercard Bio was changed to '{0}'", settingValue));
        }




        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static int Main( string[] args )
        {
            try
            {
                string [] rgstrCmdLineTags = 
                {
                    "?", 
                    "gamercard",        // command
                    "puid",             // user PUID
                    "gamertag",         // user gamertag
                    "motto",            // new motto 
                    "location",         // new location
                    "name",             // new name
                    "bio"               // new bio
                };
                
                NamedArgParser ArgParser = new NamedArgParser( rgstrCmdLineTags );

                // Parse any command line arguments
                if ( !ArgParser.Parse( args ) )
                {
                    Usage();
                    return -1;
                }

                // Did the user request usage information?            
                if ( 0 == ArgParser.Count ||
                    null != ArgParser[ "?" ] )
                {
                    Usage();
                    return 0;
                }

                // Did the user ask us to do something?
                if( null == ArgParser[ "gamercard" ] 
                    )
                {
                    // user didn't supply a known command
                    Usage();
                    Console.WriteLine( "" );
                    Console.WriteLine( "Error: a command must be supplied." );
                    return -1;
                }

                else if (ArgParser["gamercard" ] != null) {

                    User uctUser = new User();
                    uint hresult = 0;

                    try {
                        if (ArgParser["puid"] != null) {
                            // throws an exception if user isn't found
                            uctUser.Load(System.Convert.ToUInt64(ArgParser["puid"]));                                         
                        }

                        else if (ArgParser["gamertag"] != null) {
                            hresult = uctUser.LoadFromGamerTag( ArgParser["gamertag"]);

                            if (HResult.Failed( hresult)) {
                                throw new Exception( String.Format( "Error: Couldn't find user by Gamertag '{0}'", ArgParser[ "gamertag" ] ) );
                            }
                        }

                        else {
                            throw new Exception("User puid or gameter tag not specified");
                        }
                    }
                    catch ( Exception e )
                    {
                        Console.WriteLine( "" );
                        Console.WriteLine( "Error: Couldn't find user. " );
                        Console.WriteLine( "" );

                        // have to have one of these, or we wouldn't have called 
                        if ( null != ArgParser[ "puid" ] )
                        {
                            Console.WriteLine( "--> An incorrect PUID ('{0}') is one cause of this error.", ArgParser[ "puid" ] );
                        }
                        else if ( null != ArgParser[ "gamertag" ] )
                        {
                            Console.WriteLine( "--> An incorrect gamertag ('{0}') is one cause of this error.", ArgParser[ "gamertag" ] );
                        }
                        Console.WriteLine( "" );                   
                        Console.WriteLine( "Exception text is: \r\n" + e.Message.ToString() );
                        Console.WriteLine( "" );
                        Console.WriteLine( "Exception stack was: \r\n" + e.StackTrace );
                        return -1;
                    }

                    Console.WriteLine( "User puid is: " + uctUser.Puid.ToString() );

                    try  {
                        if (ArgParser["location"] != null) {
                            ChangeUserLocation(uctUser,ArgParser["location"]);
                        }

                        if (ArgParser["motto"] != null) {
                            ChangeUserMotto(uctUser,ArgParser["motto"]);
                        }

                        if (ArgParser["name"] != null) {
                            ChangeUserName(uctUser,ArgParser["name"]);
                        }

                        if (ArgParser["bio"] != null) {
                            ChangeUserBio(uctUser,ArgParser["bio"]);
                        }
                    }

                    catch (Exception e) {
                        Console.Out.WriteLine("Error changing user setting.");
                        Console.Out.WriteLine(e.ToString());

                        return -1;
                    }
                } // gamercard user content action

            } //outermost try
            catch ( Exception e )
            {
                Console.WriteLine( "An unexpected error occurred during processing." );
                Console.WriteLine( "" );                   
                Console.WriteLine( "Exception text is: \r\n" + e.Message.ToString() );
                Console.WriteLine( "" );
                Console.WriteLine( "Exception stack was: \r\n" + e.StackTrace );
                return -1;
            }

            return 0;

        }  // main

    } // user content tool

} //xonline.common.tools
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Utils\XmlUtility.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Xml.Serialization;
using System.IO;

namespace Utils
{
    public class XmlUtility
    {


        public static string SerializeObject<T>(T obj)
        {
            return SerializeObject<T>(obj, String.Empty);
        }

        public static string SerializeObject<T>(T obj , string nameSpace  )
        {
            XmlSerializer serializer;

            StringBuilder sb = new StringBuilder();
            StringWriter writer = new StringWriter(sb);

            if (String.IsNullOrEmpty(nameSpace))
            {
                serializer = new XmlSerializer(typeof(T));
            } 
            else {
                serializer = new XmlSerializer(typeof(T), nameSpace);
            }

            serializer.Serialize(writer, obj);
            writer.Close();

            return sb.ToString();
        }



        public static T DeserializeObject<T>(string str)
        {
            return DeserializeObject<T>(str, String.Empty);
        }

        public static T DeserializeObject<T>(string str, string nameSpace)
        {
            XmlSerializer serializer;

            StringReader reader = new StringReader(str);

            if (String.IsNullOrEmpty(nameSpace))
            {
                serializer = new XmlSerializer(typeof(T));
            } 
            else {
                serializer = new XmlSerializer(typeof(T), nameSpace);
            }
            
            return (T)serializer.Deserialize(reader);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Utils\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_utils_none_12.4.56.0_none_f388627b9401233c
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_utils_no-public-key_12.4.56.0_x-ww_2c60e694
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=utils
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_utils_no-public-key_12.4.56.0_x-ww_2c60e694
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_utils_no-public-key_12.4.56.0_x-ww_2c60e694.manifest
XP_MANIFEST_PATH=manifests\msil_utils_no-public-key_12.4.56.0_x-ww_2c60e694.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_utils_no-public-key_12.4.56.0_x-ww_2c60e694.cat
XP_CATALOG_PATH=manifests\msil_utils_no-public-key_12.4.56.0_x-ww_2c60e694.cat
XP_PAYLOAD_PATH=msil_utils_no-public-key_12.4.56.0_x-ww_2c60e694
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=utils,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\VoucherMgr\exe\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Utils\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_utils_none_12.4.56.0_none_f388627b9401233c
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_utils_no-public-key_12.4.56.0_x-ww_2c60e694
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=utils
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_utils_no-public-key_12.4.56.0_x-ww_2c60e694
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_utils_no-public-key_12.4.56.0_x-ww_2c60e694.manifest
XP_MANIFEST_PATH=manifests\msil_utils_no-public-key_12.4.56.0_x-ww_2c60e694.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_utils_no-public-key_12.4.56.0_x-ww_2c60e694.cat
XP_CATALOG_PATH=manifests\msil_utils_no-public-key_12.4.56.0_x-ww_2c60e694.cat
XP_PAYLOAD_PATH=msil_utils_no-public-key_12.4.56.0_x-ww_2c60e694
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=utils,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\VoucherMgr\exe\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\VoucherMgr\genvoucher\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wiredatadump\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Utils\Utils.cs ===
using System;
using System.Collections;
using System.Collections.Specialized;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;

namespace xonline.common.utils
{
	/// <summary>
	/// Summary description for class.
	/// </summary>
	public class FileUtils
	{

        static Random rand = new Random(3);
        
        #region Token replacement
        
        /// <summary>
        /// TokenReplaceFile
        /// 
        /// Replaces all occurences of the specified token with the specified string in
        /// the specified file.  This is done line-by-line so the token may not span lines.
        /// </summary>
        /// <param name="token"></param>
        /// <param name="replace"></param>
        /// <param name="filename"></param>
        public static void TokenReplaceFile(Hashtable tokenMappings, string oldFileName, string newFileName, bool randomize , string postfix )
        {
            string newFile ;
            StringBuilder sb = new StringBuilder(); 


            //
            //  Save current attributes and clear read-only flag
            //

            if ((String.IsNullOrEmpty(newFileName)) || (newFileName == oldFileName))
                newFile = oldFileName + ".new";
            else
                newFile = newFileName;

            FileAttributes fa = File.GetAttributes(oldFileName);
            File.SetAttributes(oldFileName, fa & ~FileAttributes.ReadOnly);


            
            //Replace
            using(StreamReader sr = new StreamReader(oldFileName, Encoding.Default, true))
            {
                string line = sr.ReadLine();
                Encoding sourceEncoding = sr.CurrentEncoding;

                using (StreamWriter sw = new StreamWriter(newFile, false, sourceEncoding))
                {
                    do
                    {
                        //Read each line and replae all the tokens in that line

                        sb = new StringBuilder(line);
                        foreach (DictionaryEntry e in tokenMappings)
                        {
                            if (!randomize)
                            sb.Replace((string)e.Key, (string)e.Value);

                            if (randomize)
                            {
                                string newValue = (string)e.Value + "_" + postfix + "_" + rand.Next(0, 5);
                                sb.Replace((string)e.Key, newValue);
                            }

                        }

                        sw.WriteLine(sb.ToString());
                    }
                    while ((line = sr.ReadLine()) != null);
                }
            }

            if (newFileName == oldFileName)
            {
                File.Delete(oldFileName);
                File.Move(newFile, oldFileName);
            }
            File.SetAttributes(oldFileName, fa);
            
        }


        /// <summary>
        /// TokenReplaceFiles
        /// 
        /// Replaces the specified token with the specified replacement string in
        /// all files in path.
        /// </summary>
        /// <param name="token"></param>
        /// <param name="path"></param>
        public static void TokenReplaceFiles(Hashtable tokenMappings, string path, string newPath, string[] arrFiles)
        {
            foreach (string file in arrFiles)
            {

                TokenReplaceFile(tokenMappings, Path.Combine(path, file), Path.Combine(newPath, file), false, "");
            }
        }


        /// <summary>
        /// TokenReplaceFiles
        /// 
        /// Replaces the specified token with the specified replacement string in
        /// all files in path.
        /// </summary>
        /// <param name="token"></param>
        /// <param name="path"></param>
        public static void TokenReplaceFiles(Hashtable tokenMappings, string path, string newPath, string[] arrFiles, bool randomize, string postfix)
        {
            foreach(string file in arrFiles)
            {

                TokenReplaceFile(tokenMappings, Path.Combine(path, file), Path.Combine(newPath, file), randomize, postfix);
            }
        }

        #endregion Token replacement

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\VoucherMgr\vouchermgr.cs ===
/*
 * VoucherMgr.cs
 *
 * Xbox Live Operations / Voucher Management tool
 *
 * Copyright (c) Microsoft Corporation. All Rights Reserved.
 *
 * Author: SLamb     (Custodian: BenZotto)
 */

using System;
using System.Collections;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;

using xonline.common.billing;
using xonline.common.mgmt;
using xonline.common.offer;
using xonline.common.service;
using xonline.common.tools;
using xonline.common.tools.console;
using xonline.common.user;
using xonline.common.utilities;

using xonline.tools.framework;

namespace xonline.tools.vouchermgr
{
    public class VoucherMgrApp
    {
        static private NamedArgParser _args;
        static private UnicodeEncoding _enc;
        static private CVoucher _voucherFramework;
        static private CToken _tokenFramework;

        static private uint _added = 0;
        static private uint _updated = 0;
        static private uint _deleted = 0;
        static private uint _viewed = 0;

        static private ulong _espOfferId = 0;
        static private string _emsOfferId = null;
        static private int _mediaTypeId = 0;
        static private int _useCount = 1;
        static private byte _SCG = 0;
        static private byte _consolever = 1;
        static private int _status = 0;
        static private uint _minseq = 0;
        static private uint _maxseq = UInt32.MaxValue;
        static private int _retries = 6;

        static private StreamWriter _swFailedVouchers = null;

        // bugs #26234 and #26232
        static private StreamWriter swFailedVouchers
        {
            // to avoid FailedVouchers.txt file locking problems while writing from multiple VoucherMgr
            // instances running in parallel we don't log all failed vouchers in ONE file anymore:
            // every failed voucher gets logged into its corresponding .txt file according to
            // the accosiated offerID (which becomes a part of .txt file name now).
            // This approach would help localize offer-related problems much easier.

            get
            {
                if (_swFailedVouchers == null)
                {
                    // take emsOfferId if it exist, otherwise - take espOfferId;
                    string currOfferId = (!string.IsNullOrEmpty(_emsOfferId)) ? _emsOfferId : _espOfferId.ToString("X");

                    string failedVoucherFileName = string.Format("{0}{1}{2}", "FailedVouchers_", currOfferId, ".txt");
                    _swFailedVouchers = File.CreateText(Path.Combine(System.Environment.CurrentDirectory, failedVoucherFileName));
                    _swFailedVouchers.AutoFlush = true;
                }

                return _swFailedVouchers;
            }
        }

        // bugs #26234 and #26232
        static private void LogFailedVoucherInfo(string logMessage)
        {
            try
            {
                // trying to write to FailedVoucher_OfferId.txt file
                swFailedVouchers.WriteLine(logMessage);
            }
            catch (Exception e)
            {
                // writing error to the console
                Output.WriteAll("Writing to FailedVoucher file: Error!  " + e.ToString(), true);
            }
        }

        static private System.Text.ASCIIEncoding _ascii = new System.Text.ASCIIEncoding();

        private const string BAD_COMMAND_STRING = "Only one of /import, /disable, /enable, /delete, /view or /summary may be\r\nspecified.";

        /// <summary>current size of token batches sent to database</summary>
        static private int _batchSize = 10000;
        /// <summary>minimum size of token batches sent to database; not yet implemented</summary>
        static private int _minBatchSize = 10;
        /// <summary>maximum size of token batches sent to database; not yet implemented</summary>
        static private int _maxBatchSize = 10000;
        /// <summary>current sleep time in milliseconds</summary>
        static private int _sleep = 0;
        /// <summary>minimum sleep time in milliseconds</summary>
        static private int _minSleep = 0;
        /// <summary>maximum sleep time in milliseconds</summary>
        static private int _maxSleep = 8000;
        /// <summary>amount by which sleep time is decremented upon successful insertion (linear decrease in milliseconds)</summary>
        static private int _sleepDecrement = 1000;
        /// <summary>rate at which sleep time is multiplied upon failed insertion (geometric increase)</summary>
        static private double _sleepMultiplier = 2;


        /// <summary>
        /// Method that flushes a batch of hashes to one logical partition of the database.
        /// </summary>
        /// <param name="partition">partition to which hashes belong</param>
        /// <param name="hashList">list of hashes</param>
        /// <param name="firstIndex">index of first item to flush</param>
        /// <param name="lastIndex">index of last item to flush</param>
        private delegate void FlushDelegate( int partition, ArrayList hashList, int firstIndex, int lastIndex );


        /// <summary>
        /// List of hash values (which all belong to one partition) that automatically flushes to database when full.
        /// </summary>
        private class HashList
        {
            /// <summary>method for flushing hash values to database; ESP or EMS</summary>
            private static FlushDelegate _flush = null;

            /// <summary>list of hash values</summary>
            private ArrayList _list = new ArrayList( _maxBatchSize );
            /// <summary>logical partition that is destination for list of hash values</summary>
            private int _partition = -1;
            /// <summary>logical partition that is destination for list of hash values</summary>
            public int Partition { get { return _partition; } }
            /// <summary>index of next element to flush</summary>
            private int _nextIndexToFlush = 0;


            /// <summary>method for flushing hash values to database; ESP or EMS</summary>
            public static FlushDelegate FlushDel { set { _flush = value; } }


            /// <summary>
            /// Constructs a list of hash values mapped to a given logical partition of the database.
            /// </summary>
            /// <param name="partition">logical partition</param>
            public HashList( int partition )
            {
                _partition = partition;
            }


            /// <summary>
            /// Adds a hash value to the list, flushing to the database when full.
            /// </summary>
            /// <param name="hash">hash value</param>
            public void Add( byte[] hash )
            {
                _list.Add( hash );
                while( _list.Count >= _batchSize ) {
                    Flush();
                }
            }


            /// <summary>
            /// Flushes one batch of hash values to the database.
            /// </summary>
            public void Flush()
            {
                int lastIndexToFlush = Math.Min( _nextIndexToFlush + _batchSize, _list.Count ) - 1;

                _flush( _partition, _list, _nextIndexToFlush, lastIndexToFlush );

                if( lastIndexToFlush == _list.Count - 1 ) {
                    _list.Clear();
                    _nextIndexToFlush = 0;
                }
                else {
                    _nextIndexToFlush = lastIndexToFlush + 1;
                }
            }
        }


        /// <summary>
        /// Main entry point for vouchermgr.exe.
        /// </summary>
        /// <param name="rawArgs">Arguments.  See Help() method.</param>
        /// <returns>nothing</returns>

        public static void Main(string[] rawArgs)
        {
            if(rawArgs.Length == 0)
            {
                Help();
                return;
            }

            try
            {
                //
                //  Initialization
                //

                XomLoggingControl.Init();
                _enc = new UnicodeEncoding();
                _voucherFramework = new CVoucher();
                _tokenFramework = new CToken();

                //
                //  Parse arguments
                //

                string[] tags = {
                    // help
                    "?",
                    // commands
                    "import", "disable", "enable", "delete", "view",
                    // options
                    "verbose", "file", "catalogofferid", "offerid", "espofferid", "emsofferid", "usecount", "key", "minseq", "maxseq", "summary", "emssummary", "retries", "SCG", "consolever", "mediatype",
                    "status", "minbatchsize", "batchsize", "minsleep", "maxsleep",
                    // legacy
                    "keyimport", "hashimport"
                };

                _args = new NamedArgParser(tags);
                if (!_args.Parse(rawArgs))
                {
                    throw new ArgumentException("Invalid command line argument: " + _args.InvalidArgText);
                }

                // Check for /verbose flag, or assume verbose for /view or /summary operations
                if (_args["verbose"] != null
                    || _args["view"] != null
                    || _args["emssummary"] != null
                    || _args["summary"] != null) {
                    CommandUtility.IsVerbose = true;
                }
                else {
                    CommandUtility.IsVerbose = false;
                }

                Output.WriteAll("\r\nVoucherMgr run on: " + DateTime.Now.ToString() + "\r\n", false);

                //
                //  Help?
                //
                if (_args["?"] != null)
                {
                    Help();
                    return;
                }

                //
                // Shared parameters used in many commands.
                //

                // sequence range
                //
                _minseq = UInt32.MinValue;
                if (_args["minseq"] != null)
                {
                    _minseq = UInt32.Parse(_args["minseq"]);
                }

                _maxseq = UInt32.MaxValue;
                if (_args["maxseq"] != null)
                {
                    _maxseq = UInt32.Parse(_args["maxseq"]);
                }

                // retries - maximum *additional* attempts after the first failure
                if( _args["retries"] != null ) {
                    _retries = Int32.Parse( _args["retries"] );
                }

                // minimum batch size for voucher/token insertion/modification
                // TODO: possibly implement dynamic batch size logic
                if( _args["minbatchsize"] != null ) {
                    _minBatchSize = Int32.Parse( _args["minbatchsize"] );
                }
                if( _minBatchSize <= 0 ) {
                    throw new ArgumentException( "Minimum batch size (" + _minBatchSize + ") must be positive." );
                }

                // batch size for voucher/token insertion/modification
                if( _args["batchsize"] != null ) {
                    _maxBatchSize = _batchSize = Int32.Parse( _args["batchsize"] );
                }
                if( _batchSize < _minBatchSize ) {
                    throw new ArgumentException( "Batch size (" + _batchSize
                        + ") cannot be smaller than minimum batch size (" + _minBatchSize + ")." );
                }

                // minimum sleep time
                if( _args["minsleep"] != null ) {
                    _sleep = _minSleep = Int32.Parse( _args["minsleep"] );
                }
                if( _sleep < 0 ) {
                    throw new ArgumentException( "Minimum sleep time (" + _minSleep + ") must be nonnegative." );
                }

                // maximum sleep time
                if( _args["maxsleep"] != null ) {
                    _maxSleep = Int32.Parse( _args["maxsleep"] );
                }
                if( _maxSleep < _minSleep ) {
                    throw new ArgumentException( "Maximum sleep time (" + _maxSleep
                        + ") cannot be smaller than minimum sleep time (" + _minSleep + ")." );
                }

                //
                // Handle commands.  There should be exactly one command specified.
                //

                if(_args["import"] != null)
                {
                    if( _args["disable"] != null ||
                        _args["enable"]  != null ||
                        _args["delete"]  != null ||
                        _args["view"]    != null ||
                        _args["emssummary"] != null ||
                        _args["summary"] != null)
                    {
                        throw new ArgumentException(BAD_COMMAND_STRING);
                    }

                    if ( !string.IsNullOrEmpty(_args["emsofferid"]) )
                    {
                        DoEmsTokenImport();
                    }

                    if ( !string.IsNullOrEmpty(_args["offerid"]) || !string.IsNullOrEmpty(_args["espofferid"]) )
                    {
                        DoEspImport();
                    }
                }
                else if (_args["enable"] != null)
                {
                    if( _args["disable"] != null ||
                        _args["delete"]  != null ||
                        _args["view"]    != null ||
                        _args["summary"] != null)
                    {
                        throw new ArgumentException(BAD_COMMAND_STRING);
                    }

                    SetStatus(true);
                }
                else if (_args["disable"] != null)
                {
                    if( _args["delete"]  != null ||
                        _args["view"]    != null ||
                        _args["summary"] != null)
                    {
                        throw new ArgumentException(BAD_COMMAND_STRING);
                    }

                    SetStatus(false);
                }
                else if (_args["delete"] != null)
                {
                    if( _args["view"] != null ||
                        _args["summary"] != null)
                    {
                        throw new ArgumentException(BAD_COMMAND_STRING);
                    }

                    DoDelete();
                }
                else if (_args["view"] != null)
                {
                    if(_args["summary"] != null)
                    {
                        throw new ArgumentException(BAD_COMMAND_STRING);
                    }

                    DoView();
                }
                else if (_args["summary"] != null || _args["espsummary"] != null)
                {
                    DoEspSummary();
                }
                else if (_args["emssummary"] != null)
                {
                    DoEmsSummary();
                }
            }
            catch (ArgumentException e)
            {
                Output.WriteAll("VoucherManager: " + e.Message, true);
                Help();
            }
            catch (Exception e)
            {
                Output.WriteAll("VoucherManager: Error!  " + e.ToString(), true);
            }
            finally
            {
              Xom.NtEvent( XEvent.Id.VOUCHERMGR_COMPLETION,
                    "VoucherMgr run with command line:\n" + GrabArgList(rawArgs) + "\n" + Output.EventText );
                _voucherFramework.Dispose();
                _tokenFramework.Dispose();
                if (_swFailedVouchers != null)
                {
                    _swFailedVouchers.Close();
                }
            }
        }

        /// <summary>
        /// Helper function for parsing and validating /key and /file
        /// command line parameters.
        /// </summary>
        /// <param name="hashList">
        /// Contains a hashlist.  Result of parsing and processing
        /// either the /key or the /file parameter.
        /// </param>
        private static void ProcessKeyFileArgs(out ArrayList hashList)
        {
            hashList    = null;

            string key  = _args["key"];
            string file = _args["file"];

            if(!(key == null ^ file == null))
            {
                throw new ArgumentException("Either /file, or /key must be specified, but not both.");
            }

            if(key != null)
            {
                byte [] hash = GetHashFromKey(key);
                Output.WriteAll("Key: " + key, false);
                hashList = new ArrayList();
                hashList.Add(hash);
            }
            else
            {
                if(file == string.Empty)
                    throw new ArgumentException("No file specified.");

                Output.WriteAll("Key File: " + file, false);
                ProcessFile(file, out hashList);
            }
        }

        /// <summary>
        /// Handle the /import command:
        ///
        /// /import /usecount /offerid /key|/file [ /status:0|1 ]
        ///
        /// </summary>
        private static void DoEspImport()
        {
            string usecount = _args["usecount"];
            string offerid  = _args["espofferid"];
            string emsOfferId = _args["emsofferid"];
            string status   = _args["status"];
            string SCG      = _args["SCG"];
            string consolever = _args["consolever"];

            // if /espofferid is not present, look for legacy /offerid
            if ( string.IsNullOrEmpty(offerid) )
            {
                offerid = _args["offerid"];
            }

            //  First check for required parameters

            // usecount is required
            if ( string.IsNullOrEmpty(usecount) )
            {
                throw new ArgumentException("Must specify /usecount when updating/adding voucher!");
            }

            // espofferid is required
            if ( string.IsNullOrEmpty(offerid) )
            {
                throw new ArgumentException("Must specify either /emsofferid or /espofferid (or both) when updating/adding voucher!");
            }

            // strip off optional hex specifier
            if (offerid.Length == 18 && offerid.ToUpper().Substring(0, 2) == "0X")
                offerid = offerid.Substring(2);

            if (offerid.Length != 16)
            {
                throw new ArgumentException("Invalid offer id.");
            }

            // SCG is required
            if ( string.IsNullOrEmpty(SCG) )
            {
                throw new ArgumentException("Must specify /SCG when updating/adding voucher!");
            }
            else if (SCG != "0" && SCG != "1")
            {
                throw new ArgumentException("Only allowable values for /SCG are 0 (disabled) or 1 (enabled).");
            }

            // consolever is required
            if (string.IsNullOrEmpty(consolever))
            {
                throw new ArgumentException("Must specify /consolever when updating/adding voucher!");
            }
            else if (consolever != "1" && consolever != "2")
                throw new ArgumentException("Only allowable values for /consolever are 1 (Xbox) or 2 (Xenon).");

            // status is optional, defaults to zero (enabled)
            if(status == null)
                status = "0";
            else if(status != "0" && status != "1")
                throw new ArgumentException("Only allowable values for /status are 0 (enabled) or 1 (disabled).");

            // convert all other params from string to correct types
            _espOfferId = UInt64.Parse(offerid, NumberStyles.HexNumber);

            // validate useCount is not less than -1
            _useCount = Int32.Parse(usecount);
            if ( _useCount < -1 )
            {
                throw new ArgumentException("/usecount must be greater than or equal to -1.");
            }

            _status = Int32.Parse(status);
            _SCG = Byte.Parse(SCG);
            _consolever = Byte.Parse(consolever);

            Output.WriteAll("Offer ID: 0x" + _espOfferId.ToString("x") + "\r\nUse Count: " + _useCount + "\r\nStatus: " + _status + "\r\nSCG: " + _SCG + "\r\nConsole Version: " + _consolever, false);

            Offer o = Offer.CreateInstance(_espOfferId);

            // It is expected that an offer may have some tokens that are POSA-enabled and exist
            // in SCG while other tokens are not POSA-enabled and don't have billing offer ids
            // in some of the countries where they will be offered.
            //
            // If the token is configured as existing in SCG, verify that there is a billing
            // offer id present for at least one of the countries the offer is available in.
            if ( _SCG != 0 )
            {
                byte[] countryIds = o.GetCountriesOfferedIn(PaymentTypeEnum.Token, TierEnum.NewUser);
                bool hasOneBillingOffer = false;

                if ( o.IsXenonOffer )
                {
                    for (int i=0; i<countryIds.Length; i++)
                    {
                        // Every subscription or content token should be redeemable either by
                        // a new user or a silver user.
                        if ( o.AcceptsVoucher(countryIds[i], (int)TierEnum.NewUser) && !string.IsNullOrEmpty(o.BillingOfferId(countryIds[i], (int)TierEnum.NewUser, (int)PaymentTypeEnum.Token)) )
                        {
                            hasOneBillingOffer = true;
                            break;
                        }
                        else if ( o.AcceptsVoucher(countryIds[i], (int)TierEnum.Silver) && !string.IsNullOrEmpty(o.BillingOfferId(countryIds[i], (int)TierEnum.Silver, (int)PaymentTypeEnum.Token)) )
                        {
                            hasOneBillingOffer = true;
                            break;
                        }
                    }

                    if ( !hasOneBillingOffer )
                    {
                        throw new ArgumentException("/SCG:1 requires that corresponding offer must have an SCS billing offer id in at least one of the countries where it is available.");
                    }
                }
                else
                {
                    for (int i=0; i<countryIds.Length; i++)
                    {
                        if ( o.RequiresVoucher && !string.IsNullOrEmpty(o.BillingOfferId(countryIds[i])) )
                        {
                            hasOneBillingOffer = true;
                            break;
                        }
                    }

                    if ( !hasOneBillingOffer )
                    {
                        throw new ArgumentException("/SCG:1 requires that corresponding offer must have an SCS billing offer id in at least one of the countries where it is available.");
                    }
                }
            }

            // add key or file of keys/hashes
            AddKeyFile( AddListEsp );
        }


        /// <summary>
        /// Handle the /import command:
        ///
        /// /import /usecount /offerid /key|/file [ /status:0|1 ]
        ///
        /// </summary>
        private static void DoEmsTokenImport()
        {
            string mediaTypeId = _args["mediatype"];
            string usecount = _args["usecount"];
            string emsOfferId = _args["emsofferid"];
            string status   = _args["status"];
            string SCG      = _args["SCG"];
            string consolever = _args["consolever"];

            //  First check for required parameters

            // usecount is required
            if ( string.IsNullOrEmpty(usecount) )
            {
                throw new ArgumentException("Must specify /usecount when updating/adding token!");
            }

            // emsofferid is required
            if ( string.IsNullOrEmpty(emsOfferId) )
            {
                throw new ArgumentException("Must specify either /emsofferid or /espofferid (or both) when updating/adding token!");
            }

            // mediatype is required
            if ( string.IsNullOrEmpty(mediaTypeId) )
            {
                throw new ArgumentException("Must specify /mediatype when updating/adding an EMS token!");
            }

            // make sure the EMS offerid is valid guid
            try
            {
                Guid offeringGuid = new Guid(emsOfferId);
            }
            catch (FormatException fe)
            {
                throw new ArgumentException("Invalid offer id.", fe);
            }

            // SCG is required
            if ( string.IsNullOrEmpty(SCG) )
            {
                throw new ArgumentException("Must specify /SCG when updating/adding voucher!");
            }

            else if (SCG != "0" && SCG != "1")
            {
                throw new ArgumentException("Only allowable values for /SCG are 0 (disabled) or 1 (enabled).");
            }

            // consolever is required
            if (string.IsNullOrEmpty(consolever))
            {
                throw new ArgumentException("Must specify /consolever when updating/adding voucher!");
            }
            else if (consolever != "1" && consolever != "2")
                throw new ArgumentException("Only allowable values for /consolever are 1 (Xbox) or 2 (Xenon).");

            // status is optional, defaults to zero (enabled)
            if (status == null)
            {
                status = "0";
            }
            else if (status != "0" && status != "1")
            {
                throw new ArgumentException("Only allowable values for /status are 0 (enabled) or 1 (disabled).");
            }

            // set the offer id
            _emsOfferId = emsOfferId;

            // validate useCount is not less than -1
            _useCount = Int32.Parse(usecount);
            if ( _useCount < -1 )
            {
                throw new ArgumentException("/usecount must be greater than or equal to -1.");
            }

            _mediaTypeId = Int32.Parse(mediaTypeId);
            _status = Int32.Parse(status);
            _SCG = Byte.Parse(SCG);
            _consolever = Byte.Parse(consolever);

            Output.WriteAll("Offer ID: 0x" + _emsOfferId + "\r\nUse Count: " + _useCount + "\r\nStatus: " + _status + "\r\nSCG: " + _SCG + "\r\nConsole Version: " + _consolever, false);

#if false
            Offer o = Offer.CreateInstance(_espOfferId);
            if ( _SCG != 0 )
            {
                byte[] countryIds = o.GetCountriesOfferedIn(PaymentTypeEnum.Token, TierEnum.NewUser);
                for (int i=0; i<countryIds.Length; i++)
                {
                    if ( o.AcceptsVoucher(countryIds[i], (int)TierEnum.NewUser) )
                    {
                        if ( string.IsNullOrEmpty(o.BillingOfferId(countryIds[i], (int) TierEnum.NewUser, (int)PaymentTypeEnum.Token)) )
                        {
                            throw new ArgumentException("/SCG:1 requires that corresponding offer must have an SCS billing offer id in every country it is available (no billing offer id found for " + CountryDictionary.CountryCode(countryIds[i]) + ").");
                        }
                    }
                    else if ( o.AcceptsVoucher(countryIds[i], (int)TierEnum.Silver) )
                    {
                        if ( string.IsNullOrEmpty(o.BillingOfferId(countryIds[i], (int) TierEnum.Silver, (int)PaymentTypeEnum.Token)) )
                        {
                            throw new ArgumentException("/SCG:1 requires that corresponding offer must have an SCS billing offer id in every country it is available (no billing offer id found for " + CountryDictionary.CountryCode(countryIds[i]) + ").");
                        }
                    }
                }
            }
#endif
            // add key or file of keys
            AddKeyFile( AddListEms );
        }


        /// <summary>
        /// Handle the /disable and /enable commands:
        ///
        /// /ensable /key|/file
        /// /disable /key|/file
        ///
        /// </summary>
        private static void SetStatus(bool bEnable)
        {
            ArrayList hashList;

            // must specify either key or file, but not both
            ProcessKeyFileArgs(out hashList);

            //
            //  Now for each hash in the list, we first get info for it,
            //  then disable it.
            //

            _status = bEnable ? 0 : 1;

            foreach(byte [] hash in hashList)
            {
                ArrayList espInfo;
                ArrayList espUsed;
                _voucherFramework.GetVoucherInfo(hash, out espInfo, out espUsed);

                // disable each ESP voucher returned
                foreach(VoucherInfo vi in espInfo)
                {
                    _espOfferId = vi._offerID;
                    _useCount = vi._useCount;
                    _SCG = vi._SCG;
                    _consolever = vi._consolever;
                    Add(hash);
                }

                ArrayList emsInfo;
                ArrayList emsUsed;
                _tokenFramework.GetTokenInfo(hash, out emsInfo, out emsUsed);

                // disable each EMS token returned
                foreach (TokenInfo ti in emsInfo)
                {
                    _emsOfferId = ti._offerId.ToString();
                    _useCount = ti._useCount;
                    _SCG = ti._SCG;
                    _consolever = ti._consolever;
                    AddEmsToken(hash);
                }
            }
        }

        /// <summary>
        /// Handle the /delete command:
        ///
        /// /delete /key|/file [ /offerid ]
        ///
        /// </summary>
        private static void DoDelete()
        {
            ArrayList hashList;
            string offerid = _args["offerid"];

            ProcessKeyFileArgs(out hashList);

            if (offerid != null)
            {
                if(offerid.Length < 2)
                    throw new ArgumentException("Invalid offer id.");

                if(offerid.ToUpper().Substring(0,2) == "0X")
                    offerid = offerid.Substring(2);

                _espOfferId = UInt64.Parse(offerid, NumberStyles.HexNumber);
            }
            else
                _espOfferId = CVoucher.CVOUCHER_ALL_OFFERS;

            Delete(hashList);
        }

        /// <summary>
        /// Handle the /view command:
        ///
        /// /view /key|/file [/minseq] [/maxseq]
        ///
        /// </summary>
        private static void DoView()
        {
            ArrayList hashList;

            ProcessKeyFileArgs(out hashList);

            View(hashList);
        }

        /// <summary>
        /// Handle the /espsummary command:
        ///
        /// /summary
        ///
        /// Get a summary of all vouchers configured to ESP in the system.
        /// </summary>
        private static void DoEspSummary()
        {
            ArrayList info;
            Hashtable offers = new Hashtable();

            _voucherFramework.GetVouchersSummary(out info);

            foreach(VoucherInfo v in info)
            {
                string key = "0x" + v._offerID.ToString("x") + "\t" + v._useCount.ToString();
                if (offers.Contains(key))
                {
                    offers[key] = ((int)offers[key]) + v._numVouchers;
                }
                else
                {
                    offers[key] = v._numVouchers;
                }
            }

            Output.WriteConsole("Count\t\tOfferId\t\t\tUseCount", false);
            Output.WriteConsole("------------------------------------------------", false);
            foreach (DictionaryEntry entry in offers)
            {
                Output.WriteConsole(entry.Value + "\t\t" + entry.Key, false);
            }
        }

        /// <summary>
        /// Handle the /emssummary command:
        ///
        /// /summary
        ///
        /// Get a summary of all tokens associated with EMS offers in the system.
        /// </summary>
        private static void DoEmsSummary()
        {
            ArrayList info;
            Hashtable offers = new Hashtable();

            _tokenFramework.GetTokensSummary(out info);

            foreach(TokenInfo ti in info)
            {
                string key = ti._offerId.ToString() + "\t" + ti._useCount.ToString();
                if (offers.Contains(key))
                {
                    offers[key] = ((int)offers[key]) + ti._numTokens;
                }
                else
                {
                    offers[key] = ti._numTokens;
                }
            }

            Output.WriteConsole("Count\t\tOfferId\t\t\t\t\tUseCount", false);
            Output.WriteConsole("----------------------------------------------------------------", false);
            foreach (DictionaryEntry entry in offers)
            {
                Output.WriteConsole(entry.Value + "\t\t" + entry.Key, false);
            }
        }

        /// <summary>
        /// Print out hash or key info for a list of such.
        /// </summary>
        /// <param name="hashList"></param>
        private static void View(ArrayList hashList)
        {
            foreach( byte[] hash in hashList ) {
                Output.WriteConsole("hash: 0x" + ByteConvert.ToString(hash), false);
                ViewHashInfoInDb(hash);
                Output.WriteConsole(string.Empty, false);

                _viewed++;
            }

            if(_viewed == 0)
            {
                Output.WriteAll("VoucherManager: Warning: Specified range does not exist in file.", true);
            }
        }

        /// <summary>
        /// Insert or update a single voucher hash in the db.
        /// </summary>
        /// <param name="hash">Hash to insert or update.</param>
        private static void Add(byte [] hash)
        {
            int iRetries;

            for(iRetries = _retries; iRetries > 0; --iRetries)
            {
                try
                {
                    uint hr = _voucherFramework.SetVoucher(hash, _espOfferId, _useCount, _status, _SCG, _consolever);

                    if (hr == 0) _added++;
                    else _updated++;

                    if ((_updated + _added) % 1000 == 0)        Output.WriteConsole("\r\n" + (_updated + _added) + " ", false);
                    else if ((_updated + _added) % 100 == 0)    Output.WriteConsole(".", false);

                    break;
                }
                catch(InvalidOfferIdException)
                {
                  Xom.NtEvent( XEvent.Id.VOUCHERMGR_INVALID_OFFER, "Invalid offer id." );
                    throw;
                }
                catch(Exception e)
                {
                  Xom.NtEvent( XEvent.Id.VOUCHERMGR_FAILED_ATTEMPT, "Try " + iRetries +
                        ":  Failed to load voucher: \"" + hash + "\".  Error = " + e.Message );
                    System.Threading.Thread.Sleep(1000 * (2 ^ (4 - iRetries)));
                    continue;
                }
            }

            if(iRetries == 0)
            {
                Output.WriteConsole("\r\nVoucherManager: Failed to load voucher: " + ConvertHashToString( hash ) + ".  See event log for details.", true);
              Xom.NtEvent( XEvent.Id.VOUCHERMGR_FAILED_COMPLETE, "Failed to load voucher: " + ConvertHashToString( hash ) + "." );
                LogFailedVoucherInfo(ConvertHashToString(hash));
            }
        }


        /// <summary>
        /// Insert or update multiple voucher hashes in the database.
        /// </summary>
        /// <param name="partition">Logical partition for all hashes in list.</param>
        /// <param name="hashList">List of hashes to insert or update.</param>
        /// <param name="firstIndex">index of first item to flush</param>
        /// <param name="lastIndex">index of last item to flush</param>
        private static void AddListEsp( int partition, ArrayList hashList, int firstIndex, int lastIndex )
        {
            int iRetries;

            for( iRetries = 0; iRetries <= _retries; ++iRetries ) {
                if( _sleep > 0 ) {
                    System.Threading.Thread.Sleep( _sleep );
                }
                try {
                    _voucherFramework.SetVouchers( hashList, firstIndex, lastIndex, partition,
                        _espOfferId, _useCount, _status, _SCG, _consolever );

                    // on success, reduce sleep interval; down to _minSleep
                    _sleep = Math.Max( _minSleep, _sleep - _sleepDecrement );

                    uint old_added = _added;
                    _added += (uint) hashList.Count;

                    while( (old_added / 1000) < (_added / 1000) ) {
                        old_added += 1000;
                        Output.WriteConsole( ((old_added / 1000) * 1000) + " ", false );
                    }
                    return;
                }
                catch( InvalidOfferIdException ) {
                  Xom.NtEvent( XEvent.Id.VOUCHERMGR_INVALID_OFFER, "Invalid offer id." );
                    throw;
                }
                catch( Exception e ) {
                    // on failure, increase sleep interval; at least by minimum step, up to _maxSleep
                    _sleep = Math.Min( Math.Max( _sleepDecrement, (int) (_sleep * _sleepMultiplier) ), _maxSleep );

                    string entry = "Try " + iRetries + ":  Failed to load vouchers for partition: \"" + partition + "\".  Error = ";
                    if( e.Message.Length > 2000 ) {
                        entry += (e.Message.Substring( 0, 1000 ) + " ... " + e.Message.Substring( e.Message.Length - 1000 ));
                    }
                    else {
                        entry += e.Message;
                    }
                  Xom.NtEvent( XEvent.Id.VOUCHERMGR_FAILED_ATTEMPT, entry );
                    continue;
                }
            }

            // only reach here after all attempts have failed
            Output.WriteConsole( "\r\nVoucherManager: Failed to load vouchers for partition: " + partition + ".  See event log for details.", true );
          Xom.NtEvent( XEvent.Id.VOUCHERMGR_FAILED_COMPLETE, "Failed to load vouchers for partition: " + partition + "." );

            // getting timestamp of failure event
            DateTime timestamp = DateTime.Now;
            string sTimeStamp = timestamp.Minute.ToString(); // tick would be ideal here but ticks don't fit into Int32 format used everywhere in voucher manager

            string logMessage;
            for (int i = firstIndex; i <= lastIndex; ++i)
            {
                logMessage = string.Format("0,{0},{1},{2},{3}", sTimeStamp, iRetries.ToString(), partition.ToString(), ConvertHashToString((byte[])hashList[i]));
                LogFailedVoucherInfo(logMessage);
            }
        }


        /// <summary>
        /// Add a single key or multiple keys/hashes from a file.
        /// </summary>
        /// <param name="flushList">method for flushing a list of hash values to the database</param>
        private static void AddKeyFile( FlushDelegate flushList )
        {
            string key  = _args["key"];
            string file = _args["file"];

            if( !(key == null ^ file == null) ) {
                throw new ArgumentException( "Either /file, or /key must be specified, but not both." );
            }

            if( key != null ) { // single command-line key
                byte[] hash = GetHashFromKey( key );
                Output.WriteAll( "Key: " + key, false );

                if ( !string.IsNullOrEmpty(_emsOfferId) )
                {
                    AddEmsToken( hash );
                }

                if ( _espOfferId != 0 )
                {
                    Add( hash );
                }
            }
            else { // file of hashes or keys
                if( file == string.Empty ) {
                    throw new ArgumentException( "No file specified." );
                }

                Output.WriteAll( "Key File: " + file, false );

                // read into array of HashList, one per logical partition; update DB as each HashList fills, then flush
                int numPartitions = _voucherFramework.GetNumPartitions();
                HashList.FlushDel = flushList;
                HashList[] hashLists = new HashList[numPartitions];
                for( int i = 0; i < numPartitions; ++i ) {
                    hashLists[i] = new HashList( i );
                }

                StreamReader reader;
                string line;

                reader = File.OpenText( file );

                try {
                    line = reader.ReadLine();

                    if( line.IndexOf( "," ) != -1 ) { // file of hashes, sequence numbers, and other fields
                        byte[] hash;
                        do {
                            line = line.Trim();
                            if( line == String.Empty ) {
                                continue;
                            }

                            uint curseq;
                            GetHashAndSeq( line, out hash, out curseq );

                            // are we before the import window?
                            if( curseq < _minseq ) {
                                continue;
                            }

                            // if we're after the import window, we're done
                            if( curseq > _maxseq ) {
                                break;
                            }

                            hashLists[_voucherFramework.GetPartition( hash )].Add( hash );

                        } while( (line = reader.ReadLine()) != null );
                    }
                    else { // file of keys
                        do {
                            line = line.Trim();
                            if( line == String.Empty ) {
                                continue;
                            }

                            byte[] hash = GetHashFromKey( line );
                            hashLists[_voucherFramework.GetPartition( hash )].Add( hash );

                        } while( (line = reader.ReadLine()) != null );
                    }

                    // flush lists that didn't fill
                    foreach( HashList hashList in hashLists ) {
                        hashList.Flush();
                    }
                }
                finally {
                    // close up shop, all done
                    reader.Close();
                }
            }

            if( _added == 0 && _updated == 0 ) {
                Output.WriteAll( "Warning: No vouchers were added or updated.", false );
            }
        }


        /// <summary>
        /// Insert or update a single token hash in the db.
        /// </summary>
        /// <param name="hash">Hash to insert or update.</param>
        private static void AddEmsToken(byte [] hash)
        {
            int iRetries;

            for(iRetries = _retries; iRetries > 0; --iRetries)
            {
                try
                {
                    uint hr = _tokenFramework.AddToken(hash, new Guid(_emsOfferId), _mediaTypeId, _useCount, _status, _SCG, _consolever);

                    if (hr == 0) _added++;
                    else _updated++;

                    if ((_updated + _added) % 1000 == 0)        Output.WriteConsole("\r\n" + (_updated + _added) + " ", false);
                    else if ((_updated + _added) % 100 == 0)    Output.WriteConsole(".", false);

                    break;
                }
                catch(InvalidOfferIdException)
                {
                  Xom.NtEvent( XEvent.Id.VOUCHERMGR_INVALID_OFFER, "Invalid offer id." );
                    throw;
                }
                catch(Exception e)
                {
                  Xom.NtEvent( XEvent.Id.VOUCHERMGR_FAILED_ATTEMPT, "Try " + iRetries +
                        ":  Failed to load token: \"" + hash + "\".  Error = " + e.Message );
                    System.Threading.Thread.Sleep(1000 * (2 ^ (4 - iRetries)));
                    continue;
                }
            }

            if(iRetries == 0)
            {
                Output.WriteConsole("\r\nVoucherManager: Failed to load token: " + ConvertHashToString( hash ) + ".  See event log for details.", true);
              Xom.NtEvent( XEvent.Id.VOUCHERMGR_FAILED_COMPLETE, "Failed to load token: " + ConvertHashToString( hash ) + "." );
                LogFailedVoucherInfo(ConvertHashToString(hash));
            }
        }


        /// <summary>
        /// Insert or update multiple token hashes in the database.
        /// </summary>
        /// <param name="partition">Logical partition for all hashes in list.</param>
        /// <param name="hashList">List of hashes to insert or update.</param>
        private static void AddListEms( int partition, ArrayList hashList, int firstIndex, int lastIndex )
        {
            int iRetries;

            for( iRetries = 0; iRetries <= _retries; ++iRetries ) {
                if( _sleep > 0 ) {
                    System.Threading.Thread.Sleep( _sleep );
                }
                try {
                    _tokenFramework.AddTokens( hashList, firstIndex, lastIndex, partition,
                        new Guid( _emsOfferId ), _mediaTypeId, _useCount, _status, _SCG, _consolever );

                    // on success, reduce sleep interval; down to _minSleep
                    _sleep = Math.Max( _minSleep, _sleep - _sleepDecrement );

                    uint old_added = _added;
                    _added += (uint) hashList.Count;

                    while( (old_added / 1000) < (_added / 1000) ) {
                        old_added += 1000;
                        Output.WriteConsole( ((old_added / 1000) * 1000) + " ", false );
                    }
                    return;
                }
                catch( InvalidOfferIdException ) {
                  Xom.NtEvent( XEvent.Id.VOUCHERMGR_INVALID_OFFER, "Invalid offer id." );
                    throw;
                }
                catch( Exception e ) {
                    // on failure, increase sleep interval; at least by minimum step, up to _maxSleep
                    _sleep = Math.Min( Math.Max( _sleepDecrement, (int) (_sleep * _sleepMultiplier) ), _maxSleep );

                    string entry = "Try " + iRetries + ":  Failed to load tokens for partition: \"" + partition + "\".  Error = ";
                    if( e.Message.Length > 2000 ) {
                        entry += (e.Message.Substring( 0, 1000 ) + " ... " + e.Message.Substring( e.Message.Length - 1000 ));
                    }
                    else {
                        entry += e.Message;
                    }
                  Xom.NtEvent( XEvent.Id.VOUCHERMGR_FAILED_ATTEMPT, entry );
                    continue;
                }
            }

            // only reach here after all attempts have failed
            Output.WriteConsole( "\r\nVoucherManager: Failed to load tokens for partition: " + partition + ".  See event log for details.", true );
          Xom.NtEvent( XEvent.Id.VOUCHERMGR_FAILED_COMPLETE, "Failed to load tokens for partition: " + partition + "." );

            DateTime timestamp = DateTime.Now;
            string sTimeStamp = timestamp.Minute.ToString(); // tick would be ideal here but ticks don't fit into Int32 format used everywhere in voucher manager

            string logMessage;
            for (int i = firstIndex; i <= lastIndex; ++i)
            {
                logMessage = string.Format("0,{0},{1},{2},{3}", sTimeStamp, iRetries.ToString(), partition.ToString(), ConvertHashToString((byte[])hashList[i]));
                LogFailedVoucherInfo(logMessage);
            }
        }


        /// <summary>
        /// Delete a single voucher hash in the db.
        /// </summary>
        /// <param name="hash">Hash to delete.</param>
        private static void Delete(byte [] hash)
        {
            int iRetries;

            for (iRetries = _retries; iRetries > 0; --iRetries)
            {
                try
                {
                    _voucherFramework.DeleteVoucher(hash, _espOfferId);
                    ++_deleted;

                    if (_deleted % 1000 == 0)
                        Output.WriteConsole("\r\n" + (_deleted) + " ", false);

                    else if (_deleted % 100 == 0)
                        Output.WriteConsole(".", false);

                    break;
                }
                catch(Exception e)
                {
                  Xom.NtEvent( XEvent.Id.VOUCHERMGR_FAILED_ATTEMPT, "Try " + iRetries +
                        ":  Failed to delete voucher: " + ByteConvert.ToString(hash) + "\".  Error = " + e.Message );
                    System.Threading.Thread.Sleep(1000 * (2 ^ (4 - iRetries)));
                    continue;
                }
            }

            if (iRetries == 0)
            {
                Output.WriteConsole("\r\nFailed to delete voucher: " + ByteConvert.ToString(hash) + ".  See event log for details.", true);
              Xom.NtEvent( XEvent.Id.VOUCHERMGR_FAILED_COMPLETE, "Failed to delete voucher: " + ByteConvert.ToString( hash ) + "." );
                LogFailedVoucherInfo(ByteConvert.ToString(hash));
            }

            // if the token is associated with any EMS offers, delete it
            for (iRetries = _retries; iRetries > 0; --iRetries)
            {
                try
                {
                    _tokenFramework.DeleteToken(hash, null);
                    ++_deleted;

                    if (_deleted % 1000 == 0)
                        Output.WriteConsole("\r\n" + (_deleted) + " ", false);

                    else if (_deleted % 100 == 0)
                        Output.WriteConsole(".", false);

                    break;
                }
                catch(Exception e)
                {
                  Xom.NtEvent( XEvent.Id.VOUCHERMGR_FAILED_ATTEMPT, "Try " + iRetries +
                        ":  Failed to delete token: " + ByteConvert.ToString( hash ) + ".  Error = " + e.Message );
                    System.Threading.Thread.Sleep(1000 * (2 ^ (4 - iRetries)));
                    continue;
                }
            }

            if (iRetries == 0)
            {
                Output.WriteConsole("\r\nFailed to delete token: " + ByteConvert.ToString(hash) + ".  See event log for details.", true);
              Xom.NtEvent( XEvent.Id.VOUCHERMGR_FAILED_COMPLETE, "Failed to delete token: " + ByteConvert.ToString( hash ) + "." );
                LogFailedVoucherInfo(ByteConvert.ToString(hash));
            }


        }

        /// <summary>
        /// Delete a list of hashes/keys.
        /// </summary>
        /// <param name="hashList"></param>
        private static void Delete(ArrayList hashList)
        {
            foreach(byte [] hash in hashList)
            {
                Delete(hash);
            }

            if(_deleted == 0)
            {
                Output.WriteAll("Warning: Specified range does not exist in file.", false);
            }
        }


        /// <summary>
        /// Process a file and return a list of hashes (byte[]) or keys (string)
        /// </summary>
        /// <param name="hashList"></param>
        /// <returns></returns>
        private static void ProcessFile(string file, out ArrayList hashList)
        {
            hashList = new ArrayList();
            StreamReader reader;
            string line;

            reader = File.OpenText(file);

            try
            {
                line = reader.ReadLine();

                if( line.IndexOf( "," ) != -1 ) { // file of hashes, sequence numbers, and other fields
                    byte[] hash;
                    do
                    {
                        line = line.Trim();
                        if( line == String.Empty ) {
                            continue;
                        }

                        uint curseq;
                        GetHashAndSeq( line, out hash, out curseq );

                        // are we before the import window?
                        if (curseq < _minseq)
                        {
                            continue;
                        }

                        // if we're after the import window, we're done
                        if (curseq > _maxseq)
                        {
                            break;
                        }

                        hashList.Add( hash );
                    } while( (line = reader.ReadLine()) != null );
                }
                else { // file of keys
                    do {
                        line = line.Trim();
                        if( line == String.Empty ) {
                            continue;
                        }
                        hashList.Add( GetHashFromKey( line ) );
                    } while( (line = reader.ReadLine()) != null );
                }
            }
            finally
            {
                // close up shop, all done
                reader.Close();
            }
        }

        /// <summary>
        /// Give a line of text, extract the hash and sequence number
        /// </summary>
        /// <param name="line">Line of text to parse</param>
        /// <param name="hash">Returned hash</param>
        /// <param name="seq">Returned sequence number</param>
        private static void GetHashAndSeq( string line, out byte[] hash, out uint seq )
        {
            string[] parts;

            seq = 0;
            hash = null;

            // split out line components
            parts = line.Trim().Split( new char[] {','} );
            if (parts.Length != 4 && parts.Length != 5)
            {
                throw new FormatException("Invalid format for hash! ('" + line + "')");
            }

            // seq num
            seq = Convert.ToUInt32(parts[1]);

            // hex encoded hash data
            hash = new byte[parts[parts.Length-1].Length/2];
            for (int i = 0; i < hash.Length; i++)
            {
                hash[i] = Convert.ToByte(parts[parts.Length - 1].Substring(i * 2, 2), 16);
            }
        }


        /// <summary>
        /// Converts a hash value into a string representation that can be read by VoucherMgr.
        /// </summary>
        /// <param name="hash">hash represented as 20-byte array</param>
        /// <returns>string representation of a hash readable by VoucherMgr</returns>
        private static string ConvertHashToString( byte[] hash )
        {
            StringBuilder s = new StringBuilder( 2 * hash.Length );
            for( int i = 0; i < hash.Length; ++i ) {
                s.Append( (hash[i] < 16 ? "0" : "") + Convert.ToString( hash[i], 16 ) );
            }
            return s.ToString();
        }


        /// <summary>
        /// Call VoucherUtil.GetTokenHash to compute the hash for the given 5x5 token
        /// </summary>
        /// <param name="key">5x5 token</param>
        /// <returns>hash of the 5x5 token</returns>
        private static byte[] GetHashFromKey(string token)
        {
            byte[] tokenHash = null;
            bool isLiveGenerated = false;

            VoucherUtil.GetTokenHash(token, out tokenHash, out isLiveGenerated);

            return tokenHash;
        }

        /// <summary>
        /// Display information about a voucher.
        /// </summary>
        /// <param name="hash"></param>
        private static void ViewHashInfoInDb(byte[] hash)
        {
            ArrayList espInfo;
            ArrayList espUsed;
            _voucherFramework.GetVoucherInfo(hash, out espInfo, out espUsed);

            ArrayList emsInfo;
            ArrayList emsUsed;
            _tokenFramework.GetTokenInfo(hash, out emsInfo, out emsUsed);

            if ( espInfo.Count == 0 && emsInfo.Count == 0 )
            {
                Output.WriteConsole("Token not found in UODB.", false);
                return;
            }

            if (espInfo.Count != 0)
            {
                foreach(VoucherInfo v in espInfo)
                {
                    Output.WriteConsole("Offer ID: 0x" + v._offerID.ToString("x") + "      Use count: " + v._useCount + "         Status: " + v._status+ "            SCG: " + v._SCG + "    Console Version: " + v._consolever, false);
                }

                if (espUsed.Count != 0)
                {
                    Output.WriteConsole("Uses", false);
                    Output.WriteConsole("----", false);

                    foreach(VoucherUseInfo v in espUsed)
                    {
                        User u = new User();
                        u.Load((ulong)v._puid);

                        Output.WriteConsole("Date: " + v._whenUsed + "\tUser: " + u.GamerTag + " (0x" + u.Puid.ToString("x") + ")", false);
                    }
                }
            }

            else
            {
                Output.WriteConsole("No uses registered.", false);
            }

            if (emsInfo.Count != 0)
            {
                foreach (TokenInfo ti in emsInfo)
                {
                    Output.WriteConsole("Offer ID: " + ti._offerId + "  Media Type Id: " + ti._mediaTypeId + "      Use count: " + ti._useCount + "         Status: " + ti._status+ "            SCG: " + ti._SCG + "    Console Version: " + ti._consolever, false);
                }

                if (emsUsed.Count != 0)
                {
                    Output.WriteConsole("Uses", false);
                    Output.WriteConsole("----", false);

                    foreach(TokenUseInfo tui in emsUsed)
                    {
                        User u = new User();
                        u.Load((ulong)tui._puid);

                        Output.WriteConsole("Date: " + tui._whenUsed + "\tUser: " + u.GamerTag + " (0x" + u.Puid.ToString("x") + ")", false);
                    }
                }
            }

        }

        /// <summary>
        /// Command line help.
        /// </summary>
        private static void Help()
        {
            Console.WriteLine(@"
vouchermgr <options>

    -- OPTIONS --
One of the following functions must be specified:

/import /key|/file /usecount /offerid /SCG /consolever [/verbose] [/status] [/minseq] [/maxseq] [/retries] [/batchsize]
    Imports key(s) or hash(es)

/disable /key|/file [/verbose] [/minseq] [/maxseq]
    Disables key(s) or hash(es)

/enable /key|/file [/verbose] [/minseq] [/maxseq]
    Enables key(s) or hash(es)

/delete /key|/file [/verbose] [/offerid] [/minseq] [/maxseq] [/retries]
    Deletes key(s) or hash(es).  If /offerid is specified only
    deletes voucher from that offerid.

/view /key|/file
    shows usage for the given key(s) or hashes

/summary
    shows offer id usage summary information

Parameters:
  /verbose                      enables non-error console output

  /key:<key>                    perform action on a single raw key

  /file:<file>                  file listing of raw keys, one per line,
                                                  -OR-
                                file listing of hashes, each line in the format:
                                       2 digit GroupId
                                       9 digit sequence number
                                       1 digit Upgrade flag
                                       40 characters of hex encoded data
                                       (2 character CR/LF DOS style line terminator)

                                  VoucherMgr uses the first line of the file to
                                  determine the format to use.

  /usecount:<use count>         number of times the hash(s) can be used, -1 for infinite

  /SCG:<SCG status>             whether the key is tracked in SCG and needs activation
                                verification.
                                   0 = disabled [no extra validation check]
                                   1 = active [keys will be validated against SCG]

  /consolever:<version>         the version of the console tied to the key
                                   1 = Xbox
                                   2 = Xenon/Xbox360

                                This should be 2 for anything other than Xbox1 offers

  /status:<status id>           initial status of vouchers:
                                   0 = active [default]
                                   1 = disabled

  /espofferid:<offer id>        if specified with /import, offer id to associate
                                   with the hash(s)
                                if specified with /delete, deletes only those
                                   keys/hashes for this offer id

  /emsofferid:<guid>            if specified with /import, offer id to associate
                                   with the hash(s)
                                if specified with /delete, deletes only those
                                   keys/hashes for this offering id

  /mediatype:<media-type-id>    for EMS offers, the EMS media type id that corresponds to
                                   the offer.

  /minseq:<sequence num>        minimum sequence number (inclusive)
                                       (used only with /file where the file
                                        contains hashes, not keys)

  /maxseq:<sequence num>        maximum sequence number (inclusive)
                                       (used only with /file where the file
                                        contains hashes, not keys)

  /batchsize:<size>             database batch size for importing from a file
                                       (/import /file...); default is 10000

  /minsleep:<size>              minimum sleep time (millseconds) before each insert
                                       (/import /file...); default is 0

  /maxsleep:<size>              maximum sleep time (millseconds) before each insert
                                       (/import /file...); default is 8000

@<response file>                file containing any of the above arguments,
                                        one per line

    -- EXAMPLES --

VoucherMgr /import /file:hashes.txt /offerid:0xfffe000080000001 /usecount:1
           /verbose /minseq:1000 /maxseq:2000 /SCG:1 /consolever:2

VoucherMgr /import /key:aaaaa-bbbbb-ccccc-ddddd-eeeee /emsofferid:fd20133f-1d38-499d-aba5-dee4f409a146 /mediatype:18 /usecount:1 /SCG:0 /consolever:2

VoucherMgr /view /key:11111-11111-11111-11111-11111

VoucherMgr /enable /verbose /key:22222-22222-22222-22222-22222

VoucherMgr /disable /file:keys.txt

VoucherMgr /delete /verbose /key:44444-44444-44444-44444-44444

VoucherMgr /summary

VoucherMgr @args.txt
  where args.txt contains:
   /import
   /file:keys.txt
   /offerid:0xfffe000080000001
");

        }


        /// <summary>
        /// Format command line args for display.
        /// </summary>
        /// <param name="arglist">Arglist passed into vouchermgr.</param>
        /// <returns>String containing args for display.</returns>
        private static string GrabArgList(string[] arglist)
        {
            string filearg;
            try
            {
                StringBuilder sb = new StringBuilder();

                foreach(string arg in arglist)
                {

                    if(arg[0] == '@')
                    {
                        StreamReader reader = File.OpenText(arg.Substring(1));
                        filearg = reader.ReadLine();

                        while (filearg != null)
                        {
                            filearg = filearg.Trim();
                            if (filearg != string.Empty)
                                sb.Append(filearg.Trim() + " ");

                            filearg = reader.ReadLine();
                        }
                        reader.Close();

                        return sb.ToString();

                    }
                    else
                    {
                        sb.Append(arg + " ");
                    }
                }

                return sb.ToString();

            }
            catch
            {
                return(String.Join(" ", arglist));
            }
        }
    }

    /// <summary>
    /// Output wrapper class.
    /// </summary>
    public class Output
    {
        private static StringBuilder _evtsb;

        public static string EventText
        {
            get
            {
                return _evtsb.ToString();
            }
        }

        static Output()
        {
            _evtsb = new StringBuilder();
        }

        public static void WriteConsole(string s, bool isError)
        {
            if (isError) {
                CommandUtility.WriteError(s);
            }
            else {
                CommandUtility.WriteOutput(s);
            }
        }

        public static void WriteEvent(string s)
        {
            _evtsb.Append(s + "\n");
        }

        public static void WriteAll(string s, bool isError)
        {
            _evtsb.Append(s + "\n");
            WriteConsole(s, isError);
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wiretap\darray.h ===
#ifndef _DARRAY_H_
#define _DARRAY_H_

template <
    class T, 
    int CELLSIZE, 
    int MAXCELLS, 
    int MAXEMPTYCELLS> 
class CDArray
{
public:
    
    CDArray()
    {
        m_cCells = 0;
        m_cNodes = 0;
    }

    HRESULT InsertBogus()
    {
        HRESULT hr = S_OK;
    
        if((m_cNodes / CELLSIZE) + 1 > m_cCells)
        {
            hr = Grow();
        }

        if(SUCCEEDED(hr))
        {
            m_cNodes++;
        }

        return hr;
    }

    HRESULT InsertAtTheEnd(
        T& refNode
    )
    {
        HRESULT hr = S_OK;
    
        if((m_cNodes / CELLSIZE) + 1 > m_cCells)
        {
            hr = Grow();
        }

        if(SUCCEEDED(hr))
        {
            m_cNodes++;
            Set(m_cNodes-1, refNode);
        }

        return hr;
    }

    T RemoveFromTheEnd()
    {
        m_cNodes--;

        T ret = m_pCells[m_cNodes / CELLSIZE]->rgNode[m_cNodes % CELLSIZE];

        Shrink();

        return ret;
    }

    void Set(
        DWORD dwIndex,
        T& refNode
    )
    {
        ASSERT(dwIndex < m_cNodes);

        m_pCells[dwIndex / CELLSIZE]->rgNode[dwIndex % CELLSIZE] = refNode;
    }


    T& Get(
        DWORD dwIndex)
    {
        ASSERT(dwIndex < m_cNodes);
    
        return m_pCells[dwIndex / CELLSIZE]->rgNode[dwIndex % CELLSIZE];
    }
   
    void Shrink()
    {
        if(m_cCells - ((m_cNodes / CELLSIZE) + 1) > MAXEMPTYCELLS)
        {
            m_cCells--;
            delete m_pCells[m_cCells];
            m_pCells[m_cCells] = NULL;
        }
    }

    struct CELL 
    {
        T rgNode[CELLSIZE];
    };
    
    HRESULT Grow()
    {
        m_pCells[m_cCells] = new CELL;

        if(m_pCells[m_cCells])
        {
            m_cCells++;
            return S_OK;
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }

    DWORD GetCount()
    {
        return m_cNodes;
    }

protected:


    CELL* m_pCells[MAXCELLS];
    DWORD m_cCells;
    DWORD m_cNodes;
};


#endif // #ifndef _DARRAY_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\VoucherMgr\genvoucher\genvoucher.cs ===
/*
 * GenVoucher.cs
 *
 * Testing tool for creating random vouchers.
 *
 * Copyright (c) Microsoft Corporation. All Rights Reserved.
 *
 * Author: BenZotto
 */
                                   
using System;
using System.IO;
using System.Collections;
using System.Text;
using System.Globalization;
using System.Security.Cryptography;
using System.Diagnostics;

public class VoucherMgr
{
    static SHA1CryptoServiceProvider _sha;
    static UnicodeEncoding _enc;        
                                                          
    public static int Main(string[] rawArgs)
    {
        _sha = new SHA1CryptoServiceProvider();
        _enc = new UnicodeEncoding();
        
        Random rand = new Random();
        string key = "", strHash;
        byte[] hash;
        
        //
        // build voucher
        //
        
        for(int i=0; i < 25; i++)
        {
            int j = rand.Next(36);
            
            if(j < 10)
            {
                key += j.ToString("d");
            }
            else
            {
                key += (Convert.ToChar(j + 55));
            }            
        }
        
        key = key.Insert(20, "-");
        key = key.Insert(15, "-");
        key = key.Insert(10, "-");
        key = key.Insert(5,  "-");
        
        Console.WriteLine(key);        
    
        hash = GetHashFromKey(key);
        strHash = "0x";
    
        foreach(byte b in hash)
        {
            strHash += b.ToString("x");
        }
        
        Console.WriteLine(strHash);
                                       
        return 0;
    }        
    
    
    public static byte[] GetHashFromKey(string key)
    {
        key = key.ToUpper();
        
        if (key[5] != '-')
        {
            // insert dashes (thank you windows.net)
            key = key.Insert(20, "-");
            key = key.Insert(15, "-");
            key = key.Insert(10, "-");
            key = key.Insert(5,  "-");
        }
        
        // extra null is again, thanks to windows.net
        return _sha.ComputeHash(_enc.GetBytes(key + "\0"));
    }
   
       
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wiretap\dheap.h ===
#ifndef _DHEAP_H_
#define _DHEAP_H_

#include "darray.h"

template <class T>
class CDHeapNoNotify
{
public:
    void operator()(T v, int nNewPos)
    {
        // Do nothing
    }
};

template <
    class T,
    class COMPARE,
    int CELLSIZE, 
    int MAXCELLS, 
    int MAXEMPTYCELLS,
    class NOTIFYONNEWPOSITION=CDHeapNoNotify>
class CDHeap
{
public:
    
    CDHeap()
    {
        m_Array.InsertBogus();
    }

    HRESULT Insert(
        T node
    )
    {
        HRESULT hr = m_Array.InsertAtTheEnd(node);

        if(SUCCEEDED(hr))
        {
            UpHeap(GetCount());
        }

        return hr;
    }

    T Remove(
        DWORD dwIndex
    )
    {
        dwIndex++;

        ASSERT(dwIndex <= GetCount());
    
        T ret = m_Array.Get(dwIndex);

        m_Array.Set(dwIndex, m_Array.Get(GetCount()));
        
        NOTIFYONNEWPOSITION()(m_Array.Get(dwIndex), dwIndex-1);

        m_Array.RemoveFromTheEnd();

        if(GetCount() > 0 && dwIndex < GetCount())
            DownHeap(dwIndex);

        return ret;
    }

    T Peek(
        DWORD dwIndex
    )
    {
        return m_Array.Get(dwIndex+1);
    }

    DWORD GetCount()
    {
        return m_Array.GetCount() - 1;
    }

    void Dump()
    {
        int iCount = GetCount();

        for(int i=1; i <= iCount; i++)
        {
            printf("%d(%d) ", m_Array.Get(i).v, m_Array.Get(i).pos);
        }
        printf("\n");
    }

protected:

    void UpHeap(
        DWORD dwIndex
    )
    {
        T v = m_Array.Get(dwIndex);

        while(dwIndex > 1 && COMPARE()(m_Array.Get(dwIndex / 2), v) < 0)
        {
            m_Array.Set(dwIndex, m_Array.Get(dwIndex / 2));
    
            NOTIFYONNEWPOSITION()(m_Array.Get(dwIndex), dwIndex-1);

            dwIndex /= 2;
        }

        m_Array.Set(dwIndex, v);

        NOTIFYONNEWPOSITION()(m_Array.Get(dwIndex), dwIndex-1);
    }

    void DownHeap(
        DWORD dwIndex
    )
    {
        T v = m_Array.Get(dwIndex);
    
        DWORD dwSize = GetCount();

        while(dwIndex <= dwSize / 2)
        {
            DWORD j = dwIndex * 2;

            if(j < dwSize && COMPARE()(m_Array.Get(j),m_Array.Get(j+1)) < 0)
            {
                j++;
            }

            if(COMPARE()(v, m_Array.Get(j)) >= 0)
            {
                break;
            }

            m_Array.Set(dwIndex, m_Array.Get(j));

            NOTIFYONNEWPOSITION()(m_Array.Get(dwIndex), dwIndex-1);

            dwIndex = j;
        }

        m_Array.Set(dwIndex, v);

        NOTIFYONNEWPOSITION()(m_Array.Get(dwIndex), dwIndex-1);
    }
    
    typedef CDArray <T, CELLSIZE, MAXCELLS, MAXEMPTYCELLS> ARRAY;

    ARRAY m_Array;
};

#endif // #ifndef _DHEAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wiretap\dyncapturefile.cpp ===
//-----------------------------------------------------------------------------
//  Microsoft (R) XWireTap (tm). 
//  Copyright (C) 2002. All rights reserved.
//
//  FILE: CaptureFile.cpp
//
//  Interface for NetMon Capture file writer.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Includes
//-----------------------------------------------------------------------------
#include "StdAfx.h"

//-----------------------------------------------------------------------------
// Definitions
//-----------------------------------------------------------------------------
#define DEFAULT_READ_SIZE				128
#define MAX_PERMITTED_FILESIZE			2000000000

//-----------------------------------------------------------------------------
// CDynCaptureFile
//-----------------------------------------------------------------------------

CDynCaptureFile::CDynCaptureFile(void)
{
    SYSTEMTIME stStartTime;

    // initialize all variables to some default.
    m_CapFileHandle = INVALID_HANDLE_VALUE;
    m_FrameTableFileHandle = INVALID_HANDLE_VALUE;

    m_dwCurFileSize = 0;
    m_dwMaxFileSize = 0;
    m_dwFileOffset = 0;

    m_szCapFileName = NULL;    
    m_szDumpFileName = NULL;    

    // set up the capture file header.
    ZeroMemory( &m_objCFHeader, sizeof(CAPTUREFILE_HEADER_VALUES) );
    ZeroMemory( &m_objFrameTable, sizeof(FRAMETABLE) );
    
    // todo:  (lohab) make this non static
    m_objCFHeader.Signature   =  NETMON_2_0_CAPTUREFILE_SIGNATURE;
    m_objCFHeader.BCDVerMinor =  CAPTUREFILE_VERSION_MINOR;
    m_objCFHeader.BCDVerMajor =  CAPTUREFILE_VERSION_MAJOR;
    m_objCFHeader.MacType     =  MAC_TYPE_ETHERNET;

    // set the start time.
    GetSystemTime( &stStartTime );
    memcpy( (LPVOID)&(m_objCFHeader.TimeStamp),   
            (LPVOID)&(stStartTime),
            sizeof(SYSTEMTIME));

    m_bIsComplete = NULL;

}

CDynCaptureFile::~CDynCaptureFile(void)
{
    // ensure the file is closed.
    if ( !m_bIsComplete )
    {
        Close();
    }

    // clear the file name
    if ( m_szCapFileName != NULL )
    {
        delete[] m_szCapFileName;
        m_szCapFileName = NULL;
    }

    if ( m_szDumpFileName != NULL )
    {
        delete[] m_szDumpFileName;
        m_szDumpFileName = NULL;
    }

}

// -------------------------------------------------
//  Open:  Opens a capture file of a fixed size.
// -------------------------------------------------
HRESULT CDynCaptureFile::Open( char *szFilename, DWORD dwFileSize )
{
    HRESULT hr = S_OK;
    
    hr = Open( szFilename );
    if ( FAILED(hr) )
    {
        goto Exit;
    }
    m_dwMaxFileSize = dwFileSize;

Exit:
    return hr;
}

// -------------------------------------------------
//  Open:  Opens a file of variable size.
// -------------------------------------------------
HRESULT CDynCaptureFile::Open( char *szFilename )
{
    HRESULT hr = S_OK;
    int nFileNameSize = 0;
    DWORD dwBytesWritten = 0;

    // ensure the file has not already been opened.
    if ( m_szCapFileName != NULL && m_CapFileHandle != INVALID_HANDLE_VALUE )
    {
        hr = E_CAPFILE_ALREADY_OPEN;
        goto Exit;
    }

    XOMASSERT( szFilename !=  NULL );

    // get the size of the file name
    nFileNameSize = strlen( szFilename );
    m_szCapFileName = new char[ nFileNameSize + 1];
    ZeroMemory( m_szCapFileName, nFileNameSize + 1 );
    memcpy( m_szCapFileName, szFilename, nFileNameSize * sizeof(char) );

    m_szDumpFileName = new char[ nFileNameSize + 1];
    ZeroMemory( m_szDumpFileName, nFileNameSize + 1 );
    memcpy( m_szDumpFileName, szFilename, nFileNameSize * sizeof(char) );
    memcpy( (m_szDumpFileName + nFileNameSize - 3), "dmp", 3 );
    
    m_dwMaxFileSize = MAX_PERMITTED_FILESIZE;

    // open the capture file
    m_CapFileHandle = CreateFileA( 
                            m_szCapFileName, 
                            GENERIC_WRITE, 
                            0, 
                            NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);
    if ( INVALID_HANDLE_VALUE == m_CapFileHandle )
    {
        delete[] m_szCapFileName;
        delete[] m_szDumpFileName;
        hr = MAKE_HRESULT( 1, FACILITY_WIN32, GetLastError());
        goto Exit;
    }

    // open the dump file for the file table.
    m_FrameTableFileHandle = CreateFileA(
                            m_szDumpFileName, 
                            GENERIC_WRITE | GENERIC_READ, 
                            0, 
                            NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);
    if ( INVALID_HANDLE_VALUE == m_FrameTableFileHandle )
    {
        CloseHandle( m_CapFileHandle );
        delete[] m_szCapFileName;
        delete[] m_szDumpFileName;
        hr = MAKE_HRESULT( 1, FACILITY_WIN32, GetLastError() );
        goto Exit;
    }

    // write the empty header to the file.
    if (! WriteFile( m_CapFileHandle, (LPCVOID)&m_objCFHeader, CAPTURE_FILE_HEADER_SIZE, &dwBytesWritten, NULL ) )
    {
        CloseHandle( m_CapFileHandle );
        CloseHandle( m_FrameTableFileHandle );
        delete[] m_szCapFileName;
        delete[] m_szDumpFileName;
        hr = MAKE_HRESULT( 1, FACILITY_WIN32, GetLastError() );
        goto Exit;
    }

    // set file offsets
    m_bIsComplete = FALSE;
    m_dwCurFileSize = CAPTURE_FILE_HEADER_SIZE + sizeof(FRAMETABLE);
    m_dwFileOffset = CAPTURE_FILE_HEADER_SIZE;

Exit:
    return hr;
}

// -------------------------------------------------
//  Close:  Closes the file.  Building the final
//      capture file.
// -------------------------------------------------
HRESULT CDynCaptureFile::Close()
{
    HRESULT hr = S_OK;
    DWORD dwBytesWritten = 0;
    DWORD dwBytesRead = 0;
    DWORD dwFrameDescriptorOffset = 0;
    DWORD dwRes = 0;                    // temp pointer for setfilepointer result.
    BYTE  bytBuffer[128];               // used to read values from dump file.

    // ensure we should be here.
    if ( m_bIsComplete )
    {
        hr = E_CAPFILE_ALREADY_COMPLETE;
        goto Exit;
    }

    XOMASSERT( m_CapFileHandle != INVALID_HANDLE_VALUE );
    XOMASSERT( m_FrameTableFileHandle != INVALID_HANDLE_VALUE );

    // modify the flag.
    m_bIsComplete = TRUE;

    // set teh file pointer of the dump file back to the beginning.
    dwRes = SetFilePointer( m_FrameTableFileHandle, (-1 * m_objFrameTable.FrameCount * sizeof(DWORD)), NULL, FILE_CURRENT );
    if ( dwRes == INVALID_SET_FILE_POINTER )
    {
        // ok... all hell has broken loose... may God have mercy on us all.
        hr = MAKE_HRESULT( 1, FACILITY_WIN32, GetLastError() );
        goto Exit;    
    }

    // move the dump file into 
    while ( TRUE )
    {
        BOOL bIsEOF = FALSE;
        // read 128 bytes from the file.
        if ( !ReadFile( m_FrameTableFileHandle, bytBuffer, DEFAULT_READ_SIZE, &dwBytesRead, NULL ) )
        {
            if ( GetLastError() == ERROR_HANDLE_EOF )
            {
                bIsEOF = TRUE;
            }
            else
            {
                // ok... all hell has broken loose... may God have mercy on us all.
                hr = MAKE_HRESULT( 1, FACILITY_WIN32, GetLastError() );
                goto Exit;    
            }
        }

        // write to the end of the capture file
        if (! WriteFile( m_CapFileHandle, (LPCVOID)bytBuffer, dwBytesRead, &dwBytesWritten, NULL ) )
        {
            hr = MAKE_HRESULT( 1, FACILITY_WIN32, GetLastError() );
            goto Exit;
        }
    
        // see if we've read all the data.
        if ( bIsEOF || dwBytesRead == 0 )
        {
            break;
        }
    }
    
    // destroy the dump file. NOTE:  This is not an important action. Do not fail on error.
    CloseHandle( m_FrameTableFileHandle );
    DeleteFileA( m_szDumpFileName );

    // clean up offset values.
    m_objCFHeader.FrameTableLength = m_objFrameTable.FrameCount * sizeof(DWORD);
    m_objCFHeader.FrameTableOffset = m_dwFileOffset;

    // move the file pointer for the capture file.
    dwRes = SetFilePointer( m_CapFileHandle, 0, NULL, FILE_BEGIN );
    if ( dwRes == INVALID_SET_FILE_POINTER )
    {
        // ok... all hell has broken loose... may God have mercy on us all.
        hr = MAKE_HRESULT( 1, FACILITY_WIN32, GetLastError() );
        goto Exit;    
    }

    // re-write the file header.
    if (! WriteFile( m_CapFileHandle, (LPCVOID)&m_objCFHeader, sizeof(CAPTUREFILE_HEADER_VALUES), &dwBytesWritten, NULL ) )
    {
        hr = MAKE_HRESULT( 1, FACILITY_WIN32, GetLastError() );
        goto Exit;
    }

    CloseHandle( m_CapFileHandle );

Exit:
    return hr;
}

// -------------------------------------------------
//  SaveFrame:  Saves a frame to the capture file 
//   the file offsets to the frame table dump file.
// -------------------------------------------------
HRESULT CDynCaptureFile::SaveFrame( BYTE *pBytFrame )
{
    FRAME *pFrame = (FRAME*)pBytFrame;
    HRESULT hr = S_OK;
    DWORD dwCurOffset = 0;
    DWORD dwDataSize = 0;
    DWORD dwBytesWritten = 0;

    // ensure we should be here.
    if ( m_bIsComplete )
    {
        hr = E_CAPFILE_ALREADY_COMPLETE;
        goto Exit;
    }

    XOMASSERT( m_CapFileHandle != INVALID_HANDLE_VALUE );
    XOMASSERT( m_FrameTableFileHandle != INVALID_HANDLE_VALUE );
    XOMASSERT( pBytFrame != NULL );

    // calculate the byte offset.
    dwCurOffset = m_dwFileOffset;

    // re-calculate the offset after this frame.
    dwDataSize = sizeof(FRAME) + pFrame->FrameLength ;

    // ensure the capfile is not full. 
    if ( dwDataSize + sizeof(DWORD) + m_dwCurFileSize > m_dwMaxFileSize )
    {
        hr = E_CAPFILE_FULL;
        goto Exit;
    }

    // write to the capture file.
    if (! WriteFile( m_CapFileHandle, (LPCVOID)pBytFrame, dwDataSize, &dwBytesWritten, NULL ) )
    {
        hr = MAKE_HRESULT( 1, FACILITY_WIN32, GetLastError() );
        goto Exit;
    }
    
    if ( dwBytesWritten != dwDataSize )
    {
        hr = MAKE_HRESULT( 1, FACILITY_WIN32, GetLastError() );
        goto Exit;    
    }
    
    // set the offsets.
    m_dwFileOffset = m_dwFileOffset + dwBytesWritten;
    m_dwCurFileSize =  m_dwCurFileSize + dwBytesWritten;

    // write to the dump file.
    if (! WriteFile( m_FrameTableFileHandle, (LPCVOID)&dwCurOffset, sizeof(DWORD), &dwBytesWritten, NULL ) )
    {
        hr = MAKE_HRESULT( 1, FACILITY_WIN32, GetLastError() );
        goto Exit;
    }

    // ensure we've written the entire offset to this file or roll it back.
    if ( dwBytesWritten != sizeof(DWORD) )
    {
        DWORD dwRes;

        // re-set the file pointer
        dwRes = SetFilePointer( m_FrameTableFileHandle, -1 * dwBytesWritten, NULL, FILE_CURRENT );
        if ( dwRes == INVALID_SET_FILE_POINTER )
        {
            // ok... all hell has broken loose... may God have mercy on us all.
            hr = MAKE_HRESULT( 1, FACILITY_WIN32, GetLastError() );
            goto Exit;    
        }
    }

    m_objFrameTable.FrameCount++;
    m_objFrameTable.FrameTableLength = m_objFrameTable.FrameCount * sizeof(DWORD);
    m_dwCurFileSize =  m_dwCurFileSize + dwBytesWritten;

    // todo: (lohab) Make a rollback feature to remove entry from capture file if any file write fails.

Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wiredatadump\wiredatadump.cs ===
using System;
using System.Web;
using System.IO;
using System.Net;
using System.Text;
using System.Net.Sockets;
using System.Collections.Specialized;
using System.Text.RegularExpressions;
using System.Threading;
using System.Diagnostics;
using System.Collections;
using System.Reflection;
using System.Security.Cryptography;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.protocol;


namespace xonline.tools.wiredatadump
{
    public class wiredatadump
    {

        public static void Main(string[] args)
        {
            if (args.Length < 2)
            {
                Console.WriteLine("usage: wiredatadump <wiredata class> <protocol file> [<filetype>] [outputfile]");
                Console.WriteLine();
                Console.WriteLine("Example: wiredatadump xonline.common.protocol.AddRequest addreq.txt 1");
                Console.WriteLine();
                Console.WriteLine("Protocol file can be in one of several formats (1 is the default):");
                Console.WriteLine();
                Console.WriteLine("filetype 1 is the hex portion of netmon capture, i.e.");
                Console.WriteLine("  30 D4 11 82 37 BA 37 5A 6E 64 43 A0 50 19");
                Console.WriteLine("  43 C8 7B 72 00 00");
                Console.WriteLine();
                Console.WriteLine("filetype 2 is a hex dump format like from hd or copying from netmon, i.e,");
                Console.WriteLine("  00004400   0a 7d 89 00 00 04 02 7b 89 00 00 04 17 6f e4 00  .}.....{.....o..");
                Console.WriteLine("  00004410   00 0a 02 02 7b 89 00 00 04 25 fe 07 e5 00 00 0a  ....{....%......");
                Console.WriteLine();
                Console.WriteLine("filetype 2 also works for data copied from the data section of Event Viewer:");
                Console.WriteLine("  0000: d1 07 51 54 06 c0 03 00   .QT...");
                Console.WriteLine("  0008: 00 00 09 00 00 00 c1 f0   ......");
                Console.WriteLine();
                Console.WriteLine("filetype 3 is the data protion of an Windows event, i.e.");
                Console.WriteLine("  30D4118237BA375A6E6443A0501943C87B720000");
                return;
            }

            Regex   regexLineFilter = null;
            Regex   byteFilter = null;
            int     fileType = 1;
            string  outputFileName = null;

            if (args.Length > 2)
                fileType = int.Parse(args[2]);

            if (args.Length > 3)
                outputFileName = args[3];

            switch (fileType)
            {
                case 1:
                    byteFilter = new Regex(@"([A-Fa-f0-9]{2})[\ ]?");
                    break;

                case 2:
                    regexLineFilter = new Regex(@"[A-Fa-f0-9]{4,8}[:]?[\ ]+(([A-Fa-f0-9]{2}[\ ]?)+)");
                    byteFilter = new Regex(@"([A-Fa-f0-9]{2})[\ ]?");
                    break;

                case 3:
                    byteFilter = new Regex(@"([A-Fa-f0-9]{2})");
                    break;

                default:
                    throw new ApplicationException("Unknown file type: " + fileType);
            }

            StreamReader reader = File.OpenText(args[1]);

            ArrayList strbytes = new ArrayList();

            string protclass = args[0];
            if (protclass.IndexOf('.') == -1)
            {
                protclass = "xonline.common.protocol." + protclass;
            }

            string line = reader.ReadLine();

            while (line != null)
            {
                line = line.Trim();

                if (line != "")
                {
                    // Apply the line filter to clean up extraneous characters
                    if (null != regexLineFilter)
                    {
                        Match match = regexLineFilter.Match(line);

                        if (0 == match.Groups.Count)
                            continue;

                        line = match.Groups[1].Value;

//                        Console.WriteLine("New line: " + line);
                    }

                    // Match all the bytes in this line
                    MatchCollection matches = byteFilter.Matches(line);

                    foreach (Match match in matches)
                    {
                        strbytes.Add(match.Groups[1].Value);
                    }
                }

                line = reader.ReadLine();
            }

            // Convert the text to binary bytes
            byte[] bytes = new byte[strbytes.Count];

            for (int i = 0; i < strbytes.Count; i++)
            {
//                Console.Write("'{0}' ", strbytes[i]);
                bytes[i] = Convert.ToByte((string)strbytes[i], 16);
            }

            if (null != outputFileName)
            {
                using (FileStream outputStream = new FileStream(outputFileName, FileMode.Create))
                {
                    outputStream.Write(bytes, 0 /* offset */, bytes.Length);
                }
            }

            MemoryStream stream = new MemoryStream(bytes);
            BinaryReader binreader = new BinaryReader(stream);
            Assembly asm = Assembly.GetExecutingAssembly();
            WireData ob;

            if (protclass.ToLower() == "xonline.common.protocol.reqstatpost")
            {
                // special case for statspost
                ReqStatPost req = new ReqStatPost();

                req.ReadFrom(binreader);
                Console.WriteLine(req.ToString());

            }
            /*
            else if (protclass.ToLower() == "xonline.common.protocol.sginfo")
            {
                // special case for sginfo
                SGInfo sginfo = new SGInfo(binreader);
                Console.WriteLine(sginfo.ToString());
            }
            */
            else
            {
                ob = (WireData)asm.CreateInstance(protclass);

                if (null == ob)
                    throw new ApplicationException(String.Format("Protocol class {0} not found.", protclass));

                ob.ReadStream(binreader);

                Console.WriteLine(ob.ToString());
            }


            if (stream.Position < stream.Length)
            {
                Console.WriteLine("Bytes consumed: " + stream.Position + "  Bytes left: " + (stream.Length - stream.Position).ToString());
                Console.WriteLine("Trying to consume remaining bytes with TeamTickets (ignore if this isn't expected)...");

                try
                {
                    TeamTickets tix = new TeamTickets(binreader);
                    Console.WriteLine(tix.ToString());
                }
                catch (Exception e)
                {
                    Console.WriteLine("Error reading team tickets:\r\n" + e.ToString());
                }
            }

            if (stream.Position < stream.Length)
            {
                Console.WriteLine("Bytes consumed: " + stream.Position + "  Bytes left: " + (stream.Length - stream.Position).ToString());
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wiretap\DynCaptureFile.h ===
//-----------------------------------------------------------------------------
//  Microsoft (R) XWireTap (tm). 
//  Copyright (C) 2002. All rights reserved.
//
//  FILE: DynCaptureFile.h
//
//  Interface for NetMon Capture file writer.
//   Creates file of both a fixed size and variable size.
//-----------------------------------------------------------------------------

#pragma once

//-----------------------------------------------------------------------------
//  Includes
//-----------------------------------------------------------------------------
#include <netmon.h>

//-----------------------------------------------------------------------------
//  Definitions
//-----------------------------------------------------------------------------
#define FACILITY_CAPFILE                50                      
#define CAPTURE_FILE_HEADER_SIZE        128                     

//-----------------------------------------------------------------------------
//  Return Values
//-----------------------------------------------------------------------------
#define E_CAPFILE_ALREADY_OPEN          MAKE_HRESULT( 1, FACILITY_CAPFILE, 1 ); 
#define E_CAPFILE_FULL                  MAKE_HRESULT( 1, FACILITY_CAPFILE, 2 ); 
#define E_CAPFILE_ALREADY_COMPLETE      MAKE_HRESULT( 1, FACILITY_CAPFILE, 3 ); 


class CDynCaptureFile
{
public:
    CDynCaptureFile( void );                     
    virtual ~CDynCaptureFile(void);

    // -------------------------------------------------
    //  Open:  Opens a capture file of a fixed size.
    // -------------------------------------------------
    HRESULT Open(   char *szFilename, 
                    DWORD FileSize  );       

    // -------------------------------------------------
    //  Open:  Opens a file of variable size.
    // -------------------------------------------------
    HRESULT Open(   char *szFilename );

    // -------------------------------------------------
    //  Close:  Closes the file.  Building the final
    //      capture file.
    // -------------------------------------------------
    HRESULT Close();

    // -------------------------------------------------
    //  SaveFrame:  Saves a frame to the capture file 
    //   the file offsets to the frame table dump file.
    // -------------------------------------------------
    HRESULT SaveFrame( BYTE *pBytFrame );

private:
    HANDLE m_CapFileHandle;
    HANDLE m_FrameTableFileHandle;

    DWORD  m_dwCurFileSize;
    DWORD  m_dwMaxFileSize;
    DWORD  m_dwFileOffset;

    char   *m_szCapFileName;    
    char   *m_szDumpFileName;    

    CAPTUREFILE_HEADER_VALUES   m_objCFHeader;                  // capture file header...  value offsets
    FRAMETABLE                  m_objFrameTable;                // frame table object.
    BOOL                        m_bIsComplete;                  // whether the file is complete or not.

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wiretap\ExprBlder.h ===
//-----------------------------------------------------------------------------
//  Microsoft (R) XWireTap (tm). 
//  Copyright (C) 2002. All rights reserved.
//
//  FILE: ExprBlder.h
//
//  Interface ExprBlder Implementation.
//-----------------------------------------------------------------------------

#pragma once

//-----------------------------------------------------------------------------
// Includes
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// CExprBlder
//-----------------------------------------------------------------------------

class CExprBlder
{
public:
    CExprBlder( );
    virtual ~CExprBlder(void);

    static HRESULT BuildWireTapIpExpr( BYTE *pbytExpr /*IN, OUT*/, 
                                       DWORD *pdwExprSize /*IN, OUT*/, 
                                       DWORD dwId /*IN*/, 
                                       BYTE *pIPBuffer /*IN*/,
                                       DWORD dwIPBufferSize );

    static HRESULT BuildWireTapAuthExprMachine( BYTE *pbytExpr /*IN, OUT*/, 
                                       DWORD *pdwExprSize /*IN, OUT*/, 
                                       DWORD dwId /*IN*/, 
                                       char *szPUID /*IN*/);

    static HRESULT BuildWireTapAuthExprUser( BYTE *pbytExpr /*IN, OUT*/, 
                                       DWORD *pdwExprSize /*IN, OUT*/, 
                                       DWORD dwId /*IN*/, 
                                       char *szPUID /*IN*/);

    static HRESULT BuildCloseWireTap( BYTE *pbytExpr /*IN, OUT*/, 
                                       DWORD *pdwExprSize /*IN, OUT*/, 
                                       DWORD dwId /*IN*/ );

    static HRESULT BuildReadAllTrafficQuery( BYTE *pbytExpr /*IN, OUT*/, 
                                       DWORD *pdwExprSize /*IN, OUT*/, 
                                       DWORD dwId /*IN*/ );
                                   
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wiretap\HashTable.h ===
//--------------------------------------------------------------------
//  Microsoft (R) XWireTap (tm). 
//  Copyright (C) 2002. All rights reserved.
//
//  HashTable.h: interface for the CHashTable and CDOSList class.
//--------------------------------------------------------------------

//--------------------------------------------------------------------
//  Includes
//--------------------------------------------------------------------
#include <time.h>
#include "ListMacros.h"

//--------------------------------------------------------------------
//  Definitions
//--------------------------------------------------------------------

#if !defined(AFX_HASHTABLE_H__D5F38145_64C1_4E36_96BA_E28905DC886F__INCLUDED_)
#define AFX_HASHTABLE_H__D5F38145_64C1_4E36_96BA_E28905DC886F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


//--------------------------------------------------------------------
//  Constants
//--------------------------------------------------------------------
#define HASH_KEY_SIZE                           4

//--------------------------------------------------------------------
//  TYPES/STRUCTURES
//--------------------------------------------------------------------

typedef struct _HashListNode
{
    // hash table pointers
    ListNode            m_Link;
    BYTE                m_pKey[HASH_KEY_SIZE];
    
} HashListNode;


//--------------------------------------------------------------------
//  Global functions.
//--------------------------------------------------------------------

//--------------------------------------------------------------------
//  Class:  CHashTable
//--------------------------------------------------------------------
class CHashTable  
{
public:
    CHashTable();
    virtual ~CHashTable();

    //-----------------------------------------------
    // -- Methods
    HashListNode       *Lookup( const BYTE *pKey );
    void                Insert( HashListNode *plnIns );
    void                Delete( HashListNode *plnDel );

    // computes the hash function for this table.
    int                 Compute( const BYTE *pKey );

    BOOL                IsValid();

protected:
    //-----------------------------------------------
    // -- Attributes
    HashListNode*       m_pTable;                       // pointer to the table.
    int                 m_nTableSize;                   // size of the table
    int                 m_nNumOfEnt;                    // number of entries

private:
    CRITICAL_SECTION    m_csHashTable;                  // the cs around the hash table.

};

#endif // !defined(AFX_HASHTABLE_H__D5F38145_64C1_4E36_96BA_E28905DC886F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wiretap\ListMacros.h ===
//-----------------------------------------------------------------------------
//  Microsoft (R) XWireTap (tm). 
//  Copyright (C) 2002. All rights reserved.
//
//  FILE: ListMacros.h
//
//  List macros for quick operations
//-----------------------------------------------------------------------------

#pragma once

//-----------------------------------------------------------------------------
//
//  ----  NODE FORMAT FOR INTEGRATION
//  ListNode should be the first object defined for your struct to use this.
//
typedef struct _ListNode
{
    // hash table pointers
    _ListNode      *m_pPrev;
    _ListNode      *m_pNext;

} ListNode;
//
//-----------------------------------------------------------------------------

//--------------------------------------------------------------------
//  The following macros are defined to simplify list manipulation
//      calls.  Logically they are procedures but create less overhead
//      as macros.
//--------------------------------------------------------------------
#define InitializeListHead(ListHead) {\
    (ListHead)->m_pNext = (ListHead)->m_pPrev = (ListNode*)(ListHead); \
    }

#define IsListEmpty(ListHead) \
    ((ListHead)->m_pNext == (ListHead)->m_pNext->m_pNext)

#define RemoveEntryList(Entry) {\
    ListNode *pPrev;\
    ListNode *pNext;\
    pNext = (Entry)->m_pNext;\
    pPrev = (Entry)->m_pPrev;\
    pPrev->m_pNext = pNext;\
    pNext->m_pPrev = pPrev;\
    (Entry)->m_pNext = NULL; \
    (Entry)->m_pPrev = NULL; \
    }

#define InsertTailList(ListHead,Entry) {\
    ListNode *pPrev;\
    ListNode *_EX_ListHead;\
    _EX_ListHead = (ListHead);\
    pPrev = _EX_ListHead->m_pPrev;\
    (Entry)->m_pNext = pPrev->m_pNext;\
    (Entry)->m_pPrev = pPrev;\
    pPrev->m_pNext = (Entry);\
    _EX_ListHead->m_pPrev = (Entry);\
    }

//#endif __LISTMACROS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wiretap\MgmtInterface.h ===
//-----------------------------------------------------------------------------
//  Microsoft (R) XWireTap (tm). 
//  Copyright (C) 2002. All rights reserved.
//
//  FILE: MgmtInterface.h
//
//  Interface MgmtInterface Implementation.
//-----------------------------------------------------------------------------

#pragma once

//-----------------------------------------------------------------------------
// Includes
//-----------------------------------------------------------------------------
#include "ListMacros.h"

//-----------------------------------------------------------------------------
// Pre-Declarations
//-----------------------------------------------------------------------------
class CWireTap;
class CXMgmtControlCallback;
class CMgmtInterface;


//-----------------------------------------------------------------------------
// Types/Structures
//-----------------------------------------------------------------------------
typedef HRESULT (*MgmtCmdHandler)(
    IN LPVOID lpCmdData,
    IN CMgmtInterface *pMgmtInf,
    IN DWORD dwRequestId,
    IN CXomControlResponseInterface *pResponseInterface,
    IN DWORD argc,
    IN LPCSTR argv[]
    );

typedef struct _XomMgmtCmd {
    char*           szCmdName;
    DWORD           dwCmdNameLen;
    MgmtCmdHandler  pfnCmdProc;
    char*           szCmdHelp;
    LPVOID          lpData;
} XomMgmtCmd;

//-----------------------------------------------------------------------------
// CMgmtInterface
//-----------------------------------------------------------------------------

class CMgmtInterface
{
public:
    CMgmtInterface( );
    virtual ~CMgmtInterface(void);

    // call before using.
    HRESULT Initialize( DWORD dwNumOfCmds );
    HRESULT Terminate();

    // sycn TCPIP XMGMT connection to specified address.
    HRESULT SendRequest( char *szSG, LPCSTR lpszRequest, char* szResponse, DWORD dwResponseBufferSize, DWORD *pdwBytesRecv, HRESULT *pHr );

    HRESULT RegisterCommand( XomMgmtCmd newCmd );

    DWORD   GetNumberOfRegisteredCommands() { return m_dwNumRegCmds; }

    friend CXMgmtControlCallback;

    static HRESULT MgmtCmdHelp(    
                                IN LPVOID lpCmdData,
                                IN CMgmtInterface *pMgmtInf,
                                IN DWORD dwRequestId,
                                IN CXomControlResponseInterface *pResponseInterface,
                                IN DWORD argc,
                                IN LPCSTR argv[] );

    static HRESULT MgmtCmdAddTap(    
                                IN LPVOID lpCmdData,
                                IN CMgmtInterface *pMgmtInf,
                                IN DWORD dwRequestId,
                                IN CXomControlResponseInterface *pResponseInterface,
                                IN DWORD argc,
                                IN LPCSTR argv[] );

    static HRESULT MgmtCmdListTaps(    
                                IN LPVOID lpCmdData,
                                IN CMgmtInterface *pMgmtInf,
                                IN DWORD dwRequestId,
                                IN CXomControlResponseInterface *pResponseInterface,
                                IN DWORD argc,
                                IN LPCSTR argv[] );

    static HRESULT MgmtCmdCloseTap(    
                                IN LPVOID lpCmdData,
                                IN CMgmtInterface *pMgmtInf,
                                IN DWORD dwRequestId,
                                IN CXomControlResponseInterface *pResponseInterface,
                                IN DWORD argc,
                                IN LPCSTR argv[] );

    static HRESULT MgmtCmdRollTap(    
                                IN LPVOID lpCmdData,
                                IN CMgmtInterface *pMgmtInf,
                                IN DWORD dwRequestId,
                                IN CXomControlResponseInterface *pResponseInterface,
                                IN DWORD argc,
                                IN LPCSTR argv[] );

    static HRESULT MgmtCmdShutdown(    
                                IN LPVOID lpCmdData,
                                IN CMgmtInterface *pMgmtInf,
                                IN DWORD dwRequestId,
                                IN CXomControlResponseInterface *pResponseInterface,
                                IN DWORD argc,
                                IN LPCSTR argv[] );

    static HRESULT MgmtCmdMonitor(    
                                IN LPVOID lpCmdData,
                                IN CMgmtInterface *pMgmtInf,
                                IN DWORD dwRequestId,
                                IN CXomControlResponseInterface *pResponseInterface,
                                IN DWORD argc,
                                IN LPCSTR argv[] );


    // overrides
    void *operator new(size_t len) { return XAlloc(len); }
    void operator delete(void *pv) { XFree(pv); }
   

protected:
    CXMgmtControlCallback* m_pMgmtHandler;

    XomMgmtCmd *m_pCmdList;
    DWORD m_dwMaxCmds;
    DWORD m_dwNumRegCmds;    
    
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wiretap\ExprBlder.cpp ===
//-----------------------------------------------------------------------------
//  Microsoft (R) XWireTap (tm). 
//  Copyright (C) 2002. All rights reserved.
//
//  FILE: ExprBlder.cpp
//
//  Implementation of the expression builder 
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  Include
//-----------------------------------------------------------------------------
#include "StdAfx.h"

//-----------------------------------------------------------------------------
//  Constants
//-----------------------------------------------------------------------------
const DWORD c_dwMachineValueOffset = (DWORD)(&((XKERB_AD_XENON*)0)->qwXboxID);
const DWORD c_dwUserStructOffset   = (DWORD)(&((XKERB_AD_XENON*)0)->users);

//-----------------------------------------------------------------------------
//  DEBUG Areas
//-----------------------------------------------------------------------------
XomImportArea(XWireTap);

//-----------------------------------------------------------------------------
//  CExprBlder Implementation
//-----------------------------------------------------------------------------
CExprBlder::CExprBlder()
{    
}

CExprBlder::~CExprBlder(void)
{
}

//-----------------------------------------------------------------------------
//  BuildWireTapIpExpr:  
//-----------------------------------------------------------------------------
HRESULT CExprBlder::BuildWireTapIpExpr( BYTE *pbytExpr /*IN, OUT*/, 
                                       DWORD *pdwExprSize /*IN, OUT*/, 
                                       DWORD dwId /*IN*/, 
                                       BYTE *pIPBuffer /*IN*/,
                                       DWORD dwIPBufferSize )
{
    HRESULT hr = S_OK;
    int nBytesWritten = 0;
    char *szIP = new char[ (dwIPBufferSize * 2) + 1 ];  // each byte is 2 hex values.
    if ( szIP == NULL )
    {
        // out of bloody memory
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    ZeroMemory( szIP, sizeof( szIP ) );

    // get the IP in a string format.
    nBytesWritten = safe_snprintf( szIP, (dwIPBufferSize * 2) + 1, "%.8X", HTONL(*((DWORD*)pIPBuffer)) );
        
    // create the statement.
    nBytesWritten = safe_snprintf( (char*)pbytExpr, *pdwExprSize, "e :SG configure_string \"Wiretap{ id %d ipexpr 2200%.2X%s}\"", 
                                    dwId, 
                                    sizeof(DWORD), 
                                    szIP );

    delete[] szIP;

    XomTrace1( XWireTap, L_LOW, "CExprBlder::BuildWireTapIpExpr:  MSG -> %s", pbytExpr );
    // ensure no overrun.
    if ( nBytesWritten < 0 )
    {
        hr = E_FAIL;
        goto Exit;
    }

Exit:
    return hr;
}

//-----------------------------------------------------------------------------
//  BuildWireTapAuthExprMachine:  builds a auth expression for the SG for
//              machine PUID lookups
//-----------------------------------------------------------------------------
HRESULT CExprBlder::BuildWireTapAuthExprMachine( BYTE *pbytExpr /*IN, OUT*/, 
                                       DWORD *pdwExprSize /*IN, OUT*/, 
                                       DWORD dwId /*IN*/, 
                                       char *szPUID /*IN*/)
{
    HRESULT hr = S_OK;
    int nBytesWritten = 0;
    char *szPUIDByteString;
    char *szPUIDStartingMarker = szPUID;
    int nStringSize = 0;

    XOMASSERT( szPUID != NULL );

    // remove the 0x if the PUID starts with it.
    if ( szPUIDStartingMarker[0] == '0' && 
            ( szPUIDStartingMarker[1] == 'x' || szPUIDStartingMarker[1] == 'X' ) )
    {
        szPUIDStartingMarker = szPUIDStartingMarker + 2;
    }

    // determine the size and whether this string has enough bytes.
    nStringSize = strlen( szPUIDStartingMarker );
    if ( ( nStringSize % 2 ) == 1 )
    {
        // not an event number of characters.  Need to set leading 0.
        szPUIDByteString = (char*)(XAlloc( (nStringSize + 2) * sizeof(char) ));
        szPUIDByteString[0] = '0';
        strncpy( (szPUIDByteString + 1), szPUIDStartingMarker, nStringSize );
        nStringSize++;        
    }
    else
    {
        // an event number of characters.  No need for leading 0.
        szPUIDByteString = (char*)(XAlloc( (nStringSize + 1) * sizeof(char) ));
        strncpy( (szPUIDByteString), szPUIDStartingMarker, nStringSize );
    }

    szPUIDByteString[nStringSize] = '\0';
    
    // create the statement.
    nBytesWritten = safe_snprintf( (char*)pbytExpr, *pdwExprSize, "e :SG configure_string \"Wiretap{ id %d authexpr 2A%.2X%.2X%s}\"", 
                                    dwId, 
                                    c_dwMachineValueOffset, 
                                    nStringSize/2, 
                                    szPUIDByteString );

    XomTrace1( XWireTap, L_LOW, "CExprBlder::BuildWireTapAuthExprMachine:  MSG -> %s", pbytExpr );

    // ensure no overrun.
    if ( nBytesWritten < 0 )
    {
        hr = E_FAIL;
        goto Exit;
    }

Exit:
    XFree( szPUIDByteString );
    return hr;
}

//-----------------------------------------------------------------------------
//  BuildWireTapAuthExprUser -- builds a user auth expression.
//-----------------------------------------------------------------------------
HRESULT CExprBlder::BuildWireTapAuthExprUser( BYTE *pbytExpr /*IN, OUT*/, 
                                       DWORD *pdwExprSize /*IN, OUT*/, 
                                       DWORD dwId /*IN*/, 
                                       char *szPUID /*IN*/)
{
    HRESULT hr = S_OK;
    int nBytesWritten = 0;
    char *szPUIDStartingMarker = szPUID;
    DWORD dwValueSize = 0;
    char *szPUIDByteString;
    int nStringSize = 0;

    // remove the 0x if the PUID starts with it.
    if ( szPUIDStartingMarker[0] == '0' && 
            ( szPUIDStartingMarker[1] == 'x' || szPUIDStartingMarker[1] == 'X' ) )
    {
        szPUIDStartingMarker = szPUIDStartingMarker + 2;
    }

    // determine the size and whether this string has enough bytes.
    nStringSize = strlen( szPUIDStartingMarker );
    if ( ( nStringSize % 2 ) == 1 )
    {
        // not an event number of characters.  Need to set leading 0.
        szPUIDByteString = (char*)(XAlloc( (nStringSize + 2) * sizeof(char) ));
        szPUIDByteString[0] = '0';
        strncpy( (szPUIDByteString + 1), szPUIDStartingMarker, nStringSize );
        nStringSize++;        
    }
    else
    {
        // an event number of characters.  No need for leading 0.
        szPUIDByteString = (char*)(XAlloc( (nStringSize + 1) * sizeof(char) ));
        strncpy( (szPUIDByteString), szPUIDStartingMarker, nStringSize );
    }

    szPUIDByteString[nStringSize] = '\0';

    dwValueSize = nStringSize/2;
    // create the statement.
    nBytesWritten = safe_snprintf( (char*)pbytExpr, *pdwExprSize, "e :SG configure_string \"Wiretap{ id %d authexpr 11112A%.2X%.2X%s2A%.2X%.2X%s112A%.2X%.2X%s2A%.2X%.2X%s }\"", 
                                    dwId, 
                                    c_dwUserStructOffset, 
                                    dwValueSize, 
                                    szPUIDByteString,                                    
                                    c_dwUserStructOffset + (sizeof(XUID) ), 
                                    dwValueSize, 
                                    szPUIDByteString,                                   
                                    c_dwUserStructOffset + (sizeof(XUID) * 2), 
                                    dwValueSize, 
                                    szPUIDByteString,                                    
                                    c_dwUserStructOffset + (sizeof(XUID) * 3), 
                                    dwValueSize, 
                                    szPUIDByteString );

    XomTrace1( XWireTap, L_LOW, "CExprBlder::BuildWireTapAuthExprUser:  MSG -> %s", pbytExpr );

    // ensure no overrun.
    if ( nBytesWritten < 0 )
    {
        hr = E_FAIL;
        goto Exit;
    }

Exit:
    XFree( szPUIDByteString );
    return hr;
}

//-----------------------------------------------------------------------------
//  BuildReadAllTrafficQuery: builds a command to get all traffic from the SG.
//-----------------------------------------------------------------------------
HRESULT CExprBlder::BuildReadAllTrafficQuery( BYTE *pbytExpr /*IN, OUT*/, 
                                       DWORD *pdwExprSize /*IN, OUT*/, 
                                       DWORD dwId /*IN*/ )
{
    HRESULT hr = S_OK;
    int nBytesWritten = 0;

    // create the statement.
    nBytesWritten = safe_snprintf( (char*)pbytExpr, *pdwExprSize, "e :SG configure_string \"Wiretap{ id %d ipexpr 01 }\"", dwId);

    XomTrace1( XWireTap, L_LOW, "CExprBlder::BuildWireTapAuthExprUser:  MSG -> %s", pbytExpr );

    // ensure no overrun.
    if ( nBytesWritten < 0 )
    {
        hr = E_FAIL;
        goto Exit;
    }

Exit:
    return hr;
}

//-----------------------------------------------------------------------------
//  BuildCloseWireTap: builds the close wiretap express and places it in
//              the given buffer.
//-----------------------------------------------------------------------------
HRESULT CExprBlder::BuildCloseWireTap( BYTE *pbytExpr /*IN, OUT*/, 
                                       DWORD *pdwExprSize /*IN, OUT*/, 
                                       DWORD dwId /*IN*/ )
{
    HRESULT hr = S_OK;
    int nBytesWritten = 0;

    // create the statement.
    nBytesWritten = safe_snprintf( (char*)pbytExpr, *pdwExprSize, "e :SG configure_string \"Wiretap{ id %d }\"", dwId);

    XomTrace1( XWireTap, L_LOW, "CExprBlder::BuildWireTapAuthExprUser:  MSG -> %s", pbytExpr );

    // ensure no overrun.
    if ( nBytesWritten < 0 )
    {
        hr = E_FAIL;
        goto Exit;
    }

Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wiretap\HashTable.cpp ===
//--------------------------------------------------------------------
//  Microsoft (R) XWireTap (tm). 
//  Copyright (C) 2002. All rights reserved.
//
//  HashTable.cpp: implementation of the CHashTable
//    class.
//--------------------------------------------------------------------

//--------------------------------------------------------------------
// Includes
//--------------------------------------------------------------------
#include "stdafx.h"

//--------------------------------------------------------------------
// Definitions
//--------------------------------------------------------------------

//  Prime Numbers
//        { 37,59,89,139,227,359,577,929,1499,2423,3919,6337,10253,16573,
//        26821,43391,70207,113591,183797,297377,481171,778541,1259701,2038217,3297913,5336129,
//        8633983,13970093,22604069,36574151,59178199,95752333,154930511,250682837,405613333,
//        656296153,1061909479,1718205583,2780115059,0xFFFFFFFF};

// used for logging and debugging
XomDefineArea(XWireTapHash);

//--------------------------------------------------------------------
// CONSTANTS
//--------------------------------------------------------------------

// Hash table size -- currently constants with prime numbers.
const int c_nHashTableSize          = 297377;        

//--------------------------------------------------------------------
//  HashTable -- definitions.
//--------------------------------------------------------------------

//--------------------------------------------------------------------
//  Local Function Declarations
//--------------------------------------------------------------------

//--------------------------------------------------------------------
// Class:  CHashTable
//--------------------------------------------------------------------

CHashTable::CHashTable()
{
    int nCount;

    m_nTableSize    = c_nHashTableSize;
    m_nNumOfEnt     = 0;

    // create the table
    m_pTable = new HashListNode[m_nTableSize];
    if ( m_pTable == NULL )
    {
        // log a problem here... without this list... we can't continue
        XomTrace0(XWireTapHash, L_HIGH, "HASH:(CHashTable)  Failed to attain enough memory for the hash table.");
        XomNtEvent( XEVENT_XWIRETAP_GENERIC_ERROR, "HASH:(CHashTable)  Failed to attain enough memory for the hash table.");
        XOMASSERT(0);       
        return;
    }
    
    // initialize the entries.
    for ( nCount = 0; nCount < m_nTableSize; nCount++ )
    {
        InitializeListHead( &( m_pTable[nCount].m_Link ) );
    }

    InitializeCriticalSection( &m_csHashTable );
    XomTrace0(XWireTapHash, L_NORMAL,  "HASH:(CHashTable)  Hash table successfully created.");
    
}

CHashTable::~CHashTable()
{
    // delete the table.
    delete[] m_pTable;

    // then clear the memory.
    m_pTable        = NULL;
    m_nTableSize    = 0;

    // delete the critical section.
    DeleteCriticalSection( &m_csHashTable );

    XomTrace0(XWireTapHash, L_NORMAL,  "HASH:(~CHashTable)  Hash table successfully destroyed.");
    
}

//-------------------------------------------
// CHashTable::Lookup
//-------------------------------------------
HashListNode * CHashTable::Lookup( const BYTE *pKey )
{
    int nIdx                = Compute(pKey);                // index of bucket we want.
    HashListNode * plnHead;
    ListNode * pln      = NULL;
    HashListNode * plnRes   = NULL;

    XomTrace0(XWireTapHash, L_LOW, "HASH:(CHashTable::Lookup)  Enter.");

    XOMASSERT( m_pTable );
    if ( m_pTable == NULL )
    {
        XomTrace0( XWireTapHash, L_WARNING, "HASH:(CHashTable::Lookup)  No hash table exists.  HASH has not been properly set up.  Please reload configuration.");
        XomNtEvent( XEVENT_XWIRETAP_GENERIC_ERROR_1, "HASH:(CHashTable::Lookup)  No hash table exists.  HASH has not been properly set up.  Please reload XMACS.");
        plnRes = NULL;
        goto Exit;
    }
    
    plnHead  = &(m_pTable[nIdx]);
    
    // scan forward for the desired node.
    for ( pln = plnHead->m_Link.m_pNext; pln != (ListNode*)plnHead; pln = pln->m_pNext)
    {
        if ( memcmp( ((HashListNode*)pln)->m_pKey, pKey, HASH_KEY_SIZE ) == 0 )
        {
            // got it.
            plnRes = (HashListNode*)pln;
            goto Exit;
        }
    }

Exit:
    XomTrace0(XWireTapHash, L_LOW, "HASH:(CHashTable::Lookup)  Exit.");
    return plnRes;
}

//-------------------------------------------
// CHashTable::Insert a listnode into the list.
//-------------------------------------------
void CHashTable::Insert( HashListNode * plnIns)
{
    XomTrace0(XWireTapHash, L_LOW, "HASH:(CHashTable::Insert)  Enter.");

    XOMASSERT( m_pTable );
    if ( m_pTable == NULL )
    {
        XomTrace0( XWireTapHash, L_WARNING, "HASH:(CHashTable::Insert)  No hash table exists.  HASH has not been properly set up.  Please reload configuration.");
        XomNtEvent( XEVENT_XWIRETAP_GENERIC_ERROR_2, "HASH:(CHashTable::Insert)  No hash table exists.  HASH has not been properly set up.  Please reload XMACS.");
        return;    
    }

    HashListNode * plnHead = &m_pTable[ Compute(plnIns->m_pKey) ];

    // ensure this item is not already in the list.
    InsertTailList((ListNode*)plnHead, (ListNode*)plnIns);
    m_nNumOfEnt += 1;
    XomTrace0(XWireTapHash, L_LOW, "HASH:(CHashTable::Insert)  Exit.");
}

//-------------------------------------------
// CHashTable::Delete entry for the table.
//-------------------------------------------
void CHashTable::Delete( HashListNode * plnDel )
{
    XOMASSERT( m_nNumOfEnt >= 0 );
    if ( m_nNumOfEnt < 0 )
    {
        return;
    }

    // don't handle NULL nodes.
    XOMASSERT( plnDel );
    if ( plnDel == NULL )
    {
        XomTrace0( XWireTapHash, L_WARNING, "HASH:(CHashTable::Insert)  Passed param is NULL.  This is a coding error and should be investigated by the developer responsible.  Please reload XMACS is this continues.");
        XomNtEvent( XEVENT_XWIRETAP_GENERIC_ERROR_3, "HASH:(CHashTable::Insert)  No hash table exists.  HASH has not been properly set up.  Please reload XMACS.");
        return;            
    }

    XOMASSERT( m_pTable );
    if ( m_pTable == NULL )
    {
        XomTrace0( XWireTapHash, L_WARNING, "HASH:(CHashTable::Insert)  No hash table exists.  HASH has not been properly set up.  Please reload configuration.");
        XomNtEvent( XEVENT_XWIRETAP_GENERIC_ERROR_4, "HASH:(CHashTable::Insert)  No hash table exists.  HASH has not been properly set up.  Please reload XMACS.");
        return;    
    }
    
    XomTrace0(XWireTapHash, L_LOW, "HASH:(CHashTable::Delete)  Enter.");

    if ( ( (plnDel->m_Link.m_pNext == NULL) && (plnDel->m_Link.m_pPrev == NULL) ) )
    {
        // this entry doesn't exist... in the list.
        XomTrace0(XWireTapHash, L_LOW, "HASH:(CHashTable::Delete)  Exit.");
        return;
    }

    // remove the entry.
    RemoveEntryList((ListNode*)plnDel);

    m_nNumOfEnt -= 1;
    XomTrace0(XWireTapHash, L_LOW, "HASH:(CHashTable::Delete)  Exit.");
}

//-------------------------------------------
// CHashTable::Compute: the hash function
//-------------------------------------------
int CHashTable::Compute( const BYTE *pKey )
{
    int nRes                = 0;
    int nUpper              = (int)(*((int*)(pKey)));
    int nLower              = (int)(*((int*)(pKey+(HASH_KEY_SIZE - 4))));
    
    // multiply the upper, lower and a prime and then mod the table size... very nice.
    ULONGLONG ullval = ( nUpper ^ 113591 ^ nLower );
    nRes = (int)( ullval % m_nTableSize );

    return nRes;
}

//-------------------------------------------
// CHashTable::IsValid: returns result of 
//      this object being valid or not.
//-------------------------------------------
BOOL CHashTable::IsValid()
{
    return ( m_pTable != NULL );
}


//--------------------------------------------------------------------
//  Local Functions
//--------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wiretap\NetStructs.h ===
//-----------------------------------------------------------------------------
//  Microsoft (R) XWireTap (tm). 
//  Copyright (C) 2002. All rights reserved.
//
//  FILE: NetStructs.h
//
//  Structures for internet/ethernet packets.  NOTE:  these structures and 
//      Macros were acquired from Sg.hand XGGTest.h
//-----------------------------------------------------------------------------

#pragma once

//-----------------------------------------------------------------------------
//  Include
//-----------------------------------------------------------------------------
#include <xonlinep.h>

//-----------------------------------------------------------------------------
//  Definitions
//-----------------------------------------------------------------------------

#define FINLINE __forceinline

#define dimensionof(x)          (sizeof((x))/sizeof(*(x)))
#define BIT(n)                  (1u << (n))
#define ROUNDUP4(count)         (((count) + 3) & ~3)
#define ROUNDUP8(count)         (((count) + 7) & ~7)
#define IsListNull(_ple)        ((_ple)->Flink == NULL)

#define HTONL_(ul) \
    ((ULONG)((((ul) >> 24) & 0x000000FFL) | (((ul) >>  8) & 0x0000FF00L) | \
             (((ul) <<  8) & 0x00FF0000L) | (((ul) << 24))))

#define NTOHL_(ul) HTONL_(ul)

#define HTONS_(us) \
    ((USHORT)((((us) >> 8) & 0x00FF) | (((us) << 8) & 0xFF00)))

#define NTOHS_(us) HTONS_(us)

#define ARP_OP_REQUEST      HTONS(1)    // opcodes
#define ARP_OP_REPLY        HTONS(2)

#define ARP_HWTYPE_ENET     HTONS(1)    // hardware address spaces
#define ARP_HWTYPE_802      HTONS(6)

//-----------------------------------------------------------------------------
//  Functions
//-----------------------------------------------------------------------------

FINLINE ULONG  HTONL(ULONG  ul) { return(HTONL_(ul)); }
FINLINE ULONG  NTOHL(ULONG  ul) { return(NTOHL_(ul)); }
FINLINE USHORT HTONS(USHORT us) { return(HTONS_(us)); }
FINLINE USHORT NTOHS(USHORT us) { return(NTOHS_(us)); }


//-----------------------------------------------------------------------------
//  Types/Structures
//-----------------------------------------------------------------------------

#pragma pack (push, 1)

//-----------------------------------------------------------------------------
//  Constants
//-----------------------------------------------------------------------------
const DWORD c_dwARPPacketSize               = 42;
const BYTE  c_rgVMAC[6]                     = {0x00,0x11,0x22,0x33,0x44,0x55};
const DWORD c_dwMAX_MTU_ETHERNET            = 1500;


//-----------------------------------------------------------------------------
//
// CIpAddr
//
// This struct was ripped from Dinarte's very functional CIpAddr.  It is in 
// fact the same structure which comes with lots of cool helper functions.
//
// It essentially represents an IP address
//
//-----------------------------------------------------------------------------
struct CIpAddr
{
    union
    {
        BYTE        _ab[4];
        DWORD       _dw;
    };

    #define IPADDR_BROADCAST            CIpAddr(HTONL(0xFFFFFFFF))
    #define IPADDR_LOOPBACK             CIpAddr(HTONL(0x7F000001))
    #define IPADDR_CLASSA_NETMASK       CIpAddr(HTONL(0xFF000000))
    #define IPADDR_CLASSB_NETMASK       CIpAddr(HTONL(0xFFFF0000))
    #define IPADDR_CLASSC_NETMASK       CIpAddr(HTONL(0xFFFFFF00))
    #define IPADDR_CLASSD_NETMASK       CIpAddr(HTONL(0xF0000000))
    #define IPADDR_CLASSD_NETID         CIpAddr(HTONL(0xE0000000))
    #define IPADDR_LOOPBACK_NETID       CIpAddr(HTONL(0x7F000000))

    FINLINE operator DWORD () const { return(_dw); }
    FINLINE DWORD operator = (DWORD & dw) { return(_dw = dw); }
    FINLINE CIpAddr(DWORD dw) { _dw = dw; }
    FINLINE CIpAddr() {}

    FINLINE BOOL IsBroadcast() const { return(_dw == IPADDR_BROADCAST); }
    FINLINE BOOL IsMulticast() const { return(IsClassD() && !IsBroadcast()); }
    FINLINE BOOL IsLoopback() const { return((_dw & IPADDR_CLASSA_NETMASK) == IPADDR_LOOPBACK_NETID); }
    FINLINE BOOL IsClassA() const { return((_dw & HTONL(0x80000000)) == HTONL(0x00000000)); }
    FINLINE BOOL IsClassB() const { return((_dw & HTONL(0xC0000000)) == HTONL(0x80000000)); }
    FINLINE BOOL IsClassC() const { return((_dw & HTONL(0xE0000000)) == HTONL(0xC0000000)); }
    FINLINE BOOL IsClassD() const { return((_dw & HTONL(0xF0000000)) == HTONL(0xE0000000)); }
    FINLINE BOOL IsValidMask() const { DWORD dw = ~NTOHL(_dw); return((dw & (dw + 1)) == 0); }
           BOOL IsValidAddr() const;
    char * Str() const;
};


//-----------------------------------------------------------------------------
//
// CEnetAddr
//
// This represents a very robust ethernet address struct, ripped from Dinarte.
//
//-----------------------------------------------------------------------------
struct CEnetAddr
{
    BYTE _ab[6];

    FINLINE BOOL IsEqual(const CEnetAddr & ea) const { return(memcmp(_ab, ea._ab, sizeof(_ab)) == 0); }
    FINLINE BOOL IsEqual(const BYTE * pb) const { return(memcmp(_ab, pb, sizeof(_ab)) == 0); }
    FINLINE void SetBroadcast()                { *(DWORD *)&_ab[0] = 0xFFFFFFFF; *(WORD *)&_ab[4] = 0xFFFF; }
    FINLINE void SetZero()                     { *(DWORD *)&_ab[0] = 0x00000000; *(WORD *)&_ab[4] = 0x0000; }
    FINLINE BOOL IsBroadcast() const           { return(*(DWORD *)&_ab[0] == 0xFFFFFFFF && *(WORD *)&_ab[4] == 0xFFFF); }
    FINLINE BOOL IsMulticast() const           { return((_ab[0] & 1) != 0); }
    char * Str() const;
};

//-----------------------------------------------------------------------------
//
// IP_HEADER
//
// This struct stores an IP header
//
//-----------------------------------------------------------------------------
struct IP_HEADER {
    BYTE    x;
    BYTE    tos;
    WORD    length;
    WORD    identifier;
    WORD    fragment;
    BYTE    ttl;
    BYTE    protocol;
    WORD    cksum;
    DWORD   src;
    DWORD   dest;
};

//-----------------------------------------------------------------------------
//
// ENET_HEADER
//
// This struct stores an Ethernet header
//
//-----------------------------------------------------------------------------
#define ENET_DATA_MAXSIZE   1500
#define ENET_TYPE_IP        HTONS_(0x0800)
#define ENET_TYPE_ARP       HTONS_(0x0806)

struct CEnetHdr
{
    CEnetAddr       _eaDst;
    CEnetAddr       _eaSrc;
    WORD            _wType;
};

struct CIeeeHdr : public CEnetHdr
{
    BYTE            _bDsap;         // 0xAA
    BYTE            _bSsap;         // 0xAA
    BYTE            _bControl;      // 0x03
    BYTE            _bOrgCode[3];   // 0x00 0x00 0x00
    WORD            _wTypeIeee;

    FINLINE BOOL IsEnetFrame()   { return(*(DWORD *)&_bDsap == 0x0003AAAA && *(WORD *)&_bOrgCode[1] == 0); }
    FINLINE BOOL IsValid()       { return(NTOHS(_wType) > ENET_DATA_MAXSIZE || IsEnetFrame()); }
};

//-----------------------------------------------------------------------------
//
// UDP_HEADER
//
// This struct stores a UDP header
//
//-----------------------------------------------------------------------------
struct UDP_HEADER
{
    WORD wSrcPort;
    WORD wDestPort;
    WORD wLength;        // UDP header + data
    WORD wChecksum;
};

//-----------------------------------------------------------------------------
//
// CArpMsg 
//
// This struct stores an ARP message
//
//-----------------------------------------------------------------------------
struct CArpMsg
{
    WORD            _wHrd;      // hardware address space
    WORD            _wPro;      // protocol address space (ENET_TYPE_IP)
    BYTE            _bHln;      // hardware address length (6)
    BYTE            _bPln;      // protocol address length (4)
    WORD            _wOp;       // opcode
    CEnetAddr       _eaSender;  // sender's hardware address
    DWORD         _ipaSender; // sender's protocol address
    CEnetAddr       _eaTarget;  // target's hardware address
    DWORD         _ipaTarget; // target's protocol address
};


#pragma pack (pop)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wiretap\MgmtInterface.cpp ===
//-----------------------------------------------------------------------------
//  Microsoft (R) XWireTap (tm). 
//  Copyright (C) 2002. All rights reserved.
//
//  FILE: MgmtInterface.cpp
//
//  Implementation of the node bag.
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
//  Include
//-----------------------------------------------------------------------------
#include "StdAfx.h"

//-----------------------------------------------------------------------------
//  Debugging Areas
//-----------------------------------------------------------------------------
XomImportArea(XWireTap);

//-----------------------------------------------------------------------------
//  Definitions
//-----------------------------------------------------------------------------
#define MAX_MGMT_RESPONSE_SIZE          256

//-----------------------------------------------------------------------------
//  Constant
//-----------------------------------------------------------------------------
const char c_szKeyTypeMachinePUID[]     = "xboxpuid";
const char c_szKeyTypeUserPUID[]        = "userpuid";
const char c_szKeyTypeIP[]              = "srcip";

const DWORD c_dwDefaultQueueSize        = 400;
const DWORD c_dwDefaultMaxFileSize      = 200000;

//-----------------------------------------------------------------------------
//  Local Function Declaration
//-----------------------------------------------------------------------------
void                OutputAddCmdLine( CXomControlResponseInterface *pResponseInterface, DWORD dwRequestId );
void                OutputCloseCmdLine( CXomControlResponseInterface *pResponseInterface, DWORD dwRequestId );
void                OutputRolloverCmdLine( CXomControlResponseInterface *pResponseInterface, DWORD dwRequestId );

BOOL                StringToTime( const char *szTimeStr, DWORD *pdwHours, DWORD *pdwMinutes, DWORD *pdwSeconds );
void                StringToLowerCase( char *szResult, char *szSrc, DWORD dwSrcSize );


//-----------------------------------------------------------------------------
// CXMgmtControlCallback provides mgmt interface for XWireTap service
//-----------------------------------------------------------------------------
class CXMgmtControlCallback : public CXomControlCallback
{
    IMPLEMENT_REFCOUNT_COM;

    CXMgmtControlCallback(CMgmtInterface *pMI) :
        CXomControlCallback(),
        m_pMgmtInterface(pMI)
    {
    }

    virtual ~CXMgmtControlCallback()
    {
    }

    virtual HRESULT OnControlRequest(
        LPCSTR pszRequest,
        DWORD dwRequestId,
        CXomControlResponseInterface* pResponseInterface );
    
 protected:
    HRESULT ParseArgList(
        IN  LPCSTR pszRequest,
        OUT DWORD *pdwArgc,
        OUT LPCSTR **ppArgv );
    
    CMgmtInterface* m_pMgmtInterface;
    
};


//-----------------------------------------------------------------------------
//  CMgmtInterface Implementation
//-----------------------------------------------------------------------------
CMgmtInterface::CMgmtInterface()
{
    m_dwNumRegCmds = 0;
    m_dwMaxCmds    = 0;
    m_pCmdList     = NULL;
}

CMgmtInterface::~CMgmtInterface(void)
{
    DWORD dwX = 0;

    if ( m_pCmdList )
    {        
        delete[] m_pCmdList;
    }

    m_dwNumRegCmds = 0;
    m_dwMaxCmds    = 0;
    m_pCmdList     = NULL;
}

//-----------------------------------------------------------------------------
//  Initialize:  Creates the node bag.
//-----------------------------------------------------------------------------
HRESULT CMgmtInterface::Initialize( DWORD dwNumOfCmds )
{
    HRESULT hr = S_OK;


    XomTrace0( XWireTap, L_NORMAL, "CMgmtInterface::Initialize:  Initializing MGMT Interface.");

    // install the mgmt command handler
    m_pMgmtHandler = new CXMgmtControlCallback(this);
    if ( NULL == m_pMgmtHandler )
    {
        // not enough memory to create wiretap instance.
        XomNtEvent( XEVENT_XWIRETAP_MEMORY_WARNING, "CMgmtInterface::Initialize:  Failed to attain memory for the mgmt control callback handler.  This machine needs more memory to operate the currently configured XWireTap.  Modify the configuration or add more phyical memory to this machine.");
        XomTrace0( XWireTap, L_ERROR, "CMgmtInterface::Initialize:  Failed to attain memory for the mgmt control callback handler.  This machine needs more memory to operate the currently configured XWireTap.  Modify the configuration or add more phyical memory to this machine.");
            
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    XomTrace0( XWireTap, L_NORMAL, "CMgmtInterface::Initialize:  Registering mgmt control handler.");
    g_xomcentral.RegisterControlCallback(m_pMgmtHandler);

    m_dwMaxCmds = dwNumOfCmds;
    m_pCmdList = new XomMgmtCmd[dwNumOfCmds];
    m_dwNumRegCmds = 0;
    
Exit:    
    XomTrace1( XWireTap, L_LOW, "CMgmtInterface::Initialize:  Complete with result = 0x%X.", hr);
    return hr;
}

//-----------------------------------------------------------------------------
//  Terminate:  Unregistered XMGMT calbacks
//-----------------------------------------------------------------------------
HRESULT CMgmtInterface::Terminate( )
{
    HRESULT hr = S_OK;


    XomTrace0( XWireTap, L_NORMAL, "CMgmtInterface::Terminate:  Terminating MGMT Interface.");

    XomTrace0( XWireTap, L_NORMAL, "CMgmtInterface::Terminate:  UnRegistering mgmt control handler.");
    g_xomcentral.UnregisterControlCallback(m_pMgmtHandler);

    if ( m_pMgmtHandler)
    {
        delete m_pMgmtHandler;
        m_pMgmtHandler = NULL;
    }

    return hr;
}

//-----------------------------------------------------------------------------
//  SendRequest:  sycn TCPIP XMGMT connection to specified address.  Sends
//   give data request and returns the response.
//-----------------------------------------------------------------------------
HRESULT CMgmtInterface::SendRequest( char *szHost, LPCSTR lpszRequest, char* szResponse, DWORD dwResponseBufferSize, DWORD *pdwBytesRecv, HRESULT *pHr )
{
    HRESULT hr = S_OK;
    CXomAdminSession adminSession;


    // initialize the admin aession connection
    hr = adminSession.Init( szHost );
    if ( FAILED(hr) )
    {
        // session connection failed.
        XomNtEvent( XEVENT_XWIRETAP_XMGMT_CONNECTION_FAILED, "CMgmtInterface::SendRequest:  Failed to connect to %s.  Please ensure this machine is still operating. RESULT = 0x%X", szHost, hr );
        XomTrace2( XWireTap, L_ERROR, "CMgmtInterface::SendRequest:  Failed to connect to %s.  Please ensure this machine is still operating. RESULT = 0x%X", szHost, hr );

        goto Exit;
    }

    // send the desired data.
    hr = adminSession.SendRequest(lpszRequest, szResponse, dwResponseBufferSize, pdwBytesRecv, pHr);
    if ( FAILED(hr) )
    {
        // the send request failed.
        XomNtEvent( XEVENT_XWIRETAP_XMGMT_CONNECTION_FAILED_1, "CMgmtInterface::SendRequest:  Failed to send request to %s.  Please ensure this machine is still operating. RESULT = 0x%X", szHost, hr );
        XomTrace2( XWireTap, L_ERROR, "CMgmtInterface::SendRequest:  Failed to send request to %s.  Please ensure this machine is still operating. RESULT = 0x%X", szHost, hr );

        goto Exit;        
    }

    if ( FAILED( pHr ) )
    {
        // the send request returned a failure hr.
        XomTrace2( XWireTap, L_ERROR, "CMgmtInterface::SendRequest:  SendRequest has sent the request however we received a failure hr. RESULT = 0x%X", szHost, *pHr);
    }
    
Exit:
    XomTrace1( XWireTap, L_LOW, "CMgmtInterface::SendRequest:  Complete with Result = 0x%X", hr );
    return hr;    
}

//-----------------------------------------------------------------------------
//  RegisterCommand:  Registers a callback command with the interface..
//-----------------------------------------------------------------------------
HRESULT CMgmtInterface::RegisterCommand( XomMgmtCmd newCmd )
{
    HRESULT hr = S_OK;
    XOMASSERT( m_dwNumRegCmds < m_dwMaxCmds );

    // copy information into structure.
    if ( newCmd.szCmdName == NULL )
    {
        // the send request failed.
        XomTrace0( XWireTap, L_ERROR, "CMgmtInterface::RegisterCommand:  Registering command must have a name.");
        XOMASSERT( FALSE );        
    }
    
    m_pCmdList[m_dwNumRegCmds].szCmdName = newCmd.szCmdName;
    m_pCmdList[m_dwNumRegCmds].dwCmdNameLen= newCmd.dwCmdNameLen;
    
    // copy pointer values
    m_pCmdList[m_dwNumRegCmds].lpData = newCmd.lpData;
    m_pCmdList[m_dwNumRegCmds].pfnCmdProc = newCmd.pfnCmdProc;

    // copy the help name
    m_pCmdList[m_dwNumRegCmds].szCmdHelp = newCmd.szCmdHelp;
    
    // increase the number of register commands.
    m_dwNumRegCmds++;
    
    return hr;
}


//------------------------------------------------------------------------------
//  MgmtCmdHelp:  help command.  Displays commands
//------------------------------------------------------------------------------
HRESULT CMgmtInterface::MgmtCmdHelp(    
                                IN LPVOID lpCmdData,
                                IN CMgmtInterface *pMgmtInf,
                                IN DWORD dwRequestId,
                                IN CXomControlResponseInterface *pResponseInterface,
                                IN DWORD argc,
                                IN LPCSTR argv[] )
{
    HRESULT hr = S_OK;

    CHAR szHelpText[MAX_MGMT_RESPONSE_SIZE];
    
    _snprintf(szHelpText, MAX_MGMT_RESPONSE_SIZE-1,
              "XWireTap commands: \n"
              );
    pResponseInterface->WriteResponse(dwRequestId, (BYTE*) szHelpText, (DWORD)-1);

    for (DWORD i=0; i < pMgmtInf->GetNumberOfRegisteredCommands(); i++)
    {
        // don't print help for the help command
        if ( 0 == _strnicmp(pMgmtInf->m_pCmdList[i].szCmdName, argv[0], pMgmtInf->m_pCmdList[i].dwCmdNameLen) )
        {
            continue;
        }
            
        if ( NULL == pMgmtInf->m_pCmdList[i].szCmdHelp )
        {
            _snprintf(szHelpText, MAX_MGMT_RESPONSE_SIZE-1,
                      "  %s\r\n",
                      pMgmtInf->m_pCmdList[i].szCmdName);
        }
        else
        {
            _snprintf(szHelpText, MAX_MGMT_RESPONSE_SIZE-1,
                      "  %s %s\r\n",
                      pMgmtInf->m_pCmdList[i].szCmdName,
                      pMgmtInf->m_pCmdList[i].szCmdHelp);
        }
        
        pResponseInterface->WriteResponse(dwRequestId, (BYTE*) szHelpText, (DWORD)-1);
    }
    
    // perform the response

    return hr;
}

//------------------------------------------------------------------------------
//  MgmtCmdShutdown:
//------------------------------------------------------------------------------
HRESULT CMgmtInterface::MgmtCmdShutdown(    
                                IN LPVOID lpCmdData,
                                IN CMgmtInterface *pMgmtInf,
                                IN DWORD dwRequestId,
                                IN CXomControlResponseInterface *pResponseInterface,
                                IN DWORD argc,
                                IN LPCSTR argv[] )
{
    HRESULT hr = S_OK;
    CWTAction* pAction = NULL;
    CWireTap *pWireTap = CWireTap::GetInstance();
    
    pWireTap->Shutdown();
    
    pWireTap->ReleaseInstance();
    return hr;
}

//------------------------------------------------------------------------------
//  MgmtCmdAddTap:  tells the program to set up a new interface.
//------------------------------------------------------------------------------
HRESULT CMgmtInterface::MgmtCmdAddTap(    
                                IN LPVOID lpCmdData,
                                IN CMgmtInterface *pMgmtInf,
                                IN DWORD dwRequestId,
                                IN CXomControlResponseInterface *pResponseInterface,
                                IN DWORD argc,
                                IN LPCSTR argv[] )
{
    HRESULT     hr = S_OK;
    char        szBuf[MAX_MGMT_RESPONSE_SIZE];
    BYTE        pbytWireTapRequest[256];
    CWireTap*   pWireTap = CWireTap::GetInstance();
    DWORD       dwX = 0;
    int         nActualSize = 0;
    CTap*       pTap = NULL;
    CWTAction*  pAction = NULL;
    TapId*      pTapId = NULL;
    DWORD       dwTapLifeTime = INFINITE;
    WORD        wTapSeq = 0;
    DWORD       dwReqSize = 0;
    char        szLowerCaseArgv[128];
    DWORD       dwArgvSize = 0;
    ULONGLONG   qwTempIdHolder = 0;

    XOMASSERT( pWireTap != NULL );
    
    // ensure the args
    if ( argc < 2 )
    {
        OutputAddCmdLine( pResponseInterface, dwRequestId );
        hr = E_INVALIDARG;
        goto Exit;
    }

    // add to the number of taps if possible.
    if ( ! pWireTap->IncNumTaps() )
    {
        XomTrace0( XWireTap, L_WARNING, "CMgmtInterface::MgmtCmdAddTap: At maximum number of TAPs that can be created.  Please re-configure if more are necessary." );

        nActualSize = safe_snprintf( szBuf, sizeof(szBuf), "XWireTap:(ERROR) XWireTap has already used all it room for available TAP.  This TAP could not be created." );
        pResponseInterface->WriteResponse( dwRequestId, (BYTE*)szBuf, nActualSize );
        hr = E_FAIL;
        goto Exit;
    }
    
    ZeroMemory( pbytWireTapRequest, sizeof(pbytWireTapRequest) );
    ZeroMemory( szLowerCaseArgv, sizeof(szLowerCaseArgv) );
    
    // create the tap 
    pTap = new CTap();
    if ( pTap == NULL )
    {
        hr = E_OUTOFMEMORY;
        
        XomNtEvent( XEVENT_XWIRETAP_MEMORY_WARNING_1, "CMgmtInterface::MgmtCmdAddTap: Failed to allocate enough memory to create a new TAP. :  RESULT = 0x%X.", hr );
        XomTrace1( XWireTap, L_ERROR, "CMgmtInterface::MgmtCmdAddTap: Failed to allocate enough memory to create a new TAP. :  RESULT = 0x%X.", hr );

        nActualSize = safe_snprintf( szBuf, sizeof(szBuf), "XWireTap:(ERROR) Failed to allocate enough memory to create a new TAP. :  RESULT = 0x%X.", hr );
        pResponseInterface->WriteResponse( dwRequestId, (BYTE*)szBuf, nActualSize );
        pWireTap->DecNumTaps();
        goto Exit;        
    }
        
    // get an action node
    pAction = pWireTap->GetAction();
    if ( pAction == NULL )
    {
        XomNtEvent( XEVENT_XWIRETAP_MEMORY_WARNING_2, "CMgmtInterface::MgmtCmdAddTap:  There are no more Action nodes.  This request has failed.  Please re-config with more memory to avoid this.");
        XomTrace0( XWireTap, L_ERROR, "CMgmtInterface::MgmtCmdAddTap:  There are no more Action nodes.  This request has failed.  Please re-config with more memory to avoid this.");

        nActualSize = safe_snprintf( szBuf, sizeof(szBuf), "XWireTap:(ERROR) There are no more Action nodes.  This request has failed.  Please re-config with more memory to avoid this.");
        pResponseInterface->WriteResponse( dwRequestId, (BYTE*)szBuf, nActualSize );

        pWireTap->DecNumTaps();
        delete pTap;
        hr = E_OUTOFMEMORY;
        goto Exit;        
    }

    // generate a tap id for this tap.
    qwTempIdHolder = pWireTap->GenerateNewTapId();
    pTapId = (TapId*)&(qwTempIdHolder);
    
    // get the sequence number of this tap.  Its the last word of the id.
    wTapSeq = pTapId->m_wId;  

    // get argv[2] in lowercase
    if ( argc >= 3 )
    {
        dwArgvSize = strlen(argv[2]);
        
        XOMASSERT( dwArgvSize < sizeof(szLowerCaseArgv) );
        StringToLowerCase( szLowerCaseArgv, (char*)argv[2], dwArgvSize );
        
        // determine the tap lifetime
        if ( strstr( szLowerCaseArgv, "lifetime" ) == szLowerCaseArgv && dwArgvSize > 9 )
        {
            char *szTimePos = (char*)(argv[2] + 9);
            DWORD dwHours = 0;
            DWORD dwMins = 0;
            DWORD dwSecs = 0;

            // change the string into a time 
            if ( StringToTime( szTimePos, &dwHours, &dwMins, &dwSecs ) )
            {
                dwTapLifeTime = ( ( (dwHours * 60) + dwMins ) * 60 ) + dwSecs;
                dwTapLifeTime*=1000;  //milliseconds
            }
        }
    }
    
    // get argv[1] in lower case.
    dwArgvSize = strlen(argv[1]);
    XOMASSERT( dwArgvSize < sizeof(szLowerCaseArgv) );
    StringToLowerCase( szLowerCaseArgv, (char*)argv[1], dwArgvSize );

    // determine the type of tap we want.    
    if ( strstr( szLowerCaseArgv, c_szKeyTypeIP ) == szLowerCaseArgv )
    {
        // this is an IP tap. 
        char *szIPPos = NULL;
        DWORD dwIPAddr = 0;       

        // get the IP desired.
        szIPPos = (char*)(argv[1] + sizeof(c_szKeyTypeIP));

        // change the ip string into the DWORD rep
        dwIPAddr = StringToIp( szIPPos );

        // create the expression.
        dwReqSize = sizeof(pbytWireTapRequest);
        hr = CExprBlder::BuildWireTapIpExpr( pbytWireTapRequest, &dwReqSize, wTapSeq, (BYTE*)(&dwIPAddr), sizeof(dwIPAddr));
        
        if ( FAILED( hr ) )
        {
            XOMASSERT( FALSE );
            
            XomNtEvent( XEVENT_XWIRETAP_TAP_CREATION_ERROR, "CMgmtInterface::MgmtCmdAddTap: Failed to build wiretap request.  This should never happen.  Please notify developer of this problem.  RESULT=0x%X", hr );
            XomTrace1( XWireTap, L_ERROR, "CMgmtInterface::MgmtCmdAddTap: Failed to build wiretap request.  This should never happen.  Please notify developer of this problem.  RESULT=0x%X", hr );
            
            pWireTap->ReleaseAction( pAction );
            delete pTap;
            pWireTap->DecNumTaps();
            
            goto Exit;        
        }

        // enter the information into the tap.
        // TODO: (lohab) add support for queue size and file size modifications
        hr = pTap->Initialize( *((ULONGLONG*)pTapId), c_dwDefaultQueueSize, c_dwDefaultMaxFileSize, SRC_IP, (BYTE*)&(dwIPAddr), dwTapLifeTime );
        
    }
    else if ( strstr( szLowerCaseArgv, c_szKeyTypeMachinePUID) == szLowerCaseArgv)
    {
        // this is an machine PUID tap. 
        char *szAuthPos = NULL;
        ULONGLONG qwAuthData = 0;
                
        // get the IP desired.
        szAuthPos = (char*)(argv[1] + sizeof(c_szKeyTypeMachinePUID));

        // change the ip string into the DWORD rep
        qwAuthData = QwordFromHexStr( szAuthPos );
        
        // create the expression.
        dwReqSize = sizeof(pbytWireTapRequest);
        hr = CExprBlder::BuildWireTapAuthExprMachine( pbytWireTapRequest, &dwReqSize, wTapSeq, szAuthPos);
        if ( FAILED( hr ) )
        {
            XOMASSERT( FALSE );
            
            XomNtEvent( XEVENT_XWIRETAP_TAP_CREATION_ERROR_1, "CMgmtInterface::MgmtCmdAddTap: Failed to build wiretap request.  This should never happen.  Please notify developer of this problem.  RESULT=0x%X", hr );
            XomTrace1( XWireTap, L_ERROR, "CMgmtInterface::MgmtCmdAddTap: Failed to build wiretap request.  This should never happen.  Please notify developer of this problem.  RESULT=0x%X", hr );
            
            pWireTap->ReleaseAction( pAction );
            delete pTap;
            pWireTap->DecNumTaps();
            
            goto Exit;        
        }

        // enter the information into the tap.
        // TODO: (lohab) add support for  queue size and file size modifications
        hr = pTap->Initialize( *((ULONGLONG*)pTapId), c_dwDefaultQueueSize, c_dwDefaultMaxFileSize, MACHINE_ID, (BYTE*)(&qwAuthData), dwTapLifeTime );
        
    }
    else if ( strstr( szLowerCaseArgv, c_szKeyTypeUserPUID) == szLowerCaseArgv )
    {
        // this is an user PUID tap. 
        char *szAuthPos = NULL;
        ULONGLONG qwAuthData = 0;
        
        // get the IP desired.
        szAuthPos = (char*)(argv[1] + sizeof(c_szKeyTypeMachinePUID));

        // change the ip string into the DWORD rep
        qwAuthData = QwordFromHexStr( szAuthPos );
        
        // create the expression.
        dwReqSize = sizeof(pbytWireTapRequest);
        hr = CExprBlder::BuildWireTapAuthExprUser( pbytWireTapRequest, &dwReqSize, wTapSeq, szAuthPos);
        if ( FAILED( hr ) )
        {
            XOMASSERT( FALSE );
            
            XomNtEvent( XEVENT_XWIRETAP_TAP_CREATION_ERROR_2, "CMgmtInterface::MgmtCmdAddTap: Failed to build wiretap request.  This should never happen.  Please notify developer of this problem.  RESULT=0x%X", hr );
            XomTrace1( XWireTap, L_ERROR, "CMgmtInterface::MgmtCmdAddTap: Failed to build wiretap request.  This should never happen.  Please notify developer of this problem.  RESULT=0x%X", hr );
            
            pWireTap->ReleaseAction( pAction );
            delete pTap;

            pWireTap->DecNumTaps();
            goto Exit;        
        }

        // enter the information into the tap.
        // TODO: (lohab) add support for  queue size and file size modifications
        hr = pTap->Initialize( *((ULONGLONG*)pTapId), c_dwDefaultQueueSize, c_dwDefaultMaxFileSize, MACHINE_ID, (BYTE*)(&qwAuthData), dwTapLifeTime );
        
    }
    else
    {
        // unknown key type.
        OutputAddCmdLine( pResponseInterface, dwRequestId );

        pWireTap->ReleaseAction( pAction );
        delete pTap;
        pWireTap->DecNumTaps();
        
        hr = E_INVALIDARG;
        goto Exit;
    }

    if ( FAILED(hr) )
    {        
        XomNtEvent( XEVENT_XWIRETAP_TAP_CREATION_ERROR_3, "CMgmtInterface::MgmtCmdAddTap:  Failed to initialize the tap with the given information.  Please try again after solving the problem.  RESULT = 0x%X", hr);
        XomTrace1( XWireTap, L_ERROR, "CMgmtInterface::MgmtCmdAddTap:  Failed to initialize the tap with the given information.  Please try again after solving the problem.  RESULT = 0x%X", hr);

        nActualSize = safe_snprintf( szBuf, sizeof(szBuf), "XWireTap:(ERROR)  Failed to initialize the tap with the given information.  Please try again after solving the problem.  RESULT = 0x%X", hr);
        pResponseInterface->WriteResponse( dwRequestId, (BYTE*)szBuf, nActualSize );

        pWireTap->ReleaseAction( pAction );
        delete pTap;
        pWireTap->DecNumTaps();
        goto Exit;        
    }
    
    // set up the action
    pAction->Setup(  CWTAction::CREATE_TAP, (LPBYTE)pTap );
    
    // post the action to the completion port.
    hr = pWireTap->GetMasterCompletionPort()->PostCompletion( (CCompletionContext*) pAction, sizeof(CWTAction), NULL );
    if ( FAILED(hr) )
    {
        XomNtEvent( XEVENT_XWIRETAP_TAP_CREATION_ERROR_4, "CMgmtInterface::MgmtCmdAddTap: Failed to post this TAP to the WireTap service.  TAP creation failed. :  RESULT = 0x%X.", hr );
        XomTrace1( XWireTap, L_ERROR, "CMgmtInterface::MgmtCmdAddTap: Failed to post this TAP to the WireTap service.  TAP creation failed. :  RESULT = 0x%X.", hr );

        pWireTap->ReleaseAction( pAction );
        delete pTap;
        pWireTap->DecNumTaps();
        goto Exit;        
    }

    nActualSize = safe_snprintf( szBuf, sizeof(szBuf), "\nNow submitting request to the SG for AuthData.  TAP-ID => 0x%I64X ", *((ULONGLONG*)pTapId) );
    pResponseInterface->WriteResponse( dwRequestId, (BYTE*)szBuf, nActualSize );

    // submit the request to the SGs
    hr = pWireTap->SubmitRequestToSGs( pbytWireTapRequest, dwReqSize );
    if ( FAILED(hr) )
    {
        XomTrace2( XWireTap, L_ERROR, "CTap::TAPThreadInternal:  Failed to submit request. Request=%s.  RESULT = 0x%X", (char*)pbytWireTapRequest, hr );
    }

    nActualSize = safe_snprintf( szBuf, sizeof(szBuf), "\nSuccessfully created a new TAP.  TAP-ID => 0x%I64X ", *((ULONGLONG*)pTapId) );
    pResponseInterface->WriteResponse( dwRequestId, (BYTE*)szBuf, nActualSize );
    

Exit:
    pWireTap->ReleaseInstance();
    return hr;
}


//------------------------------------------------------------------------------
//  MgmtCmdMonitor:  tells the program to set up a new interface.
//------------------------------------------------------------------------------
HRESULT CMgmtInterface::MgmtCmdMonitor(    
                                IN LPVOID lpCmdData,
                                IN CMgmtInterface *pMgmtInf,
                                IN DWORD dwRequestId,
                                IN CXomControlResponseInterface *pResponseInterface,
                                IN DWORD argc,
                                IN LPCSTR argv[] )
{
    HRESULT     hr = S_OK;
    char        szBuf[MAX_MGMT_RESPONSE_SIZE];
    BYTE        pbytWireTapRequest[256];
    CWireTap*   pWireTap = CWireTap::GetInstance();
    DWORD       dwX = 0;
    int         nActualSize = 0;
    CTap*       pTap = NULL;
    CWTAction*  pAction = NULL;
    TapId*      pTapId = NULL;
    DWORD       dwTapLifeTime = INFINITE;
    WORD        wTapSeq = 0;
    DWORD       dwReqSize = 0;
    char        szLowerCaseArgv[128];
    DWORD       dwArgvSize = 0;
    ULONGLONG   qwTempIdHolder = 0;

    XOMASSERT( pWireTap != NULL );
    
    // add to the number of taps if possible.
    if ( ! pWireTap->IncNumTaps() )
    {
        XomTrace0( XWireTap, L_WARNING, "CMgmtInterface::MgmtCmdMonitor: At maximum number of TAPs that can be created.  Please re-configure if more are necessary." );

        nActualSize = safe_snprintf( szBuf, sizeof(szBuf), "XWireTap:(ERROR) XWireTap has already used all it room for available TAP.  This TAP could not be created." );
        pResponseInterface->WriteResponse( dwRequestId, (BYTE*)szBuf, nActualSize );
        hr = E_FAIL;
        goto Exit;
    }
    
    ZeroMemory( pbytWireTapRequest, sizeof(pbytWireTapRequest) );
    ZeroMemory( szLowerCaseArgv, sizeof(szLowerCaseArgv) );
    
    // create the tap 
    pTap = new CTap();
    if ( pTap == NULL )
    {
        hr = E_OUTOFMEMORY;
        
        XomNtEvent( XEVENT_XWIRETAP_MEMORY_WARNING_3, "CMgmtInterface::MgmtCmdAddTap: Failed to allocate enough memory to create a new TAP. :  RESULT = 0x%X.", hr );
        XomTrace1( XWireTap, L_ERROR, "CMgmtInterface::MgmtCmdAddTap: Failed to allocate enough memory to create a new TAP. :  RESULT = 0x%X.", hr );

        nActualSize = safe_snprintf( szBuf, sizeof(szBuf), "XWireTap:(ERROR) Failed to allocate enough memory to create a new TAP. :  RESULT = 0x%X.", hr );
        pResponseInterface->WriteResponse( dwRequestId, (BYTE*)szBuf, nActualSize );
        pWireTap->DecNumTaps();
        goto Exit;        
    }
        
    // get an action node
    pAction = pWireTap->GetAction();
    if ( pAction == NULL )
    {
        XomNtEvent( XEVENT_XWIRETAP_MEMORY_WARNING_4, "CMgmtInterface::MgmtCmdAddTap:  There are no more Action nodes.  This request has failed.  Please re-config with more memory to avoid this.");
        XomTrace0( XWireTap, L_ERROR, "CMgmtInterface::MgmtCmdAddTap:  There are no more Action nodes.  This request has failed.  Please re-config with more memory to avoid this.");

        nActualSize = safe_snprintf( szBuf, sizeof(szBuf), "XWireTap:(ERROR) There are no more Action nodes.  This request has failed.  Please re-config with more memory to avoid this.");
        pResponseInterface->WriteResponse( dwRequestId, (BYTE*)szBuf, nActualSize );

        pWireTap->DecNumTaps();
        delete pTap;
        hr = E_OUTOFMEMORY;
        goto Exit;        
    }

    // generate a tap id for this tap.
    qwTempIdHolder = pWireTap->GenerateNewTapId();
    pTapId = (TapId*)&(qwTempIdHolder);
    
    // get the sequence number of this tap.  Its the last word of the id.
    wTapSeq = pTapId->m_wId;  

    // this is an IP tap. 
    char *szIPPos = NULL;
    DWORD dwIPAddr = 0;       

    // create the expression.
    dwReqSize = sizeof(pbytWireTapRequest);
    hr = CExprBlder::BuildReadAllTrafficQuery( pbytWireTapRequest, &dwReqSize, wTapSeq );        
    if ( FAILED( hr ) )
    {           
        XomNtEvent( XEVENT_XWIRETAP_TAP_CREATION_ERROR_5, "CMgmtInterface::MgmtCmdAddTap: Failed to build wiretap request.  This should never happen.  Please notify developer of this problem.  RESULT=0x%X", hr );
        XomTrace1( XWireTap, L_ERROR, "CMgmtInterface::MgmtCmdAddTap: Failed to build wiretap request.  This should never happen.  Please notify developer of this problem.  RESULT=0x%X", hr );
            
        pWireTap->ReleaseAction( pAction );
        delete pTap;
        pWireTap->DecNumTaps();
            
        goto Exit;        
    }

    // enter the information into the tap.
    // TODO: (lohab) add support for queue size and file size modifications
    hr = pTap->Initialize( *((ULONGLONG*)pTapId), c_dwDefaultQueueSize, c_dwDefaultMaxFileSize, SRC_IP, (BYTE*)&(dwIPAddr), dwTapLifeTime );
        
    if ( FAILED(hr) )
    {        
        XomNtEvent( XEVENT_XWIRETAP_TAP_CREATION_ERROR_6, "CMgmtInterface::MgmtCmdAddTap:  Failed to initialize the tap with the given information.  Please try again after solving the problem.  RESULT = 0x%X", hr);
        XomTrace1( XWireTap, L_ERROR, "CMgmtInterface::MgmtCmdAddTap:  Failed to initialize the tap with the given information.  Please try again after solving the problem.  RESULT = 0x%X", hr);

        nActualSize = safe_snprintf( szBuf, sizeof(szBuf), "XWireTap:(ERROR)  Failed to initialize the tap with the given information.  Please try again after solving the problem.  RESULT = 0x%X", hr);
        pResponseInterface->WriteResponse( dwRequestId, (BYTE*)szBuf, nActualSize );

        pWireTap->ReleaseAction( pAction );
        delete pTap;
        pWireTap->DecNumTaps();
        goto Exit;        
    }
    
    // set up the action
    pAction->Setup(  CWTAction::CREATE_TAP, (LPBYTE)pTap );
    
    // post the action to the completion port.
    hr = pWireTap->GetMasterCompletionPort()->PostCompletion( (CCompletionContext*) pAction, sizeof(CWTAction), NULL );
    if ( FAILED(hr) )
    {
        XomNtEvent( XEVENT_XWIRETAP_TAP_CREATION_ERROR_7, "CMgmtInterface::MgmtCmdAddTap: Failed to post this TAP to the WireTap service.  TAP creation failed. :  RESULT = 0x%X.", hr );
        XomTrace1( XWireTap, L_ERROR, "CMgmtInterface::MgmtCmdAddTap: Failed to post this TAP to the WireTap service.  TAP creation failed. :  RESULT = 0x%X.", hr );

        pWireTap->ReleaseAction( pAction );
        delete pTap;
        pWireTap->DecNumTaps();
        goto Exit;        
    }

    nActualSize = safe_snprintf( szBuf, sizeof(szBuf), "\nNow submitting request to the SG for AuthData.  TAP-ID => 0x%I64X ", *((ULONGLONG*)pTapId) );
    pResponseInterface->WriteResponse( dwRequestId, (BYTE*)szBuf, nActualSize );

    // submit the request to the SGs
    hr = pWireTap->SubmitRequestToSGs( pbytWireTapRequest, dwReqSize );
    if ( FAILED(hr) )
    {
        XomTrace2( XWireTap, L_ERROR, "CTap::TAPThreadInternal:  Failed to submit request. Request=%s.  RESULT = 0x%X", (char*)pbytWireTapRequest, hr );
    }

    nActualSize = safe_snprintf( szBuf, sizeof(szBuf), "\nSuccessfully created a new TAP.  TAP-ID => 0x%I64X ", *((ULONGLONG*)pTapId) );
    pResponseInterface->WriteResponse( dwRequestId, (BYTE*)szBuf, nActualSize );
    

Exit:
    pWireTap->ReleaseInstance();
    return hr;
}


//------------------------------------------------------------------------------
//  MgmtCmdListTaps:
//------------------------------------------------------------------------------
HRESULT CMgmtInterface::MgmtCmdListTaps(    
                                IN LPVOID lpCmdData,
                                IN CMgmtInterface *pMgmtInf,
                                IN DWORD dwRequestId,
                                IN CXomControlResponseInterface *pResponseInterface,
                                IN DWORD argc,
                                IN LPCSTR argv[] )
{
    HRESULT hr         = S_OK;
    char szBuf[MAX_MGMT_RESPONSE_SIZE];
    int nActualSize    = 0;
    CWireTap *pWireTap = CWireTap::GetInstance();
    ListNode* pTapList = NULL;
    ListNode* pTrav    = NULL;
    time_t curTime;
    struct tm *newtime;

    // get the current time.
    time( &curTime );
    newtime = gmtime( &curTime );

    // ensure we have a wiretap at this time.
    XOMASSERT( pWireTap != NULL );
    pWireTap->ReadLockTapList();

    // get the tap list.
    pTapList = pWireTap->GetTapList();
    XOMASSERT( pTapList != NULL );
    
    nActualSize = safe_snprintf( szBuf, sizeof(szBuf), "\n\n TAP LIST  --  GMT: %s \n---------------------------------------------\n", asctime( newtime ));
    pResponseInterface->WriteResponse( dwRequestId, (BYTE*)szBuf, nActualSize );                

    // move through the list.
    for ( pTrav = pTapList->m_pNext; pTrav != pTapList; pTrav = pTrav->m_pNext )
    {
        CTap* pTap = (CTap*)pTrav;
        SGAuthData authData;

        // get the auth data
        hr = pTap->GetTapAuthData( &authData );
        if (FAILED(hr) )
        {
            // TODO:  (lohab)what's wrong here? Invalid memory?  What should we do?
            continue;                
        }

        // determine the type of auth data.
        switch(pTap->GetTapType())
        {
            case MACHINE_ID:
            {
                nActualSize = safe_snprintf( szBuf, sizeof(szBuf), "TAP-ID => 0x%I64X   AUTHDATA => Machine PUID = 0x%I64X\n", pTap->GetTapID(), authData.qwXboxID );
                pResponseInterface->WriteResponse( dwRequestId, (BYTE*)szBuf, nActualSize );                
            }
                break;
            case USER_ID:
            {
                nActualSize = safe_snprintf( szBuf, sizeof(szBuf), "TAP-ID => 0x%I64X   AUTHDATA => User PUID = 0x%I64X\n", pTap->GetTapID(), authData.users[0].qwUserID );
                pResponseInterface->WriteResponse( dwRequestId, (BYTE*)szBuf, nActualSize );                
            }
                break;
            case SRC_IP:
            {
                nActualSize = safe_snprintf( szBuf, sizeof(szBuf), "TAP-ID => 0x%I64X   AUTHDATA => Src IP = 0x%X\n", pTap->GetTapID(), authData._ipaI );
                pResponseInterface->WriteResponse( dwRequestId, (BYTE*)szBuf, nActualSize );                
            }
                break;
            default:
                break;
        };
        
    }

    pWireTap->ReadUnlockTapList();
    
    pWireTap->ReleaseInstance();
    return hr;
}


//------------------------------------------------------------------------------
//  MgmtCmdCloseTap:  Signals that a specific tap should be closed.
//------------------------------------------------------------------------------
HRESULT CMgmtInterface::MgmtCmdCloseTap(    
                                IN LPVOID lpCmdData,
                                IN CMgmtInterface *pMgmtInf,
                                IN DWORD dwRequestId,
                                IN CXomControlResponseInterface *pResponseInterface,
                                IN DWORD argc,
                                IN LPCSTR argv[] )
{
    HRESULT     hr = S_OK;
    char        szBuf[MAX_MGMT_RESPONSE_SIZE];
    CWireTap*   pWireTap = CWireTap::GetInstance();
    CWTAction*  pAction = NULL;
    int         nActualSize = 0;
    ULONGLONG   qwTapId = 0;
    PacketNode  *pPacketNode = NULL;

    XOMASSERT( pWireTap != NULL );

    // ensure the args
    if ( argc < 2 )
    {
        OutputCloseCmdLine( pResponseInterface, dwRequestId );
        hr = E_INVALIDARG;
        goto Exit;
    }

    // get a packet Node.... this is how we're going to send the id.
    pPacketNode = pWireTap->GetPacketNode();
    if ( pPacketNode == NULL )
    {
        XomNtEvent( XEVENT_XWIRETAP_MEMORY_WARNING_5, "CMgmtInterface::MgmtCmdCloseTap:  Could not attain enough memory to build this request.  Try again later.");
        XomTrace0( XWireTap, L_ERROR, "CMgmtInterface::MgmtCmdCloseTap:  Could not attain enough memory to build this request.  Try again later.");

        nActualSize = safe_snprintf( szBuf, sizeof(szBuf), "XWireTap:(ERROR) There is not enough memory to handle this request.  Please try again later.");
        pResponseInterface->WriteResponse( dwRequestId, (BYTE*)szBuf, nActualSize );
        
        hr = E_OUTOFMEMORY;
        goto Exit;        
    }
    
    // get an action node
    pAction = pWireTap->GetAction();
    if ( pAction == NULL )
    {
        XomNtEvent( XEVENT_XWIRETAP_MEMORY_WARNING_6, "CMgmtInterface::MgmtCmdCloseTap:  There are no more Action nodes.  This request has failed.  Please re-config with more memory to avoid this.");
        XomTrace0( XWireTap, L_ERROR, "CMgmtInterface::MgmtCmdCloseTap:  There are no more Action nodes.  This request has failed.  Please re-config with more memory to avoid this.");

        nActualSize = safe_snprintf( szBuf, sizeof(szBuf), "XWireTap:(ERROR) There are no more Action nodes.  This request has failed.  Please re-config with more memory to avoid this.");
        pResponseInterface->WriteResponse( dwRequestId, (BYTE*)szBuf, nActualSize );
        
        pWireTap->ReleasePacketNode(pPacketNode);
        hr = E_OUTOFMEMORY;
        goto Exit;        
    }
    
    // change the ip string into the DWORD rep
    qwTapId = QwordFromHexStr( (char*)argv[1] );

    XomTrace1( XWireTap, L_LOW, "CMgmtInterface::MgmtCmdCloseTap:  Signalling close on TAP(0x%I64X).", qwTapId );
    
    // set up the action
    memcpy( PACKETNODE_DATA_ADDR(pPacketNode), &qwTapId, sizeof(ULONGLONG));
    pAction->Setup(  CWTAction::CLOSE_TAP, (LPBYTE)pPacketNode );
    
    // post the action to the completion port.
    hr = pWireTap->GetMasterCompletionPort()->PostCompletion( (CCompletionContext*) pAction, sizeof(CWTAction), NULL );
    if ( FAILED(hr) )
    {
        XomNtEvent( XEVENT_XWIRETAP_TAP_CREATION_ERROR_8, "CMgmtInterface::MgmtCmdCloseTap: Failed to post this TAP to the WireTap service.  TAP creation failed. :  RESULT = 0x%X.", hr );
        XomTrace1( XWireTap, L_ERROR, "CMgmtInterface::MgmtCmdCloseTap: Failed to post this TAP to the WireTap service.  TAP creation failed. :  RESULT = 0x%X.", hr );

        pWireTap->ReleasePacketNode(pPacketNode);
        pWireTap->ReleaseAction( pAction );
        pWireTap->DecNumTaps();
        goto Exit;        
    }

    nActualSize = safe_snprintf( szBuf, sizeof(szBuf), "XWireTap:  Tap 0x%I64X has signaled to be closed.  Please check the event logs for further details on this progress.", qwTapId);
    pResponseInterface->WriteResponse( dwRequestId, (BYTE*)szBuf, nActualSize );

Exit:
    pWireTap->ReleaseInstance();
    return hr;
}


//------------------------------------------------------------------------------
//  MgmtCmdRollTap:
//------------------------------------------------------------------------------
HRESULT CMgmtInterface::MgmtCmdRollTap(    
                                IN LPVOID lpCmdData,
                                IN CMgmtInterface *pMgmtInf,
                                IN DWORD dwRequestId,
                                IN CXomControlResponseInterface *pResponseInterface,
                                IN DWORD argc,
                                IN LPCSTR argv[] )
{
    HRESULT     hr = S_OK;
    char        szBuf[MAX_MGMT_RESPONSE_SIZE];
    CWireTap*   pWireTap = CWireTap::GetInstance();
    CWTAction*  pAction = NULL;
    int         nActualSize = 0;
    ULONGLONG   qwTapId = 0;
    PacketNode  *pPacketNode = NULL;

    XOMASSERT( pWireTap != NULL );
    
    // ensure the args
    if ( argc < 2 )
    {
        OutputRolloverCmdLine( pResponseInterface, dwRequestId );
        hr = E_INVALIDARG;
        goto Exit;
    }

    // get a packet Node.... this is how we're going to send the id.
    pPacketNode = pWireTap->GetPacketNode();
    if ( pPacketNode == NULL )
    {
        XomNtEvent( XEVENT_XWIRETAP_MEMORY_WARNING_7, "CMgmtInterface::MgmtCmdRollTap:  Could not attain enough memory to build this request.  Try again later.");
        XomTrace0( XWireTap, L_ERROR, "CMgmtInterface::MgmtCmdRollTap:  Could not attain enough memory to build this request.  Try again later.");

        nActualSize = safe_snprintf( szBuf, sizeof(szBuf), "XWireTap:(ERROR) There is not enough memory to handle this request.  Please try again later.");
        pResponseInterface->WriteResponse( dwRequestId, (BYTE*)szBuf, nActualSize );
        
        hr = E_OUTOFMEMORY;
        goto Exit;        
    }

    // get an action node
    pAction = pWireTap->GetAction();
    if ( pAction == NULL )
    {
        XomNtEvent( XEVENT_XWIRETAP_MEMORY_WARNING_8, "CMgmtInterface::MgmtCmdRollTap:  There are no more Action nodes.  This request has failed.  Please re-config with more memory to avoid this.");
        XomTrace0( XWireTap, L_ERROR, "CMgmtInterface::MgmtCmdRollTap:  There are no more Action nodes.  This request has failed.  Please re-config with more memory to avoid this.");

        nActualSize = safe_snprintf( szBuf, sizeof(szBuf), "XWireTap:(ERROR) There are no more Action nodes.  This request has failed.  Please re-config with more memory to avoid this.");
        pResponseInterface->WriteResponse( dwRequestId, (BYTE*)szBuf, nActualSize );
        pWireTap->ReleasePacketNode(pPacketNode);
  
        hr = E_OUTOFMEMORY;
        goto Exit;        
    }
    
    // change the ip string into the DWORD rep
    qwTapId = QwordFromHexStr( (char*)argv[1] );
    
    // set up the action
    memcpy( PACKETNODE_DATA_ADDR(pPacketNode), &qwTapId, sizeof(ULONGLONG));    
    pAction->Setup(  CWTAction::ROLL_TAP, (LPBYTE)pPacketNode );
    
    // post the action to the completion port.
    hr = pWireTap->GetMasterCompletionPort()->PostCompletion( (CCompletionContext*) pAction, sizeof(CWTAction), NULL );
    if ( FAILED(hr) )
    {
        XomNtEvent( XEVENT_XWIRETAP_TAP_CREATION_ERROR_9, "CMgmtInterface::MgmtCmdRollTap: Failed to post this TAP to the WireTap service.  TAP creation failed. :  RESULT = 0x%X.", hr );
        XomTrace1( XWireTap, L_ERROR, "CMgmtInterface::MgmtCmdRollTap: Failed to post this TAP to the WireTap service.  TAP creation failed. :  RESULT = 0x%X.", hr );

        pWireTap->ReleasePacketNode(pPacketNode);
        pWireTap->ReleaseAction( pAction );
        pWireTap->DecNumTaps();
        goto Exit;        
    }

    nActualSize = safe_snprintf( szBuf, sizeof(szBuf), "XWireTap:  Tap 0x%I64X has signaled for a CAP file rollover.  This action should be performed momentarily.", qwTapId);
    pResponseInterface->WriteResponse( dwRequestId, (BYTE*)szBuf, nActualSize );

Exit:
    pWireTap->ReleaseInstance();
    return hr;

}




//------------------------------------------------------------------------------
//  CXMgmtControlCallback Implementation.
//------------------------------------------------------------------------------


//------------------------------------------------------------------------------
//  ParseArgList:  Parses the arguements and calls the correct register function.
//     Code from BaseProvider.cpp
//------------------------------------------------------------------------------
HRESULT CXMgmtControlCallback::ParseArgList(
    IN  LPCSTR pszRequest,
    OUT DWORD *pdwArgc,
    OUT LPCSTR **ppArgv
    )
{
    HRESULT hr = S_OK;
    DWORD dwArgc = 0;
    LPCSTR *pArgv = NULL;

    if ( NULL == pdwArgc || NULL == ppArgv )
    {
        return E_INVALIDARG;
    }
    
    // initialize return params
    *pdwArgc = 0;
    *ppArgv = NULL;
    
    // parse the request into separate arguments
    DWORD dwCmdTextSize = strlen(pszRequest) + 1;
    LPSTR pszCmdText = (LPSTR)XAlloc(dwCmdTextSize);
    if ( NULL == pszCmdText )
    {
        XomNtEvent(XEVENT_XWIRETAP_MEMORY_WARNING_9, "CXMgmtControlCallback::ParseArgList: Failed to allocate %d bytes.", strlen(pszRequest));
        XomTrace1(XWireTap, L_ERROR, "CXMgmtControlCallback::ParseArgList: Failed to allocate %d bytes.",  strlen(pszRequest));
        
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    ZeroMemory(pszCmdText, dwCmdTextSize);
    
    // get rid of leading, trailing, and extra whitespace
    LPCSTR src = pszRequest;
    LPSTR dst = pszCmdText;

    // advance past any leading whitespace
    while ( *src && isspace(*src) )
        src++;

    // copy cmd string eliminating any extra whitespace and putting NUL chars
    // between the arguments
    while ( *src )
    {
        if ( '"' == *src )
        {
            src++;
            while ( *src && '"' != *src )
            {
                *dst++ = *src++;
            }
            
            if ( '"' != *src )
            {
                hr = E_INVALIDARG;
                goto Exit;
            }
            
            // skip any whitespace after the "
            while ( isspace(*++src) )
                ;
            
            *dst++ = '\0';
            dwArgc++;
            continue;
        }

        *dst = *src;

        if ( isspace(*src) )
        {
            *dst = '\0';
            dwArgc++;
            src++;
            while ( *src && isspace(*src) )
            {
                src++;
            }
        }
        else
        {
            src++;
        }
        dst++;
    }

    // if the last character copied wasn't whitespace, increment arg count
    if ( src > pszRequest && !isspace(*(src-1)) && '"' != *(src-1) )
    {
        dwArgc++;
    }
    
    // remove any trailing spaces
    dst = pszCmdText + strlen(pszCmdText) - 1;
    while (*dst && isspace(*dst))
    {
        dst--;
    }

    // allocate and assign the argument list
    if ( dwArgc > 0 )
    {
        DWORD dwSize = dwArgc * sizeof(pArgv[0]);
        DWORD i = 0;
        DWORD j = 0;
        LPCSTR pArg = NULL;
        
        pArgv = (LPCSTR*)XAlloc(dwSize);
        if ( NULL == pArgv )
        {
            XomNtEvent(XEVENT_KDC_BASE_NO_MEMORY_2, "CXMgmtControlCallback::ParseArgList: failed to allocate %d bytes.", dwSize);
            XomTrace1(XWireTap, L_ERROR, "CXMgmtControlCallback::ParseArgList: failed to allocate %d bytes.", dwSize);

            hr = E_OUTOFMEMORY;
            goto Exit;
        }
        ZeroMemory(pArgv, dwSize);

        pArg = pszCmdText;
        for ( i=0; i < dwArgc; i++ )
        {
            pArgv[i] = pArg;
            pArg = pArg + strlen(pArg) + 1;
        }
    }

    if ( !FAILED(hr) )
    {
        *pdwArgc = dwArgc;
        *ppArgv = pArgv;
    }

Exit:
    return hr;
}


//------------------------------------------------------------------------------
//  OnControlRequest:  Called when cmd received through XMGMT stuff.
//     Code from BaseProvider.cpp
//------------------------------------------------------------------------------
HRESULT CXMgmtControlCallback::OnControlRequest(
    IN  LPCSTR pszRequest,
    IN  DWORD dwRequestId,
    IN  CXomControlResponseInterface* pResponseInterface
    )
{
    HRESULT hr = S_OK;
    DWORD dwArgc = 0;
    LPCSTR *pArgv = NULL;
    DWORD i = 0;

    XOMASSERT( m_pMgmtInterface != NULL );

    hr = ParseArgList(pszRequest, &dwArgc, &pArgv);
    if ( FAILED(hr) )
    {
        CHAR szResponse[MAX_MGMT_RESPONSE_SIZE];
        _snprintf(szResponse, MAX_MGMT_RESPONSE_SIZE-1, "CXMgmtControlCallback::OnControlRequest: failed with hr = 0x%08X.\r\n", hr);
        pResponseInterface->WriteResponse(dwRequestId, (BYTE*) szResponse, (DWORD)-1);
    }
    
    for ( i=0; i < m_pMgmtInterface->GetNumberOfRegisteredCommands(); i++ )
    {
        if ( 0 == _strnicmp(pszRequest, m_pMgmtInterface->m_pCmdList[i].szCmdName, m_pMgmtInterface->m_pCmdList[i].dwCmdNameLen) )
        {
            hr = (*(m_pMgmtInterface->m_pCmdList[i].pfnCmdProc))(
                    m_pMgmtInterface->m_pCmdList[i].lpData,
                    m_pMgmtInterface,
                    dwRequestId,
                    pResponseInterface,
                    dwArgc,
                    pArgv
                    );

            
            if ( FAILED(hr) )
            {
                CHAR szResponse[MAX_MGMT_RESPONSE_SIZE];
                _snprintf(szResponse, MAX_MGMT_RESPONSE_SIZE-1, "%s: failed with hr = 0x%08X.\r\n", m_pMgmtInterface->m_pCmdList[i].szCmdName, hr);
                pResponseInterface->WriteResponse(dwRequestId, (BYTE*) szResponse, (DWORD)-1);
            }
            
            break;
        }
    }

    if ( pArgv )
    {
        if ( pArgv[0] )
        {
            XFree((LPVOID)pArgv[0]);
            pArgv[0] = NULL;
        }
        
        XFree((LPVOID)pArgv);
        pArgv = 0;
        dwArgc = 0;
    }
    
    return hr;
}


//------------------------------------------------------------------------------
//  Local Function Implementation
//------------------------------------------------------------------------------


//------------------------------------------------------------------------------
//  OutputAddCmdLine:  output the command line 
//------------------------------------------------------------------------------
void OutputAddCmdLine( CXomControlResponseInterface *pResponseInterface, DWORD dwRequestId )
{
    CHAR szBuf[MAX_MGMT_RESPONSE_SIZE];
    int nActualSize = 0;

    nActualSize = safe_snprintf( szBuf, sizeof(szBuf), "\nUsage:  >e :xwiretap AddTap <key type>=<key> [lifetime=<##h##m##s>]\n");
    pResponseInterface->WriteResponse( dwRequestId, (BYTE*)szBuf, nActualSize );

    nActualSize = safe_snprintf( szBuf, sizeof(szBuf), "     key-type => xboxPUID, userPUID, srcIP  -- NOTE:  PUIDs should be in Hex format.\n");
    pResponseInterface->WriteResponse( dwRequestId, (BYTE*)szBuf, nActualSize );

    nActualSize = safe_snprintf( szBuf, sizeof(szBuf), "     lifetime => optional param to indicate the inactive lifetime of a tap.  Default is eternity.\n");
    pResponseInterface->WriteResponse( dwRequestId, (BYTE*)szBuf, nActualSize );

}

//------------------------------------------------------------------------------
//  OutputCloseCmdLine:  output the command line 
//------------------------------------------------------------------------------
void OutputCloseCmdLine( CXomControlResponseInterface *pResponseInterface, DWORD dwRequestId )
{
    CHAR szBuf[MAX_MGMT_RESPONSE_SIZE];
    int nActualSize = 0;

    nActualSize = safe_snprintf( szBuf, sizeof(szBuf), "\nUsage:  >e :xwiretap CloseTap <tap id>\n");
    pResponseInterface->WriteResponse( dwRequestId, (BYTE*)szBuf, nActualSize );

}

//------------------------------------------------------------------------------
//  OutputCloseCmdLine:  output the command line 
//------------------------------------------------------------------------------
void OutputRolloverCmdLine( CXomControlResponseInterface *pResponseInterface, DWORD dwRequestId )
{
    CHAR szBuf[MAX_MGMT_RESPONSE_SIZE];
    int nActualSize = 0;

    nActualSize = safe_snprintf( szBuf, sizeof(szBuf), "\nUsage:  >e :xwiretap Rollover <tap id>\n");
    pResponseInterface->WriteResponse( dwRequestId, (BYTE*)szBuf, nActualSize );

}

//------------------------------------------------------------------
//  StringToTime:  Basic breakdown of an hours, minutes seconds
//          string into a value for hours, minutes and seconds.
//          FORMAT:  All seconds values are followed by s
//                   All minute values are followed by m
//                   All hour values are followed by h
//          Returns fales for invalid params.
//------------------------------------------------------------------
BOOL StringToTime( const char *szTimeStr, DWORD *pdwHours, DWORD *pdwMinutes, DWORD *pdwSeconds )
{
    int nStrSize = 0;
    BOOL bRes = TRUE;                                   // result value.
    int nCurValSize = 0;
    char *szPos = NULL;
    char *szStart = NULL;

    // ensure values.
    if ( szTimeStr == NULL || 
         pdwHours == NULL  || 
         pdwMinutes == NULL || 
         pdwSeconds == NULL )
    {
        bRes = FALSE;
        goto CleanUp;
    }

    // get the size of the time string.
    nStrSize = (int)strlen( szTimeStr );

    // set up values for scan
    szPos = (char*)szTimeStr;
    szStart = szPos;
    nCurValSize = 0;
    *pdwHours = 0;
    *pdwMinutes = 0;
    *pdwSeconds = 0;

    // scan the string and get what we want
    while ( *szPos != '\0' )
    {        
        if ( *szPos >= '0' && *szPos <= '9'  )
        {
            nCurValSize++;
        }
        else if ( nCurValSize > 0 && ( *szPos == 's' || *szPos == 'S' ) )
        {
            *szPos = '\0';
            *pdwSeconds = atoi(szStart);
            *szPos = 's';
            nCurValSize = 0;
            szStart = szPos;
            szStart++;
        }
        else if ( nCurValSize > 0 && ( *szPos == 'h' || *szPos == 'H' ) )
        {
            *szPos = '\0';
            *pdwHours = atoi(szStart);
            *szPos = 'h';
            nCurValSize = 0;
            szStart = szPos;
            szStart++;
        }
        else if ( nCurValSize > 0 && ( *szPos == 'm' || *szPos == 'M' ) )
        {
            *szPos = '\0';
            *pdwMinutes = atoi(szStart);
            *szPos = 'm';
            nCurValSize = 0;
            szStart = szPos;
            szStart++;
        }
        else
        {
            // I don't know what's in this buffer... just keep moving.
            szStart = szPos;
            szStart++;
            nCurValSize = 0;
        }
        szPos++;
    }

    // we got some value but we dont' know what  ... assume it means seconds.
    if ( nCurValSize > 0 )
    {
        *pdwSeconds = atoi(szStart);
    }

CleanUp:
    return bRes;

}

//------------------------------------------------------------------
// StringToLowerCase: Change string to lower case.
//------------------------------------------------------------------
void StringToLowerCase( char *szResult, char *szSrc, DWORD dwSrcSize )
{
    DWORD dwX = 0;
    XOMASSERT( szResult != NULL );
    XOMASSERT( szSrc != NULL );

    // for each element in szSrc
    for ( dwX = 0; dwX < dwSrcSize; dwX++ )
    {
        szResult[dwX] = (char)tolower((int)szSrc[dwX]);
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wiretap\NodeBag.cpp ===
//-----------------------------------------------------------------------------
//  Microsoft (R) XWireTap (tm). 
//  Copyright (C) 2002. All rights reserved.
//
//  FILE: NodeBag.cpp
//
//  Implementation of the node bag.
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
//  Include
//-----------------------------------------------------------------------------
#include "StdAfx.h"

//-----------------------------------------------------------------------------
//  CNodeBag Implementation
//-----------------------------------------------------------------------------
CNodeBag::CNodeBag()
{
    InitializeCriticalSection( &m_csListLock );
    m_pListHead = NULL;
}

CNodeBag::~CNodeBag(void)
{
    EnterCriticalSection( &m_csListLock );

    if ( m_pNodeList != NULL )
    {
        m_pListHead = NULL;
        XFree(m_pNodeList);
    }

    LeaveCriticalSection( &m_csListLock );

    DeleteCriticalSection( &m_csListLock );
}

//-----------------------------------------------------------------------------
//  Initialize:  Creates the node bag.
//-----------------------------------------------------------------------------
HRESULT CNodeBag::Initialize(DWORD dwNodeSize, DWORD dwNumOfNodes )
{
    DWORD dwX = 0;                 // loop counter
    HRESULT hr = S_OK;

    InitializeCriticalSection( &m_csListLock );

    EnterCriticalSection( &m_csListLock );

    // create the memory buffer.
    m_pNodeList = (BYTE*)XAlloc( dwNodeSize * dwNumOfNodes );
    if ( m_pNodeList == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    ZeroMemory( m_pNodeList, dwNodeSize * dwNumOfNodes );
    
    // put the nodes into the bag.
    m_pListHead = (ListNode*)m_pNodeList;
    InitializeListHead( m_pListHead );

    for ( dwX = 0; dwX < dwNumOfNodes; dwX++ )
    {
        // insert to the tail.
        InsertTailList( m_pListHead, (ListNode*)&(m_pNodeList[dwX * dwNodeSize] ) );
    }
    
Exit:
    LeaveCriticalSection( &m_csListLock );
    return hr;
}

//-----------------------------------------------------------------------------
//  GetFromBag:  Gets an unused node from the bag.
//-----------------------------------------------------------------------------
ListNode* CNodeBag::GetFromBag()
{
    ListNode *pRes = NULL;
    EnterCriticalSection( &m_csListLock );

    if ( m_pListHead == NULL )
    {
        goto Exit;
    }

    // get the next free node.
    pRes = m_pListHead;

    // check if this is the last in the list.
    if ( m_pListHead->m_pNext == m_pListHead )
    {
        m_pListHead = NULL;
    }
    else
    {
        // remove the entry from the list.
        m_pListHead = m_pListHead->m_pNext;
        RemoveEntryList( pRes );
    }
    
Exit:
    LeaveCriticalSection( &m_csListLock );
    return pRes;
}

//-----------------------------------------------------------------------------
//  PutInBag:  Puts a node back in the bag.
//      NOTE:  Node POINTERS SHOULD BE NULL.
//-----------------------------------------------------------------------------
void CNodeBag::PutInBag( ListNode *pNode )
{
    EnterCriticalSection( &m_csListLock );

    XOMASSERT( pNode->m_pNext == NULL );
    XOMASSERT( pNode->m_pPrev == NULL );

    // check if the list is empty.
    if ( m_pListHead == NULL )
    {
        m_pListHead = pNode;
        InitializeListHead(m_pListHead);
    }
    else
    {
        // otherwise... insert to the tail.
        InsertTailList( m_pListHead, pNode );
    }

    LeaveCriticalSection( &m_csListLock );
}

//-----------------------------------------------------------------------------
//  IsEmpty():  Determines in the bag is empty.
//-----------------------------------------------------------------------------
BOOL CNodeBag::IsEmpty()
{
    return ( m_pListHead == NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wiretap\NodeBag.h ===
//-----------------------------------------------------------------------------
//  Microsoft (R) XWireTap (tm). 
//  Copyright (C) 2002. All rights reserved.
//
//  FILE: NodeBag.h
//
//  Interface NodeBag Implementation.
//-----------------------------------------------------------------------------

#pragma once

//-----------------------------------------------------------------------------
// Includes
//-----------------------------------------------------------------------------
#include "ListMacros.h"
#include <XAlloc.h>

//-----------------------------------------------------------------------------
// CNodeBag
//-----------------------------------------------------------------------------

class CNodeBag
{
public:
    CNodeBag( );
    virtual ~CNodeBag(void);

    // call before using.
    HRESULT Initialize( DWORD dwNodeSize, DWORD dwNumOfNodes );

    // Bag access functions
    ListNode*           GetFromBag();
    void                PutInBag( ListNode *pNode );

    BOOL                IsEmpty();

    // overrides
    void *operator new(size_t len) { return XAlloc(len); }
    void operator delete(void *pv) { XFree(pv); }

private:
    
    BYTE*               m_pNodeList;
    ListNode*           m_pListHead;
    DWORD               m_dwNodeSize;
    DWORD               m_dwNumOfNodes;

    CRITICAL_SECTION    m_csListLock;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wiretap\ProdCons.cpp ===
//-----------------------------------------------------------------------------
//  Microsoft (R) XWireTap (tm). 
//  Copyright (C) 2002. All rights reserved.
//
//  FILE: ProdCons.h
//
//  Producer/Consumer buffer implementation.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// INCLUDES
//-----------------------------------------------------------------------------
#include "StdAfx.h"

//-----------------------------------------------------------------------------
//  Logging Area
//-----------------------------------------------------------------------------
XomDefineArea(XWireTapProdCons);

//-----------------------------------------------------------------------------
//  Definitions
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  Types/Structures
//-----------------------------------------------------------------------------
typedef struct _QueueNode
{
    ListNode    m_Link;
    DWORD       m_dwID;
    LPVOID      m_pData;
} QueueNode;

//-----------------------------------------------------------------------------
//  CProdConsBuffer Implementation
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  Constructor/Destructor
//-----------------------------------------------------------------------------
CProdConsBuffer::CProdConsBuffer( )
{
    m_pNodeBag = NULL;
    InitializeCriticalSection( &m_csQueueLock );
    
}

CProdConsBuffer::~CProdConsBuffer(void)
{
    if ( m_pNodeBag != NULL )
    {
        delete m_pNodeBag;
        m_pNodeBag = NULL;
    }

    CloseHandle( m_hWakeUpEvent );
    DeleteCriticalSection( &m_csQueueLock );
}


//-----------------------------------------------------------------------------
//  Initialize:  initializes the object.
//-----------------------------------------------------------------------------
HRESULT CProdConsBuffer::Initialize( DWORD dwQueueSize )
{
    HRESULT hr = S_OK;

    // create the node bag
    m_pNodeBag = new CNodeBag();

    if ( m_pNodeBag == NULL )
    {
        XomTrace0( XWireTapProdCons, L_ERROR, "CProdConsBuffer::Initialize:  Not enough memory to create node bag." );
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // initialize the node bag
    hr = m_pNodeBag->Initialize( sizeof(QueueNode), dwQueueSize );
    if ( FAILED(hr) )
    {
        XomTrace1( XWireTapProdCons, L_ERROR, "CProdConsBuffer::Initialize:  Failed to initialize Node Bag.  RESULT = 0x%X", hr );
        goto Exit;
    }

    // create the wakeup event
    m_hWakeUpEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
    if ( m_hWakeUpEvent == NULL )
    {
        hr = MAKE_HRESULT( 1, FACILITY_WIN32, GetLastError() );
        XomTrace1( XWireTapProdCons, L_ERROR, "CProdConsBuffer::Initialize:  Failed to create WakeUp event.  RESULT = 0x%X", hr );
        goto Exit;
    }

    // set the queue head.
    InitializeListHead( &m_QueueHead );

    m_dwWaitTime = INFINITE;

Exit:
    XomTrace1( XWireTapProdCons, L_LOW, "CProdConsBuffer::Initialize:  Completed with Result = 0x%X", hr );
    
    return hr;
}

//-----------------------------------------------------------------------------
//  Initialize:  initializes the object.
//-----------------------------------------------------------------------------
HRESULT CProdConsBuffer::Initialize( DWORD dwQueueSize, DWORD dwWaitTime )
{
    HRESULT hr = S_OK;

    hr = Initialize( dwQueueSize );
    if ( FAILED(hr) )
    {
        goto Exit;
    }

    m_dwWaitTime = dwWaitTime;
    
Exit:
    return hr;
}

//-----------------------------------------------------------------------------
//  Get:  Gets the next element off the Prod/cons queue.  Blocks in empty.
//-----------------------------------------------------------------------------
HRESULT CProdConsBuffer::Get( LPVOID *ppItem, DWORD *pdwIdentifier )
{
    HRESULT hr = S_OK;
    DWORD dwSignal = 0;

    XOMASSERT( ppItem != NULL );

    if ( m_hWakeUpEvent == NULL || m_pNodeBag == NULL )
    {
        XomTrace0( XWireTapProdCons, L_ERROR, "CProdConsBuffer::Get: Trying to Get from a non-initialized queue." );
        hr = E_INVALIDARG;
        goto Exit;
    }

    dwSignal = WaitForSingleObject( m_hWakeUpEvent, m_dwWaitTime );
    switch( dwSignal )
    {
    case WAIT_OBJECT_0:
        {
            QueueNode *pNode; 

            // get the lock
            EnterCriticalSection( &m_csQueueLock );
            
            // note:  this queue should not be empty if we get here.
            XOMASSERT( !IsListEmpty(&m_QueueHead) );

            pNode = (QueueNode*)(m_QueueHead.m_pNext);

            // get the next node from the queue.
            *ppItem = pNode->m_pData;
            *pdwIdentifier = pNode->m_dwID;
            RemoveEntryList(&(pNode->m_Link));

            // if the queue is empty... reset the wakeup event.
            if ( IsListEmpty(&m_QueueHead) )
            {
                ResetEvent( m_hWakeUpEvent );
            }
            
            // release the lock.
            LeaveCriticalSection( &m_csQueueLock );

            // put this node back in the back
            pNode->m_pData = NULL;
            pNode->m_dwID = 0;
            m_pNodeBag->PutInBag( (ListNode*)pNode );
        }
        break;
    case WAIT_TIMEOUT:
        {
            // timed out... we should do this again.
            XomTrace0( XWireTapProdCons, L_INFO, "CProdConsBuffer::Get: We timed out." );
            hr = S_FALSE;
            goto Exit;
        }
        break;
    case WAIT_ABANDONED:
        {
            // this is a problem... the handle went away... 
            XomTrace0( XWireTapProdCons, L_WARNING, "CProdConsBuffer::Get: Event was abandoned." );
            hr = E_FAIL;
            goto Exit;
        }
        break;
    default:
        {
            //todo:  Do some logging here.
            XomTrace0( XWireTapProdCons, L_WARNING, "CProdConsBuffer::Get: Event signalled produced an unknown result." );
            hr = E_FAIL;
            goto Exit;
        }
    }
Exit:
    XomTrace1( XWireTapProdCons, L_LOW, "CProdConsBuffer::Get:  Completed with Result = 0x%X", hr );    
    return hr;
}

//-----------------------------------------------------------------------------
// Put:  Puts an entry on the queue.  Signals wake up event.
//-----------------------------------------------------------------------------
HRESULT CProdConsBuffer::Put( LPVOID pItem , DWORD dwIdentifier)
{
    HRESULT hr = S_OK;
    QueueNode *pNode = NULL;

    if ( m_hWakeUpEvent == NULL || m_pNodeBag == NULL )
    {
        XomTrace0( XWireTapProdCons, L_ERROR, "CProdConsBuffer::Put: Trying to Put from a non-initialized queue." );
        hr = E_INVALIDARG;
        goto Exit;
    }

    // get a node from the bag.
    pNode = (QueueNode*)m_pNodeBag->GetFromBag();
    if ( pNode == NULL )
    {
        // ouch... we've already used everything in the bag.  Oh well... list is full right now.
        XomTrace0( XWireTapProdCons, L_ERROR, "CProdConsBuffer::Put: Queue is FULL nothing we can do." );
        hr = E_FAIL;
        goto Exit;
    }

    // point at the same object.
    pNode->m_pData = pItem;
    pNode->m_dwID  = dwIdentifier;

    // enter the critical section
    EnterCriticalSection( &m_csQueueLock );

    // add this entry to the queue.
    InsertTailList( &m_QueueHead, ((ListNode*)pNode) );

    // set the event.
    SetEvent( m_hWakeUpEvent );

    // leave the critical section
    LeaveCriticalSection( &m_csQueueLock );

Exit:
    XomTrace1( XWireTapProdCons, L_LOW, "CProdConsBuffer::Put:  Completed with Result = 0x%X", hr );    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wiretap\ReceiverList.cpp ===
//-----------------------------------------------------------------------------
//  Microsoft (R) XWireTap (tm). 
//  Copyright (C) 2002. All rights reserved.
//
//  FILE: ReceiverList.cpp
//
//  Implementation of the ReceiverList.
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
//  Include
//-----------------------------------------------------------------------------
#include "stdafx.h"

//-----------------------------------------------------------------------------
//  Types and Structures
//-----------------------------------------------------------------------------
XomImportArea(XWireTap);

//-----------------------------------------------------------------------------
//  CReceiverList  Implementation
//-----------------------------------------------------------------------------
CReceiverList::CReceiverList(void)
{
    m_pReceiverNodeBag = NULL;
    m_pCarrierNodeBag = NULL;
    m_pMasterList = NULL; 
    m_pWireTap = NULL;
    
}

CReceiverList::~CReceiverList(void)
{
}

//-----------------------------------------------------------------------------
//  Initialize:  Initializes
//-----------------------------------------------------------------------------
HRESULT CReceiverList::Initialize( DWORD dwNumOfReceiverNodes, DWORD dwNumOfCarrierNodes )
{
    HRESULT hr = S_OK;
    
    m_pWireTap = CWireTap::GetInstance();
    if ( FAILED(hr) )
    {
        XomNtEvent( XEVENT_XWIRETAP_GENERIC_ERROR_5, "CReceiverList::Initialize:  You cannot create a TAP without the wiretap interface.  Please initialize that first." );        
        XomTrace0( XWireTap, L_ERROR, "CReceiverList::Initialize:  You cannot create a TAP without the wiretap interface.  Please initialize that first." );        
        hr = E_FAIL;
        goto Exit;
    }

    XomTrace0( XWireTap, L_LOW, "CReceiverList::Initialize:  Creating Receiver List Nodebag.");
    // create a new node bag.
    m_pReceiverNodeBag = new CNodeBag();
    if ( m_pReceiverNodeBag == NULL )
    {
        // not enough memory to create wiretap instance.
        XomNtEvent( XEVENT_XWIRETAP_MEMORY_WARNING_10, "CReceiverList::Initialize:  Failed to allocated memory for the Receiver Node Bag handle.  Please ensure machine has enough available RAM to run this program.");
        XomTrace0( XWireTap, L_ERROR, "CReceiverList::Initialize:  Failed to allocated memory for the Receiver Node Bag handle.  Please ensure machine has enough available RAM to run this program.");
        hr = E_OUTOFMEMORY;
        goto Exit;        
    }

    XomTrace0( XWireTap, L_LOW, "CReceiverList::Initialize:  Initialize the packet buffer.");
    hr = m_pReceiverNodeBag->Initialize( sizeof(ReceiverListNode), dwNumOfReceiverNodes );
    if ( FAILED(hr) )
    {
        // not enough memory to create wiretap instance.
        XomNtEvent( XEVENT_XWIRETAP_MEMORY_WARNING_11, "CReceiverList::Initialize:  Failed to allocated memory for the Receiver Node Bag.  Please ensure machine has enough available RAM to run this program or modify config setting to work with the given resources.");
        XomTrace0( XWireTap, L_ERROR, "CReceiverList::Initialize:  Failed to allocated memory for the Receiver Node Bag.  Please ensure machine has enough available RAM to run this program or modify config setting to work with the given resources.");
        goto Exit;
    }

    XomTrace0( XWireTap, L_LOW, "CReceiverList::Initialize:  Creating Receiver List Nodebag.");
    // create a new node bag.
    m_pCarrierNodeBag = new CNodeBag();
    if ( m_pCarrierNodeBag == NULL )
    {
        // not enough memory to create wiretap instance.
        XomNtEvent( XEVENT_XWIRETAP_MEMORY_WARNING_12, "CReceiverList::Initialize:  Failed to allocated memory for the Carrier Node Bag handle.  Please ensure machine has enough available RAM to run this program.");
        XomTrace0( XWireTap, L_ERROR, "CReceiverList::Initialize:  Failed to allocated memory for the Carrier Node Bag handle.  Please ensure machine has enough available RAM to run this program.");
        hr = E_OUTOFMEMORY;
        goto Exit;        
    }

    XomTrace0( XWireTap, L_LOW, "CReceiverList::Initialize:  Initialize the packet buffer.");
    hr = m_pCarrierNodeBag->Initialize( sizeof(CarrierNode), dwNumOfCarrierNodes );
    if ( FAILED(hr) )
    {
        // not enough memory to create wiretap instance.
        XomNtEvent( XEVENT_XWIRETAP_MEMORY_WARNING_13, "CReceiverList::Initialize:  Failed to allocated memory for the Carrier Node Bag.  Please ensure machine has enough available RAM to run this program or modify config setting to work with the given resources.");
        XomTrace0( XWireTap, L_ERROR, "CReceiverList::Initialize:  Failed to allocated memory for the Carrier Node Bag.  Please ensure machine has enough available RAM to run this program or modify config setting to work with the given resources.");
        goto Exit;
    }

    m_pMasterList = new ListNode;
    if ( m_pMasterList == NULL )
    {
        // not enough memory to create wiretap instance.
        XomNtEvent( XEVENT_XWIRETAP_MEMORY_WARNING_14, "CReceiverList::Initialize:  Failed to allocated memory for the Carrier Node Bag handle.  Please ensure machine has enough available RAM to run this program.");
        XomTrace0( XWireTap, L_ERROR, "CReceiverList::Initialize:  Failed to allocated memory for the Carrier Node Bag handle.  Please ensure machine has enough available RAM to run this program.");
        hr = E_OUTOFMEMORY;
        goto Exit;        
    }
    InitializeListHead( m_pMasterList );

Exit:
    return hr;
}

//-----------------------------------------------------------------------------
//  CReceiverList  Implementation
//-----------------------------------------------------------------------------
HRESULT CReceiverList::Terminate( )
{
    // if the memory is not NULL... free it.
    if ( m_pReceiverNodeBag )
    {
        delete m_pReceiverNodeBag;
    }

    if ( m_pCarrierNodeBag )
    {
        delete m_pCarrierNodeBag;
    }
    
    if ( m_pMasterList )
    {
        delete m_pMasterList;
    }

    if ( m_pWireTap )
    {
        m_pWireTap = NULL;
        CWireTap::ReleaseInstance();
    }

    return S_OK;    
}

//-----------------------------------------------------------------------------
//  Add:  Adds a new receiver node under the given key to the hash table and
//          master list.
//-----------------------------------------------------------------------------
HRESULT CReceiverList::Add( BYTE* pKey )
{
    HRESULT hr = S_OK;
    ReceiverListNode *pNewRN = NULL;
    CActivityMonitor *pNewActivityMonitor = NULL;    

    XOMASSERT( m_pWireTap );

    CScheduler *pScheduler = m_pWireTap->GetSchedulerInstance();

    if ( pScheduler == NULL )
    {
        hr = E_FAIL;
        goto Exit;                
    }
    
    // get a new node.
    pNewRN = (ReceiverListNode*)(m_pReceiverNodeBag->GetFromBag());
    if ( pNewRN == NULL )
    {
        // not enough memory to create wiretap instance.
        XomNtEvent( XEVENT_XWIRETAP_MEMORY_WARNING_15, "CReceiverList::Add:  Receiver List Bag is out of nodes.  Please re-configure this system with enough memory to handle the tasks you require.");
        XomTrace0( XWireTap, L_ERROR, "CReceiverList::Add:  Receiver List Bag is out of nodes.  Please re-configure this system with enough memory to handle the tasks you require.");
        hr = E_OUTOFMEMORY;
        goto Exit;        
    }

    // create a new callback for the session timeout.
    pNewActivityMonitor = new CActivityMonitor( pNewRN, this );
    if ( pNewActivityMonitor == NULL )
    {
        // not enough memory to create an activity monitor.
        XomNtEvent( XEVENT_XWIRETAP_MEMORY_WARNING_16, "CReceiverList::Add:  Failed to allocate memory for monitor appointment.  Please ensure this system has enough memory for the necessary interactions");
        XomTrace0( XWireTap, L_ERROR, "CReceiverList::Add:  Failed to allocate memory for monitor appointment.  Please ensure this system has enough memory for the necessary interactions");
        hr = E_OUTOFMEMORY;
        goto Exit;        
    }

    // create the appointment and add it to the scheduler.
    hr = pScheduler->CreateAppointment( ( pScheduler->GetCurrentTime() + m_pWireTap->GetReceiverNodeLifetime() ),
                                                        pNewActivityMonitor, 
                                                        0, 
                                                        &(pNewRN->m_hSessionTimeoutApt) );
    if ( FAILED(hr) )
    {
        // not enough memory to create an activity monitor.
        XomNtEvent( XEVENT_XWIRETAP_MEMORY_WARNING_17, "CReceiverList::Add:  Failed to create a session timeout appointment in the scheduler.");
        XomTrace0( XWireTap, L_ERROR, "CReceiverList::Add:  Failed to allocate memory for monitor appointment.  Please ensure this system has enough memory for the necessary interactions");
        goto Exit;        
    }

    pNewRN->m_hAuthDataRetryApt = 0;
    
    // copy key into node.
    memcpy( &(pNewRN->m_Key), pKey, HASH_KEY_SIZE );

    // set the auth data state.
    pNewRN->m_AuthDataState = ADS_NONE;

    // setup up other things.
    InitializeListHead(&pNewRN->m_TapList);
    InitializeListHead(&pNewRN->m_MasterLink);
    InitializeListHead(&pNewRN->m_ReceivedPackets);
    
    // Insert node into hash table. 
    Insert((HashListNode*) pNewRN);

    // Insert node into master list.
    InsertTailList( m_pMasterList, &(pNewRN->m_MasterLink) );

Exit:
    m_pWireTap->ReleaseSchedulerInstance();
    return hr;
}


//-----------------------------------------------------------------------------
//  Remove:  Remove a receiver node from teh list.
//-----------------------------------------------------------------------------
HRESULT CReceiverList::Remove( BYTE* pKey )
{
    HRESULT hr = S_OK;
    ReceiverListNode *pRN = NULL;
    PacketNode* pIter = NULL;

    XOMASSERT( m_pWireTap );

    CScheduler *pScheduler = m_pWireTap->GetSchedulerInstance();

    if ( pScheduler == NULL )
    {
        hr = E_FAIL;
        goto Exit;                
    }
    
    pRN = (ReceiverListNode*)Lookup( pKey );
    if ( pRN == NULL )
    {
        // what... this entry doesn't exist.!!!
        XomNtEvent( XEVENT_XWIRETAP_GENERIC_ERROR_6, "CReceiverList::Remove:  This entry does not exist in the hash table. KEY=0x%X", *((DWORD*)pKey));
        XomTrace1( XWireTap, L_ERROR, "CReceiverList::Remove:  This entry does not exist in the hash table. KEY=0x%X", *((DWORD*)pKey));
        XOMASSERT( pRN != NULL );
        hr = E_FAIL;
        goto Exit;        
    }

    // remove the entry from the lists.
    RemoveEntryList( &(pRN->m_MasterLink) );        // master list
    Delete( (HashListNode*) pRN );                  // hash table.

    // remove all packetnode entries for this node.
    while ( ( pIter = (PacketNode*)(GetQueuedPacket( pRN )) ) != NULL )
    {
        m_pWireTap->ReleasePacketNode( pIter );
    }
            
    // remove the appointment.
    if ( pRN->m_hAuthDataRetryApt != 0 )
    {
        hr = pScheduler->CloseAppointment( pRN->m_hAuthDataRetryApt );
        if ( FAILED(hr) )
        {
            XomTrace2( XWireTap, L_ERROR, "CReceiverList::Remove:  Could not close the auth data retry appointment. Possible memory leak.  KEY=0x%X", *((DWORD*)pKey), hr );
            hr = S_OK;
        }
    }
    
    hr = pScheduler->CloseAppointment( pRN->m_hSessionTimeoutApt );
    if ( FAILED(hr) )
    {            
        XomTrace2( XWireTap, L_ERROR, "CReceiverList::Remove:  Could not close Session Timeout appointment. Possible memory leak.  KEY=0x%X", *((DWORD*)pKey), hr );
        hr = S_OK;        
    }

    // clear the memory
    ZeroMemory( pRN, sizeof(ReceiverListNode) );

    // put it back in the bag.
    m_pReceiverNodeBag->PutInBag((ListNode*) pRN);

Exit:    
    m_pWireTap->ReleaseSchedulerInstance();
    return hr;
}

//-----------------------------------------------------------------------------
//  AssociateAuthData:  Copies Auth Data into ReceiverListNode
//-----------------------------------------------------------------------------
HRESULT CReceiverList::AssociateAuthData( BYTE* pKey, BYTE* pNode )
{
    HRESULT hr = S_OK;
    ReceiverListNode *pRN = NULL;
    CTap* pTap = NULL;
    CSgMsgSpiRep *pResp = NULL;
    PacketNode* pPacketNode = NULL;

    XOMASSERT( pNode != NULL );
    pPacketNode = (PacketNode*)pNode;
    pResp = (CSgMsgSpiRep*)PACKETNODE_DATA_ADDR(pPacketNode);

    XOMASSERT( m_pWireTap );
    XOMASSERT( pResp != NULL );

    CScheduler *pScheduler = m_pWireTap->GetSchedulerInstance();

    if ( pScheduler == NULL )
    {
        hr = E_FAIL;
        goto Exit;                
    }
    
    pRN = (ReceiverListNode*)Lookup( pKey );
    if ( pRN == NULL )
    {
        // what... this entry doesn't exist.!!!
        XomNtEvent( XEVENT_XWIRETAP_GENERIC_ERROR_7, "CReceiverList::AssociateAuthData:  This entry does not exist in the hash table. KEY=0x%X", *((DWORD*)pKey));
        XomTrace1( XWireTap, L_ERROR, "CReceiverList::AssociateAuthData:  This entry does not exist in the hash table. KEY=0x%X", *((DWORD*)pKey));
        hr = E_FAIL;
        goto Exit;        
    }

    // close the auth data appointment... if it exists.
    if ( pRN->m_hAuthDataRetryApt != 0 )
    {
        hr = pScheduler->CloseAppointment( pRN->m_hAuthDataRetryApt );
        if ( FAILED(hr) )
        {
            XomTrace1( XWireTap, L_ERROR, "CReceiverList::AssociateAuthData:  Could not close auth data appointment. KEY=0x%X", *((DWORD*)pKey));
            hr = S_OK;
        }
        pRN->m_hAuthDataRetryApt = 0;
    }

    // ensure this data does not already exist.
    if ( pRN->m_AuthDataState == ADS_DONE )
    {
        // this data has already been set?
        XomTrace1( XWireTap, L_ERROR, "CReceiverList::AssociateAuthData:  This entry already has Auth Data, just forget about it. KEY=0x%X", *((DWORD*)pKey));
        hr = S_FALSE;
        goto Exit;        
    }

    XomTrace1( XWireTap, L_LOW, "CReceiverList::AssociateAuthData:  Authdata identified.  KEY=0x%X", *((DWORD*)pKey) );

    // copy the proper data into our structure.
    memcpy( &(pRN->m_AuthData), (LPVOID)(((BYTE*)pResp) + sizeof(CSgMsgSpiRep) + sizeof (CSgMsgSpiData) + sizeof(CSgMsgHdr)), sizeof(XKERB_AD_XENON) );
    CSgMsgSpiData* pMsgData=(CSgMsgSpiData*)(((BYTE*)pResp)+sizeof(CSgMsgSpiRep));
    memcpy( &(pRN->m_AuthData._ipaI), &(pMsgData->_ipaI), sizeof(DWORD) );
    pRN->m_AuthData._ipportI = pMsgData->_ipportI;
                            
    pRN->m_AuthDataState = ADS_DONE;

    // scan the tap list and add all taps that match this data.
    for ( pTap = (CTap*)(m_pWireTap->GetTapList()->m_pNext); 
          (pTap != m_pWireTap->GetTapList()); 
          pTap = (CTap*)(pTap->m_pNext) )
    {        
        if ( pTap->IsAssociated( &(pRN->m_AuthData) ) )
        {
            // get a new node.
            CarrierNode *pCN = (CarrierNode*)(m_pCarrierNodeBag->GetFromBag());
            if ( pCN == NULL )
            {
                // not enough memory to create wiretap instance.
                XomNtEvent( XEVENT_XWIRETAP_MEMORY_WARNING_18, "CReceiverList::AssociateAuthData:  Carrier Node Bag is out of nodes.  Please re-configure this system with enough memory to handle the tasks you require.");
                XomTrace0( XWireTap, L_ERROR, "CReceiverList::AssociateAuthData:  Carrier Node Bag is out of nodes.  Please re-configure this system with enough memory to handle the tasks you require.");
                hr = E_OUTOFMEMORY;
                goto Exit;        
            }
            // attach this to the carrier node.
            pCN->m_pItem = (LPVOID)pTap;

            //put the node in the receiverListNodes Tap List.
            InsertTailList( &(pRN->m_TapList), ((ListNode*)pCN) );
            
            // post this info so the tap can create a file with this data.
            m_pWireTap->AddRefPacketNode( pPacketNode );
            hr = pTap->PostInfo( (LPVOID)pPacketNode );
            if ( FAILED(hr) )
            {                
                m_pWireTap->ReleasePacketNode( pPacketNode );
                // not enough memory to create wiretap instance.
                XomNtEvent( XEVENT_XWIRETAP_MEMORY_WARNING_19, "CReceiverList::AssociateAuthData:  Failed to post info to TAP(0x%I64X).  Result=0x%X", pTap->GetTapID(), hr );
                XomTrace2( XWireTap, L_ERROR, "CReceiverList::AssociateAuthData:  Failed to post info to TAP(0x%I64X).  Result=0x%X", pTap->GetTapID(), hr );
                continue;
            }            
        }
    }

Exit:    
    m_pWireTap->ReleaseSchedulerInstance();
    return hr;
}

//-----------------------------------------------------------------------------
//  RemoveTap:  Pulls a tap from the receiver list.
//-----------------------------------------------------------------------------
HRESULT CReceiverList::RemoveTap( ULONGLONG qwTapId )
{
    HRESULT hr = S_OK;
    ReceiverListNode* pRNTraverse = NULL;
    ListNode*         pTrav       = NULL;
    
    XOMASSERT( m_pWireTap );

    // scan the master list for this entry.
    for ( pTrav = m_pMasterList->m_pNext; pTrav != m_pMasterList; pTrav = pTrav->m_pNext )
    {
        CarrierNode*      pCNode      = NULL;

        // this really isn't a receiver node... so let's cast it to one.
        pRNTraverse = CONTAINING_RECORD( pTrav, ReceiverListNode, m_MasterLink );
        
        if ( IsListEmpty( &(pRNTraverse->m_TapList) ))
        {
            // if the list is empty it may be waiting on authdata... regardless if this tap doesn't exist it will get cleaned.
            
            // don't bother to send messages out.
            continue;
        }
        
        // for each TAP for the receiver node, if the id matchs... remove it.
        for ( pCNode = (CarrierNode*)(pRNTraverse->m_TapList.m_pNext); 
                ( pCNode->m_Link.m_pNext != (pRNTraverse->m_TapList.m_pNext) );   
                pCNode = (CarrierNode*)(pCNode->m_Link.m_pNext) )
        {
            CTap *pTap = (CTap*)pCNode->m_pItem;

            // if the node is here then it should exist.
            XOMASSERT( pTap != NULL );
            if ( pTap == NULL )
            {
                // why is this node here?  Forget it... just autocorrect
                RemoveEntryList( (ListNode*)pCNode );
                m_pCarrierNodeBag->PutInBag( (ListNode*)pCNode);
            }
            
            // remove everything with the identified id
            if ( pTap->GetTapID() == qwTapId )
            {
                RemoveEntryList( (ListNode*)pCNode );             
                ZeroMemory( pCNode, sizeof( CarrierNode ) );
                m_pCarrierNodeBag->PutInBag( (ListNode*)pCNode);
                break;
            }
        }
        
    }

    XomTrace1( XWireTap, L_ERROR, "CReceiverList::RemoveTap:  Remove Node Completed with RESULT = 0x%X.", hr);
    
    return hr;
}

//-----------------------------------------------------------------------------
//  AddTap:  Looks through receiver list for any nodes that are getting info
//     with similar auth data.
//-----------------------------------------------------------------------------
HRESULT CReceiverList::AddTap( CTap *pTap )
{
    HRESULT hr = S_OK;
    ReceiverListNode* pRNTraverse = NULL;
    CarrierNode*      pCNode      = NULL;
    ListNode*         pTrav       = NULL;
    
    XOMASSERT( m_pWireTap != NULL );
    XOMASSERT( pTap != NULL );

    // scan the master list for this entry.
    for ( pTrav = m_pMasterList->m_pNext; pTrav != m_pMasterList; pTrav = pTrav->m_pNext )
    {
        pRNTraverse = CONTAINING_RECORD( pTrav, ReceiverListNode, m_MasterLink );
        // see if the auth data association exists.
        if (!pTap->IsAssociated( &(pRNTraverse->m_AuthData) ) )
        {
            continue;
        }

        // get a new node.
        CarrierNode *pCN = (CarrierNode*)(m_pCarrierNodeBag->GetFromBag());
        if ( pCN == NULL )
        {
            // not enough memory to create wiretap instance.
            XomNtEvent( XEVENT_XWIRETAP_MEMORY_WARNING_20, "CReceiverList::AddTap:  Carrier Node Bag is out of nodes.  Please re-configure this system with enough memory to handle the tasks you require.");
            XomTrace0( XWireTap, L_ERROR, "CReceiverList::AddTap:  Carrier Node Bag is out of nodes.  Please re-configure this system with enough memory to handle the tasks you require.");
            hr = E_OUTOFMEMORY;
            goto Exit;        
        }

        pCN->m_pItem = (LPVOID)pTap;
        InsertTailList( &(pRNTraverse->m_TapList), (ListNode*)pCN);
        
    }
    
Exit:
    return hr;
}

//-----------------------------------------------------------------------------
//  GetCarrierNode:  Gets a carrier node from teh bag if possible,
//-----------------------------------------------------------------------------
ListNode* CReceiverList::GetCarrierNode()
{
    ListNode* pRes = NULL;
    XOMASSERT(m_pCarrierNodeBag);
    if ( m_pCarrierNodeBag )
    {
        pRes = m_pCarrierNodeBag->GetFromBag();
    }

    return pRes;
}

//-----------------------------------------------------------------------------
//  AddPacket:  Adds a packet to the receiver nodes list
//-----------------------------------------------------------------------------
HRESULT CReceiverList::AddPacket( ReceiverListNode* pNode, ListNode *pPacketNode )
{
    HRESULT hr = S_OK;

    XOMASSERT( m_pWireTap );
    CScheduler *pScheduler = m_pWireTap->GetSchedulerInstance();

    if ( pScheduler == NULL )
    {
        hr = E_FAIL;
        goto Exit;                
    }
    
    // get a new node.
    CarrierNode *pCN = (CarrierNode*)(m_pCarrierNodeBag->GetFromBag());
    if ( pCN == NULL )
    {
        // not enough memory to create wiretap instance.
        XomNtEvent( XEVENT_XWIRETAP_MEMORY_WARNING_21, "CReceiverList::AddTap:  Carrier Node Bag is out of nodes.  Please re-configure this system with enough memory to handle the tasks you require.");
        XomTrace0( XWireTap, L_ERROR, "CReceiverList::AddTap:  Carrier Node Bag is out of nodes.  Please re-configure this system with enough memory to handle the tasks you require.");
        hr = E_OUTOFMEMORY;
        goto Exit;        
    }

    // time stamp the node.
    pNode->m_qwLastAccessTime = pScheduler->GetCurrentTime();

    pCN->m_pItem = (LPVOID)pPacketNode;
    InsertTailList( &(pNode->m_ReceivedPackets), (ListNode*)pCN );

 Exit:
    m_pWireTap->ReleaseSchedulerInstance();
    return hr; 
}

//-----------------------------------------------------------------------------
//  GetQueuedPacket:  Pulls first entry in the queue packet list for this 
//      node and returns it.
//-----------------------------------------------------------------------------
ListNode* CReceiverList::GetQueuedPacket( ReceiverListNode* pNode )
{
    ListNode* pRes = NULL;
    CarrierNode* pCarrier = NULL;

    // get the packet list.
    if ( !IsListEmpty( &(pNode->m_ReceivedPackets) ) )
    {
        pCarrier = (CarrierNode*)(pNode->m_ReceivedPackets.m_pNext);
        RemoveEntryList( (ListNode*)pCarrier );
        pRes = (ListNode*)(pCarrier->m_pItem);
                    
        ZeroMemory( pCarrier, sizeof( CarrierNode ) );
        m_pCarrierNodeBag->PutInBag((ListNode*)pCarrier);
    }

    return pRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wiretap\stdafx.cpp ===
#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wiretap\ProdCons.h ===
//-----------------------------------------------------------------------------
//  Microsoft (R) XWireTap (tm). 
//  Copyright (C) 2002. All rights reserved.
//
//  FILE: ProdCons.h
//
//  Producer/Consumer queue implementation.
//-----------------------------------------------------------------------------

#pragma once

#ifndef __PRODCONS_H__
#define __PRODCONS_H__

//-----------------------------------------------------------------------------
// Includes
//-----------------------------------------------------------------------------
#include "ListMacros.h"

//-----------------------------------------------------------------------------
// Pre-Declarations
//-----------------------------------------------------------------------------
class CNodeBag;

//-----------------------------------------------------------------------------
// Types and Structures
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  CProdConsBuffer definition
//-----------------------------------------------------------------------------
class CProdConsBuffer
{
public:
    CProdConsBuffer( );
    virtual ~CProdConsBuffer(void);

    HRESULT     Initialize( DWORD dwQueueSize );
    HRESULT     Initialize( DWORD dwQueueSize, DWORD dwWaitTime );

    // tools for consumer
    HRESULT     Get( LPVOID *pItem, DWORD *pdwIdentifier );

    // tools for producer
    HRESULT     Put( LPVOID pItem, DWORD dwIdentifier );

protected:

    // head of the queue
    ListNode                m_QueueHead;

    // Nodes for the queue.
    CNodeBag*               m_pNodeBag;

    CRITICAL_SECTION        m_csQueueLock;
    HANDLE                  m_hWakeUpEvent;
    DWORD                   m_dwWaitTime;
    
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wiretap\sched.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    pqueue.h

Abstract:


--*/

#ifndef _XCS_SCHEDULER_H_
#define _XCS_SCHEDULER_H_

#include "dheap.h"
#include "addref.h"

//
// Forward declarations and types
//

class CScheduler;
class CSchedulerAppointment;
class CSchedulerCallback;

typedef CSchedulerAppointment* HAPPOINTMENT;


/******************************************************************************
  
  class CScheduler

******************************************************************************/

class CSchedulerCallback : public CAddRefable
{
public:

    virtual HRESULT OnAppointment(
        ULONGLONG qwCallbackArgument, 
        HAPPOINTMENT hAppointment
        ) = 0;
};

/******************************************************************************
  
  class CScheduler

******************************************************************************/

class CSchedulerAppointment
{
public:


    CSchedulerAppointment()
    {
        m_dwPQueueIndex = ~0;
        m_qwTimeScheduled = 0;
        m_pCallback = NULL;
        m_qwCallbackArgument = 0;
        m_lRefCount = 1;
    }

    ~CSchedulerAppointment()
    {
        SAFE_RELEASE(m_pCallback);
    }

    void Init(
        ULONGLONG qwTimeScheduled,
        CSchedulerCallback* pCallback,
        ULONGLONG qwCallbackArgument
    )
    {
        m_qwTimeScheduled = qwTimeScheduled;
        m_pCallback = pCallback;
        m_pCallback->AddRef();
        m_qwCallbackArgument = qwCallbackArgument;
    }
    
    virtual ULONG AddRef() 
    { 
        return (ULONG) InterlockedIncrement(&m_lRefCount);
    }

    virtual ULONG Release() 
    {
        LONG lCount = InterlockedDecrement(&m_lRefCount);
        
        if(lCount == 0)
        {
            delete this;
        }

        return (ULONG) lCount;
    }

    ULONGLONG GetTimeScheduled()
    {
        return m_qwTimeScheduled;
    }

    DWORD GetPQueueIndex()
    {
        return m_dwPQueueIndex;
    }

    void SetPQueueIndex(
        DWORD dwPQueueIndex
    )
    {
        m_dwPQueueIndex = dwPQueueIndex;
    }

    CSchedulerCallback* GetCallback()
    {
        return m_pCallback;
    }

    ULONGLONG GetCallbackArgument()
    {
        return m_qwCallbackArgument;
    }

private:

    DWORD m_dwPQueueIndex;
    ULONGLONG m_qwTimeScheduled;
    CSchedulerCallback* m_pCallback;
    ULONGLONG m_qwCallbackArgument;
    LONG m_lRefCount;
};


/******************************************************************************
  
  class CScheduler

******************************************************************************/

class CScheduler
{
public:

    CScheduler();

    ~CScheduler();
    
    HRESULT Initialize(
        CCompletionPort* pCompletionPort );
    
    HRESULT CreateAppointment(
        ULONGLONG qwTimeScheduled,
        CSchedulerCallback* pCallback,
        ULONGLONG qwCallbackArgument,
        HAPPOINTMENT* phAppointment );

    HRESULT CloseAppointment(
        HAPPOINTMENT hAppointment );

    void Shutdown();
    
    DWORD GetCount();

    ULONGLONG GetCurrentTime();
    
    void Lock()
    {
        EnterCriticalSection(&m_cs);
    }

    void Unlock()
    {
        LeaveCriticalSection(&m_cs);
    }

protected:

    static DWORD WINAPI ThreadProc(LPVOID pThisRaw);

    void DoWork();
    
    class NotifyOnNewPosition
    {
    public:
        operator()(
            CSchedulerAppointment* p, 
            int iNewIndex
        )
        {
            p->SetPQueueIndex(iNewIndex);            
            return iNewIndex;
        }
    };

    class Compare
    {
    public:
        LONGLONG operator()(
            CSchedulerAppointment* a,
            CSchedulerAppointment* b
        )
        {
            return (LONGLONG) b->GetTimeScheduled() - (LONGLONG) a->GetTimeScheduled();
        }
    };
            
    
    typedef CDHeap<CSchedulerAppointment*, Compare, 1024, 1024, 4, NotifyOnNewPosition> DHEAP;

    DHEAP m_dheap;

    CRITICAL_SECTION m_cs;

    HANDLE m_hEventShutdown;

    HANDLE m_hEventQueueChanged;

    HANDLE m_hThread;
    
    DWORD m_dwThreadId;

    CCompletionPort* m_pCompletionPort;

    LARGE_INTEGER m_liPerfFreq;

    LONG m_fShutdown;
};


#endif // #ifndef _XCS_PQUEUE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wiretap\ReceiverList.h ===
//-----------------------------------------------------------------------------
//  Microsoft (R) XWireTap (tm). 
//  Copyright (C) 2002. All rights reserved.
//
//  FILE: ReceiverList.h
//
//  Interface for the receiver list implementation.
//-----------------------------------------------------------------------------

#pragma once

//-----------------------------------------------------------------------------
// Includes
//-----------------------------------------------------------------------------
#include "sched.h"
#include "nodebag.h"
#include "Tap.h"
#include "hashtable.h"

//-----------------------------------------------------------------------------
// Definitions
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Class pre-declarations
//-----------------------------------------------------------------------------
class CWireTap;

//-----------------------------------------------------------------------------
// Types
//-----------------------------------------------------------------------------

typedef enum _AuthDataState
{
    ADS_NONE = 0,
    ADS_PENDING = 1,
    ADS_DONE    = 2           
} AuthDataState;

typedef struct _ReceiverListNode
{

    // hash table pointers NOTE:  These values align with HashListNode for a reason
    //   DON'T Add something before these 2 values.  Do no re-arrange them.
    ListNode            m_Link;
    BYTE                m_Key[HASH_KEY_SIZE];

    // last time this node received a packet.
    ULONGLONG           m_qwLastAccessTime;

    HAPPOINTMENT        m_hAuthDataRetryApt;
    HAPPOINTMENT        m_hSessionTimeoutApt;
    
    // used for the master list.
    ListNode            m_MasterLink;

    AuthDataState       m_AuthDataState;
    
    // a copy of related AUTHINFO for this node.
    SGAuthData          m_AuthData;

    ListNode            m_TapList;
    
    ListNode            m_ReceivedPackets;
} ReceiverListNode;


typedef struct _CarrierNode
{
    ListNode m_Link;
    LPVOID   m_pItem;
}  CarrierNode;


//-----------------------------------------------------------------------------
// CReceiverList
//-----------------------------------------------------------------------------

#pragma once

class CReceiverList :
    public CHashTable
{
public:
    CReceiverList(void);
    virtual ~CReceiverList(void);

    HRESULT Initialize( DWORD dwNumOfReceiverNodes, DWORD dwNumOfCarrierNodes );
    HRESULT Terminate();

    // use these to add and delete from the receiver list.
    HRESULT Add( BYTE* pKey );
    HRESULT Remove( BYTE* pKey );

    // associates auth data and adds appropriate tasks.
    HRESULT AssociateAuthData( BYTE* pKey, BYTE* pNode );

    HRESULT RemoveTap( ULONGLONG qwTapId );
    HRESULT AddTap( CTap *pTap );

    HRESULT AddPacket( ReceiverListNode* pNode, ListNode *pPacketNode );
    ListNode* GetQueuedPacket( ReceiverListNode* pNode );

    ListNode* GetCarrierNode();

protected:

    // node bag
    CNodeBag *m_pReceiverNodeBag;
    CNodeBag *m_pCarrierNodeBag;                // carries node for the tap list for each receiver.

    ListNode *m_pMasterList;                    // list of all active hash nodes.

    CWireTap *m_pWireTap;


};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wiretap\sched.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    pqueue.cpp

Abstract:


--*/

#include "stdafx.h"

XomDefineArea(Debug);



CScheduler::CScheduler()
/*++

Routine Description:

    Constructor

Arguments:

    None

Return Value:

    None

--*/ 
{
    InitializeCriticalSection(&m_cs);

    m_hEventShutdown = NULL;
    m_hEventQueueChanged = NULL;
    m_hThread = NULL;
    m_dwThreadId = 0;
    m_pCompletionPort = NULL;
    m_liPerfFreq.QuadPart = 0;
    m_fShutdown = FALSE;
}

CScheduler::~CScheduler()
/*++

Routine Description:
    

Arguments:

    None

Return Value:

    None

--*/ 
{
    Shutdown();
    
    if(m_hThread)
    {
        CloseHandle(m_hThread);
        m_hThread = NULL;
    }
    
    if(m_pCompletionPort)
    {
        m_pCompletionPort->Release();
        m_pCompletionPort = NULL;
    }

    if(m_hEventShutdown)
    {
        CloseHandle(m_hEventShutdown);
        m_hEventShutdown = NULL;
    }

    if(m_hEventQueueChanged)
    {
        CloseHandle(m_hEventQueueChanged);
        m_hEventQueueChanged = NULL;
    }

    DeleteCriticalSection(&m_cs);
}

HRESULT CScheduler::Initialize(
    CCompletionPort* pCompletionPort
)
/*++

Routine Description:
    

Arguments:

    None

Return Value:

    None

--*/ 
{
    HRESULT hr = S_OK;
    
    m_pCompletionPort = pCompletionPort;
    m_pCompletionPort->AddRef();

    if(!QueryPerformanceFrequency(&m_liPerfFreq))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        XomTrace1(Debug, L_ERROR, 
            "[CScheduler::Initialize] QueryPerformanceFrequency(&m_liPerfFreq) failed, hr = 0x%08x", hr);
        goto lDone;
    }

    m_hEventShutdown = CreateEvent(NULL, TRUE, FALSE, NULL);

    if(NULL == m_hEventShutdown)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        XomTrace1(Debug, L_ERROR, 
            "[CScheduler::Initialize] m_hEventShutdown = CreateEvent failed, hr = 0x%08x", hr);
        goto lDone;
    }

    m_hEventQueueChanged = CreateEvent(NULL, FALSE, FALSE, NULL);

    if(NULL == m_hEventQueueChanged)
    {
        hr = GetLastError();
        XomTrace1(Debug, L_ERROR, 
            "[CScheduler::Initialize] m_hEventQueueChanged = CreateEvent failed, hr = 0x%08x", hr);
        goto lDone;
    }

    m_hThread = CreateThread(NULL, 0, ThreadProc, this, 0, &m_dwThreadId);

lDone:
    
    return S_OK;
}

void CScheduler::Shutdown()
/*++

Routine Description:
    

Arguments:

    None

Return Value:

    None

--*/ 
{
    InterlockedExchange(&m_fShutdown, (LONG) TRUE);

    //
    // Shutdown worker thread
    //
    
    if(m_hThread != NULL)
    {
        if(m_hEventShutdown)
        {
            SetEvent(m_hEventShutdown);
        }
        
        int iRes = WaitForSingleObject(m_hThread, 5000);

        if(iRes != WAIT_OBJECT_0)
        {
            XomTrace0(Debug, L_ERROR, 
                "[CScheduler::~CScheduler] Waiting for thread to shutdown failed.");
        }
    }

    //
    // Clean up queue
    //

    Lock();

    DWORD dwCount = m_dheap.GetCount();
    
    for(DWORD nItem=0; nItem < dwCount; nItem++)
    {
        CSchedulerAppointment* pAppt = m_dheap.Remove(0);
        pAppt->Release();
    }
    
    Unlock();
}

ULONGLONG CScheduler::GetCurrentTime()
/*++

Routine Description:
    

Arguments:

    None

Return Value:

    None

--*/ 
{
    LARGE_INTEGER liNow;

    QueryPerformanceCounter(&liNow);

    return (liNow.QuadPart / ( m_liPerfFreq.QuadPart / 1000)) ;
}

DWORD WINAPI CScheduler::ThreadProc(LPVOID pThisRaw)
/*++

Routine Description:
    

Arguments:

    None

Return Value:

    None

--*/ 
{
    ((CScheduler*)pThisRaw)->DoWork();

    return 0;
}

void CScheduler::DoWork()
/*++

Routine Description:
    

Arguments:

    None

Return Value:

    None

--*/ 
{
    CSchedulerAppointment* pObject = NULL;
    
    HANDLE rgWaitFor[] = {
        m_hEventShutdown,
        m_hEventQueueChanged
    };
    
    do
    {
        ResetEvent(m_hEventQueueChanged);
        
        DWORD dwSleep;
        
        ULONGLONG qwNow = GetCurrentTime();

        Lock();

        if(GetCount() > 0)
        {
            //
            // Peek at the next object in line
            //

            pObject = m_dheap.Peek(0);

            if(NULL == pObject)
            {
                XomTrace0(Debug, L_ERROR, 
                    "[CScheduler::DoWork] m_dheap.peek failed even though there are items in the queue");
                Unlock();
                break;
            }

            //
            // Calculate for how long we can sleep til we need to execute this object.
            //

            if(pObject->GetTimeScheduled() > qwNow)
            {
                dwSleep = (DWORD) (pObject->GetTimeScheduled() - qwNow);
            }
            else
            {
                //
                // We're already late. Don't sleep.
                //
                
                dwSleep = 0;
            }

            pObject = NULL;
        }
        else
        {
            //
            // No objects, just sleep...
            //
            
            dwSleep = INFINITE;
        }

        Unlock();

        //
        // Time to sleep
        //

        DWORD dwRes;
        dwRes = WaitForMultipleObjects(
            ARRAY_ELEMENTS(rgWaitFor),
            rgWaitFor,
            FALSE,
            dwSleep);

        if(WAIT_OBJECT_0 == dwRes)
        {
            // Shutdown 

            break;
        }
        else if(WAIT_OBJECT_0 + 1 == dwRes)
        {
            // Priority queue changed. We gotta re-evaluate for how long we are going
            // to sleep. The priority queue will only notify us if we have a different
            // object at the top of the queue.
        
            continue;
        }
        
        Lock();

        if(GetCount() == 0)
        {
            //
            // While we were sleeping, the queue got empty. Scan it again.
            //
            
            Unlock();
            continue;
        }
            
        pObject = m_dheap.Remove(0);

        if(!pObject)
        {
            XomTrace0(Debug, L_ERROR, 
                "[CScheduler::DoWork] m_dheap.Remove failed, even though there are items in the queue");
        
            Unlock();
            break;
        }

        //
        // Mark this object as out of the queue
        //
        
        pObject->SetPQueueIndex(~0);

        Unlock();

        // TODO: Use completion port

        pObject->GetCallback()->OnAppointment(
            pObject->GetCallbackArgument(),
            (HAPPOINTMENT) pObject);
        
        pObject->Release();

        pObject = NULL;
    
    } while (TRUE);
}


HRESULT CScheduler::CreateAppointment(
    ULONGLONG qwTimeScheduled,
    CSchedulerCallback* pCallback,
    ULONGLONG qwCallbackArgument,
    HAPPOINTMENT* phAppointment 
)
/*++

Routine Description:
    

Arguments:

    None

Return Value:

    None

--*/ 
{
    HRESULT hr = S_OK;

	CSchedulerAppointment* pNewAppointment = NULL;

    if(m_fShutdown)
    {
        hr = E_FAIL;
        goto lDone;
    }
    
    //
    // Create new appointment object and fill it out.
    //
    
    pNewAppointment = new CSchedulerAppointment;

    if(NULL == pNewAppointment)
    {
        hr = E_OUTOFMEMORY;
        XomTrace0(Debug, L_ERROR, 
            "[CScheduler::CreateAppointment] pNewAppointment = new CSchedulerAppointment failed, out of memory?");
        goto lDone;
    }

    pNewAppointment->Init(qwTimeScheduled, pCallback, qwCallbackArgument);

    //
    // Add object to the heap
    //
    
    Lock();
    
    hr = m_dheap.Insert(pNewAppointment);

    if(SUCCEEDED(hr))
    {
        pNewAppointment->AddRef();
        
        //
        // Check if we need to notify somebody
        //

        if( pNewAppointment->GetPQueueIndex() == 0 )
        {
            SetEvent(m_hEventQueueChanged);
        }

        //
        // Return appointment handle to the caller
        //
        
        *phAppointment = (HAPPOINTMENT) pNewAppointment;
        pNewAppointment = NULL;
    }

    Unlock();

lDone:

    SAFE_RELEASE(pNewAppointment);
    
    return hr;
}

HRESULT CScheduler::CloseAppointment(
    HAPPOINTMENT hAppointment 
)
/*++

Routine Description:
    

Arguments:

    None

Return Value:

    None

--*/ 
{
    HRESULT hr = S_OK;

    CSchedulerAppointment* pAppt = (CSchedulerAppointment*) hAppointment;
    
    Lock();
    
    DWORD dwIndex = pAppt->GetPQueueIndex();
    
    if(dwIndex != ~0)
    {
        CSchedulerAppointment* pDrop = m_dheap.Remove(dwIndex);

        XOMASSERT(pDrop == pAppt);

        pDrop->Release();
    }

    Unlock();

    pAppt->Release();
    pAppt = NULL;

    return S_OK;
}

DWORD CScheduler::GetCount()
/*++

Routine Description:
    

Arguments:

    None

Return Value:

    None

--*/ 
{
    Lock();

    DWORD dwRet = m_dheap.GetCount();
    
    Unlock();
    
    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wiretap\stdafx.h ===
#pragma once

#ifdef UNICODE
#undef UNICODE
#endif

#ifdef _UNICODE
#undef _UNICODE
#endif

#ifndef ARRAY_ELEMENTS
#define ARRAY_ELEMENTS(x) (sizeof(x)/sizeof(x[0]))
#endif

#ifndef ASSERT
#define ASSERT XOMASSERT
#endif

// public\ext\ntpublic\sdk\inc
#include <windows.h>
#define INCL_WINSOCK_API_TYPEDEFS 1
#include <winsock2.h>
#include <netmon.h>

// public\ext\ntpublic\sdk\inc\crt
#include <time.h>
#include <stdio.h>

// private\common\inc
#include <wsockntp.h>
#include <xonlinep.h>
#include <cryptohelper.h>
#include <xeventids.h>
#include <xalloc.h>
#include <addref.h>
#include <atlbase.h>

// private\common\servhlp\ntsvc
#include <compport.h>
#include <servsock.h>

// private\common\servhlp\dstruct
#include <xlocks.h>

// private\common\xmgmtlib\inc
#include <xmgmt.h>

// private\common\xmgmtlib
#include <xomcmmon.h>
#include <xomadmin.h>

// private\server\sg\util\vlan\inc
#include <vlan.h>

#import "CommonConfig.tlb" raw_interfaces_only, no_smart_pointers
using namespace XblConfig;
using namespace xlocks;

// private\tools\wiretap
#include "dyncapturefile.h"
#include "exprblder.h"
#include "hashtable.h"
#include "listmacros.h"
#include "mgmtinterface.h"
#include "netstructs.h"
#include "nodebag.h"
#include "prodcons.h"
#include "receiverlist.h"
#include "sched.h"
#include "tap.h"
#include "wiretap.h"
#include "wtaction.h"
#include "wtappointments.h"
#include "wtnicmgr.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wiretap\Tap.h ===
//-----------------------------------------------------------------------------
//  Microsoft (R) XWireTap (tm). 
//  Copyright (C) 2002. All rights reserved.
//
//  FILE: Tap.h
//
//  Interface for the Tap implementation.
//-----------------------------------------------------------------------------

#pragma once

//-----------------------------------------------------------------------------
// Includes
//-----------------------------------------------------------------------------
#include <xonlinep.h>
#include "ListMacros.h"

//-----------------------------------------------------------------------------
// Definitions
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Types
//-----------------------------------------------------------------------------
class CProdConsBuffer;
class CWireTap;
class CDynCaptureFile;

typedef enum
{
    NONE       = 0,
    MACHINE_ID = 1,
    USER_ID    = 2,
    SRC_IP     = 3
} TAP_TYPE;

struct SGAuthData : public XKERB_AD_XENON
{
    WORD            _ipportI;                   // IP port of the client on the Internet
    IN_ADDR         _ipaI;                      // IP address of the client on the Internet
};

typedef struct _TapId
{
    WORD m_wId;
    WORD m_wHour;
    WORD m_wDay;
    WORD m_wMonth;
} TapId;


//-----------------------------------------------------------------------------
// CTap
//-----------------------------------------------------------------------------

#pragma once

class CTap: 
    public ListNode
{
public:
    CTap();
    virtual ~CTap(void);

    HRESULT Initialize( ULONGLONG qwID, DWORD dwQueueSize, DWORD dwMaxFileSize, TAP_TYPE nTapType, BYTE *pTapIdentifier, DWORD dwTapLife );
    HRESULT Close();

    HRESULT PostRollover();
    HRESULT PostPacket( LPVOID pItem );
    HRESULT PostInfo( LPVOID pItem );
    
    BOOL    IsAssociated( SGAuthData *pAuthData );

    ULONGLONG GetTapID() { return *((ULONGLONG*)&m_TapId); }
    TAP_TYPE  GetTapType() { return m_nTapType; }    
    HRESULT   GetTapAuthData( SGAuthData *pAuth );

    void *operator new(size_t len) { return XAlloc(len); }
    void operator delete(void *pv) { XFree(pv); }

protected:

    // tap properties.
    SGAuthData          m_AuthData;       
    TAP_TYPE            m_nTapType;
    TapId               m_TapId;
    DWORD               m_dwTapLife;

    // tap thread attributes
    HANDLE              m_hTapThreadHandle;
    BOOL                m_bIsComplete;
    DWORD               m_dwTAPThreadId;           // id of the PUID thread

    DWORD               m_dwMaxFileSize;

    // producer consumer object.
    CProdConsBuffer*    m_pServiceQueue;

    // file properties
    CDynCaptureFile*    m_pCapFile;

    CWireTap*           m_pWireTap;               // pointer to parent.
    
    // PUID thread methods
    static DWORD WINAPI TAPThread( LPVOID pThis );
    HRESULT             InitializeTAPThread();
    void                TAPThreadInternal();
    void                TerminateTAPThread();

private:
    HRESULT SetupAuthData( TAP_TYPE nTapType, BYTE *pTapId );
    void ConstructFileNameFromTime( char *szNewFileName, DWORD dwFileNameSize, char* szPath, DWORD dwPathSize, char *szDirectory, char *szExt );
    HRESULT OutputTapAuthData( BYTE* pNode );


};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wiretap\WireTap.h ===
//-----------------------------------------------------------------------------
//  Microsoft (R) XWireTap (tm). 
//  Copyright (C) 2002. All rights reserved.
//
//  FILE: Wiretap.h
//
//  Interface for wiretap object (singleton)
//-----------------------------------------------------------------------------

#pragma once

//-----------------------------------------------------------------------------
//  Include
//-----------------------------------------------------------------------------
#include <netmon.h>
#include "netstructs.h"
#include <ntservice.h>
#include "ListMacros.h"
#include "Tap.h"

#include <XAlloc.h>

//-----------------------------------------------------------------------------
//  Pre-Declared Classes
//-----------------------------------------------------------------------------
class CNodeBag;
class CScheduler;
class CServerSocket;
class CCompletionPort;
class CMgmtInterface;
class CReceiverList;
class CWTAction;
class CAuthSocketCallback;
class CWTNicMgr;

#define MAX_SGS 100

//-----------------------------------------------------------------------------
//  Global definitions
//-----------------------------------------------------------------------------

// used to manipulate packet nodes for carrying auth data.
#define PACKETNODE_DATA_ADDR( pPN ) (BYTE*)( &(pPN->m_Frame.MacFrame[0]) )
#define PACKETNODE_FROMBUFFER( pBuf ) ( CONTAINING_RECORD( pBuf, PacketNode, m_Frame.MacFrame[0]))

//-----------------------------------------------------------------------------
//  types/structures
//-----------------------------------------------------------------------------

typedef struct _PacketNode
{
    ListNode m_Link;
    DWORD    m_dwRefCount;
    DWORD    m_dwNicId;
    FRAME    m_Frame;
} PacketNode;

//-----------------------------------------------------------------------------
//  Global functions
//-----------------------------------------------------------------------------
extern unsigned int        StringToIp( char *szValue );
extern void                BinToHex( char *szString, DWORD dwStringSize, char **szHexString );
extern void                HexToBin( char *szHexString, DWORD dwStringSize, BYTE **ppBinData );
extern unsigned __int64    QwordFromHexStr(char *sz);
extern HRESULT ConstructPath( char *szPath, DWORD cPath );

//-----------------------------------------------------------------------------
//  CWireTap Interface
//-----------------------------------------------------------------------------
class CWireTap : public CNTService
{
public:
    static CWireTap*    GetInstance();
    static void         ReleaseInstance();

    // main program 
    HRESULT             Start();
    HRESULT             Run();
    HRESULT             Term();

    // overrides:  Initializes the service.
    virtual HRESULT     InitService( DWORD dwArgc, LPWSTR *pszArgv );

    // overrides:  run the service.
    virtual HRESULT     RunService( BOOL *pfServiceRan );

    // load the config.
    HRESULT             LoadConfig();
    HRESULT             LoadNicConfig();

    // VLan methods
    HRESULT             QueuePacket( BYTE *pPacket, UINT cPacket, DWORD dwNicId);

    // used to keep track of packet nodes.
    void                AddRefPacketNode ( PacketNode *pNode );
    void                ReleasePacketNode( PacketNode *pNode );
    PacketNode*         GetPacketNode();

    // access attributes
    char*               GetDumpDirectory() { return m_szDumpDir; }

    // manage the auth data
    HRESULT             RequestAuthData( PacketNode *pNode, BYTE* pKey );
    HRESULT             ProcessAuthData( BYTE *pIPPortKey, PacketNode *pPacketNode );
    HRESULT             ProcessAuthDataReply( BYTE* pReply );


    // access to TAP features
    CTap*               GetTap( ULONGLONG qwTapId );
    ListNode*           GetTapList() { return m_pTapList; }
    void                InsertTapList( CTap* pTap );
    void                RemoveTapList( CTap* pTap );
    HRESULT             CloseTap( ULONGLONG qwTapId );
    HRESULT             CreateTap( CTap* pTap );
    HRESULT             RollTapCapFile( ULONGLONG qwTapId );
    BOOL                IncNumTaps();
    void                DecNumTaps();    
    void                ReadLockTapList();
    void                WriteLockTapList();
    void                ReadUnlockTapList();
    void                WriteUnlockTapList();
    
    // generates a new tap id based on time and the counter
    ULONGLONG           GenerateNewTapId();

    // figure out what to do with the packet
    HRESULT             ProcessPacket( PacketNode *pNode );

    // check if the IP is unwanted.
    HRESULT             IsNotUnWanted( DWORD dwIP );

    // just in case someone needs to post to our completion port.
    CCompletionPort*    GetMasterCompletionPort() { return m_pCompletionPort; }

    // Action node methods
    CWTAction*          GetAction();
    void                ReleaseAction( CWTAction *pAction );

    // talk to all the SGs with requests
    HRESULT             SubmitRequestToSGs( BYTE* pbytRequest, DWORD dwReqSize );


    // tells the wire tap its time to shutdown.
    void                Shutdown() { SetEvent( ShutdownEvent() ); }
    void                CleanLists();
    BOOL                IsComplete() { return m_bIsComplete; }

    DWORD               GetMaxAuthDataRetries() { return m_dwMaxSGRetries; }

    DWORD               GetMaxReTrys() { return m_dwMaxRetrys; }
    ULONGLONG           GetReceiverNodeLifetime() { return m_qwReceiverNodeLifetimeInterval; }

    CScheduler*         GetSchedulerInstance(); 
    void                ReleaseSchedulerInstance();

    // signals that a node in teh receiver list should be cleaned up.
    HRESULT             CleanReceiverNode( BYTE *pKey );        
    
    // overrides
    void *operator      new(size_t len) { return XAlloc(len); }
    void operator       delete(void *pv) { XFree(pv); }
   
protected:
    CWireTap(void);
    virtual ~CWireTap(void);

    HRESULT             ProcessQueuedPackets( BYTE *pReceiverListNodeKey );
    HRESULT             SendAuthDataRequest( PacketNode *pNode, BYTE* pKey  );
    HRESULT             VerifySGAuthResponse( BYTE* pPacket );

    // initialize wiretap mgmt callbacks
    void                InitializeCallbacks();

    HRESULT             InitializeActionNodes();
    HRESULT             CleanActionNodes();

    BOOL                ConstructUnWantedList( char *szUnWantedList );

    HRESULT             AddSGServer(BSTR bstrServerName);
    HRESULT             LoadSGSVCINTServers();
    DWORD               GetDWORDSetting( Setting enumSetting, DWORD dwDefault );
    void                GetStringSetting( LPSTR pch, DWORD cch, Setting enumSetting, const char *c_szDefault );
    
    // attributes
    CNodeBag*           m_pPacketBuffer;
    DWORD               m_dwPacketBufferSize;

    CNodeBag*           m_pActionBag;

    // config properties
    DWORD               m_dwLocalIP;
    DWORD               m_dwUDPLocalIP;
    char*               m_szVlanMacAddr;
    CEnetAddr           m_eaLocal;
    char                m_szDumpDir[256];
    DWORD               m_dwNumOfReceiverNodes;
    DWORD               m_dwNumOfCarrierNodes;
    CComBSTR            m_pszSGList[MAX_SGS];
    DWORD               m_dwSGListSize;
    DWORD               m_dwMaxRetrys;
    DWORD               m_dwUnWantedListSize;
    DWORD*              m_pdwUnWantedList;
    ULONGLONG           m_qwReceiverNodeLifetimeInterval;
    DWORD               m_dwSGReplyWaitTimeInSecs;
    DWORD               m_dwMaxSGRetries;
    DWORD               m_dwNumOfNics;
    
    CRITICAL_SECTION    m_csNumOfTaps;
    DWORD               m_dwMaxNumOfTaps;
    DWORD               m_dwNumOfTaps;

    // scheduler for tasks
    CScheduler*         m_pScheduler;
    DWORD               m_dwSchedulerRefCnt;

    // interface for mgmt stuff
    CMgmtInterface*     m_pMgmtInterface;

    // the receiver list.
    CReceiverList*      m_pReceiverList;

    // indicates that the WireTap service is complete or not.
    BOOL                m_bIsComplete;

    HANDLE              m_hShutdown;                    // wiretap shutdown handle... fired when shutdown is complete.

    // tap list properties
    ListNode*           m_pTapList;
    WORD                m_wTapCounter;                  // number of generated taps, rolls over when more than 65535
    CReaderWriterLock3  m_TapListLock;

    DWORD               m_dwUDPAuthReplyPort;           // the port to listen for authdata replies.
    DWORD               m_dwRequestCounter;             // counts the number of requests sent

    CCompletionPort*    m_pCompletionPort;              // the main completion port.

    CAuthSocketCallback* m_pSockCallback;               // socket call back object.

    CWTNicMgr*          m_pNicMgr;                      // object to manage Vlan Nics

    // config db interface
    CComPtr<IConfig>    m_pConfig;

private:
    static CWireTap*    m_pInstance;
    static DWORD        m_dwRefCount;
        
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wiretap\WTAction.h ===
//-----------------------------------------------------------------------------
//  Microsoft (R) XWireTap (tm). 
//  Copyright (C) 2002. All rights reserved.
//
//  FILE: WTAction.h
//
//  Interface WTAction Implementation.
//-----------------------------------------------------------------------------

#pragma once

//-----------------------------------------------------------------------------
// Includes
//-----------------------------------------------------------------------------
#include <Compport.h>
#include "ListMacros.h"

//-----------------------------------------------------------------------------
// Class Pre-Declaration
//-----------------------------------------------------------------------------
class CWireTap;

    
//-----------------------------------------------------------------------------
// CWTAction:  Nodes managed by the completion port to handle wiretap
//      business.
//-----------------------------------------------------------------------------
class CWTAction     : public ListNode,
                      public CCompletionContext, 
                      public CCompletionHandler
                   
{
public:
    enum ActionType
    {
        NONE = 0,
        PACKET = 1,
        CLOSE_TAP = 2,
        CREATE_TAP = 3,
        TERMINATE = 4,
        RETRY = 5,
        AUTHDATA = 6,
        ROLL_TAP = 7
    };
    
    CWTAction( CWireTap *pWT ) : 
        m_pWireTap(pWT)
    {
        m_pNext = (NULL);
        m_pPrev = (NULL);
    }

    virtual void Clean()
    {
        m_nAction = NONE;
        m_pData   = NULL;
    }

    virtual ULONG AddRef() { return 0; }

    virtual ULONG Release() { return 0; }

    
    virtual void Setup( ActionType act, LPBYTE pData )
        {
            m_nAction = act;
            m_pData   = pData;
        }
    
    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void OnIoCompletion( 
        DWORD dwError, 
        DWORD cbTransferred, 
        ULONG_PTR ulpKey,
        CCompletionContext *pCtx );
      
protected:
    CWireTap*   m_pWireTap;
    LPBYTE      m_pData;
    ActionType  m_nAction;

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wiretap\WTAction.cpp ===
//-----------------------------------------------------------------------------
//  Microsoft (R) XWireTap (tm). 
//  Copyright (C) 2002. All rights reserved.
//
//  FILE: WTAction.cpp
//
//  Implementation of the node bag.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  Include
//-----------------------------------------------------------------------------
#include "stdafx.h"

//-----------------------------------------------------------------------------
//  DEBUG Areas
//-----------------------------------------------------------------------------
XomImportArea(XWireTap);

//-----------------------------------------------------------------------------
//  CWTAction Implementation
//-----------------------------------------------------------------------------
void CWTAction::OnIoCompletion( 
                    DWORD dwError, 
                    DWORD cbTransferred, 
                    ULONG_PTR ulpKey,
                    CCompletionContext *pCtx )
{
    CWTAction *pAction = NULL;
    HRESULT hr = S_OK;
    
    // get the action handler.
    pAction  = ( CWTAction* )pCtx;

    // we're done but someone is still sending us messages... ignore them.
    if ( m_pWireTap->IsComplete() )
    {
        goto Exit;
    }

    // TODO:  (lohab)  Add more logging here.
    
    switch (pAction->m_nAction)
    {
        case CLOSE_TAP:
            {
                PacketNode *pPacketNode = NULL;
                ULONGLONG qwId = 0;

                pPacketNode = (PacketNode*)pAction->m_pData;                
                qwId = *((ULONGLONG*) PACKETNODE_DATA_ADDR( pPacketNode ));
                m_pWireTap->CloseTap( qwId );

                m_pWireTap->ReleasePacketNode( pPacketNode );
                
            }
        break;
        case CREATE_TAP:
            {
                hr = m_pWireTap->CreateTap( (CTap*)pAction->m_pData );
            }
            break;
        case TERMINATE:
            {
                m_pWireTap->Term();
            }
            break;
        case PACKET:
            {
                m_pWireTap->ProcessPacket( (PacketNode*)pAction->m_pData );
            }
            break;
        case ROLL_TAP:
            {
                PacketNode *pPacketNode = NULL;
                ULONGLONG qwId = 0;

                pPacketNode = (PacketNode*)pAction->m_pData;                
                qwId = *((ULONGLONG*) PACKETNODE_DATA_ADDR( pPacketNode ));
                m_pWireTap->RollTapCapFile( qwId );

                m_pWireTap->ReleasePacketNode( pPacketNode );
            }
            break;
        case RETRY:
            {
                // TODO:  (lohab)Implement this!!!  Need to use the scheduler.
            }
            break;
        case AUTHDATA:
            {
                PacketNode *pPacketNode = (PacketNode*)pAction->m_pData;
                hr = m_pWireTap->ProcessAuthDataReply( pAction->m_pData );
                if ( FAILED(hr) )
                {
                    break;
                }              

                // ok we cheated the buffer is actually a packetnode so now we have to clean it up.
                m_pWireTap->ReleasePacketNode( pPacketNode );
                
            }
            break;
        case NONE:
            {
                // ok... what the?
                XomTrace0( XWireTap, L_WARNING, "CWTAction::OnIoCompletion:  We've received a action to do NOTHING.  Please correct this.");
            }
            break;
        default:
            {
                // why are we here... this isn't valid.
                XOMASSERT( FALSE );
            }
            break;
    };

    m_pWireTap->ReleaseAction( pAction );
    
Exit:
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wiretap\WTAppointments.cpp ===
//-----------------------------------------------------------------------------
//  Microsoft (R) XWireTap (tm). 
//  Copyright (C) 2002. All rights reserved.
//
//  FILE: WTAppointments.cpp
//
//  Implementation of the wrietap appointment classes.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  Include
//-----------------------------------------------------------------------------
#include "stdafx.h"

//-----------------------------------------------------------------------------
//  DEBUG Areas
//-----------------------------------------------------------------------------
XomImportArea(XWireTap);

//-----------------------------------------------------------------------------
//  CSGRetryCallback Implementation
//-----------------------------------------------------------------------------

CSGRetryCallback::CSGRetryCallback( PacketNode *pPacketNode, BYTE* pKey, DWORD cKey )
{
    XOMASSERT( cKey == HASH_KEY_SIZE );

    m_lRefCount = 0;
    m_pWireTap = CWireTap::GetInstance();
    m_pWireTap->AddRefPacketNode( pPacketNode );
    m_pPacket = pPacketNode;
    memcpy( m_Key, pKey, sizeof(m_Key) );
    m_dwNoOfRetries = 0;
}


CSGRetryCallback::~CSGRetryCallback()
{
    m_pWireTap->ReleasePacketNode( m_pPacket );
    m_pWireTap->ReleaseInstance();
    
    m_pPacket = NULL;
    m_pWireTap = NULL;
    ZeroMemory( m_Key, sizeof( m_Key ) );
}
    
HRESULT CSGRetryCallback::OnAppointment( ULONGLONG qwCallbackArgument, HAPPOINTMENT hAppointment )
{
    HRESULT hr = S_OK;

    // increase our number of attempts.
    m_dwNoOfRetries++;

    // ensure we're not over the retry max
    if ( m_dwNoOfRetries >= m_pWireTap->GetMaxAuthDataRetries() )
    {
        // clean the node
        hr = m_pWireTap->CleanReceiverNode( m_Key );
        if ( FAILED(hr) )
        {
            XomTrace2( XWireTap, L_WARNING, "CSGRetryCallback::OnAppointment: Failed to clean up node for 0x%X.  Memory Leak.  HRESULT = 0x%X", m_Key, hr );
            XomNtEvent( XEVENT_XWIRETAP_GENERIC_ERROR_13, "CSGRetryCallback::OnAppointment: Failed to clean up node for 0x%X.  Memory Leak.  HRESULT = 0x%X", m_Key, hr );
        }
        goto Exit;
    }

    // otherwise submit another SG auth call.
    hr = m_pWireTap->RequestAuthData( m_pPacket, (BYTE*)m_Key );
    if ( FAILED(hr) )
    {
        XomTrace2( XWireTap, L_WARNING, "CSGRetryCallback::OnAppointment: Failed to resend auth data request for 0x%X.  HRESULT = 0x%X", m_Key, hr );
        XomNtEvent( XEVENT_XWIRETAP_GENERIC_ERROR_14, "CSGRetryCallback::OnAppointment: Failed to resend auth data request for 0x%X.  HRESULT = 0x%X", m_Key, hr );
        goto Exit;
    }

    
Exit:
    return hr;
}


//-----------------------------------------------------------------------------
//  CActivityMonitor Implementation
//-----------------------------------------------------------------------------

CActivityMonitor::CActivityMonitor( ReceiverListNode *pReceiverNode , CReceiverList* pReceiverList )
{
    m_pReceiverList = pReceiverList;
    m_pReceiverNode = pReceiverNode;
    m_lRefCount = 0;    
}


CActivityMonitor::~CActivityMonitor()
{
    m_pReceiverList = NULL;
    m_pReceiverNode = NULL;
}

HRESULT CActivityMonitor::OnAppointment( ULONGLONG qwCallbackArgument, HAPPOINTMENT hAppointment )
{
    HRESULT hr = S_OK;
    CWireTap *pWireTap = CWireTap::GetInstance();
    CScheduler *pScheduler = NULL;

    // check the wiretap.
    if ( pWireTap == NULL )
    {
        // no instance... too bad
        goto Exit;
    }

    // get the scheduler.
    pScheduler = pWireTap->GetSchedulerInstance();
    if ( pScheduler == NULL )
    {
        goto Exit;
    }
    
    // check that this node is still valid
    if ( m_pReceiverNode == NULL )
    {
        // not important... just disappear without a trace.
        hr = S_OK;
        goto Exit;
    }

    // check the time on the node.
    if ( m_pReceiverNode->m_qwLastAccessTime + pWireTap->GetReceiverNodeLifetime() < ( pScheduler->GetCurrentTime()) )
    {
        // if expired.  remove this node
        hr = m_pReceiverList->Remove( m_pReceiverNode->m_Key );
        if ( FAILED(hr) )
        {
            XomTrace2( XWireTap, L_WARNING, "CActivityMonitor::OnAppointment: Failed to remove entry 0x%X from ReceiverList. Memory Leak.  HRESULT = 0x%X", m_pReceiverNode->m_Key, hr );            
            XomNtEvent( XEVENT_XWIRETAP_GENERIC_ERROR_15, "CActivityMonitor::OnAppointment: Failed to remove entry 0x%X from ReceiverList. Memory Leak.  HRESULT = 0x%X", m_pReceiverNode->m_Key, hr );            
            goto Exit;
        }
    }
    else
    {
        // else, go back to sleep.
        hr = pScheduler->CreateAppointment( m_pReceiverNode->m_qwLastAccessTime + pWireTap->GetReceiverNodeLifetime(), 
                                                            (CSchedulerCallback*)this, 
                                                            qwCallbackArgument, 
                                                            &hAppointment );
        if ( FAILED(hr) )
        {
            // TODO:  maybe I should remove the node here and let it run its course again....
            
            XomTrace2( XWireTap, L_WARNING, "CActivityMonitor::OnAppointment: Failed to re-schedule checkup on entry 0x%X. It won't get cleaned.  Memory Leak.  HRESULT = 0x%X", m_pReceiverNode->m_Key, hr );            
            XomNtEvent( XEVENT_XWIRETAP_GENERIC_ERROR_16, "CActivityMonitor::OnAppointment: Failed to re-schedule checkup on entry 0x%X. It won't get cleaned.  Memory Leak.  HRESULT = 0x%X", m_pReceiverNode->m_Key, hr );            
            goto Exit;
        }
    }

Exit:
    pWireTap->ReleaseSchedulerInstance();
    CWireTap::ReleaseInstance();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wiretap\WireTap.cpp ===
//-----------------------------------------------------------------------------
//  Microsoft (R) XWireTap (tm). 
//  Copyright (C) 2002. All rights reserved.
//
//  FILE: WireTap.cpp
//
//  Implementation of the wiretap class.
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
//  Include
//-----------------------------------------------------------------------------
#include "StdAfx.h"

//-----------------------------------------------------------------------------
//  Definitions
//-----------------------------------------------------------------------------
XomDefineArea(XWireTap);

#define SG_INFO_DEFAULT_PORT    0xFFFF

//-----------------------------------------------------------------------------
//  Static Declarations
//-----------------------------------------------------------------------------
CWireTap* CWireTap::m_pInstance = NULL;
DWORD     CWireTap::m_dwRefCount = 0;

CNTService* g_pService = NULL;

//-----------------------------------------------------------------------------
//  Pre-Declarations for local functions
//-----------------------------------------------------------------------------
void                GetXOMSetting( char** pszValue, const char *c_szArea, const char *c_szDefault );
void                GetXOMSetting( DWORD* pdwValue, const char *c_szArea, DWORD c_dwDefault );
void                BuildSGInfoReq( CSgMsgSpiReq *pReq, DWORD dwReqNum, IN_ADDR ipaZ, WORD ipportZ );
void                GetPacketIPPortForSrc( BYTE *pPacket, IN_ADDR* pIP, WORD *pPort );
void                GetPacketIPPortForDest( BYTE *pPacket, IN_ADDR* pIP, WORD *pPort );
void                ConstructHashKey( BYTE *pKey, DWORD dwIP );
DWORD               TranslateAddr( char * sz );


//-----------------------------------------------------------------------------
//  Constants
//-----------------------------------------------------------------------------
const XomMgmtCmd c_aCmdList[] = {
    { "help",           strlen("help"),               CMgmtInterface::MgmtCmdHelp,           NULL,                                      NULL },
    { "AddTap",         strlen("AddTap"),             CMgmtInterface::MgmtCmdAddTap,         "<key type>=<key> lifetime=<HH:MM:SS>",    NULL },
    { "ListTaps",       strlen("ListTaps"),           CMgmtInterface::MgmtCmdListTaps,       NULL,                                      NULL },
    { "CloseTap",       strlen("CloseTap"),           CMgmtInterface::MgmtCmdCloseTap,       "<tap id>",                                NULL },
    { "RolloverTap",    strlen("RolloverTap"),        CMgmtInterface::MgmtCmdRollTap,        "<tap id>",                                NULL },
    { "Shutdown",       strlen("Shutdown"),           CMgmtInterface::MgmtCmdShutdown,       NULL,                                      NULL },        
    { "MonitorAll",     strlen("MonitorAll"),         CMgmtInterface::MgmtCmdMonitor,        NULL,                                      NULL },
};

const DWORD c_dwNumOfCommands               = ARRAY_ELEMENTS(c_aCmdList);
    
const char  c_szNumOfNics[]                 = "WireTap.NumOfNics";
const char  c_szLocalIP[]                   = "Nic%d.LocalIP";
const char  c_szAuthIP[]                    = "Nic%d.AuthDataIP";
const char  c_szVLanMACAddr[]               = "Nic%d.VLanMACAddr";
const char  c_szIPStart[]                   = "Nic%d.IPStart";
const char  c_szIPEnd[]                     = "Nic%d.IPEnd";

const DWORD c_dwDefaultPacketBufferSize     = 100000;
const DWORD c_dwDefaultAuthDataReplyPort    = 0xFFFF;
const DWORD c_dwDefaultNumOfReceiverNodes   = 10253;
const DWORD c_dwDefaultNumOfCarrierNodes    = 100000;
const DWORD c_dwAdditionPaddingNodes        = 100;
const DWORD c_dwDefaultMaxNumOfTaps         = 16;
const DWORD c_dwDefaultMaxNumOfRetrys       = 5;
const DWORD c_dwDefaultMaxNumOfSGRetrys     = 3;
const DWORD c_dwDefaultAuthDataWaitTime     = 2;
const DWORD c_dwDefaultSessTimeoutInterval  = 300;
const char  c_szDefaultIPStart[]            = "0.0.0.0";
const char  c_szDefaultIPEnd[]              = "255.255.255.255";
const DWORD c_dwDefaultNumOfNics            = 1;

const DWORD c_ShutdownTime                  = 1200000;           // 20 seconds to free memory and shut down.

const WCHAR  c_szServiceName[]               = L"XWireTap";
const WCHAR  c_szServiceDisplayName[]        = L"Xbox Wire Tap";
const WCHAR  c_szServiceDescription[]        = L"Xbox Wiretap Service";
const WCHAR  c_szPerfBaseName[]              = L"XWireTap";


//-----------------------------------------------------------------------------
//  CAuthSocketCallback Definition
//-----------------------------------------------------------------------------
class CAuthSocketCallback : public CServerSocketCallback
{
public:
        CAuthSocketCallback( ){}
    virtual ~CAuthSocketCallback(){}

    virtual ULONG AddRef() { return 0; }

    virtual ULONG Release() { return 0; }
    virtual void CAuthSocketCallback::OnSocketReceive(
                        BYTE *pbFilledInBuffer,
                        DWORD cbRead,
                        HRESULT hr,
                        QWORD qwCallbackArg );
};

//-----------------------------------------------------------------------------
//  CWireTap Implementation
//-----------------------------------------------------------------------------
CWireTap::CWireTap(void) : CNTService( c_szServiceName, c_szServiceDisplayName, c_szServiceDescription, c_szPerfBaseName )
{
    m_pScheduler = NULL;
    m_pPacketBuffer = NULL;
    m_bIsComplete = TRUE;
    m_pMgmtInterface = NULL;
    m_wTapCounter = 0;
    m_dwRequestCounter = 0;
    m_dwNumOfReceiverNodes = 0;
    m_dwNumOfCarrierNodes = 0;
    m_dwSGListSize = 0;
    m_dwMaxRetrys = 0;
    InitializeCriticalSection(&m_csNumOfTaps);
    m_dwNumOfTaps = 0;
    m_pdwUnWantedList = NULL;
    m_dwUnWantedListSize = 0;
    m_pNicMgr = NULL;
}

CWireTap::~CWireTap(void)
{
    m_pScheduler = NULL;
    m_pPacketBuffer = NULL;
    m_bIsComplete = TRUE;
    m_pMgmtInterface = NULL;
    m_wTapCounter  = 0;
    m_dwSGListSize = 0;
    m_dwMaxRetrys = 0;
    m_dwNumOfTaps = 0;
    DeleteCriticalSection(&m_csNumOfTaps);
    m_pdwUnWantedList = NULL;
    m_dwUnWantedListSize = 0;
    m_pNicMgr = NULL;
}

//-----------------------------------------------------------------------------
//  GetInstance:  Gets an instance of the wiretap
//-----------------------------------------------------------------------------
CWireTap* CWireTap::GetInstance()
{
    if ( m_pInstance == NULL )
    {
        XOMASSERT( m_dwRefCount == 0 );
        m_pInstance = new CWireTap();
        g_pService = m_pInstance;
        if ( m_pInstance == NULL )
        {
            // not enough memory to create wiretap instance.
            XomNtEvent( XEVENT_XWIRETAP_MEMORY_WARNING_25, "CWireTap::GetInstance:  Failed to allocate instance memory.  Please ensure machine has enough available RAM to run this program");
            XomTrace0( XWireTap, L_ERROR, "CWireTap::GetInstance:  Failed to allocate instance memory.  Please ensure machine has enough available RAM to run this program");
            goto Exit;
        }
    }

    InterlockedIncrement( (LPLONG)&(m_dwRefCount) );

Exit:
    return m_pInstance;
}

//-----------------------------------------------------------------------------
//  ReleaseInstance:  Releases the instance of the wiretap.
//-----------------------------------------------------------------------------
void CWireTap::ReleaseInstance()
{
    LONG lValue = 0;
    XOMASSERT( m_dwRefCount > 0 && m_pInstance != NULL );
    lValue = InterlockedDecrement( (LPLONG)&(m_dwRefCount) );
    if ( lValue == 0 )
    {
        delete m_pInstance;
        m_pInstance = NULL;
    }
}

//-----------------------------------------------------------------------------
//  Start:  Initializes and starts the wiretap service.
//-----------------------------------------------------------------------------
HRESULT CWireTap::Start()
{
    HRESULT hr = S_OK;    

    XOMASSERT( m_pPacketBuffer == NULL );
    XOMASSERT( m_pScheduler == NULL );
    XOMASSERT( m_pMgmtInterface == NULL );
    XOMASSERT( m_bIsComplete == TRUE );

    // TODO:  If something fails right now... we have MASSIVE MEMORY LEAKING... MUST FIX THIS PROBLEM.
    
    if ( !m_bIsComplete )
    {
        // not enough memory to create wiretap instance.
        XomNtEvent( XEVENT_XWIRETAP_GENERIC_ERROR_10, "CWireTap::Start:  WireTap service already started.");
        XomTrace0( XWireTap, L_ERROR, "CWireTap::Start:  WireTap service already started.");
        hr = E_FAIL;
        goto Exit;                        
    }
    
    XomTrace0( XWireTap, L_NORMAL, "CWireTap::Start:  Starting XWireTap.");
    
    //-------------------------------------------------------------
    // CONFIG
    XomTrace0( XWireTap, L_LOW, "CWireTap::Start:  Reading config data.");
    hr = LoadConfig();
    if ( FAILED(hr) )
    {
        // not enough memory to create wiretap instance.
        XomNtEvent( XEVENT_XWIRETAP_MEMORY_WARNING_26, "CWireTap::Start:  Failed to successfully load config data.  Please investigate this situation.  RESULT = %X", hr);
        XomTrace1( XWireTap, L_ERROR, "CWireTap::Start:  Failed to successfully load config data.  Please investigate this situation.  RESULT = %X", hr);
        goto Exit;                
    }

    // no shutdown event ... bummer.
    m_hShutdown = CreateEvent( NULL, FALSE, FALSE, NULL );
    if ( m_hShutdown == NULL ) 
    {
        hr = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );

        XomNtEvent( XEVENT_XWIRETAP_MEMORY_WARNING_27, "CWireTap::Start:  Failed to create handle.  Please investigate this situation.  RESULT = %X", hr);
        XomTrace1( XWireTap, L_ERROR, "CWireTap::Start:  Failed to create handle.  Please investigate this situation.  RESULT = %X", hr);
        goto Exit;                        
    }
    
    //-------------------------------------------------------------
    // Initialize completion port. 
    XomTrace0( XWireTap, L_LOW, "CWireTap::Start:  Creating the completion port.");
    hr = CCompletionPort::CreateInstance( 0, 1, THREAD_PRIORITY_ABOVE_NORMAL, &m_pCompletionPort);
    if(FAILED(hr))
    {
        XomNtEvent( XEVENT_XWIRETAP_INIT_FAIL, "CWireTap::Start:  CompletionPort CreateInstance Failed with RESULT = 0x%X.", hr);
        XomTrace1( XWireTap, L_ERROR, "CWireTap::Start:  CompletionPort CreateInstance Failed with RESULT = 0x%X.", hr);
        goto Exit;
    }

    //-------------------------------------------------------------
    //  NODEBAG
    XomTrace0( XWireTap, L_LOW, "CWireTap::Start:  Creating packet buffer object.");
    // create a new node bag.
    m_pPacketBuffer = new CNodeBag();
    if ( m_pPacketBuffer == NULL )
    {
        // not enough memory to create wiretap instance.
        XomNtEvent( XEVENT_XWIRETAP_MEMORY_WARNING_28, "CWireTap::Start:  Failed to allocated memory for the packet buffer handle.  Please ensure machine has enough available RAM to run this program.");
        XomTrace0( XWireTap, L_ERROR, "CWireTap::Start:  Failed to allocated memory for the packet buffer handle.  Please ensure machine has enough available RAM to run this program.");
        hr = E_OUTOFMEMORY;
        goto Exit;        
    }

    XomTrace0( XWireTap, L_LOW, "CWireTap::Start:  Initialize the packet buffer.");
    hr = m_pPacketBuffer->Initialize( sizeof(PacketNode) + c_dwMAX_MTU_ETHERNET, m_dwPacketBufferSize );
    if ( FAILED(hr) )
    {
        // not enough memory to create wiretap instance.
        XomNtEvent( XEVENT_XWIRETAP_MEMORY_WARNING_29, "CWireTap::Start:  Failed to allocated memory for the packet buffer.  Please ensure machine has enough available RAM to run this program or modify config setting to work with the given resources.");
        XomTrace0( XWireTap, L_ERROR, "CWireTap::Start:  Failed to allocated memory for the packet buffer.  Please ensure machine has enough available RAM to run this program or modify config setting to work with the given resources.");
        goto Exit;
    }

    //-------------------------------------------------------------
    // ActionNode Bag  
    XomTrace0( XWireTap, L_LOW, "CWireTap::Start:  Setting up the Action Nodes.");
    // create a tap listr
    hr = InitializeActionNodes();
    if ( FAILED(hr) )
    {
        // not enough memory to create wiretap instance.
        XomNtEvent( XEVENT_XWIRETAP_INIT_FAIL_1, "CWireTap::Start:  Failed to initialize the Action Node Bag Buffer.  Please investigate.  RESULT = 0x%X", hr);
        XomTrace1( XWireTap, L_ERROR, "CWireTap::Start:  Failed to initialize the Action Node Bag Buffer.  Please investigate.  RESULT = 0x%X", hr);
        hr = E_OUTOFMEMORY;
        goto Exit;        
    }


    //-------------------------------------------------------------
    // Scheduler
    XomTrace0( XWireTap, L_LOW, "CWireTap::Start:  Creating the scheduler.");
    // create a new scheduler
    m_pScheduler = new CScheduler();
    if ( m_pScheduler == NULL )
    {
        // not enough memory to create wiretap instance.
        XomNtEvent( XEVENT_XWIRETAP_MEMORY_WARNING_30, "CWireTap::Start:  Failed to allocated memory for the scheduler.  Please ensure machine has enough available RAM to run this program.");
        XomTrace0( XWireTap, L_ERROR, "CWireTap::Start:  Failed to allocated memory for the scheduler.  Please ensure machine has enough available RAM to run this program.");
        hr = E_OUTOFMEMORY;
        goto Exit;        
    }

    // initialize the scheduler.
    hr = m_pScheduler->Initialize( m_pCompletionPort );
    if ( FAILED(hr) )
    {
        // not enough memory to create wiretap instance.
        XomTrace1( XWireTap, L_ERROR, "CWireTap::Start:  Failed to initialize the scheduler.  RESULT = 0x%X", hr );
        goto Exit;        
    }

    // set the ref counter here... its default will be one... when this one is gone... it can't be created anymore.
    m_dwSchedulerRefCnt = 1;

    //-------------------------------------------------------------
    // ReceiverList
    XomTrace0( XWireTap, L_LOW, "CWireTap::Start:  Creating the Receiver List.");
    // create a new scheduler
    m_pReceiverList = new CReceiverList();
    if ( m_pReceiverList == NULL )
    {
        // not enough memory to create wiretap instance.
        XomNtEvent( XEVENT_XWIRETAP_MEMORY_WARNING_31, "CWireTap::Start:  Failed to allocated memory for the receiver list.  Please ensure machine has enough available RAM to run this program.");
        XomTrace0( XWireTap, L_ERROR, "CWireTap::Start:  Failed to allocated memory for the receiver list.  Please ensure machine has enough available RAM to run this program.");
        hr = E_OUTOFMEMORY;
        goto Exit;        
    }

    hr = m_pReceiverList->Initialize( m_dwNumOfReceiverNodes, m_dwNumOfCarrierNodes );
    if ( FAILED(hr) )
    {
        // not enough memory to create wiretap instance.
        XomTrace1( XWireTap, L_ERROR, "CWireTap::Start:  Failed to initialize the receiver list.  RESULT = 0x%X", hr );
        goto Exit;        
    }

    //-------------------------------------------------------------
    // Mgmt Interface
    XomTrace0( XWireTap, L_LOW, "CWireTap::Start:  Creating the XMGMT Interface.");
    // create a new mgmt interface
    m_pMgmtInterface = new CMgmtInterface();
    if ( m_pMgmtInterface == NULL )
    {
        // not enough memory to create wiretap instance.
        XomNtEvent( XEVENT_XWIRETAP_MEMORY_WARNING_32, "CWireTap::Start:  Failed to allocated memory for the Mgmt interface.  Please ensure machine has enough available RAM to run this program.");
        XomTrace0( XWireTap, L_ERROR, "CWireTap::Start:  Failed to allocated memory for the Mgmt interface.  Please ensure machine has enough available RAM to run this program.");
        hr = E_OUTOFMEMORY;
        goto Exit;        
    }

    hr = m_pMgmtInterface->Initialize( 20 );
    if ( FAILED(hr) )
    {
        // not enough memory to create wiretap instance.
        XomTrace1( XWireTap, L_ERROR, "CWireTap::Start:  Failed to initialize the Mgmt interface.  RESULT = 0x%X", hr );
        goto Exit;        
    }

    // intialize the callbacks
    InitializeCallbacks();
    
    //-------------------------------------------------------------
    //  Tap List
    XomTrace0( XWireTap, L_LOW, "CWireTap::Start:  Setting Up Task List.");
    // create a tap listr
    m_pTapList = new ListNode;
    if ( m_pTapList == NULL )
    {
        // not enough memory to create wiretap instance.
        XomNtEvent( XEVENT_XWIRETAP_MEMORY_WARNING_33, "CWireTap::Start:  Failed to create memory for the task list.  Please ensure machine has enough available RAM to run this program.");
        XomTrace0( XWireTap, L_ERROR, "CWireTap::Start:  Failed to create memory for the task list.  Please ensure machine has enough available RAM to run this program.");
        hr = E_OUTOFMEMORY;
        goto Exit;        
    }
    // initialize the head of the list.
    InitializeListHead(m_pTapList);

    //-------------------------------------------------
    // create the socket callback object.
    m_pSockCallback = new CAuthSocketCallback();
    if ( m_pSockCallback == NULL )
    {
        // not enough memory to create wiretap instance.
        XomNtEvent( XEVENT_XWIRETAP_MEMORY_WARNING_34, "CWireTap::Start:  Failed to create memory for the authdata socket callback interface.  Please ensure machine has enough available RAM to run this program.");
        XomTrace0( XWireTap, L_ERROR, "CWireTap::Start:  Failed to create memory for the authdata socket callback interface.  Please ensure machine has enough available RAM to run this program.");
        hr = E_OUTOFMEMORY;
        goto Exit;        
    }
        
    //-------------------------------------------------------------
    //  NicMgr/Vlan
    XomTrace0( XWireTap, L_LOW, "CWireTap::Start:  Initializing NicMgr.");
    m_pNicMgr = CWTNicMgr::GetInstance();

    hr = m_pNicMgr->Initialize( m_dwNumOfNics );
    if ( FAILED(hr) )
    {
        // not enough memory to create wiretap instance.
        XomNtEvent( XEVENT_XWIRETAP_INIT_FAIL_2, "CWireTap::Start:  Failed to initialize the Nic Mgr.  Result= 0x%X", hr);
        XomTrace1( XWireTap, L_ERROR, "CWireTap::Start:  Failed to initialize the Nic Mgr.  Result= 0x%X", hr);
        goto Exit;        
    }

    // load the nic configuration.
    hr = LoadNicConfig();
    if ( FAILED(hr) )
    {
        // not enough memory to create wiretap instance.
        XomNtEvent( XEVENT_XWIRETAP_INIT_FAIL_3, "CWireTap::Start:  Failed to configure the Nic Mgr.  Result= 0x%X", hr);
        XomTrace1( XWireTap, L_ERROR, "CWireTap::Start:  Failed to configure the Nic Mgr.  Result= 0x%X", hr);
        goto Exit;        
    }
    
    // no taps at this time 
    m_dwNumOfTaps = 0;

    // start the counter at 1... not zero
    m_wTapCounter = 1;

    XomNtEvent( XEVENT_XWIRETAP_INIT_SUCCESS, "CWireTap::Start:  Successfully started XWireTap.");
    XomTrace0( XWireTap, L_NORMAL, "CWireTap::Start:  Successfully started XWireTap.");
    m_bIsComplete = FALSE;

Exit:
    return hr;
}

//-----------------------------------------------------------------------------
//  Run:  runs until everything is quit.
//-----------------------------------------------------------------------------
HRESULT CWireTap::Run()
{
    HRESULT hr = S_OK;

    WaitForSingleObject( ShutdownEvent(), INFINITE );
    
    return hr;
}

//-----------------------------------------------------------------------------
//  Term:  Termintates wiretap service.
//-----------------------------------------------------------------------------
HRESULT CWireTap::Term()
{
    HRESULT hr = S_OK;

    XOMASSERT( m_pNicMgr != NULL );
    XOMASSERT( m_pScheduler != NULL);
    XOMASSERT (m_pMgmtInterface != NULL);
    XOMASSERT( m_pSockCallback != NULL);
    XOMASSERT( m_pPacketBuffer != NULL);

    m_pNicMgr->Terminate();
    CWTNicMgr::ReleaseInstance();
    m_pNicMgr = NULL;

    // TODO:  (lohab) I should block here until the completion port thread is dead....
    
    // Mgmt Interface
    m_pMgmtInterface->Terminate(); 
    if ( m_pMgmtInterface )
    {
        delete m_pMgmtInterface;
        m_pMgmtInterface = NULL;
    }
        
    // scheduler
    ReleaseSchedulerInstance();

    // delete the callback socket
    m_pSockCallback->Release();
    delete m_pSockCallback;
    m_pSockCallback = NULL;
    
    // delete the tap list and receiver list.
    CleanLists();

    // delete the packet buffer.
    delete m_pPacketBuffer;
    m_pPacketBuffer=NULL;

    m_bIsComplete = TRUE;
    
    SetEvent( m_hShutdown );
    
    return hr;
}


//-----------------------------------------------------------------------------
//  InitService:  initialize the wiretap service
//      overrides:  Initializes the service.
//-----------------------------------------------------------------------------
HRESULT CWireTap::InitService( DWORD dwArgc, LPWSTR *pszArgv )
{
    return Start();
}

//-----------------------------------------------------------------------------
//  InitService:  initialize the wiretap service
//      overrides:  run the service.
//-----------------------------------------------------------------------------
HRESULT CWireTap::RunService( BOOL *pfServiceRan )
{
    HRESULT hr = S_OK;
    CWTAction* pAction = NULL;
    
    hr = Run();
    if ( FAILED( hr ) )
    {
        XomNtEvent( XEVENT_XWIRETAP_TERM_FAIL, "CWireTap::RunService:  Failed to stop properly. 0x%X", hr);
        goto Exit;
    }
    *pfServiceRan = TRUE;

    XOMASSERT( m_pActionBag != NULL );
    XOMASSERT( m_pMgmtInterface != NULL);
    XOMASSERT( m_pCompletionPort != NULL );

    // post a message to the completion port to shutdown.
    // get an action node
    pAction = GetAction();
    if ( pAction == NULL )
    {
        XomNtEvent( XEVENT_XWIRETAP_MEMORY_WARNING_35, "CWireTap::RunService:  There are no more Action nodes.  This packet will be dropped.  Please re-config with more memory to avoid this.");
        XomTrace0( XWireTap, L_ERROR, "CWireTap::RunService:  There are no more Action nodes.  This packet will be dropped.  Please re-config with more memory to avoid this.");

        hr = E_OUTOFMEMORY;
        goto Exit;        
    }

    // set up the action
    pAction->Setup(  CWTAction::TERMINATE, (LPBYTE)NULL );
    
    // post the action to the completion port.
    hr = m_pCompletionPort->PostCompletion( (CCompletionContext*) pAction, sizeof(CWTAction), NULL );
    if ( FAILED(hr) )
    {
        XomNtEvent( XEVENT_XWIRETAP_TERM_FAIL_1, "CWireTap::RunService: Failed to post this TAP to the WireTap service.  TAP creation failed. :  RESULT = 0x%X.", hr );
        XomTrace1( XWireTap, L_ERROR, "CWireTap::RunService: Failed to post this TAP to the WireTap service.  TAP creation failed. :  RESULT = 0x%X.", hr );

        ReleaseAction( pAction );
        goto Exit;        
    }

    WaitForSingleObject( m_hShutdown, c_ShutdownTime );
    CloseHandle( m_hShutdown );

    // blow away the completion port
    if ( m_pCompletionPort )
    {
        m_pCompletionPort->Shutdown();        
        hr = m_pCompletionPort->Release();
        if ( FAILED(hr) )
        {
            XomNtEvent( XEVENT_XWIRETAP_GENERIC_ERROR_11, "CWireTap::RunService:  We experienced troubles release down the completion port.  RESULT = 0x%X", hr );
            XomTrace1( XWireTap, L_ERROR, "CWireTap::RunService:  We experienced troubles release down the completion port.  RESULT = 0x%X", hr );
        }

        m_pCompletionPort = NULL;
    }

    // get rid of the action nodes.
    hr = CleanActionNodes();
    if ( FAILED(hr) )
    {
        XomNtEvent( XEVENT_XWIRETAP_GENERIC_ERROR_12, "CWireTap::RunService:  Failed to destroy the Action node bag during termination.  Please investigate.  RESULT = 0x%X", hr );
        XomTrace1( XWireTap, L_ERROR, "CWireTap::RunService:  Failed to destroy the Action node bag during termination.  Please investigate.  RESULT = 0x%X", hr );
    }

    // free the unwanted list
    if (m_pdwUnWantedList)
    {
        XFree( m_pdwUnWantedList );
        m_pdwUnWantedList=NULL;
        m_dwUnWantedListSize=0;
    }

    XomNtEvent( XEVENT_XWIRETAP_TERM_SUCCESS ,"CWireTap::Term:  Successfully terminated XWiretap service.");
    XomTrace0( XWireTap, L_NORMAL ,"CWireTap::Term:  Successfully terminated XWiretap service.");

Exit:
    return hr;
}


//-----------------------------------------------------------------------------
//  LoadConfig:  Loads config data from xwiretap.ini
//-----------------------------------------------------------------------------
HRESULT CWireTap::LoadConfig()
{
    HRESULT hr = S_OK;
    BOOL    bRes = TRUE;
    char   szBuf[128];

    XomLog0(XWireTap, "---------------------------------------------------" );
    XomLog0(XWireTap, "   XWireTap Config Settings" );
    XomLog0(XWireTap, "---------------------------------------------------" );

    // create the config db instance for all KDCs
    hr = m_pConfig.CoCreateInstance(  __uuidof(ConfigInterop) );
    if ( FAILED(hr) )
    {
        XomTrace1(XWireTap, L_ERROR, "CWireTap::LoadConfig: Failed to create instance of the configDB interface.  Please investigate.  hr = 0x%X", hr);
        XomNtEvent( XEVENT_TOOLS_CODE_119, "CWireTap::LoadConfig: Failed to create instance of the configDB interface.  Please investigate.  hr = 0x%X", hr);
        goto Exit;
    }

    //------------------------------------------------------------------
    //  Get the Available SG's
    hr = LoadSGSVCINTServers();
    if ( FAILED(hr) )
    {
        XomNtEvent( XEVENT_TOOLS_CONFIG_60, "CWireTap::LoadConfig:  Could not retrieve the list of sgsvc_int interfaces.  This is the list used to send mgmt commands for tapping, without it this will not operate properly." );        
        XomTrace0( XWireTap, L_ERROR, "CWireTap::LoadConfig:  Could not retrieve the list of sgsvc_int interfaces.  This is the list used to send mgmt commands for tapping, without it this will not operate properly." );        
        hr = E_FAIL;
        goto Exit;        
    }
    
    //------------------------------------------------------------------
    //  Get the unwanted Ips to monitor.
    GetStringSetting( (LPSTR)szBuf, ARRAY_ELEMENTS(szBuf), Setting_wiretap_UnwantedIPs, "" );
    bRes = ConstructUnWantedList( szBuf );
    if (!bRes )
    {
        XomNtEvent( XEVENT_XWIRETAP_INVALID_SETTING, "CWireTap::LoadConfig:  No memory for the Unwanted List.  NOTE:  No unwanted address will be filter because of this problem." );        
        XomTrace0( XWireTap, L_ERROR, "CWireTap::LoadConfig:  No memory for the Unwanted List.  NOTE:  No unwanted address will be filter because of this problem." );        
    }

    //------------------------------------------------------------------
    //  Get the packet size buffer.
    m_dwPacketBufferSize = GetDWORDSetting( Setting_wiretap_PacketBufferSize, c_dwDefaultPacketBufferSize );

    //------------------------------------------------------------------
    //  Get the file output directory.
    GetStringSetting( (LPSTR)m_szDumpDir, ARRAY_ELEMENTS(m_szDumpDir), Setting_wiretap_DumpDirectory, "c:\\" );

    //------------------------------------------------------------------
    //  Get the file auth data reply port.
    m_dwUDPAuthReplyPort = GetDWORDSetting( Setting_wiretap_AuthDataReplyPort, c_dwDefaultAuthDataReplyPort );

    //------------------------------------------------------------------
    //  Get the number of receiver nodes for this process.
    m_dwNumOfReceiverNodes = GetDWORDSetting( Setting_wiretap_NumOfReceiverNodes, c_dwDefaultNumOfReceiverNodes );

    //------------------------------------------------------------------
    //  Get the number of carrier nodes for this process.
    m_dwNumOfCarrierNodes = GetDWORDSetting( Setting_wiretap_NumOfCarrierNodes, c_dwDefaultNumOfCarrierNodes );

    //------------------------------------------------------------------
    //  Get the maximum number of taps
    m_dwMaxNumOfTaps = GetDWORDSetting( Setting_wiretap_MaxNumOfTaps, c_dwDefaultMaxNumOfTaps );

    //------------------------------------------------------------------
    //  Get the maximum number of retries
    m_dwMaxRetrys = GetDWORDSetting( Setting_wiretap_MaxNumOfRetrys, c_dwDefaultMaxNumOfRetrys );

    //------------------------------------------------------------------
    //  Get the maximum number of SG retries before a recevier node is closed.
    m_dwMaxSGRetries = GetDWORDSetting( Setting_wiretap_MaxSGAuthDataRetry, c_dwDefaultMaxNumOfSGRetrys );

    //------------------------------------------------------------------
    //  Get the auth data wait time
    m_dwSGReplyWaitTimeInSecs = GetDWORDSetting( Setting_wiretap_AuthDataWaitTimeInSecs, c_dwDefaultAuthDataWaitTime );

    //------------------------------------------------------------------
    //  Get the default session timeout
    DWORD dwIntervalInSecs = 0;
    dwIntervalInSecs = GetDWORDSetting( Setting_wiretap_SGSessionTimeoutInSecs, c_dwDefaultSessTimeoutInterval );
    m_qwReceiverNodeLifetimeInterval = dwIntervalInSecs * 1000;

    //------------------------------------------------------------------
    //  Read and build interfaces for all nics.
    //m_dwNumOfNics = GetDWORDSetting( Setting_wiretap_NumOfNics, c_dwDefaultNumOfNics );
    GetXOMSetting( &m_dwNumOfNics, c_szNumOfNics, c_dwDefaultNumOfNics );
 
    XomLog0(XWireTap, "---------------------------------------------------" );

Exit:
    return hr;    
}


//-----------------------------------------------------------------------------
//  LoadNicConfig:  Loads config data from xwiretap.ini for Nic Mgr
//-----------------------------------------------------------------------------
HRESULT CWireTap::LoadNicConfig()
{
    HRESULT hr      = S_OK;
    BOOL    bRes    = TRUE;
    DWORD   dwNumOfNics = 0;
    DWORD   dwX     = 0;
    char*   szBuf;
    sockaddr_in saListenSocket;
    CServerSocket *pAuthDataSock = NULL;

    XomLog0(XWireTap, "---------------------------------------------------" );
    XomLog0(XWireTap, "   XWireTap Config Nic Settings" );
    XomLog0(XWireTap, "---------------------------------------------------" );
        

    XOMASSERT( m_pNicMgr != NULL );
    
    // for each nic...
    for ( dwX = 0; dwX < m_dwNumOfNics; dwX++ )
    {
        char szParamName[32];
        DWORD dwIP = 0;
        DWORD dwAuthIP = 0;
        DWORD dwStartIP = 0;
        DWORD dwEndIP = 0;
        DWORD dwId = 0;
        char* pszVlanMacAddr = NULL;

        // collect the params.        
        safe_snprintf( szParamName, ARRAY_ELEMENTS(szParamName), c_szLocalIP, dwX );
        GetXOMSetting( &szBuf, szParamName, "" );
        XOMASSERT( szBuf != NULL );
        dwIP = (DWORD)StringToIp( szBuf );
        if ( dwIP == 0 )
        {
            // invalid IP?  
            continue;
        }

        // udp socket for auth data
        safe_snprintf( szParamName, ARRAY_ELEMENTS(szParamName), c_szAuthIP, dwX );
        GetXOMSetting( &szBuf, szParamName, "" );
        XOMASSERT( szBuf != NULL );
        dwAuthIP = (DWORD)StringToIp( szBuf );
        if ( dwAuthIP == 0 )
        {
            // invalid IP?  
            continue;
        }
                
        safe_snprintf( szParamName, ARRAY_ELEMENTS(szParamName), c_szVLanMACAddr, dwX );
        GetXOMSetting( &pszVlanMacAddr, szParamName, "" );

        safe_snprintf( szParamName, ARRAY_ELEMENTS(szParamName), c_szIPStart, dwX );
        GetXOMSetting( &szBuf, szParamName, "" );
        XOMASSERT( szBuf != NULL );
        dwStartIP = (DWORD)StringToIp( szBuf );

        safe_snprintf( szParamName, ARRAY_ELEMENTS(szParamName), c_szIPEnd, dwX );
        GetXOMSetting( &szBuf, szParamName, "" );
        XOMASSERT( szBuf != NULL );
        dwEndIP = (DWORD)StringToIp( szBuf );
        if ( dwStartIP >= dwEndIP )
        {
            // invalid IP range
            continue;
        }

        //-------------------------------------------------------------
        // initialize the listener socket for Auth Data replies.
        XomTrace1( XWireTap, L_LOW, "CWireTap::LoadNicConfig: Initializing AuthData connection listener socket for Nic %d.", dwX );
        hr = CServerSocket::CreateInstance(&pAuthDataSock, m_pCompletionPort, m_pCompletionPort);
        if(FAILED(hr))
        {
            XomNtEvent(XEVENT_XWIRETAP_INIT_FAIL_4,  "CWireTap::LoadNicConfig: CServerSocket::CreateInstance failed, hr = 0x%X", hr);
            XomTrace1( XWireTap, L_ERROR, "CWireTap::LoadNicConfig: CServerSocket::CreateInstance failed, hr = 0x%X", hr);
            goto Exit;
        }

        // Check the addresses we got from the config file. If any of them are zero, 
        // we'll try to discover the local address.
        ZeroMemory(&saListenSocket, sizeof(saListenSocket));
        saListenSocket.sin_family = AF_INET;
        saListenSocket.sin_port = htons( (WORD)m_dwUDPAuthReplyPort );
        saListenSocket.sin_addr.S_un.S_addr = dwAuthIP;

        // initialize the UDP socket.
        hr = pAuthDataSock->Init(IPPROTO_UDP, &saListenSocket, FALSE);
        if(FAILED(hr))
        {
            XomNtEvent(XEVENT_XWIRETAP_INIT_FAIL_5,  "CWireTap::LoadNicConfig: CServerSocket Init failed.  Failed to add NIC%d.  Result = 0x%X", dwX, hr);
            XomTrace2( XWireTap, L_ERROR, "CWireTap::LoadNicConfig: CServerSocket Init failed.  Failed to add NIC%d.  Result = 0x%X", dwX, hr);
            goto Exit;
        }

        
        // add a new node to the nic mgr.
        hr = m_pNicMgr->Add( pszVlanMacAddr, dwIP, dwStartIP, dwEndIP, &dwId, pAuthDataSock );
        if ( FAILED(hr) )
        {
            XomTrace2(XWireTap, L_WARNING, "CWireTap::LoadNicConfig:  Failed to add Nic #%d.  Result = 0x%X", dwX, hr );
            continue;
        }
        
    }

    // make sure we at least have 1 nic
    if ( m_pNicMgr->GetNumOfNics() == 0 )
    {
        XomTrace0(XWireTap, L_WARNING, "CWireTap::LoadNicConfig:  No Nics present.  Please make sure this is properly configured." );
        hr = E_FAIL;
        goto Exit;
    }
 
    XomLog0(XWireTap, "---------------------------------------------------" );

Exit:
    return hr;    
}

//------------------------------------------------------------------
// QueuePacket:  Gets a node from the buffer and puts the packet 
//          on the processing IOCompletion port queue.
//------------------------------------------------------------------
HRESULT CWireTap::QueuePacket( BYTE *pPacket, UINT cPacket, DWORD dwNicId )
{
    FRAME *pFrame = NULL;
    PacketNode *pNode = NULL;
    HRESULT hr = S_OK;
    DWORD dwPacketSize = 0;
    CWTAction* pAction = NULL;
    IP_HEADER *pIPHdr = NULL;
    CScheduler* pScheduler = GetSchedulerInstance();
        
    XOMASSERT( pPacket != NULL );
    XOMASSERT( cPacket > 0 );

    if ( pScheduler == NULL )
    {
        // we're not initialized.
        goto Exit;
    }

    // get a node for this job
    pNode = (PacketNode*)m_pPacketBuffer->GetFromBag();
    if ( pNode == NULL )
    {
        XomNtEvent( XEVENT_XWIRETAP_MEMORY_WARNING_36, "CWireTap::QueuePacket:  Failed to get storage for packet.  XWiretap needs more resources to manage under this load.  Please investigate and add more memory if possible.");
        XomTrace0( XWireTap, L_ERROR, "CWireTap::QueuePacket:  Failed to get storage for packet.  XWiretap needs more resources to manage under this load.  Please investigate and add more memory if possible.");
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    AddRefPacketNode(pNode);

    // set up the node.
    pNode->m_Frame.TimeStamp = pScheduler->GetCurrentTime();

    // ensure it's not too big for us to handle.
    if ( cPacket > c_dwMAX_MTU_ETHERNET )
    {
        dwPacketSize = c_dwMAX_MTU_ETHERNET;
    }
    else
    {
        dwPacketSize = cPacket;
    }
    
    pNode->m_Frame.FrameLength = pNode->m_Frame.nBytesAvail = dwPacketSize;
    pNode->m_dwNicId = dwNicId;
    pIPHdr = (IP_HEADER*)(pNode->m_Frame.MacFrame + sizeof(CEnetHdr));

    // copy the packet contents over.
    memcpy( pNode->m_Frame.MacFrame, pPacket, dwPacketSize );

    XomTrace9(XWireTap, L_LOW, "CWireTap::QueuePacket:  Queueing Packet.  SIZE:%d  FROM:%d.%d.%d.%d  TO:%d.%d.%d.%d", 
                                dwPacketSize, 
                                (DWORD)(((BYTE*)&(pIPHdr->src))[0]), 
                                (DWORD)(((BYTE*)&(pIPHdr->src))[1]), 
                                (DWORD)(((BYTE*)&(pIPHdr->src))[2]), 
                                (DWORD)(((BYTE*)&(pIPHdr->src))[3]), 
                                (DWORD)(((BYTE*)&(pIPHdr->dest))[0]), 
                                (DWORD)(((BYTE*)&(pIPHdr->dest))[1]), 
                                (DWORD)(((BYTE*)&(pIPHdr->dest))[2]), 
                                (DWORD)(((BYTE*)&(pIPHdr->dest))[3]));

    // get an action node
    pAction = GetAction();
    if ( pAction == NULL )
    {
        XomNtEvent( XEVENT_XWIRETAP_MEMORY_WARNING_37, "CWireTap::QueuePacket:  There are no more Action nodes.  This packet will be dropped.  Please re-config with more memory to avoid this.");
        XomTrace0( XWireTap, L_ERROR, "CWireTap::QueuePacket:  There are no more Action nodes.  This packet will be dropped.  Please re-config with more memory to avoid this.");

        ReleasePacketNode( (PacketNode*)pNode );
        hr = E_OUTOFMEMORY;
        goto Exit;        
    }

    // set up the action
    pAction->Setup(  CWTAction::PACKET, (LPBYTE)pNode );
    
    // post the action to the completion port.
    hr = m_pCompletionPort->PostCompletion( (CCompletionContext*) pAction, sizeof(CWTAction), NULL );
    if ( FAILED(hr) )
    {
        XomNtEvent( XEVENT_XWIRETAP_TAP_CREATION_ERROR_10, "CWireTap::QueuePacket: Failed to post this TAP to the WireTap service.  TAP creation failed. :  RESULT = 0x%X.", hr );
        XomTrace1( XWireTap, L_ERROR, "CWireTap::QueuePacket: Failed to post this TAP to the WireTap service.  TAP creation failed. :  RESULT = 0x%X.", hr );

        ReleaseAction( pAction );
        ReleasePacketNode( (PacketNode*)pNode );
        goto Exit;        
    }

Exit:
    ReleaseSchedulerInstance();
    return hr;    
}


//------------------------------------------------------------------
// AddRef:  Increments the reference counter for this node.
//------------------------------------------------------------------
void CWireTap::AddRefPacketNode( PacketNode *pNode )
{
    InterlockedIncrement( (LPLONG)&(pNode->m_dwRefCount) );
}

//------------------------------------------------------------------
// Release:  removes the reference counter for this node.  Also,
//    Zero's out memory fo node when complete.
//------------------------------------------------------------------
void CWireTap::ReleasePacketNode( PacketNode *pNode )
{
    LONG lValue = 0;
    
    XOMASSERT( pNode->m_dwRefCount > 0 );
    
    lValue = InterlockedDecrement( (LPLONG)&(pNode->m_dwRefCount) );
    if ( lValue == 0 )
    {
        ZeroMemory( pNode, sizeof(PacketNode) + c_dwMAX_MTU_ETHERNET );    
        m_pPacketBuffer->PutInBag((ListNode*)pNode);    
    }
}

//------------------------------------------------------------------
// GetPacketNode:  returns a packet node
//------------------------------------------------------------------
PacketNode* CWireTap::GetPacketNode()
{
    PacketNode *pNode = NULL;
    
    // get a node for this job
    pNode = (PacketNode*)m_pPacketBuffer->GetFromBag();
    if ( pNode != NULL )
    {
        AddRefPacketNode(pNode);
    }

    return pNode;
}

//------------------------------------------------------------------
//  ProcessQueuedPackets:  When we have packets from an IP/Port that
//    we just found out about... we need to call this so it runs 
//    through the list and empties these packets.
//------------------------------------------------------------------
HRESULT CWireTap::ProcessQueuedPackets( BYTE *pReceiverListNodeKey )
{
    HRESULT hr = S_OK;
    ReceiverListNode *pRN;
    PacketNode* pPacket;

    XOMASSERT( m_pReceiverList );
    //  look up this entry in the receiver list.
    pRN = (ReceiverListNode*)m_pReceiverList->Lookup( pReceiverListNodeKey );
    if ( pRN == NULL )
    {
        // no entry to this... just forget about this then
        XomTrace1( XWireTap, L_WARNING, "CWireTap::ProcessQueuedPackets:  The given key has no associated receiver node.  IP=%X", 
                    (*((DWORD*)pReceiverListNodeKey)));
        goto Exit;
    }

    // ensure some entries exist.
    if ( IsListEmpty( &(pRN->m_TapList) ) )
    {
        XomTrace1( XWireTap, L_WARNING, "CWireTap::ProcessQueuedPackets:  The SG is sending information for TAPs that don't exist.  IP=%X", 
                    (*((DWORD*)pReceiverListNodeKey)));
        // no taps to send to right now... 
        goto Exit;
    }
    
    // look at all the packets... for each packet... send it to all the associated taps.
    while ( NULL != ( pPacket = (PacketNode*)m_pReceiverList->GetQueuedPacket( pRN ) ) )
    {       
        CarrierNode* pCarrier = NULL;
        for(    pCarrier = (CarrierNode*)(pRN->m_TapList.m_pNext); 
                pCarrier->m_Link.m_pNext != pRN->m_TapList.m_pNext; 
                pCarrier = (CarrierNode*)(pCarrier->m_Link.m_pNext) )
        {
            CTap *pTap = (CTap*)(pCarrier->m_pItem);
            
            // this tap thread now has a reference to this packet.
            AddRefPacketNode( pPacket );
            pTap->PostPacket( (LPVOID)pPacket );
        }

        // the master thread no longer cares about this packet.  Release our reference.
        ReleasePacketNode( pPacket );
    }

Exit:
    return hr;
}

//------------------------------------------------------------------
//  ProcessPacket:  figure out what to do with the packet
//------------------------------------------------------------------
HRESULT CWireTap::ProcessPacket( PacketNode *pNode )
{
    HRESULT hr = S_OK;
    ReceiverListNode *pRN;
    BYTE bytKey[HASH_KEY_SIZE];
    DWORD dwIP = 0;
    WORD wPort;
    DWORD dwIPDest = 0;
    WORD wPortDest;
    IP_HEADER *pIPHdr = (IP_HEADER*)(pNode->m_Frame.MacFrame + sizeof(CEnetHdr));

    ZeroMemory( bytKey , sizeof( bytKey ));

    XOMASSERT( m_pReceiverList );

    // make sure that we want to collect packets.  Otherwise... drop on the floor
    if ( m_dwNumOfTaps == 0 )
    {
        goto Exit;
    }

    GetPacketIPPortForSrc( (BYTE*)&(pNode->m_Frame.MacFrame), (IN_ADDR*)&dwIP, &wPort );    
    GetPacketIPPortForDest( (BYTE*)&(pNode->m_Frame.MacFrame), (IN_ADDR*)&dwIPDest, &wPortDest );

    XomTrace9(XWireTap, L_LOW, "CWireTap::ProcessPacket:  Reviewing Packet.  SIZE:%d  FROM IP:%d.%d.%d.%d  TO:%d.%d.%d.%d", 
                                pNode->m_Frame.FrameLength, 
                                DWORD(((BYTE*)&dwIP)[0]), 
                                DWORD(((BYTE*)&dwIP)[1]), 
                                DWORD(((BYTE*)&dwIP)[2]), 
                                DWORD(((BYTE*)&dwIP)[3]), 
                                DWORD(((BYTE*)&dwIPDest)[0]), 
                                DWORD(((BYTE*)&dwIPDest)[1]), 
                                DWORD(((BYTE*)&dwIPDest)[2]), 
                                DWORD(((BYTE*)&dwIPDest)[3]) );

    // ensure that packet is not from or to anywhere we dont' want to log.
    hr = IsNotUnWanted( dwIP );
    if ( FAILED(hr) )
    {
        // dont' care... just toss it away.
        hr = S_OK;
        goto Exit;        
    }
    hr = IsNotUnWanted( dwIPDest );
    if ( FAILED(hr) )
    {
        // dont' care... just toss it away.
        hr = S_OK;
        goto Exit;        
    }

    // check if the packets IPs are in the expected range.
    int nRangeCheck = m_pNicMgr->IsInSGRange( pNode->m_dwNicId, dwIP, dwIPDest );
    switch(nRangeCheck)
    {
        case -1:
        {
            // just continue doing what you do....
            break;
        }
        case 1:
        {
            // this isn't a packet from the SG... check the dest packet.
            dwIP = dwIPDest;
            wPort = wPortDest;
            break;
        }
        default:
        {
            // don't know why we got this packet...
            goto Exit;
        }                    
    }

    // construct the key based on what we know.
    ConstructHashKey( (BYTE*)bytKey, dwIP );

    XomTrace9(XWireTap, L_LOW, "CWireTap::ProcessPacket:  Processing Packet.  SIZE:%d  FROM IP:%d.%d.%d.%d   TO:%d.%d.%d.%d", 
                                pNode->m_Frame.FrameLength, 
                                DWORD(((BYTE*)&dwIP)[0]), 
                                DWORD(((BYTE*)&dwIP)[1]), 
                                DWORD(((BYTE*)&dwIP)[2]), 
                                DWORD(((BYTE*)&dwIP)[3]), 
                                DWORD(((BYTE*)&dwIPDest)[0]), 
                                DWORD(((BYTE*)&dwIPDest)[1]), 
                                DWORD(((BYTE*)&dwIPDest)[2]), 
                                DWORD(((BYTE*)&dwIPDest)[3]) );


    //  look up this entry in the receiver list.
    pRN = (ReceiverListNode*)m_pReceiverList->Lookup( bytKey );
    if ( pRN == NULL )
    {
        //hmm... no node for this yet...
        hr = m_pReceiverList->Add( bytKey );
        if ( FAILED(hr) )
        {
            // TODO:  (lohab)  add some tracing here.
            // failed to add a new node... drop the packet and continue.
            goto Exit;
        }

        // now that this entry is in the list... 
        pRN = (ReceiverListNode*)m_pReceiverList->Lookup( bytKey );
        XOMASSERT( pRN != NULL );        

    }

    // check the time on this node.  if its been inactive for too long... clean it up...
    if ( pRN->m_qwLastAccessTime + m_qwReceiverNodeLifetimeInterval < m_pScheduler->GetCurrentTime() )
    {
        // remove the entry
        hr = m_pReceiverList->Remove( bytKey );
        if ( FAILED(hr) )
        {
            // darn... failed to remove the node... this is a big problem.  Maybe it's gone now.    
            XomTrace2(XWireTap, L_LOW, "CWireTap::ProcessPacket:  Entry can't be found in table.  Failed to remove but continuing to process.  Key=0x%X, Result=0x%X", bytKey, hr );
            hr = S_OK;
        }
        
        //hmm... no node for this yet...
        hr = m_pReceiverList->Add( bytKey );
        if ( FAILED(hr) )
        {
            // TODO:  (lohab)  add some tracing here.
            // failed to add a new node... drop the packet and continue.
            goto Exit;
        }

        // now that this entry is in the list... 
        pRN = (ReceiverListNode*)m_pReceiverList->Lookup( bytKey );
        XOMASSERT( pRN != NULL );        
    }
       

    // check the TapList.
    if ( IsListEmpty( &(pRN->m_TapList) ) )
    {
        hr = m_pReceiverList->AddPacket( pRN, (ListNode*) pNode);        
        if ( FAILED(hr) )
        {
            XomTrace1( XWireTap, L_WARNING, "CWireTap::ProcessPacket:  The given key has no associated receiver node.  IP=0x%X", 
                    dwIP );
            
            goto Exit;
        }
        XomTrace1(XWireTap, L_LOW, "CWireTap::ProcessPacket:  Added PacketNode to receiver list under key(0x%X).", *((DWORD*)bytKey) );
        AddRefPacketNode( pNode );

        // if no one has acted yet... send a request for auth data.
        if ( pRN->m_AuthDataState == ADS_NONE )
        {
            XomTrace2( XWireTap, L_LOW, "CWireTap::ProcessPacket:  Sending request for AuthData.  Key=0x%X  IP:0x%X", *((DWORD*)bytKey), dwIP);

            hr = RequestAuthData( pNode, (BYTE*)bytKey );
            if ( FAILED(hr) )
            {
                XomTrace2( XWireTap, L_ERROR, "CWireTap::ProcessPacket:  Failed Request for AuthData.  Key=0x%X  Result:0x%X", *((DWORD*)bytKey), hr);
                goto Exit;
            }
            pRN->m_AuthDataState = ADS_PENDING;
        }
        
        goto Exit;
    }
    
    // look at all the packets... for each packet... send it to all the associated taps.
    CarrierNode* pCarrier = NULL;
    for(    pCarrier = (CarrierNode*)(pRN->m_TapList.m_pNext); 
            pCarrier->m_Link.m_pNext != pRN->m_TapList.m_pNext; 
            pCarrier = (CarrierNode*)(pCarrier->m_Link.m_pNext) )
    {
        CTap *pTap = (CTap*)pCarrier->m_pItem;
            
        // this tap thread now has a reference to this packet.
        AddRefPacketNode( pNode );
        pTap->PostPacket( (LPVOID)pNode );
    }


Exit:
    ReleasePacketNode( pNode );
    return hr;
    
}


//------------------------------------------------------------------
//  SendAuthDataRequest:  sends an authdata request to the
//              requesting SG
//------------------------------------------------------------------
HRESULT CWireTap::SendAuthDataRequest( PacketNode *pNode , BYTE* pKey )
{
    HRESULT hr = S_OK;
    SOCKET  sock;
    int     nSendToRes = 0;
    CSgMsgSpiReq sqInfoReq;
    IN_ADDR ipaZ;
    WORD    wPortZ;
    SOCKADDR_IN saddr;

    // extract the necessary address from
    memcpy( &ipaZ, pKey, sizeof(ipaZ) );
    memcpy( &wPortZ, pKey + sizeof(DWORD), sizeof(wPortZ) );
    
    m_dwRequestCounter = (m_dwRequestCounter + 1) % 2147483648;

    // build the request
    BuildSGInfoReq( &sqInfoReq, m_dwRequestCounter, ipaZ, wPortZ );

    // get the SOCKET from the CServSock object.
    hr = (m_pNicMgr->GetServerSock(pNode->m_dwNicId))->GetSocket( &sock );
    if ( FAILED(hr) )
    {
        XomTrace2( XWireTap, L_ERROR, "CWireTap::SendAuthDataRequest:  Failed to get SOCKET for Auth Data lookups.  Request for Packet data failed.  Key = 0x%X, RESULT = 0x%X", *((DWORD*)pKey), hr);
        goto Exit;
    }

    // set up the TO socket addr for the send.
    saddr.sin_family = AF_INET;
    saddr.sin_port  = SG_INFO_DEFAULT_PORT;
    saddr.sin_addr  = ipaZ;
        
    XomTrace1( XWireTap, L_LOW, "CWireTap::SendAuthDataRequest:  Sending AUTHDATA request.  Key = 0x%X", *((DWORD*)pKey) );

    // use the socket and send the packet to the appropriate SG.
    nSendToRes = sendto( sock, (char*)(&sqInfoReq), sizeof(sqInfoReq), 0, (const sockaddr*)&saddr , sizeof(saddr) ); 
    if ( nSendToRes == SOCKET_ERROR || nSendToRes < sizeof(sqInfoReq) )
    {
        // something went wrong... let's report it and hope everything is alright.
        hr = MAKE_HRESULT( 1, FACILITY_WIN32, WSAGetLastError() );
        XomTrace1( XWireTap, L_ERROR, "CWireTap::SendAuthDataRequest:  Failed to send packet.  Key = 0x, RESULT = 0x%X", hr );
        goto Exit;
    }

Exit:
    return hr;
}

//------------------------------------------------------------------
//  CloseTap:  Informs a TAP to close down.
//------------------------------------------------------------------
HRESULT CWireTap::CloseTap( ULONGLONG qwTapId )
{
    HRESULT hr = S_OK;
    CTap *pTap = NULL;

    // get the tap.
    pTap = GetTap( qwTapId );
    if ( pTap == NULL )
    {
        XomNtEvent( XEVENT_XWIRETAP_TAP_CLOSE_ERROR, "CWireTap::CloseTap:  Could not find the desire Tap with ID = 0x%I64X.", qwTapId );
        XomTrace1( XWireTap, L_ERROR, "CWireTap::CloseTap:  Could not find the desire Tap with ID = 0x%I64X.", qwTapId );
        goto Exit;        
    }

    WriteLockTapList();
    // remove from the Tap List
    RemoveEntryList( ((ListNode*)pTap) );
    WriteUnlockTapList();

    // remove from teh receiver list.
    hr = m_pReceiverList->RemoveTap( qwTapId );
    if ( FAILED(hr) )
    {
        XomTrace2( XWireTap, L_ERROR, "CWireTap::CloseTap:  Failed to remove tap from receiver list.  ID = 0x%I64X RESULT = 0x%X.", qwTapId, hr );

        // don't really care here... keep going.
        hr = S_OK;
    }

    // decrement the counter
    DecNumTaps();

    // signal the tap to clean up itself on its own thread.    
    hr = pTap->Close();
    if ( FAILED(hr) )
    {
        XomNtEvent( XEVENT_XWIRETAP_TAP_CLOSE_ERROR_1, "CWireTap::CloseTap:  Could not close the desire Tap with ID = 0x%I64X.", qwTapId );
        XomTrace1( XWireTap, L_ERROR, "CWireTap::CloseTap:  Could not close the desire Tap with ID = 0x%I64X.", qwTapId );
        goto Exit;        
    }

Exit:
    return hr;
}

//------------------------------------------------------------------
//  CreateTap:  creates a tap and puts it in the list.
//    NOT THREAD SAFE... should be run on completion port thread.
//------------------------------------------------------------------
HRESULT CWireTap::CreateTap( CTap* pTap )
{
    HRESULT hr = S_OK;

    XOMASSERT( pTap != NULL );

    // add the tap to the receiver list.
    hr = m_pReceiverList->AddTap( pTap );
    if ( FAILED(hr) )
    {
        XomNtEvent( XEVENT_XWIRETAP_TAP_CREATION_ERROR_11, "CWireTap::CreateTap:  Failed to add the tap to the receiver list.  Result=0x%X", hr);
        XomTrace1( XWireTap, L_ERROR, "CWireTap::CreateTap:  Failed to add the tap to the receiver list.  Result=0x%X", hr);
        goto Exit;
    }

    // put it in the tap list.    
    InsertTapList( pTap );
    
Exit:        
    return hr;
}

//------------------------------------------------------------------
//  InsertTapList:  Places Tap in tap list.
//------------------------------------------------------------------
void  CWireTap::InsertTapList( CTap* pTap )
{
    WriteLockTapList();
    // insert into the tap list.
    InsertTailList( m_pTapList, (ListNode*)pTap );   

    WriteUnlockTapList();
}

//------------------------------------------------------------------
//  RemoveTapList:  Removes the tap from the tap list.
//------------------------------------------------------------------
void  CWireTap::RemoveTapList( CTap* pTap )
{
    WriteLockTapList();
    // insert into the tap list.
    RemoveEntryList( (ListNode*)pTap );   
    WriteUnlockTapList();
    
}

//------------------------------------------------------------------
//  CleanLists:  Destroys the receiver and Tap lists.
//------------------------------------------------------------------
void CWireTap::CleanLists()
{
    ListNode *pItem = NULL;

    XOMASSERT( m_pReceiverList != NULL );
    XOMASSERT( m_pTapList != NULL );

    m_pReceiverList->Terminate();
    delete m_pReceiverList;
    m_pReceiverList=NULL;

    WriteLockTapList();

    // clean the tap list.
    for ( pItem = m_pTapList->m_pNext; pItem != m_pTapList ;  )
    {
        CTap* pTap = (CTap*)pItem;
        
        pItem = pItem->m_pNext;
        pTap->Close();
        RemoveEntryList( (ListNode*)pTap );
    }

    WriteUnlockTapList();

    delete m_pTapList;
    m_pTapList = NULL;
    
}

//------------------------------------------------------------------
//  RequestAuthData:  Sends a request to the SGs for auth data
//      about this packet.
//------------------------------------------------------------------
HRESULT CWireTap::RequestAuthData( PacketNode *pNode, BYTE* pKey  )
{
    HRESULT hr = S_OK;
    PacketNode* pBuffer = NULL;
    ReceiverListNode* pReceiverNode = NULL;
    CSGRetryCallback* pCallback = NULL;

    // ensure that we don't have auth data for this entry.
    pReceiverNode = (ReceiverListNode*)m_pReceiverList->Lookup( pKey );
    if ( pReceiverNode != NULL )
    {
        // this node is already in the table.  check the timestamp and only get auth data if it has expired.
        if ( ( pReceiverNode->m_AuthDataState == ADS_DONE ) &&
             ( pReceiverNode->m_qwLastAccessTime + m_qwReceiverNodeLifetimeInterval < m_pScheduler->GetCurrentTime() ) )
        {
            hr = S_OK;
            goto Exit;
        }
    }
    
    // get a node for this job
    pBuffer = (PacketNode*)m_pPacketBuffer->GetFromBag();
    if ( pNode == NULL )
    {
        XomNtEvent( XEVENT_XWIRETAP_MEMORY_WARNING_38, "CWireTap::RequestAuthData:  Failed to get storage for packet.  XWiretap needs more resources to manage under this load.  Please investigate and add more memory if possible. Key = 0x%X", *pKey);
        XomTrace1( XWireTap, L_ERROR, "CWireTap::RequestAuthData:  Failed to get storage for packet.  XWiretap needs more resources to manage under this load.  Please investigate and add more memory if possible. Key = 0x%X", *pKey);
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    AddRefPacketNode(pBuffer);

    XomTrace1( XWireTap, L_LOW, "CWireTap::RequestAuthData:  Setting up 'Receive' for AUTHDATA.  Key = 0x%X", *((DWORD*)pKey));

    // set up a buffer for the response.
    // NOTE:  the buffer used is a packet buffer.  So we can determine what to do with it after.  The  packetnode
    //      will be used for the response.  The MACROs here give the addresses that will be used for this data.
    hr = (m_pNicMgr->GetServerSock(pNode->m_dwNicId))->Receive( PACKETNODE_DATA_ADDR(pBuffer), c_dwMAX_MTU_ETHERNET, m_pSockCallback, 0);
    if (FAILED(hr) )
    {
        XomTrace1( XWireTap, L_ERROR, "CWireTap::RequestAuthData:  Failed to request authdata from SG. Key = 0x%X", *((DWORD*)pKey));
        ReleasePacketNode(pBuffer);

        goto Exit;
    }

    // set up the appointment
    if ( pReceiverNode->m_hAuthDataRetryApt != 0 )
    {
        // we already have an auth data appointment...  do it again :)
        CSchedulerAppointment *pSA = (CSchedulerAppointment*)pReceiverNode->m_hAuthDataRetryApt;

        pCallback = (CSGRetryCallback*)(pSA->GetCallback());                
    }
    else
    {
        // create a new callback.
        pCallback = new CSGRetryCallback( pNode, pKey, HASH_KEY_SIZE );
        if ( pCallback == NULL )
        {
            // AHHH  no more memory!!!
            XomTrace1( XWireTap, L_ERROR, "CWireTap::RequestAuthData:  Out of memory trying to create a retry callback for Auth data.  Please ensure the system is strong enough for this.  Key = 0x%X", *((DWORD*)pKey));
            hr = E_OUTOFMEMORY;
            goto Exit;
            
        }
    }

    // create a new appointment for the retry.
    m_pScheduler->CreateAppointment( ( m_dwSGReplyWaitTimeInSecs * 1000 ) + m_pScheduler->GetCurrentTime(), 
                                     pCallback, 
                                     0, 
                                     &(pReceiverNode->m_hAuthDataRetryApt) );
    if ( FAILED(hr) )
    {
        XomTrace2( XWireTap, L_ERROR, "CWireTap::RequestAuthData:  Failed to create a new appointment.  If this is expected, please remove this message.  Key = 0x%X, RESULT = 0x%X", *((DWORD*)pKey), hr);
        goto Exit;
    }
    
    // send the request for auht data
    hr = SendAuthDataRequest( pNode , pKey );

Exit:    
    return hr;
}

//------------------------------------------------------------------
//  ProcessAuthData:  Takes given auth data and add it to entry
//      in receiver list.
//------------------------------------------------------------------
HRESULT CWireTap::ProcessAuthData( BYTE *pKey, PacketNode* pPacketNode )
{
    HRESULT hr = S_OK;

    XOMASSERT( m_pReceiverList );
    //  look up this entry in the receiver list.
    hr = m_pReceiverList->AssociateAuthData( pKey, (BYTE*)pPacketNode );
    if (FAILED(hr) )
    {
        // no entry to this... just forget about this then
        XomTrace1( XWireTap, L_WARNING, "CWireTap::ProcessAuthData:  Failed to associate auth data to node at this key(0x%X).", *((DWORD*)pKey));
        goto Exit;
    }
    else if ( hr == S_FALSE )
    {
        // we don't care if the node is active ... assume we just got a retry response.
        hr = S_OK;
    }

    hr = ProcessQueuedPackets( pKey );
    if ( FAILED(hr) )
    {
        // no entry to this... just forget about this then
        XomTrace1( XWireTap, L_WARNING, "CWireTap::ProcessAuthData:  Failed to process Queued Packets.  This may cause lost data or incorrected data ordering for key(0x%I64X).", *((DWORD*)pKey) );
        goto Exit;
    }

Exit:    
    return hr;
}

//------------------------------------------------------------------
//  ProcessAuthDataReply:  Processes the auth data reply.
//------------------------------------------------------------------
HRESULT CWireTap::ProcessAuthDataReply( BYTE *pReply )
{
    HRESULT hr = S_OK;
    BYTE bytKey[HASH_KEY_SIZE];
    CSgMsgSpiRep* pResp;
    PacketNode *pPacketNode;

    XOMASSERT( pReply != NULL );

    pPacketNode = (PacketNode*)pReply;
    pResp = (CSgMsgSpiRep*)PACKETNODE_DATA_ADDR(pPacketNode);
    
    XomTrace0( XWireTap, L_LOW, "CWireTap::ProcessAuthDataReply:  Received data from SG.  Verifying.  Please see log for more information." );
    
    //  verify the contents of teh packet.
    hr = VerifySGAuthResponse( PACKETNODE_DATA_ADDR(pPacketNode) );
    if ( FAILED(hr) )
    {
        // no entry to this... just forget about this then
        XomTrace0( XWireTap, L_WARNING, "CWireTap::ProcessAuthData:  Received an invalid SG auth response.");
        goto Exit;                
    }

    // get the key
    ConstructHashKey( (BYTE*)bytKey, (DWORD)(pResp->_ipaZ.S_un.S_addr) );

    hr = ProcessAuthData( (BYTE*)bytKey, pPacketNode );
    if ( FAILED(hr) )
    {
        // no entry to this... just forget about this then
        XomTrace2( XWireTap, L_WARNING, "CWireTap::ProcessAuthData:  Failed to associate auth data to this IP/Port combination.  Key = 0x%X, RESULT = 0x%X", *((DWORD*)bytKey), hr);
        goto Exit;                        
    }
    
Exit:    
    return hr;
}

//------------------------------------------------------------------
//  VerifySGAuthResponse:  Verifies the auth data response.
//------------------------------------------------------------------
HRESULT CWireTap::VerifySGAuthResponse( BYTE* pPacket )
{
    HRESULT hr = S_OK;
    CSgMsgSpiRep* pResp = NULL;
        
    XOMASSERT( pPacket != NULL );

    // get the response... jump pass all the heaeder information.
    pResp = (CSgMsgSpiRep*)(pPacket);

    // ensure the type.
    if ( pResp->_wType != SGMSG_TYPE_SPIDATA_REP )
    {
        // no entry to this... just forget about this then
        XomTrace1( XWireTap, L_WARNING, "CWireTap::VerifySGAuthResponse:  Invalid response type given.  TYPE = %d", 
            pResp->_wType );
        hr = E_FAIL;
        goto Exit;        
    }

    // ensure the packet size
    if ( pResp->_cbEnt < sizeof(CSgMsgSpiRep) )
    {
        // no entry to this... just forget about this then
        XomTrace2( XWireTap, L_WARNING, "CWireTap::VerifySGAuthResponse:  Size of response is incorrect.  Size = 0x%X, Expected >= 0x%X ", 
            pResp->_cbEnt, 
            sizeof(CSgMsgSpiRep) );
        hr = E_FAIL;
        goto Exit;        
    }
    
    // check if the request was found.
    if ( pResp->_fNotFound != 0 )
    {           
        // no entry to this... just forget about this then
        XomTrace2( XWireTap, L_WARNING, "CWireTap::VerifySGAuthResponse:  This entry was not found on the SG.  0x%X:%X(DMZ)", 
                    pResp->_ipaZ,
                    pResp->_ipportZ
                  );

        // TODO:  (lohab) Extract the key... find the node... and mark it free again!!!!
        hr = E_FAIL;
        goto Exit;
    }
        
    // finally check the size of the replys auth data.
    if ( pResp->_cbEnt != CBSGSPIREPMSG )
    {
        XomTrace3( XWireTap, L_WARNING, "CWireTap::VerifySGAuthResponse:  SG auth data size is incorrect.  Size = 0x%X, 0x%X:%X(DMZ)", 
                    pResp->_cbEnt,
                    pResp->_ipaZ,
                    pResp->_ipportZ
                  );
        hr = E_FAIL;
        goto Exit;        
    }

Exit:
    return hr;
}
       
//------------------------------------------------------------------
//  GetTap:  Gets the tap with the given Id.  
//     NULL if does not exist.
//------------------------------------------------------------------
CTap* CWireTap::GetTap( ULONGLONG qwTapId )
{
    CTap* pRes = NULL;

    // scan for our entry.
    for ( pRes = (CTap*)m_pTapList->m_pNext; 
          (pRes->GetTapID()!= qwTapId) && ((ListNode*)pRes != m_pTapList); 
          pRes = (CTap*)pRes->m_pNext );
    
    // if this is the head of the list still... then we didn't find the node we wanted... return NULL;
    if ( pRes == m_pTapList )
    {
        pRes = NULL;
    }

    return pRes;
}

//------------------------------------------------------------------
//  GenerateNewTapId:  generates the new Tap id
//------------------------------------------------------------------
ULONGLONG CWireTap::GenerateNewTapId()
{
    TapId tapId;
    SYSTEMTIME stTime;

    GetSystemTime( &stTime );

    //  the format is MMDDHH{counter}
    tapId.m_wMonth = stTime.wMonth;
    tapId.m_wDay   = stTime.wDay;
    tapId.m_wHour  = stTime.wHour;
    tapId.m_wId    = m_wTapCounter;

    // increase the counter  
    InterlockedIncrement( (LPLONG)&(m_wTapCounter) );
    
    return *((ULONGLONG*)(&tapId));
}

//------------------------------------------------------------------
//  InitializeCallbacks:  Initializes callback with mgmt interface.
//------------------------------------------------------------------
void CWireTap::InitializeCallbacks()
{
    HRESULT hr = S_OK;
    DWORD   dwX = 0;

    for ( dwX = 0; dwX < c_dwNumOfCommands;  dwX++ )
    {
        hr = m_pMgmtInterface->RegisterCommand( c_aCmdList[dwX] );
        if ( FAILED(hr) )
        {
            XomNtEvent( XEVENT_XWIRETAP_VLAN_ERROR,"CWireTap::Start:  Failed to attach VLAN to given address.  Please ensure setting is correct." );        
            XomTrace0( XWireTap, L_ERROR, "CWireTap::Start:  Failed to attach VLAN to given address.  Please ensure setting is correct." ); 
        }


    }
}

//------------------------------------------------------------------
//  GetAction:  Gets a action node from the bag.
//------------------------------------------------------------------
CWTAction* CWireTap::GetAction()
{
    XOMASSERT( m_pActionBag != NULL );
    return (CWTAction*)m_pActionBag->GetFromBag();
}

//------------------------------------------------------------------
//  ReleaseAction:  Releases an action node and puts it in the bag
//------------------------------------------------------------------
void CWireTap::ReleaseAction( CWTAction *pAction )
{
    XOMASSERT( pAction != NULL );
    pAction->Clean();

    m_pActionBag->PutInBag( (ListNode*)pAction );
}

//------------------------------------------------------------------
//  InitializeActionNodes:  Builds all nodes in the action node bag.
//------------------------------------------------------------------
HRESULT CWireTap::InitializeActionNodes()
{
    HRESULT hr = S_OK;
    ListNode tempList;
    ListNode *pItem = NULL;
    CWTAction* pAct = NULL;
    
    InitializeListHead( &tempList );

    // create a new bag of action nodes
    m_pActionBag = new CNodeBag();
    if ( m_pActionBag == NULL )
    {
        XomTrace0( XWireTap, L_ERROR, "CWireTap::InitializeActionNodes:  Failed to get memory for Action node bag." ); 
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = m_pActionBag->Initialize( sizeof(CWTAction) + sizeof(DWORD), m_dwPacketBufferSize + c_dwAdditionPaddingNodes );
    if ( FAILED(hr) )
    {
        XomTrace1( XWireTap, L_ERROR, "CWireTap::InitializeActionNodes:  Failed to initialize action node buffer.  RESULT = 0x%X", hr ); 
        goto Exit;
    }

    // get all the nodes out of the bag and call the constructor on them.
    while ( NULL != ( pItem = m_pActionBag->GetFromBag() ) )
    {
        pAct = (CWTAction*)( pItem + sizeof(DWORD) );
        pAct->CWTAction::CWTAction(this);

        // insert into our temp list.
        InsertTailList( &tempList, (ListNode*)pAct );
    }

    // put all the nodes back in the bag.
    while ( !IsListEmpty( &tempList ) )
    {
        pItem = tempList.m_pNext;
        RemoveEntryList(pItem);
        pItem->m_pNext = pItem->m_pPrev = NULL;
        m_pActionBag->PutInBag( pItem );
    }

Exit:
    return hr;
}

//------------------------------------------------------------------
//  CleanActionNodes:  calls destructor for all action nodes in bag.
//------------------------------------------------------------------
HRESULT CWireTap::CleanActionNodes()
{
    HRESULT hr = S_OK;
    ListNode *pItem = NULL;

    // get all the nodes out of the bag and call the constructor on them.
    while ( NULL != ( pItem = m_pActionBag->GetFromBag() ) )
    {
        CWTAction* pAct = (CWTAction*)pItem;
        pAct->~CWTAction();

    }

    // destroy the aciton bag and its contents.
    delete m_pActionBag;
    
    return hr;
}

//------------------------------------------------------------------
//  ConstructUnWantedList:  constructs the listof unwanted tapped 
//          addresses..
//------------------------------------------------------------------
BOOL CWireTap::ConstructUnWantedList( char *szUnWantedList )
{
    char *szPos = szUnWantedList;
    DWORD dwCounter = 1;
        
    // while ',' is found
    while ( NULL != ( szPos = strchr( szPos, ',' ) ) )
    {
        dwCounter++;
        szPos++;
    }

    m_dwUnWantedListSize = dwCounter;
    m_pdwUnWantedList= (DWORD*)XAlloc( m_dwUnWantedListSize * sizeof(DWORD) );

    XOMASSERT( m_pdwUnWantedList );
    if ( m_pdwUnWantedList == NULL )
    {
        m_dwUnWantedListSize = 0;
        return FALSE;
    }

    szPos = szUnWantedList;
    dwCounter = 0;
    
    // while ',' is found
    while ( NULL != ( szPos = strchr( szPos, ',' ) ) )
    {
        char *szRev = szPos - 1;
        *szPos = '\0';
         
        while ( szRev != szUnWantedList && ( *szRev == ' ') )
        {
            *szRev = '\0';
            szRev--;
        }
        szPos++;
        while ( *szPos == ' ' ) 
        {
            *szPos = '\0';
            szPos++;
        }   

        // translate this add to DWORD IP
        (m_pdwUnWantedList)[dwCounter] = TranslateAddr(szPos);
        if ( (m_pdwUnWantedList)[dwCounter] == 0 )
        {
            // this isn't an IP... just continue and try more.
            continue;
        }
        
        dwCounter++;
    }

    m_pdwUnWantedList[dwCounter] = TranslateAddr(szUnWantedList);
    if ( (m_pdwUnWantedList)[dwCounter] != 0 )
    {
        dwCounter++;    
    }

    return TRUE;
}

//------------------------------------------------------------------
//  SubmitRequestToSGs:  submits request to SGs via xmgmt
//------------------------------------------------------------------
HRESULT CWireTap::SubmitRequestToSGs( BYTE* pbytRequest , DWORD dwReqSize )
{
    HRESULT hr = S_OK;
    HRESULT hrReq = S_OK;
    DWORD dwX = 0;
    BYTE pbytResp[256];
    DWORD dwAmtWritten = 0;

    for ( dwX = 0; dwX < m_dwSGListSize; dwX++ )
    {
        CXomAdminSession objAdminSession;
        ZeroMemory( pbytResp , sizeof(pbytRequest));

        // initialize the connection.
        hr = objAdminSession.Init( CW2CT(m_pszSGList[dwX]) );
        if ( FAILED(hr) )
        {
            // we failed but don't die... continue.
            XomNtEvent( XEVENT_XWIRETAP_SG_COMMUNICATION_FAILURE , "CWireTap::SubmitRequestToSGs:  Failed to initialize connection to SG-%s.  Result=0x%X", m_pszSGList[dwX], hr);
            XomTrace2( XWireTap, L_ERROR, "CWireTap::SubmitRequestToSGs:  Failed to initialize connection to SG-%s.  Result=0x%X", m_pszSGList[dwX], hr);

            continue;
        }

        // send the request.
        hr = objAdminSession.SendRequest( (LPCSTR)pbytRequest, (LPSTR)pbytResp, sizeof( pbytResp ), &dwAmtWritten, &hrReq);
        if ( FAILED(hr) )
        {
            XomNtEvent( XEVENT_XWIRETAP_SG_COMMUNICATION_FAILURE_1 , "CWireTap::SubmitRequestToSGs:  SendRequest failed with Result=0x%X.  Response=%s. Amount Written=%d", hr, pbytResp, dwAmtWritten);
            XomTrace3( XWireTap, L_ERROR, "CWireTap::SubmitRequestToSGs:  SendRequest failed with Result=0x%X.  Response=%s. Amount Written=%d", hr, pbytResp, dwAmtWritten);

            continue;
        }

        // ensrue the request hr        
        if (FAILED( hrReq ) )
        {
            XomNtEvent( XEVENT_XWIRETAP_SG_COMMUNICATION_FAILURE_2 , "CWireTap::SubmitRequestToSGs:  SendRequest Successful, however the request failed on the SG.  Response=%s. Amount Written=%d.  Result = 0x%X", pbytResp, dwAmtWritten, hr );
            XomTrace3( XWireTap, L_ERROR, "CWireTap::SubmitRequestToSGs:  SendRequest Successful, however the request failed on the SG.  Response=%s. Amount Written=%d.  Result = 0x%X", pbytResp, dwAmtWritten, hr );

            continue;
        }

        XomTrace2( XWireTap, L_LOW, "CWireTap::SubmitRequestToSGs:  SendRequest Successful.  Response=%s. Amount Written=%d.", pbytResp, dwAmtWritten );
        
    }

    return hr;
}

//-----------------------------------------------------------------------------
//  IncNumTaps:  Increments the number of Taps.
//-----------------------------------------------------------------------------
BOOL CWireTap::IncNumTaps()
{
    BOOL bRes = TRUE;
    EnterCriticalSection( &m_csNumOfTaps );

    // ensure we're not higher than we need to be.
    if ( m_dwNumOfTaps < m_dwMaxNumOfTaps )
    {
        m_dwNumOfTaps++;
    }
    else
    {
        bRes = FALSE;
    }
    
    LeaveCriticalSection( &m_csNumOfTaps );
    return bRes;
}

//-----------------------------------------------------------------------------
//  DecNumTaps:  decrements the number of taps
//-----------------------------------------------------------------------------
void CWireTap::DecNumTaps()
{
    EnterCriticalSection( &m_csNumOfTaps );
    if ( m_dwNumOfTaps != 0 )
    {
        m_dwNumOfTaps--;
    }
    LeaveCriticalSection( &m_csNumOfTaps );    
}

//-----------------------------------------------------------------------------
//  ReadLockTapList:  Sets the read lock on the tap list.
//-----------------------------------------------------------------------------
void CWireTap::ReadLockTapList()
{
    m_TapListLock.ReadLock();
}

//-----------------------------------------------------------------------------
//  WriteLockTapList:  Sets the write lock on the tap list.
//-----------------------------------------------------------------------------
void CWireTap::WriteLockTapList()
{
    m_TapListLock.WriteLock();    
}

//-----------------------------------------------------------------------------
//  ReadUnlockTapList:  releases a read lock on the tap list.
//-----------------------------------------------------------------------------
void CWireTap::ReadUnlockTapList()
{
    m_TapListLock.ReadUnlock();
}

//-----------------------------------------------------------------------------
//  WriteUnlockTapList:  releases a write lock on the tap list.
//-----------------------------------------------------------------------------
void CWireTap::WriteUnlockTapList()
{
    m_TapListLock.WriteUnlock();
}

//-----------------------------------------------------------------------------
//  RollTapCapFile:  Tells a tap to roll its capture file.
//-----------------------------------------------------------------------------
HRESULT CWireTap::RollTapCapFile( ULONGLONG qwTapId )
{
    HRESULT hr = S_OK;
    CTap *pTap = NULL;

    // get the tap.
    pTap = GetTap( qwTapId );
    if ( pTap == NULL )
    {
        XomNtEvent( XEVENT_XWIRETAP_TAP_CLOSE_ERROR_2, "CWireTap::RollTapCapFile:  Could not find the desire Tap with ID = 0x%I64X.", qwTapId );
        XomTrace1( XWireTap, L_ERROR, "CWireTap::RollTapCapFile:  Could not find the desire Tap with ID = 0x%I64X.", qwTapId );
        goto Exit;        
    }

    // signal the tap to clean up itself on its own thread.    
    hr = pTap->PostRollover();
    if ( FAILED(hr) )
    {
        XomNtEvent( XEVENT_XWIRETAP_TAP_CLOSE_ERROR_3, "CWireTap::RollTapCapFile:  Could not rollover the file for the desire Tap with ID = 0x%I64X.", qwTapId );
        XomTrace1( XWireTap, L_ERROR, "CWireTap::RollTapCapFile:  Could not rollover the file for the desire Tap with ID = 0x%I64X.", qwTapId );
        goto Exit;        
    }

Exit:
    return hr;    
}

//-----------------------------------------------------------------------------
//  IsUnWanted:  Checks if the given ip is unwatned by us.
//-----------------------------------------------------------------------------
HRESULT CWireTap::IsNotUnWanted( DWORD dwIP )
{
    HRESULT hr = S_OK;
    DWORD   dwX = 0;

    // don't capture packets to this place.
    for ( dwX = 0; dwX < m_dwUnWantedListSize; dwX++ )
    {
        if ( dwIP == m_pdwUnWantedList[dwX] )
        {
            // this packet shouldn't be seen.
            hr = E_FAIL;
            goto Exit;
        }
    }

Exit:
    return hr;
}

//-----------------------------------------------------------------------------
//  CleanReceiverNode:  Removes the receiver node of a given key.
//-----------------------------------------------------------------------------
HRESULT CWireTap::CleanReceiverNode( BYTE *pKey )
{
    return m_pReceiverList->Remove( pKey );
}

//-----------------------------------------------------------------------------
//  CleanReceiverNode:  Removes the receiver node of a given key.
//-----------------------------------------------------------------------------
CScheduler* CWireTap::GetSchedulerInstance()
{
    if ( m_pScheduler != NULL )
    {
        InterlockedIncrement( (LPLONG)&(m_dwSchedulerRefCnt ) );        
    }
    return m_pScheduler;
}

//-----------------------------------------------------------------------------
//  CleanReceiverNode:  Removes the receiver node of a given key.
//-----------------------------------------------------------------------------
void CWireTap::ReleaseSchedulerInstance()
{
    LONG lValue = 0;
    
    XOMASSERT( m_pScheduler != NULL);

    #pragma warning( disable : 4296 )
    XOMASSERT( m_dwSchedulerRefCnt >= 0 );
    #pragma warning( default : 4296 )

    lValue = InterlockedDecrement( (LPLONG)&(m_dwSchedulerRefCnt) );
    if ( lValue == 0 )
    {
        XomTrace0(XWireTap, L_WARNING, "CWireTap::ReleaseSchedulerInstance:  Scheduler Shutdown.");
        m_pScheduler->Shutdown();
        delete m_pScheduler;
        m_pScheduler = NULL;
    }
    else if ( lValue < 0 )
    {
        InterlockedExchange( (LPLONG)&m_dwSchedulerRefCnt, 0 );        
    }
}

//-----------------------------------------------------------------------------
//  GetStringSetting:  Loads a value from config interface.
//-----------------------------------------------------------------------------
void CWireTap::GetStringSetting( LPSTR pch, DWORD cch, Setting enumSetting, const char *c_szDefault )
{
    CComBSTR bstrSetting;
    HRESULT hr = S_OK;

    XOMASSERT( pch != NULL );
    XOMASSERT( cch > 0 );
    
    // get the setting
    hr = m_pConfig->GetSetting( enumSetting, &bstrSetting );
    if( FAILED(hr) || bstrSetting.m_str == NULL )
    {
        _snprintf( pch, cch, "%s\0", c_szDefault );
        XomTrace3( XWireTap, L_WARNING,  "CWireTap:(Config)  Enum: %d, Value (Default): %S.  Config set to default since no value could be attained from ConfigDB.  HRESULT=0x%X", enumSetting, pch, hr );
        XomNtEvent( XEVENT_TOOLS_CONFIG_64, "CWireTap:(Config)  Enum: %d, Value (Default): %S.  Config set to default since no value could be attained from ConfigDB.  HRESULT=0x%X", enumSetting, pch, hr );
    }
    else
    {
        // copy the setting into the static buffer.
        _snprintf( pch, cch, "%S\0", bstrSetting ); 
        XomTrace2( XWireTap, L_NORMAL,  "CWireTap:(Config)  Enum: %d, Value: %S.", enumSetting, pch );
    } 
 }

//-----------------------------------------------------------------------------
//  LoadSGSVCINTServers:  Gets all the SGSVC_INT interfaces
//-----------------------------------------------------------------------------
HRESULT CWireTap::LoadSGSVCINTServers()
{
    HRESULT hr = S_OK;
    BSTR* pbstr = NULL;
    SAFEARRAY* pArray = NULL;
    CComPtr<IInterfaceInfo> pInterfaceInfo;

    hr = m_pConfig->GetServerListByInterface( Interface_sgsvc_int, &pArray );
    if( FAILED( hr ) )
    {
        XomNtEvent( XEVENT_TOOLS_CONFIG_65, "CWireTap::LoadSGSVCINTServers() - GetServerListByInterface failed, hr=0x%08X", hr );
        goto lDone;
    }

    hr = SafeArrayAccessData( pArray, (void**) &pbstr );
    if( FAILED( hr ) )
    {
        XomNtEvent( XEVENT_TOOLS_CONFIG_66, "CWireTap::LoadSGSVCINTServers() - SafeArrayAccessData failed, hr=0x%08X", hr );
        goto lDone;
    }

    for( DWORD iServer = 0; iServer < pArray->rgsabound->cElements; iServer++ )
    {
        hr = m_pConfig->GetInterface(pbstr[iServer], Interface_sgsvc_int, &pInterfaceInfo);
        if (FAILED(hr))
        {
            XomNtEvent( XEVENT_TOOLS_CONFIG_67, "CWireTap::LoadSGSVCINTServers() - GetInterface failed, hr=0x%08X", hr );
            break;
        }

        hr = pInterfaceInfo->get_IPAddressString(&m_pszSGList[iServer]);
        if (FAILED(hr))
        {
            XomNtEvent( XEVENT_TOOLS_CONFIG_68, "CWireTap::LoadSGSVCINTServers() - get_IPAddressString failed, hr=0x%08X", hr );
            break;
        }
        m_dwSGListSize++;
    }

    SafeArrayUnaccessData( pArray );
    pbstr = NULL;

    SafeArrayDestroy( pArray );
    pArray = NULL;

lDone:
    if( NULL != pbstr )
    {
        SafeArrayUnaccessData( pArray );
        pbstr = NULL;
    }
    if( NULL != pArray )
    {
        SafeArrayDestroy( pArray );
        pArray = NULL;
    }

    return hr;
}

//-----------------------------------------------------------------------------
//  GetDWORDSetting:  Loads a dword value from config interface.
//-----------------------------------------------------------------------------
DWORD CWireTap::GetDWORDSetting( Setting enumSetting, DWORD dwDefault )
{
    HRESULT hr = S_OK;
    CComBSTR bstrSetting;
    DWORD dwValue = 0;

    // get the setting
    hr = m_pConfig->GetSetting( enumSetting, &bstrSetting );
    if( FAILED(hr) || bstrSetting.m_str == NULL )
    {
        dwValue = dwDefault;
        XomTrace3( XWireTap, L_WARNING,  "CWireTap:(Config)  Enum: %d, Value (Default): 0x%X.  Config set to default since no value could be attained from ConfigDB.  HRESULT=0x%X", enumSetting, dwValue, hr );
        XomNtEvent( XEVENT_TOOLS_CONFIG_69, "CWireTap:(Config)  Enum: %d, Value (Default): %X.  Config set to default since no value could be attained from ConfigDB.  HRESULT=0x%X", enumSetting, dwValue, hr );
    }
    else
    {
        // copy the setting into the static buffer.
        dwValue = _wtoi( bstrSetting );
        XomTrace2( XWireTap, L_LOW,  "CWireTap:(Config)  Enum: %d, Value: 0x%X.", enumSetting, dwValue );
    }

    return dwValue;    
}

//-----------------------------------------------------------------------------
//  CAuthSocketCallback Implementation
//-----------------------------------------------------------------------------
void CAuthSocketCallback::OnSocketReceive(
                        BYTE *pbFilledInBuffer,
                        DWORD cbRead,
                        HRESULT hr,
                        QWORD qwCallbackArg )
{
    HRESULT hrRes = S_OK;
    CWTAction* pAction = NULL;
    CWireTap*  pWireTap = NULL;
    PacketNode *pPacketNode = PACKETNODE_FROMBUFFER( pbFilledInBuffer );

    // get instance of the wiretap.
    pWireTap = CWireTap::GetInstance();

    XOMASSERT( pWireTap != NULL );

    XomTrace2( XWireTap, L_LOW, "CAuthSocketCallback::OnSocketReceive:  OnSocketReceive returned.  Size=%d  RESULT = 0x%X", cbRead, hr );
    
    // check the return result.
    if ( FAILED(hr) )
    {
        // TODO: (lohab) Post this receive again.
        pWireTap->ReleasePacketNode( pPacketNode );
        XomNtEvent( XEVENT_XWIRETAP_MEMORY_WARNING_39, "CAuthSocketCallback::OnSocketReceive:  Got FAILED hr from caller.  Receive failed.  RESULT = 0x%X", hr);
        XomTrace1( XWireTap, L_ERROR, "CAuthSocketCallback::OnSocketReceive:  Got FAILED hr from caller.  Receive failed.  RESULT = 0x%X", hr);
        hrRes = hr;
        goto Exit;
    }
        
    // get an action node
    pAction = pWireTap->GetAction();
    if ( pAction == NULL )
    {
        pWireTap->ReleasePacketNode( pPacketNode );
        XomNtEvent( XEVENT_XWIRETAP_MEMORY_WARNING_40, "CAuthSocketCallback::OnSocketReceive:  There are no more Action nodes.  Cannot send AuthData response to main processor.");
        XomTrace0( XWireTap, L_ERROR, "CAuthSocketCallback::OnSocketReceive:  There are no more Action nodes.  Cannot send AuthData response to main processor.");

        hrRes = E_OUTOFMEMORY;
        goto Exit;        
    }

    XomTrace2( XWireTap, L_LOW, "CAuthSocketCallback::OnSocketReceive:  Received a response for AUTHDATA.  Size=%d, Result=0x%X.", cbRead, hr );

    // set up the action
    pAction->Setup(  CWTAction::AUTHDATA, (LPBYTE)pPacketNode );
    
    // post the action to the completion port.
    hrRes = pWireTap->GetMasterCompletionPort()->PostCompletion( (CCompletionContext*) pAction, sizeof(CWTAction), NULL );
    if ( FAILED(hr) )
    {
        pWireTap->ReleasePacketNode( pPacketNode );
        XomNtEvent( XEVENT_TOOLS_CONFIG_70, "CServerSocketCallback::OnSocketReceive: Failed to post this authdata to the WireTap service.  TAP creation failed. :  RESULT = 0x%X.", hr);
        XomTrace1( XWireTap, L_ERROR, "CServerSocketCallback::OnSocketReceive: Failed to post this authdata to the WireTap service.  TAP creation failed. :  RESULT = 0x%X.", hr);

        pWireTap->ReleaseAction( pAction );
        goto Exit;        
    }
        
Exit:
    pWireTap->ReleaseInstance();
    //return hrRes;
}
                        
//-----------------------------------------------------------------------------
//  Local function implementations.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  GetXOMSetting:  Loads a value from mgmt interface.
//-----------------------------------------------------------------------------
void GetXOMSetting( char** pszValue, const char *c_szArea, const char *c_szDefault )
{
    CXomSetting *pSet = NULL;

    if(SUCCEEDED(g_xomcentral.GetSetting( c_szArea, &pSet)) && ( pSet != NULL ) )
    {
        *pszValue = (char*)pSet->GetStr();
        XomLog2(XWireTap, "CWireTap::LoadConfig: %s=%s", c_szArea, *pszValue );
    }
    else
    {
        XomLog2(XWireTap, "CWireTap::LoadConfig: Failed to attain a value for %s, using default of %s.", c_szArea, c_szDefault );
        *pszValue = (char*)c_szDefault;
    }
 }

//-----------------------------------------------------------------------------
//  GetXOMSetting:  Loads a value from mgmt interface.
//-----------------------------------------------------------------------------
void GetXOMSetting( DWORD* pdwValue, const char *c_szArea, DWORD dwDefault )
{
    CXomSetting *pSet = NULL;

    if(SUCCEEDED(g_xomcentral.GetSetting( c_szArea, &pSet)) && ( pSet != NULL ) )
    {
        *pdwValue = pSet->GetDw();
        XomLog2(XWireTap, "CWireTap::LoadConfig: %s=%d", c_szArea, *pdwValue );
    }
    else
    {
        XomLog2(XWireTap, "CWireTap::LoadConfig: Failed to attain a value for %s, using default of %d.", c_szArea, dwDefault );
        *pdwValue = dwDefault;
    }
 }

//------------------------------------------------------------------
// BuildSGInfoReq:  Builds the SG Info request
//------------------------------------------------------------------
void BuildSGInfoReq( CSgMsgSpiReq *pReq, DWORD dwReqNum, IN_ADDR ipaZ, WORD ipportZ )
{
    pReq->_wType = SGMSG_TYPE_SPIDATA_REQ;
    pReq->_cbEnt = sizeof(CSgMsgSpiReq);
    pReq->_dwReqNum = dwReqNum;
    memcpy( &(pReq->_ipaZ), &(ipaZ), sizeof( ipaZ ) );
    pReq->_ipportZ = ipportZ;
}

//------------------------------------------------------------------
// GetPacketIPPortForSrc:  Gets the port and IP for a given packet.
//------------------------------------------------------------------
void GetPacketIPPortForSrc( BYTE *pPacket, IN_ADDR* pIP, WORD *pPort )
{
    IP_HEADER* pIPHdr; 
    UDP_HEADER* pUDPHdr; 
    
    XOMASSERT( pPacket != NULL );
    XOMASSERT( pIP != NULL );
    XOMASSERT( pPort != NULL );

    pIPHdr = (IP_HEADER*)(pPacket+sizeof(CEnetHdr));
    pUDPHdr = (UDP_HEADER*)(pPacket+sizeof(CEnetHdr)+sizeof(IP_HEADER));
    memcpy( (void*)pIP, &(pIPHdr->src), sizeof(DWORD) );
    memcpy( (void*)pPort, &(pUDPHdr->wSrcPort), sizeof(WORD) );    
}

//------------------------------------------------------------------
// GetPacketIPPortForDest:  Gets the port and IP for a given packet.
//------------------------------------------------------------------
void GetPacketIPPortForDest( BYTE *pPacket, IN_ADDR* pIP, WORD *pPort )
{
    IP_HEADER* pIPHdr; 
    UDP_HEADER* pUDPHdr; 
    
    XOMASSERT( pPacket != NULL );
    XOMASSERT( pIP != NULL );
    XOMASSERT( pPort != NULL );

    pIPHdr = (IP_HEADER*)(pPacket+sizeof(CEnetHdr));
    pUDPHdr = (UDP_HEADER*)(pPacket+sizeof(CEnetHdr)+sizeof(IP_HEADER));
    memcpy( (void*)pIP, &(pIPHdr->dest), sizeof(DWORD) );
    memcpy( (void*)pPort, &(pUDPHdr->wDestPort), sizeof(WORD) );    
}

//------------------------------------------------------------------
// ConstructHashKey:  Gets the port and IP for a given packet.
//------------------------------------------------------------------
void ConstructHashKey( BYTE *pKey, DWORD dwIP  )
{
    XOMASSERT( pKey != NULL );

    ZeroMemory( pKey, HASH_KEY_SIZE );
    
    // get the key
    memcpy( pKey, (LPVOID)&(dwIP), sizeof(dwIP) );
}

//------------------------------------------------------------------
// StringToIp:  Converts a hex string to an unsigned int64 value.
//------------------------------------------------------------------
unsigned int StringToIp( char *szValue )
{
    DWORD dwStringSize;
    unsigned int nIp = 0;
    bool fLikeIp = true;
    int nOctets = 1;

    if (! szValue || szValue[0] == 0) 
    {
        goto Exit;
    }

    if (szValue[0] == '0' && (szValue[1] == 'x' || szValue[1] == 'X') && ((strlen(szValue) == 10) || (strchr(szValue, ':') - szValue == 10)))
    {
        char szT[9];
        strncpy(szT, szValue+2, 8);
        szT[min(8, strlen(szValue)-2)] = 0;
        // The IP is in Hex form
        nIp = (DWORD)QwordFromHexStr(szT);
        goto Exit;
    }

    dwStringSize = strlen(szValue);
    for (unsigned int i = 0; i < dwStringSize && szValue[i] != ':'; i++)
    {
        if(szValue[i] == '.')
        {
            nOctets++;
        }
        else if ((szValue[i] < '0' || szValue[i] > '9'))
        {
            fLikeIp = false;
            break;
        }
    }

    if (fLikeIp && nOctets == 4)
    {
        // The IP is in decimal dot form
        char *szIp = szValue;
        nIp = atoi(szIp);
        szIp = strchr(szIp, '.') + 1;
        nIp |= szIp ? atoi(szIp) << 8 : 0;
        szIp = strchr(szIp, '.') + 1;
        nIp |= szIp ? atoi(szIp) << 16 : 0;
        szIp = strchr(szIp, '.') + 1;
        nIp |= szIp ? atoi(szIp) << 24 : 0;
    }
    else
    {
        nIp = 0;
    }

Exit:
    return nIp;
}

//------------------------------------------------------------------
// BinToHex:  changes a Bin string into a hex string
//------------------------------------------------------------------
void BinToHex( char *szString, DWORD dwStringSize, char **szHexString )
{
    DWORD dwPos;
    *szHexString = new char[(dwStringSize * 2)+1];

    ZeroMemory( *szHexString, (dwStringSize * 2)+1 );
    
    // loop through the string
    for ( dwPos = 0; dwPos < dwStringSize; dwPos++ )
    {
        sprintf( (char*)((ULONGLONG)(*szHexString)+(dwPos*2)), "%2.2X", (BYTE)szString[dwPos] );
    }

    
}

//------------------------------------------------------------------
// BinToHex:  changes a Bin string into a hex string
//------------------------------------------------------------------
void HexToBin( char *szHexString, DWORD dwStringSize, BYTE **ppBinData )
{
    DWORD dwPos;
    int nSize = ((int)(dwStringSize/2));
    *ppBinData = new BYTE[nSize];

    ZeroMemory( *ppBinData, nSize );

    // loop through the string
    for ( dwPos = 0; dwPos < (DWORD)nSize; dwPos++ )
    {        
        int nVal = 0;
        char szPos[3];
        szPos[2] = '\0';
        szPos[0] = *((char*)(((ULONGLONG)(szHexString)) + (dwPos * 2)));
        szPos[1] = *((char*)(((ULONGLONG)(szHexString)) + (dwPos * 2) + 1));
        sscanf( szPos, "%hX", &nVal );
        (*ppBinData)[dwPos] = (BYTE)nVal;
    }

    
}

//------------------------------------------------------------------
// QwordFromHexStr:  Converts a hex string to an unsigned int64 value.
//------------------------------------------------------------------
unsigned __int64 QwordFromHexStr(char *sz)
{
    char *szHex = sz;
    unsigned __int64 qwResult = 0;

    // don't look at the prefix
    if (strstr(szHex, "0x") == szHex || strstr(szHex, "0X") == szHex)
    {
        szHex += 2;
    }

    // this is a 64 bit integer.
    sscanf(szHex, "%I64x", &qwResult );

    return qwResult;
}

//------------------------------------------------------------------
// TranslateAddr:  Takes a string and turns it into an inaddr
//------------------------------------------------------------------
DWORD TranslateAddr( char * sz )
{
    DWORD dwRes = 0;

    // see if this addr is just a.b.c.d form.
    dwRes = (DWORD)inet_addr(sz);
    if( 0 == dwRes || INADDR_NONE == dwRes )
    {
        // Hmmm, it's not in the IP format or it's an invalid IP. Let's 
        // assume that it is a hostname. Now we need to figure out its IP.

        hostent* pHost = gethostbyname(sz);

        if(NULL == pHost)
        {
            // oh well...  can't figure this out.
            dwRes = 0;
            goto Exit;
        }

        dwRes = ((in_addr*)pHost->h_addr_list[0])->s_addr;
    }
    
Exit:
    return dwRes;
}

//------------------------------------------------------------------
//  ConstructPath: recursively constructs all directories in a path.
//------------------------------------------------------------------
HRESULT ConstructPath( char *szPath, DWORD cPath )
{
    HRESULT hr = S_OK;
    DWORD cModPath = cPath - 1;
    DWORD dwRes = 0;
    char *sz = szPath + cModPath ;

    if ( cPath <= 1 )
    {
        hr = E_FAIL;
        goto Exit;
    }

    // try to create the path.  If failed go down one level and try to create.
    if ( ! CreateDirectoryA( szPath, NULL ) )
    {
        if ( GetLastError() != ERROR_ALREADY_EXISTS )
        {
            // determine the lower level.
            while ( *sz != '\\' && *sz != '/' )
            {
                cModPath--;
                sz--;
                if ( cModPath <= 1 )
                {
                    hr = E_FAIL;
                    goto Exit;
                }
            }
            *sz = '\0';

            // call again at a lower level.
            hr = ConstructPath( szPath, cModPath );
            if ( FAILED(hr) )
            {
                goto Exit;
            }

            // correct the modified string.
            *sz = '\\';
            
            // create again.
            if ( !CreateDirectoryA( szPath, NULL ) )
            {
                hr = MAKE_HRESULT( 1, FACILITY_WIN32, GetLastError());
                goto Exit;
            }
        }
    }

Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wiretap\Tap.cpp ===
//-----------------------------------------------------------------------------
//  Microsoft (R) XWireTap (tm). 
//  Copyright (C) 2002. All rights reserved.
//
//  FILE: Tap.cpp
//
//  Implementation of the CTap class.
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
//  Include
//-----------------------------------------------------------------------------
#include "stdafx.h"

//-----------------------------------------------------------------------------
//  Debugging Area
//-----------------------------------------------------------------------------
XomImportArea(XWireTap);

//-----------------------------------------------------------------------------
//  Types
//-----------------------------------------------------------------------------
typedef enum
{
    PACKET     = 1,
    CLOSE_FILE = 2,
    SHUTDOWN   = 3,
    INFO       = 4
} QUEUE_MESSAGE_TYPE;

//-----------------------------------------------------------------------------
//  Function pre-declarations
//-----------------------------------------------------------------------------
            
//-----------------------------------------------------------------------------
//  Definitions
//-----------------------------------------------------------------------------

#define MAX_TERMINATE_WAIT_TIME                 15000   /* 15 seconds wait time */

//-----------------------------------------------------------------------------
//  CTap Implementation
//-----------------------------------------------------------------------------
CTap::CTap( void )
{
    m_pCapFile = NULL;
    m_pServiceQueue = NULL;
    m_bIsComplete = FALSE;
    m_nTapType = NONE;
    m_dwTAPThreadId = 0;
    m_hTapThreadHandle = 0;
    ZeroMemory( &m_TapId, sizeof(m_TapId) );
    m_pWireTap = NULL;
}

CTap::~CTap(void)
{
    m_pCapFile = NULL;
    m_pServiceQueue = NULL;
    m_bIsComplete = FALSE;
    m_nTapType = NONE;
    m_dwTAPThreadId = 0;
    ZeroMemory( &m_TapId, sizeof(m_TapId) );
    m_pWireTap = NULL;
    CloseHandle(m_hTapThreadHandle);
    m_hTapThreadHandle = 0;
}

//-----------------------------------------------------------------------------
//  Initialize:  Initialize the tap.  Including building the queue and starting
//          the TAP's writer thread.
//-----------------------------------------------------------------------------
HRESULT CTap::Initialize( ULONGLONG qwID, DWORD dwQueueSize, DWORD dwMaxFileSize, TAP_TYPE nTapType, BYTE *pTapIdentifier, DWORD dwTapLife = INFINITE )
{
    HRESULT hr = S_OK;

    // must be clean or at least closed before doing this.
    XOMASSERT( m_pServiceQueue == NULL );
    XOMASSERT( m_pWireTap == NULL );
        
    XomTrace2( XWireTap, L_INFO, "CTap::Initialize:  Initializing TAP:  QueueSize=%d, TAP_TYPE=%d.", dwQueueSize, nTapType );

    m_pWireTap = CWireTap::GetInstance();
    if ( FAILED(hr) )
    {
        XomNtEvent( XEVENT_XWIRETAP_GENERIC_ERROR_8, "CTap::Initialize:  You cannot create a TAP without the wiretap interface.  Please initialize that first." );        
        XomTrace0( XWireTap, L_ERROR, "CTap::Initialize:  You cannot create a TAP without the wiretap interface.  Please initialize that first." );        
        hr = E_ABORT;
        goto Exit;
    }
    
    // identify the tap type
    hr = SetupAuthData( nTapType, pTapIdentifier );
    if ( FAILED(hr) )
    {
        XomNtEvent( XEVENT_XWIRETAP_GENERIC_ERROR_9, "CTap::Initialize:  The auth data type passed is incorrect.  If new types have been added then SetupAuthData must be modified to support these values." );        
        XomTrace0( XWireTap, L_ERROR, "CTap::Initialize:  The auth data type passed is incorrect.  If new types have been added then SetupAuthData must be modified to support these values." );        
        hr = E_INVALIDARG;
        goto Exit;
    }
            
    // create he queue
    m_pServiceQueue = new CProdConsBuffer();
    if ( m_pServiceQueue == NULL )
    {
        XomNtEvent( XEVENT_XWIRETAP_MEMORY_WARNING_22, "CTap::Initialize:  Failed to generate producer/consumer queue due to memory restrictions.   Please free memory on this box or close it down." );        
        XomTrace0( XWireTap, L_ERROR, "CTap::Initialize:  Failed to generate producer/consumer queue due to memory restrictions.   Please free memory on this box or close it down." );        
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = m_pServiceQueue->Initialize( dwQueueSize, dwTapLife );
    if ( FAILED(hr) )
    {
        XomNtEvent( XEVENT_XWIRETAP_MEMORY_WARNING_23, "CTap::Initialize:  Failed to initialize producer/consumer queue due to memory restrictions.   Please free memory on this box or close it down.  RESULT = 0x%X", hr );        
        XomTrace1( XWireTap, L_ERROR, "CTap::Initialize:  Failed to initialize producer/consumer queue due to memory restrictions.   Please free memory on this box or close it down.  RESULT = 0x%X", hr );        
        goto Exit;
    }

    // initialize the thread.
    hr = InitializeTAPThread();
    if (FAILED(hr) )
    {
        XomTrace1( XWireTap, L_ERROR, "CTap::Initialize:  Failed to initialize TAP thread.  RESULT = 0x%X", hr );        
        goto Exit;
    }

    m_dwMaxFileSize = dwMaxFileSize;
    memcpy( &m_TapId, &qwID, sizeof(m_TapId) );
    m_dwTapLife = dwTapLife;
    
    XomTrace0( XWireTap, L_INFO, "CTap::Initialize:  Tap Successfully Initialized." );
    
Exit:
    XomTrace1( XWireTap, L_LOW, "CTap::Initialize:  Complete with result = 0x%X.", hr);
    return hr;
}

//-----------------------------------------------------------------------------
//  Close:  Closes up this task.  Signals thread to shut down... then 
//      destroys queue.
//-----------------------------------------------------------------------------
HRESULT CTap::Close()
{
    HRESULT hr = S_OK;
    
    // do not call this from the main thread.  
    // signal the thread to die.  The thread should do the rest.    
    while ( TRUE )
    {
        hr = m_pServiceQueue->Put( NULL, SHUTDOWN );
        // if we get an E_FAIL we want to keep trying...  E_FAIL should be only if we can't get a new node... one has to be available soon.
        if ( hr == S_OK )
        {
            break;
        }
        else if ( hr != E_FAIL )
        {
            goto Exit;
        }
        Sleep(20);
    }

Exit:
    XomTrace1( XWireTap, L_LOW, "CTap::Complete:  Complete with result = 0x%X.", hr);

    return hr;
}

//-----------------------------------------------------------------------------
//  PostRollover:  Posts a file rollover message to the tap thread.
//-----------------------------------------------------------------------------
HRESULT CTap::PostRollover()
{
    HRESULT hr = S_OK;
    
    // do not call this from the main thread.  
    // signal the thread to die.  The thread should do the rest.    
    while ( TRUE )
    {
        hr = m_pServiceQueue->Put( NULL, CLOSE_FILE );
        // if we get an E_FAIL we want to keep trying...  E_FAIL should be only if we can't get a new node... one has to be available soon.
        if ( hr == S_OK )
        {
            break;
        }
        else if ( hr != E_FAIL )
        {
            goto Exit;
        }
        Sleep(20);
    }

Exit:
    XomTrace1( XWireTap, L_LOW, "CTap::PostRollover:  Complete with result = 0x%X.", hr);

    return hr;
}

//-----------------------------------------------------------------------------
//  PostPacket:  Puts a packet on the taps queue for processing.
//      NOTE:  a NULL packet will cause a file rollover.
//-----------------------------------------------------------------------------
HRESULT CTap::PostPacket( LPVOID pItem )
{
    HRESULT hr = S_OK;
    if ( pItem == NULL )
    {
        hr = m_pServiceQueue->Put( NULL, CLOSE_FILE );        
        if ( FAILED(hr) )
        {
            goto Exit;
        }
    }
    else
    {
        hr = m_pServiceQueue->Put( pItem, PACKET );        
        if ( FAILED(hr) )
        {
            goto Exit;
        }
    }

Exit:
    XomTrace1( XWireTap, L_LOW, "CTap::PostPacket:  Complete with result = 0x%X.", hr);
    return hr;
}


//-----------------------------------------------------------------------------
//  PostInfo:  Put auth data into queue where it will be sent to the 
//      appropriate file.
//-----------------------------------------------------------------------------
HRESULT CTap::PostInfo( LPVOID pItem )
{
    HRESULT hr = S_OK;
    if ( pItem == NULL )
    {
        hr = m_pServiceQueue->Put( NULL, CLOSE_FILE );        
        if ( FAILED(hr) )
        {
            goto Exit;
        }
    }
    else
    {
        hr = m_pServiceQueue->Put( pItem, INFO );        
        if ( FAILED(hr) )
        {
            goto Exit;
        }
    }

Exit:
    XomTrace1( XWireTap, L_LOW, "CTap::PostPacket:  Complete with result = 0x%X.", hr);
    return hr;
}

//-----------------------------------------------------------------------------
//  TAPThread:  the main entry point for the TAP thread.
//-----------------------------------------------------------------------------
DWORD WINAPI CTap::TAPThread( LPVOID pThis )
{
    CTap* pTap = (CTap*)pThis;

    // run the internal function.
    pTap->TAPThreadInternal();
    return 0;
}

//-----------------------------------------------------------------------------
//  InitializeTAPThread:  Creates the TAP thread.
//-----------------------------------------------------------------------------
HRESULT CTap::InitializeTAPThread()
{
    HRESULT hr = S_OK;

    // set the flag for managing the life of the TAP thread.
    m_bIsComplete = FALSE;
    
    // create and start admin ticket thread.  LOG IT
    if ( (m_hTapThreadHandle = CreateThread( NULL, NULL, TAPThread, this, 0, &m_dwTAPThreadId ) ) == NULL )
    {
        hr = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );

        XomNtEvent( XEVENT_XWIRETAP_MEMORY_WARNING_24, "CTap::InitializeTAPThread:  Failed to initialize the TAP thread.  RESULT = 0x%X", hr );        
        XomTrace1( XWireTap, L_ERROR, "CTap::InitializeTAPThread:  Failed to initialize the TAP thread.  RESULT = 0x%X", hr );
  
        goto Exit;
    }
    
    
Exit:
    XomTrace1( XWireTap, L_LOW, "CTap::InitializeTAPThread:  Complete with result = 0x%X.", hr);
    
    return hr;
}

//-----------------------------------------------------------------------------
//  TAPThreadInternal:  The main function of the TAP thread.
//-----------------------------------------------------------------------------
void CTap::TAPThreadInternal()
{
    char szFileName[512];
    char szPath[248];
    HRESULT hr = S_OK; 
    LPVOID  pItem = NULL;
    QUEUE_MESSAGE_TYPE  nMsgTyp;
    WORD wTapSeq = 0;
    BYTE pbytReq[64];
    DWORD dwSizeofReq = sizeof(pbytReq);
    CWireTap *pWireTap = NULL;
    DWORD dwProblematic = 0;
    TapId tapId;
    
    ZeroMemory( pbytReq, sizeof(pbytReq) );

    // keep a local copy for cleaning purposes.
    memcpy( &tapId, &m_TapId, sizeof(TapId) );

    pWireTap = CWireTap::GetInstance();
    XOMASSERT( pWireTap != NULL );
    
    while ( !m_bIsComplete && dwProblematic < pWireTap->GetMaxReTrys())
    {        
        // if the file pointer is NULL... create the new file.
        if ( m_pCapFile == NULL )
        {
            m_pCapFile = new CDynCaptureFile();

            ConstructFileNameFromTime( (char*)szFileName, ARRAY_ELEMENTS(szFileName), szPath, ARRAY_ELEMENTS(szPath), m_pWireTap->GetDumpDirectory(), ".cap" );

            // build the path
            hr = ConstructPath( szPath, strlen(szPath) );
            if ( FAILED(hr) )
            {
                XomNtEvent( XEVENT_XWIRETAP_CAP_FILE_CREATION_FAILED, "CTap::TAPThreadInternal: (ID:%I64X) Failed to create the path %s.  Please investigate.  Result=0x%X", *((ULONGLONG*)&m_TapId) , szPath, hr );        
                XomTrace3( XWireTap, L_WARNING, "CTap::TAPThreadInternal: (ID:%I64X) Failed to create the path %s.  Please investigate. Result=0x%X", *((ULONGLONG*)&m_TapId), szPath , hr);

                Sleep(100);
                dwProblematic++;
                continue;            
            }

            // open the file.
            hr = m_pCapFile->Open(szFileName, m_dwMaxFileSize );
            if ( FAILED(hr) )
            {
                // TODO:  (lohab)  Should I kill the TAP here... or just allow things to build...
                XomNtEvent( XEVENT_XWIRETAP_CAP_FILE_CREATION_FAILED_1, "CTap::TAPThreadInternal: (ID:%I64X) Failed to create CAP file.  Please investigate.  RESULT = 0x%X", *((ULONGLONG*)&m_TapId) , hr );        
                XomTrace2( XWireTap, L_ERROR, "CTap::TAPThreadInternal: (ID:%I64X) Failed to create CAP file.  Please investigate.  RESULT = 0x%X", *((ULONGLONG*)&m_TapId), hr );

                // TODO: (lohab)  This won't work... we need to notify the main program that this thread is complete.
                Sleep(100);
                dwProblematic++;
                continue;            
            }
        }

        // Get the next message out of the queue.
        hr = m_pServiceQueue->Get( &pItem, (DWORD*)&nMsgTyp );

        // check the return value.
        if ( FAILED(hr) )
        {
            // something serious must have happened...
            
            // close out the thread. 
            // nMsgTyp = SHUTDOWN;

            // We have to cleanup the lists that have this this tap in it before we signal shutdown.
            // This call will also call pTap->Close() which will also signal shutdown but we will be in process at this point
            hr = m_pWireTap->CloseTap(GetTapID());
            if ( FAILED(hr) )
            {
                XomNtEvent( XEVENT_TOOLS_CONFIG_58, "CTap::TAPThreadInternal: (ID:%I64X) Failed to close the tap.  Please investigate.  RESULT = 0x%X", *((ULONGLONG*)&m_TapId) , hr );        
                XomTrace2( XWireTap, L_ERROR, "CTap::TAPThreadInternal: (ID:%I64X) Failed to close the tap.  Please investigate.  RESULT = 0x%X", *((ULONGLONG*)&m_TapId), hr );
            }
            nMsgTyp = SHUTDOWN;

        }
        else if ( hr == S_FALSE )
        {
            // seems like we've just timed out  
            // TODO:  (lohab)  Should I post something here?  Some type of log out? Right now we'll just loop around
            // for now... just wait again...
            //nMsgTyp = SHUTDOWN;

            // We have to cleanup the lists that have this this tap in it before we signal shutdown.
            // This call will also call pTap->Close() which will signal shutdown.
            hr = m_pWireTap->CloseTap(GetTapID());
            if ( FAILED(hr) )
            {
                XomNtEvent( XEVENT_TOOLS_CONFIG_59, "CTap::TAPThreadInternal: (ID:%I64X) Failed to close the tap.  Please investigate.  RESULT = 0x%X", *((ULONGLONG*)&m_TapId) , hr );        
                XomTrace2( XWireTap, L_ERROR, "CTap::TAPThreadInternal: (ID:%I64X) Failed to close the tap.  Please investigate.  RESULT = 0x%X", *((ULONGLONG*)&m_TapId), hr );
            }
            nMsgTyp = SHUTDOWN;
        }

        // check the message type.
        switch( nMsgTyp )
        {
            case PACKET:
            {
                PacketNode *pPacketNode = (PacketNode*)pItem;
                
                // write this packet to the file.
                hr = m_pCapFile->SaveFrame( (BYTE*)&(pPacketNode->m_Frame) );
                if ( FAILED(hr) )
                {
                    XomNtEvent( XEVENT_XWIRETAP_CAP_FILE_WRITE_FAILED, "CTap::TAPThreadInternal: (ID:%I64X) Failed to create CAP file.  Please investigate.  RESULT = 0x%X", *((ULONGLONG*)&m_TapId), hr );        
                    XomTrace2( XWireTap, L_ERROR, "CTap::TAPThreadInternal: (ID:%I64X) Failed to create CAP file.  Please investigate.  RESULT = 0x%X", *((ULONGLONG*)&m_TapId), hr );
                }
                
                // reduce the ref counter on the packet node.
                m_pWireTap->ReleasePacketNode( pPacketNode );
                
            }
            break;
            case INFO:
            {
                // TODO:  (lohab)  Not really necessary but you may want to add a trace statement here.
                //hr = OutputTapAuthData( (BYTE*)pItem );
            }
            break;
            case CLOSE_FILE:
            {
                hr = m_pCapFile->Close();
                if ( FAILED(hr) )
                {                    
                    XomNtEvent( XEVENT_XWIRETAP_CAP_FILE_WRITE_FAILED_1, "CTap::TAPThreadInternal: (ID:%I64X) Failed to close CAP file.  The file will be in an invalid format, so please use proper tools to recover.  Please investigate reasons for failure.  RESULT = 0x%X", *((ULONGLONG*)&m_TapId), hr );        
                    XomTrace2( XWireTap, L_ERROR, "CTap::TAPThreadInternal: (ID:%I64X) Failed to close CAP file.  The file will be in an invalid format, so please use proper tools to recover.  Please investigate reasons for failure.  RESULT = 0x%X", *((ULONGLONG*)&m_TapId), hr );        
                }
                                
                delete m_pCapFile;
                m_pCapFile = NULL;
            }
            break;
            case SHUTDOWN:
            {
                hr = m_pCapFile->Close();
                if ( FAILED(hr) )
                {                    
                    XomNtEvent( XEVENT_XWIRETAP_CAP_FILE_WRITE_FAILED_2, "CTap::TAPThreadInternal: (ID:%I64X) Failed to close CAP file.  The file will be in an invalid format, so please use proper tools to recover.  Please investigate reasons for failure.  RESULT = 0x%X", *((ULONGLONG*)&m_TapId), hr );        
                    XomTrace2( XWireTap, L_ERROR, "CTap::TAPThreadInternal: (ID:%I64X) Failed to close CAP file.  The file will be in an invalid format, so please use proper tools to recover.  Please investigate reasons for failure.  RESULT = 0x%X", *((ULONGLONG*)&m_TapId), hr );        
                }
                                
                delete m_pCapFile;
                m_pCapFile = NULL;
                
                // clean up memory                
                m_bIsComplete = TRUE;

                // clean up memory
                ZeroMemory( &m_AuthData, sizeof(SGAuthData) );
                m_dwMaxFileSize = 0;

                m_nTapType = NONE;
                m_dwTAPThreadId = 0;
                ZeroMemory( &m_TapId, sizeof(m_TapId) );
                m_pWireTap = NULL;

                delete m_pServiceQueue;
                m_pServiceQueue = NULL;

                delete this;
    
            }
            break;
            default:
            {
                XOMASSERT( FALSE );
                // we don't knwo about this... it shouldn't happen.
            }
                    
        }
        
        dwProblematic = 0;
    }    

    // send the clean up message to the SG.
    // get the sequence number of this tap.  Its the last word of the id.
    wTapSeq = tapId.m_wId;  

    hr = CExprBlder::BuildCloseWireTap( pbytReq, &dwSizeofReq, wTapSeq);
    if ( FAILED(hr) )
    {
        XOMASSERT(FALSE);
        XomTrace2( XWireTap, L_ERROR, "CTap::TAPThreadInternal: (ID:%I64X) Failed to create TAP closure request.  Please notify the proper Dev of this problem.  RESULT = 0x%X", *((ULONGLONG*)&tapId), hr );
    }
    else
    {
        hr = pWireTap->SubmitRequestToSGs( pbytReq, dwSizeofReq );
        if ( FAILED(hr) )
        {
            XomTrace3( XWireTap, L_ERROR, "CTap::TAPThreadInternal: (ID:%I64X) Failed to submit request. Request=%s.  RESULT = 0x%X", *((ULONGLONG*)&tapId), (char*)pbytReq, hr );
        }
    }

    XomNtEvent( XEVENT_XWIRETAP_TAP_CLOSE, "(ID:%I64X) Tap is now complete.  The SGs have been signalled to no longer communicate this information.", *((ULONGLONG*)&tapId));        
    
    CWireTap::ReleaseInstance();
    
}
    
//-----------------------------------------------------------------------------
//  IsAssociated:  Checks for an associate between the given authdata and 
//          this tasks key.
//-----------------------------------------------------------------------------
BOOL CTap::IsAssociated( SGAuthData *pAuthData )
{
    BOOL bRes = TRUE;

    switch( m_nTapType )
    {
        case NONE:
        {
            bRes = FALSE;            
        }
        break;
        case MACHINE_ID:
        {
            bRes = (pAuthData->qwXboxID == m_AuthData.qwXboxID);
        }
        break;
        case USER_ID:
        {
            int nUser = 0;
            for ( nUser = 0; nUser < XONLINE_MAX_LOGON_USERS; nUser++ )
            {
                bRes = FALSE;
                if ( pAuthData->users[nUser].qwUserID == m_AuthData.users[0].qwUserID )
                {                    
                    bRes = TRUE;
                    break;
                }
            }
        }
        break;
        case SRC_IP:
        {
            // if the ipaddr matches for if this entry gets all traffic.
            bRes = (((*(DWORD*)&(pAuthData->_ipaI)) == (*(DWORD*)&(m_AuthData._ipaI)) ) || ((*(DWORD*)&(m_AuthData._ipaI)) == 0) );
        }
        break;
        default:
        {
            XOMASSERT(FALSE);
            bRes = FALSE;
        }
        break;        
    }
    
    return bRes;
}

//-----------------------------------------------------------------------------
//  SetupAuthData:  Sets auth data into structure.
//-----------------------------------------------------------------------------
HRESULT CTap::SetupAuthData( TAP_TYPE nTapType, BYTE *pTapId )
{
    HRESULT hr = S_OK;

    ZeroMemory( &m_AuthData, sizeof(SGAuthData) );
    m_nTapType = nTapType;

    switch( nTapType )
    {
        case MACHINE_ID:
        {
            m_AuthData.qwXboxID = *((ULONGLONG*)pTapId);
        }
        break;
        case USER_ID:
        {
            m_AuthData.users[0].qwUserID = *((ULONGLONG*)pTapId);
        }
        break;
        case SRC_IP:
        {
            memcpy( (LPVOID)&(m_AuthData._ipaI), (LPVOID)pTapId, sizeof( IN_ADDR ) );
        }
        break;
        case NONE:
        {
            ZeroMemory( &m_AuthData, sizeof(SGAuthData) );
        }
        break;
        default:
        {
            XOMASSERT( FALSE );
            // why did we get this... be sure to keep to known tap types.
            hr = E_INVALIDARG;
        }
    }

    return hr;
}


//-----------------------------------------------------------------------------
//  ConstructFileNameFromTime:  Constructs a file name from the system time.
//-----------------------------------------------------------------------------
void CTap::ConstructFileNameFromTime( char *szNewFileName, DWORD dwFileNameSize, char* szPath, DWORD dwPathSize, char *szDirectory, char *szExt )
{
    SYSTEMTIME stCur;

    // get the current time.
    GetSystemTime( &stCur );

    safe_snprintf( szPath, dwPathSize, "%s\\%I64X\0", 
        szDirectory,         
        *((ULONGLONG*)&m_TapId) );

    safe_snprintf( szNewFileName, dwFileNameSize, "%s\\%d%d%d%d%d%d%s\0", 
        szPath,
        stCur.wMonth, 
        stCur.wDay, 
        stCur.wHour, 
        stCur.wMinute, 
        stCur.wSecond, 
        stCur.wMilliseconds, 
        szExt);
    
}

//-----------------------------------------------------------------------------
//  GetTapAuthData:  Puts a copy of auth data into the given structure.
//-----------------------------------------------------------------------------
HRESULT CTap::GetTapAuthData( SGAuthData *pAuth )
{
    HRESULT hr = S_OK;

    XOMASSERT( pAuth != NULL );
    if ( pAuth == NULL )
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    memcpy( (LPVOID)pAuth, &m_AuthData, sizeof(m_AuthData) );
    
Exit:
    return hr;
}

//-----------------------------------------------------------------------------
//  OutputTapAuthData:  Writes auth data to a file.
//-----------------------------------------------------------------------------
HRESULT CTap::OutputTapAuthData( BYTE* pNode )
{
    HRESULT hr = S_OK;
    XKERB_AD_XENON* pAuthData = NULL;
    CSgMsgSpiRep* pResp = NULL;
    DWORD dwNumOfBytesToWrite = 0;
    DWORD dwBytesWritten = 0;

    XOMASSERT( pNode != NULL);

    PacketNode *pPacketNode = (PacketNode*)pNode;
    
    // extract the auth data information.
    pResp = (CSgMsgSpiRep*)(PACKETNODE_DATA_ADDR(pPacketNode));

    pAuthData = (XKERB_AD_XENON*)((pNode + sizeof(CSgMsgSpiRep) + sizeof(CSgMsgSpiData) + sizeof(CSgMsgHdr)), sizeof(XKERB_AD_XENON) );
    CSgMsgSpiData* pMsgData=(CSgMsgSpiData*)(pNode+sizeof(CSgMsgSpiRep));

    XomLog12( XWireTap, 
              "AuthData for TAP(0x%I64X)\r\n\n   FromIP=0x%X; \r\n   FromPort= 0x%hX; \r\n   SrcIP = 0x%X; \r\n   SrcPort = 0x%hX; \r\n   AuthData Version = 0x%hX \r\n   Client Version = 0x%I64X \r\n   Title ID = 0x%X \r\n   Title Version = 0x%X \r\n   Title Region = 0x%X \r\n   Xbox ID = 0x%I64X \r\n   NumServices = 0x%X \r\n",
              m_TapId,
              pResp->_ipaZ,
              pResp->_ipportZ,
              pMsgData->_ipaI,
              pMsgData->_ipportI,
              pAuthData->wAuthDataVersion,
              pAuthData->clientVersion,
              pAuthData->dwTitleID,
              pAuthData->dwTitleVersion,
              pAuthData->dwTitleRegion,
              pAuthData->qwXboxID,
              pAuthData->wNumDwordServices
            );


    m_pWireTap->ReleasePacketNode( pPacketNode );
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wiretap\WTAppointments.h ===
//-----------------------------------------------------------------------------
//  Microsoft (R) XWireTap (tm). 
//  Copyright (C) 2002. All rights reserved.
//
//  FILE: WTAppointments.h
//
//  Interface for the wiretap appointments.
//-----------------------------------------------------------------------------

#pragma once

//-----------------------------------------------------------------------------
// Includes
//-----------------------------------------------------------------------------
#include "sched.h"
#include "hashtable.h"
#include "WireTap.h"
#include "ReceiverList.h"

//-----------------------------------------------------------------------------
// Pre-Declarations
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Appointment callbacks
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// CSGRetryCallback
//-----------------------------------------------------------------------------
class CSGRetryCallback: public CSchedulerCallback
{
public:
    CSGRetryCallback( PacketNode *pPacketNode, BYTE* pKey, DWORD cKey );
    ~CSGRetryCallback();

    virtual ULONG AddRef() 
    { 
        return (ULONG) InterlockedIncrement(&m_lRefCount);
    }

    virtual ULONG Release() 
    {
        LONG lCount = InterlockedDecrement(&m_lRefCount);
        if(lCount == 0)
        {
            delete this;
        }
        return (ULONG) lCount;
    }
    
    virtual HRESULT OnAppointment(
        ULONGLONG qwCallbackArgument, 
        HAPPOINTMENT hAppointment
        );

    DWORD GetNoOfRetries()  { return m_dwNoOfRetries; }
protected:
    CWireTap*           m_pWireTap;
    BYTE                m_Key[HASH_KEY_SIZE];
    PacketNode*         m_pPacket;
    DWORD               m_dwNoOfRetries;
    LONG                m_lRefCount;        
};


//-----------------------------------------------------------------------------
// CActivityMonitor
//-----------------------------------------------------------------------------
class CActivityMonitor: public CSchedulerCallback
{
public: 
    CActivityMonitor( ReceiverListNode *pReceiverNode , CReceiverList* pReceiverList );
    ~CActivityMonitor();

    virtual ULONG AddRef() 
    { 
        return (ULONG) InterlockedIncrement(&m_lRefCount);
    }

    virtual ULONG Release() 
    {
        LONG lCount = InterlockedDecrement(&m_lRefCount);
        if(lCount == 0)
        {
            delete this;
        }
        return (ULONG) lCount;
    }
        
    virtual HRESULT OnAppointment(
        ULONGLONG qwCallbackArgument, 
        HAPPOINTMENT hAppointment
        );

protected:
    ReceiverListNode*   m_pReceiverNode;    
    CReceiverList*      m_pReceiverList;
    LONG                m_lRefCount;        
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wiretap\WTNicMgr.cpp ===
//-----------------------------------------------------------------------------
//  Microsoft (R) XWireTap (tm). 
//  Copyright (C) 2002. All rights reserved.
//
//  FILE: WTNicMgr.cpp
//
//  Implementation of the node bag.
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
//  Include
//-----------------------------------------------------------------------------
#include "StdAfx.h"

//-----------------------------------------------------------------------------
//  Log Area
//-----------------------------------------------------------------------------

//  TODO : Should I define a log area for here?
XomDefineArea(XWireTapNicMgr);

//-----------------------------------------------------------------------------
//  Static Declarations
//-----------------------------------------------------------------------------
CWTNicMgr* CWTNicMgr::m_pInstance = NULL;
DWORD CWTNicMgr::m_dwRefCount = 0;

//-----------------------------------------------------------------------------
//  CWTNicMgr Implementation
//-----------------------------------------------------------------------------
CWTNicMgr::CWTNicMgr(): m_pAttachList(NULL), m_cNicsCreated(0)
{
}

CWTNicMgr::~CWTNicMgr(void)
{
    if ( m_pAttachList != NULL )
    {
        Terminate();
    }
    
    m_cNicsCreated = 0;
    m_pAttachList = NULL;
    m_dwRefCount = 0;
}

//-----------------------------------------------------------------------------
//  GetInstance:  Gets an instance of the wiretap
//-----------------------------------------------------------------------------
CWTNicMgr* CWTNicMgr::GetInstance()
{
    if ( m_pInstance == NULL )
    {
        XOMASSERT( m_dwRefCount == 0 );
        m_pInstance = new CWTNicMgr();
        if ( m_pInstance == NULL )
        {
            // not enough memory to create wiretap instance.
            XomTrace0( XWireTapNicMgr, L_ERROR, "CWTNicMgr::GetInstance:  Failed to allocate instance memory.  Please ensure machine has enough available RAM to run this program");
            goto Exit;
        }
    }

    InterlockedIncrement( (LPLONG)&(m_pInstance->m_dwRefCount) );

Exit:
    return m_pInstance;
}

//-----------------------------------------------------------------------------
//  ReleaseInstance:  Releases the instance of the wiretap.
//-----------------------------------------------------------------------------
void CWTNicMgr::ReleaseInstance()
{
    LONG lValue = 0;
    XOMASSERT( m_pInstance != NULL && m_pInstance->m_dwRefCount > 0  );
    lValue = InterlockedDecrement( (LPLONG)&(m_pInstance->m_dwRefCount) );
    if ( lValue == 0 )
    {
        XomTrace0( XWireTapNicMgr, L_NORMAL, "CWTNicMgr::ReleaseInstance:  Releasing instance of WTNicMgr Wrapper.");
        delete m_pInstance;
        m_pInstance = NULL;
    }
}

//-----------------------------------------------------------------------------
//  Initialize:  setup up WTNicMgr and attachment list.
//-----------------------------------------------------------------------------
HRESULT CWTNicMgr::Initialize( DWORD dwNumOfNics )
{
    HRESULT hr = S_OK;

    m_pAttachList = new WTNicMgrNode[ dwNumOfNics ];
    if ( m_pAttachList == NULL )
    {
        XomTrace0( XWireTapNicMgr, L_ERROR, "CWTNicMgr::Initialize:  Not enough memory for list of NICs.");
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    ZeroMemory( m_pAttachList, sizeof( WTNicMgrNode ) * dwNumOfNics );
    
    // initialize WTNicMgr
    if (! VLanInit() )
    {
        XomTrace0( XWireTapNicMgr, L_ERROR, "CWTNicMgr::Initialize:  Failed to intialize Vlan.");
        hr = E_ABORT;        
        goto Exit;
    }

Exit:
    return hr;
}

//-----------------------------------------------------------------------------
//  Terminate:  cleans up vlan implementation.
//-----------------------------------------------------------------------------
HRESULT CWTNicMgr::Terminate()
{
    HRESULT hr = S_OK;
    DWORD dwX = 0;

    WriterLock();
    
    // go through the list and remove everything.
    for ( dwX = 0; dwX < m_cNicsCreated ; dwX ++ )
    {
        // TODO:  If we get a log area for here... we should log the failed detaches.
        if (! VLanDetach( (BYTE*)&(m_pAttachList[dwX]._ea) ) )
        {
            XomTrace8(  XWireTapNicMgr, 
                        L_ERROR, 
                        "CWTNicMgr::ReleaseInstance:  Failed to detach Nic id=%d, EA=%X%X%X%X%X%X, IP=0x%X", 
                        m_pAttachList[dwX]._dwId,
                        DWORD(m_pAttachList[dwX]._ea._ab[0]),
                        DWORD(m_pAttachList[dwX]._ea._ab[1]),
                        DWORD(m_pAttachList[dwX]._ea._ab[2]),
                        DWORD(m_pAttachList[dwX]._ea._ab[3]),
                        DWORD(m_pAttachList[dwX]._ea._ab[4]),
                        DWORD(m_pAttachList[dwX]._ea._ab[5]),
                        m_pAttachList[dwX]._dwIP
                     );            
        }
        m_pAttachList[dwX]._pSSock->Release();
    }

    delete m_pAttachList;
    m_pAttachList = NULL;
    m_cNicsCreated = 0;

    WriterUnlock();
    
    // call vlan terminate.
    VLanTerm();

    return hr;
}

//-----------------------------------------------------------------------------
//  Add:  Adds another nic to the WTNicMgr.
//-----------------------------------------------------------------------------
HRESULT CWTNicMgr::Add( char *szVlanMacAddr, DWORD dwIP, DWORD dwIPStart, DWORD dwIPEnd , DWORD *pdwId, CServerSocket* pSSock )
{
    HRESULT hr = S_OK;

    XOMASSERT( pdwId != NULL );
    XOMASSERT( szVlanMacAddr != NULL );

    WriterLock();
    
    // attach to Vlan...
    if ( ! VLanAttach( (char *)szVlanMacAddr, (BYTE*)&(m_pAttachList[m_cNicsCreated]._ea), &( m_pAttachList[m_cNicsCreated]._dwId ) ) )
    {
        XomTrace1( XWireTapNicMgr, L_ERROR, "CWTNicMgr::Add:  Failed to attach VLAN to %s.  Please ensure setting is correct.", szVlanMacAddr ); 
        hr = E_FAIL;        
        goto Exit;
    }

    // fill in the node
    m_pAttachList[m_cNicsCreated]._dwIP = dwIP;
    m_pAttachList[m_cNicsCreated]._dwIPStart = dwIPStart;
    m_pAttachList[m_cNicsCreated]._dwIPEnd = dwIPEnd;    
    m_pAttachList[m_cNicsCreated]._pSSock = pSSock;
    m_pAttachList[m_cNicsCreated]._dwId = m_cNicsCreated;
    *pdwId = m_cNicsCreated;
    
    XomTrace8( XWireTapNicMgr, L_LOW, "CWTNicMgr::Add:  Added new Vlan connection %s.  Ethernet Addr= %X-%X-%X-%X-%X-%X.  Id = %d", 
            szVlanMacAddr,
            m_pAttachList[m_cNicsCreated]._ea._ab[0],
            m_pAttachList[m_cNicsCreated]._ea._ab[1],
            m_pAttachList[m_cNicsCreated]._ea._ab[2],
            m_pAttachList[m_cNicsCreated]._ea._ab[3],
            m_pAttachList[m_cNicsCreated]._ea._ab[4],
            m_pAttachList[m_cNicsCreated]._ea._ab[5],
            *(&( m_pAttachList[m_cNicsCreated]._dwId ))
            ); 

    // inc the counter.
    m_cNicsCreated++;

Exit:
    WriterUnlock();
    return hr;
}

//-----------------------------------------------------------------------------
//  ManageARP:  Manages ARP connections
//-----------------------------------------------------------------------------
HRESULT CWTNicMgr::ManageARP( BYTE *pPacket, UINT cPacket, DWORD dwId )
{
    CArpMsg ArpMsg;
    CEnetHdr* pEHdr = (CEnetHdr*)pPacket;
    HRESULT hr = S_OK;
    DWORD dwIdx = dwId;

    //If this is an ARP packet, send an ARP reply
    if( cPacket < (sizeof(CArpMsg) + sizeof(CEnetHdr)))
    {
        XomTrace1( XWireTapNicMgr, L_ERROR, "CWTNicMgr::ManageARP:  Incoming ARP request has invalid size.  SIZE = %d", cPacket );
        hr = E_FAIL;
        goto Exit;
    }
 
    memcpy( &ArpMsg, pPacket + sizeof(CEnetHdr), sizeof(CArpMsg) );

    XomTrace3( XWireTapNicMgr, L_LOW, "CWTNicMgr::ManageARP:  Incoming ARP request For:0x%X on VLAN=%d (0x%X).  SIZE = %d", ArpMsg._ipaTarget, dwId, m_pAttachList[dwIdx]._dwIP );
    
    // Service the arp request if it is bound for this machine
    if (ArpMsg._wOp == ARP_OP_REQUEST && (DWORD)(ArpMsg._ipaTarget) == m_pAttachList[dwIdx]._dwIP )
    {
        // Swap the source and destination enet addresses
        CEnetAddr eaTemp = ArpMsg._eaTarget;

        pEHdr->_eaDst    = ArpMsg._eaSender;
        memcpy(pEHdr->_eaSrc._ab, &(m_pAttachList[dwIdx]._ea), sizeof(CEnetAddr));
        pEHdr->_wType    = ENET_TYPE_ARP;

        ArpMsg._wOp       = ARP_OP_REPLY;
        ArpMsg._eaTarget  = ArpMsg._eaSender;
        ArpMsg._ipaTarget = ArpMsg._ipaSender;
        ArpMsg._ipaSender = m_pAttachList[dwIdx]._dwIP; 
        memcpy(ArpMsg._eaSender._ab, &(m_pAttachList[dwIdx]._ea), sizeof(CEnetAddr));

        // Copy the redefined ethernet header and ARP header into pb
        memcpy( pPacket, pEHdr, sizeof(CEnetHdr) );
        memcpy( pPacket + sizeof(CEnetHdr), &ArpMsg, sizeof(CArpMsg) );

        // Transmit the reply.
        hr = Transmit( pPacket, cPacket );
        if( !FAILED(hr) )
        {
            XomTrace0( XWireTapNicMgr, L_INFO, "ManageARP:  ARP process request successful." );
        }
        else
        {
            XomTrace0( XWireTapNicMgr, L_WARNING, "ManageARP:  ARP process request failed." );
        }
    }

Exit:
    return hr;
}

//-----------------------------------------------------------------------------
//  Transmit:  Does the Vlan transmit.
//-----------------------------------------------------------------------------
HRESULT CWTNicMgr::Transmit( BYTE *pPacket, DWORD cPacket )
{
    HRESULT hr = S_OK;
    if ( m_pAttachList == NULL )
    {
        XomTrace0( XWireTapNicMgr, L_ERROR, "CWTNicMgr::Transmit:  Trying to transmit without any attached Nics.");
        hr = E_NOINTERFACE;
        goto Exit;
    }

    // send the packet through VLAN.
    if ( ! VLanXmit( pPacket, cPacket) )
    {
        XomTrace0( XWireTapNicMgr, L_ERROR, "CWTNicMgr::Transmit:  Failed to transmit packet.");
        hr = E_FAIL;
        goto Exit;
    }
    
Exit:
    return hr;
}

//-----------------------------------------------------------------------------
//  GetIndexNumber:  Retrieves an index number from the given arg.
//          returns -1 if that's not possible.
//-----------------------------------------------------------------------------
DWORD CWTNicMgr::GetIndexNumber( void* pvArg )
{
    DWORD dwRes = -1;

    if ( m_pAttachList == NULL || m_cNicsCreated < 1 )
    {
        goto Exit;
    }
    
    dwRes = ((WTNicMgrNode*)pvArg)->_dwId;
Exit:
    return dwRes;
}

//-----------------------------------------------------------------------------
//  GetIndexNumber:  Retrieves an index number from the given arg.
//          returns -1 if that's not possible.
//-----------------------------------------------------------------------------
CServerSocket* CWTNicMgr::GetServerSock( DWORD dwId )
{
    CServerSocket *pRes = NULL;

    if ( m_pAttachList == NULL || m_cNicsCreated < 1 || dwId > m_cNicsCreated )
    {
        goto Exit;
    }

    pRes = m_pAttachList[dwId]._pSSock;
Exit:
    return pRes;
}

//-----------------------------------------------------------------------------
//  IsInSGRange:  Determines if the given IP is inbetween the start and end
//          of this NICS expected SG IP range.  
//              -1 from src
//              0 not from either
//              1 from dst
//-----------------------------------------------------------------------------
int CWTNicMgr::IsInSGRange( DWORD dwId, DWORD dwSrcAddr, DWORD dwDstAddr )
{
    int nRes = -1;
    
    // make sure this has something to do with the SGs.
    if ( NTOHL(dwSrcAddr) < NTOHL( m_pAttachList[dwId]._dwIPStart) || NTOHL(dwSrcAddr) > NTOHL(m_pAttachList[dwId]._dwIPEnd) )
    {
        nRes = 1;
        if ( NTOHL(dwDstAddr) < NTOHL( m_pAttachList[dwId]._dwIPStart ) || NTOHL(dwDstAddr) > NTOHL(m_pAttachList[dwId]._dwIPEnd) )
        {
            // hmm... why did we get this... it has nothing to do with the SG... toss it on the floor.
            nRes = 0;
            goto Exit;
        }
        
    }

Exit:
    return nRes;
}

//-----------------------------------------------------------------------------
//  VLAN Implementation
//-----------------------------------------------------------------------------
//------------------------------------------------------------------
//  VLanRecv:  Implementation of VLan receive.
//------------------------------------------------------------------
void __stdcall VLanRecv(BYTE * pb, UINT cb, void * pvArg)
{
    CEnetHdr* pEnetHdr;
    BYTE* pHdr = pb;
    UINT uiType;
    DWORD dwId = 0;
    CWireTap *pTap = CWireTap::GetInstance();
    CWTNicMgr *pNicMgr = CWTNicMgr::GetInstance();
    HRESULT hr = S_OK;

    XOMASSERT( pTap != NULL );
    
    // NOTE: This code was borrowed from the SG.
    //
    // Process the Ethernet header
    //

    pNicMgr->ReaderLock();

    dwId = pNicMgr->GetIndexNumber( pvArg );
    if ( dwId == -1 )
    {
        XomTrace0(XWireTapNicMgr, L_LOW, "VLanRecv:  The Nic Manager is not initialized.  Throwing packet away." );
        goto Exit;
    }
    
    pEnetHdr = (CEnetHdr *)pb;
    if (cb < sizeof(CEnetHdr))
    {
        // make info traces... this isn't important enough for an error log.
        XomTrace2(XWireTapNicMgr, L_LOW, "VLanRecv:  Frame (%d bytes) is smaller than CEnetHdr (%d bytes).", cb, sizeof(CEnetHdr) );
        goto Exit;
    }

    // get the header type
    uiType = pEnetHdr->_wType;

    if (NTOHS((USHORT)uiType) <= ENET_DATA_MAXSIZE)
    {
        CIeeeHdr * pIeeeHdr = (CIeeeHdr *)pEnetHdr;
        
        if (cb < sizeof(CIeeeHdr))
        {
            // make info traces... this isn't important enough for an error log.
            XomTrace2(XWireTapNicMgr, L_LOW, "VLanRecv:  Frame (%d bytes) is smaller than CIeeeHdr (%d bytes).", cb, sizeof(CEnetHdr) );
            goto Exit;
        }

        if (!pIeeeHdr->IsEnetFrame())
        {
            char *szHex = NULL;
            BinToHex( (char*)pIeeeHdr, sizeof(CIeeeHdr), &szHex );
            XomTrace1(XWireTapNicMgr, L_LOW, "VLanRecv:  Frame has unrecognized ethernet header (%s).", szHex);
            goto Exit;
        }

        // Update the frame type from the IEEE header
        uiType = pIeeeHdr->_wTypeIeee;

    }

    // look at the MAC addrs on the packet.
    XomTrace15(XWireTapNicMgr, L_LOW, "VLanRecv:  Packet From:  %.2X-%.2X-%.2X-%.2X-%.2X-%.2X   To: %.2X-%.2X-%.2X-%.2X-%.2X-%.2X.  Type = %d  Id = %d Size = %d",
                                pEnetHdr->_eaSrc._ab[0],
                                pEnetHdr->_eaSrc._ab[1],
                                pEnetHdr->_eaSrc._ab[2],
                                pEnetHdr->_eaSrc._ab[3],
                                pEnetHdr->_eaSrc._ab[4],
                                pEnetHdr->_eaSrc._ab[5],
                                pEnetHdr->_eaDst._ab[0],
                                pEnetHdr->_eaDst._ab[1],
                                pEnetHdr->_eaDst._ab[2],
                                pEnetHdr->_eaDst._ab[3],
                                pEnetHdr->_eaDst._ab[4],
                                pEnetHdr->_eaDst._ab[5],
                                pEnetHdr->_wType,
                                dwId,
                                cb
            );
    
    
    // Determine the type of the packet that we received.
    switch( pEnetHdr->_wType )
    {
    case ENET_TYPE_ARP:
        {
            CArpMsg *parpMsg = (CArpMsg*)(pb + sizeof(CEnetHdr));

            // ensure this a an arp request.
            if ( parpMsg->_wHrd == ARP_HWTYPE_ENET 
                &&  parpMsg->_wPro == ENET_TYPE_IP
                &&  parpMsg->_bHln == sizeof(CEnetAddr)
                &&  parpMsg->_bPln == sizeof(CIpAddr)
                &&  parpMsg->_wOp  == ARP_OP_REQUEST  )
            {
                XomTrace0(XWireTapNicMgr, L_LOW, "VLanRecv:  Got an ARP request." );
        
                // manage the ARP request.
                pNicMgr->ManageARP( pb, cb, dwId );

                break;
            }

            // otherwise, handle like an other packet.
        } 

    case ENET_TYPE_IP:
        {
            IP_HEADER *pIPHdr = (IP_HEADER*)(pb + sizeof(CEnetHdr));

            // alrighty... we like this guy... let's get him into our buffer and post to the completion port
            hr = pTap->QueuePacket( pb, cb , dwId );
            if ( FAILED(hr) )
            {
                XomNtEvent( XEVENT_XWIRETAP_INVALID_SETTING_1, "VLanRecv:  Failed to save packet.  0x%X", hr );        
                XomTrace1( XWireTapNicMgr, L_ERROR, "VLanRecv:  Failed to save packet.  0x%X", hr );        
                goto Exit;
            }
        } 
        break;
    default:
        {
            // TODO:  (lohab) Do I want to log this?  
            XomTrace1( XWireTapNicMgr, L_ERROR, "VLanRecv:  Received unknown Ethernet hearder type 0x%X.  Is this expected?  Please investivate.", pEnetHdr->_wType );

            // alrighty... we like this guy... let's get him into our buffer and post to the completion port
            hr = pTap->QueuePacket( pb, cb, dwId );
            if ( FAILED(hr) )
            {
                XomNtEvent( XEVENT_XWIRETAP_INVALID_SETTING_2, "VLanRecv:  Failed to save packet.  0x%X", hr );        
                XomTrace1( XWireTapNicMgr, L_ERROR, "VLanRecv:  Failed to save packet.  0x%X", hr );        
                goto Exit;
            }
        }
    }

Exit:
    pNicMgr->ReaderUnlock();
    CWireTap::ReleaseInstance();
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\bvt-ext\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wiretap\WTNicMgr.h ===
//-----------------------------------------------------------------------------
//  Microsoft (R) XWireTap (tm). 
//  Copyright (C) 2002. All rights reserved.
//
//  FILE: WTNicMgr.h
//
//  Interface WTNicMgr wrapper Implementation.
//-----------------------------------------------------------------------------

#pragma once

//-----------------------------------------------------------------------------
// Includes
//-----------------------------------------------------------------------------
#include <XAlloc.h>
#include "netstructs.h"
#include "xlocks.h"

//-----------------------------------------------------------------------------
// Pre-declarations
//-----------------------------------------------------------------------------
class CServerSocket;

//-----------------------------------------------------------------------------
// Structs/Types
//-----------------------------------------------------------------------------
typedef struct _WTNicMgrNode
{
    DWORD           _dwId;
    DWORD           _dwIP;
    DWORD           _dwIPStart;
    DWORD           _dwIPEnd;
    CServerSocket*  _pSSock;
    
    CEnetAddr       _ea;
} WTNicMgrNode;

//-----------------------------------------------------------------------------
// CWTNicMgr
//-----------------------------------------------------------------------------

class CWTNicMgr
{
public:
    static CWTNicMgr*   GetInstance();    
    static void         ReleaseInstance();

    // call before using.
    HRESULT             Initialize( DWORD dwNumOfNics );

    // cleans up implementation.
    HRESULT             Terminate( );

    // adds NICS for WTNicMgr to attach too.
    HRESULT             Add( char *szVlanMacAddr, DWORD dwIP, DWORD dwIPStart, DWORD dwIPEnd, DWORD *pdwId, CServerSocket* pSSock);

    HRESULT             ManageARP( BYTE *pPacket, UINT cPacket, DWORD dwId );

    HRESULT             Transmit( BYTE *pPacket, DWORD cPacket );

    DWORD               GetIndexNumber( void* pvArg );
    CServerSocket*      GetServerSock( DWORD dwId );

    BOOL                IsInSGRange( DWORD dwId, DWORD dwSrcAddr, DWORD dwDstAddr );

    DWORD               GetNumOfNics() { return m_cNicsCreated; }

    // lock functions
    void                ReaderLock() { m_rwlAttachList.ReadLock(); }
    void                ReaderUnlock() { m_rwlAttachList.ReadUnlock(); }
    
    // overrides
    void *operator      new(size_t len) { return XAlloc(len); }
    void operator       delete(void *pv) { XFree(pv); }

protected:
    CWTNicMgr( );
    virtual ~CWTNicMgr(void);

    void                WriterLock() { m_rwlAttachList.WriteLock(); }
    void                WriterUnlock() { m_rwlAttachList.WriteUnlock(); }

    CReaderWriterLock3  m_rwlAttachList;
    WTNicMgrNode*       m_pAttachList;
    
    DWORD               m_cNicsCreated;
    
private:
    static CWTNicMgr*   m_pInstance;
    static DWORD        m_dwRefCount;
    
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wiretap\xwiretap.cpp ===
// Xwiretap.cpp : Defines the entry point for the console application.
//

//-----------------------------------------------------------------------------
//  Includes
//-----------------------------------------------------------------------------
#include "stdafx.h"

//-----------------------------------------------------------------------------
//  Logging Area
//-----------------------------------------------------------------------------
XomImportArea(XWireTap);

//-----------------------------------------------------------------------------
//  Local Functions
//-----------------------------------------------------------------------------
void BinToHex( char *szString, DWORD dwStringSize, char **szHexString );
void HexToBin( char *szHexString, DWORD dwStringSize, BYTE **ppBinData );
BOOL StringToTime( const char *szTimeStr, DWORD *pdwHours, DWORD *pdwMinutess, DWORD *pdwSeconds );

//-----------------------------------------------------------------------------
//  GLOBAL VARIABLES
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  CONSTANTS
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  IMPLEMENTATION
//-----------------------------------------------------------------------------

int __cdecl wmain(int argc, wchar_t *argv[])
{
    HRESULT hr = S_OK;
    DWORD dwErr = ERROR_SUCCESS;
    CWireTap* pWireTap = NULL;

    // attach the debugging information.
    hr = g_xomcentral.Init( "XWireTap", "xwiretap.ini" );
    if ( FAILED( hr ) )
    {
        XomNtEvent( XEVENT_XWIRETAP_INIT_FAIL_6, "Failed to initialize the xom stuff. 0x%X", hr);
        return 1;
    }

    pWireTap = CWireTap::GetInstance();

    dwErr = pWireTap->ProcessMain( (DWORD)argc, argv );
    if ( ERROR_SUCCESS != dwErr )
    {
        XomNtEvent( XEVENT_XWIRETAP_INIT_FAIL_7, "Failed to start properly. 0x%X", dwErr);
        return 1;
    }
    
    CWireTap::ReleaseInstance();
    
    // terminate the logging and debugging.
    g_xomcentral.Term();
    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\bvt-ext\BVTExtension.cs ===
using System;
using System.Collections.Generic;
using System.Text;

namespace xonline.tools.lsmonitor.bvt.extension {
   public class BVTExtension {
      public BVTExtension() { }

      public int GetInt(int p) { return p; }
      public string GetString(string p) { return p; }
      public void Exception() { throw new Exception("BVTExtension Exception"); }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\bvt-ext\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\bvt-ext\BVTAspect.cs ===
namespace xonline.tools.lsmonitor.bvt.extension {
   #region Using Directives
   using System;
   using System.Collections.Generic;
   using System.Text;

   using WSMonitor.Framework.Scripting;
   using WSMonitor.Framework.Reporting;

   using System.Runtime.Remoting.Messaging;
   #endregion

   class BVTAspect : Aspect {
      public BVTAspect(IMessageSink next) : base(next) { }

      public override void Enter(Report report, IMethodMessage msg) {
         report.Properties.Add("BVTAspect", "Visited");
      }

      public override void Leave(Report report, IMethodReturnMessage result) {
         
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\bvt-ext\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\bvt-ext\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_bvt-ext_none_12.4.56.0_none_42f66d1f3f486a8f
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_bvt-ext_no-public-key_12.4.56.0_x-ww_49263657
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=bvt-ext
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_bvt-ext_no-public-key_12.4.56.0_x-ww_49263657
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_bvt-ext_no-public-key_12.4.56.0_x-ww_49263657.manifest
XP_MANIFEST_PATH=manifests\msil_bvt-ext_no-public-key_12.4.56.0_x-ww_49263657.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_bvt-ext_no-public-key_12.4.56.0_x-ww_49263657.cat
XP_CATALOG_PATH=manifests\msil_bvt-ext_no-public-key_12.4.56.0_x-ww_49263657.cat
XP_PAYLOAD_PATH=msil_bvt-ext_no-public-key_12.4.56.0_x-ww_49263657
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=bvt-ext,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\common\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\bvt-ext\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_bvt-ext_none_12.4.56.0_none_42f66d1f3f486a8f
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_bvt-ext_no-public-key_12.4.56.0_x-ww_49263657
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=bvt-ext
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_bvt-ext_no-public-key_12.4.56.0_x-ww_49263657
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_bvt-ext_no-public-key_12.4.56.0_x-ww_49263657.manifest
XP_MANIFEST_PATH=manifests\msil_bvt-ext_no-public-key_12.4.56.0_x-ww_49263657.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_bvt-ext_no-public-key_12.4.56.0_x-ww_49263657.cat
XP_CATALOG_PATH=manifests\msil_bvt-ext_no-public-key_12.4.56.0_x-ww_49263657.cat
XP_PAYLOAD_PATH=msil_bvt-ext_no-public-key_12.4.56.0_x-ww_49263657
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=bvt-ext,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\common\Control.Result.cs ===
using System;
using System.Collections.Generic;
using System.Reflection;
using System.Text;

using System.Xml;
using System.Xml.XPath;
using System.Data.SqlTypes;

namespace WSMCommon.Control.Result {
   public class XmlParser {
      public XmlParser(XPathNavigator nav) {
         this.navigator = nav;
      }

      public XmlParser(XmlReader reader) {
         XmlDocument Doc = new XmlDocument();
         Doc.Load(reader);
         this.navigator = Doc.CreateNavigator();
      }

      public XmlParser(SqlXml result) : this(result.CreateReader()) { }

      public XmlParser() : this((XPathNavigator)null) { }

      public XPathNavigator Navigator {
         get { return navigator; }
         set { navigator = value; }
      }

      public T Read<T>(string xpath, T _default) {
         return _default;
      }

      public T[] ReadAll<T>(string xpath) {
         List<T> Results = new List<T>();

         if (null != navigator) {
            XPathNodeIterator Itor;
            Itor = navigator.Select(xpath);
            while (Itor.MoveNext())
               Results.Add((T)Convert.ChangeType(Itor.Current.Value, typeof(T)));
         }

         return Results.ToArray();
      }

      public bool TryRead<T>(string xpath, out T result) {
         XPathNodeIterator I;

         if ((null != navigator) && (I = navigator.Select(xpath)).MoveNext()) {
            try {
               result = (T)Convert.ChangeType(I.Current.Value, typeof(T));
               return true;
            }
            catch (InvalidCastException) { }
         }

         result = default(T);

         return false;
      }

      public T Read<T>(string xpath) {
         T result;

         if (TryRead<T>(xpath, out result))
            return result;

         throw new XmlParserException("Unable to read path: " + xpath);
      }

      private XPathNavigator navigator;
   }

   public class XmlParserException : Exception {
      public XmlParserException(string message, string config, Exception inner)
         : base(message, inner) {
         this.config = config;
      }
      public XmlParserException(string message) : this(message, null, null) { }
      public XmlParserException(string message, string config) : this(message, config, null) { }
      public XmlParserException(string message, Exception inner) : this(message, null, inner) { }
      public XmlParserException(Exception inner) : this(null, null, inner) { }
      public XmlParserException() : this(null, null, null) { }

      public override string Message {
         get {
            string message = string.IsNullOrEmpty(base.Message) ? "" : base.Message;
            return string.Format("Invalid configuration: {0}.\r\n{1}",
               string.IsNullOrEmpty(config) ? "(Unspecified)" : config,
               message);
         }
      }

      public string ConfigurationSetting {
         get { return string.IsNullOrEmpty(config) ? config : ""; }
         set { config = value; }
      }

      private string config;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\common\Control.cs ===
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Data.SqlTypes;
using System.Reflection;

namespace WSMCommon.Control {

   public class SqlColumnAttribute : Attribute {
      public SqlColumnAttribute(string name) {
         this.name = name;
      }

      public string Name { get { return string.IsNullOrEmpty(name) ? "" : name; } }
      
      public Type Converter { 
         get { return this.converter; }
         set { this.converter = value; } 
      }

      private string name;
      private Type converter;
   }

   internal partial class InformationBuilder {
      private static SqlXml GetSqlXml(IDataRecord record, int ordinal) {
         SqlXml xml;

         if (record.IsDBNull(ordinal))
            return xml = SqlXml.Null;
         else {
            using (System.IO.StringReader Reader = new System.IO.StringReader(record.GetString(ordinal)))
               using (System.Xml.XmlTextReader XReader = new System.Xml.XmlTextReader(Reader))
                  xml = new SqlXml(XReader);
         }

         return xml;
      }

      public static T PopulateObject<T>(IDataRecord reader) where T : struct {
         return (T)PopulateObject(default(T), reader);
      }

      public static object PopulateObject(object info, IDataRecord reader) {
         if (null == info) throw new ArgumentNullException("info");
         if (null == reader) throw new ArgumentNullException("reader");

         FieldInfo[] Fields = info.GetType().GetFields(
            BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
         PropertyInfo[] Properties = info.GetType().GetProperties(
            BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);

         foreach (FieldInfo Field in Fields) {
            SqlColumnAttribute[] Attribs = (SqlColumnAttribute[])Field.GetCustomAttributes(typeof(SqlColumnAttribute), true);
            if (null != Attribs && Attribs.Length > 0)
               Field.SetValue(info, reader.GetValue(reader.GetOrdinal(Attribs[0].Name)));
         }

         foreach (PropertyInfo Property in Properties) {
            SqlColumnAttribute[] Attribs = (SqlColumnAttribute[])Property.GetCustomAttributes(typeof(SqlColumnAttribute), true);
            if (null != Attribs && Attribs.Length > 0) {
               int ord = reader.GetOrdinal(Attribs[0].Name);

               if (!reader.IsDBNull(ord)) {
                  if (Property.PropertyType == typeof(SqlXml))
                     Property.SetValue(
                        info,
                        GetSqlXml(reader, ord),
                        null);
                  else
                     Property.SetValue(
                         info,
                         reader.GetValue(ord),
                         null);
               }
            }
         }

         return info;
      }
   }

   /// <summary>Holds properties assoicated with an aspect.</summary>
   [Serializable]
   public struct AspectInformation {
      /// <summary>Initializes new instance of <typeparamref name="AspectInformation"/> type.</summary>
      /// <param name="name">Alias associate with aspect, this value need not be unique (but it pretty damn confusing to a user if not).</param>
      /// <param name="assembly">Name of assembly that the aspect class lives in.</param>
      /// <param name="type">Name of the class associated with the aspect.</param>
      public AspectInformation(string name, string assembly, string type) {
         this.name = name;
         this.assembly = assembly;
         this.type = type;
         this.id = 0;
      }

      /// <summary>Unique identifier associated with this entry.</summary>
      [SqlColumn("i_aspect")]
      public int Identifier { get { return id; } set { id = value; } }
      /// <summary>Alias associate with aspect, this value need not be unique.</summary>
      [SqlColumn("vc_name")]
      public string Name { get { return _s(name); } set { name = value; } }
      /// <summary>Name of assembly that the aspect class lives in.</summary>
      [SqlColumn("vc_assembly")]
      public string Assembly { get { return _s(assembly); } set { assembly = value; } }
      /// <summary>Name of the class associated with the aspect.</summary>
      [SqlColumn("vc_type")]
      public string TypeName { get { return _s(type); } set { type = value; } }

      private string _s(string s) { return string.IsNullOrEmpty(s) ? "" : s; }

      internal int id;

      private string name;
      private string assembly;
      private string type;
   }

   /// <summary>Holds properties assoicated with an aspect group.</summary>
   [Serializable]
   public struct AspectGroupInformation {
      /// <summary>Initializes new instance of <typeparamref name="AspectGroupInformation"/> type.</summary>
      /// <param name="name">Alias associate with aspect group, this value need not be unique.</param>
      /// <param name="description">A brief description of the aspect group.</param>
      public AspectGroupInformation(string name, string description) {
         this.name = name;
         this.description = description;
         this.id = 0;
      }

      /// <summary>Unique identifier associated with this entry.</summary>
      [SqlColumn("i_aspect_group")]
      public int Identifier { get { return id; } set { id = value; } }
      /// <summary>Alias associate with aspect group, this value need not be unique.</summary>
      [SqlColumn("vc_name")]
      public string Name { get { return _s(name); } set { name = value; } }
      /// <summary>A brief description of the aspect group.</summary>
      [SqlColumn("vc_description")]
      public string Description { get { return _s(description); } set { description = value; } }

      private string _s(string s) { return string.IsNullOrEmpty(s) ? "" : s; }

      private int id;
      private string name;
      private string description;
   }

   /// <summary>Hold properties associated with a service.</summary>
   [Serializable]
   public struct ServiceInformation {
      /// <summary>Initializes new instance of <typeparamref name="ServiceInformation"/> type.</summary>
      /// <param name="aspect_group">Aspect group associated with this service.</param>
      /// <param name="protocol">Protocol associated with the service.</param>
      /// <param name="alias">Alias associated with the service.  This name must be unique.</param>
      /// <param name="host">Host associated with the script.  This value is scoped to environment.</param>
      /// <param name="flag">Flags associated with the script.  This value is scoped to environment.</param>
      public ServiceInformation(int aspect_group, string protocol, string alias, string host, Nullable<long> flag) {
         this.aspect_group = aspect_group;
         this.protocol = protocol;
         this.alias = alias;
         this.host = host;
         this.flags = flag;
         this.id = 0;
      }

      /// <summary>Initializes new instance of <typeparamref name="ServiceInformation"/> type.</summary>
      /// <param name="aspect_group">Aspect group associated with this service.</param>
      /// <param name="protocol">Protocol associated with the service.</param>
      /// <param name="alias">Alias associated with the service.  This name must be unique.</param>
      public ServiceInformation(int aspect_group, string protocol, string alias) : this(aspect_group, protocol, alias, null, null) { }

      /// <summary>Unique identifier associated with this entry.</summary>
      [SqlColumn("i_service")]
      public int Identifier { get { return id; } set { id = value; } }
      /// <summary>Aspect group associated with this service.</summary>
      [SqlColumn("i_aspect_group")]
      public int AspectGroup { get { return aspect_group; } set { aspect_group = value; } }
      /// <summary>Protocol associated with the service.</summary>
      [SqlColumn("vc_protocol")]
      public string Protocol { get { return _s(protocol); } set { protocol = value; } }
      /// <summary>Alias associated with the service.  This name must be unique.</summary>
      [SqlColumn("vc_alias")]
      public string Alias { get { return _s(alias); } set { alias = value; } }
      /// <summary>Host associated with the script.  This value is scoped to environment.</summary>
      [SqlColumn("vc_host")]
      public string Host { get { return host; } set { host = value; } }
      /// <summary>Flags associated with the script.  This value is scoped to environment.</summary>
      [SqlColumn("bi_flags")]
      public Nullable<long> Flag { get { return flags; } set { flags = value; } }

      private string _s(string s) { return string.IsNullOrEmpty(s) ? "" : s; }

      private int id;

      private int aspect_group;
      private string protocol;
      private string alias;
      private string host;
      private Nullable<long> flags;
   }

   /// <summary>Hold properties associated with a script group.</summary>
   [Serializable]
   public struct ScriptGroupInformation {
      public string GetScriptsXml() {
         System.Xml.XmlDocument Doc = new System.Xml.XmlDocument();
         System.Xml.XmlElement Group = Doc.CreateElement("group");

         Doc.AppendChild(Group);
         Group.Attributes.Append(Doc.CreateAttribute("id")).Value = id.ToString();

         if (null != scripts) {
            foreach (int script in scripts) {
               System.Xml.XmlElement Script = Doc.CreateElement("script");
               Group.AppendChild(Script);
               Script.Attributes.Append(Doc.CreateAttribute("id")).Value = script.ToString();
            }
         }

         return Group.OuterXml;
      }

      public static int[] Convert(string xml) {
         List<int> Results = new List<int>();
         using (System.IO.StringReader Reader = new System.IO.StringReader(xml)) {
            using (System.Xml.XmlTextReader XReader = new System.Xml.XmlTextReader(Reader)) {
               while (XReader.Read()) {
                  if (XReader.Name == "script") {
                     XReader.MoveToAttribute("id");
                     Results.Add(System.Convert.ToInt32(XReader.Value));
                  }
               }
            }
         }
         return Results.ToArray();
      }

      /// <summary>Unique identifier associated with this entry.</summary>
      [SqlColumn("i_script_group")]
      public int Identifier { get { return this.id; } set { this.id = value; } }
      /// <summary>Name associated with script group.</summary>
      [SqlColumn("vc_name")]
      public string Name { get { return _s(this.name); } set { this.name = value; } }
      /// <summary>A brief description of the script group.</summary>
      [SqlColumn("vc_description")]
      public string Description { get { return _s(this.description); } set { this.description = value; } }
      /// <summary>Scheduling period associated with the script group.  If the scheduled flag is not set this value is ignored.  This value is scoped to environment</summary>
      [SqlColumn("i_period")]
      public int? Period { get { return this.period; } set { this.period = value; } }
      /// <summary>Flags associated with the script group.  This value is scoped to environment.</summary>
      [SqlColumn("bi_flags")]
      public long? Flag { get { return this.flags; } set { this.flags = value; } }
      /// <summary>Scripts contained in the script group.</summary>
      public int[] Scripts {
         get { return this.scripts; }
         set { this.scripts = value; }
      }
      /// <summary>Converts xml of scripts contained in the script group to an int array.</summary>
      [SqlColumn("xml_scripts")]
      internal string ScriptXmlConverter {
         set { this.scripts = Convert((string)value); } 
      }

      private string _s(string s) { return s ?? ""; }

      private int id;
      private string name;
      private string description;
      private int? period;
      private long? flags;
      private int[] scripts;
   }

   /// <summary>Hold properties associated with a script.</summary>
   [Serializable]
   public struct ScriptInformation : ICloneable {
      /// <summary>Initializes new instance of <typeparamref name="ScriptInformation"/> type.</summary>
      /// <param name="alias">Unique alias associated with this entry.</param>
      /// <param name="sourcecode">The C# code executed everytime this script is run.</param>
      /// <param name="period">Scheduling period associated with the script.  If the scheduled flag is not set this value is ignored.  This value is scoped to environment</param>
      /// <param name="flags">Flags associated with the script.  This value is scoped to environment.</param>
      public ScriptInformation(string alias, string sourcecode, Nullable<int> period, Nullable<long> flags) {
         this.alias = alias;
         this.sourcecode = sourcecode;
         this.period = period;
         this.flags = flags;
         this.id = 0;
         this.aspectGroup = null;
      }

      /// <summary>Initializes new instance of <typeparamref name="ScriptInformation"/> type.</summary>
      /// <param name="alias">Unique alias associated with this entry.</param>
      /// <param name="sourcecode">The C# code executed everytime this script is run.</param>
      public ScriptInformation(string alias, string sourcecode) : this(alias, sourcecode, null, null) { }

      /// <summary>Unique identifier associated with this entry.</summary>
      [SqlColumn("i_script")]
      public int Identifier { get { return id; } set { id = value; } }
      /// <summary>Unique alias associated with this entry.</summary>
      [SqlColumn("vc_alias")]
      public string Alias { get { return _s(alias); } set { alias = value; } }
      /// <summary>The C# code executed everytime this script is run.</summary>
      [SqlColumn("txt_source")]
      public string SourceCode { get { return _s(sourcecode); } set { sourcecode = value; } }
      /// <summary>ScriptGroup, if any, associated with this script.</summary>
      [SqlColumn("i_aspect_group")]
      public Nullable<int> AspectGroup { get { return aspectGroup; } set { aspectGroup = value; } }
      /// <summary>Scheduling period associated with the script.  If the scheduled flag is not set this value is ignored.  This value is scoped to environment</summary>
      [SqlColumn("i_period")]
      public Nullable<int> Period { get { return period; } set { period = value; } }
      /// <summary>Flags associated with the script.  This value is scoped to environment.</summary>
      [SqlColumn("bi_flags")]
      public Nullable<long> Flag { get { return flags; } set { flags = value; } }

      private string _s(string s) { return string.IsNullOrEmpty(s) ? "" : s; }
      
      private int id;

      private string alias;
      private string sourcecode;
      private Nullable<int> aspectGroup;
      private Nullable<int> period;
      private Nullable<long> flags;

      #region ICloneable Members
      public object Clone() {
         ScriptInformation info;

         info.id = this.id;
         info.alias = this.alias;
         info.sourcecode = this.sourcecode;
         info.aspectGroup = this.aspectGroup;
         info.period = this.period;
         info.flags = this.flags;

         return info;
      }
      #endregion
   }

   /// <summary>Hold properties associated with a environment.</summary>
   [Serializable]
   public struct EnvironmentInformation {
      /// <summary>Initializes new instance of <typeparamref name="EnvironmentInformation"/> type.</summary>
      /// <param name="name">Name associated with environment.</param>
      /// <param name="version">Version associated with environment.</param>
      /// <param name="host">Host address for the service.</param>
      /// <param name="decription">A brief description of the environment.</param>
      /// <param name="certificate">Path to certificate used for authenticated access to host.  If empty unauthenticated access will be used.</param>
      /// <param name="test_aspect_group">Aspect group associated with test scripts.  A value of zero indicates that no aspect group will be used.</param>
      /// <param name="general_aspect_group">Aspect group associated with general scripts.  A value of zero indicates that no aspect group will be used.</param>
      public EnvironmentInformation(string name, string version, string host, string description, string certificate, int test_aspect_group, int general_aspect_group) {
         this.name = name;
         this.version = version;
         this.host = host;
         this.description = description;
         this.certificate = certificate;
         this.test_aspect_group = test_aspect_group;
         this.general_aspect_group = general_aspect_group;
         this.id = 0;
      }

      /// <summary>Initializes new instance of <typeparamref name="EnvironmentInformation"/> type.</summary>
      /// <param name="name">Name associated with environment.</param>
      /// <param name="version">Version associated with environment.</param>
      /// <param name="host">Host address for the service.</param>
      /// <param name="decription">A brief description of the environment.</param>
      /// <param name="certificate">Path to certificate used for authenticated access to host.  If empty unauthenticated access will be used.</param>
      public EnvironmentInformation(string name, string version, string host, string description, string certificate)
         : this(name, version, host, description, certificate, 0, 0) { }

      /// <summary>Initializes new instance of <typeparamref name="EnvironmentInformation"/> type.</summary>
      /// <param name="name">Name associated with environment.</param>
      /// <param name="version">Version associated with environment.</param>
      /// <param name="host">Host address for the service.</param>
      /// <param name="decription">A brief description of the environment.</param>
      public EnvironmentInformation(string name, string version, string host, string description)
         : this(name, version, host, description, null) { }

      /// <summary>Unique identifier associated with this entry.</summary>
      [SqlColumn("i_environment")]
      public int Identifier { get { return id; } set { id = value; } }
      /// <summary>Name associated with environment.</summary>
      [SqlColumn("vc_name")]
      public string Name { get { return _s(name); } set { name = value; } }
      /// <summary>Version associated with environment.</summary>
      [SqlColumn("vc_version")]
      public string Version { get { return _s(version); } set { version = value; } }
      /// <summary>Host address for the service.</summary>
      [SqlColumn("vc_host")]
      public string Host { get { return _s(host); } set { host = value; } }
      /// <summary>A brief description of the environment.</summary>
      [SqlColumn("vc_description")]
      public string Description { get { return _s(description); } set { description = value; } }
      /// <param name="certificate">Path to certificate used for authenticated access to host.  If empty unauthenticated access will be used.</param>
      [SqlColumn("vc_cert")]
      public string Certificate { get { return _s(certificate); } set { certificate = value; } }
      /// <summary>Aspect group associated with test scripts.  A value of zero indicates that no aspect group will be used.</summary>
      [SqlColumn("i_aspect_group_test")]
      public int TestAspectGroup { get { return test_aspect_group; } set { test_aspect_group = value; } }
      /// <summary>Aspect group associated with general scripts.  A value of zero indicates that no aspect group will be used.</summary>
      [SqlColumn("i_aspect_group_general")]
      public int GeneralAspectGroup { get { return general_aspect_group; } set { general_aspect_group = value; } }


      private string _s(string s) { return string.IsNullOrEmpty(s) ? "" : s; }

      private int id;

      private string name;
      private string version;
      private string host;
      private string description;
      private string certificate;
      private int test_aspect_group;
      private int general_aspect_group;
   }

   [Serializable]
   public struct ScriptInstance {
      [SqlColumn("bi_script")]
      public long Instance { get { return instance; } set { instance = value; } }
      [SqlColumn("bi_environment")]
      public long EnvironmentInstance { get { return environmentInstance; } set { environmentInstance = value; } }
      [SqlColumn("i_script")]
      public int Script { get { return script; } set { script = value; } }
      [SqlColumn("vc_name")]
      public string Name { get { return name; } set { name = value; } }
      [SqlColumn("i_status")]
      public int Status { get { return status; } set { status = value; } }
      [SqlColumn("xml_report")]
      public SqlXml Report { get { return report; } set { report = value; } }
      [SqlColumn("dt_modified")]
      public DateTime Modified { get { return modified; } set { modified = value; } }

      private string name;
      private long instance;
      private long environmentInstance;
      private int script;
      private int status;
      private SqlXml report;
      private DateTime modified;
   }

   [Serializable]
   public struct EnvironmentInstance {
      [SqlColumn("bi_environment")]
      public long Instance { get { return instance; } set { instance = value; } }
      [SqlColumn("i_environment")]
      public int Environment { get { return environment; } set { environment = value; } }
      [SqlColumn("vc_name")]
      public string Name { get { return name; } set { name = value; } }
      [SqlColumn("i_status")]
      public int Status { get { return status; } set { status = value; } }
      [SqlColumn("dt_modified")]
      public DateTime Modified { get { return modified; } set { modified = value; } }

      private string name;
      private long instance;
      private int environment;
      private int status;
      private DateTime modified;
   }

   [Serializable]
   public struct StatusName {
      [SqlColumn("i_status")]
      public int Status { get { return status; } set { status = value; } }
      [SqlColumn("vc_name")]
      public string Name { get { return name; } set { name = value; } }
      [SqlColumn("vc_description")]
      public string Description { get { return description; } set { description = value; } }

      private string name;
      private string description;
      private int status;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\common\Control.Command.cs ===
using System;
using System.Security.Principal;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Data.SqlTypes;
using System.Reflection;
using System.Xml;
using System.Xml.XPath;

using WSMCommon.Control;

namespace WSMCommon.Control.Command
{
    /// <summary>
    /// Indicates that the decorated CommandState is in a final state.
    /// </summary>
    [AttributeUsage(AttributeTargets.Field, AllowMultiple = false)]
    public sealed class FinalStateAttribute : Attribute
    {
        public FinalStateAttribute() { }

        /// <summary>
        /// Indicates whether or not the given command state is a final state or not.
        /// </summary>
        /// <param name="state">The command state of interest.</param>
        /// <returns>true indicates the state is final.  false indicates it is not.</returns>
        public static bool IsFinal(CommandState state)
        {
            if (!cache.ContainsKey(state))
            {
                FieldInfo Field;
                object[] Attribs;
                Field = commandStateType.GetField(state.ToString());
                Attribs = Field.GetCustomAttributes(attributeType, true);
                cache[state] = !(Attribs == null || Attribs.Length == 0);
            }

            return cache[state];
        }

        private static Type attributeType = typeof(FinalStateAttribute);
        private static Type commandStateType = typeof(CommandState);
        private static Dictionary<CommandState, bool> cache = new Dictionary<CommandState, bool>();
    }

    /// <summary>
    /// Indicates the status of a command.
    /// <![CDATA[Coupling Notice: CommandProcessor needs to know if status results in a result -> result_history transition.]]>
    /// </summary>
    public enum CommandState : int
    {
        Queued = 10,
        Running = 20,

        [FinalState]
        Completed = 30,
        [FinalState]
        Failed = 35,
        [FinalState]
        Success = 36,
        [FinalState]
        Exception = 37,

        Paused = 40,
        [FinalState]
        Cancelled = 50,

        [FinalState]
        Error = 900,

        Unknown = 1000,
        Undefined = 2000
    }

    [Serializable]
    public class CommandResponse
    {
        public string XmlResult;

        protected static XmlDocument CreateDocument(XmlReader reader)
        {
            XmlDocument Doc = new XmlDocument();
            if (null != reader)
                Doc.Load(reader);
            return Doc;
        }

        public CommandResponse(XmlReader reader)
            : this(CommandResponse.CreateDocument(reader)) { }
        public CommandResponse(SqlXml result)
            : this((result == null || result.IsNull) ? null : result.CreateReader()) { }
        public CommandResponse()
            : this("") { }
        public CommandResponse(XmlDocument doc)
        {
            XmlResult = "";
            if (null != doc && null != doc.DocumentElement)
                XmlResult = doc.DocumentElement.OuterXml;
        }

        public CommandResponse(string xml)
        {
            this.XmlResult = xml;
        }
    }

    [Serializable]
    public class CommandStatus : CommandResponse
    {
        public static CommandStatus CreateSuccess(long command, XmlReader reader)
        {
            return Create(command, CommandState.Completed, reader);
        }
        public static CommandStatus CreateSuccess(long command, SqlXml result)
        {
            return Create(command, CommandState.Completed, result);
        }
        public static CommandStatus CreateSuccess(long command, string xml)
        {
            return Create(command, CommandState.Completed, xml);
        }

        public static CommandStatus CreateError(long command, XmlReader reader)
        {
            return Create(command, CommandState.Error, reader);
        }
        public static CommandStatus CreateError(long command, SqlXml result)
        {
            return Create(command, CommandState.Error, result);
        }
        public static CommandStatus CreateError(long command, string xml)
        {
            return Create(command, CommandState.Error, xml);
        }

        public static CommandStatus Create(long command, CommandState status, XmlReader reader)
        {
            return new CommandStatus(command, status, reader);
        }
        public static CommandStatus Create(long command, CommandState status, SqlXml result)
        {
            return new CommandStatus(command, status, result);
        }
        public static CommandStatus Create(long command, CommandState status, string xml)
        {
            return new CommandStatus(command, status, xml);
        }

        public CommandStatus(long command, CommandState status, XmlReader reader)
            : this(command, status, CommandResponse.CreateDocument(reader)) { }
        public CommandStatus(long command, CommandState status, SqlXml result)
            : this(command, status, (null == result || result.IsNull) ? null : result.CreateReader()) { }
        public CommandStatus()
            : this(0, CommandState.Undefined, "") { }
        public CommandStatus(long command, CommandState status, XmlDocument doc)
            : base(doc)
        {
            this.command = command;
            this.status = status;
        }
        public CommandStatus(long command, CommandState status, string xml)
            : base(xml)
        {
            this.command = command;
            this.status = status;
        }

        public CommandState Status
        {
            get { return status; }
            set { status = value; }
        }

        public long Command { get { return command; } }

        internal CommandState status;
        internal long command;
    }

    public partial class CommandLink
    {
        private SqlConnection controllerDb;

        public CommandLink(WindowsIdentity identity, string sqlHost)
            : this()
        {
            if (string.IsNullOrEmpty(sqlHost)) sqlHost = "localhost";

            string ConnectionString = string.Format("Server={0};Integrated Security=SSPI;Database=WSMControlDb", sqlHost);
            WindowsImpersonationContext Context = null;

            // If this extra catch looks odd to you, then maybe you haven't read http://msdn.microsoft.com/en-us/ms182322.aspx.
            // Mind you, there's a comment at the bottom that indicates you don't need to do this anymore, but I trust our
            // current version of FxCop more than I trust some comment on MSDN.
            try
            {
                try
                {
                    if (null != identity)
                        Context = identity.Impersonate();

                    controllerDb = new SqlConnection(ConnectionString);
                    controllerDb.Open();
                }
                finally
                {
                    if (null != Context)
                        Context.Undo();
                }
            }
            catch
            {
                throw;
            }
        }

        private Exception GetNullControllerExcepion()
        {
            return new InvalidOperationException("Controller connection is not initialized.");
        }

        public CommandResponse SendCommand(ICommandParameters parameters)
        {
            if (null == parameters)
                throw new ArgumentNullException("parameters");

            SqlCommand Command = GenerateCommand(parameters.StoredProcedureName, parameters.GetParameters());
            SqlParameter Output = new SqlParameter("@xml_return", SqlDbType.Xml, 1024);

            Output.Direction = ParameterDirection.Output;

            Command.Parameters.Add(Output);
            Command.ExecuteNonQuery();

            return new CommandResponse(Output.Value as string);
        }

        internal SqlCommand GenerateCommand(string name, SqlParameter[] parameters)
        {
            if (null == controllerDb)
                throw GetNullControllerExcepion();

            if (string.IsNullOrEmpty(name))
                throw new ArgumentException("name cannot be null or empty", "name");

            SqlCommand Command = new SqlCommand(name, controllerDb);

            Command.CommandType = CommandType.StoredProcedure;

            if (null != parameters)
            {
                foreach (SqlParameter p in parameters)
                    Command.Parameters.Add(p);
            }

            return Command;
        }

        internal SqlCommand GenerateCommand(string sproc, string[] pnames, object[] values)
        {
            SqlParameter[] Parameters = new SqlParameter[pnames.Length];

            for (int c = 0; c < Parameters.Length; c++)
                Parameters[c] = new SqlParameter(pnames[c], values[c]);

            return GenerateCommand(sproc, Parameters);
        }

        internal SqlCommand GenerateCommand(string sproc, string name, object value)
        {
            return GenerateCommand(sproc, new string[] { name }, new object[] { value });
        }

        internal T[] EnumerateObjects<T>(string sproc, string[] pnames, object[] values)
        {
            SqlCommand Command = GenerateCommand(sproc, pnames, values);

            List<T> Results = new List<T>();

            using (SqlDataReader Records = Command.ExecuteReader())
            {
                while (Records.Read())
                    Results.Add(
                        (T)InformationBuilder.PopulateObject(Activator.CreateInstance<T>(),
                        Records));
            }

            return Results.ToArray();
        }

        internal T[] EnumerateObjects<T>(string sproc, string pname, object value)
        {
            return EnumerateObjects<T>(sproc, new string[] { pname }, new object[] { value });
        }

        public StatusName[] EnumerateStatusNames()
        {
            return EnumerateObjects<StatusName>("p_enum_status_names", new string[0], new object[0]);
        }

        public AspectInformation[] EnumerateAspects(int group0, int group1)
        {
            return EnumerateObjects<AspectInformation>(
               "p_get_aspects",
               new string[] { "@i_aspect_group", "@i_aspect_group1" },
               new object[] { group0, group1 }
               );
        }

        public AspectInformation[] EnumerateAspects(int group)
        {
            return EnumerateAspects(group, 0);
        }

        public AspectInformation[] EnumerateAspects()
        {
            return EnumerateAspects(0);
        }

        public Nullable<AspectInformation> FetchAspect(int id)
        {
            AspectInformation[] Results = EnumerateObjects<AspectInformation>("p_get_aspects", "@i_aspect", id);
            return Results.Length > 0 ? (Nullable<AspectInformation>)Results[0] : null;
        }

        public AspectGroupInformation[] EnumerateAspectGroups()
        {
            return EnumerateObjects<AspectGroupInformation>("p_get_aspect_groups", "@i_aspect_group", 0);
        }

        public AspectGroupInformation[] EnumerateAspectAspectGroups(int id)
        {
            return EnumerateObjects<AspectGroupInformation>("p_get_aspect_aspectgroups", "@i_aspect", id);
        }

        public Nullable<AspectGroupInformation> FetchAspectGroup(int id)
        {
            AspectGroupInformation[] Results = EnumerateObjects<AspectGroupInformation>("p_get_aspect_groups", "@i_aspect_group", id);
            return Results.Length > 0 ? (Nullable<AspectGroupInformation>)Results[0] : null;
        }

        public EnvironmentInformation[] EnumerateEnvironments()
        {
            return EnumerateObjects<EnvironmentInformation>("p_get_environments", "@i_environment", 0);
        }

        public EnvironmentInformation[] EnumerateScriptEnvironments(int id)
        {
            return EnumerateObjects<EnvironmentInformation>("p_get_script_environments", "@i_script", id);
        }

        public EnvironmentInformation[] EnumerateScriptGroupEnvironments(int id)
        {
            return EnumerateObjects<EnvironmentInformation>("p_get_scriptgroup_environments", "@i_script_group", id);
        }

        public EnvironmentInformation[] EnumerateServiceEnvironments(int id)
        {
            return EnumerateObjects<EnvironmentInformation>("p_get_service_environments", "@i_service", id);
        }

        public Nullable<EnvironmentInformation> FetchEnvironment(int id)
        {
            EnvironmentInformation[] Results = EnumerateObjects<EnvironmentInformation>("p_get_environments", "@i_environment", id);
            return Results.Length > 0 ? (Nullable<EnvironmentInformation>)Results[0] : null;
        }

        public ScriptGroupInformation[] EnumerateScriptGroups(int env)
        {
            string[] Params = new string[] { "@i_environment", "@i_script_group" };
            object[] Values = ParameterUtility.PrepareArray<int>(new int[] { env, 0 });
            return EnumerateObjects<ScriptGroupInformation>("p_get_script_groups", Params, Values);
        }

        public ScriptGroupInformation[] EnumerateScriptGroups()
        {
            return EnumerateScriptGroups(0);
        }

        public Nullable<ScriptGroupInformation> FetchScriptGroup(int env, int id)
        {
            string[] Params = new string[] { "@i_environment", "@i_script_group" };
            object[] Values = ParameterUtility.PrepareArray<int>(new int[] { env, id });
            ScriptGroupInformation[] Results = EnumerateObjects<ScriptGroupInformation>("p_get_script_groups", Params, Values);
            return Results.Length > 0 ? (Nullable<ScriptGroupInformation>)Results[0] : null;
        }

        public Nullable<ScriptGroupInformation> FetchScriptGroup(int id)
        {
            return FetchScriptGroup(0, id);
        }

        public ScriptInformation[] EnumerateScripts(int env)
        {
            string[] Params = new string[] { "@i_environment", "@i_script" };
            object[] Values = ParameterUtility.PrepareArray<int>(new int[] { env, 0 });

            return EnumerateObjects<ScriptInformation>("p_get_scripts", Params, Values);
        }

        public ScriptInformation[] EnumerateScripts()
        {
            return EnumerateScripts(0);
        }

        public Nullable<ScriptInformation> FetchScript(int env, int id)
        {
            string[] Params = new string[] { "@i_environment", "@i_script" };
            object[] Values = ParameterUtility.PrepareArray<int>(new int[] { env, id });
            ScriptInformation[] Results = EnumerateObjects<ScriptInformation>("p_get_scripts", Params, Values);
            return Results.Length > 0 ? (Nullable<ScriptInformation>)Results[0] : null;
        }

        public Nullable<ScriptInformation> FetchScript(int id)
        {
            return FetchScript(0, id);
        }

        public ServiceInformation[] EnumerateServices(int env)
        {
            string[] Params = new string[] { "@i_environment", "@i_service" };
            object[] Values = ParameterUtility.PrepareArray<int>(new int[] { env, 0 });

            return EnumerateObjects<ServiceInformation>("p_get_services", Params, Values);
        }

        public ServiceInformation[] EnumerateServices()
        {
            return EnumerateServices(0);
        }

        public AspectInformation[] EnumerateAspectsInGroup(int id)
        {
            return EnumerateObjects<AspectInformation>("p_get_aspects_in_aspectgroup", "@i_aspect_group", id);
        }

        public Nullable<ServiceInformation> FetchService(int env, int id)
        {
            string[] Params = new string[] { "@i_environment", "@i_service" };
            object[] Values = ParameterUtility.PrepareArray<int>(new int[] { env, id });
            ServiceInformation[] Results = EnumerateObjects<ServiceInformation>("p_get_services", Params, Values);
            return Results.Length > 0 ? (Nullable<ServiceInformation>)Results[0] : null;
        }

        public Nullable<ServiceInformation> FetchService(int id)
        {
            return FetchService(0, id);
        }

        public EnvironmentInstance[] EnumerateEnvironmentInstances()
        {
            return EnumerateObjects<EnvironmentInstance>("p_get_environment_instances", "@bi_environment", (long)0);
        }

        public Nullable<EnvironmentInstance> FetchEnvironmentInstance(long inst)
        {
            EnvironmentInstance[] Results = EnumerateObjects<EnvironmentInstance>("p_get_environment_instances", "@bi_environment", inst);
            return Results.Length > 0 ? (Nullable<EnvironmentInstance>)Results[0] : null;
        }

        internal ScriptInstance[] EnumerateScriptInstances(long envInst, long scriptInst)
        {
            string[] Params = new string[] { "@bi_environment", "@bi_script" };
            object[] Values = ParameterUtility.PrepareArray<long>(new long[] { envInst, scriptInst });
            return EnumerateObjects<ScriptInstance>("p_get_script_instances", Params, Values);
        }

        public ScriptInstance[] EnumerateScriptInstances(long envInst)
        {
            return EnumerateScriptInstances(envInst, 0);
        }

        public ScriptInstance[] EnumerateAllScriptInstances()
        {
            return EnumerateScriptInstances(0, 0);
        }

        public Nullable<ScriptInstance> FetchScriptInstance(long inst)
        {
            ScriptInstance[] Results = EnumerateScriptInstances(0, inst);
            return Results.Length > 0 ? (Nullable<ScriptInstance>)Results[0] : null;
        }

        public static CommandState GetStatusFromInt(int status)
        {
            if (Enum.IsDefined(typeof(CommandState), status))
                return (CommandState)status;
            else
                return CommandState.Unknown;
        }

        public CommandState QueryCommandStatus(long command)
        {
            SqlCommand Command = GenerateCommand("p_get_command_status", "@bi_command", command);

            using (SqlDataReader Reader = Command.ExecuteReader())
            {
                if (Reader.Read())
                {
                    int Result = Reader.GetInt32(0);

                    return GetStatusFromInt(Result);
                }
            }

            return CommandState.Undefined;
        }

        public CommandStatus QueryCommandResult(long command)
        {
            SqlCommand Command = GenerateCommand("p_get_command_result", "@bi_command", command);

            using (SqlDataReader Reader = Command.ExecuteReader())
            {
                if (Reader.Read())
                {
                    return new CommandStatus(
                       command,
                       GetStatusFromInt((int)Reader["i_status"]),
                       Reader.GetSqlXml(Reader.GetOrdinal("xml_result")));
                }
            }

            return null;
        }

        public ScriptInstance WaitForScriptInstance(long command, int timeout, Predicate<ScriptInstance> predicate)
        {
            DateTime Timeout = DateTime.UtcNow + new TimeSpan(timeout * TimeSpan.TicksPerMillisecond);
            CommandStatus Result;
            long Instance;
            XmlDocument Doc;
            XPathNavigator Nav;

            Result = WaitForCommand(command, timeout, true);

            Doc = new XmlDocument();
            Doc.LoadXml(Result.XmlResult);

            Nav = Doc.CreateNavigator().SelectSingleNode("/result/details/script-instance");

            if (null == Nav)
                throw new InvalidOperationException("Result does not contain a script instance: expects '/result/details/script-instance'");

            Instance = long.Parse(Nav.InnerXml);

            while (true)
            {
                ScriptInstance? ScriptInstance;

                if (timeout > 0)
                {
                    //check for timeout
                    if (DateTime.UtcNow > Timeout)
                        break;
                }

                ScriptInstance = FetchScriptInstance(Instance);
                if (ScriptInstance.HasValue)
                {
                    if (predicate(ScriptInstance.Value))
                        return ScriptInstance.Value;
                }

                System.Threading.Thread.Sleep(0);
            }

            throw new TimeoutException();
        }
        public ScriptInstance WaitForScriptInstance(long command, int timeout, bool isFinal)
        {
            return WaitForScriptInstance(
               command,
               timeout,
               delegate(ScriptInstance si) { return !isFinal || FinalStateAttribute.IsFinal(GetStatusFromInt(si.Status)); });
        }
        public ScriptInstance WaitForScriptInstance(long command, int timeout, CommandState[] targetStates)
        {
            Predicate<ScriptInstance> predicate;
            List<CommandState> TempStates;
            List<int> TargetStates;

            TempStates = new List<CommandState>(targetStates == null ? new CommandState[0] : targetStates);
            TargetStates = TempStates.ConvertAll<int>(delegate(CommandState s) { return (int)s; });

            predicate = delegate(ScriptInstance cs)
            {
                return TargetStates.Count == 0 || TargetStates.Contains(cs.Status);
            };

            return WaitForScriptInstance(command, timeout, predicate);
        }
        public ScriptInstance WaitForScriptInstance(long command, int timeout)
        {
            return WaitForScriptInstance(
               command,
               timeout,
               delegate { return true; });
        }

        public CommandStatus WaitForCommand(long command, int timeout, Predicate<CommandStatus> predicate)
        {
            DateTime Start = DateTime.UtcNow;
            TimeSpan Timeout = new TimeSpan(timeout * TimeSpan.TicksPerMillisecond);

            while (true)
            {
                CommandStatus Result;

                if (timeout > 0)
                {
                    //check for timeout

                    TimeSpan Elapsed = DateTime.UtcNow - Start;
                    if (Elapsed > Timeout)
                        break;
                }

                if (null != (Result = QueryCommandResult(command)))
                {
                    if (predicate(Result))
                        return Result;
                }

                System.Threading.Thread.Sleep(0);
            }

            throw new TimeoutException();
        }

        public CommandStatus WaitForCommand(long command, int timeout, bool isFinal)
        {
            return WaitForCommand(
               command,
               timeout,
               delegate(CommandStatus cs) { return !isFinal || FinalStateAttribute.IsFinal(cs.Status); });
        }

        public CommandStatus WaitForCommand(long command, int timeout, CommandState[] targetStates)
        {
            Predicate<CommandStatus> predicate;
            List<CommandState> TargetStates;

            TargetStates = new List<CommandState>(targetStates == null ? new CommandState[0] : targetStates);
            predicate = delegate(CommandStatus cs)
            {
                return TargetStates.Count == 0 || TargetStates.Contains(cs.Status);
            };

            return WaitForCommand(
               command,
               timeout,
               predicate);
        }

        public CommandStatus WaitForCommand(long command, int timeout)
        {
            return WaitForCommand(
               command,
               timeout,
               delegate(CommandStatus cs) { return true; });
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\common\unit_Control.Command.Parameters.cs ===
namespace WSMCommon.Control.Command {
   #region Using Directives
   using LiveServiceMonitor.Test;
   using System;
   using System.Reflection;
   using System.Text;
   using System.Collections;
   using System.Collections.Generic;
   #endregion
   
   public partial class ParameterUtility : UnitTest {
      public ParameterUtility() : base("Command Parameters") {
         unitTests.Add(new DelegatedUnitTestLeaf(
            "ICommandParameter Value Type Check",
            new NodeTestDelegate(ut_ValueTypeCheck)));
         unitTests.Add(new DelegatedUnitTestLeaf(
            "ICommandParameter StoredProcedure Check",
            new NodeTestDelegate(ut_StoredProcCheck)));
         unitTests.Add(new DelegatedUnitTestLeaf(
            "ICommandParameter Unique Identity Check",
            new NodeTestDelegate(ut_UniqueIdentityCheck)));
         unitTests.Add(new DelegatedUnitTestLeaf(
            "ICommandParameter GetParameters Meaningful Defaults Check",
            new NodeTestDelegate(ut_GetParametersCheck)));
      }

      private bool ut_ValueTypeCheck(out string message) {
         StringBuilder Message = new StringBuilder();
         bool          Success = true;

         foreach (Type Type in GetTypeList()) {
            if (!Type.IsValueType) {
               Message.AppendFormat("ERROR: {0} is not a value type ", Type.FullName);
               Success = false;
               continue;
            }
         }

         message = Message.ToString();

         return Success;
      }

      private bool ut_StoredProcCheck(out string message) {
         StringBuilder Message = new StringBuilder();
         bool          Success = true;

         foreach (Type Type in GetTypeList()) {
            ICommandParameters Instance;

            try { Instance = (ICommandParameters)Activator.CreateInstance(Type); }
            catch (Exception e) {
               Message.AppendFormat("EXCEPTION: instantiation failed, type={0}, exception{1} ",
                  Type.FullName, e);
               Success = false;
               continue;
            }

            try {
               if (string.IsNullOrEmpty(Instance.StoredProcedureName)) {
                  Message.AppendFormat("ERROR: command parameter stored procedures cant be empty, type={0}\r\n", Type.FullName);
                  Success = false;
               }
            }
            catch (Exception e) {
               Message.AppendFormat("EXCEPTION: get StoredProcedureName, type={0}, exception={1}\r\n",
                  Type.FullName, e);
               Success = false;
            }
         }

         message = Message.ToString();

         return Success;
      }

      private bool ut_UniqueIdentityCheck(out string message) {
         StringBuilder Message = new StringBuilder();
         bool          Success = true;
         Hashtable     Map     = new Hashtable();

         foreach (Type Type in GetTypeList()) {
            ICommandParameters Instance;

            try { Instance = (ICommandParameters)Activator.CreateInstance(Type); }
            catch (Exception e) {
               Message.AppendFormat("EXCEPTION: instantiation failed, type={0}, exception{1} ",
                  Type.FullName, e);
               Success = false;
               continue;
            }

            try {
               if (Map[Instance.UniqueIdentifier] != null) {
                  Message.AppendFormat("ERROR: Unique identifier is not unique, type={0}, used-by={1}\r\n",
                     Type.FullName, Map[Instance.UniqueIdentifier]);
                  Success = false;
               }

               Map[Instance.UniqueIdentifier] = Type.FullName;
            }
            catch (Exception e) {
               Message.AppendFormat("EXCEPTION: get UniqueIdentifier, type={0}, exception={1}\r\n",
                  Type.FullName, e);
               Success = false;
            }
         }

         message = Message.ToString();

         return Success;
      }

      private bool ut_GetParametersCheck(out string message) {
         StringBuilder Message = new StringBuilder();
         bool Success = true;

         foreach (Type Type in GetTypeList()) {
            ICommandParameters Instance;

            try { Instance = (ICommandParameters)Activator.CreateInstance(Type); }
            catch (Exception e) {
               Message.AppendFormat("EXCEPTION: instantiation failed, type={0}, exception{1} ",
                  Type.FullName, e);
               Success = false;
               continue;
            }

            try { Instance.GetParameters(); }
            catch (Exception e) {
               Message.AppendFormat("EXCEPTION: call GetParameters, type={0}, exception={1}\r\n",
                  Type.FullName, e);
               Success = false;
            }
         }

         message = Message.ToString();

         return Success;
      }

      private Type[] GetTypeList() {
         if (typeCache == null) {
            List<Type> Types = new List<Type>();
            Type CPType = typeof(ICommandParameters);
            Assembly Current = CPType.Assembly;

            foreach (Type Type in Current.GetExportedTypes())
               if (Type != CPType && CPType.IsAssignableFrom(Type))
                  Types.Add(Type);

            typeCache = Types.ToArray();
         }

         return typeCache;
      }

      private Type[] typeCache = null;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\bvt-ext\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("bvt-ext")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("bvt-ext")]
[assembly: AssemblyCopyright("Copyright © Microsoft 2007")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("bac659e2-e009-4f5c-b72c-60b870b68e2d")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\common\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\common\unit_Root.cs ===
namespace WSMCommon {
   #region Using Directives
   using LiveServiceMonitor.Test;
   #endregion

   [UnitTestRoot]
   public class UnitTestRoot : UnitTest {
      public UnitTestRoot() : base("Live Service Monitoring Framework - Common Code Base") {
         unitTests.Add(new Control.InformationBuilder());
         unitTests.Add(new Control.Command.ParameterUtility());
         unitTests.Add(new Control.Command.CommandLink());
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\common\unit_Control.Command.cs ===
namespace WSMCommon.Control.Command {
   #region Using Directives
   using LiveServiceMonitor.Test;
   using System;
   using System.Xml;
   using System.Data.SqlTypes;
   using System.Reflection;
   #endregion

   public partial class CommandLink : UnitTest {
      internal CommandLink() : base("Command Link") {
         DelegatedUnitTestLeaf[] Tests = new DelegatedUnitTestLeaf[] {
            new DelegatedUnitTestLeaf("CommandResponse Null Activation", ut_CommandResponseNullInit),
            new DelegatedUnitTestLeaf("CommandStatus Null Activation", ut_CommandStatusNullInit)
         };

         unitTests.AddRange(Tests);
      }

      private bool ut_CommandResponseNullInit(out string message) {
         bool Success = true;

         object[] Parameters = new object[] {
            new object[] { null as XmlReader },
            new object[] { null as XmlDocument },
            new object[] { null as SqlXml },
            new object[] { SqlXml.Null },
            new object[] { null as string }
         };

         ConstructorInfo[] Constructors = new ConstructorInfo[] {
            typeof(CommandResponse).GetConstructor(new Type[] { typeof(XmlReader) } ),
            typeof(CommandResponse).GetConstructor(new Type[] { typeof(XmlDocument) } ),
            typeof(CommandResponse).GetConstructor(new Type[] { typeof(SqlXml) } ),
            typeof(CommandResponse).GetConstructor(new Type[] { typeof(SqlXml) } ),
            typeof(CommandResponse).GetConstructor(new Type[] { typeof(string) } )
         };

         message = "";
         for (int c = 0; c < Constructors.Length; c++) {
            CommandResponse Instance;

            if (null != Constructors[c]) {
               try { Instance = (CommandResponse)Constructors[c].Invoke((object[])Parameters[c]); }
               catch (Exception e) {
                  message += string.Format("EXCEPTION: ctor={0}, exception={1}", Constructors[c], e);
                  Success = false;
               }
            }
            else {
               message += string.Format("ERROR: missing constructor {0}", c);
               Success = false;
            }
         }

         return Success;
      }

      private bool ut_CommandStatusNullInit(out string message) {
         bool Success = true;

         object[] Parameters = new object[] {
            new object[] { 0L, CommandState.Unknown, null as XmlReader },
            new object[] { 0L, CommandState.Unknown, null as XmlDocument },
            new object[] { 0L, CommandState.Unknown, null as SqlXml },
            new object[] { 0L, CommandState.Unknown, SqlXml.Null },
            new object[] { 0L, CommandState.Unknown, null as string }
         };

         ConstructorInfo[] Constructors = new ConstructorInfo[] {
            typeof(CommandStatus).GetConstructor(new Type[] { typeof(long), typeof(CommandState), typeof(XmlReader) } ),
            typeof(CommandStatus).GetConstructor(new Type[] { typeof(long), typeof(CommandState), typeof(XmlDocument) } ),
            typeof(CommandStatus).GetConstructor(new Type[] { typeof(long), typeof(CommandState), typeof(SqlXml) } ),
            typeof(CommandStatus).GetConstructor(new Type[] { typeof(long), typeof(CommandState), typeof(SqlXml) } ),
            typeof(CommandStatus).GetConstructor(new Type[] { typeof(long), typeof(CommandState), typeof(string) } )
         };

         message = "";
         for (int c = 0; c < Constructors.Length; c++) {
            CommandResponse Instance;

            if (null != Constructors[c]) {
               try { Instance = (CommandResponse)Constructors[c].Invoke((object[])Parameters[c]); }
               catch (Exception e) {
                  message += string.Format("EXCEPTION: ctor={0}, exception={1}\r\n", Constructors[c], e);
                  Success = false;
               }
            }
            else {
               message += string.Format("ERROR: missing constructor {0} \r\n", c);
               Success = false;
            }
         }

         return Success;
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\common\Control.Command.Parameters.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Data.SqlTypes;
using System.IO;
using System.Text;
using System.Xml;

using WSMCommon.Control;

namespace WSMCommon.Control.Command {

   /// <summary>
   /// 
   /// </summary>
   /// <remarks>
   /// Other components may be bound to the integer values of these enumerations.
   /// </remarks>
   public enum ActionIdentifierEnum : int {
      AspectAdd = 1,
      AspectRemove = 2,
      AspectUpdate = 3,
      AspectAddToAllGroups = 4,
      AspectRemoveFromAllGroups = 5,

      ServiceAdd = 100,
      ServiceRemove = 101,
      ServiceUpdate = 102,

      ScriptAdd = 200,
      ScriptRemove = 201,
      ScriptUpdate = 202,
      ScriptEnable = 203,
      ScriptDisable = 204,
      ScriptStart = 205,
      ScriptPause = 206,
      ScriptCancel = 207,
      ScriptResume = 208,

      EnvironmentAdd = 300,
      EnvironmentRemove = 301,
      EnvironmentUpdate = 302,
      EnvironmentPauseAllScripts = 303,
      EnvironmentCancelAllScripts = 304,
      EnvironmentResumeAllScripts = 305,

      AspectGroupAdd = 400,
      AspectGroupRemove = 401,
      AspectGroupUpdate = 402,
      AspectGroupAddAspect = 403,
      AspectGroupRemoveAspect = 404,
      AspectGroupClear = 405,

      ScriptGroupAdd       = 500,
      ScriptGroupRemove    = 501,
      ScriptGroupUpdate    = 502,
      ScriptGroupStart     = 503,

      //Domain controller commands
      EnvironmentDeprecate = 10000,
      SchedulerThawGroup = 10001,
      SchedulerThawScript = 10002,
      SchedulerFreezeGroup = 10003,
      SchedulerFreezeScript = 10004,

      Invalid = 0
   }

   public enum ScriptFlagEnum : long {
      /// <summary>
      /// Prevents the script from running in the environment.
      /// </summary>
      /// <remarks>Must be kept in sync with p_enable_script, and p_disable_script.</remarks>
      Disabled          = 0x00000000000001,
      /// <summary>
      /// Prevents multiple instances of the script from running in the environment.
      /// </summary>
      Singleton         = 0x00000000000002,
      /// <summary>
      /// Indicates scheduling behavior is present on this script.
      /// </summary>
      Scheduled         = 0x00000000000004,
      /// <summary>
      /// Forces the script to be automatically run at startup.
      /// </summary>
      ScheduleStart     = 0x00000000000008 | Scheduled,
      /// <summary>
      /// Forces the script to be run back to back.
      /// </summary>
      ScheduleLoop      = 0x00000000000010 | Scheduled,
      /// <summary>
      /// Forces the script to be run periodically.
      /// </summary>
      /// <remarks>The singleton flag may prevent a script from being scheduled.</remarks>
      SchedulePeriodic  = 0x00000000000020 | Scheduled
   }

   public enum ServiceFlagEnum : long {
      /// <summary>Specifies that the Uri indicated by the service should be used as is.</summary>
      /// <remarks>The scheme is added to the uri if none is specified.</remarks>
      AbsoluteUrl  = 0x00000000000001,
      /// <summary>Specifies that the Secure Uri scheme should be used when generating the uri.</summary>
      /// <remarks>The scheme is not added if one is already present in the uri.</remarks>
      SecureScheme = 0x00000000000002
   }

   /// <summary>Interface used by all command types to convey the associated unique id.</summary>
   public interface ICommandParameters {
      /// <summary>Unique value associated with a particular command.</summary>
      ActionIdentifierEnum UniqueIdentifier { get; }

      string StoredProcedureName { get; }

      SqlParameter[] GetParameters();
   }

   public sealed class ServiceCommandAttribute : Attribute {
      public ServiceCommandAttribute() { }
   }

   public struct AspectAddParameters : ICommandParameters {
      public AspectInformation Aspect;
      public int? Rank;
      public int[] AspectGroups;

      ActionIdentifierEnum ICommandParameters.UniqueIdentifier { get { return ActionIdentifierEnum.AspectAdd; } }

      string ICommandParameters.StoredProcedureName { get { return "p_add_aspect"; } }

      SqlParameter[] ICommandParameters.GetParameters() {
         object RankValue = null;

         if (Rank.HasValue)
            RankValue = Rank.Value;

         return new SqlParameter[] {
            ParameterUtility.IntParameter("@i_aspect", 0),
            new SqlParameter("@vc_name", Aspect.Name),
            new SqlParameter("@vc_assembly", Aspect.Assembly),
            new SqlParameter("@vc_type", Aspect.TypeName),
            new SqlParameter("@i_rank", RankValue),
            ParameterUtility.GenerateXmlListParameter(ParameterUtility.PrepareArray<int>(AspectGroups))
         };
      }
   }

   public struct AspectRemoveParameters : ICommandParameters {
      public int   Identifier;
      public int[] AspectGroups;

      ActionIdentifierEnum ICommandParameters.UniqueIdentifier { get { return ActionIdentifierEnum.AspectRemove; } }

      string ICommandParameters.StoredProcedureName { get { return "p_del_aspect"; } }

      SqlParameter[] ICommandParameters.GetParameters() {
         return new SqlParameter[] {
            new SqlParameter("@i_aspect", Identifier),
            ParameterUtility.GenerateXmlListParameter(ParameterUtility.PrepareArray<int>(AspectGroups))
         };
      }
   }

   public struct AspectUpdateParameters : ICommandParameters {
      public AspectInformation Aspect;
      public int? Rank;
      public int[] AspectGroups;

      ActionIdentifierEnum ICommandParameters.UniqueIdentifier { get { return ActionIdentifierEnum.AspectUpdate; } }

      string ICommandParameters.StoredProcedureName { get { return "p_add_aspect"; } }

      SqlParameter[] ICommandParameters.GetParameters() {
         object RankValue = null;
         if (Rank.HasValue)
            RankValue = Rank.Value;

         return new SqlParameter[] {
            new SqlParameter("@i_aspect", Aspect.Identifier),
            new SqlParameter("@vc_name", Aspect.Name),
            new SqlParameter("@vc_assembly", Aspect.Assembly),
            new SqlParameter("@vc_type", Aspect.TypeName),
            new SqlParameter("@i_rank", RankValue),
            ParameterUtility.GenerateXmlListParameter(ParameterUtility.PrepareArray<int>(AspectGroups))
         };
      }
   }

   public struct AspectAddToAllGroupsParameters : ICommandParameters {
      public int Identifier;
      public int Rank;

      ActionIdentifierEnum ICommandParameters.UniqueIdentifier { get { return ActionIdentifierEnum.AspectAddToAllGroups; } }

      string ICommandParameters.StoredProcedureName { get { return "p_add_aspect_to_groups"; } }

      SqlParameter[] ICommandParameters.GetParameters() {
         return new SqlParameter[] {
                ParameterUtility.IntParameter("@i_aspect_group", 0),
                new SqlParameter("@i_aspect", Identifier),
                new SqlParameter("@i_rank", Rank)
            };
      }
   }

   public struct AspectRemoveFromAllGroupsParameters : ICommandParameters {
      public int Identifier;

      ActionIdentifierEnum ICommandParameters.UniqueIdentifier { get { return ActionIdentifierEnum.AspectRemoveFromAllGroups; } }

      string ICommandParameters.StoredProcedureName { get { return "p_del_aspect_from_groups"; } }

      SqlParameter[] ICommandParameters.GetParameters() {
         return new SqlParameter[] {
                ParameterUtility.IntParameter("@i_aspect_group", 0),
                new SqlParameter("@i_aspect", Identifier)
            };
      }
   }

   public struct ServiceAddParameters : ICommandParameters {
      public ServiceInformation Service;
      public int[] Environments;

      ActionIdentifierEnum ICommandParameters.UniqueIdentifier { get { return ActionIdentifierEnum.ServiceAdd; } }

      string ICommandParameters.StoredProcedureName { get { return "p_add_service"; } }

      SqlParameter[] ICommandParameters.GetParameters() {
         int[] Values = ((null != Environments) && (Environments.Length > 0)) ? Environments : null;
         object[] Array = ParameterUtility.PrepareArray<int>(Values);
         return new SqlParameter[] { 
                ParameterUtility.IntParameter("@i_service", 0),
                new SqlParameter("@vc_protocol", Service.Protocol),
                new SqlParameter("@vc_alias", Service.Alias),
                new SqlParameter("@i_aspect_group", Service.AspectGroup),
                new SqlParameter("@bi_flags", Service.Flag ?? 0),
                new SqlParameter("@vc_host", Service.Host ?? ""),
                ParameterUtility.GenerateXmlListParameter(Array)
            };
      }
   }

   public struct ServiceRemoveParameters : ICommandParameters {
      public int Identifier;
      public int[] Environments;

      ActionIdentifierEnum ICommandParameters.UniqueIdentifier { get { return ActionIdentifierEnum.ServiceRemove; } }

      string ICommandParameters.StoredProcedureName { get { return "p_del_service"; } }

      SqlParameter[] ICommandParameters.GetParameters() {
         if (null == Environments || Environments.Length == 0)
            return new SqlParameter[] {
               new SqlParameter("@i_service", Identifier)
            };
         else
            return new SqlParameter[] {
               new SqlParameter("@i_service", Identifier),
               ParameterUtility.GenerateXmlListParameter(ParameterUtility.PrepareArray<int>(Environments))
            };
      }
   }

   public struct ServiceUpdateParameters : ICommandParameters {
      public int[] Environments;
      public ServiceInformation Service;

      ActionIdentifierEnum ICommandParameters.UniqueIdentifier { get { return ActionIdentifierEnum.ServiceUpdate; } }

      string ICommandParameters.StoredProcedureName { get { return "p_add_service"; } }

      SqlParameter[] ICommandParameters.GetParameters() {
         int[] Values = ((null != Environments) && (Environments.Length > 0)) ? Environments : null;
         object[] Array = ParameterUtility.PrepareArray<int>(Values);
         return new SqlParameter[] { 
             new SqlParameter("@i_service", Service.Identifier),
             new SqlParameter("@vc_protocol", Service.Protocol),
             new SqlParameter("@vc_alias", Service.Alias),
             new SqlParameter("@i_aspect_group", Service.AspectGroup),
             new SqlParameter("@bi_flags", Service.Flag ?? 0),
             new SqlParameter("@vc_host", Service.Host ?? ""),
             ParameterUtility.GenerateXmlListParameter(Array)
         };
      }
   }

   public struct ScriptAddParameters : ICommandParameters {
      public int[] Environments;
      public ScriptInformation Script;

      ActionIdentifierEnum ICommandParameters.UniqueIdentifier { get { return ActionIdentifierEnum.ScriptAdd; } }

      string ICommandParameters.StoredProcedureName { get { return "p_add_script"; } }

      SqlParameter[] ICommandParameters.GetParameters() {
         int[] Values = ((null != Environments) && (Environments.Length > 0)) ? Environments : null;
         object[] Array = ParameterUtility.PrepareArray<int>(Values);
         SqlInt32 AspectGroup = Script.AspectGroup.HasValue ? new SqlInt32(Script.AspectGroup.Value) : SqlInt32.Null;

         return new SqlParameter[] {
             ParameterUtility.IntParameter("@i_script", 0),
             new SqlParameter("@txt_source", Script.SourceCode),
             new SqlParameter("@bi_flags", Script.Flag ?? 0),
             new SqlParameter("@i_period", Script.Period ?? 0),
             new SqlParameter("@vc_alias", Script.Alias),
             new SqlParameter("@i_aspect_group", AspectGroup),
            
             ParameterUtility.GenerateXmlListParameter(Array)
         };
      }
   }

   public struct ScriptRemoveParameters : ICommandParameters {
      public int Identifier;
      public int[] Environments;

      ActionIdentifierEnum ICommandParameters.UniqueIdentifier { get { return ActionIdentifierEnum.ScriptRemove; } }

      string ICommandParameters.StoredProcedureName { get { return "p_del_script"; } }

      SqlParameter[] ICommandParameters.GetParameters() {
         if (null == Environments || Environments.Length == 0)
            return new SqlParameter[] {
               new SqlParameter("@i_script", Identifier)
            };
         else
            return new SqlParameter[] {
               new SqlParameter("@i_script", Identifier),
               ParameterUtility.GenerateXmlListParameter(ParameterUtility.PrepareArray<int>(Environments))
            };
      }
   }

   public struct ScriptUpdateParameters : ICommandParameters {
      public int[] Environments;
      public ScriptInformation Script;

      ActionIdentifierEnum ICommandParameters.UniqueIdentifier { get { return ActionIdentifierEnum.ScriptUpdate; } }

      string ICommandParameters.StoredProcedureName { get { return "p_add_script"; } }

      SqlParameter[] ICommandParameters.GetParameters() {
         int[] Values = ((null != Environments) && (Environments.Length > 0)) ? Environments : null;
         object[] Array = ParameterUtility.PrepareArray<int>(Values);
         SqlInt32 AspectGroup = Script.AspectGroup.HasValue ? new SqlInt32(Script.AspectGroup.Value) : SqlInt32.Null;

         return new SqlParameter[] {
                new SqlParameter("@i_script", Script.Identifier),
                new SqlParameter("@txt_source", Script.SourceCode),
                new SqlParameter("@bi_flags", Script.Flag ?? 0),
                new SqlParameter("@i_period", Script.Period ?? 0),
                new SqlParameter("@vc_alias", Script.Alias),
                new SqlParameter("@i_aspect_group", AspectGroup),
                ParameterUtility.GenerateXmlListParameter(Array)
            };
      }
   }

   public struct ScriptEnableParameters : ICommandParameters {
      public int Identifier;
      public int[] Environments;

      ActionIdentifierEnum ICommandParameters.UniqueIdentifier { get { return ActionIdentifierEnum.ScriptEnable; } }

      string ICommandParameters.StoredProcedureName { get { return "p_enable_script"; } }

      SqlParameter[] ICommandParameters.GetParameters() {
         object[] Array = ParameterUtility.PrepareArray<int>(Environments);
         return new SqlParameter[] {
                new SqlParameter("@i_script", Identifier),
                ParameterUtility.GenerateXmlListParameter(Array)
            };
      }
   }

   public struct ScriptDisableParameters : ICommandParameters {
      public int Identifier;
      public int[] Environments;

      ActionIdentifierEnum ICommandParameters.UniqueIdentifier { get { return ActionIdentifierEnum.ScriptDisable; } }

      string ICommandParameters.StoredProcedureName { get { return "p_disable_script"; } }

      SqlParameter[] ICommandParameters.GetParameters() {
         object[] Array = ParameterUtility.PrepareArray<int>(Environments);
         return new SqlParameter[] {
                new SqlParameter("@i_script", Identifier),
                ParameterUtility.GenerateXmlListParameter(Array)
            };
      }
   }

   [ServiceCommand]
   public struct ScriptStartParameters : ICommandParameters {
      public string User;
      public int Identifier;
      public int[] Environments;

      ActionIdentifierEnum ICommandParameters.UniqueIdentifier { get { return ActionIdentifierEnum.ScriptStart; } }

      string ICommandParameters.StoredProcedureName { get { return "p_cmd_start_script"; } }

      SqlParameter[] ICommandParameters.GetParameters() {
         object[] Array = ParameterUtility.PrepareArray<int>(Environments);
         return new SqlParameter[] {
                new SqlParameter("@i_action", ((ICommandParameters)this).UniqueIdentifier),
                new SqlParameter("@vc_user", User),
                new SqlParameter("@i_script", Identifier),
                ParameterUtility.GenerateXmlListParameter("@xml_environments", Array)
            };
      }
   }

   [ServiceCommand]
   public struct ScriptPauseParameters : ICommandParameters {
      public long Instance;
      public string User;

      ActionIdentifierEnum ICommandParameters.UniqueIdentifier { get { return ActionIdentifierEnum.ScriptPause; } }

      string ICommandParameters.StoredProcedureName { get { return "p_cmd_generic_instance_action"; } }

      SqlParameter[] ICommandParameters.GetParameters() {
         return new SqlParameter[] {
                new SqlParameter("@i_action", ((ICommandParameters)this).UniqueIdentifier),
                new SqlParameter("@vc_user", User),
                new SqlParameter("@bi_instance", Instance)
            };
      }
   }

   [ServiceCommand]
   public struct ScriptCancelParameters : ICommandParameters {
      public long Instance;
      public string User;

      ActionIdentifierEnum ICommandParameters.UniqueIdentifier { get { return ActionIdentifierEnum.ScriptCancel; } }

      string ICommandParameters.StoredProcedureName { get { return "p_cmd_generic_instance_action"; } }

      SqlParameter[] ICommandParameters.GetParameters() {
         return new SqlParameter[] {
                new SqlParameter("@i_action", ((ICommandParameters)this).UniqueIdentifier),
                new SqlParameter("@vc_user", User),
                new SqlParameter("@bi_instance", Instance)
            };
      }
   }

   [ServiceCommand]
   public struct ScriptResumeParameters : ICommandParameters {
      public long Instance;
      public string User;

      ActionIdentifierEnum ICommandParameters.UniqueIdentifier { get { return ActionIdentifierEnum.ScriptResume; } }

      string ICommandParameters.StoredProcedureName { get { return "p_cmd_generic_instance_action"; } }

      SqlParameter[] ICommandParameters.GetParameters() {
         return new SqlParameter[] {
                new SqlParameter("@i_action", ((ICommandParameters)this).UniqueIdentifier),
                new SqlParameter("@vc_user", User),
                new SqlParameter("@bi_instance", Instance)
            };
      }
   }



   public struct EnvironmentAddParameters : ICommandParameters {
      public EnvironmentInformation Environment;

      ActionIdentifierEnum ICommandParameters.UniqueIdentifier { get { return ActionIdentifierEnum.EnvironmentAdd; } }

      string ICommandParameters.StoredProcedureName { get { return "p_add_environment"; } }

      SqlParameter[] ICommandParameters.GetParameters() {
         return new SqlParameter[] {
                ParameterUtility.IntParameter("@i_environment", 0),
                new SqlParameter("@vc_name", Environment.Name),
                new SqlParameter("@vc_version", Environment.Version),
                new SqlParameter("@vc_host", Environment.Host),
                new SqlParameter("@i_aspect_group_test", Environment.TestAspectGroup),
                new SqlParameter("@i_aspect_group_general", Environment.GeneralAspectGroup),
                new SqlParameter("@vc_cert", Environment.Certificate),
                new SqlParameter("@vc_description", Environment.Description)
            };
      }
   }

   public struct EnvironmentRemoveParameters : ICommandParameters {
      public int Identifier;

      ActionIdentifierEnum ICommandParameters.UniqueIdentifier { get { return ActionIdentifierEnum.EnvironmentRemove; } }

      string ICommandParameters.StoredProcedureName { get { return "p_del_environment"; } }

      SqlParameter[] ICommandParameters.GetParameters() {
         return new SqlParameter[] {
                new SqlParameter("@i_environment", Identifier)
            };
      }
   }

   public struct EnvironmentUpdateParameters : ICommandParameters {
      public int Identifier;
      public EnvironmentInformation Environment;

      ActionIdentifierEnum ICommandParameters.UniqueIdentifier { get { return ActionIdentifierEnum.EnvironmentUpdate; } }

      string ICommandParameters.StoredProcedureName { get { return "p_add_environment"; } }

      SqlParameter[] ICommandParameters.GetParameters() {
         return new SqlParameter[] {
                new SqlParameter("@i_environment", Environment.Identifier),
                new SqlParameter("@vc_name", Environment.Name),
                new SqlParameter("@vc_version", Environment.Version),
                new SqlParameter("@vc_host", Environment.Host),
                new SqlParameter("@i_aspect_group_test", Environment.TestAspectGroup),
                new SqlParameter("@i_aspect_group_general", Environment.GeneralAspectGroup),
                new SqlParameter("@vc_cert", Environment.Certificate),
                new SqlParameter("@vc_description", Environment.Description)
            };
      }
   }

   [ServiceCommand]
   public struct EnvironmentDeprecateParameters : ICommandParameters {
      public int Environment;
      public string User;

      ActionIdentifierEnum ICommandParameters.UniqueIdentifier { get { return ActionIdentifierEnum.EnvironmentDeprecate; } }
      string ICommandParameters.StoredProcedureName { get { return "p_cmd_generic_instance_action"; } }
      SqlParameter[] ICommandParameters.GetParameters() {
         return new SqlParameter[] {
            new SqlParameter("@i_action", ((ICommandParameters)this).UniqueIdentifier),
            new SqlParameter("@vc_user", User),
            new SqlParameter("@bi_instance", (long)Environment)
         };
      }
   }

   [ServiceCommand]
   public struct SchedulerThawScriptGroupParameters : ICommandParameters {
      public int Environment;
      public string User;
      public int ScriptGroup;

      ActionIdentifierEnum ICommandParameters.UniqueIdentifier { get { return ActionIdentifierEnum.SchedulerThawGroup; } }
      string ICommandParameters.StoredProcedureName { get { return "p_cmd_scheduling"; } }
      SqlParameter[] ICommandParameters.GetParameters() {
         object[] Array = ParameterUtility.PrepareArray<int>(new int[] { Environment });
         return new SqlParameter[] {
            new SqlParameter("@i_action", ((ICommandParameters)this).UniqueIdentifier),
            new SqlParameter("@vc_user", User),
            ParameterUtility.GenerateXmlListParameter("@xml_environments", Array),
            new SqlParameter("@i_target", ScriptGroup)
         };
      }
   }

   [ServiceCommand]
   public struct SchedulerThawScriptParameters : ICommandParameters {
      public int Environment;
      public string User;
      public int Script;

      ActionIdentifierEnum ICommandParameters.UniqueIdentifier { get { return ActionIdentifierEnum.SchedulerThawScript; } }
      string ICommandParameters.StoredProcedureName { get { return "p_cmd_scheduling"; } }
      SqlParameter[] ICommandParameters.GetParameters() {
         object[] Array = ParameterUtility.PrepareArray<int>(new int[] { Environment });
         return new SqlParameter[] {
            new SqlParameter("@i_action", ((ICommandParameters)this).UniqueIdentifier),
            new SqlParameter("@vc_user", User),
            ParameterUtility.GenerateXmlListParameter("@xml_environments", Array),
            new SqlParameter("@i_target", Script)
         };
      }
   }

   [ServiceCommand]
   public struct SchedulerFreezeScriptGroupParameters : ICommandParameters {
      public int Environment;
      public string User;
      public int ScriptGroup;

      ActionIdentifierEnum ICommandParameters.UniqueIdentifier { get { return ActionIdentifierEnum.SchedulerFreezeGroup; } }
      string ICommandParameters.StoredProcedureName { get { return "p_cmd_scheduling"; } }
      SqlParameter[] ICommandParameters.GetParameters() {
         object[] Array = ParameterUtility.PrepareArray<int>(new int[] { Environment });
         return new SqlParameter[] {
            new SqlParameter("@i_action", ((ICommandParameters)this).UniqueIdentifier),
            new SqlParameter("@vc_user", User),
            ParameterUtility.GenerateXmlListParameter("@xml_environments", Array),
            new SqlParameter("@i_target", ScriptGroup)
         };
      }
   }

   [ServiceCommand]
   public struct SchedulerFreezeScriptParameters : ICommandParameters {
      public int Environment;
      public string User;
      public int Script;

      ActionIdentifierEnum ICommandParameters.UniqueIdentifier { get { return ActionIdentifierEnum.SchedulerFreezeScript; } }
      string ICommandParameters.StoredProcedureName { get { return "p_cmd_scheduling"; } }
      SqlParameter[] ICommandParameters.GetParameters() {
         object[] Array = ParameterUtility.PrepareArray<int>(new int[] { Environment });
         return new SqlParameter[] {
            new SqlParameter("@i_action", ((ICommandParameters)this).UniqueIdentifier),
            new SqlParameter("@vc_user", User),
            ParameterUtility.GenerateXmlListParameter("@xml_environments", Array),
            new SqlParameter("@i_target", Script)
         };
      }
   }

   [ServiceCommand]
   public struct EnvironmentPauseAllScriptsParameters : ICommandParameters {
      public long Instance;
      public string User;

      ActionIdentifierEnum ICommandParameters.UniqueIdentifier { get { return ActionIdentifierEnum.EnvironmentPauseAllScripts; } }

      string ICommandParameters.StoredProcedureName { get { return "p_cmd_generic_instance_action"; } }

      SqlParameter[] ICommandParameters.GetParameters() {
         return new SqlParameter[] {
                new SqlParameter("@i_action", ((ICommandParameters)this).UniqueIdentifier),
                new SqlParameter("@vc_user", User),
                new SqlParameter("@bi_instance", Instance)
            };
      }
   }

   [ServiceCommand]
   public struct EnvironmentCancelAllScriptsParameters : ICommandParameters {
      public long Instance;
      public string User;

      ActionIdentifierEnum ICommandParameters.UniqueIdentifier { get { return ActionIdentifierEnum.EnvironmentCancelAllScripts; } }

      string ICommandParameters.StoredProcedureName { get { return "p_cmd_generic_instance_action"; } }

      SqlParameter[] ICommandParameters.GetParameters() {
         return new SqlParameter[] {
                new SqlParameter("@i_action", ((ICommandParameters)this).UniqueIdentifier),
                new SqlParameter("@vc_user", User),
                new SqlParameter("@bi_instance", Instance)
            };
      }
   }

   [ServiceCommand]
   public struct EnvironmentResumeAllScriptsParameters : ICommandParameters {
      public long Instance;
      public string User;

      ActionIdentifierEnum ICommandParameters.UniqueIdentifier { get { return ActionIdentifierEnum.EnvironmentResumeAllScripts; } }

      string ICommandParameters.StoredProcedureName { get { return "p_cmd_generic_instance_action"; } }

      SqlParameter[] ICommandParameters.GetParameters() {
         return new SqlParameter[] {
                new SqlParameter("@i_action", ((ICommandParameters)this).UniqueIdentifier),
                new SqlParameter("@vc_user", User),
                new SqlParameter("@bi_instance", Instance)
            };
      }
   }

   public struct AspectGroupAddParameters : ICommandParameters {
      public AspectGroupInformation AspectGroup;

      ActionIdentifierEnum ICommandParameters.UniqueIdentifier { get { return ActionIdentifierEnum.AspectGroupAdd; } }

      string ICommandParameters.StoredProcedureName { get { return "p_add_aspectgroup"; } }

      SqlParameter[] ICommandParameters.GetParameters() {
         return new SqlParameter[] {
                ParameterUtility.IntParameter("@i_aspect_group", 0),
                new SqlParameter("@vc_name", AspectGroup.Name),
                new SqlParameter("@vc_description", AspectGroup.Description)
            };
      }
   }

   public struct AspectGroupRemoveParameters : ICommandParameters {
      public int Identifier;

      ActionIdentifierEnum ICommandParameters.UniqueIdentifier { get { return ActionIdentifierEnum.AspectGroupRemove; } }

      string ICommandParameters.StoredProcedureName { get { return "p_del_aspectgroup"; } }

      SqlParameter[] ICommandParameters.GetParameters() {
         return new SqlParameter[] {
                new SqlParameter("@i_aspect_group", Identifier)
            };
      }
   }

   public struct AspectGroupUpdateParameters : ICommandParameters {
      public AspectGroupInformation AspectGroup;

      ActionIdentifierEnum ICommandParameters.UniqueIdentifier { get { return ActionIdentifierEnum.AspectGroupUpdate; } }

      string ICommandParameters.StoredProcedureName { get { return "p_add_aspectgroup"; } }

      SqlParameter[] ICommandParameters.GetParameters() {
         return new SqlParameter[] {
                new SqlParameter("@i_aspect_group", AspectGroup.Identifier),
                new SqlParameter("@vc_name", AspectGroup.Name),
                new SqlParameter("@vc_description", AspectGroup.Description)
            };
      }
   }

   public struct AspectGroupAddAspectParameters : ICommandParameters {
      public int Identifier;
      public int AspectIdentifier;
      public int Rank;

      ActionIdentifierEnum ICommandParameters.UniqueIdentifier { get { return ActionIdentifierEnum.AspectGroupAddAspect; } }

      string ICommandParameters.StoredProcedureName { get { return "p_add_aspect_to_groups"; } }

      SqlParameter[] ICommandParameters.GetParameters() {
         return new SqlParameter[] {
                new SqlParameter("@i_aspect_group", Identifier),
                new SqlParameter("@i_aspect", AspectIdentifier),
                new SqlParameter("@i_rank", Rank)
            };
      }
   }

   public struct AspectGroupRemoveAspectParameters : ICommandParameters {
      public int Identifier;
      public int AspectIdentifier;

      ActionIdentifierEnum ICommandParameters.UniqueIdentifier { get { return ActionIdentifierEnum.AspectGroupRemoveAspect; } }

      string ICommandParameters.StoredProcedureName { get { return "p_del_aspect_from_groups"; } }

      SqlParameter[] ICommandParameters.GetParameters() {
         return new SqlParameter[] {
                new SqlParameter("@i_aspect_group", Identifier),
                new SqlParameter("@i_aspect", AspectIdentifier)
            };
      }
   }

   public struct AspectGroupClearParameters : ICommandParameters {
      public int Identifier;

      ActionIdentifierEnum ICommandParameters.UniqueIdentifier { get { return ActionIdentifierEnum.AspectGroupClear; } }

      string ICommandParameters.StoredProcedureName { get { return "p_clear_aspectgroup"; } }

      SqlParameter[] ICommandParameters.GetParameters() {
         return new SqlParameter[] {
                new SqlParameter("@i_aspect_group", Identifier)
            };
      }
   }

   public struct ScriptGroupAddParameters : ICommandParameters {
      public ScriptGroupInformation ScriptGroup;
      public int[] Environments;

      ActionIdentifierEnum ICommandParameters.UniqueIdentifier { get { return ActionIdentifierEnum.ScriptGroupAdd; } }

      string ICommandParameters.StoredProcedureName { get { return "p_add_scriptgroup"; } }

      SqlParameter[] ICommandParameters.GetParameters() {
         object[] Array = ParameterUtility.PrepareArray<int>(Environments);
         SqlParameter XmlScripts;

         using (StringReader Reader = new StringReader(ScriptGroup.GetScriptsXml())) {
            using (XmlTextReader XReader = new XmlTextReader(Reader)) {
               XmlScripts = new SqlParameter("@xml_scripts", new SqlXml(XReader));
            }
         }

         return new SqlParameter[] { 
            ParameterUtility.IntParameter("@i_script_group", 0),
            new SqlParameter("@vc_name", ScriptGroup.Name),
            new SqlParameter("@vc_description", ScriptGroup.Description),
            new SqlParameter("@bi_flags", ScriptGroup.Flag ?? 0),
            new SqlParameter("@i_period", ScriptGroup.Period ?? 0),
            XmlScripts,
            ParameterUtility.GenerateXmlListParameter(Array)
         };
      }
   }

   public struct ScriptGroupRemoveParameters : ICommandParameters {
      public int Identifier;
      public int[] Environments;

      ActionIdentifierEnum ICommandParameters.UniqueIdentifier { get { return ActionIdentifierEnum.ScriptGroupRemove; } }

      string ICommandParameters.StoredProcedureName { get { return "p_del_scriptgroup"; } }

      SqlParameter[] ICommandParameters.GetParameters() {
         if (null == Environments || Environments.Length == 0)
            return new SqlParameter[] {
               new SqlParameter("@i_script_group", Identifier)
            };
         else
            return new SqlParameter[] {
               new SqlParameter("@i_script_group", Identifier),
               ParameterUtility.GenerateXmlListParameter(ParameterUtility.PrepareArray<int>(Environments))
            };
      }
   }

   public struct ScriptGroupUpdateParameters : ICommandParameters {
      public int[] Environments;
      public ScriptGroupInformation ScriptGroup;

      ActionIdentifierEnum ICommandParameters.UniqueIdentifier { get { return ActionIdentifierEnum.ScriptGroupUpdate; } }

      string ICommandParameters.StoredProcedureName { get { return "p_add_scriptgroup"; } }

      SqlParameter[] ICommandParameters.GetParameters() {
         object[] Array = ParameterUtility.PrepareArray<int>(Environments);
         SqlParameter XmlScripts;

         using (StringReader Reader = new StringReader(ScriptGroup.GetScriptsXml())) {
            using (XmlTextReader XReader = new XmlTextReader(Reader)) {
               XmlScripts = new SqlParameter("@xml_scripts", new SqlXml(XReader));
            }
         }

         return new SqlParameter[] { 
            ParameterUtility.IntParameter("@i_script_group", ScriptGroup.Identifier),
            new SqlParameter("@vc_name", ScriptGroup.Name),
            new SqlParameter("@vc_description", ScriptGroup.Description),
            new SqlParameter("@bi_flags", ScriptGroup.Flag ?? 0),
            new SqlParameter("@i_period", ScriptGroup.Period ?? 0),
            XmlScripts,
            ParameterUtility.GenerateXmlListParameter(Array)
         };
      }
   }

   public struct ScriptGroupStartParameters : ICommandParameters {
      public string User;
      public int Identifier;
      public int Environment;

      #region ICommandParameters Members
      ActionIdentifierEnum ICommandParameters.UniqueIdentifier {
         get { return ActionIdentifierEnum.ScriptGroupStart; }
      }

      string ICommandParameters.StoredProcedureName {
         get { return "p_cmd_start_scriptgroup"; }
      }

      SqlParameter[] ICommandParameters.GetParameters() {
         return new SqlParameter[] {
            new SqlParameter("@i_action", ((ICommandParameters)this).UniqueIdentifier),
            new SqlParameter("@vc_user", User),
            new SqlParameter("@i_script_group", Identifier),
            new SqlParameter("@i_environment", Environment)
         };
      }
      #endregion
   }

   public partial class ParameterUtility {
      public static SqlParameter IntParameter(string name, int value) {
         SqlParameter result = new SqlParameter(name, SqlDbType.Int);
         result.Value = value;
         return result;
      }

      public static SqlXml GenerateXmlList(object[] objects) {
         XmlDocument doc = new XmlDocument();
         doc.LoadXml("<?xml version='1.0' ?><root />");

         if (null != objects) {
            foreach (object o in objects) {
               XmlElement node = doc.CreateElement("item");
               node.InnerText = o.ToString();
               doc.DocumentElement.AppendChild(node);
            }
         }

         using (StringReader Reader = new StringReader(doc.DocumentElement.OuterXml)) {
            return new SqlXml(XmlTextReader.Create(Reader));
         }
      }

      public static SqlParameter GenerateXmlListParameter(string name, object[] objects) {
         return new SqlParameter(name, GenerateXmlList(objects));
      }

      public static SqlParameter GenerateXmlListParameter(object[] objects) {
         return GenerateXmlListParameter("xml_list", objects);
      }

      public static object[] PrepareArray<T>(T[] values) {
         object[] Results = null;

         if (null != values) {
            Results = new object[values.Length];
            for (int c = 0; c < Results.Length; c++)
               Results[c] = values[c];
         }

         return Results;
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\common\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\common\unit_Control.cs ===
namespace WSMCommon.Control {
   #region Using Directives
   using LiveServiceMonitor.Test;
   using System.Data.SqlClient;
   using System;
   using System.Collections.Generic;
   using System.Data;
   #endregion

   internal struct BVTDataField {
      public BVTDataField(string name, object value, Type type) {
         this.name = name;
         this.value = value;
         this.type = type;
      }

      public BVTDataField(string name, object value) : this(name, value, value.GetType()) { }

      public string Name { get { return name; } }
      public object Value { get { return value; } }
      public Type Type { get { return type; } }

      private string name;
      private object value;
      private Type type;
   }

   internal class BVTDataRecord : IDataRecord {
      public BVTDataRecord(params BVTDataField[] fields) {
         this.fields   = new List<BVTDataField>();

         if (null != fields) {
            foreach (BVTDataField field in fields)
               AddField(field);
         }
      }

      public void AddField(BVTDataField field) {
         if (string.IsNullOrEmpty(field.Name))
            throw new ArgumentNullException("field.Name");
         if (null == field.Type)
            throw new ArgumentNullException("field.Type");

         for (int c = 0; c < fields.Count; c++) {
            if (fields[c].Name == field.Name) {
               fields[c] = field;
               return;
            }
         }

         fields.Add(field);
      }

      
      #region IDataRecord Members
      public int FieldCount {
         get { return fields.Count; }
      }

      public T Get<T>(int i) { return (T)fields[i].Value; }
      
      public bool GetBoolean(int i) { return Get<bool>(i); }
      public byte GetByte(int i) { return Get<byte>(i); }
      public char GetChar(int i) { return Get<char>(i); }
      public DateTime GetDateTime(int i) { return Get<DateTime>(i); }
      public decimal GetDecimal(int i) { return Get<decimal>(i); }
      public double GetDouble(int i) { return Get<double>(i); }
      public float GetFloat(int i) { return Get<float>(i); }
      public Guid GetGuid(int i) { return Get<Guid>(i); }
      public short GetInt16(int i) { return Get<short>(i); }
      public int GetInt32(int i) { return Get<int>(i); }
      public long GetInt64(int i) { return Get<long>(i); }
      public string GetString(int i) { return Get<string>(i); }
      public object GetValue(int i) { return Get<object>(i); }
      public long GetBytes(int i, long fieldOffset, byte[] buffer, int bufferoffset, int length) {
         List<byte> Array = new List<byte>(Get<byte[]>(i));
         int offset = (int)fieldOffset;
         length = Math.Max(0, Array.Count - offset);
         Array.CopyTo(offset, buffer, bufferoffset, length);
         return length;
      }
      public long GetChars(int i, long fieldOffset, char[] buffer, int bufferoffset, int length) {
         List<char> Array = new List<char>(Get<char[]>(i));
         int offset = (int)fieldOffset;
         length = Math.Max(0, Array.Count - offset);
         Array.CopyTo(offset, buffer, bufferoffset, length);
         return length;
      }

      public bool IsDBNull(int i) { return fields[i].Value == null; }

      public string GetDataTypeName(int i) { return fields[i].Type.Name; }
      public Type GetFieldType(int i) { return fields[i].Type; }
      public string GetName(int i) { return fields[i].Name; }

      public int GetOrdinal(string name) {
         if (string.IsNullOrEmpty(name))
            throw new ArgumentException("name cannot be null or empty.", "name");

         for (int c=0; c<fields.Count; c++)
            if (fields[c].Name == name)
               return c;
         
         throw new IndexOutOfRangeException(string.Format("column: {0} does not exist", name));
      }

      public int GetValues(object[] values) {
         if (null == values)
            throw new ArgumentNullException("values");

         for (int c = 0; c < values.Length; c++) {
            if (c >= fields.Count)
               values[c] = null;

            values[c] = Get<object>(c);
         }

         return values.Length;
      }

      public object this[string name] { get { return Get<object>(GetOrdinal(name)); } }
      public object this[int i] { get { return Get<object>(i); } }

      #region Unsupported Methods
      public IDataReader GetData(int i) { throw new Exception("The method or operation is not implemented."); }
      #endregion

      #endregion

      private List<BVTDataField> fields;
   }

   internal partial class InformationBuilder : UnitTest {
      public InformationBuilder() : base("Information Builder Functionality") {
         DelegatedUnitTestLeaf[] PopulationTests = new DelegatedUnitTestLeaf[] {
            new DelegatedUnitTestLeaf("Aspect Population From Data Record", new NodeTestDelegate(ut_AspectPopulate)),
            new DelegatedUnitTestLeaf("Aspect Group Population From Data Record", new NodeTestDelegate(ut_AspectGroupPopulate)),
            new DelegatedUnitTestLeaf("Service Population From Data Record", new NodeTestDelegate(ut_ServicePopulate)),
            new DelegatedUnitTestLeaf("Script Group Population From Data Record", new NodeTestDelegate(ut_ScriptGroupPopulate)),
            new DelegatedUnitTestLeaf("Environment Population From Data Record", new NodeTestDelegate(ut_EnvironmentPopulate)),
            new DelegatedUnitTestLeaf("Script Instance Population From Data Record", new NodeTestDelegate(ut_ScriptInstancePopulate)),
            new DelegatedUnitTestLeaf("Environment Instance Population From Data Record", new NodeTestDelegate(ut_EnvironmentInstancePopulate)),
            new DelegatedUnitTestLeaf("Status Name Population From Data Record", new NodeTestDelegate(ut_StatusNamePopulate))
         };

         unitTests.AddRange(PopulationTests);
      }

      #region Unit Test Helper Methods
      private T _TestObject<T>(IDataRecord record) where T : struct {
         return PopulateObject<T>(record);
      }

      private string _PopulateFailed(Exception e) {
         return string.Format("Unable to populate AspectInformation: exception={0}", e);
      }

      private string _UnexpectedValue(string name, object value) {
         return string.Format("Unexpected value for '{0}': value={1}", name, value);
      }
      #endregion

      private bool ut_AspectPopulate(out string message) {
         AspectInformation X;
         
         try {
            BVTDataRecord Record = new BVTDataRecord(
               new BVTDataField("i_aspect", 1),
               new BVTDataField("vc_name", "name"),
               new BVTDataField("vc_assembly", "assembly"),
               new BVTDataField("vc_type", "type")
            );

            X = _TestObject<AspectInformation>(Record);
         }
         catch (Exception e) {
            message = _PopulateFailed(e);
            return false;
         }

         bool Success = true;
         message = "";

         if (1 != X.Identifier) {
            message += _UnexpectedValue("Identifier", X.Identifier);
            Success = false;
         }
         if ("name" != X.Name) {
            message += _UnexpectedValue("Name", X.Name ?? "(null)");
            Success = false;
         }
         if ("assembly" != X.Assembly) {
            message += _UnexpectedValue("Assembly", X.Assembly ?? "(null)");
            Success = false;
         }
         if ("type" != X.TypeName) {
            message += _UnexpectedValue("TypeName", X.TypeName ?? "(null)");
            Success = false;
         }

         return Success;
      }
      
      private bool ut_AspectGroupPopulate(out string message) {
         AspectGroupInformation X;
         
         try {
            BVTDataRecord Record = new BVTDataRecord(
               new BVTDataField("i_aspect_group", 1),
               new BVTDataField("vc_name", "name"),
               new BVTDataField("vc_description", "description")
            );

            X = _TestObject<AspectGroupInformation>(Record);
         }
         catch (Exception e) {
            message = _PopulateFailed(e);
            return false;
         }

         bool Success = true;
         message = "";
         if (1 != X.Identifier) {
            message += _UnexpectedValue("Identifier", X.Identifier);
            Success = false;
         }
         if ("name" != X.Name) {
            message += _UnexpectedValue("Name", X.Name ?? "(null)");
            Success = false;
         }
         if ("description" != X.Description) {
            message += _UnexpectedValue("Description", X.Description ?? "(null)");
            Success = false;
         }

         return Success;
      }
      
      private bool ut_ServicePopulate(out string message) {
         ServiceInformation X;

         try {
            BVTDataRecord Record = new BVTDataRecord(
               new BVTDataField("i_service", 1),
               new BVTDataField("i_aspect_group", 2),
               new BVTDataField("vc_protocol", "protocol"),
               new BVTDataField("vc_alias", "alias"),
               new BVTDataField("vc_host", "host"),
               new BVTDataField("bi_flags", 3L)
            );

            X = _TestObject<ServiceInformation>(Record);
         }
         catch (Exception e) {
            message = _PopulateFailed(e);
            return false;
         }

         bool Success = true;
         message = "";
         if (1 != X.Identifier) {
            message += _UnexpectedValue("Identifier", X.Identifier);
            Success = false;
         }
         if (2 != X.AspectGroup) {
            message += _UnexpectedValue("AspectGroup", X.AspectGroup);
            Success = false;
         }
         if ("protocol" != X.Protocol) {
            message += _UnexpectedValue("Protocol", X.Protocol ?? "(null)");
            Success = false;
         }
         if ("alias" != X.Alias) {
            message += _UnexpectedValue("Alias", X.Alias ?? "(null)");
            Success = false;
         }
         if ("host" != X.Host) {
            message += _UnexpectedValue("Host", X.Host ?? "(null)");
            Success = false;
         }
         if (3 != X.Flag) {
            message += _UnexpectedValue("Flag", X.Flag.HasValue ? X.Flag.Value.ToString() : "(null)");
            Success = false;
         }
         return Success;
      }
      
      private bool ut_ScriptGroupPopulate(out string message) {
         ScriptGroupInformation X;

         try {
            BVTDataRecord Record = new BVTDataRecord(
               new BVTDataField("i_script_group", 1),
               new BVTDataField("vc_name", "name"),
               new BVTDataField("vc_description", "description"),
               new BVTDataField("i_period", 2),
               new BVTDataField("bi_flags", 3L),
               new BVTDataField("xml_scripts", "<group id=\"1\"><script id=\"1\"/><script id=\"2\"/></group>")
            );

            X = _TestObject<ScriptGroupInformation>(Record);
         }
         catch (Exception e) {
            message = _PopulateFailed(e);
            return false;
         }

         bool Success = true;
         message = "";
         if (1 != X.Identifier) {
            message += _UnexpectedValue("Identifier", X.Identifier);
            Success = false;
         }
         if ("name" != X.Name) {
            message += _UnexpectedValue("Name", X.Name ?? "(null)");
            Success = false;
         }
         if ("description" != X.Description) {
            message += _UnexpectedValue("Description", X.Description ?? "(null)");
            Success = false;
         }
         if (2 != X.Period) {
            message += _UnexpectedValue("Period", X.Period.HasValue ? X.Period.Value.ToString() : "(null)");
            Success = false;
         }
         if (3 != X.Flag) {
            message += _UnexpectedValue("Flag", X.Flag.HasValue ? X.Flag.Value.ToString() : "(null)");
            Success = false;
         }

         List<int> Scripts = new List<int>(X.Scripts ?? new int[0]);
         if (!(Scripts.Count == 2 && Scripts.Contains(1) && Scripts.Contains(2))) {
            message += _UnexpectedValue("Scripts",
               string.Join(", ", Scripts.ConvertAll<string>(delegate(int x) { return x.ToString(); }).ToArray()));
            Success = false;
         }

         return Success;
      }

      private bool ut_ScriptPopulate(out string message) {
         ScriptInformation X;

         try {
            BVTDataRecord Record = new BVTDataRecord(
               new BVTDataField("i_script", 1),
               new BVTDataField("vc_alias", "alias"),
               new BVTDataField("txt_source", "source"),
               new BVTDataField("i_period", 2),
               new BVTDataField("bi_flags", 3)
            );

            X = _TestObject<ScriptInformation>(Record);
         }
         catch (Exception e) {
            message = _PopulateFailed(e);
            return false;
         }

         bool Success = true;
         message = "";
         if (1 != X.Identifier) {
            message += _UnexpectedValue("Identifier", X.Identifier);
            Success = false;
         }
         if ("alias" != X.Alias) {
            message += _UnexpectedValue("Alias", X.Alias ?? "(null)");
            Success = false;
         }
         if ("source" != X.SourceCode) {
            message += _UnexpectedValue("SourceCode", X.SourceCode ?? "(null)");
            Success = false;
         }
         if (2 != X.Period) {
            message += _UnexpectedValue("Period", X.Period.HasValue ? X.Period.Value.ToString() : "(null)");
            Success = false;
         }
         if (3 != X.Flag) {
            message += _UnexpectedValue("Flag", X.Flag.HasValue ? X.Flag.Value.ToString() : "(null)");
            Success = false;
         }

         return Success;
      }

      private bool ut_EnvironmentPopulate(out string message) {
         EnvironmentInformation X;

         try {
            BVTDataRecord Record = new BVTDataRecord(
               new BVTDataField("i_environment", 1),
               new BVTDataField("vc_name", "name"),
               new BVTDataField("vc_version", "1.00.00"),
               new BVTDataField("vc_host", "host"),
               new BVTDataField("vc_description", "description"),
               new BVTDataField("vc_cert", "cert.pfx"),
               new BVTDataField("i_aspect_group_test", 2),
               new BVTDataField("i_aspect_group_general", 3)
            );

            X = _TestObject<EnvironmentInformation>(Record);
         }
         catch (Exception e) {
            message = _PopulateFailed(e);
            return false;
         }

         bool Success = true;
         message = "";
         if (1 != X.Identifier) {
            message += _UnexpectedValue("Identifier", X.Identifier);
            Success = false;
         }
         if ("name" != X.Name) {
            message += _UnexpectedValue("Name", X.Name ?? "(null)");
            Success = false;
         }
         if ("1.00.00" != X.Version) {
            message += _UnexpectedValue("Version", X.Version ?? "(null)");
            Success = false;
         }
         if ("host" != X.Host) {
            message += _UnexpectedValue("Host", X.Host ?? "(null)");
            Success = false;
         }
         if ("description" != X.Description) {
            message += _UnexpectedValue("Description", X.Description ?? "(null)");
            Success = false;
         }
         if ("cert.pfx" != X.Certificate) {
            message += _UnexpectedValue("Certificate", X.Certificate ?? "(null)");
            Success = false;
         }
         if (2 != X.TestAspectGroup) {
            message += _UnexpectedValue("TestAspectGroup", X.TestAspectGroup);
            Success = false;
         }
         if (3 != X.GeneralAspectGroup) {
            message += _UnexpectedValue("GeneralAspectGroup", X.GeneralAspectGroup);
            Success = false;
         }
         return Success;
      }
      
      private bool ut_ScriptInstancePopulate(out string message) {
         ScriptInstance X;

         try {
            BVTDataRecord Record = new BVTDataRecord(
               new BVTDataField("bi_script", 1),
               new BVTDataField("bi_environment", 2),
               new BVTDataField("i_script", 3),
               new BVTDataField("vc_name", "name"),
               new BVTDataField("i_status", 4),
               new BVTDataField("xml_report", "<report />")
            );

            X = _TestObject<ScriptInstance>(Record);
         }
         catch (Exception e) {
            message = _PopulateFailed(e);
            return false;
         }

         bool Success = true;
         message = "";
         if (1 != X.Instance) {
            message += _UnexpectedValue("Instance", X.Instance);
            Success = false;
         }
         if (2 != X.EnvironmentInstance) {
            message += _UnexpectedValue("EnvironmentInstance", X.EnvironmentInstance);
            Success = false;
         }
         if (3 != X.Script) {
            message += _UnexpectedValue("Script", X.Script);
            Success = false;
         }
         if ("name" != X.Name) {
            message += _UnexpectedValue("Name", X.Name ?? "(null)");
            Success = false;
         }
         if (4 != X.Status) {
            message += _UnexpectedValue("Status", X.Status);
            Success = false;
         }
         if (null == X.Report || "<report/>" != X.Report.Value.Replace(" ","")) {
            message += _UnexpectedValue("Report",
               null == X.Report ? "(null)" : (X.Report.Value ?? "(null-value)"));
            Success = false;
         }

         return Success;
      }

      private bool ut_EnvironmentInstancePopulate(out string message) {
         EnvironmentInstance X;

         try {
            BVTDataRecord Record = new BVTDataRecord(
               new BVTDataField("bi_environment", 1),
               new BVTDataField("i_environment", 2),
               new BVTDataField("vc_name", "name"),
               new BVTDataField("i_status", 3)
            );

            X = _TestObject<EnvironmentInstance>(Record);
         }
         catch (Exception e) {
            message = _PopulateFailed(e);
            return false;
         }

         bool Success = true;
         message = "";
         if (1 != X.Instance) {
            message += _UnexpectedValue("Instance", X.Instance);
            Success = false;
         }
         if (2 != X.Environment) {
            message += _UnexpectedValue("Environment", X.Environment);
            Success = false;
         }
         if ("name" != X.Name) {
            message += _UnexpectedValue("Name", X.Name ?? "(null)");
            Success = false;
         }
         if (3 != X.Status) {
            message += _UnexpectedValue("Status", X.Status);
            Success = false;
         }

         return Success;
      }

      private bool ut_StatusNamePopulate(out string message) {
         StatusName X;

         try {
            BVTDataRecord Record = new BVTDataRecord(
               new BVTDataField("i_status", 1),
               new BVTDataField("vc_name", "name"),
               new BVTDataField("vc_description", "description")
            );

            X = _TestObject<StatusName>(Record);
         }
         catch (Exception e) {
            message = _PopulateFailed(e);
            return false;
         }

         bool Success = true;
         message = "";
         if (1 != X.Status) {
            message += _UnexpectedValue("Status", X.Status);
            Success = false;
         }
         if ("name" != X.Name) {
            message += _UnexpectedValue("Name", X.Name ?? "(null)");
            Success = false;
         }
         if ("description" != X.Description) {
            message += _UnexpectedValue("Description", X.Description ?? "(null)");
            Success = false;
         }

         return Success;
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\extensions\http\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\common\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_lsmcommon_none_12.4.56.0_none_5ca0e3d0800ab6ee
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_lsmcommon_no-public-key_12.4.56.0_x-ww_45d5ef94
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=lsmcommon
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_lsmcommon_no-public-key_12.4.56.0_x-ww_45d5ef94
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_lsmcommon_no-public-key_12.4.56.0_x-ww_45d5ef94.manifest
XP_MANIFEST_PATH=manifests\msil_lsmcommon_no-public-key_12.4.56.0_x-ww_45d5ef94.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_lsmcommon_no-public-key_12.4.56.0_x-ww_45d5ef94.cat
XP_CATALOG_PATH=manifests\msil_lsmcommon_no-public-key_12.4.56.0_x-ww_45d5ef94.cat
XP_PAYLOAD_PATH=msil_lsmcommon_no-public-key_12.4.56.0_x-ww_45d5ef94
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=lsmcommon,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\common\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_lsmcommon_none_12.4.56.0_none_5ca0e3d0800ab6ee
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_lsmcommon_no-public-key_12.4.56.0_x-ww_45d5ef94
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=lsmcommon
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_lsmcommon_no-public-key_12.4.56.0_x-ww_45d5ef94
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_lsmcommon_no-public-key_12.4.56.0_x-ww_45d5ef94.manifest
XP_MANIFEST_PATH=manifests\msil_lsmcommon_no-public-key_12.4.56.0_x-ww_45d5ef94.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_lsmcommon_no-public-key_12.4.56.0_x-ww_45d5ef94.cat
XP_CATALOG_PATH=manifests\msil_lsmcommon_no-public-key_12.4.56.0_x-ww_45d5ef94.cat
XP_PAYLOAD_PATH=msil_lsmcommon_no-public-key_12.4.56.0_x-ww_45d5ef94
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=lsmcommon,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\extensions\http\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\extensions\http\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\extensions\http\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xonline.tools.lsmonitor.extensions.http_none_12.4.56.0_none_1b1bb3bd8a1cd7c8
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xonline.tools.lsmonitor.extensions.http_no-public-key_12.4.56.0_x-ww_9af185d4
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xonline.tools.lsmonitor.extensions.http
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xonline.tools.lsmonitor.extensions.http_no-public-key_12.4.56.0_x-ww_9af185d4
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xonline.tools.lsmonitor.extensions.http_no-public-key_12.4.56.0_x-ww_9af185d4.manifest
XP_MANIFEST_PATH=manifests\msil_xonline.tools.lsmonitor.extensions.http_no-public-key_12.4.56.0_x-ww_9af185d4.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xonline.tools.lsmonitor.extensions.http_no-public-key_12.4.56.0_x-ww_9af185d4.cat
XP_CATALOG_PATH=manifests\msil_xonline.tools.lsmonitor.extensions.http_no-public-key_12.4.56.0_x-ww_9af185d4.cat
XP_PAYLOAD_PATH=msil_xonline.tools.lsmonitor.extensions.http_no-public-key_12.4.56.0_x-ww_9af185d4
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xonline.tools.lsmonitor.extensions.http,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\extensions\idcrl\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\extensions\http\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xonline.tools.lsmonitor.extensions.http_none_12.4.56.0_none_1b1bb3bd8a1cd7c8
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xonline.tools.lsmonitor.extensions.http_no-public-key_12.4.56.0_x-ww_9af185d4
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xonline.tools.lsmonitor.extensions.http
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xonline.tools.lsmonitor.extensions.http_no-public-key_12.4.56.0_x-ww_9af185d4
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xonline.tools.lsmonitor.extensions.http_no-public-key_12.4.56.0_x-ww_9af185d4.manifest
XP_MANIFEST_PATH=manifests\msil_xonline.tools.lsmonitor.extensions.http_no-public-key_12.4.56.0_x-ww_9af185d4.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xonline.tools.lsmonitor.extensions.http_no-public-key_12.4.56.0_x-ww_9af185d4.cat
XP_CATALOG_PATH=manifests\msil_xonline.tools.lsmonitor.extensions.http_no-public-key_12.4.56.0_x-ww_9af185d4.cat
XP_PAYLOAD_PATH=msil_xonline.tools.lsmonitor.extensions.http_no-public-key_12.4.56.0_x-ww_9af185d4
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xonline.tools.lsmonitor.extensions.http,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\extensions\http\HttpHelper.cs ===
namespace xonline.tools.lsmonitor.extensions.http {
   #region Using Directives
   using System;
   using System.Text;

   using System.IO;
   using System.Net;
   using System.Collections.Specialized;

   using System.Xml;
   using System.Xml.Serialization;
   using System.Runtime.Serialization;
   #endregion

   public static class HttpHelper {
      #region Helper Methods
      private static byte[] getAsciiBytes(string content) {
         ASCIIEncoding Encoding;
         Encoding = new ASCIIEncoding();
         return Encoding.GetBytes(content);
      }

      private static void writeRequestContents(HttpWebRequest request, string content) {
         using (Stream inputStream = request.GetRequestStream()) {
            using (StreamWriter streamWriter = new StreamWriter(inputStream)) {
               streamWriter.Write(content);
            }
         }
      }
      #endregion

      /// <summary>
      /// Creates a joined request modifier, which chains execution of the specified request modifiers.
      /// </summary>
      /// <param name="requestModifiers">Delegate used to modify the request before send.</param>
      /// <returns>The joined request modifier.</returns>
      public static Action<HttpWebRequest> JoinRequestModifiers(
         params Action<HttpWebRequest>[] requestModifiers) 
      {
         Action<HttpWebRequest> JoinedModifiers;

         JoinedModifiers = delegate(HttpWebRequest request) {
            if (null != requestModifiers) {
               foreach (Action<HttpWebRequest> requestModifier in requestModifiers) {
                  if (null != requestModifier)
                     requestModifier(request);
               }
            }
         };

         return JoinedModifiers;
      }

      /// <summary>
      /// Send an http request to the specified uri.
      /// </summary>
      /// <param name="uri">Target uri for the request.</param>
      /// <param name="requestModifier">Delegate used to modify the request before send.</param>
      /// <returns>An HttpWebResponse object representing the HTTP Response.</returns>
      public static HttpWebResponse SendHttpRequest(
         string uri,
         Action<HttpWebRequest> requestModifier) 
      {
         HttpWebRequest Request;
         UriBuilder UriBuilder;

         if (null == requestModifier)
            throw new ArgumentNullException("requestModifier");

         UriBuilder = new UriBuilder(uri);
         Request = (HttpWebRequest)WebRequest.Create(UriBuilder.Uri.ToString());
         requestModifier(Request);

         return (HttpWebResponse)Request.GetResponse();
      }

      private static HttpWebResponse sendHttpMethodRequest(
         string uri,
         string method,
         Action<HttpWebRequest> requestModifier) 
      {
         Action<HttpWebRequest> AdjustedModifier;

         AdjustedModifier = JoinRequestModifiers(
            delegate(HttpWebRequest request) { request.Method = method; },
            requestModifier
            );

         return SendHttpRequest(
            uri,
            AdjustedModifier);
      }

      /// <summary>
      /// Sends an http GET request to the specified uri.
      /// </summary>
      /// <param name="uri">Target uri for the request.</param>
      /// <param name="requestModifier">Delegate used to modify the request before send, this can be null.</param>
      /// <returns>An HttpWebResponse object representing the HTTP Response.</returns>
      public static HttpWebResponse SendHttpGetRequest(
         string uri,
         Action<HttpWebRequest> requestModifier) 
      {
         return sendHttpMethodRequest(uri, "GET", requestModifier);
      }

      /// <summary>
      /// Sends an http GET request to the specified uri.
      /// </summary>
      /// <param name="uri">Target uri for the requestion.</param>
      /// <returns>An HttpWebResponse object representing the HTTP Response.</returns>
      public static HttpWebResponse SendHttpGetRequest(string uri) {
         return SendHttpGetRequest(uri, null);
      }

      private static Action<HttpWebRequest> createBasicModifier(
         string contentType,
         string content,
         NameValueCollection header)
      {
         Action<HttpWebRequest> Modifier;

         Modifier = delegate(HttpWebRequest request) {
            if (null != header) {
               foreach (string key in header.AllKeys)
                  request.Headers[key] = header[key];
            }

            if (!string.IsNullOrEmpty(content)) {
               request.ContentType = contentType;
               writeRequestContents(request, content);
            }
         };

         return Modifier;
      }

      /// <summary>
      /// Sends an http GET request to the specified uri.
      /// </summary>
      /// <param name="uri">Target uri for the requestion.</param>
      /// <param name="contentType">Content type associated with body of the request, this is ignored if content is null.</param>
      /// <param name="content">Content body for the request, this can be null.</param>
      /// <param name="header">Key value pairs to inject into the request header, this can be null.</param>
      /// <param name="requestModifier">Delegate used to modify the request before send, this can be null.</param>
      /// <returns>An HttpWebResponse object representing the HTTP Response.</returns>
      public static HttpWebResponse SendHttpGetRequest(
         string uri,
         string contentType,
         string content,
         NameValueCollection header,
         Action<HttpWebRequest> requestModifier) 
      {
         Action<HttpWebRequest> Modifier;

         Modifier = JoinRequestModifiers(
            createBasicModifier(contentType, content, header),
            requestModifier);

         return SendHttpGetRequest(uri, Modifier);
      }

      /// <summary>
      /// Sends an http POST request to the specified uri.
      /// </summary>
      /// <param name="uri">Target uri for the request.</param>
      /// <param name="requestModifier">Delegate used to modify the request before send, this can be null.</param>
      /// <returns>An HttpWebResponse object representing the HTTP Response.</returns>
      public static HttpWebResponse SendHttpPostRequest(
         string uri,
         Action<HttpWebRequest> requestModifier) 
      {
         return sendHttpMethodRequest(uri, "POST", requestModifier);
      }

      /// <summary>
      /// Sends an http GET request to the specified uri.
      /// </summary>
      /// <param name="uri">Target uri for the requestion.</param>
      /// <returns>An HttpWebResponse object representing the HTTP Response.</returns>
      public static HttpWebResponse SendHttpPostRequest(string uri) {
         return SendHttpPostRequest(uri, null);
      }

      /// <summary>
      /// Sends an http POST request to the specified uri.
      /// </summary>
      /// <param name="uri">Target uri for the requestion.</param>
      /// <param name="contentType">Content type associated with body of the request, this is ignored if content is null.</param>
      /// <param name="content">Content body for the request, this can be null.</param>
      /// <param name="header">Key value pairs to inject into the request header, this can be null.</param>
      /// <param name="requestModifier">Delegate used to modify the request before send, this can be null.</param>
      /// <returns>An HttpWebResponse object representing the HTTP Response.</returns>
      public static HttpWebResponse SendHttpPostRequest(
         string uri,
         string contentType,
         string content,
         NameValueCollection header,
         Action<HttpWebRequest> requestModifier) 
      {
         Action<HttpWebRequest> Modifier;

         Modifier = JoinRequestModifiers(
            createBasicModifier(contentType, content, header),
            requestModifier);

         return SendHttpPostRequest(uri, Modifier);
      }

      /// <summary>
      /// Converts the response stream into a byte array and closes the response.
      /// </summary>
      /// <param name="response">An unconsumed HttpWebResponse returned by a http request.</param>
      /// <returns>A byte[] representation of the contents of the response.</returns>
      /// <remarks>A request can only be consumed once, doing so more than once will result in a WebException (ConnectionLost).</remarks>
      /// <exception cref="WebException">An error was encountered while reading the response stream.</exception>
      public static byte[] ConsumeResponseAsBinary(HttpWebResponse response) {
         try {
            using (Stream responseStream = response.GetResponseStream()) {
               using (MemoryStream outputBuffer = new MemoryStream()) {
                  byte[] Buffer;
                  int BytesRead;

                  Buffer = new byte[256];
                  while ((BytesRead = responseStream.Read(Buffer, 0, Buffer.Length)) > 0)
                     outputBuffer.Write(Buffer, 0, BytesRead);

                  return outputBuffer.ToArray();
               }
            }
         }
         finally {
            response.Close();
         }
      }

      /// <summary>
      /// Converts the response stream into a string and closes the response.
      /// </summary>
      /// <param name="response">An unconsumed HttpWebResponse returned by a http request.</param>
      /// <returns>A string representation of the contents of the response.</returns>
      /// <remarks>A request can only be consumed once, doing so more than once will result in a WebException (ConnectionLost).</remarks>
      /// <exception cref="WebException">An error was encountered while reading the response stream.</exception>
      public static string ConsumeResponseAsString(HttpWebResponse response) {
         ASCIIEncoding Encoding;
         Encoding = new ASCIIEncoding();
         return Encoding.GetString(ConsumeResponseAsBinary(response));
      }

      /// <summary>
      /// Converts the response stream into xml and closes the response.
      /// </summary>
      /// <param name="response">An unconsumed HttpWebResponse returned by a http request.</param>
      /// <returns>An XmlDocument representing the contents of the response.</returns>
      /// <remarks>A request can only be consumed once, doing so more than once will result in a WebException (ConnectionLost).</remarks>
      /// <exception cref="WebException">An error was encountered while reading the response stream.</exception>
      /// <exception cref="XmlException">The response is not a valid xml document.  Note, not all HTML documents are valid XML documents.</exception>
      public static XmlDocument ConsumeResponseAsXml(HttpWebResponse response) {
         XmlDocument Document;
         Document = new XmlDocument();
         Document.LoadXml(ConsumeResponseAsString(response));
         return Document;
      }

      /// <summary>
      /// Converts the response stream into a serialized object and closes the response.
      /// </summary>
      /// <param name="response">An unconsumed HttpWebResponse returned by a http request.</param>
      /// <param name="type">Type to serialize the content body to.</param>
      /// <returns>A serialized object representation of the response.</returns>
      /// <remarks>A request can only be consumed once, doing so more than once will result in a WebException (ConnectionLost).</remarks>
      /// <exception cref="WebException">An error was encountered while reading the response stream.</exception>
      /// <exception cref="InvalidOperationException">An error was encountered while deserializing the stream.  This is likely to be a result of an invalidly formatted response.</exception>
      public static object ConsumeResponseAsSerializedObject(HttpWebResponse response, Type type) {
         try {
            XmlSerializer Serializer;
            Serializer = new XmlSerializer(type);
            return Serializer.Deserialize(response.GetResponseStream());
         }
         finally {
            response.Close();
         }
      }

      /// <summary>
      /// Converts the response stream into a serialized object and closes the response.
      /// </summary>
      /// <typeparam name="T">Type to serialize the content body to.</typeparam>
      /// <param name="response">An unconsumed HttpWebResponse returned by a http request.</param>
      /// <returns>A serialized T representation of the response.</returns>
      /// <remarks>A request can only be consumed once, doing so more than once will result in a WebException (ConnectionLost).</remarks>
      /// <exception cref="WebException">An error was encountered while reading the response stream.</exception>
      /// <exception cref="InvalidOperationException">An error was encountered while deserializing the stream.  This is likely to be a result of an invalidly formatted response.</exception>
      public static T ConsumeResponseAsSerializedObject<T>(HttpWebResponse response) {
         return (T)ConsumeResponseAsSerializedObject(response, typeof(T));
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\extensions\idcrl\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\common\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("wsmCommon")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("wsmCommon")]
[assembly: AssemblyCopyright("Copyright © Microsoft 2007")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("5db1d2c7-2d63-4024-b0fd-4624a264a269")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\extensions\idcrl\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\extensions\idcrl\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xonline.tools.lsmonitor.extensions.idcrl_none_12.4.56.0_none_991da32db9291d70
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xonline.tools.lsmonitor.extensions.idcrl_no-public-key_12.4.56.0_x-ww_b7c7923c
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xonline.tools.lsmonitor.extensions.idcrl
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xonline.tools.lsmonitor.extensions.idcrl_no-public-key_12.4.56.0_x-ww_b7c7923c
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xonline.tools.lsmonitor.extensions.idcrl_no-public-key_12.4.56.0_x-ww_b7c7923c.manifest
XP_MANIFEST_PATH=manifests\msil_xonline.tools.lsmonitor.extensions.idcrl_no-public-key_12.4.56.0_x-ww_b7c7923c.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xonline.tools.lsmonitor.extensions.idcrl_no-public-key_12.4.56.0_x-ww_b7c7923c.cat
XP_CATALOG_PATH=manifests\msil_xonline.tools.lsmonitor.extensions.idcrl_no-public-key_12.4.56.0_x-ww_b7c7923c.cat
XP_PAYLOAD_PATH=msil_xonline.tools.lsmonitor.extensions.idcrl_no-public-key_12.4.56.0_x-ww_b7c7923c
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xonline.tools.lsmonitor.extensions.idcrl,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\extensions\xml\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\extensions\idcrl\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xonline.tools.lsmonitor.extensions.idcrl_none_12.4.56.0_none_991da32db9291d70
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xonline.tools.lsmonitor.extensions.idcrl_no-public-key_12.4.56.0_x-ww_b7c7923c
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xonline.tools.lsmonitor.extensions.idcrl
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xonline.tools.lsmonitor.extensions.idcrl_no-public-key_12.4.56.0_x-ww_b7c7923c
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xonline.tools.lsmonitor.extensions.idcrl_no-public-key_12.4.56.0_x-ww_b7c7923c.manifest
XP_MANIFEST_PATH=manifests\msil_xonline.tools.lsmonitor.extensions.idcrl_no-public-key_12.4.56.0_x-ww_b7c7923c.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xonline.tools.lsmonitor.extensions.idcrl_no-public-key_12.4.56.0_x-ww_b7c7923c.cat
XP_CATALOG_PATH=manifests\msil_xonline.tools.lsmonitor.extensions.idcrl_no-public-key_12.4.56.0_x-ww_b7c7923c.cat
XP_PAYLOAD_PATH=msil_xonline.tools.lsmonitor.extensions.idcrl_no-public-key_12.4.56.0_x-ww_b7c7923c
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xonline.tools.lsmonitor.extensions.idcrl,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\extensions\xml\Exceptions.cs ===
using System;
using System.Collections.Generic;
using System.Text;

namespace xonline.tools.lsmonitor.extensions.xml {
   #region Using Directives
   using System;
   using System.Runtime.Serialization;
   #endregion

   [Serializable]
   public class EntryMissingException : Exception {
      public EntryMissingException() { }
      public EntryMissingException(string xpath) 
         : this(xpath, null, null) { }
      public EntryMissingException(string xpath, string message) 
         : this(xpath, message, null) { }
      public EntryMissingException(string xpath, Exception inner) 
         : this(xpath, null, inner) { }
      public EntryMissingException(string xpath, string message, Exception inner)
         : base(message, inner) 
      {
         this.xpath = xpath;
      }

      protected EntryMissingException(SerializationInfo info, StreamingContext context)
         : base(info, context) { }

      private string xpath;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\extensions\idcrl\IdcrlHelper.cs ===
namespace xonline.tools.lsmonitor.extensions.idcrl {
   #region Using Directives
   using System;
   using System.Collections.Generic;
   using System.Text;
   using Microsoft.Passport.Test.Ppcrl;
   #endregion

   public class IdcrlHelper : IDisposable {
      public readonly static Guid   DefaultApplicationGuid = new Guid("28880461-ed9b-4911-b691-474503c690e7");
      public readonly static int    DefaultPPCRLVersion    = 1;
      public readonly static string DefaultProxyUserInfo   = "int";

      private Guid         _applicationGuid;
      private int          _ppcrlVersion;
      private string       _proxyUserInfo;
      private ManagedIDCRL _managedIDCRL;

      public IdcrlHelper(Guid applicationGuid, int ppcrlVersion, string proxyUserInfo) {
         if (null == proxyUserInfo)
            throw new ArgumentException("proxyUserInfo");

         _applicationGuid = applicationGuid;
         _ppcrlVersion    = ppcrlVersion;
         _proxyUserInfo   = proxyUserInfo;

         Initialize();
      }

      public IdcrlHelper() 
         : this(DefaultApplicationGuid, DefaultPPCRLVersion, DefaultProxyUserInfo) { }

      public void Dispose() {
         if (null == _managedIDCRL)
            return;

         lock (_managedIDCRL) {
            if (null != _managedIDCRL) {
               _managedIDCRL.Uninitialize();
               _managedIDCRL = null;
            }
         }
      }

      private void Initialize() {
         ManagedIDCRL.Initialize_Options[] options;

         options = new ManagedIDCRL.Initialize_Options[1];
         options[0].optionType = ManagedIDCRL.IDCRL_OPTION_ID.IDCRL_OPTION_ENVIRONMENT;
         options[0].proxyUserInfo = _proxyUserInfo;

         _managedIDCRL = new ManagedIDCRL();

         _managedIDCRL.InitializeEx(
            ref _applicationGuid,
            _ppcrlVersion,
            (uint)ManagedIDCRL.UpdateFlag.DEFAULT_UPDATE_POLICY,
            options);
      }

      public string GetRpsTicket(string user, string password, string partner, string policy) {
         ManagedIDCRL.AuthState authState;
         int                    identity = -1;

         if (string.IsNullOrEmpty(user))
            throw new ArgumentException("user");
         if (null == password)
            throw new ArgumentException("password");
         if (null == partner)
            throw new ArgumentException("partner");
         if (string.IsNullOrEmpty(policy))
            throw new ArgumentException("policy");

         try {
            _managedIDCRL.CreateIdentityHandle(user, (uint)ManagedIDCRL.IdentityFlag.IDENTITY_SHARE_ALL, out identity);
            _managedIDCRL.SetCredential(identity, ManagedIDCRL.PPCRL_CREDTYPE_PASSWORD, password);
            _managedIDCRL.LogonIdentity(identity, null, (uint)ManagedIDCRL.LogonFlag.LOGONIDENTITY_DEFAULT);
            _managedIDCRL.AuthIdentityToService(identity, partner, policy, (uint)ManagedIDCRL.ServiceTokenFlags.SERVICE_TOKEN_REQUEST_TYPE_NONE, out authState);
         }
         finally {
            if (-1 != identity)
               _managedIDCRL.CloseIdentityHandle(identity);
         }

         return authState.Token;
      }

      public static string GetRpsTicket(Guid applicationGuid, int ppcrlVersion, string user, string password, string partner, string policy, string proxyUserInfo) {
         using (IdcrlHelper helper = new IdcrlHelper(applicationGuid, ppcrlVersion, proxyUserInfo)) {
            return helper.GetRpsTicket(user, password, partner, policy);
         }
      }

      public static string GetRpsTicket(string user, string password, string partner, string policy, string proxyUserInfo) {
         return GetRpsTicket(DefaultApplicationGuid, DefaultPPCRLVersion, user, password, partner, policy, proxyUserInfo);
      }

      public Guid ApplicationGuid {
         get { return _applicationGuid; }
      }

      public int PPCRLVersion {
         get { return _ppcrlVersion; }
      }

      public ManagedIDCRL ManagedIDCRL {
         get { return _managedIDCRL; }
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\extensions\xml\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\extensions\xml\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xonline.tools.lsmonitor.extensions.xml_none_12.4.56.0_none_881dc0172f13876d
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xonline.tools.lsmonitor.extensions.xml_no-public-key_12.4.56.0_x-ww_5ea99d91
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xonline.tools.lsmonitor.extensions.xml
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xonline.tools.lsmonitor.extensions.xml_no-public-key_12.4.56.0_x-ww_5ea99d91
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xonline.tools.lsmonitor.extensions.xml_no-public-key_12.4.56.0_x-ww_5ea99d91.manifest
XP_MANIFEST_PATH=manifests\msil_xonline.tools.lsmonitor.extensions.xml_no-public-key_12.4.56.0_x-ww_5ea99d91.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xonline.tools.lsmonitor.extensions.xml_no-public-key_12.4.56.0_x-ww_5ea99d91.cat
XP_CATALOG_PATH=manifests\msil_xonline.tools.lsmonitor.extensions.xml_no-public-key_12.4.56.0_x-ww_5ea99d91.cat
XP_PAYLOAD_PATH=msil_xonline.tools.lsmonitor.extensions.xml_no-public-key_12.4.56.0_x-ww_5ea99d91
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xonline.tools.lsmonitor.extensions.xml,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\extensions\xml\XmlHelper.cs ===
namespace xonline.tools.lsmonitor.extensions.xml {
   #region Using Directives
   using System;
   using System.Collections.Generic;
   using System.Text;
   using System.Xml;
   using System.Xml.XPath;
   #endregion

   public class XmlHelper {
      public static XmlDocument CreateDocument(string xml) {
         XmlDocument Document;
         Document = new XmlDocument();
         Document.LoadXml(xml);
         return Document;
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\extensions\xml\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\extensions\http\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("http")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("http")]
[assembly: AssemblyCopyright("Copyright © Microsoft 2007")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("fde999ad-ee4d-4f20-bc86-c687f3a3ae34")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\extensions\xml\XmlParser.cs ===
namespace xonline.tools.lsmonitor.extensions.xml {
   #region Using Directives
   using System;
   using System.Collections.Generic;
   using System.Collections.Specialized;
   using System.Text;
   using System.Xml;
   using System.Xml.XPath;
   #endregion

   public class XmlParser {
      public static XmlParser CreateInstance(IXPathNavigable navigationTarget, IXmlNamespaceResolver namespaceResolver) {
         if (null == navigationTarget)
            throw new ArgumentNullException("navigationTarget");
         if (null == namespaceResolver)
            throw new ArgumentNullException("namespaceResolver");

         return new XmlParser(navigationTarget, namespaceResolver);
      }

      public static XmlParser CreateInstance(XmlDocument targetDocument) {
         XmlNamespaceManager Manager;
         
         if (null == targetDocument)
            throw new ArgumentNullException("targetDocument");

         Manager = new XmlNamespaceManager(targetDocument.NameTable);
         return CreateInstance(targetDocument, Manager);
      }

      public static XmlParser CreateInstance(XmlDocument targetDocument, NameValueCollection namespaceTable) {
         XmlNamespaceManager Manager;

         if (null == targetDocument)
            throw new ArgumentNullException("targetDocument");
         if (null == namespaceTable)
            throw new ArgumentNullException("namespaceTable");

         Manager = new XmlNamespaceManager(targetDocument.NameTable);
         foreach (string prefix in namespaceTable)
            Manager.AddNamespace(prefix, namespaceTable[prefix]);

         return CreateInstance(targetDocument, Manager);
      }

      private XmlParser(IXPathNavigable navigationTarget, IXmlNamespaceResolver namespaceResolver) {
         this.navigationTarget = navigationTarget;
         this.namespaceResolver = namespaceResolver;
      }

      private static XPathNodeIterator createXPathIterator(IXPathNavigable navigationRoot, IXmlNamespaceResolver namespaceResolver, string path) {
         XPathNavigator Navigator;
         Navigator = navigationRoot.CreateNavigator();
         return (null == namespaceResolver) ? Navigator.Select(path) : Navigator.Select(path, namespaceResolver);
      }

      #region Static Methods
      public static IEnumerable<string> ReadAllElements(IXPathNavigable navigationRoot, IXmlNamespaceResolver namespaceResolver, string path) {
         XPathNodeIterator Iterator;

         if (null == navigationRoot)
            throw new ArgumentNullException("navigationRoot");
         if (string.IsNullOrEmpty(path))
            throw new ArgumentException("cannot be null or empty", "path");

         Iterator = createXPathIterator(navigationRoot, namespaceResolver, path);

         while (Iterator.MoveNext())
            yield return Iterator.Current.OuterXml;
      }

      public static string ReadFirstElement(IXPathNavigable navigationRoot, IXmlNamespaceResolver namespaceResolver, string path) {
         foreach (string result in ReadAllElements(navigationRoot, namespaceResolver, path))
            return result;

         throw new EntryMissingException(path);
      }

		public static IEnumerable<string> ReadAllEntries(IXPathNavigable navigationRoot, IXmlNamespaceResolver namespaceResolver, string path) {
         XPathNodeIterator Iterator;

         if (null == navigationRoot)
            throw new ArgumentNullException("navigationRoot");
         if (string.IsNullOrEmpty(path))
            throw new ArgumentException("cannot be null or empty", "path");

         Iterator = createXPathIterator(navigationRoot, namespaceResolver, path);

         while (Iterator.MoveNext())
            yield return Iterator.Current.InnerXml;
      }

      public static IEnumerable<string> ReadAllEntries(IXPathNavigable navigationRoot, string path) {
         return ReadAllEntries(navigationRoot, null, path);
      }

      public static string ReadFirstEntry(IXPathNavigable navigationRoot, IXmlNamespaceResolver namespaceResolver, string path) {
         foreach (string result in ReadAllEntries(navigationRoot, namespaceResolver, path))
            return result;

         throw new EntryMissingException(path);
      }

      public static string ReadFirstEntry(IXPathNavigable navigationRoot, string path) {
         foreach (string result in ReadAllEntries(navigationRoot, path))
            return result;

         throw new EntryMissingException(path);
      }

      public static string ReadFirstEntry(IXPathNavigable navigationRoot, IXmlNamespaceResolver namespaceResolver, string path, string @default) {
         foreach (string result in ReadAllEntries(navigationRoot, namespaceResolver, path))
            return result;

         return @default;
      }

      public static string ReadFirstEntry(IXPathNavigable navigationRoot, string path, string @default) {
         foreach (string result in ReadAllEntries(navigationRoot, path))
            return result;

         return @default;
      }

      public static IEnumerable<T> ReadAllEntries<T>(IXPathNavigable navigationRoot, IXmlNamespaceResolver namespaceResolver, string path) {
         foreach (string result in ReadAllEntries(navigationRoot, namespaceResolver, path))
            yield return (T)Convert.ChangeType(result, typeof(T));
      }

      public static IEnumerable<T> ReadAllEntries<T>(IXPathNavigable navigationRoot, string path) {
         foreach (string result in ReadAllEntries(navigationRoot, path))
            yield return (T)Convert.ChangeType(result, typeof(T));
      }

      public static T ReadFirstEntry<T>(IXPathNavigable navigationRoot, IXmlNamespaceResolver namespaceResolver, string path) {
         return (T)Convert.ChangeType(ReadFirstEntry(navigationRoot, namespaceResolver, path), typeof(T));
      }

      public static T ReadFirstEntry<T>(IXPathNavigable navigationRoot, string path) {
         return (T)Convert.ChangeType(ReadFirstEntry(navigationRoot, path), typeof(T));
      }

      public static T ReadFirstEntry<T>(IXPathNavigable navigationRoot, IXmlNamespaceResolver namespaceResolver, string path, T @default) {
         foreach (T result in ReadAllEntries<T>(navigationRoot, namespaceResolver, path))
            return result;

         return @default;
      }

      public static T ReadFirstEntry<T>(IXPathNavigable navigationRoot, string path, T @default) {
         foreach (T result in ReadAllEntries<T>(navigationRoot, path))
            return result;

         return @default;
      }
	   #endregion

      #region Instance Methods
      public IEnumerable<string> ReadAllElements(string path) {
         return XmlParser.ReadAllElements(navigationTarget, namespaceResolver, path);
      }

      public string ReadFirstElement(string path) {
         return XmlParser.ReadFirstElement(navigationTarget, namespaceResolver, path);
      }

      public IEnumerable<string> ReadAllEntries(string path) {
         return XmlParser.ReadAllEntries(navigationTarget, namespaceResolver, path);
      }

      public string ReadFirstEntry(string path) {
         return XmlParser.ReadFirstEntry(navigationTarget, namespaceResolver, path);
      }

      public string ReadFirstEntry(string path, string @default) {
         return XmlParser.ReadFirstEntry(navigationTarget, namespaceResolver, path, @default);
      }

      public IEnumerable<T> ReadAllEntries<T>(string path) {
         return XmlParser.ReadAllEntries<T>(navigationTarget, namespaceResolver, path);
      }

      public T ReadFirstEntry<T>(string path) {
         return XmlParser.ReadFirstEntry<T>(navigationTarget, namespaceResolver, path);
      }

      public T ReadFirstEntry<T>(string path, T @default) {
         return XmlParser.ReadFirstEntry<T>(navigationTarget, namespaceResolver, path, @default);
      }
      #endregion

      #region Exposed Properties
      public IXmlNamespaceResolver NamespaceResolver {
         get { return this.namespaceResolver; }
         set { this.namespaceResolver = value; }
      }

      public IXPathNavigable NavigationTarget {
         get { return this.navigationTarget; }
         set { this.navigationTarget = value; }
      }
      #endregion

      private IXmlNamespaceResolver namespaceResolver;
      private IXPathNavigable navigationTarget;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\extensions\xonline.catalog\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\extensions\idcrl\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("idcrl")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("idcrl")]
[assembly: AssemblyCopyright("Copyright © Microsoft 2007")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("a62c4e44-1c45-4898-98b5-649a560ca946")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\extensions\xml\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xonline.tools.lsmonitor.extensions.xml_none_12.4.56.0_none_881dc0172f13876d
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xonline.tools.lsmonitor.extensions.xml_no-public-key_12.4.56.0_x-ww_5ea99d91
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xonline.tools.lsmonitor.extensions.xml
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xonline.tools.lsmonitor.extensions.xml_no-public-key_12.4.56.0_x-ww_5ea99d91
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xonline.tools.lsmonitor.extensions.xml_no-public-key_12.4.56.0_x-ww_5ea99d91.manifest
XP_MANIFEST_PATH=manifests\msil_xonline.tools.lsmonitor.extensions.xml_no-public-key_12.4.56.0_x-ww_5ea99d91.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xonline.tools.lsmonitor.extensions.xml_no-public-key_12.4.56.0_x-ww_5ea99d91.cat
XP_CATALOG_PATH=manifests\msil_xonline.tools.lsmonitor.extensions.xml_no-public-key_12.4.56.0_x-ww_5ea99d91.cat
XP_PAYLOAD_PATH=msil_xonline.tools.lsmonitor.extensions.xml_no-public-key_12.4.56.0_x-ww_5ea99d91
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xonline.tools.lsmonitor.extensions.xml,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\extensions\xonline.catalog\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\extensions\xonline.catalog\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xonline.tools.lsmon..ons.xonline.catalog_none_12.4.56.0_none_2c57809dcc81cd00
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xonline.tools.lsmonitor.extensions.xonline.catalog_no-public-key_12.4.56.0_x-ww_bb802c70
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xonline.tools.lsmonitor.extensions.xonline.catalog
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xonline.tools.lsmonitor.extensions.xonline.catalog_no-public-key_12.4.56.0_x-ww_bb802c70
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xonline.tools.lsmonitor.extensions.xonline.catalog_no-public-key_12.4.56.0_x-ww_bb802c70.manifest
XP_MANIFEST_PATH=manifests\msil_xonline.tools.lsmonitor.extensions.xonline.catalog_no-public-key_12.4.56.0_x-ww_bb802c70.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xonline.tools.lsmonitor.extensions.xonline.catalog_no-public-key_12.4.56.0_x-ww_bb802c70.cat
XP_CATALOG_PATH=manifests\msil_xonline.tools.lsmonitor.extensions.xonline.catalog_no-public-key_12.4.56.0_x-ww_bb802c70.cat
XP_PAYLOAD_PATH=msil_xonline.tools.lsmonitor.extensions.xonline.catalog_no-public-key_12.4.56.0_x-ww_bb802c70
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xonline.tools.lsmonitor.extensions.xonline.catalog,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\extensions\xonline.catalog\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\sanitysvc\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\extensions\xonline.catalog\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xonline.tools.lsmon..ons.xonline.catalog_none_12.4.56.0_none_2c57809dcc81cd00
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xonline.tools.lsmonitor.extensions.xonline.catalog_no-public-key_12.4.56.0_x-ww_bb802c70
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xonline.tools.lsmonitor.extensions.xonline.catalog
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xonline.tools.lsmonitor.extensions.xonline.catalog_no-public-key_12.4.56.0_x-ww_bb802c70
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xonline.tools.lsmonitor.extensions.xonline.catalog_no-public-key_12.4.56.0_x-ww_bb802c70.manifest
XP_MANIFEST_PATH=manifests\msil_xonline.tools.lsmonitor.extensions.xonline.catalog_no-public-key_12.4.56.0_x-ww_bb802c70.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xonline.tools.lsmonitor.extensions.xonline.catalog_no-public-key_12.4.56.0_x-ww_bb802c70.cat
XP_CATALOG_PATH=manifests\msil_xonline.tools.lsmonitor.extensions.xonline.catalog_no-public-key_12.4.56.0_x-ww_bb802c70.cat
XP_PAYLOAD_PATH=msil_xonline.tools.lsmonitor.extensions.xonline.catalog_no-public-key_12.4.56.0_x-ww_bb802c70
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xonline.tools.lsmonitor.extensions.xonline.catalog,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\sanitysvc\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\extensions\xml\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("xml")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("xml")]
[assembly: AssemblyCopyright("Copyright © Microsoft 2007")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("68cd087e-9781-41ff-bb1b-48981f497730")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\extensions\xonline.catalog\CatalogAPI.cs ===
namespace xonline.tools.lsmonitor.extensions.xonline.catalog {
   #region Using Directives
   using System;
   using System.Collections.Generic;
   using System.Collections.Specialized;
   using System.Text;
   using System.Xml;
   using System.Net;
   using http;
   #endregion

   public static class CatalogAPI {
      private static void addParameter(List<Pair> target, string name, object value) {
         target.Add(new Pair(name, value));
      }

      private static void addComplexParameter(List<Pair> target, string name, object value) {
         addParameter(target, "Names", name);
         addParameter(target, "Values", value);
      }

      private static void addComplexParameter<T>(List<Pair> target, string name, Nullable<T> value) 
         where T:struct
      {
         if (value.HasValue)
            addComplexParameter(target, name, value.Value);
      }

      private static string buildQueryString(List<Pair> parameters) {
         List<string> Parameters;
         Parameters = new List<string>();
         Parameters.AddRange(parameters.ConvertAll<string>(delegate(Pair p) { return p.ToString(); }));
         return "/Query?" + string.Join("&", Parameters.ToArray());
      }

      public static NameValueCollection GetNamespaceTable() {
         NameValueCollection NamespaceTable;
         NamespaceTable = new NameValueCollection();
         NamespaceTable.Add("ns", "http://www.w3.org/2005/Atom");
         NamespaceTable.Add("live", "http://www.live.com/marketplace");
         return NamespaceTable;
      }

      public static XmlDocument SendGenericQuery(string catalogUrl, List<Pair> parameters) {
         HttpWebResponse QueryResponse;
         string QueryString;

         if (string.IsNullOrEmpty(catalogUrl))
            throw new ArgumentException("cannot be null or empty", "catalogUrl");
         if (null == parameters)
            throw new ArgumentException("parameters");

         QueryString = buildQueryString(parameters);
         QueryResponse = HttpHelper.SendHttpGetRequest(catalogUrl + QueryString);

         return HttpHelper.ConsumeResponseAsXml(QueryResponse);
      }

      public static XmlDocument SendGenericQuery(
         string catalogUrl,
         string methodName,
         params Pair[] nameValueParameters) 
      {
         List<Pair> Parameters;

         if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("cannot be null or empty", "methodName");

         Parameters = new List<Pair>();
         addParameter(Parameters, "methodName", methodName);
         if (null != nameValueParameters) {
            foreach (Pair nameValue in nameValueParameters)
               addComplexParameter(Parameters, nameValue.Name, nameValue.Value);
         }

         return SendGenericQuery(catalogUrl, Parameters);
      }

      public static XmlDocument SendGenericQuery(
         string catalogUrl,
         string methodName,
         string locale,
         string legalLocal,
         int? store,
         int? pageSize,
         int? pageNumber,
         int? detailView,
         int? offerFilterLevel,
         int? mediaTypes,
         int? imageTypeIds,
         int? imageFormats,
         int? imageSizes,
         int? orderBy,
         int? orderDirection,
         Guid? mediaId) 
      {
         List<Pair> Parameters;

         if (string.IsNullOrEmpty(methodName))
            throw new ArgumentException("cannot be null or empty", "methodName");

         Parameters = new List<Pair>();
         addParameter(Parameters, "methodName", methodName);
         addComplexParameter(Parameters, "Locale", locale);
         addComplexParameter(Parameters, "LegalLocale", legalLocal);
         addComplexParameter<int>(Parameters, "Store", store);
         addComplexParameter<int>(Parameters, "PageSize", pageSize);
         addComplexParameter<int>(Parameters, "PageNum", pageNumber);
         addComplexParameter<int>(Parameters, "DetailView", detailView);
         addComplexParameter<int>(Parameters, "OfferFilterLevel", offerFilterLevel);
         addComplexParameter<int>(Parameters, "MediaTypes", mediaTypes);
         addComplexParameter<int>(Parameters, "ImageTypeIds", imageTypeIds);
         addComplexParameter<int>(Parameters, "ImageSizes", imageSizes);
         addComplexParameter<int>(Parameters, "OrderBy", orderBy);
         addComplexParameter<int>(Parameters, "OrderDirection", orderDirection);
         if (mediaId.HasValue)
            addComplexParameter(Parameters, "MediaIds", mediaId.Value);

         return SendGenericQuery(catalogUrl, Parameters);
      }

      public struct Pair {
         public Pair(string name, object value) {
            Name = name;
            Value = value;
         }

         public override string  ToString() {
 	         return string.Format("{0}={1}", Name, Value);
         }

         public string Name;
         public object Value;
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\sanitysvc\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\sanitysvc\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_sanity-svc_none_12.4.56.0_none_1cecd459ad94d93c
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_sanity-svc_no-public-key_12.4.56.0_x-ww_9e3a2744
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=sanity-svc
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_sanity-svc_no-public-key_12.4.56.0_x-ww_9e3a2744
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_sanity-svc_no-public-key_12.4.56.0_x-ww_9e3a2744.manifest
XP_MANIFEST_PATH=manifests\msil_sanity-svc_no-public-key_12.4.56.0_x-ww_9e3a2744.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_sanity-svc_no-public-key_12.4.56.0_x-ww_9e3a2744.cat
XP_CATALOG_PATH=manifests\msil_sanity-svc_no-public-key_12.4.56.0_x-ww_9e3a2744.cat
XP_PAYLOAD_PATH=msil_sanity-svc_no-public-key_12.4.56.0_x-ww_9e3a2744
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=sanity-svc,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\sanitysvc\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_sanity-svc_none_12.4.56.0_none_1cecd459ad94d93c
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_sanity-svc_no-public-key_12.4.56.0_x-ww_9e3a2744
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=sanity-svc
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_sanity-svc_no-public-key_12.4.56.0_x-ww_9e3a2744
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_sanity-svc_no-public-key_12.4.56.0_x-ww_9e3a2744.manifest
XP_MANIFEST_PATH=manifests\msil_sanity-svc_no-public-key_12.4.56.0_x-ww_9e3a2744.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_sanity-svc_no-public-key_12.4.56.0_x-ww_9e3a2744.cat
XP_CATALOG_PATH=manifests\msil_sanity-svc_no-public-key_12.4.56.0_x-ww_9e3a2744.cat
XP_PAYLOAD_PATH=msil_sanity-svc_no-public-key_12.4.56.0_x-ww_9e3a2744
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=sanity-svc,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\sanitysvc\App_Code\Service.cs ===
using System;
using System.Web;
using System.Web.Services;
using System.Web.Services.Protocols;

[WebService(Namespace = "http://tempuri.org/")]
[WebServiceBinding(ConformsTo = WsiProfiles.BasicProfile1_1)]
public class Service : System.Web.Services.WebService {
   public Service() {
      //Uncomment the following line if using designed components 
      //InitializeComponent(); 
   }

   [WebMethod]
   public string ReturnString(string value) {
      return value;
   }

   [WebMethod]
   public int ReturnInteger(int value) {
      return value;
   }

   [WebMethod]
   public void Exception() {
      throw new Exception("Sanity Exception");
   }

   [WebMethod]
   public void Sleep(int msecs) {
      System.Threading.Thread.Sleep(msecs);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\extensions\xonline.catalog\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("xonline.catalog")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("xonline.catalog")]
[assembly: AssemblyCopyright("Copyright © Microsoft 2007")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("f13729e1-7b0b-4295-a3c0-38f035b63330")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\scripts\catalog\Catalog.FeedValidate.cs ===
namespace Scripts {
   #region Using Directives
   using System;
   using System.Xml;
   using System.Collections.Specialized;
   using WSMonitor.Framework.Scripting;
   using WSMonitor.Framework.Reporting;

   using xonline.tools.lsmonitor.extensions.xonline.catalog;
   using xonline.tools.lsmonitor.extensions.xml;
   using Pair = xonline.tools.lsmonitor.extensions.xonline.catalog.CatalogAPI.Pair;
   #endregion

   [ScriptMetadata("Test")]
   public class Catalog_FeedValidate : Script {
      private XmlParser createCatalogResultParser(XmlDocument catalogResults) {
         NameValueCollection NamespaceTable;
         NamespaceTable = CatalogAPI.GetNamespaceTable();
         return XmlParser.CreateInstance(catalogResults, NamespaceTable);
      }

      [Native.Start]
      public bool FeedValidate(object xmlFeed) {
         XmlParser FeedParser;

         string FeedTitle;
         int FeedTotalItems, FeedNumItems;

         if (xmlFeed is XmlDocument)
            FeedParser = createCatalogResultParser((XmlDocument)xmlFeed);
         else
            FeedParser = (XmlParser)xmlFeed;

         FeedTitle = FeedParser.ReadFirstEntry("/ns:feed/ns:title");
         FeedTotalItems = FeedParser.ReadFirstEntry<int>("/ns:feed/live:totalItems");
         FeedNumItems = FeedParser.ReadFirstEntry<int>("/ns:feed/live:numItems");

         Report.WriteProperty("Feed.Title", FeedTitle);
         Report.WriteProperty("Feed.TotalItems", FeedTotalItems);
         Report.WriteProperty("Feed.NumItems", FeedNumItems);

         if (0 == FeedTotalItems) {
            Report.ErrorMessage("totalItems is 0");
            return false;
         }

         if (0 == FeedNumItems) {
            Report.ErrorMessage("numItems is 0");
            return false;
         }

         return true;
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\scripts\catalog\Catalog.FindPodcasts.cs ===
namespace Scripts {
   #region Using Directives
   using System;
   using System.Xml;
   using System.Collections.Generic;
   using System.Collections.Specialized;
   using WSMonitor.Framework.Scripting;
   using WSMonitor.Framework.Reporting;

   using xonline.tools.lsmonitor.extensions.xonline.catalog;
   using xonline.tools.lsmonitor.extensions.xml;
   using Pair = xonline.tools.lsmonitor.extensions.xonline.catalog.CatalogAPI.Pair;
   #endregion

   [ScriptMetadata("Test")]
   public class Catalog_FindPodcasts : Script {
      private readonly string catalogUrl = string.Format("http://{0}:12020/Catalog/Catalog.asmx", HostEnvironment);

      private XmlParser createCatalogResultParser(XmlDocument catalogResults) {
         NameValueCollection NamespaceTable;
         NamespaceTable = CatalogAPI.GetNamespaceTable();
         return XmlParser.CreateInstance(catalogResults, NamespaceTable);
      }

      [Native.Start]
      public bool FindPodcasts(string title, int category, int podcastType) {
         XmlDocument PodcastFeed;
         XmlParser FeedParser;

         Report.WriteProperty("param:Title", title);
         Report.WriteProperty("param:Category", category);
         Report.WriteProperty("param:PodcastType", podcastType);

         PodcastFeed = CatalogAPI.SendGenericQuery(
            catalogUrl,
            "FindPodcasts",
            new Pair("Locale", "en-us"),
            new Pair("LegalLocale", "en-us"),
            new Pair("PageSize", 50),
            new Pair("PageNum", 1),
            new Pair("DetailView", 5),
            //new Pair("CategoryIds", category),
            new Pair("PodcastType", podcastType));

         FeedParser = createCatalogResultParser(PodcastFeed);
         if (false == (bool)Execute("Catalog.FeedValidate", FeedParser))
            return false;
         else {
            return (bool)Execute(
               "Catalog.FindPodcastFTS", 
               FeedParser.ReadFirstEntry("/ns:feed/ns:entry/ns:title"));
         }
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\scripts\catalog\Catalog.FindPodcastFTS.cs ===
namespace Scripts {
   #region Using Directives
   using System;
   using System.Xml;
   using System.Collections.Generic;
   using System.Collections.Specialized;
   using WSMonitor.Framework.Scripting;

   using xonline.tools.lsmonitor.extensions.xonline.catalog;
   using xonline.tools.lsmonitor.extensions.xml;
   using Pair = xonline.tools.lsmonitor.extensions.xonline.catalog.CatalogAPI.Pair;
   #endregion

   [ScriptMetadata("Test")]
   public class Catalog_FindPodcastsFTS : Script {
      private readonly string catalogUrl = string.Format("http://{0}/Catalog/CatalogFTS.asmx", HostEnvironment);

      [Native.Start]
      public bool FindPodcastFTS(string query) {
         XmlDocument PodcastResult;

         PodcastResult = CatalogAPI.SendGenericQuery(
            catalogUrl,
            "FindPodcastsFTS",
            new Pair("Query", query),
            new Pair("RankingType", 0),
            new Pair("Locale", "en-us"),
            new Pair("LegalLocale", "en-us"),
            new Pair("PageSize", 50),
            new Pair("PageNum", 1),
            new Pair("DetailView", 5),
            new Pair("PodcastType", 4),
            new Pair("OrderBy", 1),
            new Pair("OrderDirection", 1)
         );

         return (bool)Execute("Catalog.FeedValidate", PodcastResult);
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\scripts\catalog\Catalog.FindMedia.cs ===
namespace Scripts {
   #region Using Directives
   using System;
   using System.Xml;
   using System.Collections.Generic;
   using WSMonitor.Framework.Scripting;
   using WSMonitor.Framework.Reporting;

   using xonline.tools.lsmonitor.extensions.xml;
   using xonline.tools.lsmonitor.extensions.xonline.catalog;
   using Pair = xonline.tools.lsmonitor.extensions.xonline.catalog.CatalogAPI.Pair;
   #endregion

   [ScriptMetadata("Test")]
   public class Catalog_FindMedia : Script {
      private readonly string catalogUrl = string.Format("http://{0}/Catalog/Catalog.asmx", HostEnvironment);

      [Native.Start]
      public bool FindMedia(string title, List<Pair> accumulatedParameters, int category, int mediaType) {
         Report.WriteProperty("param:Title", title);
         Report.WriteProperty("param:Category", category);
         Report.WriteProperty("param:MediaType", mediaType);

         bool TestResult = true;

         try { TestResult &= testTopVideo(accumulatedParameters.ToArray(), mediaType, category); }
         catch { TestResult = false; }
         try { TestResult &= testNewVideo(accumulatedParameters.ToArray(), mediaType, category); }
         catch { TestResult = false; }
         try { TestResult &= testAllVideo(accumulatedParameters.ToArray(), mediaType, category); }
         catch { TestResult = false; }

         return TestResult;
      }

      private bool testTopVideo(Pair[] accumulatedParameters, int mediaType, int category) {
         return (bool)Execute("Catalog.FindVideos", "Top Videos", accumulatedParameters, mediaType, category, 4, 2);
      }

      private bool testNewVideo(Pair[] accumulatedParameters, int mediaType, int category) {
         return (bool)Execute("Catalog.FindVideos", "Newly Released Videos", accumulatedParameters, mediaType, category, 2, 2);
      }

      private bool testAllVideo(Pair[] accumulatedParameters, int mediaType, int category) {
         return (bool)Execute("Catalog.FindVideos", "All Videos", accumulatedParameters, mediaType, category, 1, 1);
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\scripts\catalog\Catalog.FindVideos.cs ===
namespace Scripts {
   #region Using Directives
   using System;
   using System.Xml;
   using System.Collections.Generic;
   using System.Collections.Specialized;
   using WSMonitor.Framework.Scripting;
   using WSMonitor.Framework.Reporting;

   using xonline.tools.lsmonitor.extensions.xonline.catalog;
   using xonline.tools.lsmonitor.extensions.xml;
   using Pair = xonline.tools.lsmonitor.extensions.xonline.catalog.CatalogAPI.Pair;
   #endregion

   [ScriptMetadata("Test")]
   public class Catalog_FindVideos : Script {
      private readonly string catalogUrl = string.Format("http://{0}/Catalog/Catalog.asmx", HostEnvironment);
      private List<Pair> queryParameters = null;

      private XmlParser createCatalogResultParser(XmlDocument catalogResults) {
         NameValueCollection NamespaceTable;
         NamespaceTable = CatalogAPI.GetNamespaceTable();
         return XmlParser.CreateInstance(catalogResults, NamespaceTable);
      }

      [Native.Start]
      public bool FindVideos(string title, Pair[] accumulatedParameters, int mediaType, int categoryId, int orderBy, int orderDirection) {
         Report.WriteProperty("param:Title", title);
         Report.WriteProperty("param:MediaType", mediaType);
         Report.WriteProperty("param:CategoryId", categoryId);
         Report.WriteProperty("param:OrderBy", orderBy);
         Report.WriteProperty("param:OrderDirection", orderDirection);

         return enumerateVideos(accumulatedParameters, mediaType, categoryId, orderBy, orderDirection);
      }

      public override void ExceptionNotification(Exception e) {
         base.ExceptionNotification(e);
         if (null != queryParameters) {
            for (int c = 0; c < queryParameters.Count; c++) {
               Report.WriteProperty(string.Format("Parameter-{0}", c),
                  string.Format("{0} = {1}", queryParameters[c].Name, queryParameters[c].Value));
            }
         }
      }


      private bool testOfferEnumerate(XmlDocument xmlFeed, int mediaType) {
         XmlParser FeedParser;
         string RawMediaId;
         string MediaId;
         string Title;

         FeedParser = createCatalogResultParser(xmlFeed);
         RawMediaId = FeedParser.ReadFirstEntry("/ns:feed/ns:entry/ns:id");
         Title = "Getting Video Offer";
         MediaId = RawMediaId.Substring(RawMediaId.LastIndexOf(':') + 1);

         return (bool)Execute("Catalog.FindVideoOffer", Title, MediaId, mediaType);
      }

      private bool enumerateVideos(Pair[] accumulatedParameters, int mediaType, int categoryId, int orderBy, int orderDirection) {
         XmlDocument XmlFeed;

         queryParameters = new List<Pair>(accumulatedParameters);
         queryParameters.Add(new Pair("UserTypes", 2));
         queryParameters.Add(new Pair("MediaTypes", mediaType));
         queryParameters.Add(new Pair("CategoryIds", categoryId));
         queryParameters.Add(new Pair("OrderBy", orderBy));
         queryParameters.Add(new Pair("OrderDirection", orderDirection));

         XmlFeed = CatalogAPI.SendGenericQuery(
            catalogUrl,
            "FindVideos",
            queryParameters.ToArray());

         if (false == (bool)Execute("Catalog.FeedValidate", XmlFeed))
            return false;

         return testOfferEnumerate(XmlFeed, mediaType);
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\scripts\catalog\Catalog.MonitorPodcasts.cs ===
namespace Scripts {
   #region Using Directives
   using System;
   using System.Xml;
   using System.Collections.Generic;
   using System.Collections.Specialized;
   using WSMonitor.Framework.Scripting;

   using xonline.tools.lsmonitor.extensions.xonline.catalog;
   using xonline.tools.lsmonitor.extensions.xml;
   using Pair = xonline.tools.lsmonitor.extensions.xonline.catalog.CatalogAPI.Pair;
   #endregion

   [ScriptMetadata("Test")]
   public class Catalog_MonitorPodcasts : Script {
      private readonly string catalogUrl = string.Format("http://{0}/Catalog/Catalog.asmx", HostEnvironment);

      [Native.Start]
      public bool Run() {
         return (bool)Execute("Catalog.FindPodcasts", "Entertainment Podcasts", 5004, 4);
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\scripts\catalog\Catalog.FindVideoOffer.cs ===
namespace Scripts {
   #region Using Directives
   using System;
   using System.Xml;
   using System.Collections.Generic;
   using System.Collections.Specialized;
   using WSMonitor.Framework.Scripting;
   using WSMonitor.Framework.Reporting;

   using xonline.tools.lsmonitor.extensions.xonline.catalog;
   using xonline.tools.lsmonitor.extensions.xml;
   using Pair = xonline.tools.lsmonitor.extensions.xonline.catalog.CatalogAPI.Pair;
   #endregion

   [ScriptMetadata("Test")]
   public class Catalog_FindVideoOffer : Script {
      private readonly string catalogUrl = string.Format("http://{0}/Catalog/Catalog.asmx", HostEnvironment);

      private XmlParser createCatalogResultParser(XmlDocument catalogResults) {
         NameValueCollection NamespaceTable;
         NamespaceTable = CatalogAPI.GetNamespaceTable();
         return XmlParser.CreateInstance(catalogResults, NamespaceTable);
      }

      [Native.Start]
      public bool FindVideoOffer(string title, string mediaId, int mediaType) {
         List<Pair> FindVideoOfferParameters;
         XmlDocument XmlFeed;

         Report.WriteProperty("param:Title", title);
         Report.WriteProperty("param:MediaId", mediaId);
         Report.WriteProperty("param:MediaType", mediaType);

         FindVideoOfferParameters = new List<Pair>();
         FindVideoOfferParameters.Add(new Pair("Locale", "en-us"));
         FindVideoOfferParameters.Add(new Pair("LegalLocale", "en-us"));
         FindVideoOfferParameters.Add(new Pair("Store", 1));
         FindVideoOfferParameters.Add(new Pair("PageSize", 100));
         FindVideoOfferParameters.Add(new Pair("PageNum", 1));
         FindVideoOfferParameters.Add(new Pair("DetailView", 3));
         FindVideoOfferParameters.Add(new Pair("MediaIds", mediaId));
         FindVideoOfferParameters.Add(new Pair("UserTypes", 2));
         FindVideoOfferParameters.Add(new Pair("MediaTypes", mediaType));

         XmlFeed = CatalogAPI.SendGenericQuery(
            catalogUrl,
            "FindVideoOffers",
            FindVideoOfferParameters.ToArray());

         return (bool)Execute("Catalog.FeedValidate", XmlFeed);
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\scripts\catalog\Catalog.MonitorCategories.cs ===
namespace Scripts {
   #region Using Directives
   using System;
   using System.Xml;
   using System.Collections.Generic;
   using System.Collections.Specialized;
   using WSMonitor.Framework.Scripting;

   using xonline.tools.lsmonitor.extensions.xonline.catalog;
   using xonline.tools.lsmonitor.extensions.xml;
   using Pair = xonline.tools.lsmonitor.extensions.xonline.catalog.CatalogAPI.Pair;
   #endregion

   [ScriptMetadata("Test")]
   public class Catalog_MonitorCategories : Script {
      private readonly string catalogUrl = string.Format("http://{0}/Catalog/Catalog.asmx", HostEnvironment);
      
      private enum MediaId : int {
         Movie = 2,
         PromotionalVideo = 39,
         Trailer = 32,
         TvEpisode = 8
      }

      private const int FilterOfferCategories = 2;
      private const int VideoCategorySystem = 1000;
      private const int NetworkCategorySystem = 7000;
      private const int PodcastCategorySystem = 5000;
      private const int StudioCategorySystem = 8000;
      private const int ExternalXboxCategorySystem = 11000;

      private XmlParser createCatalogResultParser(XmlDocument catalogResults) {
         NameValueCollection NamespaceTable;
         NamespaceTable = CatalogAPI.GetNamespaceTable();
         return XmlParser.CreateInstance(catalogResults, NamespaceTable);
      }

      private XmlParser getFeedCategory(XmlParser feedParser) {
         XmlDocument Result;

         Result = new XmlDocument();
         Result.LoadXml(feedParser.ReadFirstElement("/ns:feed/ns:entry/live:category"));

         return createCatalogResultParser(Result);
      }

      [Native.Start]
      public bool FindCategories() {
         bool MonitoringResult;
         List<Pair> AccumulationParameters;
         
         AccumulationParameters = new List<Pair>();
         AccumulationParameters.Add(new Pair("Locale", "en-us"));
         AccumulationParameters.Add(new Pair("LegalLocale", "en-us"));
         AccumulationParameters.Add(new Pair("Store", 1));
         AccumulationParameters.Add(new Pair("PageSize", 100));
         AccumulationParameters.Add(new Pair("PageNum", 1));
         AccumulationParameters.Add(new Pair("DetailView", 3));
         AccumulationParameters.Add(new Pair("OfferFilterLevel", FilterOfferCategories));

         MonitoringResult = true;
         MonitoringResult &= monitorVideoCategorySystem(AccumulationParameters.ToArray());
         MonitoringResult &= monitorNetworkCategorySystem(AccumulationParameters.ToArray());

         AccumulationParameters.RemoveAt(2);
         /*
         MonitoringResult &= monitorPodcastCategorySystem(
            AccumulationParameters.ToArray(),
            PodcastCategorySystem);
         */

         return MonitoringResult;
      }

      private bool monitorVideoCategorySystem(Pair[] accumulationParameters) {
         return monitorVideoCategorySystem(
            accumulationParameters,
            VideoCategorySystem,
            MediaId.TvEpisode);
      }

      private bool monitorNetworkCategorySystem(Pair[] accumulationParameters) {
         return monitorVideoCategorySystem(
            accumulationParameters,
            NetworkCategorySystem,
            MediaId.TvEpisode);
      }

      private bool getCategorySystem(
         string methodName,
         Pair[] parameters,
         int categorySystem,
         out XmlParser categoryParser) 
      {
         XmlDocument FeedResult;
         XmlParser FeedParser;
         List<Pair> FindCategories;

         categoryParser = null;

         FindCategories = new List<Pair>(parameters);
         FindCategories.Add(new Pair("CategorySystemId", categorySystem));

         FeedResult = CatalogAPI.SendGenericQuery(
            catalogUrl,
            "FindCategories",
            FindCategories.ToArray());
         FeedParser = createCatalogResultParser(FeedResult);

         if (false == (bool)Execute("Catalog.FeedValidate", FeedParser))
            return false;

         categoryParser = getFeedCategory(FeedParser);

         return true;
      }

      private bool monitorPodcastCategorySystem(
         Pair[] accumulationParameters,
         int categorySystem) 
      {
         XmlParser CategoryParser;
         bool MonitoringResults;

         MonitoringResults = getCategorySystem(
            "FindCategoriesZune",
            accumulationParameters,
            categorySystem,
            out CategoryParser);

         if (!MonitoringResults)
            return false;

         return testPodcast(CategoryParser, "All Podcasts", 4);
      }

      private bool monitorVideoCategorySystem(
         Pair[] accumulationParameters, 
         int categorySystem,
         params MediaId[] mediaTypes) 
      {
         XmlParser CategoryParser;
         bool MonitoringResult;

         MonitoringResult = getCategorySystem(
            "FindCategories", 
            accumulationParameters, 
            categorySystem, 
            out CategoryParser);

         if (!MonitoringResult)
            return false;

         foreach (MediaId mediaType in mediaTypes) {
            try { testMediaType(CategoryParser, accumulationParameters, mediaType.ToString(), (int)mediaType); }
            catch { MonitoringResult = false; }
         }

         return MonitoringResult;
      }

      private bool monitorPodcastType(
         string categoryName,
         int categoryId,
         string podcastTypeName,
         int podcastType)
      {
         string Title;
         Title = string.Format("{0} - {1}", categoryName, podcastTypeName);
         return (bool)Execute("Catalog.FindMedia",
            Title,
            categoryId,
            podcastTypeName);
      }

      private bool monitorCategorySystemMediaType(
         Pair[] accumulatedParameters, 
         string categoryName, 
         int categoryId, 
         string mediaTypeName, 
         int mediaTypeId) 
      {
         string Title;
         Title = string.Format("{0} - {1}", categoryName, mediaTypeName);
         return (bool)Execute("Catalog.FindMedia",
            Title,
            new List<Pair>(accumulatedParameters),
            categoryId,
            mediaTypeId);
      }

      private void getCategoryInformation(XmlParser categoryParser, out string categoryName, out int categoryId) {
         categoryName = categoryParser.ReadFirstEntry("/live:category/live:categoryName");
         categoryId = categoryParser.ReadFirstEntry<int>("/live:category/live:categoryId");
      }

      private bool testPodcast(
         XmlParser categoryParser,
         string podcastTypeName,
         int podcastType)
      {
         string CategoryName;
         int CategoryId;

         getCategoryInformation(categoryParser, out CategoryName, out CategoryId);

         return monitorPodcastType(
            CategoryName,
            CategoryId,
            podcastTypeName,
            podcastType);
      }

      private bool testMediaType(
         XmlParser categoryParser,
         Pair[] accumulatedParameters,
         string mediaTypeName, 
         int mediaTypeId)
      {
         string CategoryName;
         int CategoryId;

         getCategoryInformation(categoryParser, out CategoryName, out CategoryId);

         return monitorCategorySystemMediaType(
            accumulatedParameters,
            CategoryName,
            CategoryId,
            mediaTypeName,
            mediaTypeId);
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmFramework\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\scripts\catalog\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("scripts.catalog")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("scripts.catalog")]
[assembly: AssemblyCopyright("Copyright © Microsoft 2007")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("f54f21ff-c9db-4061-9b10-67da5d7f952a")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\sql\wsmcontroldb\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

SQLTARGET:
    -md %_NT386TREE%\xdb\wsmcontroldb
    for /f %i in ('dir /b *.sql') do type %i | perl -pe "s/\<\<BUILDNUMBER\>\>/%_BLDVERMAJOR%.%_BLDVERMINOR%.%_BLDNUMMAJOR%.%_BLDNUMMINOR%/" > %_NT386TREE%\xdb\wsmcontroldb\%i
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\sql\wsmconfigdb\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

SQLTARGET:
    -md %_NT386TREE%\xdb\wsmconfigdb
    for /f %i in ('dir /b *.sql') do type %i | perl -pe "s/\<\<BUILDNUMBER\>\>/%_BLDVERMAJOR%.%_BLDVERMINOR%.%_BLDNUMMAJOR%.%_BLDNUMMINOR%/" > %_NT386TREE%\xdb\wsmconfigdb\%i
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\scripts\zune\Zune.MonitorSignin.cs ===
namespace Scripts {
   #region Using Directives
   using System;
   using System.Xml;
   using System.Net;
   using System.Collections.Specialized;
   using WSMonitor.Framework.Scripting;
   using WSMonitor.Framework.Reporting;

   using xonline.tools.lsmonitor.extensions.idcrl;
   using xonline.tools.lsmonitor.extensions.http;
   using xonline.tools.lsmonitor.extensions.xml;
   #endregion

   [ScriptMetadata("Test")]
   public class Zune_MonitorSignin : Script {
      private const string rpsSite = "kdc.test.xboxlive.com";
      private const int aaPort = 14100;
      private readonly string uacsSite = string.Format(
         "https://{0}:{1}/xuacs/useraccount.asmx/SignIn",
         HostEnvironment, aaPort);

      private XmlParser createParser(XmlDocument catalogResults) {
         NameValueCollection NamespaceTable;
         NamespaceTable = new NameValueCollection();
         NamespaceTable.Add("ns", "urn:schemas-xbox-com:user-account-data");
         return XmlParser.CreateInstance(catalogResults, NamespaceTable);
      }

      [Native.Start]
      public bool MonitorSignin() {
         return signinUser();
      }

      private bool signinUser() {
         XmlDocument Doc;
         XmlParser Parser;
         long HResult;

         Doc = (XmlDocument)Execute("Zune.UserSignin", 
            "DecidingSinger4@xboxtest.com", 
            "secret",
            rpsSite,
            uacsSite);

         Parser = createParser(Doc);

         HResult = Parser.ReadFirstEntry<long>("/ns:SignInResults/ns:ErrorInfo/ns:HResult");
         return (HResult & 0x80000000) == 0;
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\scripts\zune\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("scripts.zune")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("scripts.zune")]
[assembly: AssemblyCopyright("Copyright © Microsoft 2007")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("93ee02ed-1304-4032-a20c-17b8f126e4d6")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\scripts\zune\Zune.UserSignin.cs ===
namespace Scripts {
   #region Using Directives
   using System;
   using System.Xml;
   using System.Net;
   using System.Net.Security;
   using System.Collections.Specialized;
   using System.Security.Cryptography.X509Certificates;
   using WSMonitor.Framework.Scripting;
   using WSMonitor.Framework.Reporting;

   using xonline.tools.lsmonitor.extensions.idcrl;
   using xonline.tools.lsmonitor.extensions.http;
   using xonline.tools.lsmonitor.extensions.xml;
   #endregion

   [ScriptMetadata("General")]
   public class Zune_UserSignin : Script {
      private const string rpsPolicy = "mbi";

      [Native.Start]
      public XmlDocument UserSignin(string user, string password, string rpsSite, string uacsSite) {
         string SigninTicket;
         XmlDocument Results;

         Report.WriteProperty("User.Name", user);
         Report.WriteProperty("User.Password", password);

         SigninTicket = IdcrlHelper.GetRpsTicket(user, password, rpsSite, rpsPolicy);

         Report.WriteProperty("Signin.Ticket", SigninTicket);
         Results = getSigninXml(uacsSite, SigninTicket);
         Report.WriteProperty("Signin.XML", Results.DocumentElement.OuterXml);

         return Results;
      }

      private XmlDocument getSigninXml(string url, string ticket) {
         HttpWebResponse WebResponse;
         
         if (url.StartsWith("https:")) {
            ServicePointManager.ServerCertificateValidationCallback =
                new RemoteCertificateValidationCallback(validateCertificate);
         }

         WebResponse = HttpHelper.SendHttpRequest(
            url,
            delegate(HttpWebRequest r) {
               r.Method = "POST";
               r.ContentType = "application/x-www-form-urlencoded";
               r.ContentLength = 0;
               r.Headers.Add("Authorization", "WLID1.0 " + ticket);
            });

         return HttpHelper.ConsumeResponseAsXml(WebResponse);
      }

      public static bool validateCertificate(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors) {
         if ((sslPolicyErrors & SslPolicyErrors.RemoteCertificateChainErrors) == SslPolicyErrors.RemoteCertificateChainErrors)
            return false;
         else if ((sslPolicyErrors & SslPolicyErrors.RemoteCertificateNameMismatch) == SslPolicyErrors.RemoteCertificateNameMismatch)
            return false;

         return true;
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmFramework\Exceptions.cs ===
using System;
using System.Text;
using System.Runtime.Serialization;
using System.Security.Permissions;

namespace WSMonitor.Framework.Exceptions {
   //Exception class 
   [Serializable]
   public class WSMException : Exception {
      public WSMException() { }
      public WSMException(string message) : base(message) { }
      public WSMException(string message, Exception inner) : base(message, inner) { }
      public WSMException(SerializationInfo info, StreamingContext context) : base(info, context) { }
   }

   
   [global::System.Serializable]
   public class ScriptDisabledException : Exception {
      public ScriptDisabledException() { }
      public ScriptDisabledException(string alias) : this(alias, null) { }
      public ScriptDisabledException(string alias, Exception inner) 
         : base(string.Format("{0} script is disabled", alias), inner) 
      {
         this.alias = alias;
      }
      protected ScriptDisabledException(SerializationInfo info, StreamingContext context)
         : base(info, context) 
      {
         alias = info.GetString("__alias");
      }

      [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.SerializationFormatter)]
      public override void GetObjectData(SerializationInfo info, StreamingContext context)
      {
         base.GetObjectData(info, context);
         info.AddValue("__alias", alias);
      }

      public string Alias { get { return this.alias ?? ""; } }

      private string alias;
   }

   [Serializable]
   public class ScriptException : WSMException {

      public ScriptException(string message, long instance, Exception inner)
         : base(message, inner) {
         this.instance = instance;
      }
      public ScriptException(string message, Exception inner) : this(message, 0, inner) { }
      public ScriptException(string message) : this(message, 0, null) { }
      public ScriptException(string message, long instance) : this(message, instance, null) { }
      public ScriptException(Exception inner) : this(null, 0, inner) { }

      public ScriptException(long instance) : this(null, instance, null) { }
      public ScriptException(long instance, Exception inner) : this(null, instance, inner) { }
      public ScriptException() : this(null, 0, null) { }
      public ScriptException(SerializationInfo info, StreamingContext context) : base(info, context) { }

      public long Instance { 
         get { return instance; }
         set { instance = value; }
      }

      public override string Message {
         get {
            string message = string.IsNullOrEmpty(base.Message) ? "" : base.Message;
            return string.Format("Script instance identifier: {0}.\r\n{1}",
               (0 == instance) ? "(Unspecified)" : instance.ToString(),
               message);
         }
      }

      private long instance;
   }

   //Indicates logical failure of a service API call.
   [Serializable]
   public class LogicalServiceFailureException : WSMException {
      protected string service = "";
      protected string environment = "";

      public LogicalServiceFailureException() { }
      public LogicalServiceFailureException(string message) : base(message) { }
      public LogicalServiceFailureException(string message, string service, string environment)
         : base(message) {
         this.service = service;
         this.environment = environment;
      }
      public LogicalServiceFailureException(SerializationInfo info, StreamingContext context) : base(info, context) { }

      public string Service { get { return service; } set { service = value; } }
      public string Environment { get { return environment; } set { environment = value; } }
   }

   //Indicates logical failure of a script call.
   [Serializable]
   public class LogicalScriptFailureException : WSMException {
      protected string script = "";
      protected string environment = "";

      public LogicalScriptFailureException() { }
      public LogicalScriptFailureException(string message) : base(message) { }
      public LogicalScriptFailureException(string message, string script, string environment)
         : base(message) {
         this.script = script;
         this.environment = environment;
      }
      public LogicalScriptFailureException(SerializationInfo info, StreamingContext context) : base(info, context) { }

      public string Script { get { return script; } set { script = value; } }
      public string Environment { get { return environment; } set { environment = value; } }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmFramework\Reporting.ContextAttributes.cs ===
using System;
using System.Runtime.Remoting;
using System.Runtime.Remoting.Messaging;
using System.Runtime.Remoting.Activation;
using System.Runtime.Remoting.Proxies;
using System.Runtime.Remoting.Contexts;
using System.Security.Permissions;

namespace WSMonitor.Framework.Reporting {
   /// <summary>
   /// Context attribute used to decorate test scripts.
   /// </summary>
   public sealed class ReportingAspectsAttribute : Attribute, IContextAttribute {
      /// <summary>
      /// Initializes a new instance of the ReportingAspectsAttribute.
      /// </summary>
      public ReportingAspectsAttribute() { }

      #region IContextAttribute Implementation
      /// <summary>
      /// During activation of a context-bound-object dervied objects, the attributes that decorate 
      /// the class that implement the IContextAttribute have the ability to accept or deny the
      /// current context.  This method is invoked during the activation phase to determine
      /// if the current context is to be used.  If false is returned a new context is spun up
      /// and this attribute will be given a chance to inject its properties into the context.
      /// 
      /// Currently the active context will always be rejected.  In the near future I would like to
      /// partitional the app domain into 2*n + 1 contexts. Where n is the number of test scripts 
      /// started externally.  There will be no scripts running in the default context.  Each script
      /// will have at most 2 contexts associated with it.  Script are not allowed to directly
      /// access one another.  Instead, when a request to call the code of another script an instance
      /// of the containing class will be created and the execution method invoked.  In order for the
      /// aspect code to work, each call from script to script call must cross a context.
      /// Given the access pattern the execution graph will simply be a tree, since a tree can be colored 
      /// with 2 colors only 2 contexts are needed to represent all the scripts.
      /// </summary>
      /// <param name="current">
      /// Current context.  This context will be examined to determine whether or not it is suitable 
      /// for the object being activated.
      /// </param>
      /// <param name="ctor">
      /// The constructor message of the object being activated.  This message only contains 
      /// information pertinant to activation, nothing about the actual constructor parameters
      /// is accessible at this point.
      /// </param>
      /// <returns></returns>
      [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.Infrastructure)]
      public bool IsContextOK(Context current, IConstructionCallMessage ctor)
      {
         //GlobalInstanceProperty GlobalInstance;
         //AspectGroupProperty    AspectGroup;
         //Scripting.ScriptMetadataAttribute Metadata;

         ///Currently the active context will always be rejected.
         return false;

         #region Backup Deleted Acceptance logic
         /*
         GlobalInstance = GlobalInstanceProperty.GetProperty(current);
         
         if (null == GlobalInstance)
            return false;
         if (null != GlobalInstance)
            return false;

         if (null == ReportStackProperty.GetProperty(current))
            return false;

         AspectGroup = AspectGroupProperty.GetProperty(current);
         if (null == AspectGroup)
            return false;

         Metadata = Scripting.Script.GetMetadata(ctor.ActivationType);
         if (null == Metadata)
            return false;

         //Context matched
         bool Result;
         Result = Scripting.Script.Configuration.Aspects[Metadata.Type] == AspectGroup.AspectTypes;
         return Result;
         */
         #endregion
      }

      /// <summary>
      /// When IsContextOK rejects the current context this method will be invoked by the
      /// CLR.  Here the properties associated with this context attribute will be injected
      /// into the newly created context.
      /// </summary>
      /// <param name="ctor">
      /// The fully initialized constructor parameters.  This also includes activation
      /// information.
      /// </param>
      [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.Infrastructure)]
      public void GetPropertiesForNewContext(IConstructionCallMessage ctor)
      {
         AspectGroupProperty AspectGroup;
         IContextProperty[]  Properties = new IContextProperty[] {
            //Parameter 0 is the instance associated with the outter most test script
            new GlobalInstanceProperty((long)ctor.Args[0]),
            new ReportStackProperty(),
            //Parameter 1 is the array of types representing the aspects of the script.
            AspectGroup = new AspectGroupProperty((Type[])ctor.Args[1])
         };

         foreach (IContextProperty Property in Properties)
            ctor.ContextProperties.Add(Property);
      }
      #endregion
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmFramework\Reporting.ContextProperties.cs ===
using System;

using System.Collections.Generic;

using System.Runtime.Remoting;
using System.Runtime.Remoting.Messaging;
using System.Runtime.Remoting.Activation;
using System.Runtime.Remoting.Proxies;
using System.Runtime.Remoting.Contexts;

using System.Security.Permissions;

namespace WSMonitor.Framework.Reporting
{
    /// <summary>
    /// Represents the instance associated with the test that was executed first.
    /// </summary>
    public sealed class GlobalInstanceProperty : IContextProperty
    {
        /// <summary>
        /// Initializes a new instance of the GlobalInstanceProperty.
        /// </summary>
        /// <param name="instance">
        /// Instance associated with the outter most test script in the execution stack.
        /// </param>
        public GlobalInstanceProperty(long instance)
        {
            this.instance = instance;
        }

        #region IContextProperty Implementation
        /// <summary>
        /// Unique name associated with the context property.
        /// </summary>
        public string Name 
        {
            [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.Infrastructure)]
            get { return PropertyName; }
        }
        /// <summary>
        /// This property does not depend on other properties.  The conext will always
        /// be valid for this property.
        /// </summary>
        /// <param name="ctx">Context to test against.</param>
        /// <returns>Always returns true, indicating the property accepts the context.</returns>
        [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.Infrastructure)]
        public bool IsNewContextOK(Context ctx)
        {
            return true;
        }
        /// <summary>
        /// Called when the properties context is frozen.
        /// </summary>
        /// <param name="ctx">Context that was just frozen.</param>
        [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.Infrastructure)]
        public void Freeze(Context ctx) { }
        #endregion

        /// <summary>
        /// Instance associated with the test script that is at the root of the execution
        /// tree.
        /// </summary>
        public long Instance { get { return this.instance; } }
        /// <summary>
        /// Gets this GlobalInstanceProperty instance associated with the current calling context.
        /// </summary>
        /// <returns>Returns an instance of a GlobalInstanceProperty.</returns>
        public static GlobalInstanceProperty GetProperty()
        {
            return GetProperty(System.Threading.Thread.CurrentContext);
        }

        /// <summary>
        /// Gets this GlobalInstanceProperty instance associated with the specified calling context.
        /// </summary>
        /// <param name="context">The context to look in.</param>
        /// <returns>Returns an instance of a GlobalInstanceProperty.</returns>
        public static GlobalInstanceProperty GetProperty(Context context)
        {
            return context.GetProperty(PropertyName) as GlobalInstanceProperty;
        }

        /// <summary>
        /// Unique name associated with the GlobalInstanceProperty.
        /// </summary>
        public const string PropertyName = "GlobalInstance";
        private long instance;
    }

    /// <summary>
    /// Represents the partial stack associated with the current calling context.  The
    /// term 'Partial Stack' is used because roughly half of the stack is stored per context.
    /// Each contexts stack will only contain the report that where created by that context.
    /// </summary>
    public sealed class ReportStackProperty :
       IContextProperty,
       IContributeEnvoySink
    {
        /// <summary>
        /// Initializes a new instance of the ReportStackProperty.
        /// </summary>
        public ReportStackProperty()
        {
            this.stackLock = new object();
            this.stack = new Stack<Report>();
        }

        #region IContextProperty Implementation
        /// <summary>
        /// Unique name associated with the context property.
        /// </summary>
        public string Name
        {
            [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.Infrastructure)]
            get { return PropertyName; }
        }
        /// <summary>
        /// This property does not depend on other properties.  The conext will always
        /// be valid for this property.
        /// </summary>
        /// <param name="ctx">Context to test against.</param>
        /// <returns>Always returns true, indicating the property accepts the context.</returns>
        [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.Infrastructure)]
        public bool IsNewContextOK(Context ctx) { return true; }
        /// <summary>
        /// Called when the properties context is frozen.
        /// </summary>
        /// <param name="ctx">Context that was just frozen.</param>
        [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.Infrastructure)]
        public void Freeze(Context ctx) { }
        #endregion

        #region IContributeEnvoySink Implementation
        /// <summary>
        /// Attached the envoy sink to the calling chain.
        /// </summary>
        /// <param name="obj">Object the sink is scoped to.</param>
        /// <param name="nextSink">Next sink in the chain.</param>
        /// <returns></returns>
        [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.Infrastructure)]
        IMessageSink IContributeEnvoySink.GetEnvoySink(MarshalByRefObject obj, IMessageSink nextSink)
        {
            return new Sink(nextSink);
        }
        #endregion

        #region Stack Accessors
        public Report Top
        {
            get
            {
                EnvoyData envoy = CallContext.GetData(StackBase) as EnvoyData;
                envoy = envoy == null ? new EnvoyData(null) : envoy;
                lock (this.stackLock)
                {
                    return this.stack.Count > 0 ?
                       this.stack.Peek() :
                       envoy.Base;
                }
            }
        }

        public void Enter(Report report)
        {
            lock (this.stackLock)
            {
                this.stack.Push(report);
            }
        }

        public void Leave(Report report)
        {
            List<Report> reports = new List<Report>();

            lock (this.stackLock)
            {
                if (this.stack.Contains(report))
                {
                    Report current = null;
                    while (current != report)
                        reports.Add(current = this.stack.Pop());
                }
                else
                    reports.Add(report);
            }

            foreach (Report current in reports)
                current._Close(current != report);
        }

        public void Leave()
        {
            Report report;
            lock (this.stackLock)
            {
                report = this.stack.Pop();
            }
            report._Close(false);
        }
        #endregion

        /// <summary>
        /// Gets this ReportStackProperty instance associated with the current calling context.
        /// </summary>
        /// <returns>Returns an instance of a ReportStackProperty.</returns>
        public static ReportStackProperty GetProperty()
        {
            return GetProperty(System.Threading.Thread.CurrentContext);
        }
        /// <summary>
        /// Gets this ReportStackProperty instance associated with the specified calling context.
        /// </summary>
        /// <param name="context">The context to look in.</param>
        /// <returns>Returns an instance of a ReportStackProperty.</returns>
        public static ReportStackProperty GetProperty(Context context)
        {
            return context.GetProperty(PropertyName) as ReportStackProperty;
        }

        /// <summary>
        /// This simple class represents the data that is passed from the calling context to
        /// the server/object context.  The Top of the client stack acts as the base of 
        /// report stack for the object context.
        /// </summary>
        [Serializable]
        private class EnvoyData : ILogicalThreadAffinative
        {
            /// <summary>
            /// Initializes a new instance of EnvoyData
            /// </summary>
            /// <param name="base">
            /// Report base to send across the context channel to the ReportStack for 
            /// the server context.
            /// </param>
            public EnvoyData(Report @base)
            {
                this.@base = @base;
            }

            /// <summary>
            /// Report base to send across the context channel to the ReportStack for 
            /// the server context.
            /// </summary>
            public Report Base
            {
                get { return this.@base; }
            }

            private Report @base;
        }

        /// <summary>
        /// Envoy message sink associated with the ReportStack.  Unlike the other properties this
        /// property is dynamic and stateful.  This envoy sink is used to pass the top of the
        /// ReportSink stack from the client call context to the server call context.  This allows
        /// for the reports to be linked across the contexts.
        /// </summary>
        private class Sink : IMessageSink
        {
            /// <summary>
            /// Initializes a new instance of the Sink.
            /// </summary>
            /// <param name="next">Next message sink in the chain.</param>
            public Sink(IMessageSink nextSink)
            {
                this.nextSink = nextSink;
            }

            #region IMessageSink Implementation
            /// <summary>
            /// Retrieves the next message sink in the calling chain.  This is typically the object provided in the constructor.
            /// </summary>
            IMessageSink IMessageSink.NextSink
            {
                get { return this.nextSink; }
            }
            /// <summary>
            /// Performs synchronous pre and post-processing to a message call and reply chain.
            /// </summary>
            /// <param name="msg">The message to be pre-processed.</param>
            /// <returns>The post processed return message.</returns>
            IMessage IMessageSink.SyncProcessMessage(IMessage msg)
            {
                ReportStackProperty prop = GetProperty();
                IMethodCallMessage call = (IMethodCallMessage)msg;
                call.LogicalCallContext.SetData(StackBase, new EnvoyData(null == prop ? null : prop.Top));
                return AsyncReply(nextSink.SyncProcessMessage(msg));
            }
            /// <summary>
            /// Performs asynchronous post processing to a message in the calling chain.  This call also constructs
            /// the reply calling chain.
            /// </summary>
            /// <param name="msg">The message to be pre-processed.</param>
            /// <param name="replySink">The next handler in the reply chain.</param>
            /// <returns>The controller for the async call.</returns>
            IMessageCtrl IMessageSink.AsyncProcessMessage(IMessage msg, IMessageSink replySink)
            {
                ReportStackProperty prop = GetProperty();
                IMethodCallMessage call = (IMethodCallMessage)msg;
                call.LogicalCallContext.SetData(StackBase, new EnvoyData(null == prop ? null : prop.Top));
                replySink = new AsyncAspectReply(replySink, new AsyncAspectReply.AsyncDelegate(AsyncReply));
                return nextSink.AsyncProcessMessage(msg, replySink);
            }
            /// <summary>
            /// The handler for the async post-processing.  This method is invoked via a delegate in
            /// an AsyncAspectReply instance injected into the reply chain of the method call.
            /// </summary>
            /// <param name="msg">The return message to be post-processed.</param>
            /// <returns>Returns the post processed message.  The original is usually passed right through.</returns>
            private IMessage AsyncReply(IMessage msg)
            {
                IMethodReturnMessage ret = (IMethodReturnMessage)msg;
                ret.LogicalCallContext.FreeNamedDataSlot(StackBase);
                return msg;
            }
            #endregion

            private IMessageSink nextSink;
        }

        /// <summary>
        /// Unique name associated with the ReportStackProperty.
        /// </summary>
        public const string PropertyName = "ReportStack";

        private object stackLock;
        private Stack<Report> stack;

        private const string StackBase = "Report.Base";
    }

    /// <summary>
    /// Context property associated with aspect group.  This property contributes sinks to the
    /// object message chain.
    /// </summary>
    public sealed class AspectGroupProperty :
       IContextProperty,
       IContributeObjectSink
    {
        /// <summary>
        /// Initializes a new instance of the AspectGroupProperty.
        /// </summary>
        /// <param name="aspectTypes">
        /// Array of types that conform inherit from the Aspect base class.  Each of
        /// these types also need to include a constructor that accepts a single IMessageSink
        /// parameter.
        /// </param>
        public AspectGroupProperty(Type[] aspectTypes)
        {
            this.aspectTypes = aspectTypes;
        }

        #region IContextProperty Implementation
        /// <summary>
        /// Unique name associated with the context property.
        /// </summary>
        public string Name
        {
            [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.Infrastructure)]
            get { return PropertyName; }
        }
        /// <summary>
        /// This property does not depend on other properties.  The conext will always
        /// be valid for this property.
        /// </summary>
        /// <param name="ctx">Context to test against.</param>
        /// <returns>Always returns true, indicating the property accepts the context.</returns>
        [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.Infrastructure)]
        public bool IsNewContextOK(Context ctx) { return true; }
        /// <summary>
        /// Called when the properties context is frozen.
        /// </summary>
        /// <param name="ctx">Context that was just frozen.</param>
        [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.Infrastructure)]
        public void Freeze(Context ctx) { }
        #endregion

        /// <summary>
        /// Create the aspect message sink chain.  This chain is attached to the object
        /// message chain.
        /// </summary>
        /// <param name="nextSink">Next sink in the object message chain.</param>
        /// <returns>Return the new first sink in the chain.</returns>
        /// <exception cref="InvalidContextException">Thrown when one of the types is not a valid Aspect type.</exception>
        IMessageSink BuildSinks(IMessageSink nextSink)
        {
            IMessageSink Sink = nextSink;

            foreach (Type Current in aspectTypes)
            {
                if (!Aspect.IsValidAspectType(Current))
                    throw new InvalidContextException("Framework_AspectGroupProperty_TypeInvalid " + Current.Name);
                else
                    Sink = Aspect.Create(Current, Sink);
            }

            return Sink;
        }

        #region IContributeObjectSink Implementation
        /// <summary>
        /// Contributes message sinks to the object channel of the calling chain.
        /// </summary>
        /// <param name="obj">Object associated with the message chain.</param>
        /// <param name="nextSink">Next sink in the message chain, this sink will be executed after ours.</param>
        /// <returns>Returns the new first sink in the chain.</returns>
        [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.Infrastructure)]
        public IMessageSink GetObjectSink(MarshalByRefObject obj, IMessageSink nextSink)
        {
            return BuildSinks(nextSink);
        }
        #endregion

        /// <summary>
        /// Retrieves the array of aspects associated with the target object.
        /// </summary>
        public Type[] AspectTypes
        {
            get { return this.aspectTypes; }
        }
        /// <summary>
        /// Gets this AspectGroupProperty instance associated with the current calling context.
        /// </summary>
        /// <returns>Returns an instance of a AspectGroupProperty.</returns>
        public static AspectGroupProperty GetProperty()
        {
            return GetProperty(System.Threading.Thread.CurrentContext);
        }
        /// <summary>
        /// Gets this AspectGroupProperty instance associated with the specified calling context.
        /// </summary>
        /// <param name="context">The context to look in.</param>
        /// <returns>Returns an instance of a AspectGroupProperty.</returns>
        public static AspectGroupProperty GetProperty(Context context)
        {
            return context.GetProperty(PropertyName) as AspectGroupProperty;
        }
        /// <summary>
        /// Unique name associated with the AspectGroupProperty.
        /// </summary>
        public const string PropertyName = "AspectGroup";

        private Type[] aspectTypes;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmFramework\Reporting.Aspect.cs ===
using System;

using System.Threading;
using System.Collections;
using System.Reflection;

using System.Runtime.Remoting;
using System.Runtime.Remoting.Messaging;
using System.Runtime.Remoting.Activation;
using System.Runtime.Remoting.Proxies;
using System.Runtime.Remoting.Contexts;

using System.Security.Permissions;

namespace WSMonitor.Framework.Reporting
{
    /// <summary>
    /// Acts as the message sink used for rebuilding the reply chain
    /// for processing async messages.  This class is only to be used
    /// in a reply chain.
    /// </summary>
    internal sealed class AsyncAspectReply : IMessageSink
    {
        /// <summary>
        /// Async processing is done creating a delagate to a method in the orginal
        /// message sink.  This is the delagate that points to the reply message 
        /// handler of the original message sink.
        /// </summary>
        /// <param name="msg">The return message to be post-processed.</param>
        /// <returns>Returns the post processed message.  The original is usually passed right through.</returns>
        public delegate IMessage AsyncDelegate(IMessage msg);

        /// <summary>
        /// Initializes a new instance of the AsyncAspectReply.
        /// </summary>
        /// <param name="next">Next message sink in the chain.</param>
        /// <param name="delegate">Delegate to async message post-processor</param>
        /// <exception cref="ArgumentNullException">Thrown if delegate is null.</exception>
        public AsyncAspectReply(IMessageSink next, AsyncDelegate @delegate)
        {
            this.next = next;
            this.@delegate = @delegate;

            if (null == @delegate)
                throw new ArgumentNullException("@delegate", "Framework_AsyncAspectReply_NullDelegate");
        }

        #region IMessageSink Implementation
        /// <summary>
        /// Retrieves the next message sink in the reply chain.  This is typically the object provided in the constructor.
        /// </summary>
        public IMessageSink NextSink { get { return this.next; } }

        /// <summary>
        /// This is invoked during the reply message chain.  The reply chain for an Async call is processed
        /// synchronously, therefore this method will be invoked during this stage in message handling.
        /// </summary>
        /// <param name="msg">The return message to be post-processed.</param>
        /// <returns>Returns the post processed message.  The original is usually passed right through.</returns>
        public IMessage SyncProcessMessage(IMessage msg)
        {
            return next.SyncProcessMessage(@delegate(msg));
        }

        /// <summary>
        /// This method should never be invoked.  The reply chain for an Async message is synchronous.  The only
        /// way for this to be invoked is if it were attached to an async call chain.  The class is not to be
        /// used in a calling chain.
        /// </summary>
        /// <param name="msg">Not applicable.</param>
        /// <param name="replySink">Not applicable.</param>
        /// <returns>Not applicable.</returns>
        /// <exception cref="InvalidOperationException">Thrown if this method is invoked.</exception>
        public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink)
        {
            throw new InvalidOperationException("Framework_AsyncAspectReply_InvalidAsyncCall");
        }
        #endregion

        private IMessageSink next;
        private AsyncDelegate @delegate;
    }

    /// <summary>
    /// Acts as the message sink used by aspects.  Aspects need to inherit from this class, this class
    /// acts as a base to weed out some of the logic that might be common between all aspects.  Many
    /// aspects need to deal with reports this Aspect handles the logic of grabbing the report of the
    /// current context.
    /// </summary>
    public class Aspect : IMessageSink
    {
        /// <summary>
        /// Initializes a new instance of the Aspect.
        /// </summary>
        /// <param name="next">Next message sink in the chain.</param>
        public Aspect(IMessageSink next)
        {
            this.next = next;
        }

        #region IMessageSink Implementation
        /// <summary>
        /// Retrieves the next message sink in the calling chain.  This is typically the object provided in the constructor.
        /// </summary>
        IMessageSink IMessageSink.NextSink
        {
            [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.Infrastructure)]
            get { return next; }
        }
        /// <summary>
        /// Performs asynchronous post processing to a message in the calling chain.  This call also constructs
        /// the reply calling chain.
        /// </summary>
        /// <param name="msg">The message to be pre-processed.</param>
        /// <param name="replySink">The next handler in the reply chain.</param>
        /// <returns>The controller for the async call.</returns>
        [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.Infrastructure)]
        IMessageCtrl IMessageSink.AsyncProcessMessage(IMessage msg, IMessageSink replySink)
        {
            IMethodMessage method = (IMethodCallMessage)msg;
            IConstructionCallMessage ctor = (IConstructionCallMessage)msg;

            if (null == ctor)
            {
                replySink = new AsyncAspectReply(replySink, new AsyncAspectReply.AsyncDelegate(AsyncReply));

                try
                {
                    Enter(ReportStack.Top, method);
                }
                catch (ThreadAbortException abort)
                {
                    ReturnMessage message = new ReturnMessage(abort, msg as IMethodCallMessage);
                    AsyncReply(message);
                    //Thread Abort Exception will be raised by the callee as well no since in figuring
                    //out what should really be returned.
                    return null;
                }
            }

            return next.AsyncProcessMessage(msg, replySink);
        }
        /// <summary>
        /// Performs synchronous pre and post-processing to a message call and reply chain.
        /// </summary>
        /// <param name="msg">The message to be pre-processed.</param>
        /// <returns>The post processed return message.</returns>
        [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.Infrastructure)]
        IMessage IMessageSink.SyncProcessMessage(IMessage msg)
        {
            IMethodMessage method = (IMethodMessage)msg;
            IConstructionCallMessage ctor = msg as IConstructionCallMessage;
            IMethodReturnMessage resp;

            ///Aspect Enter:Leave calls are not invoked during the constructor calls.
            if (null == ctor)
            {
                resp = null;

                try
                {
                    Enter(ReportStack.Top, method);
                    resp = (IMethodReturnMessage)next.SyncProcessMessage(msg);
                }
                catch (ThreadAbortException abort)
                {
                    resp = new ReturnMessage(abort, msg as IMethodCallMessage);
                }
                finally
                {
                    if (null != resp)
                        Leave(ReportStack.Top, resp);
                }
            }
            else
            {
                resp = (IMethodReturnMessage)next.SyncProcessMessage(msg);
            }

            return resp;
        }

        /// <summary>
        /// The handler for the async post-processing.  This method is invoked via a delegate in
        /// an AsyncAspectReply instance injected into the reply chain of the method call.
        /// </summary>
        /// <param name="msg">The return message to be post-processed.</param>
        /// <returns>Returns the post processed message.  The original is usually passed right through.</returns>
        private IMessage AsyncReply(IMessage msg)
        {
            Leave(ReportStack.Top, (IMethodReturnMessage)msg);
            return msg;
        }
        #endregion

        /// <summary>
        /// Invoked to pre-process the message.  This should be overriden by the subclass to handle
        /// pre-processing in the calling chain.
        /// </summary>
        /// <param name="report">Not applicable.</param>
        /// <param name="msg">Not applicable.</param>
        public virtual void Enter(Report report, IMethodMessage msg) { }

        /// <summary>
        /// Invoked to post-process the return message.  This should be overriden by the subclass to 
        /// handle post-processing in the return chain.
        /// </summary>
        /// <param name="report"></param>
        /// <param name="result"></param>
        public virtual void Leave(Report report, IMethodReturnMessage result) { }

        /// <summary>
        /// Checks to see if the given type is a valid Aspect group subclasss.
        /// </summary>
        /// <param name="t">The type of interest.</param>
        /// <returns>True/false indicating valid/invalid.</returns>
        public static bool IsValidAspectType(Type t)
        {
            Type Aspect = typeof(Aspect);

            if (!Aspect.IsAssignableFrom(t))
                return false;

            return null != t.GetConstructor(new Type[] { typeof(IMessageSink) });
        }

        /// <summary>
        /// Static method used to create a new aspect by type.
        /// </summary>
        /// <param name="t"></param>
        /// <param name="next"></param>
        /// <returns></returns>
        public static Aspect Create(Type t, IMessageSink next)
        {
            return (Aspect)Activator.CreateInstance(t, new object[] { next });
        }

        #region Context Property Accessors
        /// <summary>
        /// Fetches the report stack associated with the current calling context.
        /// </summary>
        protected ReportStackProperty ReportStack
        {
            get { return ReportStackProperty.GetProperty(Thread.CurrentContext); }
        }

        /// <summary>
        /// Fetches the global instance associated with the current calling context.
        /// </summary>
        protected GlobalInstanceProperty GlobalInstance
        {
            get { return GlobalInstanceProperty.GetProperty(Thread.CurrentContext); }
        }
        #endregion

        private IMessageSink next;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmFramework\Reporting.Helpers.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.Remoting;
using System.Runtime.Remoting.Messaging;
using System.Security.Permissions;
using System.Xml;
using System.Xml.XPath;
using System.Xml.Serialization;
using System.IO;
using System.Runtime.Serialization;

using WSMonitor.Framework;
using WSMonitor.Framework.Exceptions;

using KeyCollection = System.Collections.Generic.Dictionary<string, object>.KeyCollection;
using ValueCollection = System.Collections.Generic.Dictionary<string, object>.ValueCollection;

namespace WSMonitor.Framework.Reporting {
   /// <summary>
   /// Report categories.
   /// </summary>
   public enum ReportCategory : int {
      Message        = 0x00000001,
      Container      = 0x00000002,
      ExecutionTrace = 0x00000004,
      FlagMask       = 0x0000FFFF,

      //Messages
      VerboseMessage   = 0x00010000 | Message,
      WarningMessage   = 0x00020000 | Message,
      ErrorMessage     = 0x00030000 | Message,
      ExceptionMessage = 0x00040000 | Message,
      
      //Pure Execution Trace Elements
      ServiceApi       = 0x00100000 | ExecutionTrace | Container,

      //Script Categories
      GeneralScript    = 0x00200000 | ExecutionTrace | Message | Container,
      TestScript       = 0x00210000 | ExecutionTrace | Message | Container,
      ScriptMember     = 0x00220000 | ExecutionTrace | Message | Container,
   }

   /// <summary>
   /// Category of the result.
   /// </summary>
   public enum ResultCode : int {
      Undefined = 0x00000000,
      Finished  = 0x00000001,
      Exception = 0x00000002,
      Cancel    = 0x00000004,
      Success   = 0x00010000 | Finished,
      Failed    = 0x00020000 | Finished
   }

   /// <summary>
   /// Exposes an interface for message reports.
   /// </summary>
   public interface ITextCategory {
      /// <summary>
      /// Text associated with message
      /// </summary>
      string Text { get; set; }
   }

   /// <summary>
   /// Exposes an interface for execution reports.
   /// </summary>
   public interface IExecutionCategory {
      /// <summary>Name assocated with execution object.</summary>
      string     Name { get; set; }
      /// <summary>Start time of the start.</summary>
      DateTime   ExecutionStart { get; set; }
      /// <summary>Time spent executing the code.</summary>
      long       ExecutionDuration { get; set; }
      /// <summary>Result code associated with the execution of the code.</summary>
      ResultCode ExecutionResult { get; set; }
   }

   /// <summary>
   /// Exposes named properties of a report as properties.
   /// </summary>
   public class MessageReportProxy : ReportProxy, ITextCategory {
      /// <summary>
      /// Initializes a new instance of the MessageReportProxy.
      /// </summary>
      /// <param name="report">Target report.</param>
      public MessageReportProxy(Report report) : base(report) { }

      /// <summary>Text property.</summary>
      public string Text {
         get { return (string)GetValue(KeyText, null); }
         set { SetValue(KeyText, value); }
      }

      /// <summary>
      /// Key associated with text property.
      /// </summary>
      public const string KeyText = "Text";
   }

   /// <summary>
   /// Exposes named properties of a report as properties.
   /// </summary>
   public class ExecutionReportProxy : ReportProxy, IExecutionCategory {
      /// <summary>
      /// Initializes a new instance of the ExecutionReportProxy.
      /// </summary>
      /// <param name="report">Target report.</param>
      public ExecutionReportProxy(Report report) : base(report) { }

      /// <summary>Name assocated with execution object.</summary>
      public string Name {
         get { return (string)GetValue(KeyName, null); }
         set { SetValue(KeyName, value); }
      }
      /// <summary>Start time of the start.</summary>
      public DateTime ExecutionStart {
         get { return (DateTime)GetValue(KeyExecutionStart, DateTime.MinValue); }
         set { SetValue(KeyExecutionStart, value); }
      }
      /// <summary>Ticks spent executing the code.</summary>
      public long ExecutionDuration {
         get { return (long)GetValue(KeyExecutionDuration, TimeSpan.MinValue); }
         set { SetValue(KeyExecutionDuration, value); }
      }
      /// <summary>Result code associated with the execution of the code.</summary>
      public ResultCode ExecutionResult {
         get { return (ResultCode)GetValue(KeyExecutionResult, ResultCode.Undefined); }
         set { SetValue(KeyExecutionResult, value); }
      }

      /// <summary>Key associated with name property.</summary>
      public const string KeyName              = "ExecutionName";
      /// <summary>Key associated with the execution start property.</summary>
      public const string KeyExecutionStart    = "ExecutionStart";
      /// <summary>Key associated with the execution duration property.</summary>
      public const string KeyExecutionDuration = "ExecutionDuration";
      /// <summary>Key associated with result of the cod eexecution.</summary>
      public const string KeyExecutionResult   = "ExecutionResult";
   }

   /// <summary>
   /// Exeception dedicated to complaining about the state of the context.  Generally, this
   /// exeception is thrown if an expectation on the state of the execution context is
   /// not met.
   /// </summary>
   [Serializable]
   public sealed class InvalidContextException : WSMException {
      public InvalidContextException() : this("", null) { }
      public InvalidContextException(string message) : this(message, null) { }
      public InvalidContextException(string message, Exception inner) : base(message, inner) { }
      public InvalidContextException(SerializationInfo info, StreamingContext context) : base(info, context) { }
   }

   /// <summary>
   /// Exception dedicated to complaining about the state of the report.  Generally, this
   /// exeception is thrown when the report contains invalid data, or if corruption in
   /// the report stack is detected.
   /// </summary>
   [Serializable]
   public sealed class InvalidReportException : WSMException {
      public InvalidReportException() : this("", null) { }
      public InvalidReportException(string message) : this(message, null) { }
      public InvalidReportException(string message, Exception inner) : base(message, inner) { }
      public InvalidReportException(SerializationInfo info, StreamingContext context) : base(info, context) { }
   }

   // See Reporting.Report.cs for details on this Report.
   public partial class Report {
      /// <summary>
      /// The ReportFactory class is dedicated to converting Report objects to Xml and vice-versa.  This class
      /// has no instance methods.
      /// </summary>
      public sealed class ReportFactory {
         private ReportFactory() { }

         /// <summary>
         /// Cache XmlSerializers.
         /// </summary>
         private static Dictionary<Type, XmlSerializer> serializerCache = new Dictionary<Type, XmlSerializer>();

         /// <summary>
         /// Creates an xml element from a given key value pair.  The return XmlElement will have nested in it
         /// the XmlSerialized value.
         /// </summary>
         /// <param name="key">Property key.</param>
         /// <param name="value">Property value.</param>
         /// <param name="doc">Target xml document.</param>
         /// <returns>Returns thew newly created XmlElement.</returns>
         private static XmlElement CreatePropertyNode(string key, object value, XmlDocument doc) {
            Type t = value.GetType();
            XmlElement Element;
            XmlAttribute Attrib;
            XmlSerializer Ser;

            Element = doc.CreateElement("property");
            Attrib = doc.CreateAttribute("key");
            Attrib.Value = key;
            Element.Attributes.Append(Attrib);
            Attrib = doc.CreateAttribute("type");
            Attrib.Value = t.Assembly.GetName().Name == "mscorlib" ? t.FullName : t.AssemblyQualifiedName;
            Element.Attributes.Append(Attrib);

            ///Add the serializer to the cache if it does not exist.
            if (!serializerCache.ContainsKey(t))
               serializerCache[t] = new XmlSerializer(t);

            Ser = serializerCache[t];

            ///Xml Serialize the value and add to the property element.
            using (StringWriter swr = new StringWriter()) {
               using (XmlTextWriter xwr = new XmlTextWriter(swr)) {
                  Ser.Serialize(xwr, value);
               }
               using (StringReader srd = new StringReader(swr.ToString())) {
                  using (XmlTextReader xrd = new XmlTextReader(srd)) {
                     XmlNode Node;
                     ///first read is the <?xml /> node
                     Node = doc.ReadNode(xrd);
                     Node = doc.ReadNode(xrd);
                     Element.AppendChild(Node);
                  }
               }
            }

            return Element;
         }

         /// <summary>
         /// Creates a key value pair from an xpath navigator that is currently on a property element.
         /// The value is attained by xml deserializing the inner xml of the property element.
         /// </summary>
         /// <param name="nav">A navigator that is currently on a property element.</param>
         /// <param name="key">The key value is written to this output parameter.</param>
         /// <returns>Return the value of the deserialized body.</returns>
         private static object GetPropertyValue(XPathNavigator nav, out string key) {
            Type t;
            XmlSerializer Ser;

            key = nav.GetAttribute("key", "");
            if (null == key)
               throw new Exception("Framework_ReportFactory_InvalidXmlAttrib key");

            try { t = Type.GetType(nav.GetAttribute("type", ""), true); }
            catch (Exception e) {
               throw new Exception("Framework_ReportFactory_InvalidXmlAttrib type", e);
            }

            if (!serializerCache.ContainsKey(t))
               serializerCache[t] = new XmlSerializer(t);

            Ser = serializerCache[t];

            ///Deserialize the inner xml of the element.
            using (StringReader rdr = new StringReader(nav.InnerXml)) {
               try { return Ser.Deserialize(rdr); }
               catch (Exception e) {
                  throw new Exception("Framework_ReportFactory_SerializationError", e);
               }
            }
         }

         /// <summary>
         /// Creates a new report from an xpath navigator.  This navigator must be currently on
         /// a report element.
         /// </summary>
         /// <param name="nav">Navigator currently located on a report element.</param>
         /// <param name="lookupTable">Lookup table used to identify</param>
         /// <returns>Newly constructed report.</returns>
         public static Report CreateReport(XPathNavigator nav, Dictionary<Guid, Report> lookupTable) {
            Report         Result;
            Report         Parent;
            Nullable<Guid> ParentGuid;
            ReportCategory Category;
            Guid           Guid;
            long           Instance;
            string         Attrib;

            //Read category attribute
            Attrib = nav.GetAttribute("category", "");
            try { Category = (ReportCategory)Enum.Parse(typeof(ReportCategory), Attrib); }
            catch (Exception e) { throw new Exception("Framework_ReportFactory_InvalidXmlAttrib category", e); }
            //Read guid attribute
            Attrib = nav.GetAttribute("guid", "");
            try { Guid = new Guid(Attrib); }
            catch (Exception e) { throw new Exception("Framework_ReportFactory_InvalidXmlAttrib guid", e); }
            //Read instance attribute
            Attrib = nav.GetAttribute("instance", "");
            try { Instance = long.Parse(Attrib); }
            catch (Exception e) { throw new Exception("Framework_ReportFactory_InvalidXmlAttrib instance", e); }
            //Read parent attribute
            Attrib = nav.GetAttribute("parent", "");
            if (string.IsNullOrEmpty(Attrib))
               ParentGuid = null;
            else {
               try { ParentGuid = new Guid(Attrib); }
               catch (Exception e) { throw new Exception("Framework_ReportFactory_InvalidXmlAttrib parent", e); }
            }

            //Make sure the guid is unique (no dups no loops).
            if (lookupTable.ContainsKey(Guid))
               throw new Exception("Framework_ReportFactory_DuplicateGuid " + Guid.ToString());

            //Look up the parent object if the guid is given.
            Parent = null;
            if (ParentGuid.HasValue) {
               if (lookupTable.ContainsKey(ParentGuid.Value))
                  Parent = lookupTable[ParentGuid.Value];

               if (null == Parent)
                  throw new Exception("Framework_ReportFactory_MissingParent " + ParentGuid.Value.ToString());
            }

            Result = new Report(Category, Parent, Guid);
            Result.instance = Instance;
            lookupTable[Guid] = Result;

            XPathNodeIterator Itor;

            //Read the full property bag.
            Itor = nav.Select("properties/property");
            while (Itor.MoveNext()) {
               string key;
               object value;
               value = GetPropertyValue(Itor.Current, out key);
               Result.Properties[key] = value;
            }

            //Create the child nodes.
            Itor = nav.Select("children/report");
            while (Itor.MoveNext())
               CreateReport(Itor.Current, lookupTable);

            return Result;
         }

         /// <summary>
         /// Creates an Xml element from the given report.  This method is invoked recursively to capture the
         /// child Reports as well.
         /// </summary>
         /// <param name="report">Target report.  The xml element will reflect the data present in this Report.</param>
         /// <param name="doc">Target document.  The xml element will be compatible with this doc.</param>
         /// <returns>Returns the newly created XmlElement representation of this Report.</returns>
         public static XmlElement CreateElement(Report report, XmlDocument doc) {
            XmlElement Root, Parent, Element;
            XmlAttribute Attrib;

            ///Element root
            Root = doc.CreateElement("report");
            
            ///Properties group
            Parent = doc.CreateElement("properties");
            Root.AppendChild(Parent);
            foreach (string key in report.Properties.Keys) {
               if (null != report.Properties[key]) {
                  Element = CreatePropertyNode(key, report.Properties[key], doc);
                  Parent.AppendChild(Element);
               }
            }

            ///Children group
            if (null != report.Children) {
               Parent = doc.CreateElement("children");
               foreach (Report target in report.Children)
                  Parent.AppendChild(CreateElement(target, doc));
               Root.AppendChild(Parent);
            }

            ///Root attributes
            (Attrib = doc.CreateAttribute("category")).Value = report.Category.ToString();
            Root.Attributes.Append(Attrib);
            (Attrib = doc.CreateAttribute("guid")).Value = report.Guid.ToString();
            Root.Attributes.Append(Attrib);
            (Attrib = doc.CreateAttribute("instance")).Value = report.Instance.ToString();
            Root.Attributes.Append(Attrib);
            if (null != report.Parent) {
               (Attrib = doc.CreateAttribute("parent")).Value = report.Parent.Guid.ToString();
               Root.Attributes.Append(Attrib);
            }

            return Root;
         }

         /// <summary>
         /// Creates an XmlDocument from the Report.
         /// </summary>
         /// <param name="report">This is the target report.</param>
         /// <returns>Returns the newly generated XmlDocument.</returns>
         public static XmlDocument CreateDocument(Report report) {
            if (null == report)
               throw new ArgumentNullException("report");

            XmlDocument Doc;
            Doc = new XmlDocument();
            Doc.AppendChild(CreateElement(report, Doc));

            return Doc;
         }

         /// <summary>
         /// Creates a Report from the XmlDocument.
         /// </summary>
         /// <param name="doc">This is the target XmlDocument.</param>
         /// <returns>Returns the newly created Report.</returns>
         public static Report CreateReport(XmlDocument doc) {
            Dictionary<Guid, Report> Lookup = new Dictionary<Guid, Report>();
            XPathNavigator nav = doc.CreateNavigator();
            return CreateReport(nav.SelectSingleNode("/report"), Lookup);
         }

         /// <summary>
         /// Creates a Report from the SqlXml.
         /// </summary>
         /// <param name="xml">This is the target SqlXml.</param>
         /// <returns>Returns the newly created Report.</returns>
         public static Report CreateReport(System.Data.SqlTypes.SqlXml xml) {
            if (null != xml) {
               XmlDocument Doc = new XmlDocument();
               Doc.Load(xml.CreateReader());
               return CreateReport(Doc);
            }

            return null;
         }
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\wsmonitor\wsmFramework\Reporting.Report.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.Remoting;
using System.Runtime.Remoting.Messaging;
using System.Reflection;
using System.Security.Permissions;
using System.Xml;
using Sy